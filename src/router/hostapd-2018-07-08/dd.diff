diff -urpN hostapd-2016-10-15/.cflags hostapd-2016-09-05.dd/.cflags
diff -urpN hostapd-2016-10-15/.dep_files hostapd-2016-09-05.dd/.dep_files
diff -urpN hostapd-2016-10-15/.gitignore hostapd-2016-09-05.dd/.gitignore
diff -urpN hostapd-2016-10-15/hostapd/.config hostapd-2016-09-05.dd/hostapd/.config
--- hostapd-2016-10-15/hostapd/.config	1970-01-01 01:00:00.000000000 +0100
+++ hostapd-2016-09-05.dd/hostapd/.config	2017-10-18 23:36:47.000000000 +0200
@@ -0,0 +1,144 @@
+# Example hostapd build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cass, these lines should use += in order not
+# to override previous values of the variables.
+
+# Driver interface for Host AP driver
+#CONFIG_DRIVER_HOSTAP=y
+
+-include ../../.config
+
+# Driver interface for wired authenticator
+#CONFIG_DRIVER_WIRED=y
+
+# Driver interface for madwifi driver
+CONFIG_DRIVER_MADWIFI=y
+ifeq ($(CONFIG_HOTSPOT20),y)
+CONFIG_HS20=y
+endif
+ifeq ($(CONFIG_ATH9K),y)
+CONFIG_IEEE80211N=y
+CONFIG_DRIVER_NL80211=y
+NEED_AP_MLME=y
+endif
+ifeq ($(CONFIG_ATH10K),y)
+CONFIG_IEEE80211AC=y
+endif
+CFLAGS +=-I$(TOP)/madwifi.dev/madwifi.dev
+
+
+
+#CFLAGS += -I../head # change to reflect local setup; directory for madwifi src
+
+# Driver interface for Prism54 driver
+#CONFIG_DRIVER_PRISM54=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+
+
+ifeq ($(CONFIG_NOMESSAGE),y)
+CONFIG_NO_STDOUT_DEBUG=y
+CONFIG_NO_HOSTAPD_LOGGER=y
+CONFIG_NO_WPS_MSG=y
+CONFIG_NO_WPA_MSG=y
+else
+CFLAGS+= -DNEED_PRINTF
+CONFIG_DEBUG_SYSLOG=y
+# Set syslog facility for debug messages
+CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
+endif
+#
+# IEEE 802.11F/IAPP
+
+# WPA2/IEEE 802.11i RSN pre-authentication
+CONFIG_RSN_PREAUTH=y
+ifeq ($(CONFIG_WPS),y)
+LDFLAGS += -L$(TOP)/libutils -L$(TOP)/nvram -lshutils -lutils -lqos -lnvram
+CONFIG_WPS=y
+#CONFIG_WPS2=y
+CONFIG_WPS_UPNP=y
+endif
+ifeq ($(CONFIG_AOSS),y)
+CFLAGS += -DHAVE_AOSS
+endif
+
+#ifneq ($(CONFIG_WPS),y)
+#ifneq ($(CONFIG_AOSS),y)
+#CONFIG_NO_CTRL_IFACE=y
+#endif
+#endif
+
+
+CONFIG_INTERNAL_LIBTOMMATH=y
+CONFIG_INTERNAL_AES=y
+CONFIG_TLS=internal
+
+ifneq ($(CONFIG_WRT300NV2),y)
+ifneq ($(CONFIG_DIST),"micro")
+CFLAGS += -DHAVE_AQOS 
+LDFLAGS += -L$(TOP)/libutils -L$(TOP)/nvram -lshutils -lutils -lqos -lnvram
+
+#CFLAGS += -DNEED_PRINTF
+NEED_AES_DEC=y
+
+CONFIG_IAPP=y
+# Integrated EAP authenticator
+CONFIG_EAP=y
+
+# CONFIG_FULL_DYNAMIC_VLAN=y
+
+# EAP-MD5 for the integrated EAP authenticator
+CONFIG_EAP_MD5=y
+
+# EAP-TLS for the integrated EAP authenticator
+CONFIG_EAP_TLS=y
+CONFIG_TLSV11=y
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
+# can be enabled to enable use of stronger crypto algorithms.
+CONFIG_TLSV12=y
+
+# EAP-MSCHAPv2 for the integrated EAP authenticator
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-PEAP for the integrated EAP authenticator
+CONFIG_EAP_PEAP=y
+
+# EAP-PSK for the integrated EAP authenticator
+CONFIG_EAP_PSK=y
+
+# EAP-GTC for the integrated EAP authenticator
+CONFIG_EAP_GTC=y
+
+# EAP-TTLS for the integrated EAP authenticator
+CONFIG_EAP_TTLS=y
+
+# EAP-SIM for the integrated EAP authenticator
+#CONFIG_EAP_SIM=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+#CONFIG_PKCS12=y
+
+# RADIUS authentication server. This provides access to the integrated EAP
+# authenticator from external hosts using RADIUS.
+#CONFIG_RADIUS_SERVER=y
+CONFIG_NO_DUMP_STATE=y
+CONFIG_EAP_FAST=y
+else
+CONFIG_NO_RADIUS=y
+CONFIG_NO_ACCOUNTING=y
+endif
+endif
+NEED_80211_COMMON=y
+CONFIG_NO_VLAN=y
+CONFIG_NO_RANDOM_POOL=y
+CONFIG_NO_DUMP_STATE=y
diff -urpN hostapd-2016-10-15/hostapd/Makefile hostapd-2016-09-05.dd/hostapd/Makefile
--- hostapd-2016-10-15/hostapd/Makefile	2017-10-19 00:05:11.543747547 +0200
+++ hostapd-2016-09-05.dd/hostapd/Makefile	2017-09-01 12:25:50.000000000 +0200
@@ -1,10 +1,9 @@
-ifndef CC
-CC=gcc
-endif
+CFLAGS+ = -MMD $(MIPS16_OPT) $(COPTS) -Wall -ffunction-sections -fdata-sections -Wl,--gc-sections
+LDFLAGS += -ffunction-sections -fdata-sections -Wl,--gc-sections
 
-ifndef CFLAGS
-CFLAGS = -MMD -O2 -Wall -g
-endif
+CFLAGS += $(EXTRA_CFLAGS)
+CFLAGS += -I$(abspath ../src)
+CFLAGS += -I$(abspath ../src/utils)
 
 ifdef LIBS
 # If LIBS is set with some global build system defaults, clone those for
@@ -21,15 +20,12 @@ LIBS_n := $(LIBS)
 endif
 endif
 
-CFLAGS += $(EXTRA_CFLAGS)
-CFLAGS += -I$(abspath ../src)
-CFLAGS += -I$(abspath ../src/utils)
-
 export BINDIR ?= /usr/local/bin/
 
 -include .config
 -include $(if $(MULTICALL), ../wpa_supplicant/.config)
 
+
 ifndef CONFIG_NO_GITVER
 # Add VERSION_STR postfix for builds from a git repository
 ifeq ($(wildcard ../.git),../.git)
@@ -199,8 +195,7 @@ endif
 
 ifdef CONFIG_NO_VLAN
 CFLAGS += -DCONFIG_NO_VLAN
-endif
-ifneq ($(findstring CONFIG_NO_VLAN,$(CFLAGS)), CONFIG_NO_VLAN)
+else
 OBJS += ../src/ap/vlan_init.o
 OBJS += ../src/ap/vlan_ifconfig.o
 OBJS += ../src/ap/vlan.o
@@ -220,9 +215,6 @@ endif
 ifdef CONFIG_NO_CTRL_IFACE
 CFLAGS += -DCONFIG_NO_CTRL_IFACE
 else
-ifdef CONFIG_CTRL_IFACE_MIB
-CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-endif
 ifeq ($(CONFIG_CTRL_IFACE), udp)
 CFLAGS += -DCONFIG_CTRL_IFACE_UDP
 else
@@ -244,6 +236,9 @@ endif
 endif
 endif
 endif
+ifdef CONFIG_CTRL_IFACE_MIB
+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
+endif
 OBJS += ../src/common/ctrl_iface_common.o
 OBJS += ctrl_iface.o
 OBJS += ../src/ap/ctrl_iface_ap.o
@@ -252,6 +247,9 @@ endif
 ifndef CONFIG_NO_CTRL_IFACE
 CFLAGS += -DCONFIG_CTRL_IFACE
 endif
+ifdef CONFIG_CTRL_IFACE_MIB
+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
+endif
 
 ifdef CONFIG_IAPP
 CFLAGS += -DCONFIG_IAPP
@@ -323,15 +321,15 @@ ifdef CONFIG_IEEE80211AC
 CFLAGS += -DCONFIG_IEEE80211AC
 endif
 
+ifndef MULTICALL
+CFLAGS += -DNO_SUPPLICANT
+endif
+
 ifdef CONFIG_MBO
 CFLAGS += -DCONFIG_MBO
 OBJS += ../src/ap/mbo_ap.o
 endif
 
-ifndef MULTICALL
-CFLAGS += -DNO_SUPPLICANT
-endif
-
 include ../src/drivers/drivers.mak
 OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
 CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
@@ -990,6 +988,9 @@ endif
 
 ifdef CONFIG_NO_STDOUT_DEBUG
 CFLAGS += -DCONFIG_NO_STDOUT_DEBUG
+#ifndef CONFIG_CTRL_IFACE
+CFLAGS += -DCONFIG_NO_WPA_MSG
+#endif
 endif
 
 ifdef CONFIG_DEBUG_LINUX_TRACING
diff -urpN hostapd-2016-10-15/hostapd/config_file.c hostapd-2016-09-05.dd/hostapd/config_file.c
--- hostapd-2016-10-15/hostapd/config_file.c	2017-10-19 00:05:11.511747959 +0200
+++ hostapd-2016-09-05.dd/hostapd/config_file.c	2017-10-17 23:49:52.000000000 +0200
@@ -115,6 +115,10 @@ static int hostapd_acl_comp(const void *
 {
 	const struct mac_acl_entry *aa = a;
 	const struct mac_acl_entry *bb = b;
+
+	if (!!aa->mask != !!bb->mask)
+		return !!aa->mask - !!bb->mask;
+
 	return os_memcmp(aa->addr, bb->addr, sizeof(macaddr));
 }
 
@@ -123,11 +127,12 @@ static int hostapd_config_read_maclist(c
 				       struct mac_acl_entry **acl, int *num)
 {
 	FILE *f;
-	char buf[128], *pos;
+	char buf[128], *pos, *macpos, *sep;
 	int line = 0;
 	u8 addr[ETH_ALEN];
 	struct mac_acl_entry *newacl;
-	int vlan_id;
+	int vlan_id, mask;
+	int i;
 
 	if (!fname)
 		return 0;
@@ -160,8 +165,27 @@ static int hostapd_config_read_maclist(c
 			rem = 1;
 			pos++;
 		}
+		pos = buf;	
+		macpos = buf;
+		while (*pos != '\0' && *pos != ' ' && *pos != '\t')
+			pos++;
+
+		sep = strchr(buf, '/');
+		if (sep && sep < pos) {
+			*(sep++) = 0;
+			mask = strtoul(sep, &pos, 10);
+			if (mask >= 8 * ETH_ALEN) {
+				wpa_printf(MSG_ERROR, "Invalid MAC address mask '%d'\n",
+					   mask);
+				fclose(f);
+				return -1;
+			}
+		}
+		else {
+			mask = 0;
+		}
 
-		if (hwaddr_aton(pos, addr)) {
+		if (hwaddr_aton(macpos, addr)) {
 			wpa_printf(MSG_ERROR, "Invalid MAC address '%s' at "
 				   "line %d in '%s'", pos, line, fname);
 			fclose(f);
@@ -203,6 +227,7 @@ static int hostapd_config_read_maclist(c
 			  sizeof((*acl)[*num].vlan_id));
 		(*acl)[*num].vlan_id.untagged = vlan_id;
 		(*acl)[*num].vlan_id.notempty = !!vlan_id;
+		(*acl)[*num].mask = mask;
 		(*num)++;
 	}
 
@@ -1181,6 +1206,8 @@ static int hostapd_config_vht_capab(stru
 		conf->vht_capab |= (3 << VHT_CAP_SOUNDING_DIMENSION_OFFSET);
 	if (os_strstr(capab, "[MU-BEAMFORMER]"))
 		conf->vht_capab |= VHT_CAP_MU_BEAMFORMER_CAPABLE;
+	if (os_strstr(capab, "[MU-BEAMFORMEE]"))
+		conf->vht_capab |= VHT_CAP_MU_BEAMFORMEE_CAPABLE;
 	if (os_strstr(capab, "[VHT-TXOP-PS]"))
 		conf->vht_capab |= VHT_CAP_VHT_TXOP_PS;
 	if (os_strstr(capab, "[HTC-VHT]"))
@@ -2439,6 +2466,8 @@ static int hostapd_config_fill(struct ho
 		bss->wpa_gmk_rekey = atoi(pos);
 	} else if (os_strcmp(buf, "wpa_ptk_rekey") == 0) {
 		bss->wpa_ptk_rekey = atoi(pos);
+	} else if (os_strcmp(buf, "wpa_disable_eapol_key_retries") == 0) {
+		bss->wpa_disable_eapol_key_retries = atoi(pos);
 	} else if (os_strcmp(buf, "wpa_passphrase") == 0) {
 		int len = os_strlen(pos);
 		if (len < 8 || len > 63) {
@@ -2651,6 +2680,9 @@ static int hostapd_config_fill(struct ho
 			conf->channel = atoi(pos);
 			conf->acs = conf->channel == 0;
 		}
+	} else if (os_strcmp(buf, "frequency") == 0) {
+		conf->frequency = atoi(pos);
+		conf->acs = conf->frequency == 0;
 	} else if (os_strcmp(buf, "chanlist") == 0) {
 		if (hostapd_parse_chanlist(conf, pos)) {
 			wpa_printf(MSG_ERROR, "Line %d: invalid channel list",
@@ -2865,8 +2897,6 @@ static int hostapd_config_fill(struct ho
 #ifdef CONFIG_IEEE80211N
 	} else if (os_strcmp(buf, "noscan") == 0) {
 		conf->noscan = atoi(pos);
-	} else if (os_strcmp(buf, "ht_coex") == 0) {
-		conf->no_ht_coex = !atoi(pos);
 	} else if (os_strcmp(buf, "ieee80211n") == 0) {
 		conf->ieee80211n = atoi(pos);
 	} else if (os_strcmp(buf, "ht_capab") == 0) {
@@ -2875,6 +2905,8 @@ static int hostapd_config_fill(struct ho
 				   line);
 			return 1;
 		}
+	} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
+		conf->dynamic_ht40 = atoi(pos);
 	} else if (os_strcmp(buf, "require_ht") == 0) {
 		conf->require_ht = atoi(pos);
 	} else if (os_strcmp(buf, "obss_interval") == 0) {
@@ -2920,6 +2952,8 @@ static int hostapd_config_fill(struct ho
 		bss->wps_independent = atoi(pos);
 	} else if (os_strcmp(buf, "ap_setup_locked") == 0) {
 		bss->ap_setup_locked = atoi(pos);
+	} else if (os_strcmp(buf, "dualband") == 0) {
+		bss->dualband = atoi(pos);
 	} else if (os_strcmp(buf, "uuid") == 0) {
 		if (uuid_str2bin(pos, bss->uuid)) {
 			wpa_printf(MSG_ERROR, "Line %d: invalid UUID", line);
Binary files hostapd-2016-10-15/hostapd/config_file.o and hostapd-2016-09-05.dd/hostapd/config_file.o differ
diff -urpN hostapd-2016-10-15/hostapd/ctrl_iface.c hostapd-2016-09-05.dd/hostapd/ctrl_iface.c
--- hostapd-2016-10-15/hostapd/ctrl_iface.c	2017-10-19 00:05:11.523747805 +0200
+++ hostapd-2016-09-05.dd/hostapd/ctrl_iface.c	2017-02-19 15:21:18.000000000 +0100
@@ -56,10 +56,11 @@
 #include "config_file.h"
 #include "ctrl_iface.h"
 #include "config_file.h"
+#include "utils/wpa_debug.h"
 
 
 #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
-
+ 
 #ifdef CONFIG_CTRL_IFACE_UDP
 #define COOKIE_LEN 8
 static unsigned char cookie[COOKIE_LEN];
@@ -70,11 +71,12 @@ static unsigned char gcookie[COOKIE_LEN]
 #define HOSTAPD_GLOBAL_CTRL_IFACE_PORT_LIMIT	50
 #endif /* CONFIG_CTRL_IFACE_UDP */
 
+static char *reload_opts = NULL;
+
 static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
 				    enum wpa_msg_type type,
 				    const char *buf, size_t len);
 
-static char *reload_opts = NULL;
 
 static int hostapd_ctrl_iface_attach(struct hostapd_data *hapd,
 				     struct sockaddr_storage *from,
@@ -126,6 +128,13 @@ static int hostapd_ctrl_iface_new_sta(st
 	return 0;
 }
 
+static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
+{
+	if (hapd->driver->stop_ap)
+		hapd->driver->stop_ap(hapd->drv_priv);
+	return 0;
+}
+
 static char *get_option(char *opt, char *str)
 {
 	int len = strlen(str);
@@ -149,15 +158,38 @@ static struct hostapd_config *hostapd_ct
 	     opt;
 		 opt = strtok(NULL, " ")) {
 
-		if ((val = get_option(opt, "channel=")))
+		if ((val = get_option(opt, "channel="))) {
 			conf->channel = atoi(val);
+			if (conf->vht_oper_chwidth == 2) {
+			if (conf->channel < 100)			
+				conf->vht_oper_centr_freq_seg0_idx = 50;
+			    else
+				conf->vht_oper_centr_freq_seg0_idx = 114;
+			} else {			
+			if (conf->secondary_channel==1)			
+				conf->vht_oper_centr_freq_seg0_idx = conf->channel + 6;
+			if (conf->secondary_channel==-1)			
+				conf->vht_oper_centr_freq_seg0_idx = conf->channel - 6;
+			}
+		} else if ((val = get_option(opt, "frequency=")))
+			conf->frequency = atoi(val);
 		else if ((val = get_option(opt, "ht_capab=")))
 			conf->ht_capab = atoi(val);
 		else if ((val = get_option(opt, "ht_capab_mask=")))
 			conf->ht_capab &= atoi(val);
-		else if ((val = get_option(opt, "sec_chan=")))
+		else if ((val = get_option(opt, "chwidth=")))
+			conf->vht_oper_chwidth = atoi(val);
+		else if ((val = get_option(opt, "sec_chan="))) {
 			conf->secondary_channel = atoi(val);
-		else if ((val = get_option(opt, "hw_mode=")))
+			if (conf->secondary_channel==1)			
+				conf->vht_oper_centr_freq_seg0_idx = conf->channel + 6;
+			if (conf->secondary_channel==-1)			
+				conf->vht_oper_centr_freq_seg0_idx = conf->channel - 6;
+		} else if ((val = get_option(opt, "sec_idx0="))) {
+			conf->vht_oper_centr_freq_seg0_idx = atoi(val);
+		} else if ((val = get_option(opt, "sec_idx1="))) {
+			conf->vht_oper_centr_freq_seg1_idx = atoi(val);
+		} else if ((val = get_option(opt, "hw_mode=")))
 			conf->hw_mode = atoi(val);
 		else if ((val = get_option(opt, "ieee80211n=")))
 			conf->ieee80211n = atoi(val);
@@ -205,6 +237,9 @@ static int hostapd_ctrl_iface_sa_query(s
 
 
 #ifdef CONFIG_WPS
+extern int sysprintf(const char *fmt, ...);
+
+
 static int hostapd_ctrl_iface_wps_pin(struct hostapd_data *hapd, char *txt)
 {
 	char *pin = os_strchr(txt, ' ');
@@ -229,7 +264,10 @@ static int hostapd_ctrl_iface_wps_pin(st
 		}
 	} else
 		timeout = 0;
-
+	sysprintf("killall wpswatcher");
+	sysprintf("wpswatcher %d",timeout);
+	sysprintf("killall ledtool");
+	sysprintf("ledtool %d 2",timeout);
 	return hostapd_wps_add_pin(hapd, addr, txt, pin, timeout);
 }
 
@@ -501,6 +539,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
 	char *pos;
 	const char *pin_txt;
 
+	if (!hapd->wps)
+		return -1;
+
 	pos = os_strchr(txt, ' ');
 	if (pos)
 		*pos++ = '\0';
@@ -538,6 +579,10 @@ static int hostapd_ctrl_iface_wps_ap_pin
 		}
 		if (os_strlen(pin) > buflen)
 			return -1;
+		sysprintf("killall wpswatcher");
+		sysprintf("wpswatcher %d",timeout);
+		sysprintf("killall ledtool");
+		sysprintf("ledtool %d 2",timeout);
 		if (hostapd_wps_ap_pin_set(hapd, pin, timeout) < 0)
 			return -1;
 		return os_snprintf(buf, buflen, "%s", pin);
Binary files hostapd-2016-10-15/hostapd/ctrl_iface.o and hostapd-2016-09-05.dd/hostapd/ctrl_iface.o differ
diff -urpN hostapd-2016-10-15/hostapd/defconfig hostapd-2016-09-05.dd/hostapd/defconfig
Binary files hostapd-2016-10-15/hostapd/eap_register.o and hostapd-2016-09-05.dd/hostapd/eap_register.o differ
diff -urpN hostapd-2016-10-15/hostapd/hostapd.conf hostapd-2016-09-05.dd/hostapd/hostapd.conf
Binary files hostapd-2016-10-15/hostapd/hostapd_cli and hostapd-2016-09-05.dd/hostapd/hostapd_cli differ
Binary files hostapd-2016-10-15/hostapd/hostapd_cli.o and hostapd-2016-09-05.dd/hostapd/hostapd_cli.o differ
Binary files hostapd-2016-10-15/hostapd/hostapd_multi.a and hostapd-2016-09-05.dd/hostapd/hostapd_multi.a differ
Binary files hostapd-2016-10-15/hostapd/hostapd_multi.o and hostapd-2016-09-05.dd/hostapd/hostapd_multi.o differ
diff -urpN hostapd-2016-10-15/hostapd/main.c hostapd-2016-09-05.dd/hostapd/main.c
--- hostapd-2016-10-15/hostapd/main.c	2017-10-19 00:05:11.535747650 +0200
+++ hostapd-2016-09-05.dd/hostapd/main.c	2017-01-25 07:30:50.000000000 +0100
@@ -545,6 +545,11 @@ static int hostapd_get_ctrl_iface_group(
 	return 0;
 }
 
+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
+                       union wpa_event_data *data);
+
+void hostapd_wpa_event_global(void *ctx, enum wpa_event_type event,
+ 				 union wpa_event_data *data);
 
 static int hostapd_get_interface_names(char ***if_names,
 				       size_t *if_names_size,
@@ -582,11 +587,6 @@ fail:
 	return -1;
 }
 
-void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-                       union wpa_event_data *data);
-
-void hostapd_wpa_event_global(void *ctx, enum wpa_event_type event,
- 				 union wpa_event_data *data);
 
 #ifdef CONFIG_WPS
 static int gen_uuid(const char *txt_addr)
Binary files hostapd-2016-10-15/hostapd/main.o and hostapd-2016-09-05.dd/hostapd/main.o differ
diff -urpN hostapd-2016-10-15/multicall/multicall.c hostapd-2016-09-05.dd/multicall/multicall.c
--- hostapd-2016-10-15/multicall/multicall.c	1970-01-01 01:00:00.000000000 +0100
+++ hostapd-2016-09-05.dd/multicall/multicall.c	2017-01-25 07:30:50.000000000 +0100
@@ -0,0 +1,28 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+
+extern int hostapd_main(int argc, char **argv);
+extern int wpa_supplicant_main(int argc, char **argv);
+
+int main(int argc, char **argv)
+{
+	bool restart = false;
+	const char *prog = argv[0];
+
+restart:
+	if (strstr(argv[0], "hostapd"))
+		return hostapd_main(argc, argv);
+	else if (strstr(argv[0], "wpa_supplicant"))
+		return wpa_supplicant_main(argc, argv);
+
+	if (!restart && argc > 1) {
+		argv++;
+		argc--;
+		restart = true;
+		goto restart;
+	}
+
+	fprintf(stderr, "Invalid command.\nUsage: %s wpa_supplicant|hostapd [<arguments>]\n", prog);
+	return 255;
+}
diff -urpN hostapd-2016-10-15/patches/001-4addr-fix-reconnecting-client-on-connection-lost.patch hostapd-2016-09-05.dd/patches/001-4addr-fix-reconnecting-client-on-connection-lost.patch
diff -urpN hostapd-2016-10-15/patches/002-mesh-Set-correct-secondary-channel-offset-if-HT40-is.patch hostapd-2016-09-05.dd/patches/002-mesh-Set-correct-secondary-channel-offset-if-HT40-is.patch
diff -urpN hostapd-2016-10-15/patches/100-mesh_mode_fix.patch hostapd-2016-09-05.dd/patches/100-mesh_mode_fix.patch
diff -urpN hostapd-2016-10-15/patches/110-fix_parse_das_client.patch hostapd-2016-09-05.dd/patches/110-fix_parse_das_client.patch
diff -urpN hostapd-2016-10-15/patches/120-daemonize_fix.patch hostapd-2016-09-05.dd/patches/120-daemonize_fix.patch
diff -urpN hostapd-2016-10-15/patches/130-no_eapol_fix.patch hostapd-2016-09-05.dd/patches/130-no_eapol_fix.patch
diff -urpN hostapd-2016-10-15/patches/140-disable_bridge_packet_workaround.patch hostapd-2016-09-05.dd/patches/140-disable_bridge_packet_workaround.patch
diff -urpN hostapd-2016-10-15/patches/200-multicall.patch hostapd-2016-09-05.dd/patches/200-multicall.patch
diff -urpN hostapd-2016-10-15/patches/300-noscan.patch hostapd-2016-09-05.dd/patches/300-noscan.patch
diff -urpN hostapd-2016-10-15/patches/310-rescan_immediately.patch hostapd-2016-09-05.dd/patches/310-rescan_immediately.patch
diff -urpN hostapd-2016-10-15/patches/320-optional_rfkill.patch hostapd-2016-09-05.dd/patches/320-optional_rfkill.patch
diff -urpN hostapd-2016-10-15/patches/330-nl80211_fix_set_freq.patch hostapd-2016-09-05.dd/patches/330-nl80211_fix_set_freq.patch
diff -urpN hostapd-2016-10-15/patches/340-reload_freq_change.patch hostapd-2016-09-05.dd/patches/340-reload_freq_change.patch
diff -urpN hostapd-2016-10-15/patches/350-nl80211_del_beacon_bss.patch hostapd-2016-09-05.dd/patches/350-nl80211_del_beacon_bss.patch
diff -urpN hostapd-2016-10-15/patches/360-ctrl_iface_reload.patch hostapd-2016-09-05.dd/patches/360-ctrl_iface_reload.patch
diff -urpN hostapd-2016-10-15/patches/370-ap_sta_support.patch hostapd-2016-09-05.dd/patches/370-ap_sta_support.patch
diff -urpN hostapd-2016-10-15/patches/380-disable_ctrl_iface_mib.patch hostapd-2016-09-05.dd/patches/380-disable_ctrl_iface_mib.patch
diff -urpN hostapd-2016-10-15/patches/390-wpa_ie_cap_workaround.patch hostapd-2016-09-05.dd/patches/390-wpa_ie_cap_workaround.patch
diff -urpN hostapd-2016-10-15/patches/400-wps_single_auth_enc_type.patch hostapd-2016-09-05.dd/patches/400-wps_single_auth_enc_type.patch
diff -urpN hostapd-2016-10-15/patches/410-limit_debug_messages.patch hostapd-2016-09-05.dd/patches/410-limit_debug_messages.patch
diff -urpN hostapd-2016-10-15/patches/420-indicate-features.patch hostapd-2016-09-05.dd/patches/420-indicate-features.patch
diff -urpN hostapd-2016-10-15/patches/430-hostapd_cli_ifdef.patch hostapd-2016-09-05.dd/patches/430-hostapd_cli_ifdef.patch
diff -urpN hostapd-2016-10-15/patches/431-wpa_cli_ifdef.patch hostapd-2016-09-05.dd/patches/431-wpa_cli_ifdef.patch
diff -urpN hostapd-2016-10-15/patches/432-missing-typedef.patch hostapd-2016-09-05.dd/patches/432-missing-typedef.patch
diff -urpN hostapd-2016-10-15/patches/450-scan_wait.patch hostapd-2016-09-05.dd/patches/450-scan_wait.patch
diff -urpN hostapd-2016-10-15/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch hostapd-2016-09-05.dd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
diff -urpN hostapd-2016-10-15/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch hostapd-2016-09-05.dd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
diff -urpN hostapd-2016-10-15/patches/462-wpa_s-support-htmode-param.patch hostapd-2016-09-05.dd/patches/462-wpa_s-support-htmode-param.patch
diff -urpN hostapd-2016-10-15/patches/470-survey_data_fallback.patch hostapd-2016-09-05.dd/patches/470-survey_data_fallback.patch
diff -urpN hostapd-2016-10-15/patches/600-ubus_support.patch hostapd-2016-09-05.dd/patches/600-ubus_support.patch
Binary files hostapd-2016-10-15/src/ap/accounting.o and hostapd-2016-09-05.dd/src/ap/accounting.o differ
diff -urpN hostapd-2016-10-15/src/ap/ap_config.c hostapd-2016-09-05.dd/src/ap/ap_config.c
diff -urpN hostapd-2016-10-15/src/ap/ap_config.h hostapd-2016-09-05.dd/src/ap/ap_config.h
--- hostapd-2016-10-15/src/ap/ap_config.h	2017-10-19 00:05:11.511747959 +0200
+++ hostapd-2016-09-05.dd/src/ap/ap_config.h	2017-10-17 23:49:52.000000000 +0200
@@ -59,6 +59,7 @@ typedef u8 macaddr[ETH_ALEN];
 struct mac_acl_entry {
 	macaddr addr;
 	struct vlan_description vlan_id;
+	int mask;
 };
 
 struct hostapd_radius_servers;
@@ -324,6 +325,7 @@ struct hostapd_bss_config {
 	int wpa_strict_rekey;
 	int wpa_gmk_rekey;
 	int wpa_ptk_rekey;
+	int wpa_disable_eapol_key_retries;
 	int rsn_pairwise;
 	int rsn_preauth;
 	char *rsn_preauth_interfaces;
@@ -404,6 +406,7 @@ struct hostapd_bss_config {
 #ifdef CONFIG_WPS
 	int wps_independent;
 	int ap_setup_locked;
+	int dualband;
 	u8 uuid[16];
 	char *wps_pin_requests;
 	char *device_name;
@@ -610,6 +613,8 @@ struct hostapd_config {
 	int fragm_threshold;
 	u8 send_probe_response;
 	u8 channel;
+	u16 frequency;
+	int *chanlist;
 	u8 acs;
 	struct wpa_freq_range_list acs_ch_list;
 	enum hostapd_hw_mode hw_mode; /* HOSTAPD_MODE_IEEE80211A, .. */
@@ -665,11 +670,11 @@ struct hostapd_config {
 	int ht_op_mode_fixed;
 	u16 ht_capab;
 	int noscan;
-	int no_ht_coex;
 	int ieee80211n;
 	int secondary_channel;
 	int no_pri_sec_switch;
 	int require_ht;
+	int dynamic_ht40;
 	int obss_interval;
 	u32 vht_capab;
 	int ieee80211ac;
Binary files hostapd-2016-10-15/src/ap/ap_config.o and hostapd-2016-09-05.dd/src/ap/ap_config.o differ
Binary files hostapd-2016-10-15/src/ap/ap_drv_ops.o and hostapd-2016-09-05.dd/src/ap/ap_drv_ops.o differ
Binary files hostapd-2016-10-15/src/ap/ap_list.o and hostapd-2016-09-05.dd/src/ap/ap_list.o differ
Binary files hostapd-2016-10-15/src/ap/ap_mlme.o and hostapd-2016-09-05.dd/src/ap/ap_mlme.o differ
Binary files hostapd-2016-10-15/src/ap/authsrv.o and hostapd-2016-09-05.dd/src/ap/authsrv.o differ
Binary files hostapd-2016-10-15/src/ap/beacon.o and hostapd-2016-09-05.dd/src/ap/beacon.o differ
Binary files hostapd-2016-10-15/src/ap/bss_load.o and hostapd-2016-09-05.dd/src/ap/bss_load.o differ
Binary files hostapd-2016-10-15/src/ap/ctrl_iface_ap.o and hostapd-2016-09-05.dd/src/ap/ctrl_iface_ap.o differ
Binary files hostapd-2016-10-15/src/ap/dfs.o and hostapd-2016-09-05.dd/src/ap/dfs.o differ
Binary files hostapd-2016-10-15/src/ap/drv_callbacks.o and hostapd-2016-09-05.dd/src/ap/drv_callbacks.o differ
Binary files hostapd-2016-10-15/src/ap/eap_user_db.o and hostapd-2016-09-05.dd/src/ap/eap_user_db.o differ
diff -urpN hostapd-2016-10-15/src/ap/hostapd.c hostapd-2016-09-05.dd/src/ap/hostapd.c
--- hostapd-2016-10-15/src/ap/hostapd.c	2017-10-19 00:05:11.543747547 +0200
+++ hostapd-2016-09-05.dd/src/ap/hostapd.c	2017-04-24 00:07:48.000000000 +0200
@@ -27,6 +27,7 @@
 #include "beacon.h"
 #include "iapp.h"
 #include "ieee802_1x.h"
+#include "ieee802_11.h"
 #include "ieee802_11_auth.h"
 #include "vlan_init.h"
 #include "wpa_auth.h"
@@ -90,6 +91,14 @@ static void hostapd_reload_bss(struct ho
 			 hapd->iconf->vht_oper_centr_freq_seg0_idx,
 			 hapd->iconf->vht_oper_centr_freq_seg1_idx);
 
+	if (hapd->iface->current_mode) {
+		if (hostapd_prepare_rates(hapd->iface, hapd->iface->current_mode)) {
+                      wpa_printf(MSG_ERROR, "Failed to prepare rates table.");
+                      hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,HOSTAPD_LEVEL_WARNING,
+                                     "Failed to prepare rates table.");
+              }
+        }
+
 	if (!ssid->wpa_psk_set && ssid->wpa_psk && !ssid->wpa_psk->next &&
 	    ssid->wpa_passphrase_set && ssid->wpa_passphrase) {
 		/*
@@ -168,6 +177,8 @@ int hostapd_reload_config(struct hostapd
 	struct hostapd_data *hapd = iface->bss[0];
 	struct hostapd_config *newconf, *oldconf;
 	size_t j;
+	int i;
+
 
 	if (iface->config_fname == NULL) {
 		/* Only in-memory config in use - assume it has been updated */
@@ -189,6 +200,14 @@ int hostapd_reload_config(struct hostapd
 	oldconf = hapd->iconf;
 	iface->conf = newconf;
 
+      for (i = 0; i < iface->num_hw_features; i++) {
+	              struct hostapd_hw_modes *mode = &iface->hw_features[i];
+	              if (mode->mode == iface->conf->hw_mode) {
+		                      iface->current_mode = mode;
+		                      break;
+		              }
+	      }
+
 	if (iface->conf->channel)
 		iface->freq = hostapd_hw_get_freq(hapd, iface->conf->channel);
 
@@ -1674,8 +1693,11 @@ static int hostapd_setup_interface_compl
 #ifdef NEED_AP_MLME
 		int res;
 #endif /* NEED_AP_MLME */
+		if (hapd->iconf->frequency)
+			iface->freq = iface->conf->frequency;
+		else
+			iface->freq = hostapd_hw_get_freq(hapd, iface->conf->channel);
 
-		iface->freq = hostapd_hw_get_freq(hapd, iface->conf->channel);
 		wpa_printf(MSG_DEBUG, "Mode: %s  Channel: %d  "
 			   "Frequency: %d MHz",
 			   hostapd_hw_mode_txt(iface->conf->hw_mode),
Binary files hostapd-2016-10-15/src/ap/hostapd.o and hostapd-2016-09-05.dd/src/ap/hostapd.o differ
diff -urpN hostapd-2016-10-15/src/ap/hw_features.c hostapd-2016-09-05.dd/src/ap/hw_features.c
--- hostapd-2016-10-15/src/ap/hw_features.c	2017-10-19 00:05:11.511747959 +0200
+++ hostapd-2016-09-05.dd/src/ap/hw_features.c	2017-01-25 07:30:50.000000000 +0100
@@ -224,16 +224,66 @@ int hostapd_prepare_rates(struct hostapd
 #ifdef CONFIG_IEEE80211N
 static int ieee80211n_allowed_ht40_channel_pair(struct hostapd_iface *iface)
 {
-	int pri_chan, sec_chan;
+	int sec_chan, ok, j, first;
+	int allowed[] = { 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157,
+			  184, 192 };
+	size_t k;
 
 	if (!iface->conf->secondary_channel)
 		return 1; /* HT40 not used */
 
-	pri_chan = iface->conf->channel;
-	sec_chan = pri_chan + iface->conf->secondary_channel * 4;
+	sec_chan = iface->conf->channel + iface->conf->secondary_channel * 4;
+	wpa_printf(MSG_DEBUG, "HT40: control channel: %d  "
+		   "secondary channel: %d",
+		   iface->conf->channel, sec_chan);
+
+	/* Verify that HT40 secondary channel is an allowed 20 MHz
+	 * channel */
+	ok = 0;
+	for (j = 0; j < iface->current_mode->num_channels; j++) {
+		struct hostapd_channel_data *chan =
+			&iface->current_mode->channels[j];
+		if (!(chan->flag & HOSTAPD_CHAN_DISABLED) &&
+		    chan->chan == sec_chan) {
+			ok = 1;
+			break;
+		}
+	}
+	if (!ok) {
+		wpa_printf(MSG_ERROR, "HT40 secondary channel %d not allowed",
+			   sec_chan);
+		return 0;
+	}
+
+	/*
+	 * Verify that HT40 primary,secondary channel pair is allowed per
+	 * IEEE 802.11n Annex J. This is only needed for 5 GHz band since
+	 * 2.4 GHz rules allow all cases where the secondary channel fits into
+	 * the list of allowed channels (already checked above).
+	 */
+//	if (1 || iface->current_mode->mode != HOSTAPD_MODE_IEEE80211A)
+		return 1;
+
+	if (iface->conf->secondary_channel > 0)
+		first = iface->conf->channel;
+	else
+		first = sec_chan;
+
+	ok = 0;
+	for (k = 0; k < ARRAY_SIZE(allowed); k++) {
+		if (first == allowed[k]) {
+			ok = 1;
+			break;
+		}
+	}
+	if (!ok) {
+		wpa_printf(MSG_ERROR, "HT40 channel pair (%d, %d) not allowed",
+			   iface->conf->channel,
+			   iface->conf->secondary_channel);
+		return 0;
+	}
 
-	return allowed_ht40_channel_pair(iface->current_mode, pri_chan,
-					 sec_chan);
+	return 1;
 }
 
 
@@ -241,9 +291,11 @@ static void ieee80211n_switch_pri_sec(st
 {
 	if (iface->conf->secondary_channel > 0) {
 		iface->conf->channel += 4;
+		iface->conf->frequency += 20;
 		iface->conf->secondary_channel = -1;
 	} else {
 		iface->conf->channel -= 4;
+		iface->conf->frequency -= 20;
 		iface->conf->secondary_channel = 1;
 	}
 }
@@ -310,7 +362,7 @@ static void ieee80211n_check_scan(struct
 	wpa_scan_results_free(scan_res);
 
 	iface->secondary_ch = iface->conf->secondary_channel;
-	if (!oper40) {
+	if (!oper40 && iface->conf->dynamic_ht40) {
 		wpa_printf(MSG_INFO, "20/40 MHz operation not permitted on "
 			   "channel pri=%d sec=%d based on overlapping BSSes",
 			   iface->conf->channel,
@@ -474,8 +526,7 @@ static int ieee80211n_check_40mhz(struct
 	int ret;
 
 	/* Check that HT40 is used and PRI / SEC switch is allowed */
-	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch ||
-		iface->conf->noscan)
+	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch || iface->conf->noscan)
 		return 0;
 
 	hostapd_set_state(iface, HAPD_IFACE_HT_SCAN);
Binary files hostapd-2016-10-15/src/ap/hw_features.o and hostapd-2016-09-05.dd/src/ap/hw_features.o differ
Binary files hostapd-2016-10-15/src/ap/iapp.o and hostapd-2016-09-05.dd/src/ap/iapp.o differ
diff -urpN hostapd-2016-10-15/src/ap/ieee802_11.c hostapd-2016-09-05.dd/src/ap/ieee802_11.c
diff -urpN hostapd-2016-10-15/src/ap/ieee802_11.c.orig hostapd-2016-09-05.dd/src/ap/ieee802_11.c.orig
Binary files hostapd-2016-10-15/src/ap/ieee802_11.o and hostapd-2016-09-05.dd/src/ap/ieee802_11.o differ
Binary files hostapd-2016-10-15/src/ap/ieee802_11_auth.o and hostapd-2016-09-05.dd/src/ap/ieee802_11_auth.o differ
diff -urpN hostapd-2016-10-15/src/ap/ieee802_11_ht.c hostapd-2016-09-05.dd/src/ap/ieee802_11_ht.c
--- hostapd-2016-10-15/src/ap/ieee802_11_ht.c	2017-10-19 00:05:11.511747959 +0200
+++ hostapd-2016-09-05.dd/src/ap/ieee802_11_ht.c	2017-01-25 07:30:50.000000000 +0100
@@ -14,9 +14,11 @@
 #include "common/ieee802_11_defs.h"
 #include "hostapd.h"
 #include "ap_config.h"
+#include "ap_drv_ops.h"
 #include "sta_info.h"
 #include "beacon.h"
 #include "ieee802_11.h"
+#include "utils/eloop.h"
 #include "hw_features.h"
 #include "ap_drv_ops.h"
 
@@ -95,6 +97,7 @@ u8 * hostapd_eid_ht_operation(struct hos
 
 	oper->primary_chan = hapd->iconf->channel;
 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
+
 	if (hapd->iconf->secondary_channel == 1)
 		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
 			HT_INFO_HT_PARAM_STA_CHNL_WIDTH;
@@ -241,10 +244,13 @@ void hostapd_2040_coex_action(struct hos
 		       HOSTAPD_LEVEL_DEBUG, "hostapd_public_action - action=%d",
 		       mgmt->u.action.u.public_action.action);
 
+	if (!iface->conf->dynamic_ht40)
+		return;
+
 	if (!(iface->conf->ht_capab & HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET))
 		return;
 
-	if (iface->conf->noscan || iface->conf->no_ht_coex)
+	if (iface->conf->noscan)
 		return;
 
 	if (len < IEEE80211_HDRLEN + 2 + sizeof(*bc_ie))
@@ -371,7 +377,7 @@ void ht40_intolerant_add(struct hostapd_
 	if (iface->current_mode->mode != HOSTAPD_MODE_IEEE80211G)
 		return;
 
-	if (iface->conf->noscan || iface->conf->no_ht_coex)
+	if (iface->conf->noscan)
 		return;
 
 	wpa_printf(MSG_INFO, "HT: Forty MHz Intolerant is set by STA " MACSTR
@@ -443,7 +449,7 @@ static void update_sta_ht(struct hostapd
 			   hapd->iface->num_sta_ht_20mhz);
 	}
 
-	if (ht_capab & HT_CAP_INFO_40MHZ_INTOLERANT)
+	if ((ht_capab & HT_CAP_INFO_40MHZ_INTOLERANT) && hapd->iface->conf->dynamic_ht40)
 		ht40_intolerant_add(hapd->iface, sta);
 }
 
Binary files hostapd-2016-10-15/src/ap/ieee802_11_shared.o and hostapd-2016-09-05.dd/src/ap/ieee802_11_shared.o differ
diff -urpN hostapd-2016-10-15/src/ap/ieee802_11_vht.c hostapd-2016-09-05.dd/src/ap/ieee802_11_vht.c
diff -urpN hostapd-2016-10-15/src/ap/ieee802_1x.c hostapd-2016-09-05.dd/src/ap/ieee802_1x.c
--- hostapd-2016-10-15/src/ap/ieee802_1x.c	2017-10-19 00:05:11.527747753 +0200
+++ hostapd-2016-09-05.dd/src/ap/ieee802_1x.c	2017-01-25 07:30:50.000000000 +0100
@@ -1644,6 +1644,46 @@ ieee802_1x_search_radius_identifier(stru
 	return id_search.sm;
 }
 
+#ifdef HAVE_AQOS
+extern void add_usermac( char *mac, int idx, char *upstream,
+			 char *downstream, char *lanstream );
+extern char *nvram_safe_get(const char *name);
+
+int addrule(char *mac, char *upstream, char *downstream)
+{
+	char *qos_mac = nvram_safe_get( "svqos_macs" );
+	char *newqos;
+	int ret = 0;
+	int len = strlen(qos_mac);
+
+	newqos = malloc(len + 128);
+	memset(newqos, 0, len + 128);
+
+	char level[32], level2[32], level3[32], data[32], type[32], prio[32];
+	strcpy(level3, "0");
+	if (len > 0) {
+		do {
+			if(sscanf( qos_mac, "%31s %31s %31s %31s %31s %31s |", data, level, level2, type, level3, prio) < 6)
+				break;
+			if (!strcasecmp(data,mac)) {
+				sprintf(newqos,"%s %s %s %s %s %s %s |",newqos,data,upstream,downstream,"hostapd",level3,prio);
+				if (!strcmp(level,upstream) && !strcmp(level2,downstream))
+					ret = 1;
+				else
+					ret = 2;
+			} else
+				sprintf(newqos,"%s %s %s %s %s %s %s |",newqos,data,level,level2,type,level3,prio);
+		} while( ( qos_mac = strpbrk( ++qos_mac, "|" ) ) && qos_mac++ );
+	}
+
+	if (!ret)
+		sprintf(newqos,"%s %s %s %s %s %s %s |",newqos,mac,upstream,downstream,"hostapd",level3,prio);
+
+	nvram_set("svqos_macs",newqos);
+	free(newqos);
+}
+
+#endif
 
 /**
  * ieee802_1x_receive_auth - Process RADIUS frames from Authentication Server
@@ -1672,6 +1712,8 @@ ieee802_1x_receive_auth(struct radius_ms
 #endif /* CONFIG_NO_VLAN */
 
 	os_memset(&vlan_desc, 0, sizeof(vlan_desc));
+ 
+	static int qosidx=3910;
 
 	sm = ieee802_1x_search_radius_identifier(hapd, hdr->identifier);
 	if (sm == NULL) {
@@ -1735,6 +1777,50 @@ ieee802_1x_receive_auth(struct radius_ms
 
 	switch (hdr->code) {
 	case RADIUS_CODE_ACCESS_ACCEPT:
+#ifdef HAVE_AQOS
+		wpa_printf(MSG_DEBUG, "check user bandwith shaping\n");
+		u32 *down,*up;
+		size_t len;
+		if ((down=(u32*)radius_msg_get_vendor_attr(msg,RADIUS_VENDOR_ID_WISPR, RADIUS_ATTR_WISPR_BANDWIDTH_MAX_DOWN ,&len)) == NULL) {
+		    wpa_printf(MSG_DEBUG, "no downstream level found\n");
+		}else
+		{
+		if ((up=(u32*)radius_msg_get_vendor_attr(msg,RADIUS_VENDOR_ID_WISPR, RADIUS_ATTR_WISPR_BANDWIDTH_MAX_UP ,&len)) == NULL) {
+		    wpa_printf(MSG_DEBUG, "no up level found\n");
+		    os_free(down);
+		    }else{
+		    *down=ntohl(*down);
+		    *up=ntohl(*up);
+		    wpa_printf(MSG_DEBUG, "downstream %d kbits, upstream %d kbits level found\n",*down,*up);
+		    char mac[64];
+		    sprintf(mac, MACSTR, MAC2STR(sta->addr));
+		    char uplevel[64];
+		    char downlevel[64];
+		    sprintf(uplevel,"%d",*up/1000);
+		    sprintf(downlevel,"%d",*down/1000);
+		    int ret = addrule(mac,uplevel,downlevel);
+		    //case 0 = does not exists, should just be added, no restart
+		    //case 1 = no change required, already added
+		    //case 2 = change required, exists, but new settings
+		    //case 3 = change required, exists, new setting 
+		    if (!ret)
+			{
+			qosidx+=10;
+			if (qosidx>6400)
+			    qosidx=0;
+			wpa_printf(MSG_DEBUG, "bandwidth rule is new, no flush required!\n");			
+			add_usermac(mac, qosidx, uplevel,downlevel,"0");
+			}else if (ret>1)
+			{
+			wpa_printf(MSG_DEBUG, "bandwidth rule change detected, flush table and reset it to new values! (status %d)\n",ret);			
+			system("startstop_f wshaper");
+			}	    
+		    os_free(up);
+		    os_free(down);
+		    }
+		
+		}
+#endif
 #ifndef CONFIG_NO_VLAN
 		if (hapd->conf->ssid.dynamic_vlan != DYNAMIC_VLAN_DISABLED) {
 			notempty = &vlan_desc.notempty;
Binary files hostapd-2016-10-15/src/ap/ieee802_1x.o and hostapd-2016-09-05.dd/src/ap/ieee802_1x.o differ
Binary files hostapd-2016-10-15/src/ap/neighbor_db.o and hostapd-2016-09-05.dd/src/ap/neighbor_db.o differ
Binary files hostapd-2016-10-15/src/ap/pmksa_cache_auth.o and hostapd-2016-09-05.dd/src/ap/pmksa_cache_auth.o differ
Binary files hostapd-2016-10-15/src/ap/preauth_auth.o and hostapd-2016-09-05.dd/src/ap/preauth_auth.o differ
Binary files hostapd-2016-10-15/src/ap/rrm.o and hostapd-2016-09-05.dd/src/ap/rrm.o differ
Binary files hostapd-2016-10-15/src/ap/sta_info.o and hostapd-2016-09-05.dd/src/ap/sta_info.o differ
Binary files hostapd-2016-10-15/src/ap/tkip_countermeasures.o and hostapd-2016-09-05.dd/src/ap/tkip_countermeasures.o differ
diff -urpN hostapd-2016-10-15/src/ap/ubus.c hostapd-2016-09-05.dd/src/ap/ubus.c
diff -urpN hostapd-2016-10-15/src/ap/ubus.h hostapd-2016-09-05.dd/src/ap/ubus.h
Binary files hostapd-2016-10-15/src/ap/utils.o and hostapd-2016-09-05.dd/src/ap/utils.o differ
Binary files hostapd-2016-10-15/src/ap/wmm.o and hostapd-2016-09-05.dd/src/ap/wmm.o differ
diff -urpN hostapd-2016-10-15/src/ap/wpa_auth.c hostapd-2016-09-05.dd/src/ap/wpa_auth.c
diff -urpN hostapd-2016-10-15/src/ap/wpa_auth.h hostapd-2016-09-05.dd/src/ap/wpa_auth.h
--- hostapd-2016-10-15/src/ap/wpa_auth.h	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/src/ap/wpa_auth.h	2017-10-17 23:49:52.000000000 +0200
@@ -144,6 +144,7 @@ struct wpa_auth_config {
 	int wpa_strict_rekey;
 	int wpa_gmk_rekey;
 	int wpa_ptk_rekey;
+	int wpa_disable_eapol_key_retries;
 	int rsn_pairwise;
 	int rsn_preauth;
 	int eapol_version;
@@ -267,7 +268,7 @@ void wpa_receive(struct wpa_authenticato
 		 u8 *data, size_t data_len);
 enum wpa_event {
 	WPA_AUTH, WPA_ASSOC, WPA_DISASSOC, WPA_DEAUTH, WPA_REAUTH,
-	WPA_REAUTH_EAPOL, WPA_ASSOC_FT
+	WPA_REAUTH_EAPOL, WPA_ASSOC_FT, WPA_DRV_STA_REMOVED
 };
 void wpa_remove_ptk(struct wpa_state_machine *sm);
 int wpa_auth_sm_event(struct wpa_state_machine *sm, enum wpa_event event);
@@ -280,6 +281,7 @@ int wpa_auth_pairwise_set(struct wpa_sta
 int wpa_auth_get_pairwise(struct wpa_state_machine *sm);
 int wpa_auth_sta_key_mgmt(struct wpa_state_machine *sm);
 int wpa_auth_sta_wpa_version(struct wpa_state_machine *sm);
+int wpa_auth_sta_ft_tk_already_set(struct wpa_state_machine *sm);
 int wpa_auth_sta_clear_pmksa(struct wpa_state_machine *sm,
 			     struct rsn_pmksa_cache_entry *entry);
 struct rsn_pmksa_cache_entry *
Binary files hostapd-2016-10-15/src/ap/wpa_auth.o and hostapd-2016-09-05.dd/src/ap/wpa_auth.o differ
diff -urpN hostapd-2016-10-15/src/ap/wpa_auth_ft.c hostapd-2016-09-05.dd/src/ap/wpa_auth_ft.c
diff -urpN hostapd-2016-10-15/src/ap/wpa_auth_glue.c hostapd-2016-09-05.dd/src/ap/wpa_auth_glue.c
Binary files hostapd-2016-10-15/src/ap/wpa_auth_glue.o and hostapd-2016-09-05.dd/src/ap/wpa_auth_glue.o differ
diff -urpN hostapd-2016-10-15/src/ap/wpa_auth_i.h hostapd-2016-09-05.dd/src/ap/wpa_auth_i.h
Binary files hostapd-2016-10-15/src/ap/wpa_auth_ie.o and hostapd-2016-09-05.dd/src/ap/wpa_auth_ie.o differ
diff -urpN hostapd-2016-10-15/src/ap/wps_hostapd.c hostapd-2016-09-05.dd/src/ap/wps_hostapd.c
--- hostapd-2016-10-15/src/ap/wps_hostapd.c	2017-10-19 00:05:11.527747753 +0200
+++ hostapd-2016-09-05.dd/src/ap/wps_hostapd.c	2017-01-25 07:30:51.000000000 +0100
@@ -346,7 +346,8 @@ static int hapd_wps_reconfig_in_memory(s
 				bss->wpa_pairwise |= WPA_CIPHER_GCMP;
 			else
 				bss->wpa_pairwise |= WPA_CIPHER_CCMP;
-		} else if (cred->encr_type & WPS_ENCR_TKIP)
+		}
+		if (cred->encr_type & WPS_ENCR_TKIP)
 			bss->wpa_pairwise |= WPA_CIPHER_TKIP;
 		bss->rsn_pairwise = bss->wpa_pairwise;
 		bss->wpa_group = wpa_select_ap_group_cipher(bss->wpa,
@@ -465,6 +466,69 @@ static int hapd_wps_cred_cb(struct hosta
 		os_memcpy(hapd->wps->network_key, cred->key, cred->key_len);
 	}
 	hapd->wps->wps_state = WPS_STATE_CONFIGURED;
+	nvram_set("wps_status","1");
+	char ifname[32];
+	strcpy(ifname,hapd->conf->iface);
+	ifname[4]=0;
+	char akm[32];
+	sprintf(akm,"%s_akm",ifname);
+	char smode[32];
+	sprintf(smode,"%s_security_mode",ifname);
+	char psk[32];
+	sprintf(psk,"%s_wpa_psk",ifname);
+	char crypto[32];
+	sprintf(crypto,"%s_crypto",ifname);
+	char ssid[32];
+	sprintf(ssid,"%s_ssid",ifname);
+ 
+	if ((cred->auth_type & (WPS_AUTH_WPA2 | WPS_AUTH_WPA2PSK)) &&
+	    (cred->auth_type & (WPS_AUTH_WPA | WPS_AUTH_WPAPSK)))
+	    {
+	    nvram_set(akm,"psk psk2");
+	    nvram_set(smode,"psk psk2");
+	    }
+	else if (cred->auth_type & (WPS_AUTH_WPA2 | WPS_AUTH_WPA2PSK))
+	{
+	    nvram_set(akm,"psk2");
+	    nvram_set(smode,"psk2");
+	}
+	else if (cred->auth_type & (WPS_AUTH_WPA | WPS_AUTH_WPAPSK))
+	{
+	    nvram_set(akm,"psk");
+	    nvram_set(smode,"psk");
+	}
+	else
+	{
+	    nvram_set(akm,"disabled");
+	    nvram_set(smode,"disabled");
+	}
+	
+	
+
+	char newkey[65];
+	strncpy(newkey,cred->key,cred->key_len);
+	newkey[cred->key_len]=0;
+	nvram_set(psk,newkey);
+
+	if (cred->encr_type & (WPS_ENCR_AES | WPS_ENCR_TKIP)) {
+	    nvram_set(crypto,"tkip+aes");
+	}else
+	if (cred->encr_type & (WPS_ENCR_AES)) {
+	    nvram_set(crypto,"aes");
+	}else
+	if (cred->encr_type & (WPS_ENCR_TKIP)) {
+	    nvram_set(crypto,"tkip");
+	}
+	char str_ssid[40];
+	memcpy(str_ssid,cred->ssid,cred->ssid_len);
+	str_ssid[cred->ssid_len]=0;
+	nvram_set(ssid,str_ssid);
+	
+
+
+	nvram_commit();
+	sysprintf("echo done > /tmp/.wpsdone");
+
 
 	if (hapd->iface->config_fname == NULL)
 		return hapd_wps_reconfig_in_memory(hapd, cred);
@@ -1066,12 +1130,12 @@ int hostapd_init_wps(struct hostapd_data
 		if (conf->rsn_pairwise & (WPA_CIPHER_CCMP | WPA_CIPHER_GCMP)) {
 			wps->encr_types |= WPS_ENCR_AES;
 			wps->encr_types_rsn |= WPS_ENCR_AES;
-		} else if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
-			wps->encr_types |= WPS_ENCR_TKIP;
+		}
+		if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
 			wps->encr_types_rsn |= WPS_ENCR_TKIP;
 		}
-	}
-
+	} 
+	
 	if (conf->wpa & WPA_PROTO_WPA) {
 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
 			wps->auth_types |= WPS_AUTH_WPAPSK;
@@ -1149,6 +1213,8 @@ int hostapd_init_wps(struct hostapd_data
 	if ((wps->dev.rf_bands & (WPS_RF_50GHZ | WPS_RF_24GHZ)) ==
 	    (WPS_RF_50GHZ | WPS_RF_24GHZ))
 		cfg.dualband = 1;
+	if (hapd->conf->dualband)
+	    cfg.dualband = 1;
 	if (cfg.dualband)
 		wpa_printf(MSG_DEBUG, "WPS: Dualband AP");
 	cfg.force_per_enrollee_psk = conf->force_per_enrollee_psk;
Binary files hostapd-2016-10-15/src/common/cli.o and hostapd-2016-09-05.dd/src/common/cli.o differ
Binary files hostapd-2016-10-15/src/common/ctrl_iface_common.o and hostapd-2016-09-05.dd/src/common/ctrl_iface_common.o differ
diff -urpN hostapd-2016-10-15/src/common/hw_features_common.c hostapd-2016-09-05.dd/src/common/hw_features_common.c
--- hostapd-2016-10-15/src/common/hw_features_common.c	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/src/common/hw_features_common.c	2017-02-19 15:21:18.000000000 +0100
@@ -366,7 +366,7 @@ int hostapd_set_freq_params(struct hosta
 	data->center_freq1 = freq + sec_channel_offset * 10;
 	data->center_freq2 = 0;
 	data->bandwidth = sec_channel_offset ? 40 : 20;
-
+	wpa_printf(MSG_DEBUG,"vht: %d vhtwidth: %d seg0 %d seg1 %d mode %d, freq = %d, channel = %d, ht_enable = %d vht_enable = %d, sec_channel_offset %d width %d",data->vht_enabled, vht_oper_chwidth,center_segment0,center_segment1,mode, freq, channel,ht_enabled,vht_enabled, sec_channel_offset, vht_oper_chwidth);
 	if (data->vht_enabled) switch (vht_oper_chwidth) {
 	case VHT_CHANWIDTH_USE_HT:
 		if (center_segment1 ||
@@ -412,6 +412,7 @@ int hostapd_set_freq_params(struct hosta
 			 * HT40 channel band is in VHT80 Pri channel band
 			 * configuration.
 			 */
+			wpa_printf(MSG_DEBUG, "center segment0 = %d\n",center_segment0);
 			if (center_segment0 == channel + 6 ||
 			    center_segment0 == channel + 2 ||
 			    center_segment0 == channel - 2 ||
@@ -419,6 +420,7 @@ int hostapd_set_freq_params(struct hosta
 				data->center_freq1 = 5000 + center_segment0 * 5;
 			else
 				return -1;
+			wpa_printf(MSG_DEBUG, "center freq1 = %d\n",data->center_freq1);
 		}
 		break;
 	case VHT_CHANWIDTH_160MHZ:
@@ -429,10 +431,16 @@ int hostapd_set_freq_params(struct hosta
 				   "160MHZ channel width is not supported!");
 			return -1;
 		}
-		if (center_segment1)
+		if (center_segment1) { 
+			wpa_printf(MSG_ERROR,
+				   "center segment 1 defined");
 			return -1;
-		if (!sec_channel_offset)
+		}
+		if (!sec_channel_offset) {
+			wpa_printf(MSG_ERROR,
+				   "no second channel offset defined");
 			return -1;
+		}
 		/*
 		 * Note: HT/VHT config and params are coupled. Check if
 		 * HT40 channel band is in VHT160 channel band configuration.
@@ -446,8 +454,11 @@ int hostapd_set_freq_params(struct hosta
 		    center_segment0 == channel - 10 ||
 		    center_segment0 == channel - 14)
 			data->center_freq1 = 5000 + center_segment0 * 5;
-		else
+		else {
+			wpa_printf(MSG_ERROR,
+				   "conflict with ht40 band config (center %d == channel %d) ",center_segment0, channel);
 			return -1;
+		}
 		break;
 	}
 
Binary files hostapd-2016-10-15/src/common/hw_features_common.o and hostapd-2016-09-05.dd/src/common/hw_features_common.o differ
diff -urpN hostapd-2016-10-15/src/common/ieee802_11_common.c hostapd-2016-09-05.dd/src/common/ieee802_11_common.c
--- hostapd-2016-10-15/src/common/ieee802_11_common.c	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/src/common/ieee802_11_common.c	2017-01-25 07:30:51.000000000 +0100
@@ -579,6 +579,9 @@ int hostapd_config_wmm_ac(struct hostapd
 }
 
 
+
+
+
 enum hostapd_hw_mode ieee80211_freq_to_chan(int freq, u8 *channel)
 {
 	u8 op_class;
@@ -587,7 +590,6 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 					     &op_class, channel);
 }
 
-
 /**
  * ieee80211_freq_to_channel_ext - Convert frequency into channel info
  * for HT40 and VHT. DFS channels are not covered.
@@ -609,7 +611,7 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 	if (sec_channel > 1 || sec_channel < -1)
 		return NUM_HOSTAPD_MODES;
 
-	if (freq >= 2412 && freq <= 2472) {
+	if (freq >= 2412 && freq <= 2484) {
 		if ((freq - 2407) % 5)
 			return NUM_HOSTAPD_MODES;
 
@@ -624,6 +626,7 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 		else
 			*op_class = 81;
 
+
 		*channel = (freq - 2407) / 5;
 
 		return HOSTAPD_MODE_IEEE80211G;
@@ -639,6 +642,71 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 		return HOSTAPD_MODE_IEEE80211B;
 	}
 
+	if (freq == 2407) {
+		if (sec_channel || vht)
+			return NUM_HOSTAPD_MODES;
+
+		if (sec_channel == 1)
+			*op_class = 83;
+		else if (sec_channel == -1)
+			*op_class = 84;
+		else
+			*op_class = 81;
+		*channel = 0;
+
+		return HOSTAPD_MODE_IEEE80211B;
+	}
+
+	if (freq > 2484 && freq < 4000) {
+		if (sec_channel || vht)
+			return NUM_HOSTAPD_MODES;
+
+		if (sec_channel == 1)
+			*op_class = 83;
+		else if (sec_channel == -1)
+			*op_class = 84;
+		else
+			*op_class = 81;
+		*channel = (freq - 2414) / 5;
+
+		return HOSTAPD_MODE_IEEE80211B;
+	}
+
+
+	if (freq < 2412) {
+		if (sec_channel || vht)
+			return NUM_HOSTAPD_MODES;
+
+		if (sec_channel == 1)
+			*op_class = 83;
+		else if (sec_channel == -1)
+			*op_class = 84;
+		else
+			*op_class = 81;
+		*channel = (freq - 2407) / 5 + 256;
+
+		return HOSTAPD_MODE_IEEE80211B;
+	}
+
+
+
+	if (freq >= 4940 && freq < 4990) {
+		if ((freq - 4000) % 5)
+			return NUM_HOSTAPD_MODES;
+		*channel = (freq - 4940) * 2 + !!((freq % 5) == 2);
+		*op_class = 0; /* TODO */
+		return HOSTAPD_MODE_IEEE80211A;
+	}
+
+	if (freq >= 4800 && freq < 5005) {
+		if ((freq - 4000) % 5)
+			return NUM_HOSTAPD_MODES;
+		*channel = (freq - 4000) / 5;
+		*op_class = 0; /* TODO */
+		return HOSTAPD_MODE_IEEE80211A;
+	}
+
+
 	if (freq >= 4900 && freq < 5000) {
 		if ((freq - 4000) % 5)
 			return NUM_HOSTAPD_MODES;
@@ -721,7 +789,7 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 		return HOSTAPD_MODE_IEEE80211A;
 	}
 
-	if (freq >= 5000 && freq < 5900) {
+	if (freq >= 5000 && freq < 7000) {
 		if ((freq - 5000) % 5)
 			return NUM_HOSTAPD_MODES;
 		*channel = (freq - 5000) / 5;
@@ -743,7 +811,6 @@ enum hostapd_hw_mode ieee80211_freq_to_c
 	return NUM_HOSTAPD_MODES;
 }
 
-
 static const char *const us_op_class_cc[] = {
 	"US", "CA", NULL
 };
Binary files hostapd-2016-10-15/src/common/ieee802_11_common.o and hostapd-2016-09-05.dd/src/common/ieee802_11_common.o differ
diff -urpN hostapd-2016-10-15/src/common/wpa_common.c hostapd-2016-09-05.dd/src/common/wpa_common.c
--- hostapd-2016-10-15/src/common/wpa_common.c	2017-10-19 00:05:11.527747753 +0200
+++ hostapd-2016-09-05.dd/src/common/wpa_common.c	2017-10-17 23:49:52.000000000 +0200
@@ -69,6 +69,12 @@ int wpa_eapol_key_mic(const u8 *key, siz
 {
 	u8 hash[SHA384_MAC_LEN];
 
+	if (key_len == 0) {
+		wpa_printf(MSG_DEBUG,
+			   "WPA: KCK not set - cannot calculate MIC");
+		return -1;
+	}
+
 	switch (ver) {
 #ifndef CONFIG_FIPS
 	case WPA_KEY_INFO_TYPE_HMAC_MD5_RC4:
@@ -147,6 +153,11 @@ int wpa_pmk_to_ptk(const u8 *pmk, size_t
 	u8 tmp[WPA_KCK_MAX_LEN + WPA_KEK_MAX_LEN + WPA_TK_MAX_LEN];
 	size_t ptk_len;
 
+	if (pmk_len == 0) {
+		wpa_printf(MSG_ERROR, "WPA: No PMK set for PT derivation");
+		return -1;
+	}
+
 	if (os_memcmp(addr1, addr2, ETH_ALEN) < 0) {
 		os_memcpy(data, addr1, ETH_ALEN);
 		os_memcpy(data + ETH_ALEN, addr2, ETH_ALEN);
@@ -1218,6 +1229,31 @@ const char * wpa_key_mgmt_txt(int key_mg
 }
 
 
+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
+				 size_t rsn_ie_len)
+{
+	int pos, count;
+
+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
+	if (rsn_ie_len < pos + 2)
+		return;
+
+	count = WPA_GET_LE16(wpa_msg_ie + pos);
+	pos += 2 + count * RSN_SELECTOR_LEN;
+	if (rsn_ie_len < pos + 2)
+		return;
+
+	count = WPA_GET_LE16(wpa_msg_ie + pos);
+	pos += 2 + count * RSN_SELECTOR_LEN;
+	if (rsn_ie_len < pos + 2)
+		return;
+
+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
+}
+
+
 u32 wpa_akm_to_suite(int akm)
 {
 	if (akm & WPA_KEY_MGMT_FT_IEEE8021X)
@@ -1246,31 +1282,6 @@ u32 wpa_akm_to_suite(int akm)
 }
 
 
-static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
-				 size_t rsn_ie_len)
-{
-	int pos, count;
-
-	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
-	if (rsn_ie_len < pos + 2)
-		return;
-
-	count = WPA_GET_LE16(wpa_msg_ie + pos);
-	pos += 2 + count * RSN_SELECTOR_LEN;
-	if (rsn_ie_len < pos + 2)
-		return;
-
-	count = WPA_GET_LE16(wpa_msg_ie + pos);
-	pos += 2 + count * RSN_SELECTOR_LEN;
-	if (rsn_ie_len < pos + 2)
-		return;
-
-	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
-	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
-		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
-}
-
-
 int wpa_compare_rsn_ie(int ft_initial_assoc,
 		       const u8 *ie1, size_t ie1len,
 		       const u8 *ie2, size_t ie2len)
diff -urpN hostapd-2016-10-15/src/common/wpa_common.h hostapd-2016-09-05.dd/src/common/wpa_common.h
Binary files hostapd-2016-10-15/src/common/wpa_common.o and hostapd-2016-09-05.dd/src/common/wpa_common.o differ
Binary files hostapd-2016-10-15/src/common/wpa_ctrl.o and hostapd-2016-09-05.dd/src/common/wpa_ctrl.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-ctr.o and hostapd-2016-09-05.dd/src/crypto/aes-ctr.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-eax.o and hostapd-2016-09-05.dd/src/crypto/aes-eax.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-encblock.o and hostapd-2016-09-05.dd/src/crypto/aes-encblock.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-internal-dec.o and hostapd-2016-09-05.dd/src/crypto/aes-internal-dec.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-internal-enc.o and hostapd-2016-09-05.dd/src/crypto/aes-internal-enc.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-internal.o and hostapd-2016-09-05.dd/src/crypto/aes-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-omac1.o and hostapd-2016-09-05.dd/src/crypto/aes-omac1.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-unwrap.o and hostapd-2016-09-05.dd/src/crypto/aes-unwrap.o differ
Binary files hostapd-2016-10-15/src/crypto/aes-wrap.o and hostapd-2016-09-05.dd/src/crypto/aes-wrap.o differ
Binary files hostapd-2016-10-15/src/crypto/crypto_internal-cipher.o and hostapd-2016-09-05.dd/src/crypto/crypto_internal-cipher.o differ
Binary files hostapd-2016-10-15/src/crypto/crypto_internal-modexp.o and hostapd-2016-09-05.dd/src/crypto/crypto_internal-modexp.o differ
Binary files hostapd-2016-10-15/src/crypto/crypto_internal-rsa.o and hostapd-2016-09-05.dd/src/crypto/crypto_internal-rsa.o differ
Binary files hostapd-2016-10-15/src/crypto/crypto_internal.o and hostapd-2016-09-05.dd/src/crypto/crypto_internal.o differ
Binary files hostapd-2016-10-15/src/crypto/des-internal.o and hostapd-2016-09-05.dd/src/crypto/des-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/md4-internal.o and hostapd-2016-09-05.dd/src/crypto/md4-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/md5-internal.o and hostapd-2016-09-05.dd/src/crypto/md5-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/md5.o and hostapd-2016-09-05.dd/src/crypto/md5.o differ
Binary files hostapd-2016-10-15/src/crypto/ms_funcs.o and hostapd-2016-09-05.dd/src/crypto/ms_funcs.o differ
Binary files hostapd-2016-10-15/src/crypto/rc4.o and hostapd-2016-09-05.dd/src/crypto/rc4.o differ
Binary files hostapd-2016-10-15/src/crypto/sha1-internal.o and hostapd-2016-09-05.dd/src/crypto/sha1-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/sha1-pbkdf2.o and hostapd-2016-09-05.dd/src/crypto/sha1-pbkdf2.o differ
Binary files hostapd-2016-10-15/src/crypto/sha1-prf.o and hostapd-2016-09-05.dd/src/crypto/sha1-prf.o differ
Binary files hostapd-2016-10-15/src/crypto/sha1-tlsprf.o and hostapd-2016-09-05.dd/src/crypto/sha1-tlsprf.o differ
Binary files hostapd-2016-10-15/src/crypto/sha1-tprf.o and hostapd-2016-09-05.dd/src/crypto/sha1-tprf.o differ
Binary files hostapd-2016-10-15/src/crypto/sha1.o and hostapd-2016-09-05.dd/src/crypto/sha1.o differ
Binary files hostapd-2016-10-15/src/crypto/sha256-internal.o and hostapd-2016-09-05.dd/src/crypto/sha256-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/sha256-prf.o and hostapd-2016-09-05.dd/src/crypto/sha256-prf.o differ
Binary files hostapd-2016-10-15/src/crypto/sha256-tlsprf.o and hostapd-2016-09-05.dd/src/crypto/sha256-tlsprf.o differ
Binary files hostapd-2016-10-15/src/crypto/sha256.o and hostapd-2016-09-05.dd/src/crypto/sha256.o differ
Binary files hostapd-2016-10-15/src/crypto/sha384-internal.o and hostapd-2016-09-05.dd/src/crypto/sha384-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/sha512-internal.o and hostapd-2016-09-05.dd/src/crypto/sha512-internal.o differ
Binary files hostapd-2016-10-15/src/crypto/tls_internal.o and hostapd-2016-09-05.dd/src/crypto/tls_internal.o differ
diff -urpN hostapd-2016-10-15/src/drivers/driver.h hostapd-2016-09-05.dd/src/drivers/driver.h
--- hostapd-2016-10-15/src/drivers/driver.h	2017-10-19 00:05:11.539747598 +0200
+++ hostapd-2016-09-05.dd/src/drivers/driver.h	2017-10-18 16:51:13.000000000 +0200
@@ -4962,6 +4962,9 @@ extern const struct wpa_driver_ops wpa_d
 #ifdef CONFIG_DRIVER_HOSTAP
 extern const struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */
 #endif /* CONFIG_DRIVER_HOSTAP */
+#ifdef CONFIG_DRIVER_MADWIFI
+extern const struct wpa_driver_ops wpa_driver_madwifi_ops; /* driver_madwifi.c */
+#endif /* CONFIG_DRIVER_MADWIFI */
 #ifdef CONFIG_DRIVER_BSD
 extern const struct wpa_driver_ops wpa_driver_bsd_ops; /* driver_bsd.c */
 #endif /* CONFIG_DRIVER_BSD */
Binary files hostapd-2016-10-15/src/drivers/driver_common.o and hostapd-2016-09-05.dd/src/drivers/driver_common.o differ
diff -urpN hostapd-2016-10-15/src/drivers/driver_madwifi.c hostapd-2016-09-05.dd/src/drivers/driver_madwifi.c
--- hostapd-2016-10-15/src/drivers/driver_madwifi.c	1970-01-01 01:00:00.000000000 +0100
+++ hostapd-2016-09-05.dd/src/drivers/driver_madwifi.c	2017-10-18 16:51:13.000000000 +0200
@@ -0,0 +1,1326 @@
+/*
+ * hostapd - driver interaction with MADWIFI 802.11 driver
+ * Copyright (c) 2004, Sam Leffler <sam@errno.com>
+ * Copyright (c) 2004, Video54 Technologies
+ * Copyright (c) 2004-2007, Jouni Malinen <j@w1.fi>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ *
+ * This driver wrapper is only for hostapd AP mode functionality. Station
+ * (wpa_supplicant) operations with madwifi are supported by the driver_wext.c
+ * wrapper.
+ */
+
+#include "includes.h"
+#include <sys/ioctl.h>
+#include <asm-generic/posix_types.h>
+
+#include "common.h"
+#include "driver.h"
+#include "driver_wext.h"
+#include "eloop.h"
+#include "common/ieee802_11_defs.h"
+#include "linux_wext.h"
+
+/*
+ * Avoid conflicts with wpa_supplicant definitions by undefining a definition.
+ */
+#undef WME_OUI_TYPE
+
+#include <include/compat.h>
+#include <net80211/ieee80211.h>
+#ifdef WME_NUM_AC
+/* Assume this is built against BSD branch of madwifi driver. */
+#define MADWIFI_BSD
+#include <net80211/_ieee80211.h>
+#endif /* WME_NUM_AC */
+#include <net80211/ieee80211_crypto.h>
+#include <net80211/ieee80211_ioctl.h>
+
+#ifdef CONFIG_WPS
+#ifdef IEEE80211_IOCTL_FILTERFRAME
+#include <netpacket/packet.h>
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW 0x0019
+#endif
+#endif /* IEEE80211_IOCTL_FILTERFRAME */
+#endif /* CONFIG_WPS */
+
+/*
+ * Avoid conflicts with hostapd definitions by undefining couple of defines
+ * from madwifi header files.
+ */
+#undef RSN_VERSION
+#undef WPA_VERSION
+#undef WPA_OUI_TYPE
+#undef WME_OUI_TYPE
+
+
+#ifdef IEEE80211_IOCTL_SETWMMPARAMS
+/* Assume this is built against madwifi-ng */
+#define MADWIFI_NG
+#endif /* IEEE80211_IOCTL_SETWMMPARAMS */
+
+#define WPA_KEY_RSC_LEN 8
+
+#include "priv_netlink.h"
+#include "netlink.h"
+#include "linux_ioctl.h"
+#include "l2_packet/l2_packet.h"
+
+
+struct madwifi_driver_data {
+	struct hostapd_data *hapd;		/* back pointer */
+
+	char	iface[IFNAMSIZ + 1];
+	int     ifindex;
+	struct l2_packet_data *sock_xmit;	/* raw packet xmit socket */
+	struct l2_packet_data *sock_recv;	/* raw packet recv socket */
+	int	ioctl_sock;			/* socket for ioctl() use */
+	struct netlink_data *netlink;
+	int	we_version;
+	u8	acct_mac[ETH_ALEN];
+	struct hostap_sta_driver_data acct_data;
+
+	struct l2_packet_data *sock_raw; /* raw 802.11 management frames */
+};
+
+static int madwifi_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
+			      int reason_code);
+
+static int
+set80211priv(struct madwifi_driver_data *drv, int op, void *data, int len)
+{
+	struct iwreq iwr;
+	int do_inline = len < IFNAMSIZ;
+
+	memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+#ifdef IEEE80211_IOCTL_FILTERFRAME
+	/* FILTERFRAME must be NOT inline, regardless of size. */
+	if (op == IEEE80211_IOCTL_FILTERFRAME)
+		do_inline = 0;
+#endif /* IEEE80211_IOCTL_FILTERFRAME */
+	if (op == IEEE80211_IOCTL_SET_APPIEBUF)
+		do_inline = 0;
+	if (do_inline) {
+		/*
+		 * Argument data fits inline; put it there.
+		 */
+		memcpy(iwr.u.name, data, len);
+	} else {
+		/*
+		 * Argument data too big for inline transfer; setup a
+		 * parameter block instead; the kernel will transfer
+		 * the data for the driver.
+		 */
+		iwr.u.data.pointer = data;
+		iwr.u.data.length = len;
+	}
+
+	if (ioctl(drv->ioctl_sock, op, &iwr) < 0) {
+#ifdef MADWIFI_NG
+		int first = IEEE80211_IOCTL_SETPARAM;
+		static const char *opnames[] = {
+			"ioctl[IEEE80211_IOCTL_SETPARAM]",
+			"ioctl[IEEE80211_IOCTL_GETPARAM]",
+			"ioctl[IEEE80211_IOCTL_SETMODE]",
+			"ioctl[IEEE80211_IOCTL_GETMODE]",
+			"ioctl[IEEE80211_IOCTL_SETWMMPARAMS]",
+			"ioctl[IEEE80211_IOCTL_GETWMMPARAMS]",
+			"ioctl[IEEE80211_IOCTL_SETCHANLIST]",
+			"ioctl[IEEE80211_IOCTL_GETCHANLIST]",
+			"ioctl[IEEE80211_IOCTL_CHANSWITCH]",
+			"ioctl[IEEE80211_IOCTL_GET_APPIEBUF]",
+			"ioctl[IEEE80211_IOCTL_SET_APPIEBUF]",
+			"ioctl[IEEE80211_IOCTL_GETSCANRESULTS]",
+			"ioctl[IEEE80211_IOCTL_FILTERFRAME]",
+			"ioctl[IEEE80211_IOCTL_GETCHANINFO]",
+			"ioctl[IEEE80211_IOCTL_SETOPTIE]",
+			"ioctl[IEEE80211_IOCTL_GETOPTIE]",
+			"ioctl[IEEE80211_IOCTL_SETMLME]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_SETKEY]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_DELKEY]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_ADDMAC]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_DELMAC]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_WDSMAC]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_WDSDELMAC]",
+			NULL,
+			"ioctl[IEEE80211_IOCTL_KICKMAC]",
+		};
+#else /* MADWIFI_NG */
+		int first = IEEE80211_IOCTL_SETPARAM;
+		static const char *opnames[] = {
+			"ioctl[IEEE80211_IOCTL_SETPARAM]",
+			"ioctl[IEEE80211_IOCTL_GETPARAM]",
+			"ioctl[IEEE80211_IOCTL_SETKEY]",
+			"ioctl[SIOCIWFIRSTPRIV+3]",
+			"ioctl[IEEE80211_IOCTL_DELKEY]",
+			"ioctl[SIOCIWFIRSTPRIV+5]",
+			"ioctl[IEEE80211_IOCTL_SETMLME]",
+			"ioctl[SIOCIWFIRSTPRIV+7]",
+			"ioctl[IEEE80211_IOCTL_SETOPTIE]",
+			"ioctl[IEEE80211_IOCTL_GETOPTIE]",
+			"ioctl[IEEE80211_IOCTL_ADDMAC]",
+			"ioctl[SIOCIWFIRSTPRIV+11]",
+			"ioctl[IEEE80211_IOCTL_DELMAC]",
+			"ioctl[SIOCIWFIRSTPRIV+13]",
+			"ioctl[IEEE80211_IOCTL_CHANLIST]",
+			"ioctl[SIOCIWFIRSTPRIV+15]",
+			"ioctl[IEEE80211_IOCTL_GETRSN]",
+			"ioctl[SIOCIWFIRSTPRIV+17]",
+			"ioctl[IEEE80211_IOCTL_GETKEY]",
+		};
+#endif /* MADWIFI_NG */
+		int idx = op - first;
+		if (first <= op &&
+		    idx < (int) ARRAY_SIZE(opnames) &&
+		    opnames[idx])
+			perror(opnames[idx]);
+		else
+			perror("ioctl[unknown???]");
+		return -1;
+	}
+	return 0;
+}
+
+static int
+set80211param(struct madwifi_driver_data *drv, int op, int arg)
+{
+	struct iwreq iwr;
+
+	memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.mode = op;
+	memcpy(iwr.u.name+sizeof(__u32), &arg, sizeof(arg));
+
+	if (ioctl(drv->ioctl_sock, IEEE80211_IOCTL_SETPARAM, &iwr) < 0) {
+		perror("ioctl[IEEE80211_IOCTL_SETPARAM]");
+		wpa_printf(MSG_DEBUG, "%s: Failed to set parameter (op %d "
+			   "arg %d)", __func__, op, arg);
+		return -1;
+	}
+	return 0;
+}
+
+#ifndef CONFIG_NO_STDOUT_DEBUG
+static const char *
+ether_sprintf(const u8 *addr)
+{
+	static char buf[sizeof(MACSTR)];
+
+	if (addr != NULL)
+		snprintf(buf, sizeof(buf), MACSTR, MAC2STR(addr));
+	else
+		snprintf(buf, sizeof(buf), MACSTR, 0,0,0,0,0,0);
+	return buf;
+}
+#endif /* CONFIG_NO_STDOUT_DEBUG */
+
+/*
+ * Configure WPA parameters.
+ */
+static int
+madwifi_configure_wpa(struct madwifi_driver_data *drv,
+		      struct wpa_bss_params *params)
+{
+	int v;
+
+	switch (params->wpa_group) {
+	case WPA_CIPHER_CCMP:
+		v = IEEE80211_CIPHER_AES_CCM;
+		break;
+	case WPA_CIPHER_TKIP:
+		v = IEEE80211_CIPHER_TKIP;
+		break;
+	case WPA_CIPHER_WEP104:
+		v = IEEE80211_CIPHER_WEP;
+		break;
+	case WPA_CIPHER_WEP40:
+		v = IEEE80211_CIPHER_WEP;
+		break;
+	case WPA_CIPHER_NONE:
+		v = IEEE80211_CIPHER_NONE;
+		break;
+	default:
+		wpa_printf(MSG_ERROR, "Unknown group key cipher %u",
+			   params->wpa_group);
+		return -1;
+	}
+	wpa_printf(MSG_DEBUG, "%s: group key cipher=%d", __func__, v);
+	if (set80211param(drv, IEEE80211_PARAM_MCASTCIPHER, v)) {
+		printf("Unable to set group key cipher to %u\n", v);
+		return -1;
+	}
+	if (v == IEEE80211_CIPHER_WEP) {
+		/* key length is done only for specific ciphers */
+		v = (params->wpa_group == WPA_CIPHER_WEP104 ? 13 : 5);
+		if (set80211param(drv, IEEE80211_PARAM_MCASTKEYLEN, v)) {
+			printf("Unable to set group key length to %u\n", v);
+			return -1;
+		}
+	}
+
+	v = 0;
+	if (params->wpa_pairwise & WPA_CIPHER_CCMP)
+		v |= 1<<IEEE80211_CIPHER_AES_CCM;
+	if (params->wpa_pairwise & WPA_CIPHER_TKIP)
+		v |= 1<<IEEE80211_CIPHER_TKIP;
+	if (params->wpa_pairwise & WPA_CIPHER_NONE)
+		v |= 1<<IEEE80211_CIPHER_NONE;
+	wpa_printf(MSG_DEBUG, "%s: pairwise key ciphers=0x%x", __func__, v);
+	if (set80211param(drv, IEEE80211_PARAM_UCASTCIPHERS, v)) {
+		printf("Unable to set pairwise key ciphers to 0x%x\n", v);
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "%s: key management algorithms=0x%x",
+		   __func__, params->wpa_key_mgmt);
+	if (set80211param(drv, IEEE80211_PARAM_KEYMGTALGS,
+			  params->wpa_key_mgmt)) {
+		printf("Unable to set key management algorithms to 0x%x\n",
+			params->wpa_key_mgmt);
+		return -1;
+	}
+
+	v = 0;
+	if (params->rsn_preauth)
+		v |= BIT(0);
+	wpa_printf(MSG_DEBUG, "%s: rsn capabilities=0x%x",
+		   __func__, params->rsn_preauth);
+	if (set80211param(drv, IEEE80211_PARAM_RSNCAPS, v)) {
+		printf("Unable to set RSN capabilities to 0x%x\n", v);
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "%s: enable WPA=0x%x", __func__, params->wpa);
+	if (set80211param(drv, IEEE80211_PARAM_WPA, params->wpa)) {
+		printf("Unable to set WPA to %u\n", params->wpa);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+madwifi_set_ieee8021x(void *priv, struct wpa_bss_params *params)
+{
+	struct madwifi_driver_data *drv = priv;
+
+	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __func__, params->enabled);
+
+	if (!params->enabled) {
+		/* XXX restore state */
+		return set80211param(priv, IEEE80211_PARAM_AUTHMODE,
+			IEEE80211_AUTH_AUTO);
+	}
+	if (!params->wpa && !params->ieee802_1x) {
+		wpa_printf(MSG_WARNING, "No 802.1X or WPA enabled!");
+		return -1;
+	}
+	if (params->wpa && madwifi_configure_wpa(drv, params) != 0) {
+		wpa_printf(MSG_WARNING, "Error configuring WPA state!");
+		return -1;
+	}
+	if (set80211param(priv, IEEE80211_PARAM_AUTHMODE,
+		(params->wpa ? IEEE80211_AUTH_WPA : IEEE80211_AUTH_8021X))) {
+		wpa_printf(MSG_WARNING, "Error enabling WPA/802.1X!");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+madwifi_set_privacy(void *priv, int enabled)
+{
+	struct madwifi_driver_data *drv = priv;
+
+	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __func__, enabled);
+
+	return set80211param(drv, IEEE80211_PARAM_PRIVACY, enabled);
+}
+
+static int
+madwifi_set_sta_authorized(void *priv, const u8 *addr, int authorized)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_mlme mlme;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s: addr=%s authorized=%d",
+		   __func__, ether_sprintf(addr), authorized);
+
+	if (authorized)
+		mlme.im_op = IEEE80211_MLME_AUTHORIZE;
+	else
+		mlme.im_op = IEEE80211_MLME_UNAUTHORIZE;
+	mlme.im_reason = 0;
+	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
+	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to %sauthorize STA " MACSTR,
+			   __func__, authorized ? "" : "un", MAC2STR(addr));
+	}
+
+	return ret;
+}
+
+static int
+madwifi_sta_set_flags(void *priv, const u8 *addr,
+		      unsigned int total_flags, unsigned int flags_or, unsigned int flags_and)
+{
+	/* For now, only support setting Authorized flag */
+	if (flags_or & WPA_STA_AUTHORIZED)
+		return madwifi_set_sta_authorized(priv, addr, 1);
+	if (!(flags_and & WPA_STA_AUTHORIZED))
+		return madwifi_set_sta_authorized(priv, addr, 0);
+	return 0;
+}
+
+static int
+madwifi_del_key(void *priv, const u8 *addr, int key_idx)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_del_key wk;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s: addr=%s key_idx=%d",
+		   __func__, ether_sprintf(addr), key_idx);
+
+	memset(&wk, 0, sizeof(wk));
+	if (addr != NULL) {
+		memcpy(wk.idk_macaddr, addr, IEEE80211_ADDR_LEN);
+		wk.idk_keyix = (u8) IEEE80211_KEYIX_NONE;
+	} else {
+		wk.idk_keyix = key_idx;
+	}
+
+	ret = set80211priv(drv, IEEE80211_IOCTL_DELKEY, &wk, sizeof(wk));
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to delete key (addr %s"
+			   " key_idx %d)", __func__, ether_sprintf(addr),
+			   key_idx);
+	}
+
+	return ret;
+}
+
+static int
+wpa_driver_madwifi_set_key(const char *ifname, void *priv, enum wpa_alg alg,
+			   const u8 *addr, int key_idx, int set_tx,
+			   const u8 *seq, size_t seq_len,
+			   const u8 *key, size_t key_len)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_key wk;
+	u_int8_t cipher;
+	int ret;
+
+	if (alg == WPA_ALG_NONE)
+		return madwifi_del_key(drv, addr, key_idx);
+
+	wpa_printf(MSG_DEBUG, "%s: alg=%d addr=%s key_idx=%d",
+		   __func__, alg, ether_sprintf(addr), key_idx);
+
+	if (alg == WPA_ALG_WEP)
+		cipher = IEEE80211_CIPHER_WEP;
+	else if (alg == WPA_ALG_TKIP)
+		cipher = IEEE80211_CIPHER_TKIP;
+	else if (alg == WPA_ALG_CCMP)
+		cipher = IEEE80211_CIPHER_AES_CCM;
+	else {
+		printf("%s: unknown/unsupported algorithm %d\n",
+			__func__, alg);
+		return -1;
+	}
+
+	if (key_len > sizeof(wk.ik_keydata)) {
+		printf("%s: key length %lu too big\n", __func__,
+		       (unsigned long) key_len);
+		return -3;
+	}
+
+	memset(&wk, 0, sizeof(wk));
+	wk.ik_type = cipher;
+	wk.ik_flags = IEEE80211_KEY_RECV;
+	if (set_tx)
+		wk.ik_flags |= IEEE80211_KEY_XMIT;
+	if (addr == NULL || is_broadcast_ether_addr(addr)) {
+		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
+		wk.ik_keyix = key_idx;
+		wk.ik_flags |= IEEE80211_KEY_DEFAULT;
+	} else {
+		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
+		wk.ik_keyix = IEEE80211_KEYIX_NONE;
+	}
+	wk.ik_keylen = key_len;
+	memcpy(wk.ik_keydata, key, key_len);
+
+#ifdef WORDS_BIGENDIAN
+#define WPA_KEY_RSC_LEN 8
+	{
+		size_t i;
+		u8 tmp[WPA_KEY_RSC_LEN];
+		os_memset(tmp, 0, sizeof(tmp));
+		for (i = 0; i < seq_len; i++)
+			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
+		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
+	}
+#else /* WORDS_BIGENDIAN */
+	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
+#endif /* WORDS_BIGENDIAN */
+
+	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
+			   " key_idx %d alg %d key_len %lu set_tx %d)",
+			   __func__, ether_sprintf(wk.ik_macaddr), key_idx,
+			   alg, (unsigned long) key_len, set_tx);
+	}
+
+	return ret;
+}
+
+
+static int
+madwifi_get_seqnum(const char *ifname, void *priv, const u8 *addr, int idx,
+		   u8 *seq)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_key wk;
+
+	wpa_printf(MSG_DEBUG, "%s: addr=%s idx=%d",
+		   __func__, ether_sprintf(addr), idx);
+
+	memset(&wk, 0, sizeof(wk));
+	if (addr == NULL)
+		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
+	else
+		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
+	wk.ik_keyix = idx;
+
+	if (set80211priv(drv, IEEE80211_IOCTL_GETKEY, &wk, sizeof(wk))) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to get encryption data "
+			   "(addr " MACSTR " key_idx %d)",
+			   __func__, MAC2STR(wk.ik_macaddr), idx);
+		return -1;
+	}
+
+#ifdef WORDS_BIGENDIAN
+	{
+		/*
+		 * wk.ik_keytsc is in host byte order (big endian), need to
+		 * swap it to match with the byte order used in WPA.
+		 */
+		int i;
+		u8 tmp[WPA_KEY_RSC_LEN];
+		memcpy(tmp, &wk.ik_keytsc, sizeof(wk.ik_keytsc));
+		for (i = 0; i < WPA_KEY_RSC_LEN; i++) {
+			seq[i] = tmp[WPA_KEY_RSC_LEN - i - 1];
+		}
+	}
+#else /* WORDS_BIGENDIAN */
+	memcpy(seq, &wk.ik_keytsc, sizeof(wk.ik_keytsc));
+#endif /* WORDS_BIGENDIAN */
+	return 0;
+}
+
+
+static int 
+madwifi_flush(void *priv)
+{
+#ifdef MADWIFI_BSD
+	u8 allsta[IEEE80211_ADDR_LEN];
+	memset(allsta, 0xff, IEEE80211_ADDR_LEN);
+	return madwifi_sta_deauth(priv, NULL, allsta,
+				  IEEE80211_REASON_AUTH_LEAVE);
+#else /* MADWIFI_BSD */
+	return 0;		/* XXX */
+#endif /* MADWIFI_BSD */
+}
+
+
+static int
+madwifi_read_sta_driver_data(void *priv, struct hostap_sta_driver_data *data,
+			     const u8 *addr)
+{
+	struct madwifi_driver_data *drv = priv;
+
+#ifdef MADWIFI_BSD
+	struct ieee80211req_sta_stats stats;
+
+	memset(data, 0, sizeof(*data));
+
+	/*
+	 * Fetch statistics for station from the system.
+	 */
+	memset(&stats, 0, sizeof(stats));
+	memcpy(stats.is_u.macaddr, addr, IEEE80211_ADDR_LEN);
+	if (set80211priv(drv,
+#ifdef MADWIFI_NG
+			 IEEE80211_IOCTL_STA_STATS,
+#else /* MADWIFI_NG */
+			 IEEE80211_IOCTL_GETSTASTATS,
+#endif /* MADWIFI_NG */
+			 &stats, sizeof(stats))) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to fetch STA stats (addr "
+			   MACSTR ")", __func__, MAC2STR(addr));
+		if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
+			memcpy(data, &drv->acct_data, sizeof(*data));
+			return 0;
+		}
+
+		printf("Failed to get station stats information element.\n");
+		return -1;
+	}
+
+	data->rx_packets = stats.is_stats.ns_rx_data;
+	data->rx_bytes = stats.is_stats.ns_rx_bytes;
+	data->tx_packets = stats.is_stats.ns_tx_data;
+	data->tx_bytes = stats.is_stats.ns_tx_bytes;
+	return 0;
+
+#else /* MADWIFI_BSD */
+
+	char buf[1024], line[128], *pos;
+	FILE *f;
+	unsigned long val;
+
+	memset(data, 0, sizeof(*data));
+	snprintf(buf, sizeof(buf), "/proc/net/madwifi/%s/" MACSTR,
+		 drv->iface, MAC2STR(addr));
+
+	f = fopen(buf, "r");
+	if (!f) {
+		if (memcmp(addr, drv->acct_mac, ETH_ALEN) != 0)
+			return -1;
+		memcpy(data, &drv->acct_data, sizeof(*data));
+		return 0;
+	}
+	/* Need to read proc file with in one piece, so use large enough
+	 * buffer. */
+	setbuffer(f, buf, sizeof(buf));
+
+	while (fgets(line, sizeof(line), f)) {
+		pos = strchr(line, '=');
+		if (!pos)
+			continue;
+		*pos++ = '\0';
+		val = strtoul(pos, NULL, 10);
+		if (strcmp(line, "rx_packets") == 0)
+			data->rx_packets = val;
+		else if (strcmp(line, "tx_packets") == 0)
+			data->tx_packets = val;
+		else if (strcmp(line, "rx_bytes") == 0)
+			data->rx_bytes = val;
+		else if (strcmp(line, "tx_bytes") == 0)
+			data->tx_bytes = val;
+	}
+
+	fclose(f);
+
+	return 0;
+#endif /* MADWIFI_BSD */
+}
+
+
+static int
+madwifi_sta_clear_stats(void *priv, const u8 *addr)
+{
+#if defined(MADWIFI_BSD) && defined(IEEE80211_MLME_CLEAR_STATS)
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_mlme mlme;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s: addr=%s", __func__, ether_sprintf(addr));
+
+	mlme.im_op = IEEE80211_MLME_CLEAR_STATS;
+	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
+	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme,
+			   sizeof(mlme));
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to clear STA stats (addr "
+			   MACSTR ")", __func__, MAC2STR(addr));
+	}
+
+	return ret;
+#else /* MADWIFI_BSD && IEEE80211_MLME_CLEAR_STATS */
+	return 0; /* FIX */
+#endif /* MADWIFI_BSD && IEEE80211_MLME_CLEAR_STATS */
+}
+
+
+static int
+madwifi_set_opt_ie(void *priv, const u8 *ie, size_t ie_len)
+{
+	/*
+	 * Do nothing; we setup parameters at startup that define the
+	 * contents of the beacon information element.
+	 */
+	return 0;
+}
+
+static int
+madwifi_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
+		   int reason_code)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_mlme mlme;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s: addr=%s reason_code=%d",
+		   __func__, ether_sprintf(addr), reason_code);
+
+	mlme.im_op = IEEE80211_MLME_DEAUTH;
+	mlme.im_reason = reason_code;
+	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
+	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to deauth STA (addr " MACSTR
+			   " reason %d)",
+			   __func__, MAC2STR(addr), reason_code);
+	}
+
+	return ret;
+}
+
+static int
+madwifi_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
+		     int reason_code)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct ieee80211req_mlme mlme;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s: addr=%s reason_code=%d",
+		   __func__, ether_sprintf(addr), reason_code);
+
+	mlme.im_op = IEEE80211_MLME_DISASSOC;
+	mlme.im_reason = reason_code;
+	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
+	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to disassoc STA (addr "
+			   MACSTR " reason %d)",
+			   __func__, MAC2STR(addr), reason_code);
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_WPS
+#ifdef IEEE80211_IOCTL_FILTERFRAME
+static void madwifi_raw_receive(void *ctx, const u8 *src_addr, const u8 *buf,
+				size_t len)
+{
+	struct madwifi_driver_data *drv = ctx;
+	const struct ieee80211_mgmt *mgmt;
+	u16 fc;
+	union wpa_event_data event;
+
+	/* Send Probe Request information to WPS processing */
+
+	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req))
+		return;
+	mgmt = (const struct ieee80211_mgmt *) buf;
+
+	fc = le_to_host16(mgmt->frame_control);
+	if (WLAN_FC_GET_TYPE(fc) != WLAN_FC_TYPE_MGMT ||
+	    WLAN_FC_GET_STYPE(fc) != WLAN_FC_STYPE_PROBE_REQ)
+		return;
+
+	os_memset(&event, 0, sizeof(event));
+	event.rx_probe_req.sa = mgmt->sa;
+	event.rx_probe_req.da = mgmt->da;
+	event.rx_probe_req.bssid = mgmt->bssid;
+	event.rx_probe_req.ie = mgmt->u.probe_req.variable;
+	event.rx_probe_req.ie_len =
+		len - (IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req));
+	wpa_supplicant_event(drv->hapd, EVENT_RX_PROBE_REQ, &event);
+}
+#endif /* IEEE80211_IOCTL_FILTERFRAME */
+#endif /* CONFIG_WPS */
+
+static int madwifi_receive_probe_req(struct madwifi_driver_data *drv)
+{
+	int ret = 0;
+#ifdef CONFIG_WPS
+#ifdef IEEE80211_IOCTL_FILTERFRAME
+	struct ieee80211req_set_filter filt;
+
+	wpa_printf(MSG_DEBUG, "%s Enter", __func__);
+	filt.app_filterype = IEEE80211_FILTER_TYPE_PROBE_REQ;
+
+	ret = set80211priv(drv, IEEE80211_IOCTL_FILTERFRAME, &filt,
+			   sizeof(struct ieee80211req_set_filter));
+	if (ret)
+		return ret;
+
+	drv->sock_raw = l2_packet_init(drv->iface, NULL, ETH_P_80211_RAW,
+				       madwifi_raw_receive, drv, 1);
+	if (drv->sock_raw == NULL)
+		return -1;
+#endif /* IEEE80211_IOCTL_FILTERFRAME */
+#endif /* CONFIG_WPS */
+	return ret;
+}
+
+#ifdef CONFIG_WPS
+static int
+madwifi_set_wps_ie(void *priv, const u8 *ie, size_t len, u32 frametype)
+{
+	struct madwifi_driver_data *drv = priv;
+	u8 buf[256];
+	struct ieee80211req_getset_appiebuf *beac_ie;
+
+	wpa_printf(MSG_DEBUG, "%s buflen = %lu", __func__,
+		   (unsigned long) len);
+
+	beac_ie = (struct ieee80211req_getset_appiebuf *) buf;
+	beac_ie->app_frmtype = frametype;
+	beac_ie->app_buflen = len;
+	memcpy(&(beac_ie->app_buf[0]), ie, len);
+
+	return set80211priv(drv, IEEE80211_IOCTL_SET_APPIEBUF, beac_ie,
+			    sizeof(struct ieee80211req_getset_appiebuf) + len);
+}
+
+static int
+madwifi_set_ap_wps_ie(void *priv, const struct wpabuf *beacon,
+		      const struct wpabuf *proberesp,
+		      const struct wpabuf *assocresp)
+{
+	if (madwifi_set_wps_ie(priv, beacon ? wpabuf_head(beacon) : NULL,
+			       beacon ? wpabuf_len(beacon) : 0,
+			       IEEE80211_APPIE_FRAME_BEACON) < 0)
+		return -1;
+	return madwifi_set_wps_ie(priv,
+				  proberesp ? wpabuf_head(proberesp) : NULL,
+				  proberesp ? wpabuf_len(proberesp) : 0,
+				  IEEE80211_APPIE_FRAME_PROBE_RESP);
+}
+#else /* CONFIG_WPS */
+#define madwifi_set_ap_wps_ie NULL
+#endif /* CONFIG_WPS */
+
+static int madwifi_set_freq(void *priv, struct hostapd_freq_params *freq)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct iwreq iwr;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.freq.m = freq->channel;
+	iwr.u.freq.e = 0;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWFREQ, &iwr) < 0) {
+		perror("ioctl[SIOCSIWFREQ]");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void
+madwifi_new_sta(struct madwifi_driver_data *drv, u8 addr[IEEE80211_ADDR_LEN])
+{
+	struct hostapd_data *hapd = drv->hapd;
+	struct ieee80211req_wpaie ie;
+	int ielen = 0;
+	u8 *iebuf = NULL;
+
+	/*
+	 * Fetch negotiated WPA/RSN parameters from the system.
+	 */
+	memset(&ie, 0, sizeof(ie));
+	memcpy(ie.wpa_macaddr, addr, IEEE80211_ADDR_LEN);
+	if (set80211priv(drv, IEEE80211_IOCTL_GETWPAIE, &ie, sizeof(ie))) {
+		wpa_printf(MSG_DEBUG, "%s: Failed to get WPA/RSN IE",
+			   __func__);
+		goto no_ie;
+	}
+	wpa_hexdump(MSG_MSGDUMP, "madwifi req WPA IE",
+		    ie.wpa_ie, IEEE80211_MAX_OPT_IE);
+	iebuf = ie.wpa_ie;
+	/* madwifi seems to return some random data if WPA/RSN IE is not set.
+	 * Assume the IE was not included if the IE type is unknown. */
+	if (iebuf[0] != WLAN_EID_VENDOR_SPECIFIC)
+		iebuf[1] = 0;
+#ifdef MADWIFI_NG
+	wpa_hexdump(MSG_MSGDUMP, "madwifi req RSN IE",
+		    ie.rsn_ie, IEEE80211_MAX_OPT_IE);
+	if (iebuf[1] == 0 && ie.rsn_ie[1] > 0) {
+		/* madwifi-ng svn #1453 added rsn_ie. Use it, if wpa_ie was not
+		 * set. This is needed for WPA2. */
+		iebuf = ie.rsn_ie;
+		if (iebuf[0] != WLAN_EID_RSN)
+			iebuf[1] = 0;
+	}
+#endif /* MADWIFI_NG */
+
+	ielen = iebuf[1];
+	if (ielen == 0)
+		iebuf = NULL;
+	else
+		ielen += 2;
+
+no_ie:
+	drv_event_assoc(hapd, addr, iebuf, ielen, 0);
+
+	if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
+		/* Cached accounting data is not valid anymore. */
+		memset(drv->acct_mac, 0, ETH_ALEN);
+		memset(&drv->acct_data, 0, sizeof(drv->acct_data));
+	}
+}
+
+static void
+madwifi_wireless_event_wireless_custom(struct madwifi_driver_data *drv,
+				       char *custom)
+{
+	wpa_printf(MSG_DEBUG, "Custom wireless event: '%s'", custom);
+
+	if (strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
+		char *pos;
+		u8 addr[ETH_ALEN];
+		pos = strstr(custom, "addr=");
+		if (pos == NULL) {
+			wpa_printf(MSG_DEBUG,
+				   "MLME-MICHAELMICFAILURE.indication "
+				   "without sender address ignored");
+			return;
+		}
+		pos += 5;
+		if (hwaddr_aton(pos, addr) == 0) {
+			union wpa_event_data data;
+			os_memset(&data, 0, sizeof(data));
+			data.michael_mic_failure.unicast = 1;
+			data.michael_mic_failure.src = addr;
+			wpa_supplicant_event(drv->hapd,
+					     EVENT_MICHAEL_MIC_FAILURE, &data);
+		} else {
+			wpa_printf(MSG_DEBUG,
+				   "MLME-MICHAELMICFAILURE.indication "
+				   "with invalid MAC address");
+		}
+	} else if (strncmp(custom, "STA-TRAFFIC-STAT", 16) == 0) {
+		char *key, *value;
+		u32 val;
+		key = custom;
+		while ((key = strchr(key, '\n')) != NULL) {
+			key++;
+			value = strchr(key, '=');
+			if (value == NULL)
+				continue;
+			*value++ = '\0';
+			val = strtoul(value, NULL, 10);
+			if (strcmp(key, "mac") == 0)
+				hwaddr_aton(value, drv->acct_mac);
+			else if (strcmp(key, "rx_packets") == 0)
+				drv->acct_data.rx_packets = val;
+			else if (strcmp(key, "tx_packets") == 0)
+				drv->acct_data.tx_packets = val;
+			else if (strcmp(key, "rx_bytes") == 0)
+				drv->acct_data.rx_bytes = val;
+			else if (strcmp(key, "tx_bytes") == 0)
+				drv->acct_data.tx_bytes = val;
+			key = value;
+		}
+	}
+}
+
+static void
+madwifi_wireless_event_wireless(struct madwifi_driver_data *drv,
+					    char *data, int len)
+{
+	struct iw_event iwe_buf, *iwe = &iwe_buf;
+	char *pos, *end, *custom, *buf;
+
+	pos = data;
+	end = data + len;
+
+	while (pos + IW_EV_LCP_LEN <= end) {
+		/* Event data may be unaligned, so make a local, aligned copy
+		 * before processing. */
+		memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
+		wpa_printf(MSG_MSGDUMP, "Wireless event: cmd=0x%x len=%d",
+			   iwe->cmd, iwe->len);
+		if (iwe->len <= IW_EV_LCP_LEN)
+			return;
+
+		custom = pos + IW_EV_POINT_LEN;
+		if (drv->we_version > 18 &&
+		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
+		     iwe->cmd == IWEVCUSTOM)) {
+			/* WE-19 removed the pointer from struct iw_point */
+			char *dpos = (char *) &iwe_buf.u.data.length;
+			int dlen = dpos - (char *) &iwe_buf;
+			memcpy(dpos, pos + IW_EV_LCP_LEN,
+			       sizeof(struct iw_event) - dlen);
+		} else {
+			memcpy(&iwe_buf, pos, sizeof(struct iw_event));
+			custom += IW_EV_POINT_OFF;
+		}
+
+		switch (iwe->cmd) {
+		case IWEVEXPIRED:
+			drv_event_disassoc(drv->hapd,
+					   (u8 *) iwe->u.addr.sa_data);
+			break;
+		case IWEVREGISTERED:
+			madwifi_new_sta(drv, (u8 *) iwe->u.addr.sa_data);
+			break;
+		case IWEVCUSTOM:
+			if (custom + iwe->u.data.length > end)
+				return;
+			buf = malloc(iwe->u.data.length + 1);
+			if (buf == NULL)
+				return;		/* XXX */
+			memcpy(buf, custom, iwe->u.data.length);
+			buf[iwe->u.data.length] = '\0';
+			madwifi_wireless_event_wireless_custom(drv, buf);
+			free(buf);
+			break;
+		}
+
+		pos += iwe->len;
+	}
+}
+
+
+static void
+madwifi_wireless_event_rtm_newlink(void *ctx, struct ifinfomsg *ifi,
+				   u8 *buf, size_t len)
+{
+	struct madwifi_driver_data *drv = ctx;
+	int attrlen, rta_len;
+	struct rtattr *attr;
+
+	if (ifi->ifi_index != drv->ifindex)
+		return;
+
+	attrlen = len;
+	attr = (struct rtattr *) buf;
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_WIRELESS) {
+			madwifi_wireless_event_wireless(
+				drv, ((char *) attr) + rta_len,
+				attr->rta_len - rta_len);
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+}
+
+
+static int
+madwifi_get_we_version(struct madwifi_driver_data *drv)
+{
+	struct iw_range *range;
+	struct iwreq iwr;
+	int minlen;
+	size_t buflen;
+
+	drv->we_version = 0;
+
+	/*
+	 * Use larger buffer than struct iw_range in order to allow the
+	 * structure to grow in the future.
+	 */
+	buflen = sizeof(struct iw_range) + 500;
+	range = os_zalloc(buflen);
+	if (range == NULL)
+		return -1;
+
+	memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) range;
+	iwr.u.data.length = buflen;
+
+	minlen = ((char *) &range->enc_capa) - (char *) range +
+		sizeof(range->enc_capa);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWRANGE]");
+		free(range);
+		return -1;
+	} else if (iwr.u.data.length >= minlen &&
+		   range->we_version_compiled >= 18) {
+		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
+			   "WE(source)=%d enc_capa=0x%x",
+			   range->we_version_compiled,
+			   range->we_version_source,
+			   range->enc_capa);
+		drv->we_version = range->we_version_compiled;
+	}
+
+	free(range);
+	return 0;
+}
+
+
+static int
+madwifi_wireless_event_init(struct madwifi_driver_data *drv)
+{
+	struct netlink_config *cfg;
+
+	madwifi_get_we_version(drv);
+
+	cfg = os_zalloc(sizeof(*cfg));
+	if (cfg == NULL)
+		return -1;
+	cfg->ctx = drv;
+	cfg->newlink_cb = madwifi_wireless_event_rtm_newlink;
+	drv->netlink = netlink_init(cfg);
+	if (drv->netlink == NULL) {
+		os_free(cfg);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int
+madwifi_send_eapol(void *priv, const u8 *addr, const u8 *data, size_t data_len,
+		   int encrypt, const u8 *own_addr, u32 flags)
+{
+	struct madwifi_driver_data *drv = priv;
+	unsigned char buf[3000];
+	unsigned char *bp = buf;
+	struct l2_ethhdr *eth;
+	size_t len;
+	int status;
+
+	/*
+	 * Prepend the Ethernet header.  If the caller left us
+	 * space at the front we could just insert it but since
+	 * we don't know we copy to a local buffer.  Given the frequency
+	 * and size of frames this probably doesn't matter.
+	 */
+	len = data_len + sizeof(struct l2_ethhdr);
+	if (len > sizeof(buf)) {
+		bp = malloc(len);
+		if (bp == NULL) {
+			printf("EAPOL frame discarded, cannot malloc temp "
+			       "buffer of size %lu!\n", (unsigned long) len);
+			return -1;
+		}
+	}
+	eth = (struct l2_ethhdr *) bp;
+	memcpy(eth->h_dest, addr, ETH_ALEN);
+	memcpy(eth->h_source, own_addr, ETH_ALEN);
+	eth->h_proto = host_to_be16(ETH_P_EAPOL);
+	memcpy(eth+1, data, data_len);
+
+	wpa_hexdump(MSG_MSGDUMP, "TX EAPOL", bp, len);
+
+	status = l2_packet_send(drv->sock_xmit, addr, ETH_P_EAPOL, bp, len);
+
+	if (bp != buf)
+		free(bp);
+	return status;
+}
+
+static void
+handle_read(void *ctx, const u8 *src_addr, const u8 *buf, size_t len)
+{
+	struct madwifi_driver_data *drv = ctx;
+	drv_event_eapol_rx(drv->hapd, src_addr, buf + sizeof(struct l2_ethhdr),
+			   len - sizeof(struct l2_ethhdr));
+}
+
+static void *
+madwifi_init(struct hostapd_data *hapd, struct wpa_init_params *params)
+{
+	struct madwifi_driver_data *drv;
+	struct ifreq ifr;
+	struct iwreq iwr;
+	char brname[IFNAMSIZ];
+
+	drv = os_zalloc(sizeof(struct madwifi_driver_data));
+	if (drv == NULL) {
+		printf("Could not allocate memory for madwifi driver data\n");
+		return NULL;
+	}
+
+	drv->hapd = hapd;
+	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (drv->ioctl_sock < 0) {
+		perror("socket[PF_INET,SOCK_DGRAM]");
+		goto bad;
+	}
+	memcpy(drv->iface, params->ifname, sizeof(drv->iface));
+
+	memset(&ifr, 0, sizeof(ifr));
+	os_strlcpy(ifr.ifr_name, drv->iface, sizeof(ifr.ifr_name));
+	if (ioctl(drv->ioctl_sock, SIOCGIFINDEX, &ifr) != 0) {
+		perror("ioctl(SIOCGIFINDEX)");
+		goto bad;
+	}
+	drv->ifindex = ifr.ifr_ifindex;
+
+	drv->sock_xmit = l2_packet_init(drv->iface, NULL, ETH_P_EAPOL,
+					handle_read, drv, 1);
+	if (drv->sock_xmit == NULL)
+		goto bad;
+	if (l2_packet_get_own_addr(drv->sock_xmit, params->own_addr))
+		goto bad;
+	if (params->bridge[0]) {
+		wpa_printf(MSG_DEBUG, "Configure bridge %s for EAPOL traffic.",
+			   params->bridge[0]);
+		drv->sock_recv = l2_packet_init(params->bridge[0], NULL,
+						ETH_P_EAPOL, handle_read, drv,
+						1);
+		if (drv->sock_recv == NULL)
+			goto bad;
+	} else if (linux_br_get(brname, drv->iface) == 0) {
+		wpa_printf(MSG_DEBUG, "Interface in bridge %s; configure for "
+			   "EAPOL receive", brname);
+		drv->sock_recv = l2_packet_init(brname, NULL, ETH_P_EAPOL,
+						handle_read, drv, 1);
+		if (drv->sock_recv == NULL)
+			goto bad;
+	} else
+		drv->sock_recv = drv->sock_xmit;
+
+	memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+
+	iwr.u.mode = IW_MODE_MASTER;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMODE]");
+		printf("Could not set interface to master mode!\n");
+		goto bad;
+	}
+
+	/* mark down during setup */
+	linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
+	madwifi_set_privacy(drv, 0); /* default to no privacy */
+
+	madwifi_receive_probe_req(drv);
+
+	if (madwifi_wireless_event_init(drv))
+		goto bad;
+
+	return drv;
+bad:
+	if (drv->sock_xmit != NULL)
+		l2_packet_deinit(drv->sock_xmit);
+	if (drv->ioctl_sock >= 0)
+		close(drv->ioctl_sock);
+	if (drv != NULL)
+		free(drv);
+	return NULL;
+}
+
+
+static void
+madwifi_deinit(void *priv)
+{
+	struct madwifi_driver_data *drv = priv;
+
+	netlink_deinit(drv->netlink);
+	(void) linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
+	if (drv->ioctl_sock >= 0)
+		close(drv->ioctl_sock);
+	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
+		l2_packet_deinit(drv->sock_recv);
+	if (drv->sock_xmit != NULL)
+		l2_packet_deinit(drv->sock_xmit);
+	if (drv->sock_raw)
+		l2_packet_deinit(drv->sock_raw);
+	free(drv);
+}
+
+static int
+madwifi_set_ssid(void *priv, const u8 *buf, int len)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct iwreq iwr;
+
+	memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.essid.flags = 1; /* SSID active */
+	iwr.u.essid.pointer = (caddr_t) buf;
+	iwr.u.essid.length = len + 1;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCSIWESSID]");
+		printf("len=%d\n", len);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+madwifi_get_ssid(void *priv, u8 *buf, int len)
+{
+	struct madwifi_driver_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
+	iwr.u.essid.pointer = (caddr_t) buf;
+	iwr.u.essid.length = len;
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCGIWESSID]");
+		ret = -1;
+	} else
+		ret = iwr.u.essid.length;
+
+	return ret;
+}
+
+static int
+madwifi_set_countermeasures(void *priv, int enabled)
+{
+	struct madwifi_driver_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
+	return set80211param(drv, IEEE80211_PARAM_COUNTERMEASURES, enabled);
+}
+
+static int
+madwifi_commit(void *priv)
+{
+	struct madwifi_driver_data *drv = priv;
+	return linux_set_iface_flags(drv->ioctl_sock, drv->iface, 1);
+}
+
+
+const struct wpa_driver_ops wpa_driver_madwifi_ops = {
+	.name			= "madwifi",
+	.desc			= "MADWIFI 802.11 support (Atheros, etc.)",
+	.set_key		= wpa_driver_madwifi_set_key,
+	.hapd_init		= madwifi_init,
+	.hapd_deinit		= madwifi_deinit,
+	.set_ieee8021x		= madwifi_set_ieee8021x,
+	.set_privacy		= madwifi_set_privacy,
+	.get_seqnum		= madwifi_get_seqnum,
+	.flush			= madwifi_flush,
+	.set_generic_elem	= madwifi_set_opt_ie,
+	.sta_set_flags		= madwifi_sta_set_flags,
+	.read_sta_data		= madwifi_read_sta_driver_data,
+	.hapd_send_eapol	= madwifi_send_eapol,
+	.sta_disassoc		= madwifi_sta_disassoc,
+	.sta_deauth		= madwifi_sta_deauth,
+	.hapd_set_ssid		= madwifi_set_ssid,
+	.hapd_get_ssid		= madwifi_get_ssid,
+	.hapd_set_countermeasures	= madwifi_set_countermeasures,
+	.sta_clear_stats        = madwifi_sta_clear_stats,
+	.commit			= madwifi_commit,
+	.set_ap_wps_ie		= madwifi_set_ap_wps_ie,
+	.set_freq		= madwifi_set_freq,
+};
diff -urpN hostapd-2016-10-15/src/drivers/driver_nl80211.c.dd hostapd-2016-09-05.dd/src/drivers/driver_nl80211.c.dd
Binary files hostapd-2016-10-15/src/drivers/driver_wext.o and hostapd-2016-09-05.dd/src/drivers/driver_wext.o differ
diff -urpN hostapd-2016-10-15/src/drivers/drivers.c hostapd-2016-09-05.dd/src/drivers/drivers.c
--- hostapd-2016-10-15/src/drivers/drivers.c	2017-10-19 00:05:11.507748011 +0200
+++ hostapd-2016-09-05.dd/src/drivers/drivers.c	2017-10-18 16:51:13.000000000 +0200
@@ -26,6 +26,9 @@ const struct wpa_driver_ops *const wpa_d
 #ifdef CONFIG_DRIVER_HOSTAP
 	&wpa_driver_hostap_ops,
 #endif /* CONFIG_DRIVER_HOSTAP */
+#ifdef CONFIG_DRIVER_MADWIFI
+	&wpa_driver_madwifi_ops,
+#endif /* CONFIG_DRIVER_MADWIFI */
 #ifdef CONFIG_DRIVER_BSD
 	&wpa_driver_bsd_ops,
 #endif /* CONFIG_DRIVER_BSD */
diff -urpN hostapd-2016-10-15/src/drivers/drivers.mak hostapd-2016-09-05.dd/src/drivers/drivers.mak
--- hostapd-2016-10-15/src/drivers/drivers.mak	2017-10-19 00:05:11.515747908 +0200
+++ hostapd-2016-09-05.dd/src/drivers/drivers.mak	2017-10-18 16:51:13.000000000 +0200
@@ -115,6 +115,15 @@ CFLAGS += -DATH_GCM_SUPPORT
 endif
 endif
 
+ifdef CONFIG_DRIVER_MADWIFI
+DRV_AP_CFLAGS += -DCONFIG_DRIVER_MADWIFI
+DRV_AP_OBJS += ../src/drivers/driver_madwifi.o
+CONFIG_WIRELESS_EXTENSION=y
+CONFIG_L2_PACKET=linux
+NEED_NETLINK=y
+NEED_LINUX_IOCTL=y
+endif
+
 ##### PURE CLIENT DRIVERS
 
 ifdef CONFIG_DRIVER_WEXT
Binary files hostapd-2016-10-15/src/drivers/drivers.o and hostapd-2016-09-05.dd/src/drivers/drivers.o differ
Binary files hostapd-2016-10-15/src/drivers/linux_ioctl.o and hostapd-2016-09-05.dd/src/drivers/linux_ioctl.o differ
diff -urpN hostapd-2016-10-15/src/drivers/linux_wext.h hostapd-2016-09-05.dd/src/drivers/linux_wext.h
--- hostapd-2016-10-15/src/drivers/linux_wext.h	2017-10-19 00:05:11.531747701 +0200
+++ hostapd-2016-09-05.dd/src/drivers/linux_wext.h	2017-01-25 07:30:51.000000000 +0100
@@ -21,6 +21,23 @@
 
 #include <stdint.h>
 #include <net/if.h>
+
+#ifndef __UCLIBC__
+/* Convenience types.  */
+typedef unsigned char __u_char;
+typedef unsigned short int __u_short;
+typedef unsigned int __u_int;
+typedef unsigned long int __u_long;
+
+/* Fixed-size types, underlying types depend on word size and compiler.  */
+typedef signed char __int8_t;
+typedef unsigned char __uint8_t;
+typedef signed short int __int16_t;
+typedef unsigned short int __uint16_t;
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#endif
+
 typedef uint32_t __u32;
 typedef int32_t __s32;
 typedef uint16_t __u16;
Binary files hostapd-2016-10-15/src/drivers/netlink.o and hostapd-2016-09-05.dd/src/drivers/netlink.o differ
Binary files hostapd-2016-10-15/src/eap_common/chap.o and hostapd-2016-09-05.dd/src/eap_common/chap.o differ
Binary files hostapd-2016-10-15/src/eap_common/eap_common.o and hostapd-2016-09-05.dd/src/eap_common/eap_common.o differ
Binary files hostapd-2016-10-15/src/eap_common/eap_fast_common.o and hostapd-2016-09-05.dd/src/eap_common/eap_fast_common.o differ
Binary files hostapd-2016-10-15/src/eap_common/eap_peap_common.o and hostapd-2016-09-05.dd/src/eap_common/eap_peap_common.o differ
Binary files hostapd-2016-10-15/src/eap_common/eap_psk_common.o and hostapd-2016-09-05.dd/src/eap_common/eap_psk_common.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap.o and hostapd-2016-09-05.dd/src/eap_peer/eap.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_fast.o and hostapd-2016-09-05.dd/src/eap_peer/eap_fast.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_fast_pac.o and hostapd-2016-09-05.dd/src/eap_peer/eap_fast_pac.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_gtc.o and hostapd-2016-09-05.dd/src/eap_peer/eap_gtc.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_leap.o and hostapd-2016-09-05.dd/src/eap_peer/eap_leap.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_md5.o and hostapd-2016-09-05.dd/src/eap_peer/eap_md5.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_methods.o and hostapd-2016-09-05.dd/src/eap_peer/eap_methods.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_mschapv2.o and hostapd-2016-09-05.dd/src/eap_peer/eap_mschapv2.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_peap.o and hostapd-2016-09-05.dd/src/eap_peer/eap_peap.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_psk.o and hostapd-2016-09-05.dd/src/eap_peer/eap_psk.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_tls.o and hostapd-2016-09-05.dd/src/eap_peer/eap_tls.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_tls_common.o and hostapd-2016-09-05.dd/src/eap_peer/eap_tls_common.o differ
Binary files hostapd-2016-10-15/src/eap_peer/eap_ttls.o and hostapd-2016-09-05.dd/src/eap_peer/eap_ttls.o differ
diff -urpN hostapd-2016-10-15/src/eap_peer/eap_wsc.c hostapd-2016-09-05.dd/src/eap_peer/eap_wsc.c
--- hostapd-2016-10-15/src/eap_peer/eap_wsc.c	2017-10-19 00:01:38.000000000 +0200
+++ hostapd-2016-09-05.dd/src/eap_peer/eap_wsc.c	2017-01-25 07:30:51.000000000 +0100
@@ -421,6 +421,10 @@ static struct wpabuf * eap_wsc_process_f
 	return eap_wsc_build_frag_ack(id, EAP_CODE_RESPONSE);
 }
 
+#ifdef HAVE_AOSS
+extern int sysprintf(const char *fmt, ...);
+extern void nvram_set(const char *name, char *value);
+#endif
 
 static struct wpabuf * eap_wsc_process(struct eap_sm *sm, void *priv,
 				       struct eap_method_ret *ret,
@@ -532,6 +536,11 @@ static struct wpabuf * eap_wsc_process(s
 		wpa_printf(MSG_DEBUG, "EAP-WSC: WPS processing completed "
 			   "successfully - wait for EAP failure");
 		eap_wsc_state(data, FAIL);
+#ifdef HAVE_AOSS
+		sysprintf("echo done > /tmp/.wpsdone");
+		nvram_set("wps_status", "1");
+		nvram_commit();
+#endif
 		break;
 	case WPS_CONTINUE:
 		eap_wsc_state(data, MESG);
Binary files hostapd-2016-10-15/src/eap_peer/mschapv2.o and hostapd-2016-09-05.dd/src/eap_peer/mschapv2.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server.o and hostapd-2016-09-05.dd/src/eap_server/eap_server.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_fast.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_fast.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_gtc.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_gtc.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_identity.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_identity.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_md5.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_md5.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_methods.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_methods.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_mschapv2.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_mschapv2.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_peap.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_peap.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_psk.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_psk.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_tls.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_tls.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_tls_common.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_tls_common.o differ
Binary files hostapd-2016-10-15/src/eap_server/eap_server_ttls.o and hostapd-2016-09-05.dd/src/eap_server/eap_server_ttls.o differ
diff -urpN hostapd-2016-10-15/src/eap_server/eap_server_wsc.c hostapd-2016-09-05.dd/src/eap_server/eap_server_wsc.c
--- hostapd-2016-10-15/src/eap_server/eap_server_wsc.c	2017-10-19 00:01:38.000000000 +0200
+++ hostapd-2016-09-05.dd/src/eap_server/eap_server_wsc.c	2017-01-25 07:30:51.000000000 +0100
@@ -286,6 +286,10 @@ static Boolean eap_wsc_check(struct eap_
 	return FALSE;
 }
 
+#ifdef HAVE_AOSS
+extern int sysprintf(const char *fmt, ...);
+extern void nvram_set(const char *name, char *value);
+#endif
 
 static int eap_wsc_process_cont(struct eap_wsc_data *data,
 				const u8 *buf, size_t len, u8 op_code)
@@ -439,6 +443,11 @@ static void eap_wsc_process(struct eap_s
 		wpa_printf(MSG_DEBUG, "EAP-WSC: WPS processing completed "
 			   "successfully - report EAP failure");
 		eap_wsc_state(data, FAIL);
+#ifdef HAVE_AOSS
+		sysprintf("echo done > /tmp/.wpsdone");
+		nvram_set("wps_status", "1");
+		nvram_commit();
+#endif
 		break;
 	case WPS_CONTINUE:
 		eap_wsc_state(data, MESG);
Binary files hostapd-2016-10-15/src/eapol_auth/eapol_auth_sm.o and hostapd-2016-09-05.dd/src/eapol_auth/eapol_auth_sm.o differ
Binary files hostapd-2016-10-15/src/eapol_supp/eapol_supp_sm.o and hostapd-2016-09-05.dd/src/eapol_supp/eapol_supp_sm.o differ
diff -urpN hostapd-2016-10-15/src/l2_packet/l2_packet_linux.c hostapd-2016-09-05.dd/src/l2_packet/l2_packet_linux.c
--- hostapd-2016-10-15/src/l2_packet/l2_packet_linux.c	2017-10-19 00:05:11.499748114 +0200
+++ hostapd-2016-09-05.dd/src/l2_packet/l2_packet_linux.c	2017-01-25 07:30:51.000000000 +0100
@@ -337,7 +337,8 @@ struct l2_packet_data * l2_packet_init_b
 
 	l2 = l2_packet_init(br_ifname, own_addr, protocol, rx_callback,
 			    rx_callback_ctx, l2_hdr);
-	return l2;
+	if (!l2)
+		return NULL;
 
 #ifndef CONFIG_NO_LINUX_PACKET_SOCKET_WAR
 	/*
Binary files hostapd-2016-10-15/src/l2_packet/l2_packet_linux.o and hostapd-2016-09-05.dd/src/l2_packet/l2_packet_linux.o differ
diff -urpN hostapd-2016-10-15/src/radius/radius.c hostapd-2016-09-05.dd/src/radius/radius.c
--- hostapd-2016-10-15/src/radius/radius.c	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/src/radius/radius.c	2017-01-25 07:30:51.000000000 +0100
@@ -915,7 +915,7 @@ int radius_msg_make_authenticator(struct
  * The returned payload is allocated with os_malloc() and caller must free it
  * by calling os_free().
  */
-static u8 *radius_msg_get_vendor_attr(struct radius_msg *msg, u32 vendor,
+u8 *radius_msg_get_vendor_attr(struct radius_msg *msg, u32 vendor,
 				      u8 subtype, size_t *alen)
 {
 	u8 *data, *pos;
diff -urpN hostapd-2016-10-15/src/radius/radius.h hostapd-2016-09-05.dd/src/radius/radius.h
--- hostapd-2016-10-15/src/radius/radius.h	2017-10-19 00:01:38.000000000 +0200
+++ hostapd-2016-09-05.dd/src/radius/radius.h	2017-01-25 07:30:51.000000000 +0100
@@ -195,6 +195,15 @@ enum {
 	RADIUS_VENDOR_ATTR_WFA_HS20_SESSION_INFO_URL = 5,
 };
 
+#define RADIUS_VENDOR_ID_WISPR 14122
+
+enum {
+       RADIUS_ATTR_WISPR_BANDWIDTH_MIN_UP = 5,     
+       RADIUS_ATTR_WISPR_BANDWIDTH_MIN_DOWN = 6,
+       RADIUS_ATTR_WISPR_BANDWIDTH_MAX_UP = 7,     
+       RADIUS_ATTR_WISPR_BANDWIDTH_MAX_DOWN = 8,
+};
+
 #ifdef _MSC_VER
 #pragma pack(pop)
 #endif /* _MSC_VER */
@@ -285,6 +294,7 @@ int radius_msg_get_vlanid(struct radius_
 char * radius_msg_get_tunnel_password(struct radius_msg *msg, int *keylen,
 				      const u8 *secret, size_t secret_len,
 				      struct radius_msg *sent_msg, size_t n);
+u8 *radius_msg_get_vendor_attr(struct radius_msg *msg, u32 vendor,u8 subtype, size_t *alen);
 
 static inline int radius_msg_add_attr_int32(struct radius_msg *msg, u8 type,
 					    u32 value)
Binary files hostapd-2016-10-15/src/radius/radius.o and hostapd-2016-09-05.dd/src/radius/radius.o differ
diff -urpN hostapd-2016-10-15/src/radius/radius_client.c hostapd-2016-09-05.dd/src/radius/radius_client.c
--- hostapd-2016-10-15/src/radius/radius_client.c	2017-10-19 00:01:38.000000000 +0200
+++ hostapd-2016-09-05.dd/src/radius/radius_client.c	2017-01-25 07:30:51.000000000 +0100
@@ -1447,15 +1447,11 @@ radius_client_init(void *ctx, struct hos
 		radius->auth_serv_sock6 = radius->acct_serv_sock6 =
 		radius->auth_sock = radius->acct_sock = -1;
 
-	if (conf->auth_server && radius_client_init_auth(radius)) {
-		radius_client_deinit(radius);
-		return NULL;
-	}
+	if (conf->auth_server)
+	    radius_client_init_auth(radius);
 
-	if (conf->acct_server && radius_client_init_acct(radius)) {
-		radius_client_deinit(radius);
-		return NULL;
-	}
+	if (conf->acct_server)
+	    radius_client_init_acct(radius);
 
 	if (conf->retry_primary_interval)
 		eloop_register_timeout(conf->retry_primary_interval, 0,
Binary files hostapd-2016-10-15/src/radius/radius_client.o and hostapd-2016-09-05.dd/src/radius/radius_client.o differ
Binary files hostapd-2016-10-15/src/radius/radius_das.o and hostapd-2016-09-05.dd/src/radius/radius_das.o differ
Binary files hostapd-2016-10-15/src/rsn_supp/peerkey.o and hostapd-2016-09-05.dd/src/rsn_supp/peerkey.o differ
Binary files hostapd-2016-10-15/src/rsn_supp/pmksa_cache.o and hostapd-2016-09-05.dd/src/rsn_supp/pmksa_cache.o differ
Binary files hostapd-2016-10-15/src/rsn_supp/preauth.o and hostapd-2016-09-05.dd/src/rsn_supp/preauth.o differ
diff -urpN hostapd-2016-10-15/src/rsn_supp/tdls.c hostapd-2016-09-05.dd/src/rsn_supp/tdls.c
diff -urpN hostapd-2016-10-15/src/rsn_supp/wpa.c hostapd-2016-09-05.dd/src/rsn_supp/wpa.c
Binary files hostapd-2016-10-15/src/rsn_supp/wpa.o and hostapd-2016-09-05.dd/src/rsn_supp/wpa.o differ
diff -urpN hostapd-2016-10-15/src/rsn_supp/wpa_ft.c hostapd-2016-09-05.dd/src/rsn_supp/wpa_ft.c
diff -urpN hostapd-2016-10-15/src/rsn_supp/wpa_i.h hostapd-2016-09-05.dd/src/rsn_supp/wpa_i.h
Binary files hostapd-2016-10-15/src/rsn_supp/wpa_ie.o and hostapd-2016-09-05.dd/src/rsn_supp/wpa_ie.o differ
Binary files hostapd-2016-10-15/src/tls/asn1.o and hostapd-2016-09-05.dd/src/tls/asn1.o differ
Binary files hostapd-2016-10-15/src/tls/bignum.o and hostapd-2016-09-05.dd/src/tls/bignum.o differ
Binary files hostapd-2016-10-15/src/tls/pkcs1.o and hostapd-2016-09-05.dd/src/tls/pkcs1.o differ
Binary files hostapd-2016-10-15/src/tls/pkcs5.o and hostapd-2016-09-05.dd/src/tls/pkcs5.o differ
Binary files hostapd-2016-10-15/src/tls/pkcs8.o and hostapd-2016-09-05.dd/src/tls/pkcs8.o differ
Binary files hostapd-2016-10-15/src/tls/rsa.o and hostapd-2016-09-05.dd/src/tls/rsa.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_client.o and hostapd-2016-09-05.dd/src/tls/tlsv1_client.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_client_ocsp.o and hostapd-2016-09-05.dd/src/tls/tlsv1_client_ocsp.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_client_read.o and hostapd-2016-09-05.dd/src/tls/tlsv1_client_read.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_client_write.o and hostapd-2016-09-05.dd/src/tls/tlsv1_client_write.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_common.o and hostapd-2016-09-05.dd/src/tls/tlsv1_common.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_cred.o and hostapd-2016-09-05.dd/src/tls/tlsv1_cred.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_record.o and hostapd-2016-09-05.dd/src/tls/tlsv1_record.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_server.o and hostapd-2016-09-05.dd/src/tls/tlsv1_server.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_server_read.o and hostapd-2016-09-05.dd/src/tls/tlsv1_server_read.o differ
Binary files hostapd-2016-10-15/src/tls/tlsv1_server_write.o and hostapd-2016-09-05.dd/src/tls/tlsv1_server_write.o differ
diff -urpN hostapd-2016-10-15/src/tls/x509v3.c hostapd-2016-09-05.dd/src/tls/x509v3.c
--- hostapd-2016-10-15/src/tls/x509v3.c	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/src/tls/x509v3.c	2017-01-25 07:30:51.000000000 +0100
@@ -2045,7 +2045,7 @@ int x509_certificate_chain_validate(stru
 		if (chain_trusted)
 			continue;
 
-		if (!disable_time_checks &&
+/*		if (!disable_time_checks &&
 		    ((unsigned long) now.sec <
 		     (unsigned long) cert->not_before ||
 		     (unsigned long) now.sec >
@@ -2055,7 +2055,7 @@ int x509_certificate_chain_validate(stru
 				   now.sec, cert->not_before, cert->not_after);
 			*reason = X509_VALIDATE_CERTIFICATE_EXPIRED;
 			return -1;
-		}
+		}*/
 
 		if (cert->next) {
 			if (x509_name_compare(&cert->issuer,
Binary files hostapd-2016-10-15/src/tls/x509v3.o and hostapd-2016-09-05.dd/src/tls/x509v3.o differ
Binary files hostapd-2016-10-15/src/utils/base64.o and hostapd-2016-09-05.dd/src/utils/base64.o differ
diff -urpN hostapd-2016-10-15/src/utils/build_features.h hostapd-2016-09-05.dd/src/utils/build_features.h
Binary files hostapd-2016-10-15/src/utils/common.o and hostapd-2016-09-05.dd/src/utils/common.o differ
Binary files hostapd-2016-10-15/src/utils/edit_simple.o and hostapd-2016-09-05.dd/src/utils/edit_simple.o differ
Binary files hostapd-2016-10-15/src/utils/eloop.o and hostapd-2016-09-05.dd/src/utils/eloop.o differ
Binary files hostapd-2016-10-15/src/utils/ip_addr.o and hostapd-2016-09-05.dd/src/utils/ip_addr.o differ
Binary files hostapd-2016-10-15/src/utils/os_unix.o and hostapd-2016-09-05.dd/src/utils/os_unix.o differ
diff -urpN hostapd-2016-10-15/src/utils/wpa_debug.h hostapd-2016-09-05.dd/src/utils/wpa_debug.h
--- hostapd-2016-10-15/src/utils/wpa_debug.h	2017-10-19 00:05:11.531747701 +0200
+++ hostapd-2016-09-05.dd/src/utils/wpa_debug.h	2017-10-17 22:11:44.000000000 +0200
@@ -208,6 +208,19 @@ static inline void wpa_hexdump_ascii_key
 #define wpa_msg_global_only(args...) do { } while (0)
 #define wpa_msg_register_cb(f) do { } while (0)
 #define wpa_msg_register_ifname_cb(f) do { } while (0)
+enum wpa_msg_type {
+	WPA_MSG_PER_INTERFACE,
+	WPA_MSG_GLOBAL,
+	WPA_MSG_NO_GLOBAL,
+	WPA_MSG_ONLY_GLOBAL,
+};
+static inline void wpa_debug_open_syslog(void)
+{
+}
+
+static inline void wpa_debug_close_syslog(void)
+{
+}
 #else /* CONFIG_NO_WPA_MSG */
 /**
  * wpa_msg - Conditional printf for default target and ctrl_iface monitors
@@ -370,17 +383,7 @@ enum hostapd_logger_level {
 void wpa_debug_open_syslog(void);
 void wpa_debug_close_syslog(void);
 
-#else /* CONFIG_DEBUG_SYSLOG */
-
-static inline void wpa_debug_open_syslog(void)
-{
-}
-
-static inline void wpa_debug_close_syslog(void)
-{
-}
-
-#endif /* CONFIG_DEBUG_SYSLOG */
+#endif
 
 #ifdef CONFIG_DEBUG_LINUX_TRACING
 
Binary files hostapd-2016-10-15/src/utils/wpa_debug.o and hostapd-2016-09-05.dd/src/utils/wpa_debug.o differ
Binary files hostapd-2016-10-15/src/utils/wpabuf.o and hostapd-2016-09-05.dd/src/utils/wpabuf.o differ
diff -urpN hostapd-2016-10-15/src/wps/wps_enrollee.c hostapd-2016-09-05.dd/src/wps/wps_enrollee.c
--- hostapd-2016-10-15/src/wps/wps_enrollee.c	2017-10-19 00:01:38.000000000 +0200
+++ hostapd-2016-09-05.dd/src/wps/wps_enrollee.c	2017-01-25 07:30:51.000000000 +0100
@@ -1445,6 +1445,14 @@ static enum wps_process_res wps_process_
 	wpa_printf(MSG_DEBUG, "WPS: Registrar terminated negotiation with "
 		   "Configuration Error %d", config_error);
 
+	if (!config_error) {
+#ifdef HAVE_AOSS
+		nvram_set("wps_status", "1");
+		nvram_commit();
+		sysprintf("echo done > /tmp/.wpsdone");
+#endif
+	}
+
 	switch (wps->state) {
 	case RECV_M4:
 		wps_fail_event(wps->wps, WPS_M3, config_error,
diff -urpN hostapd-2016-10-15/src/wps/wps_registrar.c hostapd-2016-09-05.dd/src/wps/wps_registrar.c
--- hostapd-2016-10-15/src/wps/wps_registrar.c	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/src/wps/wps_registrar.c	2017-01-25 07:30:51.000000000 +0100
@@ -3317,6 +3317,11 @@ static enum wps_process_res wps_process_
 	return WPS_DONE;
 }
 
+#ifdef HAVE_AOSS
+extern int sysprintf(const char *fmt, ...);
+extern void nvram_set(const char *name, char *value);
+#endif
+
 
 enum wps_process_res wps_registrar_process_msg(struct wps_data *wps,
 					       enum wsc_op_code op_code,
@@ -3382,6 +3387,12 @@ enum wps_process_res wps_registrar_proce
 			wps_fail_event(wps->wps, WPS_WSC_DONE,
 				       wps->config_error,
 				       wps->error_indication, wps->mac_addr_e);
+		} else {
+#ifdef HAVE_AOSS
+			nvram_set("wps_status", "1");
+			nvram_commit();
+			sysprintf("echo done > /tmp/.wpsdone");
+#endif
 		}
 		return ret;
 	default:
Binary files hostapd-2016-10-15/tests/ap-mgmt-fuzzer/auth.dat and hostapd-2016-09-05.dd/tests/ap-mgmt-fuzzer/auth.dat differ
Binary files hostapd-2016-10-15/tests/ap-mgmt-fuzzer/multi.dat and hostapd-2016-09-05.dd/tests/ap-mgmt-fuzzer/multi.dat differ
Binary files hostapd-2016-10-15/tests/ap-mgmt-fuzzer/probe-req.dat and hostapd-2016-09-05.dd/tests/ap-mgmt-fuzzer/probe-req.dat differ
Binary files hostapd-2016-10-15/tests/eapol-fuzzer/eap-req-identity.dat and hostapd-2016-09-05.dd/tests/eapol-fuzzer/eap-req-identity.dat differ
Binary files hostapd-2016-10-15/tests/eapol-fuzzer/eap-req-sim.dat and hostapd-2016-09-05.dd/tests/eapol-fuzzer/eap-req-sim.dat differ
Binary files hostapd-2016-10-15/tests/eapol-fuzzer/eapol-key-m1.dat and hostapd-2016-09-05.dd/tests/eapol-fuzzer/eapol-key-m1.dat differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/ocsp-multi-server-cache.der and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/ocsp-multi-server-cache.der differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/ocsp-req.der and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/ocsp-req.der differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/ocsp-server-cache.der and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/ocsp-server-cache.der differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/server-extra.pkcs12 and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/server-extra.pkcs12 differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/server.pkcs12 and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/server.pkcs12 differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/user.pkcs12 and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/user.pkcs12 differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/user2.pkcs12 and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/user2.pkcs12 differ
Binary files hostapd-2016-10-15/tests/hwsim/auth_serv/user3.pkcs12 and hostapd-2016-09-05.dd/tests/hwsim/auth_serv/user3.pkcs12 differ
Binary files hostapd-2016-10-15/tests/hwsim/wps-ctrl-cred and hostapd-2016-09-05.dd/tests/hwsim/wps-ctrl-cred differ
Binary files hostapd-2016-10-15/tests/hwsim/wps-ctrl-cred2 and hostapd-2016-09-05.dd/tests/hwsim/wps-ctrl-cred2 differ
Binary files hostapd-2016-10-15/tests/hwsim/wps-mixed-cred and hostapd-2016-09-05.dd/tests/hwsim/wps-mixed-cred differ
Binary files hostapd-2016-10-15/tests/p2p-fuzzer/go-neg-req.dat and hostapd-2016-09-05.dd/tests/p2p-fuzzer/go-neg-req.dat differ
Binary files hostapd-2016-10-15/tests/p2p-fuzzer/invitation-req.dat and hostapd-2016-09-05.dd/tests/p2p-fuzzer/invitation-req.dat differ
Binary files hostapd-2016-10-15/tests/p2p-fuzzer/p2ps-pd-req.dat and hostapd-2016-09-05.dd/tests/p2p-fuzzer/p2ps-pd-req.dat differ
Binary files hostapd-2016-10-15/tests/p2p-fuzzer/proberesp-go.dat and hostapd-2016-09-05.dd/tests/p2p-fuzzer/proberesp-go.dat differ
Binary files hostapd-2016-10-15/tests/p2p-fuzzer/proberesp.dat and hostapd-2016-09-05.dd/tests/p2p-fuzzer/proberesp.dat differ
Binary files hostapd-2016-10-15/tests/wnm-fuzzer/bss-tm-req.dat and hostapd-2016-09-05.dd/tests/wnm-fuzzer/bss-tm-req.dat differ
Binary files hostapd-2016-10-15/tests/wnm-fuzzer/wnm-notif.dat and hostapd-2016-09-05.dd/tests/wnm-fuzzer/wnm-notif.dat differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/.config hostapd-2016-09-05.dd/wpa_supplicant/.config
--- hostapd-2016-10-15/wpa_supplicant/.config	1970-01-01 01:00:00.000000000 +0100
+++ hostapd-2016-09-05.dd/wpa_supplicant/.config	2017-01-25 07:30:52.000000000 +0100
@@ -0,0 +1,73 @@
+-include ../../.config
+
+#CONFIG_DRIVER_WIRED=y
+ifneq ($(CONFIG_WRT300NV2),y)
+ifneq ($(CONFIG_DIST),"micro")
+CONFIG_TLS=internal
+CONFIG_INTERNAL_LIBTOMMATH=y
+CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+CONFIG_IEEE8021X_EAPOL=y
+CONFIG_EAP_MD5=y
+CONFIG_EAP_PEAP=y
+CONFIG_EAP_MSCHAPV2=y
+CONFIG_EAP_TLS=y
+CONFIG_EAP_TTLS=y
+CONFIG_EAP_PEAP=y
+CONFIG_EAP_PSK=y
+CONFIG_EAP_LEAP=y
+else
+
+endif
+endif
+
+CONFIG_MAIN=main
+CONFIG_OS=unix
+#CONFIG_TLS=openssl
+CONFIG_NO_CONFIG_WRITE=y
+
+ifeq ($(CONFIG_HOTSPOT20),y)
+CONFIG_HS20=y
+endif
+
+ifeq ($(CONFIG_NOMESSAGE),y)
+CONFIG_NO_STDOUT_DEBUG=y
+else
+CONFIG_DEBUG_SYSLOG=y
+# Set syslog facility for debug messages
+CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
+CFLAGS+= -DNEED_PRINTF
+endif
+#CONFIG_DRIVER_WEXT=y
+
+
+ifeq ($(CONFIG_MADWIFI),y)
+#CONFIG_DRIVER_MADWIFI=y
+#CFLAGS +=-I$(TOP)/madwifi.dev/madwifi.dev
+CONFIG_DRIVER_WEXT=y
+else
+ifeq ($(CONFIG_RT2880),y)
+CONFIG_DRIVER_RALINK=y
+else
+CONFIG_DRIVER_WEXT=y
+endif
+endif
+ifeq ($(CONFIG_ATH9K),y)
+CONFIG_DRIVER_NL80211=y
+endif
+ifeq ($(CONFIG_BGSCAN),y)
+CONFIG_BGSCAN_SIMPLE=y
+CONFIG_BGSCAN_LEARN=y
+endif
+
+# for local installation of OpenSSL
+#CFLAGS += -I../openssl/include
+#LDFLAGS += -L../openssl
+CONFIG_BACKEND=file
+CONFIG_CTRL_IFACE=y
+NEED_80211_COMMON=y
+NEED_AP_MLME=y
+CONFIG_NO_VLAN=y
+CONFIG_NO_RANDOM_POOL=y
+CONFIG_NO_DUMP_STATE=y
+CONFIG_VHT_OVERRIDES=y
+CONFIG_HT_OVERRIDES=y
\ No newline at end of file
diff -urpN hostapd-2016-10-15/wpa_supplicant/.config.old hostapd-2016-09-05.dd/wpa_supplicant/.config.old
diff -urpN hostapd-2016-10-15/wpa_supplicant/Makefile hostapd-2016-09-05.dd/wpa_supplicant/Makefile
--- hostapd-2016-10-15/wpa_supplicant/Makefile	2017-10-19 00:05:11.523747805 +0200
+++ hostapd-2016-09-05.dd/wpa_supplicant/Makefile	2017-09-01 12:25:50.000000000 +0200
@@ -2,9 +2,9 @@ ifndef CC
 CC=gcc
 endif
 
-ifndef CFLAGS
-CFLAGS = -MMD -O2 -Wall -g
-endif
+CFLAGS+ = -MMD  $(MIPS16_OPT) $(COPTS) -Wall 
+LDFLAGS += -ffunction-sections -fdata-sections -Wl,--gc-sections
+CFLAGS += -I. -ffunction-sections -fdata-sections -Wl,--gc-sections
 
 ifdef LIBS
 # If LIBS is set with some global build system defaults, clone those for
@@ -320,9 +320,7 @@ endif
 ifdef CONFIG_IBSS_RSN
 NEED_RSN_AUTHENTICATOR=y
 CFLAGS += -DCONFIG_IBSS_RSN
-ifndef MULTICALL
 CFLAGS += -DCONFIG_NO_VLAN
-endif
 OBJS += ibss_rsn.o
 endif
 
diff -urpN hostapd-2016-10-15/wpa_supplicant/binder/.clang-format hostapd-2016-09-05.dd/wpa_supplicant/binder/.clang-format
Binary files hostapd-2016-10-15/wpa_supplicant/blacklist.o and hostapd-2016-09-05.dd/wpa_supplicant/blacklist.o differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/bss.c hostapd-2016-09-05.dd/wpa_supplicant/bss.c
--- hostapd-2016-10-15/wpa_supplicant/bss.c	2017-10-19 00:05:11.523747805 +0200
+++ hostapd-2016-09-05.dd/wpa_supplicant/bss.c	2017-02-19 15:21:18.000000000 +0100
@@ -291,6 +291,7 @@ static void wpa_bss_copy_res(struct wpa_
 {
 	struct ieee80211_ht_capabilities *capab;
 	struct ieee80211_ht_operation *oper;
+	struct ieee80211_vht_operation *vht_oper;
 	struct ieee802_11_elems elems;
 
 	dst->flags = src->flags;
@@ -309,11 +310,17 @@ static void wpa_bss_copy_res(struct wpa_
 	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
 	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
 	oper = (struct ieee80211_ht_operation *) elems.ht_operation;
+	vht_oper = (struct ieee80211_vht_operation *) elems.vht_operation;
+
 	if (capab)
 		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
 	if (oper)
 		dst->ht_param = oper->ht_param;
-
+	dst->has_vht = 0;
+	if (vht_oper) {
+		dst->has_vht = 1;
+		memcpy(&dst->vht_oper, vht_oper, sizeof(*vht_oper));
+	}
 	calculate_update_time(fetch_time, src->age, &dst->last_update);
 }
 
diff -urpN hostapd-2016-10-15/wpa_supplicant/bss.h hostapd-2016-09-05.dd/wpa_supplicant/bss.h
--- hostapd-2016-10-15/wpa_supplicant/bss.h	2017-10-19 00:05:11.523747805 +0200
+++ hostapd-2016-09-05.dd/wpa_supplicant/bss.h	2017-02-19 15:21:18.000000000 +0100
@@ -79,6 +79,9 @@ struct wpa_bss {
 	u8 ssid[SSID_MAX_LEN];
 	/** Length of SSID */
 	size_t ssid_len;
+	
+	u8 has_vht;
+	struct ieee80211_vht_operation vht_oper;
 	/** HT capabilities */
 	u16 ht_capab;
 	/* Five octets of HT Operation Information */
Binary files hostapd-2016-10-15/wpa_supplicant/bss.o and hostapd-2016-09-05.dd/wpa_supplicant/bss.o differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/config.c hostapd-2016-09-05.dd/wpa_supplicant/config.c
Binary files hostapd-2016-10-15/wpa_supplicant/config.o and hostapd-2016-09-05.dd/wpa_supplicant/config.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/config_file.o and hostapd-2016-09-05.dd/wpa_supplicant/config_file.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/ctrl_iface.o and hostapd-2016-09-05.dd/wpa_supplicant/ctrl_iface.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/ctrl_iface_unix.o and hostapd-2016-09-05.dd/wpa_supplicant/ctrl_iface_unix.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/eap_register.o and hostapd-2016-09-05.dd/wpa_supplicant/eap_register.o differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/eapol_test.c hostapd-2016-09-05.dd/wpa_supplicant/eapol_test.c
diff -urpN hostapd-2016-10-15/wpa_supplicant/events.c hostapd-2016-09-05.dd/wpa_supplicant/events.c
Binary files hostapd-2016-10-15/wpa_supplicant/events.o and hostapd-2016-09-05.dd/wpa_supplicant/events.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/main.o and hostapd-2016-09-05.dd/wpa_supplicant/main.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/notify.o and hostapd-2016-09-05.dd/wpa_supplicant/notify.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/scan.o and hostapd-2016-09-05.dd/wpa_supplicant/scan.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/wmm_ac.o and hostapd-2016-09-05.dd/wpa_supplicant/wmm_ac.o differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/wnm_sta.c hostapd-2016-09-05.dd/wpa_supplicant/wnm_sta.c
--- hostapd-2016-10-15/wpa_supplicant/wnm_sta.c	2017-10-19 00:03:51.000000000 +0200
+++ hostapd-2016-09-05.dd/wpa_supplicant/wnm_sta.c	2017-10-16 22:14:44.000000000 +0200
@@ -260,7 +260,7 @@ static void ieee802_11_rx_wnmsleep_resp(
 
 	if (!wpa_s->wnmsleep_used) {
 		wpa_printf(MSG_DEBUG,
-			   "WNM: Ignore WNM-Sleep Mode Response frame since WNM-Sleep Mode has not been used in this association");
+			   "WNM: Ignore WNM-Sleep Mode Response frame since WNM-Sleep Mode operation has not been requested");
 		return;
 	}
 
@@ -299,6 +299,8 @@ static void ieee802_11_rx_wnmsleep_resp(
 		return;
 	}
 
+	wpa_s->wnmsleep_used = 0;
+
 	if (wnmsleep_ie->status == WNM_STATUS_SLEEP_ACCEPT ||
 	    wnmsleep_ie->status == WNM_STATUS_SLEEP_EXIT_ACCEPT_GTK_UPDATE) {
 		wpa_printf(MSG_DEBUG, "Successfully recv WNM-Sleep Response "
Binary files hostapd-2016-10-15/wpa_supplicant/wpa_cli and hostapd-2016-09-05.dd/wpa_supplicant/wpa_cli differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/wpa_cli.c hostapd-2016-09-05.dd/wpa_supplicant/wpa_cli.c
Binary files hostapd-2016-10-15/wpa_supplicant/wpa_cli.o and hostapd-2016-09-05.dd/wpa_supplicant/wpa_cli.o differ
diff -urpN hostapd-2016-10-15/wpa_supplicant/wpa_supplicant.c hostapd-2016-09-05.dd/wpa_supplicant/wpa_supplicant.c
--- hostapd-2016-10-15/wpa_supplicant/wpa_supplicant.c	2017-10-19 00:05:11.543747547 +0200
+++ hostapd-2016-09-05.dd/wpa_supplicant/wpa_supplicant.c	2017-02-19 15:21:18.000000000 +0100
@@ -147,10 +147,25 @@ static int hostapd_reload(struct wpa_sup
 	}
 
 	hw_mode = ieee80211_freq_to_chan(bss->freq, &channel);
-	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=%d hw_mode=%d",
-		     channel, sec_chan, hw_mode) < 0)
-		return -1;
-
+	if (bss->has_vht) {
+		if (asprintf(&cmd, "UPDATE channel=%d frequency=%d chwidth=%d sec_chan=%d sec_idx0=%d sec_idx1=%d hw_mode=%d ieee80211n=%d", 
+		    channel, 
+		    bss->freq,bss->vht_oper.vht_op_info_chwidth, 
+		    sec_chan, 
+		    bss->vht_oper.vht_op_info_chan_center_freq_seg0_idx, 
+		    bss->vht_oper.vht_op_info_chan_center_freq_seg1_idx, 
+		    hw_mode, !!bss->ht_capab) < 0)
+		return -1;
+	} else { 
+		if (asprintf(&cmd, "UPDATE channel=%d frequency=%d sec_chan=%d hw_mode=%d ieee80211n=%d",
+		     channel, bss->freq, sec_chan, hw_mode, !!bss->ht_capab) < 0)
+		return -1;
+	}
+	fprintf(stderr,"send command %s\n",cmd);
+//	char log[256];
+//	sprintf(log,"echo \"send command %s\n\" >> /tmp/send.log\n",cmd);
+//	system(log);
+//	wpa_printf(MSG_DEBUG, "\nsend command %s\n",cmd);
 	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
 	free(cmd);
 
@@ -1985,7 +2000,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
 		if (sec_chan->chan == channel + ht40 * 4)
 			break;
 		sec_chan = NULL;
-	}
+ 	}
 	if (!sec_chan)
 		return;
 
@@ -1996,12 +2011,12 @@ void ibss_mesh_setup_freq(struct wpa_sup
 	freq->channel = pri_chan->chan;
 
 	if (ht40 == -1) {
-		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40MINUS))
-			return;
+ 		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40MINUS))
+ 			return;
 	} else {
-		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40PLUS))
-			return;
-	}
+ 		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40PLUS))
+ 			return;
+ 	}
 	freq->sec_channel_offset = ht40;
 
 	if (obss_scan) {
@@ -5144,7 +5159,6 @@ static void wpa_supplicant_deinit_iface(
 	os_free(wpa_s);
 }
 
-
 #ifdef CONFIG_MATCH_IFACE
 
 /**
@@ -5175,6 +5189,7 @@ struct wpa_interface * wpa_supplicant_ma
 	return NULL;
 }
 
+
 /**
  * wpa_supplicant_match_existing - Match existing interfaces
  * @global: Pointer to global data from wpa_supplicant_init()
@@ -5217,6 +5232,8 @@ extern void supplicant_event(void *ctx,
 extern void supplicant_event_global(void *ctx, enum wpa_event_type event,
  				 union wpa_event_data *data);
 
+
+
 /**
  * wpa_supplicant_add_iface - Add a new network interface
  * @global: Pointer to global data from wpa_supplicant_init()
@@ -5471,9 +5488,9 @@ struct wpa_global * wpa_supplicant_init(
 #ifndef CONFIG_NO_WPA_MSG
 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
 #endif /* CONFIG_NO_WPA_MSG */
+
 	wpa_supplicant_event = supplicant_event;
 	wpa_supplicant_event_global = supplicant_event_global;
-
 	if (params->wpa_debug_file_path)
 		wpa_debug_open_file(params->wpa_debug_file_path);
 	else
Binary files hostapd-2016-10-15/wpa_supplicant/wpa_supplicant.o and hostapd-2016-09-05.dd/wpa_supplicant/wpa_supplicant.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/wpa_supplicant_multi.a and hostapd-2016-09-05.dd/wpa_supplicant/wpa_supplicant_multi.a differ
Binary files hostapd-2016-10-15/wpa_supplicant/wpa_supplicant_multi.o and hostapd-2016-09-05.dd/wpa_supplicant/wpa_supplicant_multi.o differ
Binary files hostapd-2016-10-15/wpa_supplicant/wpas_glue.o and hostapd-2016-09-05.dd/wpa_supplicant/wpas_glue.o differ
Binary files hostapd-2016-10-15/wpad and hostapd-2016-09-05.dd/wpad differ
