diff -urpN busybox-1.28.4/0086-dpkg-fix-symlink-creation-closes-10941.patch busybox-1.29.0/0086-dpkg-fix-symlink-creation-closes-10941.patch
--- busybox-1.28.4/0086-dpkg-fix-symlink-creation-closes-10941.patch	2018-05-22 17:49:24.000000000 +0200
+++ busybox-1.29.0/0086-dpkg-fix-symlink-creation-closes-10941.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-From dd56921e2d404c8fc9484290a36411a13d14df1a Mon Sep 17 00:00:00 2001
-From: Denys Vlasenko <vda.linux@googlemail.com>
-Date: Fri, 13 Apr 2018 13:26:33 +0200
-Subject: [PATCH 086/131] dpkg: fix symlink creation, closes 10941
-
-function                                             old     new   delta
-get_header_ar                                        434     442      +8
-
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- archival/libarchive/get_header_ar.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/archival/libarchive/get_header_ar.c b/archival/libarchive/get_header_ar.c
-index 93e071c9f..a97970630 100644
---- a/archival/libarchive/get_header_ar.c
-+++ b/archival/libarchive/get_header_ar.c
-@@ -127,8 +127,10 @@ char FAST_FUNC get_header_ar(archive_handle_t *archive_handle)
- 		archive_handle->action_header(typed);
- #if ENABLE_DPKG || ENABLE_DPKG_DEB
- 		if (archive_handle->dpkg__sub_archive) {
--			while (archive_handle->dpkg__action_data_subarchive(archive_handle->dpkg__sub_archive) == EXIT_SUCCESS)
-+			struct archive_handle_t *sa = archive_handle->dpkg__sub_archive;
-+			while (archive_handle->dpkg__action_data_subarchive(sa) == EXIT_SUCCESS)
- 				continue;
-+			create_symlinks_from_list(sa->symlink_placeholders);
- 		} else
- #endif
- 			archive_handle->action_data(archive_handle);
--- 
-2.16.2
-
diff -urpN busybox-1.28.4/0122-nsenter-Rename-network-option-to-net.patch busybox-1.29.0/0122-nsenter-Rename-network-option-to-net.patch
--- busybox-1.28.4/0122-nsenter-Rename-network-option-to-net.patch	2018-05-22 17:49:24.000000000 +0200
+++ busybox-1.29.0/0122-nsenter-Rename-network-option-to-net.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-From 40394cb1c963c35d2daa9570ba968afa981cf1fc Mon Sep 17 00:00:00 2001
-From: Euan Harris <euan.harris@docker.com>
-Date: Thu, 3 May 2018 13:34:46 +0100
-Subject: [PATCH 122/131] nsenter: Rename --network option to --net
-
-In nsenter from util-linux, the long version of the -n option is
---net=<path>.   BusyBox's version expects --network=<path>, so scripts
-and examples written for util-linux's version cause BusyBox's version
-to exit with the usage message.
-
-Confusingly, until commit 036585a911a5f, the usage message erroneously
-claimed that the long option was indeed called --net; after that commit
-long options are not listed at all.
-
-Signed-off-by: Euan Harris <euan.harris@docker.com>
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- util-linux/nsenter.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/util-linux/nsenter.c b/util-linux/nsenter.c
-index c6933c8d5..35439a2ab 100644
---- a/util-linux/nsenter.c
-+++ b/util-linux/nsenter.c
-@@ -112,7 +112,7 @@ static const char nsenter_longopts[] ALIGN1 =
- 	"user\0"			Optional_argument	"U"
- 	"ipc\0"				Optional_argument	"i"
- 	"uts\0"				Optional_argument	"u"
--	"network\0"			Optional_argument	"n"
-+	"net\0"				Optional_argument	"n"
- 	"pid\0"				Optional_argument	"p"
- 	"mount\0"			Optional_argument	"m"
- 	"target\0"			Required_argument	"t"
--- 
-2.16.2
-
diff -urpN busybox-1.28.4/0123-nsenter-fix-parsing-of-t-S-and-G-options.patch busybox-1.29.0/0123-nsenter-fix-parsing-of-t-S-and-G-options.patch
--- busybox-1.28.4/0123-nsenter-fix-parsing-of-t-S-and-G-options.patch	2018-05-22 17:49:24.000000000 +0200
+++ busybox-1.29.0/0123-nsenter-fix-parsing-of-t-S-and-G-options.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-From 254e47372f77ea1070be6dbb44b5c45770115a07 Mon Sep 17 00:00:00 2001
-From: Euan Harris <euan.harris@docker.com>
-Date: Fri, 4 May 2018 16:18:47 +0100
-Subject: [PATCH 123/131] nsenter: fix parsing of -t, -S and -G options
-
--t, -S and -G each take mandatory integer arguments.   getopt32long()'s
-option string syntax for this type of argument is 'c:+', however nsenter's
-opt_str uses 'c+', which specifies two options 'c' and '+' which do not
-take arguments.   This means that giving a target PID causes nsenter to
-exit and print the usage string:
-
-  # nsenter -t1 sh
-  nsenter: unrecognized option: 1
-  BusyBox v1.27.2 (2017-12-12 10:41:50 GMT) multi-call binary.
-  ...
-
-The long form options are also broken:
-
-  # nsenter --setuid=1000 --setgid=1000 sh
-  BusyBox v1.29.0.git (2018-05-04 13:56:49 UTC) multi-call binary.
-  ...
-
-`nsenter --target=<pid> sh` parses correctly and appears to work, but
-<pid> is ignored and set to 0.   This doesn't raise an error unless one
-of the namespace arguments is also given:
-
-  # ./busybox_unstripped nsenter --target=42 sh
-  # exit
-
-  # ./busybox_unstripped nsenter -n --target=42 sh
-  BusyBox v1.29.0.git (2018-05-04 13:56:49 UTC) multi-call binary.
-  ...
-
-This has caused problems in a couple of places:
-
-  https://github.com/linuxkit/linuxkit/issues/567
-  https://github.com/gliderlabs/docker-alpine/issues/359
-  https://github.com/kontena/pharos-cluster/pull/81
-
-Signed-off-by: Euan Harris <euan.harris@docker.com>
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- util-linux/nsenter.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/util-linux/nsenter.c b/util-linux/nsenter.c
-index 35439a2ab..ae8103a52 100644
---- a/util-linux/nsenter.c
-+++ b/util-linux/nsenter.c
-@@ -105,7 +105,7 @@ static const struct namespace_descr ns_list[] = {
- /*
-  * Upstream nsenter doesn't support the short option for --preserve-credentials
-  */
--static const char opt_str[] ALIGN1 = "U::i::u::n::p::m::""t+S+G+r::w::F";
-+static const char opt_str[] ALIGN1 = "U::i::u::n::p::m::""t:+S:+G:+r::w::F";
- 
- #if ENABLE_LONG_OPTS
- static const char nsenter_longopts[] ALIGN1 =
--- 
-2.16.2
-
diff -urpN busybox-1.28.4/Config.in busybox-1.29.0/Config.in
--- busybox-1.28.4/Config.in	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/Config.in	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 mainmenu "Configuration"
@@ -518,6 +518,14 @@ config USE_PORTABLE_CODE
 	compiler other than gcc.
 	If you do use gcc, this option may needlessly increase code size.
 
+config STACK_OPTIMIZATION_386
+	bool "Use -mpreferred-stack-boundary=2 on i386 arch"
+	default y
+	help
+	This option makes for smaller code, but some libc versions
+	do not work with it (they use SSE instructions without
+	ensuring stack alignment).
+
 comment 'Installation Options ("make install" behavior)'
 
 choice
diff -urpN busybox-1.28.4/Makefile busybox-1.29.0/Makefile
--- busybox-1.28.4/Makefile	2018-05-22 17:53:06.000000000 +0200
+++ busybox-1.29.0/Makefile	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 VERSION = 1
-PATCHLEVEL = 28
-SUBLEVEL = 4
+PATCHLEVEL = 29
+SUBLEVEL = 0
 EXTRAVERSION =
 NAME = Unnamed
 
@@ -368,7 +368,7 @@ gen_build_files: $(wildcard $(srctree)/*
 # we depend on scripts_basic, since scripts/basic/fixdep
 # must be built before any other host prog
 PHONY += applets_dir
-applets_dir: scripts_basic gen_build_files
+applets_dir: scripts_basic gen_build_files include/config/MARKER
 	$(Q)$(MAKE) $(build)=applets
 
 applets/%: applets_dir ;
diff -urpN busybox-1.28.4/Makefile.custom busybox-1.29.0/Makefile.custom
--- busybox-1.28.4/Makefile.custom	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/Makefile.custom	2018-07-02 15:55:14.000000000 +0200
@@ -11,6 +11,9 @@ busybox.cfg.nosuid: $(srctree)/applets/b
 	$(Q)-SUID="DROP" $(SHELL) $^ > $@
 
 .PHONY: install
+ifeq ($(CONFIG_INSTALL_APPLET_DONT),y)
+INSTALL_OPTS:= --none
+endif
 ifeq ($(CONFIG_INSTALL_APPLET_SYMLINKS),y)
 INSTALL_OPTS:= --symlinks
 endif
@@ -46,6 +49,9 @@ ifeq ($(strip $(CONFIG_FEATURE_SUID)),y)
 	@echo
 endif
 
+install-noclobber: INSTALL_OPTS+=--noclobber
+install-noclobber: install
+
 uninstall: busybox.links
 	rm -f $(CONFIG_PREFIX)/bin/busybox
 	for i in `cat busybox.links` ; do rm -f $(CONFIG_PREFIX)$$i; done
diff -urpN busybox-1.28.4/Makefile.flags busybox-1.29.0/Makefile.flags
--- busybox-1.28.4/Makefile.flags	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/Makefile.flags	2018-07-02 15:55:14.000000000 +0200
@@ -156,6 +156,10 @@ CPPFLAGS += $(SELINUX_CFLAGS)
 LDLIBS += $(if $(SELINUX_LIBS),$(SELINUX_LIBS:-l%=%),$(SELINUX_PC_MODULES:lib%=%))
 endif
 
+ifeq ($(CONFIG_FEATURE_NSLOOKUP_BIG),y)
+LDLIBS += resolv
+endif
+
 ifeq ($(CONFIG_EFENCE),y)
 LDLIBS += efence
 endif
diff -urpN busybox-1.28.4/NOFORK_NOEXEC.lst busybox-1.29.0/NOFORK_NOEXEC.lst
--- busybox-1.28.4/NOFORK_NOEXEC.lst	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/NOFORK_NOEXEC.lst	2018-07-02 15:55:14.000000000 +0200
@@ -72,7 +72,7 @@ brctl - noexec
 bunzip2 - runner
 bzcat - runner
 bzip2 - runner
-cal - runner: cal -n9999
+cal - noexec. can be runner: cal -n9999
 cat - runner: cat HUGEFILE
 chat - longterm (when used as intended - talking to modem over stdin/out)
 chattr - noexec. runner
@@ -89,7 +89,7 @@ clear - NOFORK
 cmp - runner
 comm - runner
 conspy - interactive, longterm
-cp - noexec. runner
+cp - noexec. sometimes runner
 cpio - runner
 crond - daemon
 crontab - longterm (runs $EDITOR), leaks: open+xasprintf
@@ -255,7 +255,7 @@ mount - suid
 mountpoint - noexec. leaks: option -n "print dev name": find_block_device -> readdir+xstrdup
 mpstat - longterm: "mpstat 1" runs indefinitely
 mt - hardware
-mv - noexec candidate, runner
+mv - noexec. sometimes runner
 nameif - noexec. openlog(), leaks: config_open2+ioctl_or_perror_and_die
 nbd-client - noexec
 nc - runner
diff -urpN busybox-1.28.4/NOFORK_NOEXEC.sh busybox-1.29.0/NOFORK_NOEXEC.sh
--- busybox-1.28.4/NOFORK_NOEXEC.sh	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/NOFORK_NOEXEC.sh	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+exec >NOFORK_NOEXEC.lst1
+
+false && grep -Fv 'NOFORK' NOFORK_NOEXEC.lst \
+| grep -v 'noexec.' | grep -v 'noexec$' \
+| grep -v ' suid' \
+| grep -v ' daemon' \
+| grep -v ' longterm' \
+| grep rare
+
+echo === nofork candidate
+grep -F 'nofork candidate' NOFORK_NOEXEC.lst \
+
+echo === noexec candidate
+grep -F 'noexec candidate' NOFORK_NOEXEC.lst \
+
+echo === ^C
+grep -F '^C' NOFORK_NOEXEC.lst \
+| grep -F ' - ' \
+
+echo === talks
+grep -F 'talks' NOFORK_NOEXEC.lst \
+| grep -F ' - ' \
+
+echo ===
+grep -Fv 'NOFORK' NOFORK_NOEXEC.lst \
+| grep '^[^ ][^ ]* - ' \
+| grep -v 'noexec.' | grep -v ' - noexec$' \
+| grep -v ' suid' \
+| grep -v ' daemon' \
+| grep -v 'longterm' \
+| grep -v 'interactive' \
+| grep -v 'hardware' \
diff -urpN busybox-1.28.4/applets/applet_tables.c busybox-1.29.0/applets/applet_tables.c
--- busybox-1.28.4/applets/applet_tables.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/applets/applet_tables.c	2018-07-02 15:55:14.000000000 +0200
@@ -10,6 +10,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -61,6 +62,7 @@ static int str_isalnum_(const char *s)
 int main(int argc, char **argv)
 {
 	int i, j;
+	char tmp1[PATH_MAX], tmp2[PATH_MAX];
 
 	// In find_applet_by_name(), before linear search, narrow it down
 	// by looking at N "equidistant" names. With ~350 applets:
@@ -84,7 +86,8 @@ int main(int argc, char **argv)
 
 	if (!argv[1])
 		return 1;
-	i = open(argv[1], O_WRONLY | O_TRUNC | O_CREAT, 0666);
+	snprintf(tmp1, PATH_MAX, "%s.%u.new", argv[1], (int) getpid());
+	i = open(tmp1, O_WRONLY | O_TRUNC | O_CREAT, 0666);
 	if (i < 0)
 		return 1;
 	dup2(i, 1);
@@ -209,12 +212,21 @@ int main(int argc, char **argv)
 //			fclose(fp);
 //		}
 //		if (strcmp(line_old, line_new) != 0) {
-			fp = fopen(argv[2], "w");
+			snprintf(tmp2, PATH_MAX, "%s.%u.new", argv[2], (int) getpid());
+			fp = fopen(tmp2, "w");
 			if (!fp)
 				return 1;
 			fputs(line_new, fp);
+			if (fclose(fp))
+				return 1;
 //		}
 	}
 
+	if (fclose(stdout))
+		return 1;
+	if (rename(tmp1, argv[1]))
+		return 1;
+	if (rename(tmp2, argv[2]))
+		return 1;
 	return 0;
 }
diff -urpN busybox-1.28.4/applets/install.sh busybox-1.29.0/applets/install.sh
--- busybox-1.28.4/applets/install.sh	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/applets/install.sh	2018-07-02 15:55:14.000000000 +0200
@@ -5,9 +5,12 @@ export LC_CTYPE=POSIX
 
 prefix=$1
 if [ -z "$prefix" ]; then
-	echo "usage: applets/install.sh DESTINATION [--symlinks/--hardlinks/--binaries/--scriptwrapper]"
+	echo "usage: applets/install.sh DESTINATION TYPE [OPTS ...]"
+	echo "  TYPE is one of: --symlinks --hardlinks --binaries --scriptwrapper --none"
+	echo "  OPTS is one or more of: --cleanup --noclobber"
 	exit 1
 fi
+shift # Keep only remaining options
 
 # Source the configuration
 . ./.config
@@ -21,20 +24,23 @@ scriptwrapper="n"
 binaries="n"
 cleanup="0"
 noclobber="0"
-case "$2" in
-	--hardlinks)     linkopts="-f";;
-	--symlinks)      linkopts="-fs";;
-	--binaries)      binaries="y";;
-	--scriptwrapper) scriptwrapper="y";swrapall="y";;
-	--sw-sh-hard)    scriptwrapper="y";linkopts="-f";;
-	--sw-sh-sym)     scriptwrapper="y";linkopts="-fs";;
-	--cleanup)       cleanup="1";;
-	--noclobber)     noclobber="1";;
-	"")              h="";;
-	*)               echo "Unknown install option: $2"; exit 1;;
-esac
+while [ ${#} -gt 0 ]; do
+	case "$1" in
+		--hardlinks)     linkopts="-f";;
+		--symlinks)      linkopts="-fs";;
+		--binaries)      binaries="y";;
+		--scriptwrapper) scriptwrapper="y"; swrapall="y";;
+		--sw-sh-hard)    scriptwrapper="y"; linkopts="-f";;
+		--sw-sh-sym)     scriptwrapper="y"; linkopts="-fs";;
+		--cleanup)       cleanup="1";;
+		--noclobber)     noclobber="1";;
+		--none)          h="";;
+		*)               echo "Unknown install option: $1"; exit 1;;
+	esac
+	shift
+done
 
-if [ -n "$DO_INSTALL_LIBS" ] && [ "$DO_INSTALL_LIBS" != "n" ]; then
+if [ -n "$DO_INSTALL_LIBS" ] && [ x"$DO_INSTALL_LIBS" != x"n" ]; then
 	# get the target dir for the libs
 	# assume it starts with lib
 	libdir=$($CC -print-file-name=libc.so | \
@@ -54,7 +60,7 @@ if [ -n "$DO_INSTALL_LIBS" ] && [ "$DO_I
 	done
 fi
 
-if [ "$cleanup" = "1" ] && [ -e "$prefix/bin/busybox" ]; then
+if [ x"$cleanup" = x"1" ] && [ -e "$prefix/bin/busybox" ]; then
 	inode=`ls -i "$prefix/bin/busybox" | awk '{print $1}'`
 	sub_shell_it=`
 		cd "$prefix"
@@ -77,9 +83,13 @@ install -m 755 busybox "$prefix/bin/busy
 for i in $h; do
 	appdir=`dirname "$i"`
 	app=`basename "$i"`
+	if [ x"$noclobber" = x"1" ] && [ -e "$prefix/$i" ]; then
+		echo "  $prefix/$i already exists"
+		continue
+	fi
 	mkdir -p "$prefix/$appdir" || exit 1
-	if [ "$scriptwrapper" = "y" ]; then
-		if [ "$swrapall" != "y" ] && [ "$i" = "/bin/sh" ]; then
+	if [ x"$scriptwrapper" = x"y" ]; then
+		if [ x"$swrapall" != x"y" ] && [ x"$i" = x"/bin/sh" ]; then
 			ln $linkopts busybox "$prefix/$i" || exit 1
 		else
 			rm -f "$prefix/$i"
@@ -87,21 +97,17 @@ for i in $h; do
 			chmod +x "$prefix/$i"
 		fi
 		echo "	$prefix/$i"
-	elif [ "$binaries" = "y" ]; then
+	elif [ x"$binaries" = x"y" ]; then
 		# Copy the binary over rather
-		if [ -e $sharedlib_dir/$app ]; then
-			if [ "$noclobber" = "0" ] || [ ! -e "$prefix/$i" ]; then
-				echo "   Copying $sharedlib_dir/$app to $prefix/$i"
-				cp -pPR $sharedlib_dir/$app $prefix/$i || exit 1
-			else
-				echo "  $prefix/$i already exists"
-			fi
+		if [ -e "$sharedlib_dir/$app" ]; then
+			echo "   Copying $sharedlib_dir/$app to $prefix/$i"
+			cp -pPR "$sharedlib_dir/$app" "$prefix/$i" || exit 1
 		else
 			echo "Error: Could not find $sharedlib_dir/$app"
 			exit 1
 		fi
 	else
-		if [ "$2" = "--hardlinks" ]; then
+		if [ x"$linkopts" = x"-f" ]; then
 			bb_path="$prefix/bin/busybox"
 		else
 			case "$appdir" in
@@ -123,12 +129,8 @@ for i in $h; do
 			;;
 			esac
 		fi
-		if [ "$noclobber" = "0" ] || [ ! -e "$prefix/$i" ]; then
-			echo "  $prefix/$i -> $bb_path"
-			ln $linkopts "$bb_path" "$prefix/$i" || exit 1
-		else
-			echo "  $prefix/$i already exists"
-		fi
+		echo "  $prefix/$i -> $bb_path"
+		ln $linkopts "$bb_path" "$prefix/$i" || exit 1
 	fi
 done
 
diff -urpN busybox-1.28.4/arch/i386/Makefile busybox-1.29.0/arch/i386/Makefile
--- busybox-1.28.4/arch/i386/Makefile	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/arch/i386/Makefile	2018-07-02 15:55:14.000000000 +0200
@@ -2,6 +2,12 @@
 # Build system
 # ==========================================================================
 
+# Allow i486 insns (basically, bswap insn)
+# Do not try to tune for 486+ (might add padding)
+CFLAGS += $(call cc-option,-march=i486 -mtune=i386,)
+
+ifeq ($(CONFIG_STACK_OPTIMIZATION_386),y)
 # -mpreferred-stack-boundary=2 is essential in preventing gcc 4.2.x
 # from aligning stack to 16 bytes. (Which is gcc's way of supporting SSE).
-CFLAGS += $(call cc-option,-march=i386 -mpreferred-stack-boundary=2,)
+CFLAGS += $(call cc-option,-mpreferred-stack-boundary=2,)
+endif
diff -urpN busybox-1.28.4/archival/Config.src busybox-1.29.0/archival/Config.src
--- busybox-1.28.4/archival/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/archival/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Archival Utilities"
diff -urpN busybox-1.28.4/archival/bbunzip.c busybox-1.29.0/archival/bbunzip.c
--- busybox-1.28.4/archival/bbunzip.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/bbunzip.c	2018-07-02 15:55:14.000000000 +0200
@@ -21,19 +21,6 @@
 #include "libbb.h"
 #include "bb_archive.h"
 
-/* Note: must be kept in sync with archival/lzop.c */
-enum {
-	OPT_STDOUT     = 1 << 0,
-	OPT_FORCE      = 1 << 1,
-	/* only some decompressors: */
-	OPT_KEEP       = 1 << 2,
-	OPT_VERBOSE    = 1 << 3,
-	OPT_QUIET      = 1 << 4,
-	OPT_DECOMPRESS = 1 << 5,
-	OPT_TEST       = 1 << 6,
-	SEAMLESS_MAGIC = (1 << 31) * ENABLE_ZCAT * SEAMLESS_COMPRESSION,
-};
-
 static
 int open_to_or_warn(int to_fd, const char *filename, int flags, int mode)
 {
@@ -72,7 +59,7 @@ int FAST_FUNC bbunpack(char **argv,
 
 		/* Open src */
 		if (filename) {
-			if (!(option_mask32 & SEAMLESS_MAGIC)) {
+			if (!(option_mask32 & BBUNPK_SEAMLESS_MAGIC)) {
 				if (stat(filename, &stat_buf) != 0) {
  err_name:
 					bb_simple_perror_msg(filename);
@@ -91,15 +78,15 @@ int FAST_FUNC bbunpack(char **argv,
 				xmove_fd(fd, STDIN_FILENO);
 			}
 		} else
-		if (option_mask32 & SEAMLESS_MAGIC) {
+		if (option_mask32 & BBUNPK_SEAMLESS_MAGIC) {
 			/* "clever zcat" on stdin */
 			if (setup_unzip_on_fd(STDIN_FILENO, /*fail_if_not_compressed*/ 1))
 				goto err;
 		}
 
 		/* Special cases: test, stdout */
-		if (option_mask32 & (OPT_STDOUT|OPT_TEST)) {
-			if (option_mask32 & OPT_TEST)
+		if (option_mask32 & (BBUNPK_OPT_STDOUT|BBUNPK_OPT_TEST)) {
+			if (option_mask32 & BBUNPK_OPT_TEST)
 				if (open_to_or_warn(STDOUT_FILENO, bb_dev_null, O_WRONLY, 0))
 					xfunc_die();
 			filename = NULL;
@@ -114,7 +101,7 @@ int FAST_FUNC bbunpack(char **argv,
 			}
 
 			/* -f: overwrite existing output files */
-			if (option_mask32 & OPT_FORCE) {
+			if (option_mask32 & BBUNPK_OPT_FORCE) {
 				unlink(new_name);
 			}
 
@@ -126,12 +113,12 @@ int FAST_FUNC bbunpack(char **argv,
 		}
 
 		/* Check that the input is sane */
-		if (!(option_mask32 & OPT_FORCE) && isatty(STDIN_FILENO)) {
+		if (!(option_mask32 & BBUNPK_OPT_FORCE) && isatty(STDIN_FILENO)) {
 			bb_error_msg_and_die("compressed data not read from terminal, "
 					"use -f to force it");
 		}
 
-		if (!(option_mask32 & SEAMLESS_MAGIC)) {
+		if (!(option_mask32 & BBUNPK_SEAMLESS_MAGIC)) {
 			init_transformer_state(&xstate);
 			/*xstate.signature_skipped = 0; - already is */
 			/*xstate.src_fd = STDIN_FILENO; - already is */
@@ -145,7 +132,7 @@ int FAST_FUNC bbunpack(char **argv,
 				xfunc_die();
 		}
 
-		if (!(option_mask32 & OPT_STDOUT))
+		if (!(option_mask32 & BBUNPK_OPT_STDOUT))
 			xclose(STDOUT_FILENO); /* with error check! */
 
 		if (filename) {
@@ -176,7 +163,7 @@ int FAST_FUNC bbunpack(char **argv,
 				}
 				/* Extreme bloat for gunzip compat */
 				/* Some users do want this info... */
-				if (ENABLE_DESKTOP && (option_mask32 & OPT_VERBOSE)) {
+				if (ENABLE_DESKTOP && (option_mask32 & BBUNPK_OPT_VERBOSE)) {
 					unsigned percent = status
 						? ((uoff_t)stat_buf.st_size * 100u / (unsigned long long)status)
 						: 0;
@@ -188,7 +175,7 @@ int FAST_FUNC bbunpack(char **argv,
 				}
 				/* Delete _source_ file */
 				del = filename;
-				if (option_mask32 & OPT_KEEP) /* ... unless -k */
+				if (option_mask32 & BBUNPK_OPT_KEEP) /* ... unless -k */
 					del = NULL;
 			}
 			if (del)
@@ -199,7 +186,7 @@ int FAST_FUNC bbunpack(char **argv,
 		}
 	} while (*argv && *++argv);
 
-	if (option_mask32 & OPT_STDOUT)
+	if (option_mask32 & BBUNPK_OPT_STDOUT)
 		xclose(STDOUT_FILENO); /* with error check! */
 
 	return exitcode;
@@ -389,9 +376,9 @@ int gunzip_main(int argc, char **argv) M
 int gunzip_main(int argc UNUSED_PARAM, char **argv)
 {
 #if ENABLE_FEATURE_GUNZIP_LONG_OPTIONS
-	getopt32long(argv, "cfkvqdtn", gunzip_longopts);
+	getopt32long(argv, BBUNPK_OPTSTR "dtn", gunzip_longopts);
 #else
-	getopt32(argv, "cfkvqdtn");
+	getopt32(argv, BBUNPK_OPTSTR "dtn");
 #endif
 	argv += optind;
 
@@ -400,7 +387,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 	 * But if seamless magic is enabled, then we are much more clever.
 	 */
 	if (ENABLE_ZCAT && (!ENABLE_GUNZIP || applet_name[1] == 'c'))
-		option_mask32 |= OPT_STDOUT | SEAMLESS_MAGIC;
+		option_mask32 |= BBUNPK_OPT_STDOUT | BBUNPK_SEAMLESS_MAGIC;
 
 	return bbunpack(argv, unpack_gz_stream, make_new_name_gunzip, /*unused:*/ NULL);
 }
@@ -453,10 +440,10 @@ int gunzip_main(int argc UNUSED_PARAM, c
 int bunzip2_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int bunzip2_main(int argc UNUSED_PARAM, char **argv)
 {
-	getopt32(argv, "cfkvqdt");
+	getopt32(argv, BBUNPK_OPTSTR "dt");
 	argv += optind;
 	if (ENABLE_BZCAT && (!ENABLE_BUNZIP2 || applet_name[2] == 'c')) /* bzcat */
-		option_mask32 |= OPT_STDOUT;
+		option_mask32 |= BBUNPK_OPT_STDOUT;
 
 	return bbunpack(argv, unpack_bz2_stream, make_new_name_generic, "bz2");
 }
@@ -526,15 +513,15 @@ int bunzip2_main(int argc UNUSED_PARAM,
 int unlzma_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int unlzma_main(int argc UNUSED_PARAM, char **argv)
 {
-	IF_LZMA(int opts =) getopt32(argv, "cfkvqdt");
+	IF_LZMA(int opts =) getopt32(argv, BBUNPK_OPTSTR "dt");
 # if ENABLE_LZMA
 	/* lzma without -d or -t? */
-	if (applet_name[2] == 'm' && !(opts & (OPT_DECOMPRESS|OPT_TEST)))
+	if (applet_name[2] == 'm' && !(opts & (BBUNPK_OPT_DECOMPRESS|BBUNPK_OPT_TEST)))
 		bb_show_usage();
 # endif
 	/* lzcat? */
 	if (ENABLE_LZCAT && applet_name[2] == 'c')
-		option_mask32 |= OPT_STDOUT;
+		option_mask32 |= BBUNPK_OPT_STDOUT;
 
 	argv += optind;
 	return bbunpack(argv, unpack_lzma_stream, make_new_name_generic, "lzma");
@@ -594,15 +581,15 @@ int unlzma_main(int argc UNUSED_PARAM, c
 int unxz_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int unxz_main(int argc UNUSED_PARAM, char **argv)
 {
-	IF_XZ(int opts =) getopt32(argv, "cfkvqdt");
+	IF_XZ(int opts =) getopt32(argv, BBUNPK_OPTSTR "dt");
 # if ENABLE_XZ
 	/* xz without -d or -t? */
-	if (applet_name[2] == '\0' && !(opts & (OPT_DECOMPRESS|OPT_TEST)))
+	if (applet_name[2] == '\0' && !(opts & (BBUNPK_OPT_DECOMPRESS|BBUNPK_OPT_TEST)))
 		bb_show_usage();
 # endif
 	/* xzcat? */
 	if (ENABLE_XZCAT && applet_name[2] == 'c')
-		option_mask32 |= OPT_STDOUT;
+		option_mask32 |= BBUNPK_OPT_STDOUT;
 
 	argv += optind;
 	return bbunpack(argv, unpack_xz_stream, make_new_name_generic, "xz");
diff -urpN busybox-1.28.4/archival/bzip2.c busybox-1.29.0/archival/bzip2.c
--- busybox-1.28.4/archival/bzip2.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/bzip2.c	2018-07-02 15:55:14.000000000 +0200
@@ -19,6 +19,23 @@
 //config:	Unless you have a specific application which requires bzip2, you
 //config:	should probably say N here.
 //config:
+//config:config BZIP2_SMALL
+//config:	int "Trade bytes for speed (0:fast, 9:small)"
+//config:	default 8  # all "fast or small" options default to small
+//config:	range 0 9
+//config:	depends on BZIP2
+//config:	help
+//config:	Trade code size versus speed.
+//config:	Approximate values with gcc-6.3.0 "bzip -9" compressing
+//config:	linux-4.15.tar were:
+//config:	value         time (sec)  code size (386)
+//config:	9 (smallest)       70.11             7687
+//config:	8                  67.93             8091
+//config:	7                  67.88             8405
+//config:	6                  67.78             8624
+//config:	5                  67.05             9427
+//config:	4-0 (fastest)      64.14            12083
+//config:
 //config:config FEATURE_BZIP2_DECOMPRESS
 //config:	bool "Enable decompression"
 //config:	default y
@@ -48,7 +65,11 @@
 #include "libbb.h"
 #include "bb_archive.h"
 
-#define CONFIG_BZIP2_FAST 1
+#if CONFIG_BZIP2_SMALL >= 4
+#define BZIP2_SPEED (9 - CONFIG_BZIP2_SMALL)
+#else
+#define BZIP2_SPEED 5
+#endif
 
 /* Speed test:
  * Compiled with gcc 4.2.1, run on Athlon 64 1800 MHz (512K L2 cache).
@@ -56,7 +77,7 @@
  * (time to compress gcc-4.2.1.tar is 126.4% compared to bbox).
  * At SPEED 5 difference is 32.7%.
  *
- * Test run of all CONFIG_BZIP2_FAST values on a 11Mb text file:
+ * Test run of all BZIP2_SPEED values on a 11Mb text file:
  *     Size   Time (3 runs)
  * 0:  10828  4.145 4.146 4.148
  * 1:  11097  3.845 3.860 3.861
@@ -83,15 +104,13 @@
 /* No point in being shy and having very small buffer here.
  * bzip2 internal buffers are much bigger anyway, hundreds of kbytes.
  * If iobuf is several pages long, malloc() may use mmap,
- * making iobuf is page aligned and thus (maybe) have one memcpy less
+ * making iobuf page aligned and thus (maybe) have one memcpy less
  * if kernel is clever enough.
  */
 enum {
 	IOBUF_SIZE = 8 * 1024
 };
 
-static uint8_t level;
-
 /* NB: compressStream() has to return -1 on errors, not die.
  * bbunpack() will correctly clean up in this case
  * (delete incomplete .bz2 file)
@@ -143,6 +162,7 @@ static
 IF_DESKTOP(long long) int FAST_FUNC compressStream(transformer_state_t *xstate UNUSED_PARAM)
 {
 	IF_DESKTOP(long long) int total;
+	unsigned opt, level;
 	ssize_t count;
 	bz_stream bzs; /* it's small */
 #define strm (&bzs)
@@ -151,6 +171,17 @@ IF_DESKTOP(long long) int FAST_FUNC comp
 #define wbuf (iobuf + IOBUF_SIZE)
 
 	iobuf = xmalloc(2 * IOBUF_SIZE);
+
+	opt = option_mask32 >> (BBUNPK_OPTSTRLEN IF_FEATURE_BZIP2_DECOMPRESS(+ 2) + 2);
+	/* skipped BBUNPK_OPTSTR, "dt" and "zs" bits */
+	opt |= 0x100; /* if nothing else, assume -9 */
+	level = 0;
+	for (;;) {
+		level++;
+		if (opt & 1) break;
+		opt >>= 1;
+	}
+
 	BZ2_bzCompressInit(strm, level);
 
 	while (1) {
@@ -196,26 +227,19 @@ int bzip2_main(int argc UNUSED_PARAM, ch
 	 */
 
 	opt = getopt32(argv, "^"
-		/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */
-		"cfkv" IF_FEATURE_BZIP2_DECOMPRESS("dt") "123456789qzs"
+		/* Must match BBUNPK_foo constants! */
+		BBUNPK_OPTSTR IF_FEATURE_BZIP2_DECOMPRESS("dt") "zs123456789"
 		"\0" "s2" /* -s means -2 (compatibility) */
 	);
 #if ENABLE_FEATURE_BZIP2_DECOMPRESS /* bunzip2_main may not be visible... */
-	if (opt & 0x30) // -d and/or -t
+	if (opt & (BBUNPK_OPT_DECOMPRESS|BBUNPK_OPT_TEST)) /* -d and/or -t */
 		return bunzip2_main(argc, argv);
-	opt >>= 6;
 #else
-	opt >>= 4;
+	/* clear "decompress" and "test" bits (or bbunpack() can get confused) */
+	/* in !BZIP2_DECOMPRESS config, these bits are -zs and are unused */
+	option_mask32 = opt & ~(BBUNPK_OPT_DECOMPRESS|BBUNPK_OPT_TEST);
 #endif
-	opt = (uint8_t)opt; /* isolate bits for -1..-8 */
-	opt |= 0x100; /* if nothing else, assume -9 */
-	level = 1;
-	while (!(opt & 1)) {
-		level++;
-		opt >>= 1;
-	}
 
 	argv += optind;
-	option_mask32 &= 0xf; /* ignore all except -cfkv */
 	return bbunpack(argv, compressStream, append_ext, "bz2");
 }
diff -urpN busybox-1.28.4/archival/cpio.c busybox-1.29.0/archival/cpio.c
--- busybox-1.28.4/archival/cpio.c	2018-04-01 13:04:11.000000000 +0200
+++ busybox-1.29.0/archival/cpio.c	2018-07-02 15:55:14.000000000 +0200
@@ -508,7 +508,7 @@ int cpio_main(int argc UNUSED_PARAM, cha
 	while (get_header_cpio(archive_handle) == EXIT_SUCCESS)
 		continue;
 
-	create_symlinks_from_list(archive_handle->symlink_placeholders);
+	create_links_from_list(archive_handle->link_placeholders);
 
 	if (archive_handle->cpio__blocks != (off_t)-1
 	 && !(opt & OPT_QUIET)
diff -urpN busybox-1.28.4/archival/gzip.c busybox-1.29.0/archival/gzip.c
--- busybox-1.28.4/archival/gzip.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/gzip.c	2018-07-02 15:55:14.000000000 +0200
@@ -15,21 +15,6 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-/* big objects in bss:
- * 00000020 b bl_count
- * 00000074 b base_length
- * 00000078 b base_dist
- * 00000078 b static_dtree
- * 0000009c b bl_tree
- * 000000f4 b dyn_dtree
- * 00000100 b length_code
- * 00000200 b dist_code
- * 0000023d b depth
- * 00000400 b flag_buf
- * 0000047a b heap
- * 00000480 b static_ltree
- * 000008f4 b dyn_ltree
- */
 /* TODO: full support for -v for DESKTOP
  * "/usr/bin/gzip -v a bogus aa" should say:
 a:       85.1% -- replaced with a.gz
@@ -108,12 +93,12 @@ aa:      85.1% -- replaced with aa.gz
 #include "libbb.h"
 #include "bb_archive.h"
 
-
 /* ===========================================================================
  */
 //#define DEBUG 1
 /* Diagnostic functions */
 #ifdef DEBUG
+static int verbose;
 #  define Assert(cond,msg) { if (!(cond)) bb_error_msg(msg); }
 #  define Trace(x) fprintf x
 #  define Tracev(x) {if (verbose) fprintf x; }
@@ -129,7 +114,6 @@ aa:      85.1% -- replaced with aa.gz
 #  define Tracecv(c,x)
 #endif
 
-
 /* ===========================================================================
  */
 #if   CONFIG_GZIP_FAST == 0
@@ -225,7 +209,6 @@ aa:      85.1% -- replaced with aa.gz
 #  define MAX_SUFFIX  30
 #endif
 
-
 /* ===========================================================================
  * Compile with MEDIUM_MEM to reduce the memory requirements or
  * with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the
@@ -234,15 +217,14 @@ aa:      85.1% -- replaced with aa.gz
  * affects the compression ratio. The compressed output
  * is still correct, and might even be smaller in some cases.
  */
-
 #ifdef SMALL_MEM
-#   define HASH_BITS  13	/* Number of bits used to hash strings */
+#  define HASH_BITS  13	/* Number of bits used to hash strings */
 #endif
 #ifdef MEDIUM_MEM
-#   define HASH_BITS  14
+#  define HASH_BITS  14
 #endif
 #ifndef HASH_BITS
-#   define HASH_BITS  15
+#  define HASH_BITS  15
    /* For portability to 16 bit machines, do not use values above 15. */
 #endif
 
@@ -255,7 +237,6 @@ aa:      85.1% -- replaced with aa.gz
 #endif
 /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
 
-
 /* ===========================================================================
  * These types are not really 'char', 'short' and 'long'
  */
@@ -312,46 +293,10 @@ enum {
 #endif /* ENABLE_FEATURE_GZIP_LEVELS */
 };
 
-
 struct globals {
+/* =========================================================================== */
+/* global buffers, allocated once */
 
-#if ENABLE_FEATURE_GZIP_LEVELS
-	unsigned max_chain_length;
-	unsigned max_lazy_match;
-	unsigned good_match;
-	unsigned nice_match;
-#define max_chain_length (G1.max_chain_length)
-#define max_lazy_match   (G1.max_lazy_match)
-#define good_match	 (G1.good_match)
-#define nice_match	 (G1.nice_match)
-#endif
-
-	lng block_start;
-
-/* window position at the beginning of the current output block. Gets
- * negative when the window is moved backwards.
- */
-	unsigned ins_h;	/* hash index of string to be inserted */
-
-#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1) / MIN_MATCH)
-/* Number of bits by which ins_h and del_h must be shifted at each
- * input step. It must be such that after MIN_MATCH steps, the oldest
- * byte no longer takes part in the hash key, that is:
- * H_SHIFT * MIN_MATCH >= HASH_BITS
- */
-
-	unsigned prev_length;
-
-/* Length of the best match at previous step. Matches not greater than this
- * are discarded. This is used in the lazy match evaluation.
- */
-
-	unsigned strstart;	/* start of string to insert */
-	unsigned match_start;	/* start of matching string */
-	unsigned lookahead;	/* number of valid bytes ahead in window */
-
-/* ===========================================================================
- */
 #define DECLARE(type, array, size) \
 	type * array
 #define ALLOC(type, array, size) \
@@ -359,8 +304,6 @@ struct globals {
 #define FREE(array) \
 	do { free(array); array = NULL; } while (0)
 
-	/* global buffers */
-
 	/* buffer for literals or lengths */
 	/* DECLARE(uch, l_buf, LIT_BUFSIZE); */
 	DECLARE(uch, l_buf, INBUFSIZ);
@@ -390,6 +333,46 @@ struct globals {
 	/* DECLARE(Pos, head, 1<<HASH_BITS); */
 #define head (G1.prev + WSIZE) /* hash head (see deflate.c) */
 
+/* =========================================================================== */
+/* all members below are zeroed out in pack_gzip() for each next file */
+
+	uint32_t crc;	/* shift register contents */
+	/*uint32_t *crc_32_tab;*/
+
+#if ENABLE_FEATURE_GZIP_LEVELS
+	unsigned max_chain_length;
+	unsigned max_lazy_match;
+	unsigned good_match;
+	unsigned nice_match;
+#define max_chain_length (G1.max_chain_length)
+#define max_lazy_match   (G1.max_lazy_match)
+#define good_match	 (G1.good_match)
+#define nice_match	 (G1.nice_match)
+#endif
+
+/* window position at the beginning of the current output block. Gets
+ * negative when the window is moved backwards.
+ */
+	lng block_start;
+
+	unsigned ins_h;	/* hash index of string to be inserted */
+
+/* Number of bits by which ins_h and del_h must be shifted at each
+ * input step. It must be such that after MIN_MATCH steps, the oldest
+ * byte no longer takes part in the hash key, that is:
+ * H_SHIFT * MIN_MATCH >= HASH_BITS
+ */
+#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1) / MIN_MATCH)
+
+/* Length of the best match at previous step. Matches not greater than this
+ * are discarded. This is used in the lazy match evaluation.
+ */
+	unsigned prev_length;
+
+	unsigned strstart;	/* start of string to insert */
+	unsigned match_start;	/* start of matching string */
+	unsigned lookahead;	/* number of valid bytes ahead in window */
+
 /* number of input bytes */
 	ulg isize;		/* only 32 bits stored in .gz file */
 
@@ -401,40 +384,35 @@ struct globals {
 	unsigned insize;	/* valid bytes in l_buf */
 #endif
 	unsigned outcnt;	/* bytes in output buffer */
-
 	smallint eofile;	/* flag set at end of input file */
 
 /* ===========================================================================
  * Local data used by the "bit string" routines.
  */
 
-	unsigned short bi_buf;
-
 /* Output buffer. bits are inserted starting at the bottom (least significant
  * bits).
  */
+	unsigned bi_buf;	/* was unsigned short */
 
 #undef BUF_SIZE
-#define BUF_SIZE (8 * sizeof(G1.bi_buf))
+#define BUF_SIZE (int)(8 * sizeof(G1.bi_buf))
+
 /* Number of bits used within bi_buf. (bi_buf might be implemented on
  * more than 16 bits on some systems.)
  */
-
-	int bi_valid;
-
-/* Current input function. Set to mem_read for in-memory compression */
+	unsigned bi_valid;
 
 #ifdef DEBUG
-	ulg bits_sent;			/* bit length of the compressed data */
+	ulg bits_sent;	/* bit length of the compressed data */
+# define DEBUG_bits_sent(v) (void)(G1.bits_sent v)
+#else
+# define DEBUG_bits_sent(v) ((void)0)
 #endif
-
-	/*uint32_t *crc_32_tab;*/
-	uint32_t crc;	/* shift register contents */
 };
 
 #define G1 (*(ptr_to_globals - 1))
 
-
 /* ===========================================================================
  * Write the output buffer outbuf[0..outcnt-1] and update bytes_out.
  * (used for the compressed data only)
@@ -448,7 +426,6 @@ static void flush_outbuf(void)
 	G1.outcnt = 0;
 }
 
-
 /* ===========================================================================
  */
 /* put_8bit is used for the compressed output */
@@ -473,12 +450,13 @@ static void put_16bit(ush w)
 	if (outcnt < OUTBUFSIZ-2) {
 		/* Common case */
 		ush *dst16 = (void*) dst;
-		*dst16 = w; /* unalinged LSB 16-bit store */
+		*dst16 = w; /* unaligned LSB 16-bit store */
 		G1.outcnt = outcnt + 2;
 		return;
 	}
 	*dst = (uch)w;
 	w >>= 8;
+	G1.outcnt = ++outcnt;
 #else
 	*dst = (uch)w;
 	w >>= 8;
@@ -488,20 +466,38 @@ static void put_16bit(ush w)
 		G1.outcnt = outcnt + 2;
 		return;
 	}
+	G1.outcnt = ++outcnt;
 #endif
 
 	/* Slowpath: we will need to do flush_outbuf() */
-	G1.outcnt = ++outcnt;
 	if (outcnt == OUTBUFSIZ)
-		flush_outbuf();
-	put_8bit(w);
+		flush_outbuf(); /* here */
+	put_8bit(w); /* or here */
 }
 
+#define OPTIMIZED_PUT_32BIT (CONFIG_GZIP_FAST > 0 && BB_UNALIGNED_MEMACCESS_OK && BB_LITTLE_ENDIAN)
 static void put_32bit(ulg n)
 {
+	if (OPTIMIZED_PUT_32BIT) {
+		unsigned outcnt = G1.outcnt;
+		if (outcnt < OUTBUFSIZ-4) {
+			/* Common case */
+			ulg *dst32 = (void*) &G1.outbuf[outcnt];
+			*dst32 = n; /* unaligned LSB 32-bit store */
+			//bb_error_msg("%p", dst32); // store alignment debugging
+			G1.outcnt = outcnt + 4;
+			return;
+		}
+	}
 	put_16bit(n);
 	put_16bit(n >> 16);
 }
+static ALWAYS_INLINE void flush_outbuf_if_32bit_optimized(void)
+{
+	/* If put_32bit() performs 32bit stores && it is used in send_bits() */
+	if (OPTIMIZED_PUT_32BIT && BUF_SIZE > 16)
+		flush_outbuf();
+}
 
 /* ===========================================================================
  * Run a set of bytes through the crc shift register.  If s is a NULL
@@ -513,7 +509,6 @@ static void updcrc(uch * s, unsigned n)
 	G1.crc = crc32_block_endian0(G1.crc, s, n, global_crc32_table /*G1.crc_32_tab*/);
 }
 
-
 /* ===========================================================================
  * Read a new buffer from the current input file, perform end-of-line
  * translation, and update the crc and input file size.
@@ -534,34 +529,45 @@ static unsigned file_read(void *buf, uns
 	return len;
 }
 
-
 /* ===========================================================================
  * Send a value on a given number of bits.
  * IN assertion: length <= 16 and value fits in length bits.
  */
-static void send_bits(int value, int length)
+static void send_bits(unsigned value, unsigned length)
 {
+	unsigned new_buf;
+
 #ifdef DEBUG
 	Tracev((stderr, " l %2d v %4x ", length, value));
 	Assert(length > 0 && length <= 15, "invalid length");
-	G1.bits_sent += length;
+	DEBUG_bits_sent(+= length);
 #endif
-	/* If not enough room in bi_buf, use (valid) bits from bi_buf and
-	 * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-	 * unused bits in value.
-	 */
-	if (G1.bi_valid > (int) BUF_SIZE - length) {
-		G1.bi_buf |= (value << G1.bi_valid);
-		put_16bit(G1.bi_buf);
-		G1.bi_buf = (ush) value >> (BUF_SIZE - G1.bi_valid);
-		G1.bi_valid += length - BUF_SIZE;
-	} else {
-		G1.bi_buf |= value << G1.bi_valid;
-		G1.bi_valid += length;
+	BUILD_BUG_ON(BUF_SIZE != 32 && BUF_SIZE != 16);
+
+	new_buf = G1.bi_buf | (value << G1.bi_valid);
+	/* NB: the above may sometimes do "<< 32" shift (undefined)
+	 * if check below is changed to "length > BUF_SIZE" instead of >= */
+	length += G1.bi_valid;
+
+	/* If bi_buf is full */
+	if (length >= BUF_SIZE) {
+		/* ...use (valid) bits from bi_buf and
+		 * (BUF_SIZE - bi_valid) bits from value,
+		 *  leaving (width - (BUF_SIZE-bi_valid)) unused bits in value.
+		 */
+		value >>= (BUF_SIZE - G1.bi_valid);
+		if (BUF_SIZE == 32) {
+			put_32bit(new_buf);
+		} else { /* 16 */
+			put_16bit(new_buf);
+		}
+		new_buf = value;
+		length -= BUF_SIZE;
 	}
+	G1.bi_buf = new_buf;
+	G1.bi_valid = length;
 }
 
-
 /* ===========================================================================
  * Reverse the first len bits of a code, using straightforward code (a faster
  * method would use a table)
@@ -579,25 +585,24 @@ static unsigned bi_reverse(unsigned code
 	}
 }
 
-
 /* ===========================================================================
  * Write out any remaining bits in an incomplete byte.
  */
 static void bi_windup(void)
 {
-	if (G1.bi_valid > 8) {
-		put_16bit(G1.bi_buf);
-	} else if (G1.bi_valid > 0) {
-		put_8bit(G1.bi_buf);
+	unsigned bits = G1.bi_buf;
+	int cnt = G1.bi_valid;
+
+	while (cnt > 0) {
+		put_8bit(bits);
+		bits >>= 8;
+		cnt -= 8;
 	}
 	G1.bi_buf = 0;
 	G1.bi_valid = 0;
-#ifdef DEBUG
-	G1.bits_sent = (G1.bits_sent + 7) & ~7;
-#endif
+	DEBUG_bits_sent(= (G1.bits_sent + 7) & ~7);
 }
 
-
 /* ===========================================================================
  * Copy a stored block to the zip file, storing first the length and its
  * one's complement if requested.
@@ -607,21 +612,19 @@ static void copy_block(char *buf, unsign
 	bi_windup();		/* align on byte boundary */
 
 	if (header) {
-		put_16bit(len);
-		put_16bit(~len);
-#ifdef DEBUG
-		G1.bits_sent += 2 * 16;
-#endif
+		unsigned v = ((uint16_t)len) | ((~len) << 16);
+		put_32bit(v);
+		DEBUG_bits_sent(+= 2 * 16);
 	}
-#ifdef DEBUG
-	G1.bits_sent += (ulg) len << 3;
-#endif
+	DEBUG_bits_sent(+= (ulg) len << 3);
 	while (len--) {
 		put_8bit(*buf++);
 	}
+	/* The above can 32-bit misalign outbuf */
+	if (G1.outcnt & 3) /* syscalls are expensive, is it really misaligned? */
+		flush_outbuf_if_32bit_optimized();
 }
 
-
 /* ===========================================================================
  * Fill the window when the lookahead becomes insufficient.
  * Updates strstart and lookahead, and sets eofile if end of input file.
@@ -679,7 +682,12 @@ static void fill_window(void)
 		}
 	}
 }
-
+/* Both users fill window with the same loop: */
+static void fill_window_if_needed(void)
+{
+	while (G1.lookahead < MIN_LOOKAHEAD && !G1.eofile)
+		fill_window();
+}
 
 /* ===========================================================================
  * Set match_start to the longest match starting at the given string and
@@ -770,7 +778,6 @@ static int longest_match(IPos cur_match)
 	return best_len;
 }
 
-
 #ifdef DEBUG
 /* ===========================================================================
  * Check that the match at match_start is indeed a match.
@@ -1049,24 +1056,14 @@ struct globals2 {
 	ulg opt_len;             /* bit length of current block with optimal trees */
 	ulg static_len;          /* bit length of current block with static trees */
 
-	ulg compressed_len;      /* total bit length of compressed file */
+//	ulg compressed_len;      /* total bit length of compressed file */
 };
 
 #define G2ptr ((struct globals2*)(ptr_to_globals))
 #define G2 (*G2ptr)
 
-
 /* ===========================================================================
  */
-static void gen_codes(ct_data * tree, int max_code);
-static void build_tree(tree_desc * desc);
-static void scan_tree(ct_data * tree, int max_code);
-static void send_tree(ct_data * tree, int max_code);
-static int build_bl_tree(void);
-static void send_all_trees(int lcodes, int dcodes, int blcodes);
-static void compress_block(ct_data * ltree, ct_data * dtree);
-
-
 #ifndef DEBUG
 /* Send a code of the given tree. c and tree must not have side effects */
 #  define SEND_CODE(c, tree) send_bits(tree[c].Code, tree[c].Len)
@@ -1086,7 +1083,6 @@ static void compress_block(ct_data * ltr
  * The arguments must not have side effects.
  */
 
-
 /* ===========================================================================
  * Initialize a new block.
  */
@@ -1109,7 +1105,6 @@ static void init_block(void)
 	G2.flag_bit = 1;
 }
 
-
 /* ===========================================================================
  * Restore the heap property by moving down the tree starting at node k,
  * exchanging a node with the smallest of its two sons if necessary, stopping
@@ -1147,7 +1142,6 @@ static void pqdownheap(ct_data * tree, i
 	G2.heap[k] = v;
 }
 
-
 /* ===========================================================================
  * Compute the optimal bit lengths for a tree and update the total bit length
  * for the current block.
@@ -1245,7 +1239,6 @@ static void gen_bitlen(tree_desc * desc)
 	}
 }
 
-
 /* ===========================================================================
  * Generate the codes for a given tree and bit counts (which need not be
  * optimal).
@@ -1289,7 +1282,6 @@ static void gen_codes(ct_data * tree, in
 	}
 }
 
-
 /* ===========================================================================
  * Construct one Huffman tree and assigns the code bit strings and lengths.
  * Update the total bit length for the current block.
@@ -1396,7 +1388,6 @@ static void build_tree(tree_desc * desc)
 	gen_codes((ct_data *) tree, max_code);
 }
 
-
 /* ===========================================================================
  * Scan a literal or distance tree to determine the frequencies of the codes
  * in the bit length tree. Updates opt_len to take into account the repeat
@@ -1451,7 +1442,6 @@ static void scan_tree(ct_data * tree, in
 	}
 }
 
-
 /* ===========================================================================
  * Send a literal or distance tree in compressed form, using the codes in
  * bl_tree.
@@ -1509,7 +1499,6 @@ static void send_tree(ct_data * tree, in
 	}
 }
 
-
 /* ===========================================================================
  * Construct the Huffman tree for the bit lengths and return the index in
  * bl_order of the last bit length code to send.
@@ -1538,12 +1527,11 @@ static int build_bl_tree(void)
 	}
 	/* Update opt_len to include the bit length tree and counts */
 	G2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
-	Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld", G2.opt_len, G2.static_len));
+	Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld", (long)G2.opt_len, (long)G2.static_len));
 
 	return max_blindex;
 }
 
-
 /* ===========================================================================
  * Send the header for a block using dynamic Huffman trees: the counts, the
  * lengths of the bit length codes, the literal tree and the distance tree.
@@ -1564,16 +1552,15 @@ static void send_all_trees(int lcodes, i
 		Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
 		send_bits(G2.bl_tree[bl_order[rank]].Len, 3);
 	}
-	Tracev((stderr, "\nbl tree: sent %ld", G1.bits_sent));
+	Tracev((stderr, "\nbl tree: sent %ld", (long)G1.bits_sent));
 
 	send_tree((ct_data *) G2.dyn_ltree, lcodes - 1);	/* send the literal tree */
-	Tracev((stderr, "\nlit tree: sent %ld", G1.bits_sent));
+	Tracev((stderr, "\nlit tree: sent %ld", (long)G1.bits_sent));
 
 	send_tree((ct_data *) G2.dyn_dtree, dcodes - 1);	/* send the distance tree */
-	Tracev((stderr, "\ndist tree: sent %ld", G1.bits_sent));
+	Tracev((stderr, "\ndist tree: sent %ld", (long)G1.bits_sent));
 }
 
-
 /* ===========================================================================
  * Save the match info and tally the frequency counts. Return true if
  * the current block must be flushed.
@@ -1619,7 +1606,8 @@ static int ct_tally(int dist, int lc)
 		out_length >>= 3;
 		Trace((stderr,
 				"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
-				G2.last_lit, G2.last_dist, in_length, out_length,
+				G2.last_lit, G2.last_dist,
+				(long)in_length, (long)out_length,
 				100L - out_length * 100L / in_length));
 		if (G2.last_dist < G2.last_lit / 2 && out_length < in_length / 2)
 			return 1;
@@ -1679,13 +1667,12 @@ static void compress_block(ct_data * ltr
 	SEND_CODE(END_BLOCK, ltree);
 }
 
-
 /* ===========================================================================
  * Determine the best encoding for the current block: dynamic trees, static
  * trees or store, and output the encoded block to the zip file. This function
  * returns the total compressed length for the file so far.
  */
-static ulg flush_block(char *buf, ulg stored_len, int eof)
+static void flush_block(char *buf, ulg stored_len, int eof)
 {
 	ulg opt_lenb, static_lenb;      /* opt_len and static_len in bytes */
 	int max_blindex;                /* index of last bit length code of non zero freq */
@@ -1694,10 +1681,10 @@ static ulg flush_block(char *buf, ulg st
 
 	/* Construct the literal and distance trees */
 	build_tree(&G2.l_desc);
-	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", G2.opt_len, G2.static_len));
+	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", (long)G2.opt_len, (long)G2.static_len));
 
 	build_tree(&G2.d_desc);
-	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", G2.opt_len, G2.static_len));
+	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", (long)G2.opt_len, (long)G2.static_len));
 	/* At this point, opt_len and static_len are the total bit lengths of
 	 * the compressed block data, excluding the tree representations.
 	 */
@@ -1713,7 +1700,9 @@ static ulg flush_block(char *buf, ulg st
 
 	Trace((stderr,
 			"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
-			opt_lenb, G2.opt_len, static_lenb, G2.static_len, stored_len,
+			(unsigned long)opt_lenb, (unsigned long)G2.opt_len,
+			(unsigned long)static_lenb, (unsigned long)G2.static_len,
+			(unsigned long)stored_len,
 			G2.last_lit, G2.last_dist));
 
 	if (static_lenb <= opt_lenb)
@@ -1723,14 +1712,17 @@ static ulg flush_block(char *buf, ulg st
 	 * and if the zip file can be seeked (to rewrite the local header),
 	 * the whole file is transformed into a stored file:
 	 */
-	if (stored_len <= opt_lenb && eof && G2.compressed_len == 0L && seekable()) {
-		/* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
-		if (buf == NULL)
-			bb_error_msg("block vanished");
-
-		copy_block(buf, (unsigned) stored_len, 0);	/* without header */
-		G2.compressed_len = stored_len << 3;
-	} else if (stored_len + 4 <= opt_lenb && buf != NULL) {
+// seekable() is constant FALSE in busybox, and G2.compressed_len is disabled
+// (this was the only user)
+//	if (stored_len <= opt_lenb && eof && G2.compressed_len == 0L && seekable()) {
+//		/* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
+//		if (buf == NULL)
+//			bb_error_msg("block vanished");
+//
+//		G2.compressed_len = stored_len << 3;
+//		copy_block(buf, (unsigned) stored_len, 0);	/* without header */
+//	} else
+	if (stored_len + 4 <= opt_lenb && buf != NULL) {
 		/* 4: two words for the lengths */
 		/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
 		 * Otherwise we can't have processed more than WSIZE input bytes since
@@ -1739,35 +1731,35 @@ static ulg flush_block(char *buf, ulg st
 		 * transform a block into a stored block.
 		 */
 		send_bits((STORED_BLOCK << 1) + eof, 3);	/* send block type */
-		G2.compressed_len = (G2.compressed_len + 3 + 7) & ~7L;
-		G2.compressed_len += (stored_len + 4) << 3;
-
+//		G2.compressed_len = ((G2.compressed_len + 3 + 7) & ~7L)
+//				+ ((stored_len + 4) << 3);
 		copy_block(buf, (unsigned) stored_len, 1);	/* with header */
-	} else if (static_lenb == opt_lenb) {
+	} else
+	if (static_lenb == opt_lenb) {
 		send_bits((STATIC_TREES << 1) + eof, 3);
 		compress_block((ct_data *) G2.static_ltree, (ct_data *) G2.static_dtree);
-		G2.compressed_len += 3 + G2.static_len;
+//		G2.compressed_len += 3 + G2.static_len;
 	} else {
 		send_bits((DYN_TREES << 1) + eof, 3);
 		send_all_trees(G2.l_desc.max_code + 1, G2.d_desc.max_code + 1,
 					max_blindex + 1);
 		compress_block((ct_data *) G2.dyn_ltree, (ct_data *) G2.dyn_dtree);
-		G2.compressed_len += 3 + G2.opt_len;
+//		G2.compressed_len += 3 + G2.opt_len;
 	}
-	Assert(G2.compressed_len == G1.bits_sent, "bad compressed size");
+//	Assert(G2.compressed_len == G1.bits_sent, "bad compressed size");
 	init_block();
 
 	if (eof) {
 		bi_windup();
-		G2.compressed_len += 7;	/* align on byte boundary */
+//		G2.compressed_len += 7;	/* align on byte boundary */
 	}
-	Tracev((stderr, "\ncomprlen %lu(%lu) ", G2.compressed_len >> 3,
-			G2.compressed_len - 7 * eof));
+//	Tracev((stderr, "\ncomprlen %lu(%lu) ",
+//			(unsigned long)G2.compressed_len >> 3,
+//			(unsigned long)G2.compressed_len - 7 * eof));
 
-	return G2.compressed_len >> 3;
+	return; /* was "return G2.compressed_len >> 3;" */
 }
 
-
 /* ===========================================================================
  * Update a hash value with the given input byte
  * IN  assertion: all calls to UPDATE_HASH are made with consecutive
@@ -1776,7 +1768,6 @@ static ulg flush_block(char *buf, ulg st
  */
 #define UPDATE_HASH(h, c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
 
-
 /* ===========================================================================
  * Same as above, but achieves better compression. We use a lazy
  * evaluation for matches: a match is finally adopted only if there is
@@ -1811,7 +1802,7 @@ do { \
 	head[G1.ins_h] = (s); \
 } while (0)
 
-static ulg deflate(void)
+static NOINLINE void deflate(void)
 {
 	IPos hash_head;		/* head of hash chain */
 	IPos prev_match;	/* previous match */
@@ -1900,40 +1891,35 @@ static ulg deflate(void)
 			G1.strstart++;
 			G1.lookahead--;
 		}
-		Assert(G1.strstart <= G1.isize && lookahead <= G1.isize, "a bit too far");
+		Assert(G1.strstart <= G1.isize && G1.lookahead <= G1.isize, "a bit too far");
 
 		/* Make sure that we always have enough lookahead, except
 		 * at the end of the input file. We need MAX_MATCH bytes
 		 * for the next match, plus MIN_MATCH bytes to insert the
 		 * string following the next match.
 		 */
-		while (G1.lookahead < MIN_LOOKAHEAD && !G1.eofile)
-			fill_window();
+		fill_window_if_needed();
 	}
 	if (match_available)
 		ct_tally(0, G1.window[G1.strstart - 1]);
 
-	return FLUSH_BLOCK(1);	/* eof */
+	FLUSH_BLOCK(1);	/* eof */
 }
 
-
 /* ===========================================================================
  * Initialize the bit string routines.
  */
 static void bi_init(void)
 {
-	G1.bi_buf = 0;
-	G1.bi_valid = 0;
-#ifdef DEBUG
-	G1.bits_sent = 0L;
-#endif
+	//G1.bi_buf = 0; // globals are zeroed in pack_gzip()
+	//G1.bi_valid = 0; // globals are zeroed in pack_gzip()
+	//DEBUG_bits_sent(= 0L); // globals are zeroed in pack_gzip()
 }
 
-
 /* ===========================================================================
  * Initialize the "longest match" routines for a new file
  */
-static void lm_init(ush * flagsp)
+static void lm_init(unsigned *flags16p)
 {
 	unsigned j;
 
@@ -1942,11 +1928,11 @@ static void lm_init(ush * flagsp)
 	/* prev will be initialized on the fly */
 
 	/* speed options for the general purpose bit flag */
-	*flagsp |= 2;	/* FAST 4, SLOW 2 */
+	*flags16p |= 2;	/* FAST 4, SLOW 2 */
 	/* ??? reduce max_chain_length for binary files */
 
-	G1.strstart = 0;
-	G1.block_start = 0L;
+	//G1.strstart = 0; // globals are zeroed in pack_gzip()
+	//G1.block_start = 0L; // globals are zeroed in pack_gzip()
 
 	G1.lookahead = file_read(G1.window,
 			sizeof(int) <= 2 ? (unsigned) WSIZE : 2 * WSIZE);
@@ -1956,14 +1942,14 @@ static void lm_init(ush * flagsp)
 		G1.lookahead = 0;
 		return;
 	}
-	G1.eofile = 0;
+	//G1.eofile = 0; // globals are zeroed in pack_gzip()
+
 	/* Make sure that we always have enough lookahead. This is important
 	 * if input comes from a device such as a tty.
 	 */
-	while (G1.lookahead < MIN_LOOKAHEAD && !G1.eofile)
-		fill_window();
+	fill_window_if_needed();
 
-	G1.ins_h = 0;
+	//G1.ins_h = 0; // globals are zeroed in pack_gzip()
 	for (j = 0; j < MIN_MATCH - 1; j++)
 		UPDATE_HASH(G1.ins_h, G1.window[j]);
 	/* If lookahead < MIN_MATCH, ins_h is garbage, but this is
@@ -1971,7 +1957,6 @@ static void lm_init(ush * flagsp)
 	 */
 }
 
-
 /* ===========================================================================
  * Allocate the match buffer, initialize the various tables and save the
  * location of the internal file attribute (ascii/binary) and method
@@ -1985,7 +1970,7 @@ static void ct_init(void)
 	int code;			/* code value */
 	int dist;			/* distance index */
 
-	G2.compressed_len = 0L;
+//	//G2.compressed_len = 0L; // globals are zeroed in pack_gzip()
 
 #ifdef NOT_NEEDED
 	if (G2.static_dtree[0].Len != 0)
@@ -2026,27 +2011,33 @@ static void ct_init(void)
 	Assert(dist == 256, "ct_init: 256+dist != 512");
 
 	/* Construct the codes of the static literal tree */
-	/* already zeroed - it's in bss
-	for (n = 0; n <= MAX_BITS; n++)
-		G2.bl_count[n] = 0; */
+	//for (n = 0; n <= MAX_BITS; n++) // globals are zeroed in pack_gzip()
+	//	G2.bl_count[n] = 0;
 
 	n = 0;
 	while (n <= 143) {
 		G2.static_ltree[n++].Len = 8;
-		G2.bl_count[8]++;
+		//G2.bl_count[8]++;
 	}
+	//G2.bl_count[8] = 143 + 1;
 	while (n <= 255) {
 		G2.static_ltree[n++].Len = 9;
-		G2.bl_count[9]++;
+		//G2.bl_count[9]++;
 	}
+	//G2.bl_count[9] = 255 - 143;
 	while (n <= 279) {
 		G2.static_ltree[n++].Len = 7;
-		G2.bl_count[7]++;
+		//G2.bl_count[7]++;
 	}
+	//G2.bl_count[7] = 279 - 255;
 	while (n <= 287) {
 		G2.static_ltree[n++].Len = 8;
-		G2.bl_count[8]++;
+		//G2.bl_count[8]++;
 	}
+	//G2.bl_count[8] += 287 - 279;
+	G2.bl_count[7] = 279 - 255;
+	G2.bl_count[8] = (143 + 1) + (287 - 279);
+	G2.bl_count[9] = 255 - 143;
 	/* Codes 286 and 287 do not exist, but we must include them in the
 	 * tree construction to get a canonical Huffman tree (longest code
 	 * all ones)
@@ -2063,17 +2054,15 @@ static void ct_init(void)
 	init_block();
 }
 
-
 /* ===========================================================================
  * Deflate in to out.
  * IN assertions: the input and output buffers are cleared.
  */
-
 static void zip(void)
 {
-	ush deflate_flags = 0;  /* pkzip -es, -en or -ex equivalent */
+	unsigned deflate_flags;
 
-	G1.outcnt = 0;
+	//G1.outcnt = 0; // globals are zeroed in pack_gzip()
 
 	/* Write the header to the gzip file. See algorithm.doc for the format */
 	/* magic header for gzip files: 1F 8B */
@@ -2087,10 +2076,13 @@ static void zip(void)
 
 	bi_init();
 	ct_init();
+	deflate_flags = 0;  /* pkzip -es, -en or -ex equivalent */
 	lm_init(&deflate_flags);
 
-	put_8bit(deflate_flags);	/* extra flags */
-	put_8bit(3);	/* OS identifier = 3 (Unix) */
+	put_16bit(deflate_flags | 0x300); /* extra flags. OS id = 3 (Unix) */
+
+	/* The above 32-bit misaligns outbuf (10 bytes are stored), flush it */
+	flush_outbuf_if_32bit_optimized();
 
 	deflate();
 
@@ -2101,20 +2093,21 @@ static void zip(void)
 	flush_outbuf();
 }
 
-
 /* ======================================================================== */
 static
 IF_DESKTOP(long long) int FAST_FUNC pack_gzip(transformer_state_t *xstate UNUSED_PARAM)
 {
+	/* Reinit G1.xxx except pointers to allocated buffers, and entire G2 */
+	memset(&G1.crc, 0, (sizeof(G1) - offsetof(struct globals, crc)) + sizeof(G2));
+
 	/* Clear input and output buffers */
-	G1.outcnt = 0;
+	//G1.outcnt = 0;
 #ifdef DEBUG
-	G1.insize = 0;
+	//G1.insize = 0;
 #endif
-	G1.isize = 0;
+	//G1.isize = 0;
 
 	/* Reinit G2.xxx */
-	memset(&G2, 0, sizeof(G2));
 	G2.l_desc.dyn_tree     = G2.dyn_ltree;
 	G2.l_desc.static_tree  = G2.static_ltree;
 	G2.l_desc.extra_bits   = extra_lbits;
@@ -2218,16 +2211,16 @@ int gzip_main(int argc UNUSED_PARAM, cha
 
 	/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */
 #if ENABLE_FEATURE_GZIP_LONG_OPTIONS
-	opt = getopt32long(argv, "cfkv" IF_FEATURE_GZIP_DECOMPRESS("dt") "qn123456789", gzip_longopts);
+	opt = getopt32long(argv, BBUNPK_OPTSTR IF_FEATURE_GZIP_DECOMPRESS("dt") "n123456789", gzip_longopts);
 #else
-	opt = getopt32(argv, "cfkv" IF_FEATURE_GZIP_DECOMPRESS("dt") "qn123456789");
+	opt = getopt32(argv, BBUNPK_OPTSTR IF_FEATURE_GZIP_DECOMPRESS("dt") "n123456789");
 #endif
 #if ENABLE_FEATURE_GZIP_DECOMPRESS /* gunzip_main may not be visible... */
-	if (opt & 0x30) // -d and/or -t
+	if (opt & (BBUNPK_OPT_DECOMPRESS|BBUNPK_OPT_TEST)) /* -d and/or -t */
 		return gunzip_main(argc, argv);
 #endif
 #if ENABLE_FEATURE_GZIP_LEVELS
-	opt >>= ENABLE_FEATURE_GZIP_DECOMPRESS ? 8 : 6; /* drop cfkv[dt]qn bits */
+	opt >>= (BBUNPK_OPTSTRLEN IF_FEATURE_GZIP_DECOMPRESS(+ 2) + 1); /* drop cfkvq[dt]n bits */
 	if (opt == 0)
 		opt = 1 << 6; /* default: 6 */
 	opt = ffs(opt >> 4); /* Maps -1..-4 to [0], -5 to [1] ... -9 to [5] */
@@ -2236,7 +2229,7 @@ int gzip_main(int argc UNUSED_PARAM, cha
 	max_lazy_match	 = gzip_level_config[opt].lazy2 * 2;
 	nice_match	 = gzip_level_config[opt].nice2 * 2;
 #endif
-	option_mask32 &= 0xf; /* retain only -cfkv */
+	option_mask32 &= BBUNPK_OPTSTRMASK; /* retain only -cfkvq */
 
 	/* Allocate all global buffers (for DYN_ALLOC option) */
 	ALLOC(uch, G1.l_buf, INBUFSIZ);
@@ -2246,7 +2239,7 @@ int gzip_main(int argc UNUSED_PARAM, cha
 	ALLOC(ush, G1.prev, 1L << BITS);
 
 	/* Initialize the CRC32 table */
-	global_crc32_table = crc32_filltable(NULL, 0);
+	global_crc32_new_table_le();
 
 	argv += optind;
 	return bbunpack(argv, pack_gzip, append_ext, "gz");
diff -urpN busybox-1.28.4/archival/libarchive/bz/blocksort.c busybox-1.29.0/archival/libarchive/bz/blocksort.c
--- busybox-1.28.4/archival/libarchive/bz/blocksort.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/bz/blocksort.c	2018-07-02 15:55:14.000000000 +0200
@@ -113,9 +113,8 @@ void fallbackQSort3(uint32_t* fmap,
 		int32_t   loSt,
 		int32_t   hiSt)
 {
-	int32_t unLo, unHi, ltLo, gtHi, n, m;
-	int32_t sp, lo, hi;
-	uint32_t med, r, r3;
+	int32_t sp;
+	uint32_t r;
 	int32_t stackLo[FALLBACK_QSORT_STACK_SIZE];
 	int32_t stackHi[FALLBACK_QSORT_STACK_SIZE];
 
@@ -125,6 +124,11 @@ void fallbackQSort3(uint32_t* fmap,
 	fpush(loSt, hiSt);
 
 	while (sp > 0) {
+		int32_t unLo, unHi, ltLo, gtHi, n, m;
+		int32_t lo, hi;
+		uint32_t med;
+		uint32_t r3;
+
 		AssertH(sp < FALLBACK_QSORT_STACK_SIZE - 1, 1004);
 
 		fpop(lo, hi);
@@ -161,7 +165,7 @@ void fallbackQSort3(uint32_t* fmap,
 					ltLo++;
 					unLo++;
 					continue;
-				};
+				}
 				if (n > 0) break;
 				unLo++;
 			}
@@ -172,7 +176,7 @@ void fallbackQSort3(uint32_t* fmap,
 					mswap(fmap[unHi], fmap[gtHi]);
 					gtHi--; unHi--;
 					continue;
-				};
+				}
 				if (n < 0) break;
 				unHi--;
 			}
@@ -227,17 +231,19 @@ void fallbackQSort3(uint32_t* fmap,
 #define UNALIGNED_BH(zz)  ((zz) & 0x01f)
 
 static
-void fallbackSort(uint32_t* fmap,
-		uint32_t* eclass,
-		uint32_t* bhtab,
-		int32_t   nblock)
+void fallbackSort(EState* state)
 {
 	int32_t ftab[257];
 	int32_t ftabCopy[256];
 	int32_t H, i, j, k, l, r, cc, cc1;
 	int32_t nNotDone;
 	int32_t nBhtab;
-	uint8_t* eclass8 = (uint8_t*)eclass;
+	/* params */
+	uint32_t *const fmap    = state->arr1;
+	uint32_t *const eclass  = state->arr2;
+#define eclass8 ((uint8_t*)eclass)
+	uint32_t *const bhtab   = state->ftab;
+	const int32_t   nblock  = state->nblock;
 
 	/*
 	 * Initial 1-char radix sort to generate
@@ -326,7 +332,7 @@ void fallbackSort(uint32_t* fmap,
 					if (cc != cc1) {
 						SET_BH(i);
 						cc = cc1;
-					};
+					}
 				}
 			}
 		}
@@ -349,6 +355,7 @@ void fallbackSort(uint32_t* fmap,
 		eclass8[fmap[i]] = (uint8_t)j;
 	}
 	AssertH(j < 256, 1005);
+#undef eclass8
 }
 
 #undef       SET_BH
@@ -367,25 +374,25 @@ void fallbackSort(uint32_t* fmap,
 /*---------------------------------------------*/
 static
 NOINLINE
-int mainGtU(
+int mainGtU(EState* state,
 		uint32_t  i1,
-		uint32_t  i2,
-		uint8_t*  block,
-		uint16_t* quadrant,
-		uint32_t  nblock,
-		int32_t*  budget)
+		uint32_t  i2)
 {
 	int32_t  k;
 	uint8_t  c1, c2;
 	uint16_t s1, s2;
 
+	uint8_t  *const block    = state->block;
+	uint16_t *const quadrant = state->quadrant;
+	const int32_t   nblock   = state->nblock;
+
 /* Loop unrolling here is actually very useful
  * (generated code is much simpler),
  * code size increase is only 270 bytes (i386)
  * but speeds up compression 10% overall
  */
 
-#if CONFIG_BZIP2_FAST >= 1
+#if BZIP2_SPEED >= 1
 
 #define TIMES_8(code) \
 	code; code; code; code; \
@@ -435,7 +442,7 @@ int mainGtU(
 		if (i1 >= nblock) i1 -= nblock;
 		if (i2 >= nblock) i2 -= nblock;
 
-		(*budget)--;
+		state->budget--;
 		k -= 8;
 	} while (k >= 0);
 
@@ -452,42 +459,45 @@ int mainGtU(
  * usually small, typically <= 20.
  */
 static
-const int32_t incs[14] = {
+const uint32_t incs[14] = {
 	1, 4, 13, 40, 121, 364, 1093, 3280,
 	9841, 29524, 88573, 265720,
 	797161, 2391484
 };
 
 static
-void mainSimpleSort(uint32_t* ptr,
-		uint8_t*  block,
-		uint16_t* quadrant,
-		int32_t   nblock,
+void mainSimpleSort(EState* state,
 		int32_t   lo,
 		int32_t   hi,
-		int32_t   d,
-		int32_t*  budget)
+		int32_t   d)
 {
-	int32_t i, j, h, bigN, hp;
-	uint32_t v;
+	uint32_t *const ptr = state->ptr;
 
-	bigN = hi - lo + 1;
-	if (bigN < 2) return;
-
-	hp = 0;
-	while (incs[hp] < bigN) hp++;
-	hp--;
+	/* At which increment to start? */
+	int hp = 0;
+	{
+		int bigN = hi - lo;
+		if (bigN <= 0)
+			return;
+		while (incs[hp] <= bigN)
+			hp++;
+		hp--;
+	}
 
 	for (; hp >= 0; hp--) {
-		h = incs[hp];
+		int32_t i;
+		unsigned h;
 
+		h = incs[hp];
 		i = lo + h;
 		while (1) {
-			/*-- copy 1 --*/
+			unsigned j;
+			unsigned v;
+
 			if (i > hi) break;
 			v = ptr[i];
 			j = i;
-			while (mainGtU(ptr[j-h]+d, v+d, block, quadrant, nblock, budget)) {
+			while (mainGtU(state, ptr[j-h]+d, v+d)) {
 				ptr[j] = ptr[j-h];
 				j = j - h;
 				if (j <= (lo + h - 1)) break;
@@ -496,24 +506,23 @@ void mainSimpleSort(uint32_t* ptr,
 			i++;
 
 /* 1.5% overall speedup, +290 bytes */
-#if CONFIG_BZIP2_FAST >= 3
+#if BZIP2_SPEED >= 3
 			/*-- copy 2 --*/
 			if (i > hi) break;
 			v = ptr[i];
 			j = i;
-			while (mainGtU(ptr[j-h]+d, v+d, block, quadrant, nblock, budget)) {
+			while (mainGtU(state, ptr[j-h]+d, v+d)) {
 				ptr[j] = ptr[j-h];
 				j = j - h;
 				if (j <= (lo + h - 1)) break;
 			}
 			ptr[j] = v;
 			i++;
-
 			/*-- copy 3 --*/
 			if (i > hi) break;
 			v = ptr[i];
 			j = i;
-			while (mainGtU(ptr[j-h]+d, v+d, block, quadrant, nblock, budget)) {
+			while (mainGtU(state, ptr[j-h]+d, v+d)) {
 				ptr[j] = ptr[j-h];
 				j = j - h;
 				if (j <= (lo + h - 1)) break;
@@ -521,7 +530,7 @@ void mainSimpleSort(uint32_t* ptr,
 			ptr[j] = v;
 			i++;
 #endif
-			if (*budget < 0) return;
+			if (state->budget < 0) return;
 		}
 	}
 }
@@ -545,7 +554,7 @@ uint8_t mmed3(uint8_t a, uint8_t b, uint
 		t = a;
 		a = b;
 		b = t;
-	};
+	}
 	/* here b >= a */
 	if (b > c) {
 		b = c;
@@ -586,15 +595,12 @@ uint8_t mmed3(uint8_t a, uint8_t b, uint
 #define MAIN_QSORT_STACK_SIZE   100
 
 static NOINLINE
-void mainQSort3(uint32_t* ptr,
-		uint8_t*  block,
-		uint16_t* quadrant,
-		int32_t   nblock,
+void mainQSort3(EState* state,
 		int32_t   loSt,
-		int32_t   hiSt,
-		int32_t   dSt,
-		int32_t*  budget)
+		int32_t   hiSt
+		/*int32_t dSt*/)
 {
+	enum { dSt = BZ_N_RADIX };
 	int32_t unLo, unHi, ltLo, gtHi, n, m, med;
 	int32_t sp, lo, hi, d;
 
@@ -606,6 +612,9 @@ void mainQSort3(uint32_t* ptr,
 	int32_t nextHi[3];
 	int32_t nextD [3];
 
+	uint32_t *const ptr   = state->ptr;
+	uint8_t  *const block = state->block;
+
 	sp = 0;
 	mpush(loSt, hiSt, dSt);
 
@@ -616,8 +625,8 @@ void mainQSort3(uint32_t* ptr,
 		if (hi - lo < MAIN_QSORT_SMALL_THRESH
 		 || d > MAIN_QSORT_DEPTH_THRESH
 		) {
-			mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget);
-			if (*budget < 0)
+			mainSimpleSort(state, lo, hi, d);
+			if (state->budget < 0)
 				return;
 			continue;
 		}
@@ -638,8 +647,8 @@ void mainQSort3(uint32_t* ptr,
 					ltLo++;
 					unLo++;
 					continue;
-				};
-				if (n >  0) break;
+				}
+				if (n > 0) break;
 				unLo++;
 			}
 			while (1) {
@@ -651,8 +660,8 @@ void mainQSort3(uint32_t* ptr,
 					gtHi--;
 					unHi--;
 					continue;
-				};
-				if (n <  0) break;
+				}
+				if (n < 0) break;
 				unHi--;
 			}
 			if (unLo > unHi)
@@ -721,28 +730,24 @@ void mainQSort3(uint32_t* ptr,
 #define CLEARMASK (~(SETMASK))
 
 static NOINLINE
-void mainSort(EState* state,
-		uint32_t* ptr,
-		uint8_t*  block,
-		uint16_t* quadrant,
-		uint32_t* ftab,
-		int32_t   nblock,
-		int32_t*  budget)
+void mainSort(EState* state)
 {
-	int32_t  i, j, k, ss, sb;
-	uint8_t  c1;
-	int32_t  numQSorted;
-	uint16_t s;
+	int32_t  i, j;
 	Bool     bigDone[256];
+	uint8_t  runningOrder[256];
 	/* bbox: moved to EState to save stack
-	int32_t  runningOrder[256];
 	int32_t  copyStart[256];
 	int32_t  copyEnd  [256];
 	*/
-#define runningOrder (state->mainSort__runningOrder)
 #define copyStart    (state->mainSort__copyStart)
 #define copyEnd      (state->mainSort__copyEnd)
 
+	uint32_t *const ptr      = state->ptr;
+	uint8_t  *const block    = state->block;
+	uint32_t *const ftab     = state->ftab;
+	const int32_t   nblock   = state->nblock;
+	uint16_t *const quadrant = state->quadrant;
+
 	/*-- set up the 2-byte frequency table --*/
 	/* was: for (i = 65536; i >= 0; i--) ftab[i] = 0; */
 	memset(ftab, 0, 65537 * sizeof(ftab[0]));
@@ -750,25 +755,25 @@ void mainSort(EState* state,
 	j = block[0] << 8;
 	i = nblock - 1;
 /* 3%, +300 bytes */
-#if CONFIG_BZIP2_FAST >= 2
+#if BZIP2_SPEED >= 2
 	for (; i >= 3; i -= 4) {
 		quadrant[i] = 0;
-		j = (j >> 8) | (((uint16_t)block[i]) << 8);
+		j = (j >> 8) | (((unsigned)block[i]) << 8);
 		ftab[j]++;
 		quadrant[i-1] = 0;
-		j = (j >> 8) | (((uint16_t)block[i-1]) << 8);
+		j = (j >> 8) | (((unsigned)block[i-1]) << 8);
 		ftab[j]++;
 		quadrant[i-2] = 0;
-		j = (j >> 8) | (((uint16_t)block[i-2]) << 8);
+		j = (j >> 8) | (((unsigned)block[i-2]) << 8);
 		ftab[j]++;
 		quadrant[i-3] = 0;
-		j = (j >> 8) | (((uint16_t)block[i-3]) << 8);
+		j = (j >> 8) | (((unsigned)block[i-3]) << 8);
 		ftab[j]++;
 	}
 #endif
 	for (; i >= 0; i--) {
 		quadrant[i] = 0;
-		j = (j >> 8) | (((uint16_t)block[i]) << 8);
+		j = (j >> 8) | (((unsigned)block[i]) << 8);
 		ftab[j]++;
 	}
 
@@ -785,33 +790,36 @@ void mainSort(EState* state,
 		ftab[i] = j;
 	}
 
-	s = block[0] << 8;
-	i = nblock - 1;
-#if CONFIG_BZIP2_FAST >= 2
-	for (; i >= 3; i -= 4) {
-		s = (s >> 8) | (block[i] << 8);
-		j = ftab[s] - 1;
-		ftab[s] = j;
-		ptr[j] = i;
-		s = (s >> 8) | (block[i-1] << 8);
-		j = ftab[s] - 1;
-		ftab[s] = j;
-		ptr[j] = i-1;
-		s = (s >> 8) | (block[i-2] << 8);
-		j = ftab[s] - 1;
-		ftab[s] = j;
-		ptr[j] = i-2;
-		s = (s >> 8) | (block[i-3] << 8);
-		j = ftab[s] - 1;
-		ftab[s] = j;
-		ptr[j] = i-3;
-	}
+	{
+		unsigned s;
+		s = block[0] << 8;
+		i = nblock - 1;
+#if BZIP2_SPEED >= 2
+		for (; i >= 3; i -= 4) {
+			s = (s >> 8) | (block[i] << 8);
+			j = ftab[s] - 1;
+			ftab[s] = j;
+			ptr[j] = i;
+			s = (s >> 8) | (block[i-1] << 8);
+			j = ftab[s] - 1;
+			ftab[s] = j;
+			ptr[j] = i-1;
+			s = (s >> 8) | (block[i-2] << 8);
+			j = ftab[s] - 1;
+			ftab[s] = j;
+			ptr[j] = i-2;
+			s = (s >> 8) | (block[i-3] << 8);
+			j = ftab[s] - 1;
+			ftab[s] = j;
+			ptr[j] = i-3;
+		}
 #endif
-	for (; i >= 0; i--) {
-		s = (s >> 8) | (block[i] << 8);
-		j = ftab[s] - 1;
-		ftab[s] = j;
-		ptr[j] = i;
+		for (; i >= 0; i--) {
+			s = (s >> 8) | (block[i] << 8);
+			j = ftab[s] - 1;
+			ftab[s] = j;
+			ptr[j] = i;
+		}
 	}
 
 	/*
@@ -825,24 +833,23 @@ void mainSort(EState* state,
 	}
 
 	{
-		int32_t vv;
 		/* bbox: was: int32_t h = 1; */
 		/* do h = 3 * h + 1; while (h <= 256); */
-		uint32_t h = 364;
+		unsigned h = 364;
 
 		do {
 			/*h = h / 3;*/
 			h = (h * 171) >> 9; /* bbox: fast h/3 */
 			for (i = h; i <= 255; i++) {
-				vv = runningOrder[i];
+				unsigned vv, jh;
+				vv = runningOrder[i]; /* uint8[] */
 				j = i;
-				while (BIGFREQ(runningOrder[j-h]) > BIGFREQ(vv)) {
-					runningOrder[j] = runningOrder[j-h];
-					j = j - h;
-					if (j <= (h - 1))
-						goto zero;
+				while (jh = j - h, BIGFREQ(runningOrder[jh]) > BIGFREQ(vv)) {
+					runningOrder[j] = runningOrder[jh];
+					j = jh;
+					if (j < h)
+						break;
 				}
- zero:
 				runningOrder[j] = vv;
 			}
 		} while (h != 1);
@@ -852,9 +859,8 @@ void mainSort(EState* state,
 	 * The main sorting loop.
 	 */
 
-	numQSorted = 0;
-
-	for (i = 0; i <= 255; i++) {
+	for (i = 0; /*i <= 255*/; i++) {
+		unsigned ss;
 
 		/*
 		 * Process big buckets, starting with the least full.
@@ -874,17 +880,14 @@ void mainSort(EState* state,
 		 */
 		for (j = 0; j <= 255; j++) {
 			if (j != ss) {
+				unsigned sb;
 				sb = (ss << 8) + j;
 				if (!(ftab[sb] & SETMASK)) {
-					int32_t lo =  ftab[sb]   & CLEARMASK;
+					int32_t lo =  ftab[sb] /*& CLEARMASK (redundant)*/;
 					int32_t hi = (ftab[sb+1] & CLEARMASK) - 1;
 					if (hi > lo) {
-						mainQSort3(
-							ptr, block, quadrant, nblock,
-							lo, hi, BZ_N_RADIX, budget
-						);
-						if (*budget < 0) return;
-						numQSorted += (hi - lo + 1);
+						mainQSort3(state, lo, hi /*,BZ_N_RADIX*/);
+						if (state->budget < 0) return;
 					}
 				}
 				ftab[sb] |= SETMASK;
@@ -906,6 +909,8 @@ void mainSort(EState* state,
 				copyEnd  [j] = (ftab[(j << 8) + ss + 1] & CLEARMASK) - 1;
 			}
 			for (j = ftab[ss << 8] & CLEARMASK; j < copyStart[ss]; j++) {
+				unsigned c1;
+				int32_t k;
 				k = ptr[j] - 1;
 				if (k < 0)
 					k += nblock;
@@ -914,6 +919,8 @@ void mainSort(EState* state,
 					ptr[copyStart[c1]++] = k;
 			}
 			for (j = (ftab[(ss+1) << 8] & CLEARMASK) - 1; j > copyEnd[ss]; j--) {
+				unsigned c1;
+				int32_t k;
 				k = ptr[j]-1;
 				if (k < 0)
 					k += nblock;
@@ -933,6 +940,9 @@ void mainSort(EState* state,
 		for (j = 0; j <= 255; j++)
 			ftab[(j << 8) + ss] |= SETMASK;
 
+		if (i == 255)
+			break;
+
 		/*
 		 * Step 3:
 		 * The [ss] big bucket is now done.  Record this fact,
@@ -974,15 +984,15 @@ void mainSort(EState* state,
 		 */
 		bigDone[ss] = True;
 
-		if (i < 255) {
-			int32_t bbStart = ftab[ss << 8] & CLEARMASK;
-			int32_t bbSize  = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;
-			int32_t shifts  = 0;
+		{
+			unsigned bbStart = ftab[ss << 8] & CLEARMASK;
+			unsigned bbSize  = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;
+			unsigned shifts  = 0;
 
 			while ((bbSize >> shifts) > 65534) shifts++;
 
 			for (j = bbSize-1; j >= 0; j--) {
-				int32_t a2update   = ptr[bbStart + j];
+				unsigned a2update  = ptr[bbStart + j]; /* uint32[] */
 				uint16_t qVal      = (uint16_t)(j >> shifts);
 				quadrant[a2update] = qVal;
 				if (a2update < BZ_N_OVERSHOOT)
@@ -1015,31 +1025,24 @@ void mainSort(EState* state,
  *	arr1[0 .. nblock-1] holds sorted order
  */
 static NOINLINE
-void BZ2_blockSort(EState* s)
+int32_t BZ2_blockSort(EState* state)
 {
 	/* In original bzip2 1.0.4, it's a parameter, but 30
 	 * (which was the default) should work ok. */
 	enum { wfact = 30 };
+	unsigned i;
+	int32_t origPtr = origPtr;
 
-	uint32_t* ptr    = s->ptr;
-	uint8_t*  block  = s->block;
-	uint32_t* ftab   = s->ftab;
-	int32_t   nblock = s->nblock;
-	uint16_t* quadrant;
-	int32_t   budget;
-	int32_t   i;
-
-	if (nblock < 10000) {
-		fallbackSort(s->arr1, s->arr2, ftab, nblock);
-	} else {
+	if (state->nblock >= 10000) {
 		/* Calculate the location for quadrant, remembering to get
 		 * the alignment right.  Assumes that &(block[0]) is at least
 		 * 2-byte aligned -- this should be ok since block is really
 		 * the first section of arr2.
 		 */
-		i = nblock + BZ_N_OVERSHOOT;
-		if (i & 1) i++;
-		quadrant = (uint16_t*)(&(block[i]));
+		i = state->nblock + BZ_N_OVERSHOOT;
+		if (i & 1)
+			i++;
+		state->quadrant = (uint16_t*) &(state->block[i]);
 
 		/* (wfact-1) / 3 puts the default-factor-30
 		 * transition point at very roughly the same place as
@@ -1048,22 +1051,26 @@ void BZ2_blockSort(EState* s)
 		 * resulting compressed stream is now the same regardless
 		 * of whether or not we use the main sort or fallback sort.
 		 */
-		budget = nblock * ((wfact-1) / 3);
-
-		mainSort(s, ptr, block, quadrant, ftab, nblock, &budget);
-		if (budget < 0) {
-			fallbackSort(s->arr1, s->arr2, ftab, nblock);
-		}
+		state->budget = state->nblock * ((wfact-1) / 3);
+		mainSort(state);
+		if (state->budget >= 0)
+			goto good;
 	}
+	fallbackSort(state);
+ good:
 
-	s->origPtr = -1;
-	for (i = 0; i < s->nblock; i++)
-		if (ptr[i] == 0) {
-			s->origPtr = i;
+#if BZ_LIGHT_DEBUG
+	origPtr = -1;
+#endif
+	for (i = 0; i < state->nblock; i++) {
+		if (state->ptr[i] == 0) {
+			origPtr = i;
 			break;
-		};
+		}
+	}
 
-	AssertH(s->origPtr != -1, 1003);
+	AssertH(origPtr != -1, 1003);
+	return origPtr;
 }
 
 
diff -urpN busybox-1.28.4/archival/libarchive/bz/bzlib.c busybox-1.29.0/archival/libarchive/bz/bzlib.c
--- busybox-1.28.4/archival/libarchive/bz/bzlib.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/bz/bzlib.c	2018-07-02 15:55:14.000000000 +0200
@@ -55,8 +55,9 @@ void prepare_new_block(EState* s)
 {
 	int i;
 	s->nblock = 0;
-	s->numZ = 0;
-	s->state_out_pos = 0;
+	//indexes into s->zbits[], initialzation moved to init of s->zbits
+	//s->posZ = s->zbits; // was: s->numZ = 0;
+	//s->state_out_pos = s->zbits;
 	BZ_INITIALISE_CRC(s->blockCRC);
 	/* inlined memset would be nice to have here */
 	for (i = 0; i < 256; i++)
@@ -86,7 +87,7 @@ int isempty_RL(EState* s)
 static
 void BZ2_bzCompressInit(bz_stream *strm, int blockSize100k)
 {
-	int32_t n;
+	unsigned n;
 	EState* s;
 
 	s = xzalloc(sizeof(EState));
@@ -237,11 +238,10 @@ void /*Bool*/ copy_output_until_stop(ESt
 		if (s->strm->avail_out == 0) break;
 
 		/*-- block done? --*/
-		if (s->state_out_pos >= s->numZ) break;
+		if (s->state_out_pos >= s->posZ) break;
 
 		/*progress_out = True;*/
-		*(s->strm->next_out) = s->zbits[s->state_out_pos];
-		s->state_out_pos++;
+		*(s->strm->next_out) = *s->state_out_pos++;
 		s->strm->avail_out--;
 		s->strm->next_out++;
 		s->strm->total_out++;
@@ -261,7 +261,7 @@ void /*Bool*/ handle_compress(bz_stream
 	while (1) {
 		if (s->state == BZ_S_OUTPUT) {
 			/*progress_out |=*/ copy_output_until_stop(s);
-			if (s->state_out_pos < s->numZ) break;
+			if (s->state_out_pos < s->posZ) break;
 			if (s->mode == BZ_M_FINISHING
 			//# && s->avail_in_expect == 0
 			 && s->strm->avail_in == 0
@@ -336,7 +336,7 @@ int BZ2_bzCompress(bz_stream *strm, int
 			/*if (s->avail_in_expect != s->strm->avail_in)
 				return BZ_SEQUENCE_ERROR;*/
 			/*progress =*/ handle_compress(strm);
-			if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)
+			if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->posZ)
 				return BZ_FLUSH_OK;
 			s->mode = BZ_M_RUNNING;
 			return BZ_RUN_OK;
@@ -349,9 +349,9 @@ int BZ2_bzCompress(bz_stream *strm, int
 				return BZ_SEQUENCE_ERROR;*/
 			/*progress =*/ handle_compress(strm);
 			/*if (!progress) return BZ_SEQUENCE_ERROR;*/
-			//#if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)
+			//#if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->posZ)
 			//#	return BZ_FINISH_OK;
-			if (s->strm->avail_in > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)
+			if (s->strm->avail_in > 0 || !isempty_RL(s) || s->state_out_pos < s->posZ)
 				return BZ_FINISH_OK;
 			/*s->mode = BZ_M_IDLE;*/
 			return BZ_STREAM_END;
diff -urpN busybox-1.28.4/archival/libarchive/bz/bzlib_private.h busybox-1.29.0/archival/libarchive/bz/bzlib_private.h
--- busybox-1.28.4/archival/libarchive/bz/bzlib_private.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/bz/bzlib_private.h	2018-07-02 15:55:14.000000000 +0200
@@ -120,8 +120,11 @@ typedef struct EState {
 
 	/* mode this stream is in, and whether inputting */
 	/* or outputting data */
-	int32_t  mode;
-	int32_t  state;
+	uint8_t mode;
+	uint8_t state;
+
+	/* misc administratium */
+	uint8_t blockSize100k;
 
 	/* remembers avail_in when flush/finish requested */
 /* bbox: not needed, strm->avail_in always has the same value */
@@ -129,20 +132,19 @@ typedef struct EState {
 	/* uint32_t avail_in_expect; */
 
 	/* for doing the block sorting */
-	int32_t  origPtr;
 	uint32_t *arr1;
 	uint32_t *arr2;
 	uint32_t *ftab;
 
+	uint16_t *quadrant;
+	int32_t  budget;
+
 	/* aliases for arr1 and arr2 */
 	uint32_t *ptr;
 	uint8_t  *block;
 	uint16_t *mtfv;
 	uint8_t  *zbits;
 
-	/* guess what */
-	uint32_t *crc32table;
-
 	/* run-length-encoding of the input */
 	uint32_t state_in_ch;
 	int32_t  state_in_len;
@@ -150,20 +152,23 @@ typedef struct EState {
 	/* input and output limits and current posns */
 	int32_t  nblock;
 	int32_t  nblockMAX;
-	int32_t  numZ;
-	int32_t  state_out_pos;
+	//int32_t  numZ; // index into s->zbits[], replaced by pointer:
+	uint8_t  *posZ;
+	uint8_t  *state_out_pos;
 
 	/* the buffer for bit stream creation */
 	uint32_t bsBuff;
 	int32_t  bsLive;
 
+	/* guess what */
+	uint32_t *crc32table;
+
 	/* block and combined CRCs */
 	uint32_t blockCRC;
 	uint32_t combinedCRC;
 
 	/* misc administratium */
 	int32_t  blockNo;
-	int32_t  blockSize100k;
 
 	/* stuff for coding the MTF values */
 	int32_t  nMTF;
@@ -183,7 +188,7 @@ typedef struct EState {
 	/* stack-saving measures: these can be local, but they are too big */
 	int32_t  sendMTFValues__code [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
 	int32_t  sendMTFValues__rfreq[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
-#if CONFIG_BZIP2_FAST >= 5
+#if BZIP2_SPEED >= 5
 	/* second dimension: only 3 needed; 4 makes index calculations faster */
 	uint32_t sendMTFValues__len_pack[BZ_MAX_ALPHA_SIZE][4];
 #endif
@@ -191,7 +196,6 @@ typedef struct EState {
 	int32_t  BZ2_hbMakeCodeLengths__weight[BZ_MAX_ALPHA_SIZE * 2];
 	int32_t  BZ2_hbMakeCodeLengths__parent[BZ_MAX_ALPHA_SIZE * 2];
 
-	int32_t  mainSort__runningOrder[256];
 	int32_t  mainSort__copyStart[256];
 	int32_t  mainSort__copyEnd[256];
 } EState;
@@ -199,7 +203,7 @@ typedef struct EState {
 
 /*-- compression. --*/
 
-static void
+static int32_t
 BZ2_blockSort(EState*);
 
 static void
diff -urpN busybox-1.28.4/archival/libarchive/bz/compress.c busybox-1.29.0/archival/libarchive/bz/compress.c
--- busybox-1.28.4/archival/libarchive/bz/compress.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/bz/compress.c	2018-07-02 15:55:14.000000000 +0200
@@ -32,6 +32,12 @@ in the file LICENSE.
 
 /* #include "bzlib_private.h" */
 
+#if BZIP2_SPEED >= 5
+# define ALWAYS_INLINE_5 ALWAYS_INLINE
+#else
+# define ALWAYS_INLINE_5 /*nothing*/
+#endif
+
 /*---------------------------------------------------*/
 /*--- Bit stream I/O                              ---*/
 /*---------------------------------------------------*/
@@ -50,8 +56,7 @@ static NOINLINE
 void bsFinishWrite(EState* s)
 {
 	while (s->bsLive > 0) {
-		s->zbits[s->numZ] = (uint8_t)(s->bsBuff >> 24);
-		s->numZ++;
+		*s->posZ++ = (uint8_t)(s->bsBuff >> 24);
 		s->bsBuff <<= 8;
 		s->bsLive -= 8;
 	}
@@ -61,39 +66,74 @@ void bsFinishWrite(EState* s)
 /*---------------------------------------------------*/
 static
 /* Helps only on level 5, on other levels hurts. ? */
-#if CONFIG_BZIP2_FAST >= 5
-ALWAYS_INLINE
-#endif
+ALWAYS_INLINE_5
 void bsW(EState* s, int32_t n, uint32_t v)
 {
 	while (s->bsLive >= 8) {
-		s->zbits[s->numZ] = (uint8_t)(s->bsBuff >> 24);
-		s->numZ++;
+		*s->posZ++ = (uint8_t)(s->bsBuff >> 24);
 		s->bsBuff <<= 8;
 		s->bsLive -= 8;
 	}
 	s->bsBuff |= (v << (32 - s->bsLive - n));
 	s->bsLive += n;
 }
+/* Same with n == 16: */
+static
+ALWAYS_INLINE_5
+void bsW16(EState* s, uint32_t v)
+{
+	while (s->bsLive >= 8) {
+		*s->posZ++ = (uint8_t)(s->bsBuff >> 24);
+		s->bsBuff <<= 8;
+		s->bsLive -= 8;
+	}
+	s->bsBuff |= (v << (16 - s->bsLive));
+	s->bsLive += 16;
+}
+/* Same with n == 1: */
+static
+ALWAYS_INLINE /* one callsite */
+void bsW1_1(EState* s)
+{
+	/* need space for only 1 bit, no need for loop freeing > 8 bits */
+	if (s->bsLive >= 8) {
+		*s->posZ++ = (uint8_t)(s->bsBuff >> 24);
+		s->bsBuff <<= 8;
+		s->bsLive -= 8;
+	}
+	s->bsBuff |= (1 << (31 - s->bsLive));
+	s->bsLive += 1;
+}
+static
+ALWAYS_INLINE_5
+void bsW1_0(EState* s)
+{
+	/* need space for only 1 bit, no need for loop freeing > 8 bits */
+	if (s->bsLive >= 8) {
+		*s->posZ++ = (uint8_t)(s->bsBuff >> 24);
+		s->bsBuff <<= 8;
+		s->bsLive -= 8;
+	}
+	//s->bsBuff |= (0 << (31 - s->bsLive));
+	s->bsLive += 1;
+}
 
 
 /*---------------------------------------------------*/
-static
-void bsPutU32(EState* s, unsigned u)
+static ALWAYS_INLINE
+void bsPutU16(EState* s, unsigned u)
 {
-	bsW(s, 8, (u >> 24) & 0xff);
-	bsW(s, 8, (u >> 16) & 0xff);
-	bsW(s, 8, (u >>  8) & 0xff);
-	bsW(s, 8,  u        & 0xff);
+	bsW16(s, u);
 }
 
 
 /*---------------------------------------------------*/
 static
-void bsPutU16(EState* s, unsigned u)
+void bsPutU32(EState* s, unsigned u)
 {
-	bsW(s, 8, (u >>  8) & 0xff);
-	bsW(s, 8,  u        & 0xff);
+	//bsW(s, 32, u); // can't use: may try "uint32 << -n"
+	bsW16(s, (u >> 16) & 0xffff);
+	bsW16(s, u         & 0xffff);
 }
 
 
@@ -106,25 +146,57 @@ static
 void makeMaps_e(EState* s)
 {
 	int i;
-	s->nInUse = 0;
+	unsigned cnt = 0;
 	for (i = 0; i < 256; i++) {
 		if (s->inUse[i]) {
-			s->unseqToSeq[i] = s->nInUse;
-			s->nInUse++;
+			s->unseqToSeq[i] = cnt;
+			cnt++;
 		}
 	}
+	s->nInUse = cnt;
 }
 
 
 /*---------------------------------------------------*/
+/*
+ * This bit of code is performance-critical.
+ * On 32bit x86, gcc-6.3.0 was observed to spill ryy_j to stack,
+ * resulting in abysmal performance (x3 slowdown).
+ * Forcing it into a separate function alleviates register pressure,
+ * and spillage no longer happens.
+ * Other versions of gcc do not exhibit this problem, but out-of-line code
+ * seems to be helping them too (code is both smaller and faster).
+ * Therefore NOINLINE is enabled for the entire 32bit x86 arch for now,
+ * without a check for gcc version.
+ */
+static
+#if defined __i386__
+NOINLINE
+#endif
+int inner_loop(uint8_t *yy, uint8_t ll_i)
+{
+	register uint8_t  rtmp;
+	register uint8_t* ryy_j;
+	rtmp  = yy[1];
+	yy[1] = yy[0];
+	ryy_j = &(yy[1]);
+	while (ll_i != rtmp) {
+		register uint8_t rtmp2;
+		ryy_j++;
+		rtmp2  = rtmp;
+		rtmp   = *ryy_j;
+		*ryy_j = rtmp2;
+	}
+	yy[0] = rtmp;
+	return ryy_j - &(yy[0]);
+}
 static NOINLINE
 void generateMTFValues(EState* s)
 {
 	uint8_t yy[256];
-	int32_t i, j;
-	int32_t zPend;
+	int i;
+	int zPend;
 	int32_t wr;
-	int32_t EOB;
 
 	/*
 	 * After sorting (eg, here),
@@ -148,95 +220,74 @@ void generateMTFValues(EState* s)
 	 * compressBlock().
 	 */
 	uint32_t* ptr   = s->ptr;
-	uint8_t*  block = s->block;
-	uint16_t* mtfv  = s->mtfv;
 
 	makeMaps_e(s);
-	EOB = s->nInUse+1;
-
-	for (i = 0; i <= EOB; i++)
-		s->mtfFreq[i] = 0;
 
 	wr = 0;
 	zPend = 0;
+	for (i = 0; i <= s->nInUse+1; i++)
+		s->mtfFreq[i] = 0;
+
 	for (i = 0; i < s->nInUse; i++)
 		yy[i] = (uint8_t) i;
 
 	for (i = 0; i < s->nblock; i++) {
-		uint8_t ll_i;
+		uint8_t ll_i = ll_i; /* gcc 4.3.1 thinks it may be used w/o init */
+		int32_t j;
+
 		AssertD(wr <= i, "generateMTFValues(1)");
 		j = ptr[i] - 1;
 		if (j < 0)
 			j += s->nblock;
-		ll_i = s->unseqToSeq[block[j]];
+		ll_i = s->unseqToSeq[s->block[j]];
 		AssertD(ll_i < s->nInUse, "generateMTFValues(2a)");
 
 		if (yy[0] == ll_i) {
 			zPend++;
-		} else {
-			if (zPend > 0) {
-				zPend--;
-				while (1) {
-					if (zPend & 1) {
-						mtfv[wr] = BZ_RUNB; wr++;
-						s->mtfFreq[BZ_RUNB]++;
-					} else {
-						mtfv[wr] = BZ_RUNA; wr++;
-						s->mtfFreq[BZ_RUNA]++;
-					}
-					if (zPend < 2) break;
-					zPend = (uint32_t)(zPend - 2) / 2;
-					/* bbox: unsigned div is easier */
-				};
-				zPend = 0;
-			}
-			{
-				register uint8_t  rtmp;
-				register uint8_t* ryy_j;
-				register uint8_t  rll_i;
-				rtmp  = yy[1];
-				yy[1] = yy[0];
-				ryy_j = &(yy[1]);
-				rll_i = ll_i;
-				while (rll_i != rtmp) {
-					register uint8_t rtmp2;
-					ryy_j++;
-					rtmp2  = rtmp;
-					rtmp   = *ryy_j;
-					*ryy_j = rtmp2;
-				};
-				yy[0] = rtmp;
-				j = ryy_j - &(yy[0]);
-				mtfv[wr] = j+1;
-				wr++;
-				s->mtfFreq[j+1]++;
-			}
+			continue;
 		}
-	}
 
-	if (zPend > 0) {
-		zPend--;
-		while (1) {
-			if (zPend & 1) {
-				mtfv[wr] = BZ_RUNB;
-				wr++;
-				s->mtfFreq[BZ_RUNB]++;
-			} else {
-				mtfv[wr] = BZ_RUNA;
+		if (zPend > 0) {
+ process_zPend:
+			zPend--;
+			while (1) {
+#if 0
+				if (zPend & 1) {
+					s->mtfv[wr] = BZ_RUNB; wr++;
+					s->mtfFreq[BZ_RUNB]++;
+				} else {
+					s->mtfv[wr] = BZ_RUNA; wr++;
+					s->mtfFreq[BZ_RUNA]++;
+				}
+#else /* same as above, since BZ_RUNA is 0 and BZ_RUNB is 1 */
+				unsigned run = zPend & 1;
+				s->mtfv[wr] = run;
 				wr++;
-				s->mtfFreq[BZ_RUNA]++;
-			}
-			if (zPend < 2)
-				break;
-			zPend = (uint32_t)(zPend - 2) / 2;
-			/* bbox: unsigned div is easier */
-		};
-		zPend = 0;
-	}
-
-	mtfv[wr] = EOB;
+				s->mtfFreq[run]++;
+#endif
+				zPend -= 2;
+				if (zPend < 0)
+					break;
+				zPend = (unsigned)zPend / 2;
+				/* bbox: unsigned div is easier */
+			}
+			if (i < 0) /* came via "goto process_zPend"? exit */
+				goto end;
+			zPend = 0;
+		}
+		j = inner_loop(yy, ll_i);
+		s->mtfv[wr] = j+1;
+		wr++;
+		s->mtfFreq[j+1]++;
+	}
+
+	i = -1;
+	if (zPend > 0)
+		goto process_zPend; /* "process it and come back here" */
+ end:
+	s->mtfv[wr] = s->nInUse+1;
 	wr++;
-	s->mtfFreq[EOB]++;
+	s->mtfFreq[s->nInUse+1]++;
 
 	s->nMTF = wr;
 }
@@ -249,8 +300,11 @@ void generateMTFValues(EState* s)
 static NOINLINE
 void sendMTFValues(EState* s)
 {
-	int32_t v, t, i, j, gs, ge, bt, bc, iter;
-	int32_t nSelectors, alphaSize, minLen, maxLen, selCtr;
+	int32_t t, i;
+	unsigned iter;
+	unsigned gs;
+	int32_t alphaSize;
+	unsigned nSelectors, selCtr;
 	int32_t nGroups;
 
 	/*
@@ -266,39 +320,49 @@ void sendMTFValues(EState* s)
 #define rfreq    sendMTFValues__rfreq
 #define len_pack sendMTFValues__len_pack
 
-	uint16_t cost[BZ_N_GROUPS];
-	int32_t  fave[BZ_N_GROUPS];
+	unsigned /*uint16_t*/ cost[BZ_N_GROUPS];
 
 	uint16_t* mtfv = s->mtfv;
 
 	alphaSize = s->nInUse + 2;
-	for (t = 0; t < BZ_N_GROUPS; t++)
+	for (t = 0; t < BZ_N_GROUPS; t++) {
+		unsigned v;
 		for (v = 0; v < alphaSize; v++)
 			s->len[t][v] = BZ_GREATER_ICOST;
+	}
 
 	/*--- Decide how many coding tables to use ---*/
 	AssertH(s->nMTF > 0, 3001);
-	if (s->nMTF < 200)  nGroups = 2; else
-	if (s->nMTF < 600)  nGroups = 3; else
-	if (s->nMTF < 1200) nGroups = 4; else
-	if (s->nMTF < 2400) nGroups = 5; else
-	nGroups = 6;
+	// 1..199 = 2
+	// 200..599 = 3
+	// 600..1199 = 4
+	// 1200..2399 = 5
+	// 2400..99999 = 6
+	nGroups = 2;
+	nGroups += (s->nMTF >= 200);
+	nGroups += (s->nMTF >= 600);
+	nGroups += (s->nMTF >= 1200);
+	nGroups += (s->nMTF >= 2400);
 
 	/*--- Generate an initial set of coding tables ---*/
 	{
-		int32_t nPart, remF, tFreq, aFreq;
+		unsigned nPart, remF;
 
 		nPart = nGroups;
 		remF  = s->nMTF;
 		gs = 0;
 		while (nPart > 0) {
+			unsigned v;
+			unsigned ge;
+			unsigned tFreq, aFreq;
+
 			tFreq = remF / nPart;
-			ge = gs - 1;
+			ge = gs;
 			aFreq = 0;
-			while (aFreq < tFreq && ge < alphaSize-1) {
-				ge++;
-				aFreq += s->mtfFreq[ge];
+			while (aFreq < tFreq && ge < alphaSize) {
+				aFreq += s->mtfFreq[ge++];
 			}
+			ge--;
 
 			if (ge > gs
 			 && nPart != nGroups && nPart != 1
@@ -324,19 +388,19 @@ void sendMTFValues(EState* s)
 	 * Iterate up to BZ_N_ITERS times to improve the tables.
 	 */
 	for (iter = 0; iter < BZ_N_ITERS; iter++) {
-		for (t = 0; t < nGroups; t++)
-			fave[t] = 0;
-
-		for (t = 0; t < nGroups; t++)
+		for (t = 0; t < nGroups; t++) {
+			unsigned v;
 			for (v = 0; v < alphaSize; v++)
 				s->rfreq[t][v] = 0;
+		}
 
-#if CONFIG_BZIP2_FAST >= 5
+#if BZIP2_SPEED >= 5
 		/*
 		 * Set up an auxiliary length table which is used to fast-track
 		 * the common case (nGroups == 6).
 		 */
 		if (nGroups == 6) {
+			unsigned v;
 			for (v = 0; v < alphaSize; v++) {
 				s->len_pack[v][0] = (s->len[1][v] << 16) | s->len[0][v];
 				s->len_pack[v][1] = (s->len[3][v] << 16) | s->len[2][v];
@@ -347,6 +411,9 @@ void sendMTFValues(EState* s)
 		nSelectors = 0;
 		gs = 0;
 		while (1) {
+			unsigned ge;
+			unsigned bt, bc;
+
 			/*--- Set group start & end marks. --*/
 			if (gs >= s->nMTF)
 				break;
@@ -360,7 +427,7 @@ void sendMTFValues(EState* s)
 			 */
 			for (t = 0; t < nGroups; t++)
 				cost[t] = 0;
-#if CONFIG_BZIP2_FAST >= 5
+#if BZIP2_SPEED >= 5
 			if (nGroups == 6 && 50 == ge-gs+1) {
 				/*--- fast track the common case ---*/
 				register uint32_t cost01, cost23, cost45;
@@ -390,7 +457,7 @@ void sendMTFValues(EState* s)
 			{
 				/*--- slow version which correctly handles all situations ---*/
 				for (i = gs; i <= ge; i++) {
-					uint16_t icv = mtfv[i];
+					unsigned /*uint16_t*/ icv = mtfv[i];
 					for (t = 0; t < nGroups; t++)
 						cost[t] += s->len[t][icv];
 				}
@@ -409,7 +476,6 @@ void sendMTFValues(EState* s)
 					bt = t;
 				}
 			}
-			fave[bt]++;
 			s->selector[nSelectors] = bt;
 			nSelectors++;
 
@@ -417,7 +483,7 @@ void sendMTFValues(EState* s)
 			 * Increment the symbol frequencies for the selected table.
 			 */
 /* 1% faster compress. +800 bytes */
-#if CONFIG_BZIP2_FAST >= 4
+#if BZIP2_SPEED >= 4
 			if (nGroups == 6 && 50 == ge-gs+1) {
 				/*--- fast track the common case ---*/
 #define BZ_ITUR(nn) s->rfreq[bt][mtfv[gs + (nn)]]++
@@ -464,6 +530,7 @@ void sendMTFValues(EState* s)
 		for (i = 0; i < nGroups; i++)
 			pos[i] = i;
 		for (i = 0; i < nSelectors; i++) {
+			unsigned j;
 			ll_i = s->selector[i];
 			j = 0;
 			tmp = pos[j];
@@ -472,16 +539,16 @@ void sendMTFValues(EState* s)
 				tmp2 = tmp;
 				tmp = pos[j];
 				pos[j] = tmp2;
-			};
+			}
 			pos[0] = tmp;
 			s->selectorMtf[i] = j;
 		}
-	};
+	}
 
 	/*--- Assign actual codes for the tables. --*/
 	for (t = 0; t < nGroups; t++) {
-		minLen = 32;
-		maxLen = 0;
+		unsigned minLen = 32; //todo: s->len[t][0];
+		unsigned maxLen = 0;  //todo: s->len[t][0];
 		for (i = 0; i < alphaSize; i++) {
 			if (s->len[t][i] > maxLen) maxLen = s->len[t][i];
 			if (s->len[t][i] < minLen) minLen = s->len[t][i];
@@ -509,15 +576,16 @@ void sendMTFValues(EState* s)
 			}
 		}
 
-		bsW(s, 16, inUse16);
+		bsW16(s, inUse16);
 
 		inUse16 <<= (sizeof(int)*8 - 16); /* move 15th bit into sign bit */
 		for (i = 0; i < 16; i++) {
 			if (inUse16 < 0) {
 				unsigned v16 = 0;
+				unsigned j;
 				for (j = 0; j < 16; j++)
 					v16 = v16*2 + s->inUse[i * 16 + j];
-				bsW(s, 16, v16);
+				bsW16(s, v16);
 			}
 			inUse16 <<= 1;
 		}
@@ -527,19 +595,20 @@ void sendMTFValues(EState* s)
 	bsW(s, 3, nGroups);
 	bsW(s, 15, nSelectors);
 	for (i = 0; i < nSelectors; i++) {
+		unsigned j;
 		for (j = 0; j < s->selectorMtf[i]; j++)
-			bsW(s, 1, 1);
-		bsW(s, 1, 0);
+			bsW1_1(s);
+		bsW1_0(s);
 	}
 
 	/*--- Now the coding tables. ---*/
 	for (t = 0; t < nGroups; t++) {
-		int32_t curr = s->len[t][0];
+		unsigned curr = s->len[t][0];
 		bsW(s, 5, curr);
 		for (i = 0; i < alphaSize; i++) {
-			while (curr < s->len[t][i]) { bsW(s, 2, 2); curr++; /* 10 */ };
-			while (curr > s->len[t][i]) { bsW(s, 2, 3); curr--; /* 11 */ };
-			bsW(s, 1, 0);
+			while (curr < s->len[t][i]) { bsW(s, 2, 2); curr++; /* 10 */ }
+			while (curr > s->len[t][i]) { bsW(s, 2, 3); curr--; /* 11 */ }
+			bsW1_0(s);
 		}
 	}
 
@@ -547,6 +616,8 @@ void sendMTFValues(EState* s)
 	selCtr = 0;
 	gs = 0;
 	while (1) {
+		unsigned ge;
+
 		if (gs >= s->nMTF)
 			break;
 		ge = gs + BZ_G_SIZE - 1;
@@ -605,17 +676,21 @@ void sendMTFValues(EState* s)
 static
 void BZ2_compressBlock(EState* s, int is_last_block)
 {
+	int32_t origPtr = origPtr;
+
 	if (s->nblock > 0) {
 		BZ_FINALISE_CRC(s->blockCRC);
 		s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);
 		s->combinedCRC ^= s->blockCRC;
 		if (s->blockNo > 1)
-			s->numZ = 0;
+			s->posZ = s->zbits; // was: s->numZ = 0;
 
-		BZ2_blockSort(s);
+		origPtr = BZ2_blockSort(s);
 	}
 
 	s->zbits = &((uint8_t*)s->arr2)[s->nblock];
+	s->posZ = s->zbits;
+	s->state_out_pos = s->zbits;
 
 	/*-- If this is the first block, create the stream header. --*/
 	if (s->blockNo == 1) {
@@ -649,9 +724,9 @@ void BZ2_compressBlock(EState* s, int is
 		 * so as to maintain backwards compatibility with
 		 * older versions of bzip2.
 		 */
-		bsW(s, 1, 0);
+		bsW1_0(s);
 
-		bsW(s, 24, s->origPtr);
+		bsW(s, 24, origPtr);
 		generateMTFValues(s);
 		sendMTFValues(s);
 	}
diff -urpN busybox-1.28.4/archival/libarchive/bz/huffman.c busybox-1.29.0/archival/libarchive/bz/huffman.c
--- busybox-1.28.4/archival/libarchive/bz/huffman.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/bz/huffman.c	2018-07-02 15:55:14.000000000 +0200
@@ -48,7 +48,7 @@ in the file LICENSE.
 
 
 /* 90 bytes, 0.3% of overall compress speed */
-#if CONFIG_BZIP2_FAST >= 1
+#if BZIP2_SPEED >= 1
 
 /* macro works better than inline (gcc 4.2.1) */
 #define DOWNHEAP1(heap, weight, Heap) \
@@ -217,7 +217,7 @@ void BZ2_hbAssignCodes(int32_t *code,
 			if (length[i] == n) {
 				code[i] = vec;
 				vec++;
-			};
+			}
 		}
 		vec <<= 1;
 	}
diff -urpN busybox-1.28.4/archival/libarchive/data_extract_all.c busybox-1.29.0/archival/libarchive/data_extract_all.c
--- busybox-1.28.4/archival/libarchive/data_extract_all.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/data_extract_all.c	2018-07-02 15:55:14.000000000 +0200
@@ -122,13 +122,10 @@ void FAST_FUNC data_extract_all(archive_
 
 	/* Handle hard links separately */
 	if (hard_link) {
-		res = link(hard_link, dst_name);
-		if (res != 0) {
-			/* shared message */
-			bb_perror_msg("can't create %slink '%s' to '%s'",
-				"hard",	dst_name, hard_link
-			);
-		}
+		create_or_remember_link(&archive_handle->link_placeholders,
+				hard_link,
+				dst_name,
+				1);
 		/* Hardlinks have no separate mode/ownership, skip chown/chmod */
 		goto ret;
 	}
@@ -195,9 +192,10 @@ void FAST_FUNC data_extract_all(archive_
 		 *
 		 * Untarring bug.tar would otherwise place evil.py in '/tmp'.
 		 */
-		create_or_remember_symlink(&archive_handle->symlink_placeholders,
+		create_or_remember_link(&archive_handle->link_placeholders,
 				file_header->link_target,
-				dst_name);
+				dst_name,
+				0);
 		break;
 	case S_IFSOCK:
 	case S_IFBLK:
diff -urpN busybox-1.28.4/archival/libarchive/data_extract_to_command.c busybox-1.29.0/archival/libarchive/data_extract_to_command.c
--- busybox-1.28.4/archival/libarchive/data_extract_to_command.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/data_extract_to_command.c	2018-07-02 15:55:14.000000000 +0200
@@ -37,7 +37,7 @@ static const char *const tar_var[] = {
 static void xputenv(char *str)
 {
 	if (putenv(str))
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 }
 
 static void str2env(char *env[], int idx, const char *str)
diff -urpN busybox-1.28.4/archival/libarchive/decompress_bunzip2.c busybox-1.29.0/archival/libarchive/decompress_bunzip2.c
--- busybox-1.28.4/archival/libarchive/decompress_bunzip2.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/decompress_bunzip2.c	2018-07-02 15:55:14.000000000 +0200
@@ -100,7 +100,7 @@ struct bunzip_data {
 	unsigned dbufSize;
 
 	/* For I/O error handling */
-	jmp_buf jmpbuf;
+	jmp_buf *jmpbuf;
 
 	/* Big things go last (register-relative addressing can be larger for big offsets) */
 	uint32_t crc32Table[256];
@@ -127,7 +127,7 @@ static unsigned get_bits(bunzip_data *bd
 			/* if "no input fd" case: in_fd == -1, read fails, we jump */
 			bd->inbufCount = read(bd->in_fd, bd->inbuf, IOBUF_SIZE);
 			if (bd->inbufCount <= 0)
-				longjmp(bd->jmpbuf, RETVAL_UNEXPECTED_INPUT_EOF);
+				longjmp(*bd->jmpbuf, RETVAL_UNEXPECTED_INPUT_EOF);
 			bd->inbufPos = 0;
 		}
 
@@ -151,12 +151,12 @@ static unsigned get_bits(bunzip_data *bd
 
 	return bits;
 }
+//#define get_bits(bd, n) (dbg("%d:get_bits()", __LINE__), get_bits(bd, n))
 
 /* Unpacks the next block and sets up for the inverse Burrows-Wheeler step. */
 static int get_next_block(bunzip_data *bd)
 {
-	struct group_data *hufGroup;
-	int groupCount, *base, *limit, selector,
+	int groupCount, selector,
 		i, j, symCount, symTotal, nSelectors, byteCount[256];
 	uint8_t uc, symToByte[256], mtfSymbol[256], *selectors;
 	uint32_t *dbuf;
@@ -179,15 +179,19 @@ static int get_next_block(bunzip_data *b
 	i = get_bits(bd, 24);
 	j = get_bits(bd, 24);
 	bd->headerCRC = get_bits(bd, 32);
-	if ((i == 0x177245) && (j == 0x385090)) return RETVAL_LAST_BLOCK;
-	if ((i != 0x314159) || (j != 0x265359)) return RETVAL_NOT_BZIP_DATA;
+	if ((i == 0x177245) && (j == 0x385090))
+		return RETVAL_LAST_BLOCK;
+	if ((i != 0x314159) || (j != 0x265359))
+		return RETVAL_NOT_BZIP_DATA;
 
 	/* We can add support for blockRandomised if anybody complains.  There was
 	   some code for this in busybox 1.0.0-pre3, but nobody ever noticed that
 	   it didn't actually work. */
-	if (get_bits(bd, 1)) return RETVAL_OBSOLETE_INPUT;
+	if (get_bits(bd, 1))
+		return RETVAL_OBSOLETE_INPUT;
 	origPtr = get_bits(bd, 24);
-	if (origPtr > bd->dbufSize) return RETVAL_DATA_ERROR;
+	if (origPtr > bd->dbufSize)
+		return RETVAL_DATA_ERROR;
 
 	/* mapping table: if some byte values are never used (encoding things
 	   like ascii text), the compression code removes the gaps to have fewer
@@ -231,13 +235,21 @@ static int get_next_block(bunzip_data *b
 		/* Get next value */
 		int n = 0;
 		while (get_bits(bd, 1)) {
-			if (n >= groupCount) return RETVAL_DATA_ERROR;
+			if (n >= groupCount)
+				return RETVAL_DATA_ERROR;
 			n++;
 		}
 		/* Decode MTF to get the next selector */
 		tmp_byte = mtfSymbol[n];
 		while (--n >= 0)
 			mtfSymbol[n + 1] = mtfSymbol[n];
+//We catch it later, in the second loop where we use selectors[i].
+//Maybe this is a better place, though?
+//		if (tmp_byte >= groupCount) {
+//			dbg("%d: selectors[%d]:%d groupCount:%d",
+//					__LINE__, i, tmp_byte, groupCount);
+//			return RETVAL_DATA_ERROR;
+//		}
 		mtfSymbol[0] = selectors[i] = tmp_byte;
 	}
 
@@ -248,6 +260,8 @@ static int get_next_block(bunzip_data *b
 		uint8_t length[MAX_SYMBOLS];
 		/* 8 bits is ALMOST enough for temp[], see below */
 		unsigned temp[MAX_HUFCODE_BITS+1];
+		struct group_data *hufGroup;
+		int *base, *limit;
 		int minLen, maxLen, pp, len_m1;
 
 		/* Read Huffman code lengths for each symbol.  They're stored in
@@ -283,8 +297,10 @@ static int get_next_block(bunzip_data *b
 		/* Find largest and smallest lengths in this group */
 		minLen = maxLen = length[0];
 		for (i = 1; i < symCount; i++) {
-			if (length[i] > maxLen) maxLen = length[i];
-			else if (length[i] < minLen) minLen = length[i];
+			if (length[i] > maxLen)
+				maxLen = length[i];
+			else if (length[i] < minLen)
+				minLen = length[i];
 		}
 
 		/* Calculate permute[], base[], and limit[] tables from length[].
@@ -320,7 +336,8 @@ static int get_next_block(bunzip_data *b
 		/* Count symbols coded for at each bit length */
 		/* NB: in pathological cases, temp[8] can end ip being 256.
 		 * That's why uint8_t is too small for temp[]. */
-		for (i = 0; i < symCount; i++) temp[length[i]]++;
+		for (i = 0; i < symCount; i++)
+			temp[length[i]]++;
 
 		/* Calculate limit[] (the largest symbol-coding value at each bit
 		 * length, which is (previous limit<<1)+symbols at this level), and
@@ -363,12 +380,22 @@ static int get_next_block(bunzip_data *b
 
 	runPos = dbufCount = selector = 0;
 	for (;;) {
+		struct group_data *hufGroup;
+		int *base, *limit;
 		int nextSym;
+		uint8_t ngrp;
 
 		/* Fetch next Huffman coding group from list. */
 		symCount = GROUP_SIZE - 1;
-		if (selector >= nSelectors) return RETVAL_DATA_ERROR;
-		hufGroup = bd->groups + selectors[selector++];
+		if (selector >= nSelectors)
+			return RETVAL_DATA_ERROR;
+		ngrp = selectors[selector++];
+		if (ngrp >= groupCount) {
+			dbg("%d selectors[%d]:%d groupCount:%d",
+				__LINE__, selector-1, ngrp, groupCount);
+			return RETVAL_DATA_ERROR;
+		}
+		hufGroup = bd->groups + ngrp;
 		base = hufGroup->base - 1;
 		limit = hufGroup->limit - 1;
 
@@ -403,7 +430,8 @@ static int get_next_block(bunzip_data *b
 		}
 		/* Figure how many bits are in next symbol and unget extras */
 		i = hufGroup->minLen;
-		while (nextSym > limit[i]) ++i;
+		while (nextSym > limit[i])
+			++i;
 		j = hufGroup->maxLen - i;
 		if (j < 0)
 			return RETVAL_DATA_ERROR;
@@ -671,7 +699,10 @@ int FAST_FUNC read_bunzip(bunzip_data *b
 /* Because bunzip2 is used for help text unpacking, and because bb_show_usage()
    should work for NOFORK applets too, we must be extremely careful to not leak
    any allocations! */
-int FAST_FUNC start_bunzip(bunzip_data **bdp, int in_fd,
+int FAST_FUNC start_bunzip(
+		void *jmpbuf,
+		bunzip_data **bdp,
+		int in_fd,
 		const void *inbuf, int len)
 {
 	bunzip_data *bd;
@@ -683,11 +714,14 @@ int FAST_FUNC start_bunzip(bunzip_data *
 
 	/* Figure out how much data to allocate */
 	i = sizeof(bunzip_data);
-	if (in_fd != -1) i += IOBUF_SIZE;
+	if (in_fd != -1)
+		i += IOBUF_SIZE;
 
 	/* Allocate bunzip_data.  Most fields initialize to zero. */
 	bd = *bdp = xzalloc(i);
 
+	bd->jmpbuf = jmpbuf;
+
 	/* Setup input buffer */
 	bd->in_fd = in_fd;
 	if (-1 == in_fd) {
@@ -702,10 +736,6 @@ int FAST_FUNC start_bunzip(bunzip_data *
 	/* Init the CRC32 table (big endian) */
 	crc32_filltable(bd->crc32Table, 1);
 
-	/* Setup for I/O error handling via longjmp */
-	i = setjmp(bd->jmpbuf);
-	if (i) return i;
-
 	/* Ensure that file starts with "BZh['1'-'9']." */
 	/* Update: now caller verifies 1st two bytes, makes .gz/.bz2
 	 * integration easier */
@@ -752,8 +782,12 @@ unpack_bz2_stream(transformer_state_t *x
 	outbuf = xmalloc(IOBUF_SIZE);
 	len = 0;
 	while (1) { /* "Process one BZ... stream" loop */
+		jmp_buf jmpbuf;
 
-		i = start_bunzip(&bd, xstate->src_fd, outbuf + 2, len);
+		/* Setup for I/O error handling via longjmp */
+		i = setjmp(jmpbuf);
+		if (i == 0)
+			i = start_bunzip(&jmpbuf, &bd, xstate->src_fd, outbuf + 2, len);
 
 		if (i == 0) {
 			while (1) { /* "Produce some output bytes" loop */
diff -urpN busybox-1.28.4/archival/libarchive/decompress_gunzip.c busybox-1.29.0/archival/libarchive/decompress_gunzip.c
--- busybox-1.28.4/archival/libarchive/decompress_gunzip.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/decompress_gunzip.c	2018-07-02 15:55:14.000000000 +0200
@@ -32,7 +32,6 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-#include <setjmp.h>
 #include "libbb.h"
 #include "bb_archive.h"
 
@@ -280,8 +279,8 @@ static unsigned fill_bitbuffer(STATE_PAR
 /* Given a list of code lengths and a maximum table size, make a set of
  * tables to decode that set of codes.  Return zero on success, one if
  * the given code set is incomplete (the tables are still built in this
- * case), two if the input is invalid (all zero length codes or an
- * oversubscribed set of lengths) - in this case stores NULL in *t.
+ * case), two if the input is invalid (an oversubscribed set of lengths)
+ * - in this case stores NULL in *t.
  *
  * b:	code lengths in bits (all assumed <= BMAX)
  * n:	number of codes (assumed <= N_MAX)
@@ -330,8 +329,15 @@ static int huft_build(const unsigned *b,
 		p++;     /* can't combine with above line (Solaris bug) */
 	} while (--i);
 	if (c[0] == n) {  /* null input - all zero length codes */
-		*m = 0;
-		return 2;
+		q = xzalloc(3 * sizeof(*q));
+		//q[0].v.t = NULL;
+		q[1].e = 99;    /* invalid code marker */
+		q[1].b = 1;
+		q[2].e = 99;    /* invalid code marker */
+		q[2].b = 1;
+		*t = q + 1;
+		*m = 1;
+		return 0;
 	}
 
 	/* Find minimum and maximum length, bound *m by those */
@@ -1000,7 +1006,7 @@ inflate_unzip_internal(STATE_PARAM trans
 	gunzip_bb = 0;
 
 	/* Create the crc table */
-	gunzip_crc_table = crc32_filltable(NULL, 0);
+	gunzip_crc_table = crc32_new_table_le();
 	gunzip_crc = ~0;
 
 	error_msg = "corrupted data";
diff -urpN busybox-1.28.4/archival/libarchive/decompress_unlzma.c busybox-1.29.0/archival/libarchive/decompress_unlzma.c
--- busybox-1.28.4/archival/libarchive/decompress_unlzma.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/decompress_unlzma.c	2018-07-02 15:55:14.000000000 +0200
@@ -11,6 +11,13 @@
 #include "libbb.h"
 #include "bb_archive.h"
 
+#if 0
+# define dbg(...) bb_error_msg(__VA_ARGS__)
+#else
+# define dbg(...) ((void)0)
+#endif
+
+
 #if ENABLE_FEATURE_LZMA_FAST
 #  define speed_inline ALWAYS_INLINE
 #  define size_inline
@@ -217,6 +224,7 @@ unpack_lzma_stream(transformer_state_t *
 	rc_t *rc;
 	int i;
 	uint8_t *buffer;
+	uint32_t buffer_size;
 	uint8_t previous_byte = 0;
 	size_t buffer_pos = 0, global_pos = 0;
 	int len = 0;
@@ -246,7 +254,8 @@ unpack_lzma_stream(transformer_state_t *
 	if (header.dict_size == 0)
 		header.dict_size++;
 
-	buffer = xmalloc(MIN(header.dst_size, header.dict_size));
+	buffer_size = MIN(header.dst_size, header.dict_size);
+	buffer = xmalloc(buffer_size);
 
 	{
 		int num_probs;
@@ -341,8 +350,12 @@ unpack_lzma_stream(transformer_state_t *
 						state = state < LZMA_NUM_LIT_STATES ? 9 : 11;
 
 						pos = buffer_pos - rep0;
-						if ((int32_t)pos < 0)
+						if ((int32_t)pos < 0) {
 							pos += header.dict_size;
+							/* see unzip_bad_lzma_2.zip: */
+							if (pos >= buffer_size)
+								goto bad;
+						}
 						previous_byte = buffer[pos];
 						goto one_byte1;
 #else
@@ -417,6 +430,10 @@ unpack_lzma_stream(transformer_state_t *
 						for (; num_bits2 != LZMA_NUM_ALIGN_BITS; num_bits2--)
 							rep0 = (rep0 << 1) | rc_direct_bit(rc);
 						rep0 <<= LZMA_NUM_ALIGN_BITS;
+						if ((int32_t)rep0 < 0) {
+							dbg("%d rep0:%d", __LINE__, rep0);
+							goto bad;
+						}
 						prob3 = p + LZMA_ALIGN;
 					}
 					i2 = 1;
@@ -453,7 +470,10 @@ unpack_lzma_stream(transformer_state_t *
 				if ((int32_t)pos < 0) {
 					pos += header.dict_size;
 					/* bug 10436 has an example file where this triggers: */
-					if ((int32_t)pos < 0)
+					//if ((int32_t)pos < 0)
+					//	goto bad;
+					/* more stringent test (see unzip_bad_lzma_1.zip): */
+					if (pos >= buffer_size)
 						goto bad;
 				}
 				previous_byte = buffer[pos];
@@ -482,6 +502,12 @@ unpack_lzma_stream(transformer_state_t *
 		IF_DESKTOP(total_written += buffer_pos;)
 		if (transformer_write(xstate, buffer, buffer_pos) != (ssize_t)buffer_pos) {
  bad:
+			/* One of our users, bbunpack(), expects _us_ to emit
+			 * the error message (since it's the best place to give
+			 * potentially more detailed information).
+			 * Do not fail silently.
+			 */
+			bb_error_msg("corrupted data");
 			total_written = -1; /* failure */
 		}
 		rc_free(rc);
diff -urpN busybox-1.28.4/archival/libarchive/decompress_unxz.c busybox-1.29.0/archival/libarchive/decompress_unxz.c
--- busybox-1.28.4/archival/libarchive/decompress_unxz.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/decompress_unxz.c	2018-07-02 15:55:14.000000000 +0200
@@ -52,7 +52,7 @@ unpack_xz_stream(transformer_state_t *xs
 	IF_DESKTOP(long long) int total = 0;
 
 	if (!global_crc32_table)
-		global_crc32_table = crc32_filltable(NULL, /*endian:*/ 0);
+		global_crc32_new_table_le();
 
 	memset(&iobuf, 0, sizeof(iobuf));
 	membuf = xmalloc(2 * BUFSIZ);
diff -urpN busybox-1.28.4/archival/libarchive/get_header_ar.c busybox-1.29.0/archival/libarchive/get_header_ar.c
--- busybox-1.28.4/archival/libarchive/get_header_ar.c	2018-05-22 17:52:51.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/get_header_ar.c	2018-07-02 15:55:14.000000000 +0200
@@ -34,10 +34,6 @@ char FAST_FUNC get_header_ar(archive_han
 		char raw[60];
 		struct ar_header formatted;
 	} ar;
-#if ENABLE_FEATURE_AR_LONG_FILENAMES
-	static char *ar_long_names;
-	static unsigned ar_long_name_size;
-#endif
 
 	/* dont use xread as we want to handle the error ourself */
 	if (read(archive_handle->src_fd, ar.raw, 60) != 60) {
@@ -81,10 +77,10 @@ char FAST_FUNC get_header_ar(archive_han
 			 * stores long filename for multiple entries, they are stored
 			 * in static variable long_names for use in future entries
 			 */
-			ar_long_name_size = size;
-			free(ar_long_names);
-			ar_long_names = xmalloc(size);
-			xread(archive_handle->src_fd, ar_long_names, size);
+			archive_handle->ar__long_name_size = size;
+			free(archive_handle->ar__long_names);
+			archive_handle->ar__long_names = xzalloc(size + 1);
+			xread(archive_handle->src_fd, archive_handle->ar__long_names, size);
 			archive_handle->offset += size;
 			/* Return next header */
 			return get_header_ar(archive_handle);
@@ -107,13 +103,13 @@ char FAST_FUNC get_header_ar(archive_han
 		unsigned long_offset;
 
 		/* The number after the '/' indicates the offset in the ar data section
-		 * (saved in ar_long_names) that conatains the real filename */
+		 * (saved in ar__long_names) that contains the real filename */
 		long_offset = read_num(&ar.formatted.name[1], 10,
 				       sizeof(ar.formatted.name) - 1);
-		if (long_offset >= ar_long_name_size) {
+		if (long_offset >= archive_handle->ar__long_name_size) {
 			bb_error_msg_and_die("can't resolve long filename");
 		}
-		typed->name = xstrdup(ar_long_names + long_offset);
+		typed->name = xstrdup(archive_handle->ar__long_names + long_offset);
 	} else
 #endif
 	{
@@ -130,7 +126,7 @@ char FAST_FUNC get_header_ar(archive_han
 			struct archive_handle_t *sa = archive_handle->dpkg__sub_archive;
 			while (archive_handle->dpkg__action_data_subarchive(sa) == EXIT_SUCCESS)
 				continue;
-			create_symlinks_from_list(sa->symlink_placeholders);
+			create_links_from_list(sa->link_placeholders);
 		} else
 #endif
 			archive_handle->action_data(archive_handle);
diff -urpN busybox-1.28.4/archival/libarchive/lzo1x_d.c busybox-1.29.0/archival/libarchive/lzo1x_d.c
--- busybox-1.28.4/archival/libarchive/lzo1x_d.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/lzo1x_d.c	2018-07-02 15:55:14.000000000 +0200
@@ -31,8 +31,7 @@
 ************************************************************************/
 /* safe decompression with overrun testing */
 int lzo1x_decompress_safe(const uint8_t* in, unsigned in_len,
-		uint8_t* out, unsigned* out_len,
-		void* wrkmem UNUSED_PARAM)
+		uint8_t* out, unsigned* out_len /*, void* wrkmem */)
 {
 	register uint8_t* op;
 	register const uint8_t* ip;
diff -urpN busybox-1.28.4/archival/libarchive/unsafe_symlink_target.c busybox-1.29.0/archival/libarchive/unsafe_symlink_target.c
--- busybox-1.28.4/archival/libarchive/unsafe_symlink_target.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/archival/libarchive/unsafe_symlink_target.c	2018-07-02 15:55:14.000000000 +0200
@@ -5,13 +5,14 @@
 #include "libbb.h"
 #include "bb_archive.h"
 
-void FAST_FUNC create_or_remember_symlink(llist_t **symlink_placeholders,
+void FAST_FUNC create_or_remember_link(llist_t **link_placeholders,
 		const char *target,
-		const char *linkname)
+		const char *linkname,
+		int hard_link)
 {
-	if (target[0] == '/' || strstr(target, "..")) {
-		llist_add_to(symlink_placeholders,
-			xasprintf("%s%c%s", linkname, '\0', target)
+	if (hard_link || target[0] == '/' || strstr(target, "..")) {
+		llist_add_to_end(link_placeholders,
+			xasprintf("%c%s%c%s", hard_link, linkname, '\0', target)
 		);
 		return;
 	}
@@ -23,17 +24,17 @@ void FAST_FUNC create_or_remember_symlin
 	}
 }
 
-void FAST_FUNC create_symlinks_from_list(llist_t *list)
+void FAST_FUNC create_links_from_list(llist_t *list)
 {
 	while (list) {
 		char *target;
 
-		target = list->data + strlen(list->data) + 1;
-		if (symlink(target, list->data)) {
+		target = list->data + 1 + strlen(list->data + 1) + 1;
+		if ((*list->data ? link : symlink) (target, list->data + 1)) {
 			/* shared message */
 			bb_error_msg_and_die("can't create %slink '%s' to '%s'",
-				"sym",
-				list->data, target
+				*list->data ? "hard" : "sym",
+				list->data + 1, target
 			);
 		}
 		list = list->link;
diff -urpN busybox-1.28.4/archival/lzop.c busybox-1.29.0/archival/lzop.c
--- busybox-1.28.4/archival/lzop.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/lzop.c	2018-07-02 15:55:14.000000000 +0200
@@ -80,7 +80,7 @@
 //usage:     "\n	-F	Don't verify checksum"
 //usage:
 //usage:#define unlzop_trivial_usage
-//usage:       "[-cfkvF] [FILE]..."
+//usage:       "[-cfUvF] [FILE]..."
 //usage:#define unlzop_full_usage "\n\n"
 //usage:       "	-c	Write to stdout"
 //usage:     "\n	-f	Force"
@@ -141,8 +141,7 @@ static void copy3(uint8_t* ip, const uin
 #define TEST_OP		(op <= op_end)
 
 static NOINLINE int lzo1x_optimize(uint8_t *in, unsigned in_len,
-		uint8_t *out, unsigned *out_len,
-		void* wrkmem UNUSED_PARAM)
+		uint8_t *out, unsigned *out_len /*, void* wrkmem */)
 {
 	uint8_t* op;
 	uint8_t* ip;
@@ -439,36 +438,33 @@ typedef struct chksum_t {
 } chksum_t;
 
 typedef struct header_t {
-	unsigned version;
-	unsigned lib_version;
-	unsigned version_needed_to_extract;
-	uint32_t flags;
-	uint32_t mode;
-	uint32_t mtime;
-	uint32_t gmtdiff;
-	uint32_t header_checksum;
+	/* used to have auxiliary fields here */
 
-	uint32_t extra_field_len;
-	uint32_t extra_field_checksum;
-
-	unsigned char method;
-	unsigned char level;
-
-	/* info */
-	char name[255+1];
+	/* Starting from here, the layout and endianness
+	 * are exactly in on-disk format.
+	 */
+	uint16_t version_be16;
+	uint16_t lib_version_be16;
+	uint16_t version_needed_to_extract_be16;
+	uint8_t  method;
+	uint8_t	 level;
+	uint32_t flags32; /* be32 on disk, but we keep this field in native order */
+	uint32_t mode_be32;
+	uint32_t mtime_be32;
+	uint32_t gmtdiff_be32;
+	char     len_and_name[1+255+1];
 } header_t;
 
 struct globals {
 	/*const uint32_t *lzo_crc32_table;*/
-	chksum_t chksum_in;
-	chksum_t chksum_out;
+	chksum_t chksum;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
-#define INIT_G() do { setup_common_bufsiz(); } while (0)
 //#define G (*ptr_to_globals)
-//#define INIT_G() do {
-//	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G)));
-//} while (0)
+#define INIT_G() do { \
+	setup_common_bufsiz(); \
+	/*SET_PTR_TO_GLOBALS(xzalloc(sizeof(G)));*/ \
+} while (0)
 
 
 /**********************************************************************/
@@ -549,24 +545,24 @@ lzo_crc32(uint32_t c, const uint8_t* buf
 }
 
 /**********************************************************************/
-static void init_chksum(chksum_t *ct)
+static void init_chksum(void)
 {
-	ct->f_adler32 = ADLER32_INIT_VALUE;
-	ct->f_crc32 = CRC32_INIT_VALUE;
+	G.chksum.f_adler32 = ADLER32_INIT_VALUE;
+	G.chksum.f_crc32 = CRC32_INIT_VALUE;
 }
 
-static void add_bytes_to_chksum(chksum_t *ct, const void* buf, int cnt)
+static void add_bytes_to_chksum(const void* buf, int cnt)
 {
 	/* We need to handle the two checksums at once, because at the
 	 * beginning of the header, we don't know yet which one we'll
 	 * eventually need */
-	ct->f_adler32 = lzo_adler32(ct->f_adler32, (const uint8_t*)buf, cnt);
-	ct->f_crc32 = lzo_crc32(ct->f_crc32, (const uint8_t*)buf, cnt);
+	G.chksum.f_adler32 = lzo_adler32(G.chksum.f_adler32, (const uint8_t*)buf, cnt);
+	G.chksum.f_crc32 = lzo_crc32(G.chksum.f_crc32, (const uint8_t*)buf, cnt);
 }
 
-static uint32_t chksum_getresult(chksum_t *ct, const header_t *h)
+static uint32_t chksum_getresult(uint32_t h_flags32)
 {
-	return (h->flags & F_H_CRC32) ? ct->f_crc32 : ct->f_adler32;
+	return (h_flags32 & F_H_CRC32) ? G.chksum.f_crc32 : G.chksum.f_adler32;
 }
 
 /**********************************************************************/
@@ -576,50 +572,23 @@ static uint32_t read32(void)
 	xread(0, &v, 4);
 	return ntohl(v);
 }
-
-static void write32(uint32_t v)
-{
-	v = htonl(v);
-	xwrite(1, &v, 4);
-}
-
-static void f_write(const void* buf, int cnt)
-{
-	xwrite(1, buf, cnt);
-	add_bytes_to_chksum(&G.chksum_out, buf, cnt);
-}
-
 static void f_read(void* buf, int cnt)
 {
 	xread(0, buf, cnt);
-	add_bytes_to_chksum(&G.chksum_in, buf, cnt);
-}
-
-static int f_read8(void)
-{
-	uint8_t v;
-	f_read(&v, 1);
-	return v;
-}
-
-static void f_write8(uint8_t v)
-{
-	f_write(&v, 1);
-}
-
-static unsigned f_read16(void)
-{
-	uint16_t v;
-	f_read(&v, 2);
-	return ntohs(v);
-}
-
-static void f_write16(uint16_t v)
-{
-	v = htons(v);
-	f_write(&v, 2);
+	add_bytes_to_chksum(buf, cnt);
 }
-
+//static int f_read8(void)
+//{
+//	uint8_t v;
+//	f_read(&v, 1);
+//	return v;
+//}
+//static unsigned f_read16(void)
+//{
+//	uint16_t v;
+//	f_read(&v, 2);
+//	return ntohs(v);
+//}
 static uint32_t f_read32(void)
 {
 	uint32_t v;
@@ -627,34 +596,30 @@ static uint32_t f_read32(void)
 	return ntohl(v);
 }
 
-static void f_write32(uint32_t v)
+static void write32(uint32_t v)
 {
 	v = htonl(v);
-	f_write(&v, 4);
+	xwrite(1, &v, 4);
 }
-
-/**********************************************************************/
-static int lzo_get_method(header_t *h)
+static void f_write(const void* buf, int cnt)
 {
-	/* check method */
-	if (h->method == M_LZO1X_1) {
-		if (h->level == 0)
-			h->level = 3;
-	} else if (h->method == M_LZO1X_1_15) {
-		if (h->level == 0)
-			h->level = 1;
-	} else if (h->method == M_LZO1X_999) {
-		if (h->level == 0)
-			h->level = 9;
-	} else
-		return -1;		/* not a LZO method */
-
-	/* check compression level */
-	if (h->level < 1 || h->level > 9)
-		return 15;
-
-	return 0;
+	xwrite(1, buf, cnt);
+	add_bytes_to_chksum(buf, cnt);
 }
+//static void f_write8(uint8_t v)
+//{
+//	f_write(&v, 1);
+//}
+//static void f_write16(uint16_t v)
+//{
+//	v = htons(v);
+//	f_write(&v, 2);
+//}
+//static void f_write32(uint32_t v)
+//{
+//	v = htonl(v);
+//	f_write(&v, 4);
+//}
 
 /**********************************************************************/
 #define LZO_BLOCK_SIZE	(256 * 1024l)
@@ -672,86 +637,101 @@ static NOINLINE int lzo_compress(const h
 	int r = 0; /* LZO_E_OK */
 	uint8_t *const b1 = xzalloc(block_size);
 	uint8_t *const b2 = xzalloc(MAX_COMPRESSED_SIZE(block_size));
-	unsigned src_len = 0, dst_len = 0;
 	uint32_t d_adler32 = ADLER32_INIT_VALUE;
 	uint32_t d_crc32 = CRC32_INIT_VALUE;
-	int l;
 	uint8_t *wrk_mem = NULL;
 
+	/* Only these methods are possible, see lzo_set_method():
+	 * -1:    M_LZO1X_1_15
+	 * -2..6: M_LZO1X_1
+	 * -7..9: M_LZO1X_999 if ENABLE_LZOP_COMPR_HIGH
+	 */
 	if (h->method == M_LZO1X_1)
 		wrk_mem = xzalloc(LZO1X_1_MEM_COMPRESS);
-	else if (h->method == M_LZO1X_1_15)
-		wrk_mem = xzalloc(LZO1X_1_15_MEM_COMPRESS);
-	else if (h->method == M_LZO1X_999)
+	else /* check only if it's not the only possibility */
+		IF_LZOP_COMPR_HIGH(if (h->method == M_LZO1X_1_15))
+			wrk_mem = xzalloc(LZO1X_1_15_MEM_COMPRESS);
+#if ENABLE_LZOP_COMPR_HIGH
+	else /* must be h->method == M_LZO1X_999 */
 		wrk_mem = xzalloc(LZO1X_999_MEM_COMPRESS);
+#endif
 
 	for (;;) {
+		unsigned src_len, dst_len;
+		int l;
+		uint32_t wordbuf[6];
+		uint32_t *wordptr = wordbuf;
+
 		/* read a block */
 		l = full_read(0, b1, block_size);
 		src_len = (l > 0 ? l : 0);
 
 		/* write uncompressed block size */
-		write32(src_len);
-
 		/* exit if last block */
-		if (src_len == 0)
+		if (src_len == 0) {
+			write32(0);
 			break;
+		}
+		*wordptr++ = htonl(src_len);
 
 		/* compute checksum of uncompressed block */
-		if (h->flags & F_ADLER32_D)
+		if (h->flags32 & F_ADLER32_D)
 			d_adler32 = lzo_adler32(ADLER32_INIT_VALUE, b1, src_len);
-		if (h->flags & F_CRC32_D)
+		if (h->flags32 & F_CRC32_D)
 			d_crc32 = lzo_crc32(CRC32_INIT_VALUE, b1, src_len);
 
 		/* compress */
 		if (h->method == M_LZO1X_1)
 			r = lzo1x_1_compress(b1, src_len, b2, &dst_len, wrk_mem);
-		else if (h->method == M_LZO1X_1_15)
+		else IF_LZOP_COMPR_HIGH(if (h->method == M_LZO1X_1_15))
 			r = lzo1x_1_15_compress(b1, src_len, b2, &dst_len, wrk_mem);
 #if ENABLE_LZOP_COMPR_HIGH
-		else if (h->method == M_LZO1X_999)
+		else /* must be h->method == M_LZO1X_999 */
 			r = lzo1x_999_compress_level(b1, src_len, b2, &dst_len,
 						wrk_mem, h->level);
 #endif
-		else
-			bb_error_msg_and_die("internal error");
-
 		if (r != 0) /* not LZO_E_OK */
-			bb_error_msg_and_die("internal error - compression failed");
+			bb_error_msg_and_die("%s: %s", "internal error", "compression");
 
 		/* write compressed block size */
 		if (dst_len < src_len) {
 			/* optimize */
 			if (h->method == M_LZO1X_999) {
 				unsigned new_len = src_len;
-				r = lzo1x_optimize(b2, dst_len, b1, &new_len, NULL);
+				r = lzo1x_optimize(b2, dst_len, b1, &new_len /*, NULL*/);
 				if (r != 0 /*LZO_E_OK*/ || new_len != src_len)
-					bb_error_msg_and_die("internal error - optimization failed");
+					bb_error_msg_and_die("%s: %s", "internal error", "optimization");
 			}
-			write32(dst_len);
+			*wordptr++ = htonl(dst_len);
 		} else {
 			/* data actually expanded => store data uncompressed */
-			write32(src_len);
+			*wordptr++ = htonl(src_len);
 		}
 
 		/* write checksum of uncompressed block */
-		if (h->flags & F_ADLER32_D)
-			write32(d_adler32);
-		if (h->flags & F_CRC32_D)
-			write32(d_crc32);
+		if (h->flags32 & F_ADLER32_D)
+			*wordptr++ = htonl(d_adler32);
+		if (h->flags32 & F_CRC32_D)
+			*wordptr++ = htonl(d_crc32);
 
 		if (dst_len < src_len) {
 			/* write checksum of compressed block */
-			if (h->flags & F_ADLER32_C)
-				write32(lzo_adler32(ADLER32_INIT_VALUE, b2, dst_len));
-			if (h->flags & F_CRC32_C)
-				write32(lzo_crc32(CRC32_INIT_VALUE, b2, dst_len));
+			if (h->flags32 & F_ADLER32_C)
+				*wordptr++ = htonl(lzo_adler32(ADLER32_INIT_VALUE, b2, dst_len));
+			if (h->flags32 & F_CRC32_C)
+				*wordptr++ = htonl(lzo_crc32(CRC32_INIT_VALUE, b2, dst_len));
+		}
+		xwrite(1, wordbuf, ((char*)wordptr) - ((char*)wordbuf));
+		if (dst_len < src_len) {
 			/* write compressed block data */
 			xwrite(1, b2, dst_len);
 		} else {
 			/* write uncompressed block data */
 			xwrite(1, b1, src_len);
 		}
+		// /* if full_read() was nevertheless "short", it was EOF */
+		// if (src_len < block_size)
+		// 	break;
 	}
 
 	free(wrk_mem);
@@ -778,7 +758,9 @@ static FAST_FUNC void lzo_check(
 /**********************************************************************/
 // decompress a file
 /**********************************************************************/
-static NOINLINE int lzo_decompress(const header_t *h)
+// used to have "const header_t *h" parameter, but since it uses
+// only flags32 field, changed to receive only that.
+static NOINLINE int lzo_decompress(uint32_t h_flags32)
 {
 	unsigned block_size = LZO_BLOCK_SIZE;
 	int r;
@@ -823,16 +805,16 @@ static NOINLINE int lzo_decompress(const
 		}
 
 		/* read checksum of uncompressed block */
-		if (h->flags & F_ADLER32_D)
+		if (h_flags32 & F_ADLER32_D)
 			d_adler32 = read32();
-		if (h->flags & F_CRC32_D)
+		if (h_flags32 & F_CRC32_D)
 			d_crc32 = read32();
 
 		/* read checksum of compressed block */
 		if (src_len < dst_len) {
-			if (h->flags & F_ADLER32_C)
+			if (h_flags32 & F_ADLER32_C)
 				c_adler32 = read32();
-			if (h->flags & F_CRC32_C)
+			if (h_flags32 & F_CRC32_C)
 				c_crc32 = read32();
 		}
 
@@ -847,11 +829,11 @@ static NOINLINE int lzo_decompress(const
 
 			if (!(option_mask32 & OPT_F)) {
 				/* verify checksum of compressed block */
-				if (h->flags & F_ADLER32_C)
+				if (h_flags32 & F_ADLER32_C)
 					lzo_check(ADLER32_INIT_VALUE,
 							b1, src_len,
 							lzo_adler32, c_adler32);
-				if (h->flags & F_CRC32_C)
+				if (h_flags32 & F_CRC32_C)
 					lzo_check(CRC32_INIT_VALUE,
 							b1, src_len,
 							lzo_crc32, c_crc32);
@@ -859,9 +841,9 @@ static NOINLINE int lzo_decompress(const
 
 			/* decompress */
 //			if (option_mask32 & OPT_F)
-//				r = lzo1x_decompress(b1, src_len, b2, &d, NULL);
+//				r = lzo1x_decompress(b1, src_len, b2, &d /*, NULL*/);
 //			else
-				r = lzo1x_decompress_safe(b1, src_len, b2, &d, NULL);
+				r = lzo1x_decompress_safe(b1, src_len, b2, &d /*, NULL*/);
 
 			if (r != 0 /*LZO_E_OK*/ || dst_len != d) {
 				bb_error_msg_and_die("corrupted data");
@@ -874,11 +856,11 @@ static NOINLINE int lzo_decompress(const
 
 		if (!(option_mask32 & OPT_F)) {
 			/* verify checksum of uncompressed block */
-			if (h->flags & F_ADLER32_D)
+			if (h_flags32 & F_ADLER32_D)
 				lzo_check(ADLER32_INIT_VALUE,
 					dst, dst_len,
 					lzo_adler32, d_adler32);
-			if (h->flags & F_CRC32_D)
+			if (h_flags32 & F_CRC32_D)
 				lzo_check(CRC32_INIT_VALUE,
 					dst, dst_len,
 					lzo_crc32, d_crc32);
@@ -918,7 +900,7 @@ static NOINLINE int lzo_decompress(const
  * -00000020  00 00 2d 67 04 17 00 04 00 00 00 03 ed ec 9d 6d
  * +00000020  00 00 10 5f 00 c1 00 04 00 00 00 03 ed ec 9d 6d
  *                  ^^^^^^^^^^^
- *                  chksum_out
+ *                  chksum
  * The rest is identical.
 */
 static const unsigned char lzop_magic[9] ALIGN1 = {
@@ -937,138 +919,138 @@ static void check_magic(void)
 /**********************************************************************/
 // lzop file header
 /**********************************************************************/
-static void write_header(const header_t *h)
+static void write_header(header_t *h)
 {
-	int l;
+	char *end;
 
 	xwrite(1, lzop_magic, sizeof(lzop_magic));
 
-	init_chksum(&G.chksum_out);
+	init_chksum();
 
-	f_write16(h->version);
-	f_write16(h->lib_version);
-	f_write16(h->version_needed_to_extract);
-	f_write8(h->method);
-	f_write8(h->level);
-	f_write32(h->flags);
-	f_write32(h->mode);
-	f_write32(h->mtime);
-	f_write32(h->gmtdiff);
-
-	l = (int) strlen(h->name);
-	f_write8(l);
-	if (l)
-		f_write(h->name, l);
+	/* Our caller leaves name zero-filled, so len == 0 */
+	end = h->len_and_name+1 + 0; /* 0 is strlen(h->len_and_name+1) */
+	/* Store length byte */
+	/*h->len_and_name[0] = end - (h->len_and_name+1); - zero already */
 
-	f_write32(chksum_getresult(&G.chksum_out, h));
+	f_write(&h->version_be16, end - (char*)&h->version_be16);
+
+	h->flags32 = htonl(h->flags32); /* native endianness for lzo_compress() */
+
+	write32(chksum_getresult(h->flags32));
 }
 
 static int read_header(header_t *h)
 {
-	int r;
 	int l;
 	uint32_t checksum;
+	/* As it stands now, only h->flags32 is used by our caller.
+	 * Therefore we don't store many fields in h->FIELD.
+	 */
+	unsigned h_version;
+	unsigned h_version_needed_to_extract;
 
-	memset(h, 0, sizeof(*h));
-	h->version_needed_to_extract = 0x0900;	/* first lzop version */
-	h->level = 0;
-
-	init_chksum(&G.chksum_in);
+	init_chksum();
 
-	h->version = f_read16();
-	if (h->version < 0x0900)
-		return 3;
-	h->lib_version = f_read16();
-	if (h->version >= 0x0940) {
-		h->version_needed_to_extract = f_read16();
-		if (h->version_needed_to_extract > LZOP_VERSION)
-			return 16;
-		if (h->version_needed_to_extract < 0x0900)
-			return 3;
-	}
-	h->method = f_read8();
-	if (h->version >= 0x0940)
-		h->level = f_read8();
-	h->flags = f_read32();
-	if (h->flags & F_H_FILTER)
-		return 16; /* filter not supported */
-	h->mode = f_read32();
-	h->mtime = f_read32();
-	if (h->version >= 0x0940)
-		h->gmtdiff = f_read32();
+	/* We don't support versions < 0.94, since 0.94
+	 * came only 2 months after 0.90:
+	 * 0.90 (10 Aug 1997): First public release of lzop
+	 * 0.94 (15 Oct 1997): Header format change
+	 */
 
-	l = f_read8();
-	if (l > 0)
-		f_read(h->name, l);
-	h->name[l] = 0;
+	/* Read up to and including name length byte */
+	f_read(&h->version_be16, ((char*)&h->len_and_name[1]) - ((char*)&h->version_be16));
 
-	checksum = chksum_getresult(&G.chksum_in, h);
-	h->header_checksum = f_read32();
-	if (h->header_checksum != checksum)
-		return 2;
+	h_version = htons(h->version_be16);
+	if (h_version < 0x0940)
+		return 3;
+	h_version_needed_to_extract = htons(h->version_needed_to_extract_be16);
+	if (h_version_needed_to_extract > LZOP_VERSION)
+		return 16;
+	if (h_version_needed_to_extract < 0x0940)
+		return 3;
 
 	if (h->method <= 0)
 		return 14;
-	r = lzo_get_method(h);
-	if (r != 0)
-		return r;
 
+	/* former lzo_get_method(h): */
+	if (h->method == M_LZO1X_1) {
+		if (h->level == 0)
+			h->level = 3;
+	} else if (h->method == M_LZO1X_1_15) {
+		if (h->level == 0)
+			h->level = 1;
+	} else if (h->method == M_LZO1X_999) {
+		if (h->level == 0)
+			h->level = 9;
+	} else
+		return -1; /* not a LZO method */
+	/* check compression level */
+	if (h->level < 1 || h->level > 9)
+		return 15;
+
+	h->flags32 = ntohl(h->flags32);
+	if (h->flags32 & F_H_FILTER)
+		return 16; /* filter not supported */
 	/* check reserved flags */
-	if (h->flags & F_RESERVED)
+	if (h->flags32 & F_RESERVED)
 		return -13;
 
+	l = h->len_and_name[0];
+	if (l > 0)
+		/* UNUSED */ f_read(h->len_and_name+1, l);
+	/* UNUSED h->len_and_name[1+l] = 0; */
+
+	checksum = chksum_getresult(h->flags32);
+	if (read32() != checksum)
+		return 2;
+
 	/* skip extra field [not used yet] */
-	if (h->flags & F_H_EXTRA_FIELD) {
+	if (h->flags32 & F_H_EXTRA_FIELD) {
+		uint32_t extra_field_len;
+		uint32_t extra_field_checksum;
 		uint32_t k;
+		char dummy;
 
 		/* note: the checksum also covers the length */
-		init_chksum(&G.chksum_in);
-		h->extra_field_len = f_read32();
-		for (k = 0; k < h->extra_field_len; k++)
-			f_read8();
-		checksum = chksum_getresult(&G.chksum_in, h);
-		h->extra_field_checksum = f_read32();
-		if (h->extra_field_checksum != checksum)
+		init_chksum();
+		extra_field_len = f_read32();
+		for (k = 0; k < extra_field_len; k++)
+			f_read(&dummy, 1);
+		checksum = chksum_getresult(h->flags32);
+		extra_field_checksum = read32();
+		if (extra_field_checksum != checksum)
 			return 3;
 	}
 
 	return 0;
 }
 
-static void p_header(header_t *h)
-{
-	int r;
-
-	r = read_header(h);
-	if (r == 0)
-		return;
-	bb_error_msg_and_die("header_error %d", r);
-}
-
 /**********************************************************************/
 // compress
 /**********************************************************************/
 static void lzo_set_method(header_t *h)
 {
-	int level = 1;
+	smallint level;
+
+	/* levels 2..6 or none (defaults to level 3) */
+	h->method = M_LZO1X_1;
+	level = 5; /* levels 2-6 are actually the same */
 
 	if (option_mask32 & OPT_1) {
 		h->method = M_LZO1X_1_15;
-	} else if (option_mask32 & OPT_789) {
+		level = 1;
+	}
+	if (option_mask32 & OPT_789) {
 #if ENABLE_LZOP_COMPR_HIGH
 		h->method = M_LZO1X_999;
+		level = 9;
 		if (option_mask32 & OPT_7)
 			level = 7;
 		else if (option_mask32 & OPT_8)
 			level = 8;
-		else
-			level = 9;
 #else
 		bb_error_msg_and_die("high compression not compiled in");
 #endif
-	} else { /* levels 2..6 or none (defaults to level 3) */
-		h->method = M_LZO1X_1;
-		level = 5; /* levels 2-6 are actually the same */
 	}
 
 	h->level = level;
@@ -1083,18 +1065,21 @@ static int do_lzo_compress(void)
 
 	lzo_set_method(h);
 
-	h->version = (LZOP_VERSION & 0xffff);
-	h->version_needed_to_extract = 0x0940;
-	h->lib_version = lzo_version() & 0xffff;
+	h->version_be16 = htons(LZOP_VERSION & 0xffff);
+	h->version_needed_to_extract_be16 = htons(0x0940);
+	h->lib_version_be16 = htons(lzo_version() & 0xffff);
 
-	h->flags = (F_OS & F_OS_MASK) | (F_CS & F_CS_MASK);
+	h->flags32 = htonl((F_OS & F_OS_MASK) | (F_CS & F_CS_MASK));
 
 	if (!(option_mask32 & OPT_F) || h->method == M_LZO1X_999) {
-		h->flags |= F_ADLER32_D;
+		h->flags32 |= htonl(F_ADLER32_D);
 		if (option_mask32 & OPT_C)
-			h->flags |= F_ADLER32_C;
+			h->flags32 |= htonl(F_ADLER32_C);
 	}
+
+	/* write_header() also converts h->flags32 to native endianness */
 	write_header(h);
+
 	return lzo_compress(h);
 #undef h
 }
@@ -1104,11 +1089,14 @@ static int do_lzo_compress(void)
 /**********************************************************************/
 static int do_lzo_decompress(void)
 {
+	int r;
 	header_t header;
 
 	check_magic();
-	p_header(&header);
-	return lzo_decompress(&header);
+	r = read_header(&header);
+	if (r != 0)
+		bb_error_msg_and_die("header_error %d", r);
+	return lzo_decompress(header.flags32);
 }
 
 static char* FAST_FUNC make_new_name_lzop(char *filename, const char *expected_ext UNUSED_PARAM)
@@ -1133,6 +1121,8 @@ static IF_DESKTOP(long long) int FAST_FU
 int lzop_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int lzop_main(int argc UNUSED_PARAM, char **argv)
 {
+	INIT_G();
+
 	getopt32(argv, OPTION_STRING);
 	argv += optind;
 	/* -U is "anti -k", invert bit for bbunpack(): */
@@ -1149,6 +1139,6 @@ int lzop_main(int argc UNUSED_PARAM, cha
 	if (ENABLE_UNLZOP && applet_name[4] == 'o')
 		option_mask32 |= OPT_DECOMPRESS;
 
-	global_crc32_table = crc32_filltable(NULL, 0);
+	global_crc32_new_table_le();
 	return bbunpack(argv, pack_lzop, make_new_name_lzop, /*unused:*/ NULL);
 }
diff -urpN busybox-1.28.4/archival/tar.c busybox-1.29.0/archival/tar.c
--- busybox-1.28.4/archival/tar.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/tar.c	2018-07-02 15:55:14.000000000 +0200
@@ -759,15 +759,15 @@ static llist_t *append_file_list_to_list
 //usage:	IF_FEATURE_SEAMLESS_LZMA("a")
 //usage:	IF_FEATURE_TAR_CREATE("h")
 //usage:	IF_FEATURE_TAR_NOPRESERVE_TIME("m")
-//usage:	"vO] "
+//usage:	"vokO] "
 //usage:	"[-f TARFILE] [-C DIR] "
 //usage:	IF_FEATURE_TAR_FROM("[-T FILE] [-X FILE] "IF_FEATURE_TAR_LONG_OPTIONS("[--exclude PATTERN]... "))
 //usage:	"[FILE]..."
 //usage:#define tar_full_usage "\n\n"
 //usage:	IF_FEATURE_TAR_CREATE("Create, extract, ")
 //usage:	IF_NOT_FEATURE_TAR_CREATE("Extract ")
-//usage:	"or list files from a tar file\n"
-//usage:     "\nOperation:"
+//usage:	"or list files from a tar file"
+//usage:     "\n"
 //usage:	IF_FEATURE_TAR_CREATE(
 //usage:     "\n	c	Create"
 //usage:	)
@@ -776,6 +776,13 @@ static llist_t *append_file_list_to_list
 //usage:     "\n	-f FILE	Name of TARFILE ('-' for stdin/out)"
 //usage:     "\n	-C DIR	Change to DIR before operation"
 //usage:     "\n	-v	Verbose"
+//usage:     "\n	-O	Extract to stdout"
+//usage:	IF_FEATURE_TAR_NOPRESERVE_TIME(
+//usage:     "\n	-m	Don't restore mtime"
+//usage:	)
+//usage:     "\n	-o	Don't restore user:group"
+///////:-p - accepted but ignored, restores mode (aliases in GNU tar: --preserve-permissions, --same-permissions)
+//usage:     "\n	-k	Don't replace existing files"
 //usage:	IF_FEATURE_SEAMLESS_Z(
 //usage:     "\n	-Z	(De)compress using compress"
 //usage:	)
@@ -791,13 +798,9 @@ static llist_t *append_file_list_to_list
 //usage:	IF_FEATURE_SEAMLESS_LZMA(
 //usage:     "\n	-a	(De)compress using lzma"
 //usage:	)
-//usage:     "\n	-O	Extract to stdout"
 //usage:	IF_FEATURE_TAR_CREATE(
 //usage:     "\n	-h	Follow symlinks"
 //usage:	)
-//usage:	IF_FEATURE_TAR_NOPRESERVE_TIME(
-//usage:     "\n	-m	Don't restore mtime"
-//usage:	)
 //usage:	IF_FEATURE_TAR_FROM(
 //usage:     "\n	-T FILE	File with names to include"
 //usage:     "\n	-X FILE	File with glob patterns to exclude"
@@ -811,9 +814,6 @@ static llist_t *append_file_list_to_list
 //usage:       "$ tar -cf /tmp/tarball.tar /usr/local\n"
 
 // Supported but aren't in --help:
-//	o	no-same-owner
-//	p	same-permissions
-//	k	keep-old
 //	no-recursion
 //	numeric-owner
 //	no-same-permissions
@@ -1244,7 +1244,7 @@ int tar_main(int argc UNUSED_PARAM, char
 	while (get_header_tar(tar_handle) == EXIT_SUCCESS)
 		bb_got_signal = EXIT_SUCCESS; /* saw at least one header, good */
 
-	create_symlinks_from_list(tar_handle->symlink_placeholders);
+	create_links_from_list(tar_handle->link_placeholders);
 
 	/* Check that every file that should have been extracted was */
 	while (tar_handle->accept) {
diff -urpN busybox-1.28.4/archival/unzip.c busybox-1.29.0/archival/unzip.c
--- busybox-1.28.4/archival/unzip.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/archival/unzip.c	2018-07-02 15:55:14.000000000 +0200
@@ -336,7 +336,9 @@ static void unzip_create_leading_dirs(co
 {
 	/* Create all leading directories */
 	char *name = xstrdup(fn);
-	if (bb_make_directory(dirname(name), 0777, FILEUTILS_RECUR)) {
+
+	/* mode of -1: set mode according to umask */
+	if (bb_make_directory(dirname(name), -1, FILEUTILS_RECUR)) {
 		xfunc_die(); /* bb_make_directory is noisy */
 	}
 	free(name);
@@ -370,9 +372,10 @@ static void unzip_extract_symlink(llist_
 		target[xstate.mem_output_size] = '\0';
 #endif
 	}
-	create_or_remember_symlink(symlink_placeholders,
+	create_or_remember_link(symlink_placeholders,
 			target,
-			dst_fn);
+			dst_fn,
+			0);
 	free(target);
 }
 #endif
@@ -988,7 +991,7 @@ int unzip_main(int argc, char **argv)
 	}
 
 #if ENABLE_FEATURE_UNZIP_CDF
-	create_symlinks_from_list(symlink_placeholders);
+	create_links_from_list(symlink_placeholders);
 #endif
 
 	if ((opts & OPT_l) && quiet <= 1) {
diff -urpN busybox-1.28.4/console-tools/Config.src busybox-1.29.0/console-tools/Config.src
--- busybox-1.28.4/console-tools/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/console-tools/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Console Utilities"
diff -urpN busybox-1.28.4/console-tools/setlogcons.c busybox-1.29.0/console-tools/setlogcons.c
--- busybox-1.28.4/console-tools/setlogcons.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/console-tools/setlogcons.c	2018-07-02 15:55:14.000000000 +0200
@@ -41,6 +41,7 @@
 int setlogcons_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int setlogcons_main(int argc UNUSED_PARAM, char **argv)
 {
+	char *devname;
 	struct {
 		char fn;
 		char subarg;
@@ -52,7 +53,14 @@ int setlogcons_main(int argc UNUSED_PARA
 	if (argv[1])
 		arg.subarg = xatou_range(argv[1], 0, 63);
 
-	xioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg);
+	/* Can just call it on "/dev/tty1" always, but...
+	 * in my testing, inactive (never opened) VTs are not
+	 * redirected to, despite ioctl not failing.
+	 *
+	 * By using "/dev/ttyN", ensure it is activated.
+	 */
+	devname = xasprintf("/dev/tty%u", arg.subarg);
+	xioctl(xopen(devname, O_RDONLY), TIOCLINUX, &arg);
 
 	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.28.4/coreutils/Config.src busybox-1.29.0/coreutils/Config.src
--- busybox-1.28.4/coreutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/coreutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Coreutils"
diff -urpN busybox-1.28.4/coreutils/cat.c busybox-1.29.0/coreutils/cat.c
--- busybox-1.28.4/coreutils/cat.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/coreutils/cat.c	2018-07-02 15:55:14.000000000 +0200
@@ -112,10 +112,10 @@ static int catv(unsigned opts, char **ar
 	int retval = EXIT_SUCCESS;
 	int fd;
 #if ENABLE_FEATURE_CATN
-	unsigned lineno = 0;
-	unsigned eol_char = (opts & (CAT_OPT_n|CAT_OPT_b)) ? '\n' : 0x100;
+	bool eol_seen = (opts & (CAT_OPT_n|CAT_OPT_b));
+	unsigned eol_char = (eol_seen ? '\n' : 0x100);
 	unsigned skip_num_on = (opts & CAT_OPT_b) ? '\n' : 0x100;
-	bool eol_seen = 1;
+	unsigned lineno = 0;
 #endif
 
 	BUILD_BUG_ON(CAT_OPT_e != VISIBLE_ENDLINE);
diff -urpN busybox-1.28.4/coreutils/cksum.c busybox-1.29.0/coreutils/cksum.c
--- busybox-1.28.4/coreutils/cksum.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/cksum.c	2018-07-02 15:55:14.000000000 +0200
@@ -31,9 +31,6 @@ int cksum_main(int argc, char **argv) MA
 int cksum_main(int argc UNUSED_PARAM, char **argv)
 {
 	uint32_t *crc32_table = crc32_filltable(NULL, 1);
-	uint32_t crc;
-	off_t length, filesize;
-	int bytes_read;
 	int exit_code = EXIT_SUCCESS;
 
 #if ENABLE_DESKTOP
@@ -45,38 +42,42 @@ int cksum_main(int argc UNUSED_PARAM, ch
 
 	setup_common_bufsiz();
 	do {
+		uint32_t crc;
+		off_t filesize;
 		int fd = open_or_warn_stdin(*argv ? *argv : bb_msg_standard_input);
 
 		if (fd < 0) {
 			exit_code = EXIT_FAILURE;
 			continue;
 		}
-		crc = 0;
-		length = 0;
 
+		crc = 0;
+		filesize = 0;
 #define read_buf bb_common_bufsiz1
-		while ((bytes_read = safe_read(fd, read_buf, COMMON_BUFSIZE)) > 0) {
-			length += bytes_read;
+		for (;;) {
+			uoff_t t;
+			int bytes_read = safe_read(fd, read_buf, COMMON_BUFSIZE);
+			if (bytes_read > 0) {
+				filesize += bytes_read;
+			} else {
+				/* Checksum filesize bytes, LSB first, and exit */
+				close(fd);
+				fd = -1; /* break flag */
+				t = filesize;
+				bytes_read = 0;
+				while (t != 0) {
+					read_buf[bytes_read++] = (uint8_t)t;
+					t >>= 8;
+				}
+			}
 			crc = crc32_block_endian1(crc, read_buf, bytes_read, crc32_table);
+			if (fd < 0)
+				break;
 		}
-		close(fd);
-
-		filesize = length;
 
-		while (length) {
-			crc = (crc << 8) ^ crc32_table[(uint8_t)(crc >> 24) ^ (uint8_t)length];
-			/* must ensure that shift is unsigned! */
-			if (sizeof(length) <= sizeof(unsigned))
-				length = (unsigned)length >> 8;
-			else if (sizeof(length) <= sizeof(unsigned long))
-				length = (unsigned long)length >> 8;
-			else
-				length = (unsigned long long)length >> 8;
-		}
 		crc = ~crc;
-
-		printf((*argv ? "%"PRIu32" %"OFF_FMT"i %s\n" : "%"PRIu32" %"OFF_FMT"i\n"),
-				crc, filesize, *argv);
+		printf((*argv ? "%u %"OFF_FMT"u %s\n" : "%u %"OFF_FMT"u\n"),
+				(unsigned)crc, filesize, *argv);
 	} while (*argv && *++argv);
 
 	fflush_stdout_and_exit(exit_code);
diff -urpN busybox-1.28.4/coreutils/cp.c busybox-1.29.0/coreutils/cp.c
--- busybox-1.28.4/coreutils/cp.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/cp.c	2018-07-02 15:55:14.000000000 +0200
@@ -26,6 +26,7 @@
 //config:	Also add support for --parents option.
 
 //applet:IF_CP(APPLET_NOEXEC(cp, cp, BB_DIR_BIN, BB_SUID_DROP, cp))
+/* NOEXEC despite cases when it can be a "runner" (cp -r LARGE_DIR NEW_DIR) */
 
 //kbuild:lib-$(CONFIG_CP) += cp.o
 
diff -urpN busybox-1.28.4/coreutils/dd.c busybox-1.29.0/coreutils/dd.c
--- busybox-1.28.4/coreutils/dd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/dd.c	2018-07-02 15:55:14.000000000 +0200
@@ -37,7 +37,7 @@
 //config:	elapsed time and speed.
 //config:
 //config:config FEATURE_DD_IBS_OBS
-//config:	bool "Enable ibs, obs and conv options"
+//config:	bool "Enable ibs, obs, iflag and conv options"
 //config:	default y
 //config:	depends on DD
 //config:	help
@@ -57,7 +57,7 @@
 
 //usage:#define dd_trivial_usage
 //usage:       "[if=FILE] [of=FILE] " IF_FEATURE_DD_IBS_OBS("[ibs=N] [obs=N] ") "[bs=N] [count=N] [skip=N]\n"
-//usage:       "	[seek=N]" IF_FEATURE_DD_IBS_OBS(" [conv=notrunc|noerror|sync|fsync] [iflag=skip_bytes]")
+//usage:       "	[seek=N]" IF_FEATURE_DD_IBS_OBS(" [conv=notrunc|noerror|sync|fsync] [iflag=skip_bytes|fullblock]")
 //usage:#define dd_full_usage "\n\n"
 //usage:       "Copy a file with converting and formatting\n"
 //usage:     "\n	if=FILE		Read from FILE instead of stdin"
@@ -79,6 +79,7 @@
 //usage:     "\n	conv=fsync	Physically write data out before finishing"
 //usage:     "\n	conv=swab	Swap every pair of bytes"
 //usage:     "\n	iflag=skip_bytes	skip=N is in bytes"
+//usage:     "\n	iflag=fullblock	Read full blocks"
 //usage:	)
 //usage:	IF_FEATURE_DD_STATUS(
 //usage:     "\n	status=noxfer	Suppress rate output"
@@ -130,11 +131,12 @@ enum {
 	/* start of input flags */
 	FLAG_IFLAG_SHIFT = 5,
 	FLAG_SKIP_BYTES = (1 << 5) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_FULLBLOCK = (1 << 6) * ENABLE_FEATURE_DD_IBS_OBS,
 	/* end of input flags */
-	FLAG_TWOBUFS = (1 << 6) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_COUNT   = 1 << 7,
-	FLAG_STATUS_NONE = 1 << 8,
-	FLAG_STATUS_NOXFER = 1 << 9,
+	FLAG_TWOBUFS = (1 << 7) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_COUNT   = 1 << 8,
+	FLAG_STATUS_NONE = 1 << 9,
+	FLAG_STATUS_NOXFER = 1 << 10,
 };
 
 static void dd_output_status(int UNUSED_PARAM cur_signal)
@@ -195,14 +197,18 @@ static bool write_and_stats(const void *
 	ssize_t n = full_write_or_warn(buf, len, filename);
 	if (n < 0)
 		return 1;
-	if ((size_t)n == obs)
-		G.out_full++;
-	else if (n) /* > 0 */
-		G.out_part++;
 #if ENABLE_FEATURE_DD_THIRD_STATUS_LINE
 	G.total_bytes += n;
 #endif
-	return 0;
+	if ((size_t)n == obs) {
+		G.out_full++;
+		return 0;
+	}
+	if ((size_t)n == len) {
+		G.out_part++;
+		return 0;
+	}
+	return 1;
 }
 
 #if ENABLE_LFS
@@ -251,7 +257,7 @@ int dd_main(int argc UNUSED_PARAM, char
 	static const char conv_words[] ALIGN1 =
 		"notrunc\0""sync\0""noerror\0""fsync\0""swab\0";
 	static const char iflag_words[] ALIGN1 =
-		"skip_bytes\0";
+		"skip_bytes\0""fullblock\0";
 #endif
 #if ENABLE_FEATURE_DD_STATUS
 	static const char status_words[] ALIGN1 =
@@ -290,6 +296,7 @@ int dd_main(int argc UNUSED_PARAM, char
 	/* Partially implemented: */
 	//swab          swap every pair of input bytes: will abort on non-even reads
 		OP_iflag_skip_bytes,
+		OP_iflag_fullblock,
 #endif
 	};
 	smallint exitcode = EXIT_FAILURE;
@@ -450,7 +457,13 @@ int dd_main(int argc UNUSED_PARAM, char
 		size_t blocksz = (G.flags & FLAG_SKIP_BYTES) ? 1 : ibs;
 		if (lseek(ifd, skip * blocksz, SEEK_CUR) < 0) {
 			do {
-				ssize_t n = safe_read(ifd, ibuf, blocksz);
+				ssize_t n;
+#if ENABLE_FEATURE_DD_IBS_OBS
+				if (G.flags & FLAG_FULLBLOCK)
+					n = full_read(ifd, ibuf, blocksz);
+				else
+#endif
+					n = safe_read(ifd, ibuf, blocksz);
 				if (n < 0)
 					goto die_infile;
 				if (n == 0)
@@ -465,8 +478,12 @@ int dd_main(int argc UNUSED_PARAM, char
 
 	while (!(G.flags & FLAG_COUNT) || (G.in_full + G.in_part != count)) {
 		ssize_t n;
-
-		n = safe_read(ifd, ibuf, ibs);
+#if ENABLE_FEATURE_DD_IBS_OBS
+		if (G.flags & FLAG_FULLBLOCK)
+			n = full_read(ifd, ibuf, ibs);
+		else
+#endif
+			n = safe_read(ifd, ibuf, ibs);
 		if (n == 0)
 			break;
 		if (n < 0) {
diff -urpN busybox-1.28.4/coreutils/df.c busybox-1.29.0/coreutils/df.c
--- busybox-1.28.4/coreutils/df.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/df.c	2018-07-02 15:55:14.000000000 +0200
@@ -91,8 +91,6 @@ static unsigned long kscale(unsigned lon
 int df_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int df_main(int argc UNUSED_PARAM, char **argv)
 {
-	unsigned long blocks_used;
-	unsigned blocks_percent_used;
 	unsigned long df_disp_hr = 1024;
 	int status = EXIT_SUCCESS;
 	unsigned opt;
@@ -208,6 +206,11 @@ int df_main(int argc UNUSED_PARAM, char
 		}
 
 		device = mount_entry->mnt_fsname;
+
+		/* GNU coreutils 6.10 skips certain mounts, try to be compatible */
+		if (ENABLE_FEATURE_SKIP_ROOTFS && strcmp(device, "rootfs") == 0)
+			continue;
+
 		mount_point = mount_entry->mnt_dir;
 		fs_type = mount_entry->mnt_type;
 
@@ -222,26 +225,31 @@ int df_main(int argc UNUSED_PARAM, char
 			s.f_frsize = s.f_bsize;
 
 		if ((s.f_blocks > 0) || !mount_table || (opt & OPT_ALL)) {
+			unsigned long long blocks_used;
+			unsigned long long blocks_total;
+			unsigned blocks_percent_used;
+
 			if (opt & OPT_INODE) {
 				s.f_blocks = s.f_files;
 				s.f_bavail = s.f_bfree = s.f_ffree;
 				s.f_frsize = 1;
-
 				if (df_disp_hr)
 					df_disp_hr = 1;
 			}
 			blocks_used = s.f_blocks - s.f_bfree;
-			blocks_percent_used = 0;
-			if (blocks_used + s.f_bavail) {
-				blocks_percent_used = (blocks_used * 100ULL
-						+ (blocks_used + s.f_bavail)/2
-						) / (blocks_used + s.f_bavail);
+			blocks_total = blocks_used + s.f_bavail;
+			blocks_percent_used = blocks_total; /* 0% if blocks_total == 0, else... */
+			if (blocks_total != 0) {
+				/* Downscale sizes for narrower division */
+				unsigned u;
+				while (blocks_total >= INT_MAX / 101) {
+					blocks_total >>= 1;
+					blocks_used >>= 1;
+				}
+				u = (unsigned)blocks_used * 100u + (unsigned)blocks_total / 2;
+				blocks_percent_used = u / (unsigned)blocks_total;
 			}
 
-			/* GNU coreutils 6.10 skips certain mounts, try to be compatible.  */
-			if (ENABLE_FEATURE_SKIP_ROOTFS && strcmp(device, "rootfs") == 0)
-				continue;
-
 #ifdef WHY_WE_DO_IT_FOR_DEV_ROOT_ONLY
 			if (strcmp(device, "/dev/root") == 0) {
 				/* Adjusts device to be the real root device,
diff -urpN busybox-1.28.4/coreutils/install.c busybox-1.29.0/coreutils/install.c
--- busybox-1.28.4/coreutils/install.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/coreutils/install.c	2018-07-02 15:55:14.000000000 +0200
@@ -214,7 +214,11 @@ int install_main(int argc, char **argv)
 			dest = last;
 			if (opts & OPT_MKDIR_LEADING) {
 				char *ddir = xstrdup(dest);
-				bb_make_directory(dirname(ddir), 0755, mkdir_flags);
+				/*
+				 * -D -t DIR1/DIR2/F3 FILE: create DIR1/DIR2/F3, copy FILE there
+				 * -D FILE DIR1/DIR2/F3: create DIR1/DIR2, copy FILE there as F3
+				 */
+				bb_make_directory((opts & OPT_TARGET) ? ddir : dirname(ddir), 0755, mkdir_flags);
 				/* errors are not checked. copy_file
 				 * will fail if dir is not created.
 				 */
diff -urpN busybox-1.28.4/coreutils/md5_sha1_sum.c busybox-1.29.0/coreutils/md5_sha1_sum.c
--- busybox-1.28.4/coreutils/md5_sha1_sum.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/md5_sha1_sum.c	2018-07-02 15:55:14.000000000 +0200
@@ -9,7 +9,7 @@
 //config:	bool "md5sum (6.8 kb)"
 //config:	default y
 //config:	help
-//config:	md5sum is used to print or check MD5 checksums.
+//config:	Compute and check MD5 message digest
 //config:
 //config:config SHA1SUM
 //config:	bool "sha1sum (6 kb)"
diff -urpN busybox-1.28.4/coreutils/mknod.c busybox-1.29.0/coreutils/mknod.c
--- busybox-1.28.4/coreutils/mknod.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/mknod.c	2018-07-02 15:55:14.000000000 +0200
@@ -20,7 +20,7 @@
 /* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
 
 //usage:#define mknod_trivial_usage
-//usage:       "[-m MODE] " IF_SELINUX("[-Z] ") "NAME TYPE MAJOR MINOR"
+//usage:       "[-m MODE] " IF_SELINUX("[-Z] ") "NAME TYPE [MAJOR MINOR]"
 //usage:#define mknod_full_usage "\n\n"
 //usage:       "Create a special file (block, character, or pipe)\n"
 //usage:     "\n	-m MODE	Creation mode (default a=rw)"
@@ -30,7 +30,7 @@
 //usage:     "\nTYPE:"
 //usage:     "\n	b	Block device"
 //usage:     "\n	c or u	Character device"
-//usage:     "\n	p	Named pipe (MAJOR and MINOR are ignored)"
+//usage:     "\n	p	Named pipe (MAJOR MINOR must be omitted)"
 //usage:
 //usage:#define mknod_example_usage
 //usage:       "$ mknod /dev/fd0 b 2 0\n"
@@ -47,40 +47,40 @@ static const char modes_chars[] ALIGN1 =
 static const mode_t modes_cubp[] = { S_IFIFO, S_IFCHR, S_IFBLK };
 
 int mknod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int mknod_main(int argc, char **argv)
+int mknod_main(int argc UNUSED_PARAM, char **argv)
 {
 	mode_t mode;
 	dev_t dev;
-	const char *name;
+	const char *type, *arg;
 
 	mode = getopt_mk_fifo_nod(argv);
 	argv += optind;
-	argc -= optind;
+	//argc -= optind;
 
-	if (argc >= 2) {
-		name = strchr(modes_chars, argv[1][0]);
-		if (name != NULL) {
-			mode |= modes_cubp[(int)(name[4])];
-
-			dev = 0;
-			if (*name != 'p') {
-				argc -= 2;
-				if (argc == 2) {
-					/* Autodetect what the system supports; these macros should
-					 * optimize out to two constants. */
-					dev = makedev(xatoul_range(argv[2], 0, major(UINT_MAX)),
-							xatoul_range(argv[3], 0, minor(UINT_MAX)));
-				}
-			}
-
-			if (argc == 2) {
-				name = *argv;
-				if (mknod(name, mode, dev) == 0) {
-					return EXIT_SUCCESS;
-				}
-				bb_simple_perror_msg_and_die(name);
-			}
-		}
+	if (!argv[0] || !argv[1])
+		bb_show_usage();
+	type = strchr(modes_chars, argv[1][0]);
+	if (!type)
+		bb_show_usage();
+
+	mode |= modes_cubp[(int)(type[4])];
+
+	dev = 0;
+	arg = argv[2];
+	if (*type != 'p') {
+		if (!argv[2] || !argv[3])
+			bb_show_usage();
+		/* Autodetect what the system supports; these macros should
+		 * optimize out to two constants. */
+		dev = makedev(xatoul_range(argv[2], 0, major(UINT_MAX)),
+				xatoul_range(argv[3], 0, minor(UINT_MAX)));
+		arg = argv[4];
 	}
-	bb_show_usage();
+	if (arg)
+		bb_show_usage();
+
+	if (mknod(argv[0], mode, dev) != 0) {
+		bb_simple_perror_msg_and_die(argv[0]);
+	}
+	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.28.4/coreutils/mv.c busybox-1.29.0/coreutils/mv.c
--- busybox-1.28.4/coreutils/mv.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/mv.c	2018-07-02 15:55:14.000000000 +0200
@@ -17,7 +17,8 @@
 //config:	help
 //config:	mv is used to move or rename files or directories.
 
-//applet:IF_MV(APPLET(mv, BB_DIR_BIN, BB_SUID_DROP))
+//applet:IF_MV(APPLET_NOEXEC(mv, mv, BB_DIR_BIN, BB_SUID_DROP, mv))
+/* NOEXEC despite cases when it can be a "runner" (mv LARGE_DIR OTHER_FS) */
 
 //kbuild:lib-$(CONFIG_MV) += mv.o
 
@@ -100,7 +101,7 @@ int mv_main(int argc, char **argv)
 				if (fprintf(stderr, "mv: overwrite '%s'? ", dest) < 0) {
 					goto RET_1;  /* Ouch! fprintf failed! */
 				}
-				if (!bb_ask_confirmation()) {
+				if (!bb_ask_y_confirmation()) {
 					goto RET_0;
 				}
 			}
diff -urpN busybox-1.28.4/coreutils/nice.c busybox-1.29.0/coreutils/nice.c
--- busybox-1.28.4/coreutils/nice.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/nice.c	2018-07-02 15:55:14.000000000 +0200
@@ -22,11 +22,10 @@
 //usage:       "Change scheduling priority, run PROG\n"
 //usage:     "\n	-n ADJUST	Adjust priority by ADJUST"
 
-#include <sys/resource.h>
 #include "libbb.h"
 
 int nice_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int nice_main(int argc, char **argv)
+int nice_main(int argc UNUSED_PARAM, char **argv)
 {
 	int old_priority, adjustment;
 
@@ -40,18 +39,21 @@ int nice_main(int argc, char **argv)
 	adjustment = 10;  /* Set default adjustment. */
 
 	if (argv[0][0] == '-') {
-		if (argv[0][1] == 'n') { /* -n */
-			if (argv[0][2]) { /* -nNNNN (w/o space) */
-				argv[0] += 2; argv--; argc++;
+		char *nnn = argv[0] + 1;
+		if (nnn[0] == 'n') { /* -n */
+			nnn += 1;
+			if (!nnn[0]) { /* "-n NNN" */
+				nnn = *++argv;
 			}
-		} else { /* -NNN (NNN may be negative) == -n NNN */
-			argv[0] += 1; argv--; argc++;
+			/* else: "-nNNN" (w/o space) */
 		}
-		if (argc < 4) {  /* Missing priority and/or utility! */
+		/* else: "-NNN" (NNN may be negative) - same as "-n NNN" */
+
+		if (!nnn || !argv[1]) {  /* Missing priority or PROG! */
 			bb_show_usage();
 		}
-		adjustment = xatoi_range(argv[1], INT_MIN/2, INT_MAX/2);
-		argv += 2;
+		adjustment = xatoi_range(nnn, INT_MIN/2, INT_MAX/2);
+		argv++;
 	}
 
 	{  /* Set our priority. */
diff -urpN busybox-1.28.4/coreutils/od_bloaty.c busybox-1.29.0/coreutils/od_bloaty.c
--- busybox-1.28.4/coreutils/od_bloaty.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/od_bloaty.c	2018-07-02 15:55:14.000000000 +0200
@@ -211,7 +211,14 @@ struct globals {
 
 	bool not_first;
 	bool prev_pair_equal;
+
+	char address_fmt[sizeof("%0n"OFF_FMT"xc")];
 } FIX_ALIASING;
+/* Corresponds to 'x' above */
+#define address_base_char G.address_fmt[sizeof(G.address_fmt)-3]
+/* Corresponds to 'n' above */
+#define address_pad_len_char G.address_fmt[2]
+
 #if !ENABLE_LONG_OPTS
 enum { G_pseudo_offset = 0 };
 #endif
@@ -220,6 +227,7 @@ enum { G_pseudo_offset = 0 };
 	setup_common_bufsiz(); \
 	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 	G.bytes_per_block = 32; \
+	strcpy(G.address_fmt, "%0n"OFF_FMT"xc"); \
 } while (0)
 
 
@@ -844,18 +852,12 @@ format_address_none(off_t address UNUSED
 {
 }
 
-static char address_fmt[] ALIGN1 = "%0n"OFF_FMT"xc";
-/* Corresponds to 'x' above */
-#define address_base_char address_fmt[sizeof(address_fmt)-3]
-/* Corresponds to 'n' above */
-#define address_pad_len_char address_fmt[2]
-
 static void
 format_address_std(off_t address, char c)
 {
 	/* Corresponds to 'c' */
-	address_fmt[sizeof(address_fmt)-2] = c;
-	printf(address_fmt, address);
+	G.address_fmt[sizeof(G.address_fmt)-2] = c;
+	printf(G.address_fmt, address);
 }
 
 #if ENABLE_LONG_OPTS
@@ -1371,9 +1373,13 @@ int od_main(int argc UNUSED_PARAM, char
 	}
 
 #ifdef DEBUG
-	for (i = 0; i < G.n_specs; i++) {
-		printf("%d: fmt=\"%s\" width=%d\n",
-			i, spec[i].fmt_string, width_bytes[spec[i].size]);
+	{
+		int i;
+		for (i = 0; i < G.n_specs; i++) {
+			printf("%d: fmt='%s' width=%d\n",
+				i, G.spec[i].fmt_string,
+				width_bytes[G.spec[i].size]);
+		}
 	}
 #endif
 
diff -urpN busybox-1.28.4/coreutils/readlink.c busybox-1.29.0/coreutils/readlink.c
--- busybox-1.28.4/coreutils/readlink.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/coreutils/readlink.c	2018-07-02 15:55:14.000000000 +0200
@@ -86,7 +86,7 @@ int readlink_main(int argc UNUSED_PARAM,
 
 	/* NOFORK: only one alloc is allowed; must free */
 	if (opt & 1) { /* -f */
-		buf = xmalloc_realpath(fname);
+		buf = xmalloc_realpath_coreutils(fname);
 	} else {
 		buf = xmalloc_readlink_or_warn(fname);
 	}
diff -urpN busybox-1.28.4/coreutils/realpath.c busybox-1.29.0/coreutils/realpath.c
--- busybox-1.28.4/coreutils/realpath.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/coreutils/realpath.c	2018-07-02 15:55:14.000000000 +0200
@@ -38,7 +38,7 @@ int realpath_main(int argc UNUSED_PARAM,
 
 	do {
 		/* NOFORK: only one alloc is allowed; must free */
-		char *resolved_path = xmalloc_realpath(*argv);
+		char *resolved_path = xmalloc_realpath_coreutils(*argv);
 		if (resolved_path != NULL) {
 			puts(resolved_path);
 			free(resolved_path);
diff -urpN busybox-1.28.4/coreutils/sort.c busybox-1.29.0/coreutils/sort.c
--- busybox-1.28.4/coreutils/sort.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/sort.c	2018-07-02 15:55:14.000000000 +0200
@@ -18,16 +18,24 @@
 //config:	sort is used to sort lines of text in specified files.
 //config:
 //config:config FEATURE_SORT_BIG
-//config:	bool "Full SuSv3 compliant sort (support -ktcsbdfiozgM)"
+//config:	bool "Full SuSv3 compliant sort (support -ktcbdfiogM)"
 //config:	default y
 //config:	depends on SORT
 //config:	help
-//config:	Without this, sort only supports -r, -u, and an integer version
+//config:	Without this, sort only supports -rusz, and an integer version
 //config:	of -n. Selecting this adds sort keys, floating point support, and
 //config:	more. This adds a little over 3k to a nonstatic build on x86.
 //config:
 //config:	The SuSv3 sort standard is available at:
 //config:	http://www.opengroup.org/onlinepubs/007904975/utilities/sort.html
+//config:
+//config:config FEATURE_SORT_OPTIMIZE_MEMORY
+//config:	bool "Use less memory (but might be slower)"
+//config:	default n   # defaults to N since we are size-paranoid tribe
+//config:	depends on SORT
+//config:	help
+//config:	Attempt to use less memory (by storing only one copy
+//config:	of duplicated lines, and such). Useful if you work on huge files.
 
 //applet:IF_SORT(APPLET_NOEXEC(sort, sort, BB_DIR_USR_BIN, BB_SUID_DROP, sort))
 
@@ -46,26 +54,22 @@
 //usage:     "\n	-f	Ignore case"
 //usage:     "\n	-i	Ignore unprintable characters"
 //usage:     "\n	-d	Dictionary order (blank or alphanumeric only)"
-//usage:     "\n	-g	General numerical sort"
-//usage:     "\n	-M	Sort month"
 //usage:	)
 //-h, --human-numeric-sort: compare human readable numbers (e.g., 2K 1G)
 //usage:     "\n	-n	Sort numbers"
 //usage:	IF_FEATURE_SORT_BIG(
+//usage:     "\n	-g	General numerical sort"
+//usage:     "\n	-M	Sort month"
 //usage:     "\n	-t CHAR	Field separator"
 //usage:     "\n	-k N[,M] Sort by Nth field"
 //usage:	)
 //usage:     "\n	-r	Reverse sort order"
-//usage:	IF_FEATURE_SORT_BIG(
 //usage:     "\n	-s	Stable (don't sort ties alphabetically)"
-//usage:	)
 //usage:     "\n	-u	Suppress duplicate lines"
-//usage:	IF_FEATURE_SORT_BIG(
 //usage:     "\n	-z	Lines are terminated by NUL, not newline"
-////usage:     "\n	-m	Ignored for GNU compatibility"
-////usage:     "\n	-S BUFSZ Ignored for GNU compatibility"
-////usage:     "\n	-T TMPDIR Ignored for GNU compatibility"
-//usage:	)
+///////:     "\n	-m	Ignored for GNU compatibility"
+///////:     "\n	-S BUFSZ Ignored for GNU compatibility"
+///////:     "\n	-T TMPDIR Ignored for GNU compatibility"
 //usage:
 //usage:#define sort_example_usage
 //usage:       "$ echo -e \"e\\nf\\nb\\nd\\nc\\na\" | sort\n"
@@ -85,16 +89,7 @@
 
 #include "libbb.h"
 
-/* This is a NOEXEC applet. Be very careful! */
-
-
-/*
-	sort [-m][-o output][-bdfinru][-t char][-k keydef]... [file...]
-	sort -c [-bdfinru][-t char][-k keydef][file]
-*/
-
 /* These are sort types */
-#define OPT_STR "ngMucszbrdfimS:T:o:k:*t:"
 enum {
 	FLAG_n  = 1,            /* Numeric sort */
 	FLAG_g  = 2,            /* Sort using strtod() */
@@ -117,8 +112,18 @@ enum {
 	FLAG_k  = 0x10000,
 	FLAG_t  = 0x20000,
 	FLAG_bb = 0x80000000,   /* Ignore trailing blanks  */
+	FLAG_no_tie_break = 0x40000000,
 };
 
+static const char sort_opt_str[] ALIGN1 = "^"
+			"ngMucszbrdfimS:T:o:k:*t:"
+			"\0" "o--o:t--t"/*-t, -o: at most one of each*/;
+/*
+ * OPT_STR must not be string literal, needs to have stable address:
+ * code uses "strchr(OPT_STR,c) - OPT_STR" idiom.
+ */
+#define OPT_STR (sort_opt_str + 1)
+
 #if ENABLE_FEATURE_SORT_BIG
 static char key_separator;
 
@@ -128,6 +133,10 @@ static struct sort_key {
 	unsigned flags;
 } *key_list;
 
+
+/* This is a NOEXEC applet. Be very careful! */
+
+
 static char *get_key(char *str, struct sort_key *key, int flags)
 {
 	int start = start; /* for compiler */
@@ -340,10 +349,35 @@ static int compare_keys(const void *xarg
 #endif
 	} /* for */
 
-	/* Perform fallback sort if necessary */
-	if (!retval && !(option_mask32 & FLAG_s)) {
-		flags = option_mask32;
-		retval = strcmp(*(char **)xarg, *(char **)yarg);
+	if (retval == 0) {
+		/* So far lines are "the same" */
+
+		if (option_mask32 & FLAG_s) {
+			/* "Stable sort": later line is "greater than",
+			 * IOW: do not allow qsort() to swap equal lines.
+			 */
+			uint32_t *p32;
+			uint32_t x32, y32;
+			char *line;
+			unsigned len;
+
+			line = *(char**)xarg;
+			len = (strlen(line) + 4) & (~3u);
+			p32 = (void*)(line + len);
+			x32 = *p32;
+			line = *(char**)yarg;
+			len = (strlen(line) + 4) & (~3u);
+			p32 = (void*)(line + len);
+			y32 = *p32;
+
+			/* If x > y, 1, else -1 */
+			retval = (x32 > y32) * 2 - 1;
+		} else
+		if (!(option_mask32 & FLAG_no_tie_break)) {
+			/* fallback sort */
+			flags = option_mask32;
+			retval = strcmp(*(char **)xarg, *(char **)yarg);
+		}
 	}
 
 	if (flags & FLAG_r)
@@ -368,21 +402,52 @@ static unsigned str2u(char **str)
 int sort_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int sort_main(int argc UNUSED_PARAM, char **argv)
 {
-	char *line, **lines;
+	char **lines;
 	char *str_ignored, *str_o, *str_t;
 	llist_t *lst_k = NULL;
 	int i;
 	int linecount;
 	unsigned opts;
+#if ENABLE_FEATURE_SORT_OPTIMIZE_MEMORY
+	bool can_drop_dups;
+	size_t prev_len = 0;
+	char *prev_line = (char*) "";
+	/* Postpone optimizing if the input is small, < 16k lines:
+	 * even just free()ing duplicate lines takes time.
+	 */
+	size_t count_to_optimize_dups = 0x3fff;
+#endif
 
 	xfunc_error_retval = 2;
 
 	/* Parse command line options */
-	opts = getopt32(argv, "^"
-			OPT_STR
-			"\0" "o--o:t--t"/*-t, -o: at most one of each*/,
+	opts = getopt32(argv,
+			sort_opt_str,
 			&str_ignored, &str_ignored, &str_o, &lst_k, &str_t
 	);
+#if ENABLE_FEATURE_SORT_OPTIMIZE_MEMORY
+	/* Can drop dups only if -u but no "complicating" options,
+	 * IOW: if we do a full line compares. Safe options:
+	 * -o FILE Output to FILE
+	 * -z	   Lines are terminated by NUL, not newline
+	 * -r	   Reverse sort order
+	 * -s      Stable (don't sort ties alphabetically)
+	 * Not sure about these:
+	 * -b      Ignore leading blanks
+	 * -f	   Ignore case
+	 * -i	   Ignore unprintable characters
+	 * -d	   Dictionary order (blank or alphanumeric only)
+	 * -n	   Sort numbers
+	 * -g	   General numerical sort
+	 * -M	   Sort month
+	 */
+	can_drop_dups = ((opts & ~(FLAG_o|FLAG_z|FLAG_r|FLAG_s)) == FLAG_u);
+	/* Stable sort needs every line to be uniquely allocated,
+	 * disable optimization to reuse strings:
+	 */
+	if (opts & FLAG_s)
+		count_to_optimize_dups = (size_t)-1L;
+#endif
 	/* global b strips leading and trailing spaces */
 	if (opts & FLAG_b)
 		option_mask32 |= FLAG_bb;
@@ -457,9 +522,47 @@ int sort_main(int argc UNUSED_PARAM, cha
 		 * do not continue to next file: */
 		FILE *fp = xfopen_stdin(*argv);
 		for (;;) {
-			line = GET_LINE(fp);
+			char *line = GET_LINE(fp);
 			if (!line)
 				break;
+
+#if ENABLE_FEATURE_SORT_OPTIMIZE_MEMORY
+			if (count_to_optimize_dups != 0)
+				count_to_optimize_dups--;
+			if (count_to_optimize_dups == 0) {
+				size_t len;
+				char *new_line;
+
+				/* On kernel/linux/arch/ *.[ch] files,
+				 * this reduces memory usage by 6%.
+				 *  yes | head -99999999 | sort
+				 * goes down from 1900Mb to 380 Mb.
+				 */
+				len = strlen(line);
+				if (len <= prev_len) {
+					new_line = prev_line + (prev_len - len);
+					if (strcmp(line, new_line) == 0) {
+						/* it's a tail of the prev line */
+						if (can_drop_dups && prev_len == len) {
+							/* it's identical to prev line */
+							free(line);
+							continue;
+						}
+						free(line);
+						line = new_line;
+						/* continue using longer prev_line
+						 * for future tail tests.
+						 */
+						goto skip;
+					}
+				}
+				prev_len = len;
+				prev_line = line;
+ skip: ;
+			}
+#else
+//TODO: lighter version which only drops total dups if can_drop_dups == true
+#endif
 			lines = xrealloc_vector(lines, 6, linecount);
 			lines[linecount++] = line;
 		}
@@ -482,15 +585,35 @@ int sort_main(int argc UNUSED_PARAM, cha
 		return EXIT_SUCCESS;
 	}
 #endif
+
+	/* For stable sort, store original line position beyond terminating NUL */
+	if (option_mask32 & FLAG_s) {
+		for (i = 0; i < linecount; i++) {
+			uint32_t *p32;
+			char *line;
+			unsigned len;
+
+			line = lines[i];
+			len = (strlen(line) + 4) & (~3u);
+			lines[i] = line = xrealloc(line, len + 4);
+			p32 = (void*)(line + len);
+			*p32 = i;
+		}
+		/*option_mask32 |= FLAG_no_tie_break;*/
+		/* ^^^redundant: if FLAG_s, compare_keys() does no tie break */
+	}
+
 	/* Perform the actual sort */
 	qsort(lines, linecount, sizeof(lines[0]), compare_keys);
 
 	/* Handle -u */
 	if (option_mask32 & FLAG_u) {
 		int j = 0;
-		/* coreutils 6.3 drop lines for which only key is the same */
-		/* -- disabling last-resort compare... */
-		option_mask32 |= FLAG_s;
+		/* coreutils 6.3 drop lines for which only key is the same
+		 * -- disabling last-resort compare, or else compare_keys()
+		 * will be the same only for completely identical lines.
+		 */
+		option_mask32 |= FLAG_no_tie_break;
 		for (i = 1; i < linecount; i++) {
 			if (compare_keys(&lines[j], &lines[i]) == 0)
 				free(lines[i]);
diff -urpN busybox-1.28.4/coreutils/stat.c busybox-1.29.0/coreutils/stat.c
--- busybox-1.28.4/coreutils/stat.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/coreutils/stat.c	2018-07-02 15:55:14.000000000 +0200
@@ -212,7 +212,7 @@ static const char *human_fstype(uint32_t
 		{ 0x52654973, "reiserfs" },
 		{ 0x28cd3d45, "cramfs" },
 		{ 0x7275,     "romfs" },
-		{ 0x858458f6, "romfs" },
+		{ 0x858458f6, "ramfs" },
 		{ 0x73717368, "squashfs" },
 		{ 0x62656572, "sysfs" },
 		{ 0, "UNKNOWN" }
diff -urpN busybox-1.28.4/coreutils/test.c busybox-1.29.0/coreutils/test.c
--- busybox-1.28.4/coreutils/test.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/coreutils/test.c	2018-07-02 15:55:14.000000000 +0200
@@ -76,7 +76,6 @@
 //usage:       "1\n"
 
 #include "libbb.h"
-#include <setjmp.h>
 
 /* This is a NOFORK applet. Be very careful! */
 
@@ -314,6 +313,9 @@ static const struct operator_t ops_table
 	{ /* "-L" */ FILSYM  , UNOP   },
 	{ /* "-S" */ FILSOCK , UNOP   },
 	{ /* "="  */ STREQ   , BINOP  },
+	/* "==" is bashism, http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html
+	 * lists only "=" as comparison operator.
+	 */
 	{ /* "==" */ STREQ   , BINOP  },
 	{ /* "!=" */ STRNE   , BINOP  },
 	{ /* "<"  */ STRLT   , BINOP  },
@@ -358,6 +360,7 @@ static const char ops_texts[] ALIGN1 =
 	"-L"  "\0"
 	"-S"  "\0"
 	"="   "\0"
+	/* "==" is bashism */
 	"=="  "\0"
 	"!="  "\0"
 	"<"   "\0"
diff -urpN busybox-1.28.4/debianutils/Config.src busybox-1.29.0/debianutils/Config.src
--- busybox-1.28.4/debianutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/debianutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Debian Utilities"
diff -urpN busybox-1.28.4/debianutils/start_stop_daemon.c busybox-1.29.0/debianutils/start_stop_daemon.c
--- busybox-1.28.4/debianutils/start_stop_daemon.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/debianutils/start_stop_daemon.c	2018-07-02 15:55:14.000000000 +0200
@@ -116,8 +116,6 @@ Misc options:
 //usage:	)
 //usage:     "\n	-q		Quiet"
 
-#include <sys/resource.h>
-
 /* Override ENABLE_FEATURE_PIDFILE */
 #define WANT_PIDFILE 1
 #include "libbb.h"
@@ -159,6 +157,9 @@ struct globals {
 	unsigned execname_sizeof;
 	int user_id;
 	smallint signal_nr;
+#ifdef OLDER_VERSION_OF_X
+	struct stat execstat;
+#endif
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define userspec          (G.userspec            )
@@ -186,13 +187,12 @@ static int pid_is_exec(pid_t pid)
 	sprintf(buf, "/proc/%u/exe", (unsigned)pid);
 	if (stat(buf, &st) < 0)
 		return 0;
-	if (st.st_dev == execstat.st_dev
-	 && st.st_ino == execstat.st_ino)
+	if (st.st_dev == G.execstat.st_dev
+	 && st.st_ino == G.execstat.st_ino)
 		return 1;
 	return 0;
 }
-#endif
-
+#else
 static int pid_is_exec(pid_t pid)
 {
 	ssize_t bytes;
@@ -216,6 +216,7 @@ static int pid_is_exec(pid_t pid)
 	}
 	return 0;
 }
+#endif
 
 static int pid_is_name(pid_t pid)
 {
@@ -410,9 +411,6 @@ int start_stop_daemon_main(int argc UNUS
 	char *signame;
 	char *startas;
 	char *chuid;
-#ifdef OLDER_VERSION_OF_X
-	struct stat execstat;
-#endif
 #if ENABLE_FEATURE_START_STOP_DAEMON_FANCY
 //	char *retry_arg = NULL;
 //	int retries = -1;
@@ -481,7 +479,7 @@ int start_stop_daemon_main(int argc UNUS
 
 #ifdef OLDER_VERSION_OF_X
 	if (execname)
-		xstat(execname, &execstat);
+		xstat(execname, &G.execstat);
 #endif
 
 	*--argv = startas;
diff -urpN busybox-1.28.4/debianutils/which.c busybox-1.29.0/debianutils/which.c
--- busybox-1.28.4/debianutils/which.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/debianutils/which.c	2018-07-02 15:55:14.000000000 +0200
@@ -30,12 +30,15 @@
 int which_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int which_main(int argc UNUSED_PARAM, char **argv)
 {
-	const char *env_path;
+	char *env_path;
 	int status = 0;
+	/* This sizeof(): bb_default_root_path is shorter than BB_PATH_ROOT_PATH */
+	char buf[sizeof(BB_PATH_ROOT_PATH)];
 
 	env_path = getenv("PATH");
 	if (!env_path)
-		env_path = bb_default_root_path;
+		/* env_path must be writable, and must not alloc, so... */
+		env_path = strcpy(buf, bb_default_root_path);
 
 	getopt32(argv, "^" "a" "\0" "-1"/*at least one arg*/);
 	argv += optind;
@@ -51,20 +54,17 @@ int which_main(int argc UNUSED_PARAM, ch
 			}
 		} else {
 			char *path;
-			char *tmp;
 			char *p;
 
-			path = tmp = xstrdup(env_path);
-//NOFORK FIXME: nested xmallocs (one is inside find_executable())
-//can leak memory on failure
-			while ((p = find_executable(*argv, &tmp)) != NULL) {
+			path = env_path;
+			/* NOFORK NB: xmalloc inside find_executable(), must have no allocs above! */
+			while ((p = find_executable(*argv, &path)) != NULL) {
 				missing = 0;
 				puts(p);
 				free(p);
 				if (!option_mask32) /* -a not set */
 					break;
 			}
-			free(path);
 		}
 		status |= missing;
 	} while (*++argv);
diff -urpN busybox-1.28.4/docs/Kconfig-language.txt busybox-1.29.0/docs/Kconfig-language.txt
--- busybox-1.28.4/docs/Kconfig-language.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/docs/Kconfig-language.txt	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,255 @@
+Introduction
+------------
+
+The configuration database is collection of configuration options
+organized in a tree structure:
+
+    +- Code maturity level options
+    |  +- Prompt for development and/or incomplete code/drivers
+    +- General setup
+    |  +- Networking support
+    |  +- System V IPC
+    |  +- BSD Process Accounting
+    |  +- Sysctl support
+    +- Loadable module support
+    |  +- Enable loadable module support
+    |     +- Set version information on all module symbols
+    |     +- Kernel module loader
+    +- ...
+
+Every entry has its own dependencies. These dependencies are used
+to determine the visible of an entry. Any child entry is only
+visible if its parent entry is also visible.
+
+Menu entries
+------------
+
+Most entries define a config option, all other entries help to organize
+them. A single configuration option is defined like this:
+
+config MODVERSIONS
+    bool "Set version information on all module symbols"
+    depends MODULES
+    help
+      Usually, modules have to be recompiled whenever you switch to a new
+      kernel.  ...
+
+Every line starts with a key word and can be followed by multiple
+arguments.  "config" starts a new config entry. The following lines
+define attributes for this config option. Attributes can be the type of
+the config option, input prompt, dependencies, help text and default
+values. A config option can be defined multiple times with the same
+name, but every definition can have only a single input prompt and the
+type must not conflict.
+
+Menu attributes
+---------------
+
+A menu entry can have a number of attributes. Not all of them are
+applicable everywhere (see syntax).
+
+- type definition: "bool"/"tristate"/"string"/"hex"/"integer"
+  Every config option must have a type. There are only two basic types:
+  tristate and string, the other types base on these two. The type
+  definition optionally accepts an input prompt, so these two examples
+  are equivalent:
+
+    bool "Networking support"
+  and
+    bool
+    prompt "Networking support"
+
+- input prompt: "prompt" <prompt> ["if" <expr>]
+  Every menu entry can have at most one prompt, which is used to display
+  to the user. Optionally dependencies only for this prompt can be added
+  with "if".
+
+- default value: "default" <symbol> ["if" <expr>]
+  A config option can have any number of default values. If multiple
+  default values are visible, only the first defined one is active.
+  Default values are not limited to the menu entry, where they are
+  defined, this means the default can be defined somewhere else or be
+  overridden by an earlier definition.
+  The default value is only assigned to the config symbol if no other
+  value was set by the user (via the input prompt above). If an input
+  prompt is visible the default value is presented to the user and can
+  be overridden by him.
+  Optionally dependencies only for this default value can be added with
+  "if".
+
+- dependencies: "depends on"/"requires" <expr>
+  This defines a dependency for this menu entry. If multiple
+  dependencies are defined they are connected with '&&'. Dependencies
+  are applied to all other options within this menu entry (which also
+  accept "if" expression), so these two examples are equivalent:
+
+    bool "foo" if BAR
+    default y if BAR
+  and
+    depends on BAR
+    bool "foo"
+    default y
+
+- help text: "help"
+  This defines a help text. The end of the help text is determined by
+  the level indentation, this means it ends at the first line which has
+  a smaller indentation than the first line of the help text.
+
+
+Menu dependencies
+-----------------
+
+Dependencies define the visibility of a menu entry and can also reduce
+the input range of tristate symbols. The tristate logic used in the
+expressions uses one more state than normal boolean logic to express the
+module state. Dependency expressions have the following syntax:
+
+<expr> ::= <symbol>                             (1)
+           <symbol> '=' <symbol>                (2)
+           <symbol> '!=' <symbol>               (3)
+           '(' <expr> ')'                       (4)
+           '!' <expr>                           (5)
+           <expr> '||' <expr>                   (6)
+           <expr> '&&' <expr>                   (7)
+
+Expressions are listed in decreasing order of precedence.
+
+(1) Convert the symbol into an expression. Boolean and tristate symbols
+    are simply converted into the respective expression values. All
+    other symbol types result in 'n'.
+(2) If the values of both symbols are equal, it returns 'y',
+    otherwise 'n'.
+(3) If the values of both symbols are equal, it returns 'n',
+    otherwise 'y'.
+(4) Returns the value of the expression. Used to override precedence.
+(5) Returns the result of (2-/expr/).
+(6) Returns the result of min(/expr/, /expr/).
+(7) Returns the result of max(/expr/, /expr/).
+
+An expression can have a value of 'n', 'm' or 'y' (or 0, 1, 2
+respectively for calculations). A menu entry becomes visible when it's
+expression evaluates to 'm' or 'y'.
+
+There are two type of symbols: constant and nonconstant symbols.
+Nonconstant symbols are the most common ones and are defined with the
+'config' statement. Nonconstant symbols consist entirely of alphanumeric
+characters or underscores.
+Constant symbols are only part of expressions. Constant symbols are
+always surrounded by single or double quotes. Within the quote any
+other character is allowed and the quotes can be escaped using '\'.
+
+Menu structure
+--------------
+
+The position of a menu entry in the tree is determined in two ways. First
+it can be specified explicitely:
+
+menu "Network device support"
+    depends NET
+
+config NETDEVICES
+    ...
+
+endmenu
+
+All entries within the "menu" ... "endmenu" block become a submenu of
+"Network device support". All subentries inherit the dependencies from
+the menu entry, e.g. this means the dependency "NET" is added to the
+dependency list of the config option NETDEVICES.
+
+The other way to generate the menu structure is done by analyzing the
+dependencies. If a menu entry somehow depends on the previous entry, it
+can be made a submenu of it. First the the previous (parent) symbol must
+be part of the dependency list and then one of these two condititions
+must be true:
+- the child entry must become invisible, if the parent is set to 'n'
+- the child entry must only be visible, if the parent is visible
+
+config MODULES
+    bool "Enable loadable module support"
+
+config MODVERSIONS
+    bool "Set version information on all module symbols"
+    depends MODULES
+
+comment "module support disabled"
+    depends !MODULES
+
+MODVERSIONS directly depends on MODULES, this means it's only visible if
+MODULES is different from 'n'. The comment on the other hand is always
+visible when MODULES it's visible (the (empty) dependency of MODULES is
+also part of the comment dependencies).
+
+
+Kconfig syntax
+--------------
+
+The configuration file describes a series of menu entries, where every
+line starts with a keyword (except help texts). The following keywords
+end a menu entry:
+- config
+- choice/endchoice
+- comment
+- menu/endmenu
+- if/endif
+- source
+The first four also start the definition of a menu entry.
+
+config:
+
+    "config" <symbol>
+    <config options>
+
+This defines a config symbol <symbol> and accepts any of above
+attributes as options.
+
+choices:
+
+    "choice"
+    <choice options>
+    <choice block>
+    "endchoice"
+
+This defines a choice group and accepts any of above attributes as
+options. A choice can only be of type bool or tristate, while a boolean
+choice only allows a single config entry to be selected, a tristate
+choice also allows any number of config entries to be set to 'm'. This
+can be used if multiple drivers for a single hardware exists and only a
+single driver can be compiled/loaded into the kernel, but all drivers
+can be compiled as modules.
+A choice accepts another option "optional", which allows to set the
+choice to 'n' and no entry needs to be selected.
+
+comment:
+
+    "comment" <prompt>
+    <comment options>
+
+This defines a comment which is displayed to the user during the
+configuration process and is also echoed to the output files. The only
+possible options are dependencies.
+
+menu:
+
+    "menu" <prompt>
+    <menu options>
+    <menu block>
+    "endmenu"
+
+This defines a menu block, see "Menu structure" above for more
+information. The only possible options are dependencies.
+
+if:
+
+    "if" <expr>
+    <if block>
+    "endif"
+
+This defines an if block. The dependency expression <expr> is appended
+to all enclosed menu entries.
+
+source:
+
+    "source" <prompt>
+
+This reads the specified configuration file. This file is always parsed.
diff -urpN busybox-1.28.4/docs/posix_conformance.txt busybox-1.29.0/docs/posix_conformance.txt
--- busybox-1.28.4/docs/posix_conformance.txt	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/docs/posix_conformance.txt	2018-07-02 15:55:14.000000000 +0200
@@ -178,9 +178,10 @@ dd POSIX options:
   conv=noerror    |  yes   |           |
   conv=notrunc    |  yes   |           |
   conv=sync       |  yes   |           |
+dd compatibility options:
+  conv=fsync      |  yes   |           |
   iflag=skip_bytes|  yes   |           |
-dd Busybox specific options:
- conv=fsync
+  iflag=fullblock |  yes   |           |
 
 df POSIX options
  option           | exists | compliant | remarks
diff -urpN busybox-1.28.4/e2fsprogs/Config.src busybox-1.29.0/e2fsprogs/Config.src
--- busybox-1.28.4/e2fsprogs/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/e2fsprogs/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Linux Ext2 FS Progs"
diff -urpN busybox-1.28.4/e2fsprogs/fsck.c busybox-1.29.0/e2fsprogs/fsck.c
--- busybox-1.28.4/e2fsprogs/fsck.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/e2fsprogs/fsck.c	2018-07-02 15:55:14.000000000 +0200
@@ -414,7 +414,7 @@ static void kill_all_if_got_signal(void)
 static int wait_one(int flags)
 {
 	int status;
-	int sig;
+	int exitcode;
 	struct fsck_instance *inst, *prev;
 	pid_t pid;
 
@@ -448,15 +448,16 @@ static int wait_one(int flags)
 	}
  child_died:
 
-	status = WEXITSTATUS(status);
+	exitcode = WEXITSTATUS(status);
 	if (WIFSIGNALED(status)) {
+		unsigned sig;
 		sig = WTERMSIG(status);
-		status = EXIT_UNCORRECTED;
+		exitcode = EXIT_UNCORRECTED;
 		if (sig != SIGINT) {
 			printf("Warning: %s %s terminated "
-				"by signal %d\n",
+				"by signal %u\n",
 				inst->prog, inst->device, sig);
-			status = EXIT_ERROR;
+			exitcode = EXIT_ERROR;
 		}
 	}
 
@@ -492,12 +493,12 @@ static int wait_one(int flags)
 	else
 		G.instance_list = inst->next;
 	if (G.verbose > 1)
-		printf("Finished with %s (exit status %d)\n",
-			inst->device, status);
+		printf("Finished with %s (exit status %u)\n",
+			inst->device, exitcode);
 	G.num_running--;
 	free_instance(inst);
 
-	return status;
+	return exitcode;
 }
 
 /*
diff -urpN busybox-1.28.4/editors/Config.src busybox-1.29.0/editors/Config.src
--- busybox-1.28.4/editors/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/editors/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Editors"
diff -urpN busybox-1.28.4/editors/awk.c busybox-1.29.0/editors/awk.c
--- busybox-1.28.4/editors/awk.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/editors/awk.c	2018-07-02 15:55:14.000000000 +0200
@@ -598,6 +598,7 @@ static const char EMSG_NOT_ARRAY[] ALIGN
 static const char EMSG_POSSIBLE_ERROR[] ALIGN1 = "Possible syntax error";
 static const char EMSG_UNDEF_FUNC[] ALIGN1 = "Call to undefined function";
 static const char EMSG_NO_MATH[] ALIGN1 = "Math support is not compiled in";
+static const char EMSG_NEGATIVE_FIELD[] ALIGN1 = "Access to negative field";
 
 static void zero_out_var(var *vp)
 {
@@ -2514,6 +2515,32 @@ static var *evaluate(node *op, var *res)
 		op1 = op->l.n;
 		debug_printf_eval("opinfo:%08x opn:%08x\n", opinfo, opn);
 
+		/* "delete" is special:
+		 * "delete array[var--]" must evaluate index expr only once,
+		 * must not evaluate it in "execute inevitable things" part.
+		 */
+		if (XC(opinfo & OPCLSMASK) == XC(OC_DELETE)) {
+			uint32_t info = op1->info & OPCLSMASK;
+			var *v;
+
+			debug_printf_eval("DELETE\n");
+			if (info == OC_VAR) {
+				v = op1->l.v;
+			} else if (info == OC_FNARG) {
+				v = &fnargs[op1->l.aidx];
+			} else {
+				syntax_error(EMSG_NOT_ARRAY);
+			}
+			if (op1->r.n) { /* array ref? */
+				const char *s;
+				s = getvar_s(evaluate(op1->r.n, v1));
+				hash_remove(iamarray(v), s);
+			} else {
+				clear_array(iamarray(v));
+			}
+			goto next;
+		}
+
 		/* execute inevitable things */
 		if (opinfo & OF_RES1)
 			L.v = evaluate(op1, v1);
@@ -2621,28 +2648,7 @@ static var *evaluate(node *op, var *res)
 			break;
 		}
 
-		case XC( OC_DELETE ): {
-			uint32_t info = op1->info & OPCLSMASK;
-			var *v;
-
-			if (info == OC_VAR) {
-				v = op1->l.v;
-			} else if (info == OC_FNARG) {
-				v = &fnargs[op1->l.aidx];
-			} else {
-				syntax_error(EMSG_NOT_ARRAY);
-			}
-
-			if (op1->r.n) {
-				const char *s;
-				clrvar(L.v);
-				s = getvar_s(evaluate(op1->r.n, v1));
-				hash_remove(iamarray(v), s);
-			} else {
-				clear_array(iamarray(v));
-			}
-			break;
-		}
+		/* case XC( OC_DELETE ): - moved to happen before arg evaluation */
 
 		case XC( OC_NEWSOURCE ):
 			g_progname = op->l.new_progname;
@@ -2666,12 +2672,14 @@ static var *evaluate(node *op, var *res)
 		/* -- recursive node type -- */
 
 		case XC( OC_VAR ):
+			debug_printf_eval("VAR\n");
 			L.v = op->l.v;
 			if (L.v == intvar[NF])
 				split_f0();
 			goto v_cont;
 
 		case XC( OC_FNARG ):
+			debug_printf_eval("FNARG[%d]\n", op->l.aidx);
 			L.v = &fnargs[op->l.aidx];
  v_cont:
 			res = op->r.n ? findvar(iamarray(L.v), R.s) : L.v;
@@ -2942,6 +2950,8 @@ static var *evaluate(node *op, var *res)
 
 		case XC( OC_FIELD ): {
 			int i = (int)getvar_i(R.v);
+			if (i < 0)
+				syntax_error(EMSG_NEGATIVE_FIELD);
 			if (i == 0) {
 				res = intvar[F0];
 			} else {
@@ -3035,7 +3045,8 @@ static var *evaluate(node *op, var *res)
 
 		default:
 			syntax_error(EMSG_POSSIBLE_ERROR);
-		}
+		} /* switch */
+ next:
 		if ((opinfo & OPCLSMASK) <= SHIFT_TIL_THIS)
 			op = op->a.n;
 		if ((opinfo & OPCLSMASK) >= RECUR_FROM_THIS)
@@ -3141,7 +3152,7 @@ static rstream *next_input_file(void)
 }
 
 int awk_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int awk_main(int argc, char **argv)
+int awk_main(int argc UNUSED_PARAM, char **argv)
 {
 	unsigned opt;
 	char *opt_F;
@@ -3210,7 +3221,7 @@ int awk_main(int argc, char **argv)
 	}
 	opt = getopt32(argv, OPTSTR_AWK, &opt_F, &list_v, &list_f, IF_FEATURE_AWK_GNU_EXTENSIONS(&list_e,) NULL);
 	argv += optind;
-	argc -= optind;
+	//argc -= optind;
 	if (opt & OPT_W)
 		bb_error_msg("warning: option -W is ignored");
 	if (opt & OPT_F) {
@@ -3247,15 +3258,14 @@ int awk_main(int argc, char **argv)
 		if (!*argv)
 			bb_show_usage();
 		parse_program(*argv++);
-		argc--;
 	}
 
 	/* fill in ARGV array */
-	setvar_i(intvar[ARGC], argc + 1);
 	setari_u(intvar[ARGV], 0, "awk");
 	i = 0;
 	while (*argv)
 		setari_u(intvar[ARGV], ++i, *argv++);
+	setvar_i(intvar[ARGC], i + 1);
 
 	evaluate(beginseq.first, &tv);
 	if (!mainseq.first && !endseq.first)
diff -urpN busybox-1.28.4/editors/patch.c busybox-1.29.0/editors/patch.c
--- busybox-1.28.4/editors/patch.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/editors/patch.c	2018-07-02 15:55:14.000000000 +0200
@@ -15,7 +15,6 @@
  * -D define wrap #ifdef and #ifndef around changes
  * -o outfile output here instead of in place
  * -r rejectfile write rejected hunks to this file
- * --dry-run (regression!)
  *
  * -f force (no questions asked)
  * -F fuzz (number, default 2)
@@ -34,23 +33,15 @@
 //usage:#define patch_trivial_usage
 //usage:       "[OPTIONS] [ORIGFILE [PATCHFILE]]"
 //usage:#define patch_full_usage "\n\n"
-//usage:	IF_LONG_OPTS(
-//usage:       "	-p,--strip N		Strip N leading components from file names"
-//usage:     "\n	-i,--input DIFF		Read DIFF instead of stdin"
-//usage:     "\n	-R,--reverse		Reverse patch"
-//usage:     "\n	-N,--forward		Ignore already applied patches"
-/*usage:     "\n	--dry-run		Don't actually change files" - TODO */
-//usage:     "\n	-E,--remove-empty-files	Remove output files if they become empty"
-//usage:	)
-//usage:	IF_NOT_LONG_OPTS(
 //usage:       "	-p N	Strip N leading components from file names"
 //usage:     "\n	-i DIFF	Read DIFF instead of stdin"
 //usage:     "\n	-R	Reverse patch"
 //usage:     "\n	-N	Ignore already applied patches"
 //usage:     "\n	-E	Remove output files if they become empty"
+//usage:	IF_LONG_OPTS(
+//usage:     "\n	--dry-run	Don't actually change files"
 //usage:	)
 /* -u "interpret as unified diff" is supported but not documented: this info is not useful for --help */
-/* -x "debug" is supported but does nothing */
 //usage:
 //usage:#define patch_example_usage
 //usage:       "$ patch -p1 < example.diff\n"
@@ -58,6 +49,7 @@
 
 #include "libbb.h"
 
+#define PATCH_DEBUG  0
 
 // libbb candidate?
 
@@ -122,16 +114,18 @@ struct globals {
 } while (0)
 
 
-#define FLAG_STR "Rup:i:NEx"
+#define FLAG_STR "Rup:i:NEfg"
 /* FLAG_REVERSE must be == 1! Code uses this fact. */
-#define FLAG_REVERSE (1 << 0)
-#define FLAG_u       (1 << 1)
-#define FLAG_PATHLEN (1 << 2)
-#define FLAG_INPUT   (1 << 3)
-#define FLAG_IGNORE  (1 << 4)
-#define FLAG_RMEMPTY (1 << 5)
-/* Enable this bit and use -x for debug output: */
-#define FLAG_DEBUG   (0 << 6)
+#define FLAG_REVERSE  (1 << 0)
+#define FLAG_u        (1 << 1)
+#define FLAG_PATHLEN  (1 << 2)
+#define FLAG_INPUT    (1 << 3)
+#define FLAG_IGNORE   (1 << 4)
+#define FLAG_RMEMPTY  (1 << 5)
+#define FLAG_f_unused (1 << 6)
+#define FLAG_g_unused (1 << 7)
+#define FLAG_dry_run  ((1 << 8) * ENABLE_LONG_OPTS)
+
 
 // Dispose of a line of input, either by writing it out or discarding it.
 
@@ -140,8 +134,6 @@ struct globals {
 // state = 3: write whole line to fileout
 // state > 3: write line+1 to fileout when *line != state
 
-#define PATCH_DEBUG (option_mask32 & FLAG_DEBUG)
-
 static void do_line(void *data)
 {
 	struct double_list *dlist = data;
@@ -168,12 +160,14 @@ static void finish_oldfile(void)
 		}
 		xclose(TT.fileout);
 
-		temp = xstrdup(TT.tempname);
-		temp[strlen(temp) - 6] = '\0';
-		rename(TT.tempname, temp);
-		free(temp);
+		if (!ENABLE_LONG_OPTS || TT.tempname[0]) { /* not --dry-run? */
+			temp = xstrdup(TT.tempname);
+			temp[strlen(temp) - 6] = '\0';
+			rename(TT.tempname, temp);
+			free(temp);
+			free(TT.tempname);
+		}
 
-		free(TT.tempname);
 		TT.tempname = NULL;
 	}
 	TT.fileout = TT.filein = -1;
@@ -197,8 +191,10 @@ static void fail_hunk(void)
 	// Abort the copy and delete the temporary file.
 	close(TT.filein);
 	close(TT.fileout);
-	unlink(TT.tempname);
-	free(TT.tempname);
+	if (!ENABLE_LONG_OPTS || TT.tempname[0]) { /* not --dry-run? */
+		unlink(TT.tempname);
+		free(TT.tempname);
+	}
 	TT.tempname = NULL;
 
 	TT.state = 0;
@@ -239,6 +235,7 @@ static int apply_one_hunk(void)
 	plist = TT.current_hunk;
 	buf = NULL;
 	if (reverse ? TT.oldlen : TT.newlen) for (;;) {
+//FIXME: this performs 1-byte reads:
 		char *data = xmalloc_reads(TT.filein, NULL);
 
 		TT.linenum++;
@@ -369,9 +366,45 @@ int patch_main(int argc UNUSED_PARAM, ch
 	long oldlen = oldlen; /* for compiler */
 	long newlen = newlen; /* for compiler */
 
+#if ENABLE_LONG_OPTS
+	static const char patch_longopts[] ALIGN1 =
+		"reverse\0"               No_argument       "R"
+		"unified\0"               No_argument       "u"
+		"strip\0"                 Required_argument "p"
+		"input\0"                 Required_argument "i"
+		"forward\0"               No_argument       "N"
+# if ENABLE_DESKTOP
+		"remove-empty-files\0"    No_argument       "E" /*ignored*/
+		/* "debug"                Required_argument "x" */
+# endif
+		/* "Assume user knows what [s]he is doing, do not ask any questions": */
+		"force\0"                 No_argument       "f" /*ignored*/
+# if ENABLE_DESKTOP
+		/* "Controls actions when a file is under RCS or SCCS control,
+		 * and does not exist or is read-only and matches the default version,
+		 * or when a file is under ClearCase control and does not exist..."
+		 * IOW: rather obscure option.
+		 * But Gentoo's portage does use -g0
+		 */
+		"get\0"                   Required_argument "g" /*ignored*/
+# endif
+		"dry-run\0"               No_argument       "\xfd"
+# if ENABLE_DESKTOP
+		"backup-if-mismatch\0"    No_argument       "\xfe" /*ignored*/
+		"no-backup-if-mismatch\0" No_argument       "\xff" /*ignored*/
+# endif
+		;
+#endif
+
 	INIT_TT();
 
+#if ENABLE_LONG_OPTS
+	opts = getopt32long(argv, FLAG_STR, patch_longopts, &opt_p, &opt_i);
+#else
 	opts = getopt32(argv, FLAG_STR, &opt_p, &opt_i);
+#endif
+	//bb_error_msg_and_die("opts:%x", opts);
+
 	argv += optind;
 	reverse = opts & FLAG_REVERSE;
 	TT.prefix = (opts & FLAG_PATHLEN) ? xatoi(opt_p) : 0; // can be negative!
@@ -517,10 +550,12 @@ int patch_main(int argc UNUSED_PARAM, ch
 					if (option_mask32 & FLAG_RMEMPTY) {
 						// If flag -E or --remove-empty-files is set
 						printf("removing %s\n", name);
-						xunlink(name);
+						if (!(opts & FLAG_dry_run))
+							xunlink(name);
 					} else {
 						printf("patching file %s\n", name);
-						xclose(xopen(name, O_WRONLY | O_TRUNC));
+						if (!(opts & FLAG_dry_run))
+							xclose(xopen(name, O_WRONLY | O_TRUNC));
 					}
 				// If we've got a file to open, do so.
 				} else if (!(option_mask32 & FLAG_PATHLEN) || i <= TT.prefix) {
@@ -529,24 +564,32 @@ int patch_main(int argc UNUSED_PARAM, ch
 					// If the old file was null, we're creating a new one.
 					if (strcmp(oldname, "/dev/null") == 0 || !oldsum) {
 						printf("creating %s\n", name);
-						s = strrchr(name, '/');
-						if (s) {
-							*s = 0;
-							bb_make_directory(name, -1, FILEUTILS_RECUR);
-							*s = '/';
+						if (!(opts & FLAG_dry_run)) {
+							s = strrchr(name, '/');
+							if (s) {
+								*s = '\0';
+								bb_make_directory(name, -1, FILEUTILS_RECUR);
+								*s = '/';
+							}
+							TT.filein = xopen(name, O_CREAT|O_EXCL|O_RDWR);
+						} else {
+							TT.filein = xopen("/dev/null", O_RDONLY);
 						}
-						TT.filein = xopen(name, O_CREAT|O_EXCL|O_RDWR);
 					} else {
 						printf("patching file %s\n", name);
 						TT.filein = xopen(name, O_RDONLY);
 					}
 
-					TT.tempname = xasprintf("%sXXXXXX", name);
-					TT.fileout = xmkstemp(TT.tempname);
-					// Set permissions of output file
-					fstat(TT.filein, &statbuf);
-					fchmod(TT.fileout, statbuf.st_mode);
-
+					if (!(opts & FLAG_dry_run)) {
+						TT.tempname = xasprintf("%sXXXXXX", name);
+						TT.fileout = xmkstemp(TT.tempname);
+						// Set permissions of output file
+						fstat(TT.filein, &statbuf);
+						fchmod(TT.fileout, statbuf.st_mode);
+					} else {
+						TT.tempname = (char*)"";
+						TT.fileout = xopen("/dev/null", O_WRONLY);
+					}
 					TT.linenum = 0;
 					TT.hunknum = 0;
 				}
diff -urpN busybox-1.28.4/editors/sed.c busybox-1.29.0/editors/sed.c
--- busybox-1.28.4/editors/sed.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/editors/sed.c	2018-07-02 15:55:14.000000000 +0200
@@ -988,7 +988,7 @@ static void flush_append(char *last_puts
 static char *get_next_line(char *gets_char, char *last_puts_char)
 {
 	char *temp = NULL;
-	int len;
+	size_t len;
 	char gc;
 
 	flush_append(last_puts_char);
diff -urpN busybox-1.28.4/editors/vi.c busybox-1.29.0/editors/vi.c
--- busybox-1.28.4/editors/vi.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/editors/vi.c	2018-07-02 15:55:14.000000000 +0200
@@ -750,7 +750,10 @@ static int query_screen_dimensions(void)
 	return err;
 }
 #else
-# define query_screen_dimensions() (0)
+static ALWAYS_INLINE int query_screen_dimensions(void)
+{
+	return 0;
+}
 #endif
 
 static void edit_file(char *fn)
@@ -1067,10 +1070,13 @@ static void colon(char *buf)
 	not_implemented(p);
 #else
 
-	char c, *orig_buf, *buf1, *q, *r;
+	char c, *buf1, *q, *r;
 	char *fn, cmd[MAX_INPUT_LEN], args[MAX_INPUT_LEN];
 	int i, l, li, b, e;
 	int useforce;
+# if ENABLE_FEATURE_VI_SEARCH || ENABLE_FEATURE_ALLOW_EXEC
+	char *orig_buf;
+# endif
 
 	// :3154	// if (-e line 3154) goto it  else stay put
 	// :4,33w! foo	// write a portion of buffer to file "foo"
@@ -1102,8 +1108,10 @@ static void colon(char *buf)
 	// look for optional address(es)  :.  :1  :1,9   :'q,'a   :%
 	buf = get_address(buf, &b, &e);
 
+# if ENABLE_FEATURE_VI_SEARCH || ENABLE_FEATURE_ALLOW_EXEC
 	// remember orig command line
 	orig_buf = buf;
+# endif
 
 	// get the COMMAND into cmd[]
 	buf1 = cmd;
@@ -1147,7 +1155,7 @@ static void colon(char *buf)
 			dot_skip_over_ws();
 		}
 	}
-#if ENABLE_FEATURE_ALLOW_EXEC
+# if ENABLE_FEATURE_ALLOW_EXEC
 	else if (cmd[0] == '!') {	// run a cmd
 		int retcode;
 		// :!ls   run the <cmd>
@@ -1159,7 +1167,7 @@ static void colon(char *buf)
 		rawmode();
 		Hit_Return();			// let user see results
 	}
-#endif
+# endif
 	else if (cmd[0] == '=' && !cmd[1]) {	// where is the address
 		if (b < 0) {	// no addr given- use defaults
 			b = e = count_lines(text, dot);
@@ -1194,7 +1202,7 @@ static void colon(char *buf)
 
 		size = init_text_buffer(fn);
 
-#if ENABLE_FEATURE_VI_YANKMARK
+# if ENABLE_FEATURE_VI_YANKMARK
 		if (Ureg >= 0 && Ureg < 28) {
 			free(reg[Ureg]);	//   free orig line reg- for 'U'
 			reg[Ureg] = NULL;
@@ -1203,7 +1211,7 @@ static void colon(char *buf)
 			free(reg[YDreg]);	//   free default yank/delete register
 			reg[YDreg] = NULL;
 		}
-#endif
+# endif
 		// how many lines in text[]?
 		li = count_lines(text, end - 1);
 		status_line("'%s'%s"
@@ -1350,16 +1358,16 @@ static void colon(char *buf)
 			optind = -1; /* start from 0th file */
 			editing = 0;
 		}
-#if ENABLE_FEATURE_VI_SET
+# if ENABLE_FEATURE_VI_SET
 	} else if (strncmp(cmd, "set", i) == 0) {	// set or clear features
-#if ENABLE_FEATURE_VI_SETOPTS
+#  if ENABLE_FEATURE_VI_SETOPTS
 		char *argp;
-#endif
+#  endif
 		i = 0;			// offset into args
 		// only blank is regarded as args delimiter. What about tab '\t'?
 		if (!args[0] || strcasecmp(args, "all") == 0) {
 			// print out values of all options
-#if ENABLE_FEATURE_VI_SETOPTS
+#  if ENABLE_FEATURE_VI_SETOPTS
 			status_line_bold(
 				"%sautoindent "
 				"%sflash "
@@ -1372,10 +1380,10 @@ static void colon(char *buf)
 				showmatch ? "" : "no",
 				tabstop
 			);
-#endif
+#  endif
 			goto ret;
 		}
-#if ENABLE_FEATURE_VI_SETOPTS
+#  if ENABLE_FEATURE_VI_SETOPTS
 		argp = args;
 		while (*argp) {
 			if (strncmp(argp, "no", 2) == 0)
@@ -1393,16 +1401,17 @@ static void colon(char *buf)
 			argp = skip_non_whitespace(argp);
 			argp = skip_whitespace(argp);
 		}
-#endif /* FEATURE_VI_SETOPTS */
-#endif /* FEATURE_VI_SET */
-#if ENABLE_FEATURE_VI_SEARCH
+#  endif /* FEATURE_VI_SETOPTS */
+# endif /* FEATURE_VI_SET */
+
+# if ENABLE_FEATURE_VI_SEARCH
 	} else if (cmd[0] == 's') {	// substitute a pattern with a replacement pattern
 		char *F, *R, *flags;
 		size_t len_F, len_R;
 		int gflag;		// global replace flag
-#if ENABLE_FEATURE_VI_UNDO
+#  if ENABLE_FEATURE_VI_UNDO
 		int dont_chain_first_item = ALLOW_UNDO;
-#endif
+#  endif
 
 		// F points to the "find" pattern
 		// R points to the "replace" pattern
@@ -1439,9 +1448,9 @@ static void colon(char *buf)
 				// we found the "find" pattern - delete it
 				// For undo support, the first item should not be chained
 				text_hole_delete(found, found + len_F - 1, dont_chain_first_item);
-#if ENABLE_FEATURE_VI_UNDO
+#  if ENABLE_FEATURE_VI_UNDO
 				dont_chain_first_item = ALLOW_UNDO_CHAIN;
-#endif
+#  endif
 				// insert the "replace" patern
 				bias = string_insert(found, R, ALLOW_UNDO_CHAIN);
 				found += bias;
@@ -1457,7 +1466,7 @@ static void colon(char *buf)
 			}
 			q = next_line(ls);
 		}
-#endif /* FEATURE_VI_SEARCH */
+# endif /* FEATURE_VI_SEARCH */
 	} else if (strncmp(cmd, "version", i) == 0) {  // show software version
 		status_line(BB_VER);
 	} else if (strncmp(cmd, "write", i) == 0  // write text to file
@@ -1472,12 +1481,12 @@ static void colon(char *buf)
 		if (args[0]) {
 			fn = args;
 		}
-#if ENABLE_FEATURE_VI_READONLY
+# if ENABLE_FEATURE_VI_READONLY
 		if (readonly_mode && !useforce) {
 			status_line_bold("'%s' is read only", fn);
 			goto ret;
 		}
-#endif
+# endif
 		//if (useforce) {
 			// if "fn" is not write-able, chmod u+w
 			// sprintf(syscmd, "chmod u+w %s", fn);
@@ -1517,7 +1526,7 @@ static void colon(char *buf)
 				}
 			}
 		}
-#if ENABLE_FEATURE_VI_YANKMARK
+# if ENABLE_FEATURE_VI_YANKMARK
 	} else if (strncmp(cmd, "yank", i) == 0) {	// yank lines
 		if (b < 0) {	// no addr given- use defaults
 			q = begin_line(dot);	// assume .,. for the range
@@ -1527,7 +1536,7 @@ static void colon(char *buf)
 		li = count_lines(q, r);
 		status_line("Yank %d lines (%d chars) into [%c]",
 				li, strlen(reg[YDreg]), what_reg());
-#endif
+# endif
 	} else {
 		// cmd unknown
 		not_implemented(cmd);
@@ -1535,10 +1544,10 @@ static void colon(char *buf)
  ret:
 	dot = bound_dot(dot);	// make sure "dot" is valid
 	return;
-#if ENABLE_FEATURE_VI_SEARCH
+# if ENABLE_FEATURE_VI_SEARCH
  colon_s_fail:
 	status_line(":s expression missing delimiters");
-#endif
+# endif
 #endif /* FEATURE_VI_COLON */
 }
 
diff -urpN busybox-1.28.4/examples/shutdown-1.0/README busybox-1.29.0/examples/shutdown-1.0/README
--- busybox-1.28.4/examples/shutdown-1.0/README	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/README	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,30 @@
+# Replaces traditional overdesigned shutdown mechanism.
+#
+# No communication with init is necessary:
+# just ask all processes to exit.
+# Then unmount everything. Then reboot or power off.
+
+# Install /sbin/ symlinks named halt, reboot, poweroff
+# (and also possibly shutdown) to e.g.
+# /app/shutdown-1.0/script/shutdown:
+#
+ln -s /app/shutdown-1.0/script/shutdown /sbin/halt
+ln -s /app/shutdown-1.0/script/shutdown /sbin/reboot
+ln -s /app/shutdown-1.0/script/shutdown /sbin/poweroff
+#
+# shutdown spawns do_shutdown in new session, redirected to /dev/null,
+# tells user that shutdown is in progress, and sleeps
+# (for cosmetic reasons: do not confuse user by letting him
+# type more commands in this terminal).
+#
+# do_shutdown tries to switch to a VT console.
+# Then, (only if -r) it spawns a hardshutdown child, to reboot
+# unconditionally in 30 seconds if something later goes seriously bad.
+# Then it runs stop_tasks, writing to /var/log/reboot/YYYYMMDDhhmmss.log,
+# then it runs stop_storage.
+# Then it commands kernel to halt/reboot/poweroff, if requested.
+# Then it sleeps forever.
+#
+# Build the hardshutdown binary:
+#
+cd script && ./hardshutdown.make.sh
diff -urpN busybox-1.28.4/examples/shutdown-1.0/script/do_shutdown busybox-1.29.0/examples/shutdown-1.0/script/do_shutdown
--- busybox-1.28.4/examples/shutdown-1.0/script/do_shutdown	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/script/do_shutdown	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,54 @@
+#!/bin/sh
+# We are called with stdin/out/err = /dev/null
+
+resetgracetime=60
+
+logfile="/var/log/reboot/`date '+%Y%m%d%H%M%S'`.log"
+mkdir -p /var/log/reboot
+
+PATH=/sbin:/bin
+
+say() {
+	printf "\r%s\n\r" "$*"
+}
+
+# Since there is a potential for various fuckups during umount,
+# we start delayed hard reboot here which will forcibly
+# reboot hung box in a remote datacenter a thousand miles away ;)
+if test "$1" = "-r"; then
+	./hardshutdown -r "$resetgracetime" &
+fi
+
+# Now, (try to) switch away from X and open a console. I've seen reboots
+# hung on open("/dev/console"), therefore we do it _after_ hardshutdown
+exec >/dev/console 2>&1
+
+if test "$1" = "-r"; then
+	say "* `date '+%H:%M:%S'` Scheduled hard reboot in $resetgracetime seconds"
+fi
+
+say "* `date '+%H:%M:%S'` Stopping tasks (see /var/log/reboot/* files)"
+# log reboot event to file. %Y%m%d%H%M%S: YYYYMMDDHHMMSS
+./stop_tasks >"$logfile" 2>&1
+
+# Dying X tends to leave us at semi-random vt. Try to fix that,
+# but if it doesn't work, proceed anyway.
+exec >/dev/null 2>&1
+chvt 1 & sleep 1
+exec >/dev/console 2>&1
+
+command -v ctrlaltdel >/dev/null && {
+	say "* `date '+%H:%M:%S'` Setting Ctrl-Alt-Del to 'hard'"
+	ctrlaltdel hard
+}
+
+say "* `date '+%H:%M:%S'` Stopping storage devices"
+# we can't log this: we are about to unmount everything!
+./stop_storage "$@"
+
+# If we have cmdline params, start hardshutdown with them
+test "$*" && ./hardshutdown "$@"
+
+# Just sleep endlessly...
+say "* `date '+%H:%M:%S'` You may now power off or press Ctrl-Alt-Del to reboot"
+while true; do sleep 32000; done
diff -urpN busybox-1.28.4/examples/shutdown-1.0/script/hardshutdown.c busybox-1.29.0/examples/shutdown-1.0/script/hardshutdown.c
--- busybox-1.28.4/examples/shutdown-1.0/script/hardshutdown.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/script/hardshutdown.c	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,168 @@
+/* Including <unistd.h> makes sure that on a glibc system
+ * <features.h> is included, which again defines __GLIBC__
+ */
+
+#include <unistd.h>
+#include <stdio.h>	/* puts */
+#include <time.h>	/* nanosleep */
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+/*
+ * Magic values required to use _reboot() system call.
+ */
+#define	LINUX_REBOOT_MAGIC1	0xfee1dead
+#define	LINUX_REBOOT_MAGIC2	672274793
+#define	LINUX_REBOOT_MAGIC2A	85072278
+#define	LINUX_REBOOT_MAGIC2B	369367448
+/*
+ * Commands accepted by the _reboot() system call.
+ *
+ * RESTART     Restart system using default command and mode.
+ * HALT        Stop OS and give system control to ROM monitor, if any.
+ * CAD_ON      Ctrl-Alt-Del sequence causes RESTART command.
+ * CAD_OFF     Ctrl-Alt-Del sequence sends SIGINT to init task.
+ * POWER_OFF   Stop OS and remove all power from system, if possible.
+ * RESTART2    Restart system using given command string.
+ */
+#define	LINUX_REBOOT_CMD_RESTART	0x01234567
+#define	LINUX_REBOOT_CMD_HALT		0xCDEF0123
+#define	LINUX_REBOOT_CMD_CAD_ON		0x89ABCDEF
+#define	LINUX_REBOOT_CMD_CAD_OFF	0x00000000
+#define	LINUX_REBOOT_CMD_POWER_OFF	0x4321FEDC
+#define	LINUX_REBOOT_CMD_RESTART2	0xA1B2C3D4
+
+
+#define USE_LIBC
+
+#ifdef USE_LIBC
+
+/* libc version */
+#if defined __GLIBC__ && __GLIBC__ >= 2
+#  include <sys/reboot.h>
+#  define REBOOT(cmd) reboot(cmd)
+#else
+extern int reboot(int, int, int);
+#  define REBOOT(cmd) reboot(LINUX_REBOOT_MAGIC1,LINUX_REBOOT_MAGIC2,(cmd))
+#endif
+
+static int my_reboot(int cmd)
+{
+	return REBOOT(cmd);
+}
+
+#else /* no USE_LIBC */
+
+/* direct syscall version */
+#include <linux/unistd.h>
+
+#ifdef _syscall3
+_syscall3(int,  reboot,  int,  magic, int, magic_too, int, cmd);
+#else
+/* Let us hope we have a 3-argument reboot here */
+extern int reboot(int, int, int);
+#endif
+
+static int my_reboot(int cmd)
+{
+	return reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd);
+}
+
+#endif
+
+
+static void do_reboot(void)
+{
+	my_reboot(LINUX_REBOOT_CMD_RESTART);
+}
+static void do_poweroff(void)
+{
+	my_reboot(LINUX_REBOOT_CMD_POWER_OFF);
+}
+static void do_halt(void)
+{
+	my_reboot(LINUX_REBOOT_CMD_HALT);
+}
+
+static void usage(void)
+{
+	puts(
+	    "Usage: hardshutdown -h|-r|-p [NN]\n"
+	    "	NN - seconds to sleep before requested action"
+	);
+	exit(1);
+}
+
+enum action_t {
+	SHUTDOWN,	// do nothing
+	HALT,
+	POWEROFF,
+	REBOOT
+};
+
+int main(int argc, char *argv[])
+{
+	struct timespec t = {0,0};
+	enum action_t action = SHUTDOWN;
+	int c, i;
+	char *prog, *ptr;
+
+	//if (*argv[0] == '-') argv[0]++; /* allow shutdown as login shell */
+	prog = argv[0];
+	ptr = strrchr(prog,'/');
+	if (ptr)
+		prog = ptr+1;
+
+	for (c=1; c < argc; c++) {
+		if (argv[c][0] >= '0' && argv[c][0] <= '9') {
+			t.tv_sec = strtol(argv[c], NULL, 10);
+			continue;
+		}
+		if (argv[c][0] != '-') {
+			usage();
+			return 1;
+		}
+		for (i=1; argv[c][i]; i++) {
+			switch (argv[c][i]) {
+			case 'h':
+				action = HALT;
+				break;
+			case 'p':
+				action = POWEROFF;
+				break;
+			case 'r':
+				action = REBOOT;
+				break;
+			default:
+				usage();
+				return 1;
+			}
+		}
+	}
+
+	if (action==SHUTDOWN) {
+		usage();
+		return 1;
+	}
+
+	chdir("/");
+	while (nanosleep(&t,&t)<0)
+		if (errno!=EINTR) break;
+
+	switch (action) {
+	case HALT:
+		do_halt();
+		break;
+	case POWEROFF:
+		do_poweroff();
+		break;
+	case REBOOT:
+		do_reboot();
+		break;
+	default: /* SHUTDOWN */
+		break;
+	}
+	return 1;
+}
diff -urpN busybox-1.28.4/examples/shutdown-1.0/script/hardshutdown.make.sh busybox-1.29.0/examples/shutdown-1.0/script/hardshutdown.make.sh
--- busybox-1.28.4/examples/shutdown-1.0/script/hardshutdown.make.sh	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/script/hardshutdown.make.sh	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+gcc -Wall -Os -o hardshutdown hardshutdown.c
+strip hardshutdown
+
+#or:
+#diet gcc -Wall -o hardshutdown hardshutdown.c
+#elftrunc hardshutdown
diff -urpN busybox-1.28.4/examples/shutdown-1.0/script/shutdown busybox-1.29.0/examples/shutdown-1.0/script/shutdown
--- busybox-1.28.4/examples/shutdown-1.0/script/shutdown	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/script/shutdown	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,64 @@
+#!/bin/sh
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+
+# Usually, /sbin/ has symlinks named halt, reboot, poweroff
+# (and also possibly shutdown) to e.g.
+# /app/shutdown-1.0/script/shutdown (this file).
+cd /app/shutdown-1.0/script || exit 1
+test -x ./do_shutdown || exit 1
+test -x ./hardshutdown || exit 1
+
+# "reboot -f" -> "shutdown -f -r" -> "hardshutdown -r" -> immediate reboot
+# "reboot" -> "shutdown -r" -> "do_shutdown -r"
+# ^^^^^^^^^^^^^^^^^^ similarly for halt, poweroff.
+# "shutdown" -> "do_shutdown" (everything killed/unmounted, but kernel not asked to do any poweroff etc)
+force=""
+test x"$1" = x"-f" && {
+	force="-f"
+	shift
+}
+test ! "$*" && test x"${0##*/}" = x"halt" && exec "$0" $force -h
+test ! "$*" && test x"${0##*/}" = x"reboot" && exec "$0" $force -r
+test ! "$*" && test x"${0##*/}" = x"poweroff" && exec "$0" $force -p
+# We have something else than allowed parameters?
+test x"$*" = x"" || test x"$*" = x"-h" || test x"$*" = x"-r" || test x"$*" = x"-p" || {
+	echo "Syntax: $0 [-f] [-h/-r/-p]"
+	exit 1
+}
+
+# Emergency shutdown?
+test "$force" && {
+	exec ./hardshutdown "$@"
+	exit 1
+}
+
+# Normal shutdown
+
+# We must have these executables on root fs
+# (mount/umount aren't checked, all systems are ok versus that):
+test -x /bin/killall5 -o -x /sbin/killall5 || exit 1
+test -x /bin/ps       -o -x /sbin/ps       || exit 1
+test -x /bin/date     -o -x /sbin/date     || exit 1
+test -x /bin/xargs    -o -x /sbin/xargs    || exit 1
+test -x /bin/wc       -o -x /sbin/wc       || exit 1
+test -x /bin/cat      -o -x /sbin/cat      || exit 1
+test -x /bin/sort     -o -x /sbin/sort     || exit 1
+
+i="`ulimit -n`"
+echo -n "Closing file descriptors $i-3... "
+while test "$i" -ge 3; do
+	eval "exec $i>&-"
+	i=$((i-1))
+done
+
+echo "Shutting down. Please stand by..."
+
+# setsid & /dev/null:
+# make it a process leader & detach it from current tty.
+# Why /dev/null and not /dev/console?
+# I have seen a system which locked up while opening /dev/console
+# due to the bug (?) in keyboard driver.
+setsid env - PATH="$PATH" ./do_shutdown "$@" </dev/null >/dev/null 2>&1 &
+
+while true; do read junk; done
diff -urpN busybox-1.28.4/examples/shutdown-1.0/script/stop_storage busybox-1.29.0/examples/shutdown-1.0/script/stop_storage
--- busybox-1.28.4/examples/shutdown-1.0/script/stop_storage	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/script/stop_storage	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,81 @@
+#!/bin/sh
+# Do unmount/remount-ro. Wait.
+# KILL everybody. Wait.
+# Repeat.
+
+umountcnt=2
+writeout=0	# increase if your kernel doesn ot guarantee writes to complete
+
+# No /usr - we are expecting all binaries to be accessible
+# from root fs alone
+PATH=/sbin:/bin
+
+say() {
+	printf "\r%s\n\r" "$*"
+}
+
+showps() {
+	# sleep 1 ensures that xargs will have time to start up
+	# this makes pslist less prone to random jitter
+	pslist=`{ sleep 1; ps -A -o comm=; } | sort | xargs`
+	pscnt=$(( `say "$pslist" | wc -w` + 0 ))
+	if test x"$VERBOSE" = x; then
+		say "* `date '+%H:%M:%S'` $pscnt processes"
+	else
+		say "* `date '+%H:%M:%S'` Processes ($pscnt): $pslist"
+	fi
+}
+
+say "<*> `date '+%Y-%m-%d %H:%M:%S'` Executing '$0 $*'"
+
+showps
+
+i="$umountcnt"
+while test "$i" -gt 0; do
+	say "* `date '+%H:%M:%S'` Unmounting filesystems"
+	umount -a -n -r -f
+	# In case we unmounted proc...
+	test -e /proc/version || mount -t proc none /proc
+	# Remounting / RO isn't necessary when /etc/mtab is linked to /proc/mounts:
+	# already done. But let's be more paranoid here...
+	say "* `date '+%H:%M:%S'` Remounting root filesystem read-only"
+	mount -n -o remount,ro /
+	say "* `date '+%H:%M:%S'` Freeing loop devices"
+	for a in /dev/loop*; do
+		test -b "$a" && losetup -d "$a"
+	done
+	say "* `date '+%H:%M:%S'` Syncing"
+	sync
+	say "* `date '+%H:%M:%S'` Executing: killall5 -KILL"
+	killall5 -9
+	showps
+	i=$((i-1))
+done
+
+say "* `date '+%H:%M:%S'` Filesystem status (/proc/mounts)"
+cat /proc/mounts \
+| {
+	bad=false
+	while read dev mntpoint fstype opt n1 n2; do
+		case "$fstype" in
+		( proc | sysfs | usbfs | devpts | rpc_pipefs | binfmt_misc | autofs | rootfs | tmpfs | ramfs )
+			say "$dev $mntpoint $fstype $opt $n1 $n2"
+			continue
+			;;
+		esac
+		if test "${opt:0:2}" = "rw"; then
+			say "$dev $mntpoint $fstype $opt $n1 $n2 - RW!"
+			bad=true
+		else
+			say "$dev $mntpoint $fstype $opt $n1 $n2"
+		fi
+	done
+	if $bad; then
+		say "ERROR: we have filesystems mounted RW! Press <Enter> (^J)..."
+		read junk </dev/console
+		#sh </dev/console >&0 2>&0 # debug
+	fi
+}
+
+# Disk cache writeout
+sleep "$writeout"
diff -urpN busybox-1.28.4/examples/shutdown-1.0/script/stop_tasks busybox-1.29.0/examples/shutdown-1.0/script/stop_tasks
--- busybox-1.28.4/examples/shutdown-1.0/script/stop_tasks	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/shutdown-1.0/script/stop_tasks	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,70 @@
+#!/bin/sh
+# We are trying to be nice.
+# TERM everybody. Give them some time to die.
+# KILL might make some filesystems non-unmountable,
+# so we'll do it in stop_storage instead.
+
+killcnt=30
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+
+echo "<*> `date '+%Y-%m-%d %H:%M:%S'` Executing '$0 $*'"
+
+showps() {
+	# sleep 1 ensures that xargs will have time to start up.
+	# This makes pslist less prone to random jitter.
+	pslist=`{ sleep 1; ps -A -o comm=; } | sort | xargs`
+	pscnt=$(( `echo "$pslist" | wc -w` + 0 ))
+	if test x"$VERBOSE" = x; then
+		echo "* `date '+%H:%M:%S'` $pscnt processes"
+	else
+		echo "* `date '+%H:%M:%S'` Processes ($pscnt): $pslist"
+	fi
+}
+
+# Sync.
+# Rationale: sometimes buggy root processes can
+# hang the system when killed (X for example may have problems
+# with restoring text mode on a poorly supported hardware).
+# These are bugs and must be fixed, but until then users will lose
+# dirty data on shutdown! Let's make that less likely.
+sync &
+
+# Send SIGTERMs. If list of processes changes, proceed slower.
+# If it has stabilised (all who wanted to, exited), proceed faster.
+showps
+i="$killcnt"
+while test "$i" -gt 0; do
+	echo "* `date '+%H:%M:%S'` Sending CONT, TERM" #, HUP"
+	# I've seen "killall5 2.86" which doesn't grok signal names!
+	killall5 -18
+	killall5 -15
+	#killall5 -1    # HUP: because interactive bash does not die on TERM...
+	# but init will reread /etc/inittab on HUP and my /etc is on non root fs!
+	# -> umounts will complain.
+	oldpslist="$pslist"
+	showps
+	if test x"$pslist" = x"$oldpslist"; then
+		i=$((i-8))
+	fi
+	i=$((i-2))
+done
+
+echo "* `date '+%H:%M:%S'` Turning off swap"
+swapoff -a
+cat /proc/swaps | grep -v ^Filename | cut -d ' ' -f1 \
+| while read -r line; do
+	test "$line" && {
+		echo swapoff "$line"
+		swapoff "$line"
+	}
+done
+
+echo "* /proc/swaps:"
+cat /proc/swaps
+echo "* /proc/mounts:"
+cat /proc/mounts
+echo "* ps -A e:"
+ps -A e
+echo "* top -bn1:"
+top -bn1
diff -urpN busybox-1.28.4/examples/udhcp/udhcpd.conf busybox-1.29.0/examples/udhcp/udhcpd.conf
--- busybox-1.28.4/examples/udhcp/udhcpd.conf	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/udhcp/udhcpd.conf	2018-07-02 15:55:14.000000000 +0200
@@ -70,8 +70,9 @@ option	domain	local
 option	lease	864000		# default: 10 days
 option	msstaticroutes	10.0.0.0/8 10.127.0.1		# single static route
 option	staticroutes	10.0.0.0/8 10.127.0.1, 10.11.12.0/24 10.11.12.1
-# Arbitrary option in hex form:
+# Arbitrary option in hex or string form:
 option	0x08	01020304	# option 8: "cookie server IP addr: 1.2.3.4"
+option	14	"dumpfile"
 
 # Currently supported options (for more info, see options.c):
 #opt lease      NUM
diff -urpN busybox-1.28.4/examples/var_service/README_distro_proposal.txt busybox-1.29.0/examples/var_service/README_distro_proposal.txt
--- busybox-1.28.4/examples/var_service/README_distro_proposal.txt	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/examples/var_service/README_distro_proposal.txt	2018-07-02 15:55:14.000000000 +0200
@@ -246,7 +246,8 @@ relative to the system-wide service dire
 This proposal asks developers of other daemontools implementations
 to add "svc" command to their projects]
 
-The "svok DIR" tool exits 0 if service is running, and nonzero if not.
+The "svok DIR" tool exits 0 if service supervisor is running
+(with service itself either running or stopped), and nonzero if not.
 
 Other tools with different names and APIs may exist; however
 for portability scripts should use the above tools.
diff -urpN busybox-1.28.4/examples/var_service/dnsmasq/README busybox-1.29.0/examples/var_service/dnsmasq/README
--- busybox-1.28.4/examples/var_service/dnsmasq/README	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/dnsmasq/README	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,10 @@
+Local DNS cache service.
+
+This service is useful if you have more than 3 DNS servers,
+or if you need a finer-grained control of which servers
+can serve which domain.
+
+To make programs use local DNS server, make sure
+/etc/resolv.conf says:
+
+nameserver 127.0.0.1
diff -urpN busybox-1.28.4/examples/var_service/dnsmasq/dnsmasq.conf busybox-1.29.0/examples/var_service/dnsmasq/dnsmasq.conf
--- busybox-1.28.4/examples/var_service/dnsmasq/dnsmasq.conf	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/dnsmasq/dnsmasq.conf	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,76 @@
+keep-in-foreground
+
+# "-" is stderr:
+log-facility=-
+
+# May also try log-queries=extra
+log-queries
+
+# No param = pidfile disabled:
+pid-file
+
+interface=lo
+listen-address=127.0.0.1
+bind-interfaces
+
+cache-size=999
+
+servers-file=/etc/dnsmasq_servers.conf
+
+# Don’t read /etc/resolv.conf and /etc/hosts:
+no-resolv
+#no-hosts
+
+# All reverse lookups for private IP ranges (ie 192.168.x.x, etc)
+# which are not found in /etc/hosts or the DHCP leases file are
+# answered with "no such domain" rather than being forwarded
+# upstream. The set of prefixes affected is the list given in
+# RFC6303.
+#bogus-priv
+
+#−T, --local-ttl=<time>
+# When replying with information from /etc/hosts or configuration
+# or the DHCP leases file dnsmasq by default sets the time-to-live
+# field to zero, meaning that the requester should not itself
+# cache the information. This is the correct thing to do in almost
+# all situations. This option allows a time-to-live (in seconds)
+# to be given for these replies. This will reduce the load on the
+# server at the expense of clients using stale data under some
+# circumstances.
+local-ttl=67
+
+#--dhcp-ttl=<time>
+# As for --local-ttl, but affects only replies with information
+# from DHCP leases. If both are given, --dhcp-ttl applies for DHCP
+# information, and --local-ttl for others. Setting this to zero
+# eliminates the effect of --local-ttl for DHCP.
+#
+#--neg-ttl=<time>
+# Negative replies from upstream servers normally contain time-to-
+# live information in SOA records which dnsmasq uses for caching.
+# If the replies from upstream servers omit this information, dns-
+# masq does not cache the reply. This option gives a default value
+# for time-to-live (in seconds) which dnsmasq uses to cache nega-
+# tive replies even in the absence of an SOA record.
+neg-ttl=67
+
+#--max-ttl=<time>
+# Set a maximum TTL value that will be handed out to clients. The
+# specified maximum TTL will be given to clients instead of the
+# true TTL value if it is lower. The true TTL value is however
+# kept in the cache to avoid flooding the upstream DNS servers.
+#
+#--max-cache-ttl=<time>
+# Set a maximum TTL value for entries in the cache.
+#
+#--min-cache-ttl=<time>
+# Extend short TTL values to the time given when caching them.
+# Note that artificially extending TTL values is in general a bad
+# idea, do not do it unless you have a good reason, and understand
+# what you are doing. Dnsmasq limits the value of this option to
+# one hour, unless recompiled.
+min-cache-ttl=67
+
+#--auth-ttl=<time>
+# Set the TTL value returned in answers from the authoritative
+# server.
diff -urpN busybox-1.28.4/examples/var_service/dnsmasq/log/run busybox-1.29.0/examples/var_service/dnsmasq/log/run
--- busybox-1.28.4/examples/var_service/dnsmasq/log/run	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/dnsmasq/log/run	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+user=logger
+
+logdir="/var/log/service/`(cd ..;basename $PWD)`"
+mkdir -p "$logdir" 2>/dev/null
+chown -R "$user": "$logdir"
+chmod -R go-rwxst,u+rwX "$logdir"
+rm -rf logdir
+ln -s "$logdir" logdir
+
+# make this dir accessible to logger
+chmod a+rX .
+
+exec >/dev/null
+exec 2>&1
+exec \
+env - PATH="$PATH" \
+softlimit \
+setuidgid "$user" \
+svlogd -tt "$logdir"
diff -urpN busybox-1.28.4/examples/var_service/dnsmasq/p_log busybox-1.29.0/examples/var_service/dnsmasq/p_log
--- busybox-1.28.4/examples/var_service/dnsmasq/p_log	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/dnsmasq/p_log	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+cd log/logdir || exit 1
+cat @* current | $PAGER
diff -urpN busybox-1.28.4/examples/var_service/dnsmasq/run busybox-1.29.0/examples/var_service/dnsmasq/run
--- busybox-1.28.4/examples/var_service/dnsmasq/run	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/dnsmasq/run	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+#exec >/dev/null
+exec 2>&1
+exec </dev/null
+
+echo "* Starting dnsmasq"
+exec \
+env - PATH="$PATH" \
+softlimit \
+setuidgid root \
+dnsmasq -C dnsmasq.conf
diff -urpN busybox-1.28.4/examples/var_service/dnsmasq/w_log busybox-1.29.0/examples/var_service/dnsmasq/w_log
--- busybox-1.28.4/examples/var_service/dnsmasq/w_log	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/dnsmasq/w_log	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+cd log/logdir || exit 1
+watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.28.4/examples/var_service/fw/etc/dnsmasq_servers.conf busybox-1.29.0/examples/var_service/fw/etc/dnsmasq_servers.conf
--- busybox-1.28.4/examples/var_service/fw/etc/dnsmasq_servers.conf	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/fw/etc/dnsmasq_servers.conf	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,38 @@
+#!/bin/bash
+
+empty=true
+
+prio=0
+i=0; while test "${if[$i]}"; do
+	test x"${dns_prio[$i]}" != x"" \
+	&& test "${dns_prio[$i]}" -gt "$prio" \
+	&& prio="${dns_prio[$i]}"
+let i++; done
+
+i=0; while test "${if[$i]}"; do
+	if test "${dnsmasq[$i]}"; then
+		for d in ${dnsmasq[$i]}; do
+			echo "$d"
+			empty=false
+		done
+		let i++;
+		continue
+	fi
+	# This iface has no dnsmasq-extended config.
+	# Use simple DNS names instead, if those exist.
+	for d in ${dns[$i]}; do
+		p="${dns_prio[$i]}"
+		test x"$p" == x"" && p=0
+		test x"$p" == x"$prio" || continue
+		echo "server=$d"
+		empty=false
+	done
+	let i++;
+done
+
+# Use Google DNS servers if nothing else is configured
+$empty && echo "server=8.8.8.8"
+$empty && echo "server=8.8.4.4"
+
+# SIGHUP: make dnsmasq reload config
+sv h dnsmasq
diff -urpN busybox-1.28.4/examples/var_service/getty_tty1/cfg busybox-1.29.0/examples/var_service/getty_tty1/cfg
--- busybox-1.28.4/examples/var_service/getty_tty1/cfg	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/var_service/getty_tty1/cfg	2018-07-02 15:55:14.000000000 +0200
@@ -10,7 +10,7 @@ ttyname=`tty`
 ttybase="${ttyname%%[0123456789]*}"     # strip numeric tail
 
 if test x"$ttybase" = x"/dev/vc/" -o x"$ttybase" = x"/dev/tty"; then
-	echo "* Activating Cyrillic KOI8-R -> CP866 font map"
+	echo "* Activating font map"
 	echo -ne "\033(K" >"$ttyname"
 
 	echo "* Loading screen font"
@@ -18,9 +18,9 @@ if test x"$ttybase" = x"/dev/vc/" -o x"$
 		-C "$ttyname" \
 		-m "$PWD/koi8r_to_uni.trans" \
 		"$PWD/alt08x16+unimap.fnt" \
-	|| echo "! setfont failure"
+	|| echo "setfont exit code: $?"
 
 	echo "* Loading keymap"
-	loadkeys "$PWD/ru_koi8r.keymap" \
-	|| echo "! loadkeys failure"
+	loadkeys "$PWD/unicode_cyrillic.keymap" \
+	|| echo "loadkeys exit code: $?"
 fi
diff -urpN busybox-1.28.4/examples/var_service/getty_tty1/login.sh busybox-1.29.0/examples/var_service/getty_tty1/login.sh
--- busybox-1.28.4/examples/var_service/getty_tty1/login.sh	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/var_service/getty_tty1/login.sh	2018-07-02 15:55:14.000000000 +0200
@@ -6,7 +6,8 @@ ttybase="${ttyname%%[0123456789]*}"
 if test "$ttybase" = "/dev/tty"; then
 	tail="${ttyname:8}"
 	echo "* Setting terminal device's owner to $LOGIN_UID:$LOGIN_GID"
-	chown "$LOGIN_UID:$LOGIN_GID" "/dev/vcs$tail" "/dev/vcsa$tail"
+	test -c "/dev/vcs$tail" && chown "$LOGIN_UID:$LOGIN_GID" "/dev/vcs$tail"
+	test -c "/dev/vcsa$tail" && chown "$LOGIN_UID:$LOGIN_GID" "/dev/vcsa$tail"
 fi
 # We can do this also, but login does it itself
 # chown "$LOGIN_UID:$LOGIN_GID" "$ttyname"
diff -urpN busybox-1.28.4/examples/var_service/getty_tty1/ru_koi8r.keymap busybox-1.29.0/examples/var_service/getty_tty1/ru_koi8r.keymap
--- busybox-1.28.4/examples/var_service/getty_tty1/ru_koi8r.keymap	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/var_service/getty_tty1/ru_koi8r.keymap	1970-01-01 01:00:00.000000000 +0100
@@ -1,183 +0,0 @@
-keymaps 0,1, 2,3, 4,6, 8,10, 12,14
-#
-# This one is for generating koi8r Russian chars
-# Cyr/Lat switches:  RightAlt, Shift+Ctrl, Ctrl+Shift
-# (last one does not work for dark and obscure reasons 8( )
-#
-# plain,shift, plain,shift, ctrl,ctrl alt,alt ctrlalt,ctrlalt
-# lat--------  cyr--------  lat  cyr  lat cyr lat     cyr
-#
-#Shift                     1
-#AltGr (cyr)               2
-#Control                   4
-#Alt                       8
-#ShiftL                   16
-#ShiftR                   32
-#CtrlL                    64
-#CtrlR                   128
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode   1 =   Escape          Escape          Escape          Escape          Escape                  Escape                  Meta_Escape             Meta_Escape             SAK                     SAK
-keycode   2 =   one             exclam          one             exclam          exclam                  exclam                  Meta_one                Meta_one
-keycode   3 =   two             at              two             at              nul                     nul                     Meta_two                Meta_two
-keycode   4 =   three           numbersign      three           numbersign      three                   three                   Meta_three              Meta_three
-keycode   5 =   four            dollar          four            dollar          Control_backslash       Control_backslash       Meta_four               Meta_four
-keycode   6 =   five            percent         five            percent         Control_bracketright    Control_bracketright    Meta_five               Meta_five
-keycode   7 =   six             asciicircum     six             asciicircum     Control_asciicircum     Control_asciicircum     Meta_six                Meta_six
-keycode   8 =   seven           ampersand       seven           ampersand       Control_underscore      Control_underscore      Meta_seven              Meta_seven
-keycode   9 =   eight           asterisk        eight           asterisk        eight                   eight                   Meta_eight              Meta_eight
-keycode  10 =   nine            parenleft       nine            parenleft       nine                    nine                    Meta_nine               Meta_nine
-keycode  11 =   zero            parenright      zero            parenright      zero                    zero                    Meta_zero               Meta_zero
-keycode  12 =   minus           underscore      minus           underscore      Control_underscore      Control_underscore      Meta_minus              Meta_minus
-keycode  13 =   equal           plus            equal           plus            equal                   equal                   Meta_equal              Meta_equal
-keycode  14 =   Delete          Delete          Delete          Delete          BackSpace               BackSpace               Meta_Delete             Meta_Delete
-keycode  15 =   Tab             Tab             Tab             Tab             Tab                     Tab                     Meta_Tab                Meta_Tab
-keycode  16 =   q               Q               202             234             Control_q               Control_q               Meta_q                  Meta_q                  Meta_Control_q          Meta_Control_q
-keycode  17 =   w               W               195             227             Control_w               Control_w               Meta_w                  Meta_w                  Meta_Control_w          Meta_Control_w
-keycode  18 =   e               E               213             245             Control_e               Control_e               Meta_e                  Meta_e                  Meta_Control_e          Meta_Control_e
-keycode  19 =   r               R               203             235             Control_r               Control_r               Meta_r                  Meta_r                  Meta_Control_r          Meta_Control_r
-keycode  20 =   t               T               197             229             Control_t               Control_t               Meta_t                  Meta_t                  Meta_Control_t          Meta_Control_t
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode  21 =   y               Y               206             238             Control_y               Control_y               Meta_y                  Meta_y                  Meta_Control_y          Meta_Control_y
-keycode  22 =   u               U               199             231             Control_u               Control_u               Meta_u                  Meta_u                  Meta_Control_u          Meta_Control_u
-keycode  23 =   i               I               219             251             Control_i               Control_i               Meta_i                  Meta_i                  Meta_Control_i          Meta_Control_i
-keycode  24 =   o               O               221             253             Control_o               Control_o               Meta_o                  Meta_o                  Meta_Control_o          Meta_Control_o
-keycode  25 =   p               P               218             250             Control_p               Control_p               Meta_p                  Meta_p                  Meta_Control_p          Meta_Control_p
-keycode  26 =   bracketleft     braceleft       200             232             Escape                  Escape                  Meta_bracketleft        Meta_bracketleft
-keycode  27 =   bracketright    braceright      223             255             Control_bracketright    Control_bracketright
-keycode  28 =   Return
-# Shift+Ctrl - Cyrillic
-keycode  29 =   Control		AltGr_Lock      Control         AltGr_Lock      Control		        Control		        Control		        Control		        Control		        Control
-keycode  30 =   a               A               198             230             Control_a               Control_a               Meta_a                  Meta_a                  Meta_Control_a          Meta_Control_a
-keycode  31 =   s               S               217             249             Control_s               Control_s               Meta_s                  Meta_s                  Meta_Control_s          Meta_Control_s
-keycode  32 =   d               D               215             247             Control_d               Control_d               Meta_d                  Meta_d                  Meta_Control_d          Meta_Control_d
-keycode  33 =   f               F               193             225             Control_f               Control_f               Meta_f                  Meta_f                  Meta_Control_f          Meta_Control_f
-keycode  34 =   g               G               208             240             Control_g               Control_g               Meta_g                  Meta_g                  Meta_Control_g          Meta_Control_g
-keycode  35 =   h               H               210             242             Control_h               Control_h               Meta_h                  Meta_h                  Meta_Control_h          Meta_Control_h
-keycode  36 =   j               J               207             239             Control_j               Control_j               Meta_j                  Meta_j                  Meta_Control_j          Meta_Control_j
-keycode  37 =   k               K               204             236             Control_k               Control_k               Meta_k                  Meta_k                  Meta_Control_k          Meta_Control_k
-keycode  38 =   l               L               196             228             Control_l               Control_l               Meta_l                  Meta_l                  Meta_Control_l          Meta_Control_l
-keycode  39 =   semicolon       colon           214             246             semicolon               semicolon               Meta_semicolon          Meta_semicolon
-keycode  40 =   apostrophe      quotedbl        220             252             Control_g               Control_g               Meta_apostrophe         Meta_apostrophe
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode  41 =   grave           asciitilde      grave           asciitilde      nul                     nul                     Meta_grave              Meta_grave
-keycode  42 =   Shift
-keycode  43 =   backslash       bar             backslash       bar             Control_backslash       Control_backslash       Meta_backslash          Meta_backslash
-keycode  44 =   z               Z               209             241             Control_z               Control_z               Meta_z                  Meta_z                  Meta_Control_z          Meta_Control_z
-keycode  45 =   x               X               222             254             Control_x               Control_x               Meta_x                  Meta_x                  Meta_Control_x          Meta_Control_x
-keycode  46 =   c               C               211             243             Control_c               Control_c               Meta_c                  Meta_c                  Meta_Control_c          Meta_Control_c
-keycode  47 =   v               V               205             237             Control_v               Control_v               Meta_v                  Meta_v                  Meta_Control_v          Meta_Control_v
-keycode  48 =   b               B               201             233             Control_b               Control_b               Meta_b                  Meta_b                  Meta_Control_b          Meta_Control_b
-keycode  49 =   n               N               212             244             Control_n               Control_n               Meta_n                  Meta_n                  Meta_Control_n          Meta_Control_n
-keycode  50 =   m               M               216             248             Control_m               Control_m               Meta_m                  Meta_m                  Meta_Control_m          Meta_Control_m
-keycode  51 =   comma           less            194             226             comma                   comma                   Meta_comma              Meta_comma
-keycode  52 =   period          greater         192             224             Compose                 Compose                 Meta_period             Meta_period
-keycode  53 =   slash           question        slash           question        Delete                  Delete                  Meta_slash              Meta_slash              Meta_question           Meta_question
-# Ctrl+Shift - Cyrillic (not working???)
-keycode  54 =   Shift           Shift           Shift           Shift           AltGr_Lock              AltGr_Lock              Shift                   Shift                   Shift                   Shift
-keycode  55 =   KP_Multiply
-keycode  56 =   Alt
-keycode  57 =   space           space           space           space           nul                     nul                     Meta_space              Meta_space
-keycode  58 =   Caps_Lock
-keycode  59 =   F1              F11             F1              F11             F1                      F1                      Console_1               Console_1               Console_1               Console_1
-keycode  60 =   F2              F12             F2              F12             F2                      F2                      Console_2               Console_2               Console_2               Console_2
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode  61 =   F3              F13             F3              F13             F3                      F3                      Console_3               Console_3               Console_3               Console_3
-keycode  62 =   F4              F14             F4              F14             F4                      F4                      Console_4               Console_4               Console_4               Console_4
-keycode  63 =   F5              F15             F5              F15             F5                      F5                      Console_5               Console_5               Console_5               Console_5
-keycode  64 =   F6              F16             F6              F16             F6                      F6                      Console_6               Console_6               Console_6               Console_6
-keycode  65 =   F7              F17             F7              F17             F7                      F7                      Console_7               Console_7               Console_7               Console_7
-keycode  66 =   F8              F18             F8              F18             F8                      F8                      Console_8               Console_8               Console_8               Console_8
-keycode  67 =   F9              F19             F9              F19             F9                      F9                      Console_9               Console_9               Console_9               Console_9
-keycode  68 =   F10             F20             F10             F20             F10                     F10                     Console_10              Console_10              Console_10              Console_10
-keycode  69 =   Num_Lock        Bare_Num_Lock   Num_Lock        Bare_Num_Lock
-keycode  70 =   Scroll_Lock     Show_Memory     Scroll_Lock     Show_Memory     Show_State              Show_State
-keycode  71 =   KP_7            KP_7            KP_7            KP_7            KP_7                    KP_7                    Ascii_7                 Ascii_7
-keycode  72 =   KP_8            KP_8            KP_8            KP_8            KP_8                    KP_8                    Ascii_8                 Ascii_8
-keycode  73 =   KP_9            KP_9            KP_9            KP_9            KP_9                    KP_9                    Ascii_9                 Ascii_9
-keycode  74 =   KP_Subtract     KP_Subtract     KP_Subtract     KP_Subtract     KP_Subtract             KP_Subtract             KP_Subtract             KP_Subtract
-keycode  75 =   KP_4            KP_4            KP_4            KP_4            KP_4                    KP_4                    Ascii_4                 Ascii_4
-keycode  76 =   KP_5            KP_5            KP_5            KP_5            KP_5                    KP_5                    Ascii_5                 Ascii_5
-keycode  77 =   KP_6            KP_6            KP_6            KP_6            KP_6                    KP_6                    Ascii_6                 Ascii_6
-keycode  78 =   KP_Add          KP_Add          KP_Add          KP_Add          KP_Add                  KP_Add                  KP_Add                  KP_Add
-keycode  79 =   KP_1            KP_1            KP_1            KP_1            KP_1                    KP_1                    Ascii_1                 Ascii_1
-keycode  80 =   KP_2            KP_2            KP_2            KP_2            KP_2                    KP_2                    Ascii_2                 Ascii_2
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode  81 =   KP_3            KP_3            KP_3            KP_3            KP_3                    KP_3                    Ascii_3                 Ascii_3
-keycode  82 =   KP_0            KP_0            KP_0            KP_0            KP_0                    KP_0                    Ascii_0                 Ascii_0
-keycode  83 =   KP_Period       KP_Period       KP_Period       KP_Period       KP_Period               KP_Period               KP_Period               KP_Period               Boot                    Boot
-keycode  84 =   Last_Console
-keycode  85 =
-keycode  86 =   less            greater         less            greater         less                    less                    Meta_less               Meta_less
-keycode  87 =   F11             F11             F11             F11             F11                     F11                     Console_11              Console_11              Console_11              Console_11
-keycode  88 =   F12             F12             F12             F12             F12                     F12                     Console_12              Console_12              Console_12              Console_12
-keycode  89 =
-keycode  90 =
-keycode  91 =
-keycode  92 =
-keycode  93 =
-keycode  94 =
-keycode  95 =
-keycode  96 =   KP_Enter
-keycode  97 =   Control
-keycode  98 =   KP_Divide
-keycode  99 =   Control_backslash
-# Right Alt - Cyrillic
-keycode 100 =   AltGr_Lock
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode 101 =   Break
-keycode 102 =   Find
-keycode 103 =   Up
-keycode 104 =   Prior           Scroll_Backward Prior           Scroll_Backward Prior                   Prior                   Prior                   Prior                   Prior                   Prior
-keycode 105 =   Left            Left            Left            Left            Left                    Left                    Left                    Left                    Decr_Console            Decr_Console
-keycode 106 =   Right           Right           Right           Right           Right                   Right                   Right                   Right                   Incr_Console            Incr_Console
-keycode 107 =   Select
-keycode 108 =   Down
-keycode 109 =   Next            Scroll_Forward  Next            Scroll_Forward  Next                    Next                    Next                    Next                    Next                    Next
-keycode 110 =   Insert
-keycode 111 =   Remove          Remove          Remove          Remove          Remove                  Remove                  Remove                  Remove                  Boot                    Boot
-keycode 112 =   Macro
-keycode 113 =   F13
-keycode 114 =   F14
-keycode 115 =   Help
-keycode 116 =   Do
-keycode 117 =   F17
-keycode 118 =   KP_MinPlus
-keycode 119 =   Pause
-keycode 120 =
-#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
-keycode 121 =
-keycode 122 =
-keycode 123 =
-keycode 124 =
-keycode 125 =
-keycode 126 =
-keycode 127 =
-
-string F1 = "\033[[A"
-string F2 = "\033[[B"
-string F3 = "\033[[C"
-string F4 = "\033[[D"
-string F5 = "\033[[E"
-string F6 = "\033[17~"
-string F7 = "\033[18~"
-string F8 = "\033[19~"
-string F9 = "\033[20~"
-string F10 = "\033[21~"
-string F11 = "\033[23~"
-string F12 = "\033[24~"
-string F13 = "\033[25~"
-string F14 = "\033[26~"
-string F15 = "\033[28~"
-string F16 = "\033[29~"
-string F17 = "\033[31~"
-string F18 = "\033[32~"
-string F19 = "\033[33~"
-string F20 = "\033[34~"
-string Find = "\033[1~"
-string Insert = "\033[2~"
-string Remove = "\033[3~"
-string Select = "\033[4~"
-string Prior = "\033[5~"
-string Next = "\033[6~"
-string Macro = "\033[M"
-string Pause = "\033[P"
diff -urpN busybox-1.28.4/examples/var_service/getty_tty1/run busybox-1.29.0/examples/var_service/getty_tty1/run
--- busybox-1.28.4/examples/var_service/getty_tty1/run	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/var_service/getty_tty1/run	2018-07-02 15:55:14.000000000 +0200
@@ -1,9 +1,5 @@
 #!/bin/sh
 
-exec >/dev/null
-exec 2>&1
-exec </dev/null
-
 user=root
 baud=38400
 delay=3
@@ -25,6 +21,4 @@ test -x ./cfg && . ./cfg
 
 exec \
 env - "TERM=$TERM" PATH="$PATH" LOGIN_PRE_SUID_SCRIPT="$PWD/login.sh" \
-softlimit \
-setuidgid "$user" \
 getty "$baud" "$tty" "$TERM"
diff -urpN busybox-1.28.4/examples/var_service/getty_tty1/unicode_cyrillic.keymap busybox-1.29.0/examples/var_service/getty_tty1/unicode_cyrillic.keymap
--- busybox-1.28.4/examples/var_service/getty_tty1/unicode_cyrillic.keymap	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/examples/var_service/getty_tty1/unicode_cyrillic.keymap	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,200 @@
+keymaps 0,1, 2,3, 4,6, 8,9, 10,11, 12,14
+#
+# This one is for generating Unicode Curillic chars
+# Cyr/Lat switches: RightAlt, Shift+Ctrl, Ctrl+Shift, Win keys
+#
+# plain,shift, plain,shift, ctrl,ctrl alt,shiftalt alt,shiftalt ctrlalt,ctrlalt
+# lat--------  cyr--------  lat  cyr  lat--------- cyr--------- lat     cyr
+#
+#Shift                     1
+#AltGr (cyr)               2
+#Control                   4
+#Alt                       8
+#ShiftL                   16
+#ShiftR                   32
+#CtrlL                    64
+#CtrlR                   128
+
+# L/R Ctrl: Shift+Ctrl - Cyrillic
+keycode  29 =   Control		AltGr_Lock      Control         AltGr_Lock      Control		        Control		        Control		        Control		        Control		        Control		        Control		        Control
+keycode  97 =   Control		AltGr_Lock      Control         AltGr_Lock      Control		        Control		        Control		        Control		        Control		        Control		        Control		        Control
+# L/R Shift: Ctrl+Shift - Cyrillic
+keycode  42 =   Shift           Shift           Shift           Shift           AltGr_Lock              AltGr_Lock              Shift                   Shift                   Shift                   Shift                   Shift                   Shift
+keycode  54 =   Shift           Shift           Shift           Shift           AltGr_Lock              AltGr_Lock              Shift                   Shift                   Shift                   Shift                   Shift                   Shift
+# Right Alt: Cyrillic
+keycode 100 =   AltGr_Lock
+# L/R Win: Cyrillic
+keycode 125 =   AltGr_Lock
+keycode 126 =   AltGr_Lock
+
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt shift ============= alt cyr =============== alt shift cur ========= ctrlalt =============== ctrlalt cyr ===========
+keycode   1 =   Escape          Escape          Escape          Escape          Escape                  Escape                  Meta_Escape             Meta_Escape             Meta_Escape             Meta_Escape             SAK                     SAK
+keycode   2 =   one             exclam          one             exclam          exclam                  exclam                  Meta_one                Meta_one                Meta_one                Meta_one
+keycode   3 =   two             at              two             at              nul                     nul                     Meta_two                Meta_two                Meta_two                Meta_two
+keycode   4 =   three           numbersign      three           numbersign      three                   three                   Meta_three              Meta_three              Meta_three              Meta_three
+keycode   5 =   four            dollar          four            dollar          Control_backslash       Control_backslash       Meta_four               Meta_four               Meta_four               Meta_four
+keycode   6 =   five            percent         five            percent         Control_bracketright    Control_bracketright    Meta_five               Meta_five               Meta_five               Meta_five
+keycode   7 =   six             asciicircum     six             asciicircum     Control_asciicircum     Control_asciicircum     Meta_six                Meta_six                Meta_six                Meta_six
+keycode   8 =   seven           ampersand       seven           ampersand       Control_underscore      Control_underscore      Meta_seven              Meta_seven              Meta_seven              Meta_seven
+keycode   9 =   eight           asterisk        eight           asterisk        eight                   eight                   Meta_eight              Meta_eight              Meta_eight              Meta_eight
+keycode  10 =   nine            parenleft       nine            parenleft       nine                    nine                    Meta_nine               Meta_nine               Meta_nine               Meta_nine
+keycode  11 =   zero            parenright      zero            parenright      zero                    zero                    Meta_zero               Meta_zero               Meta_zero               Meta_zero
+keycode  12 =   minus           underscore      minus           underscore      Control_underscore      Control_underscore      Meta_minus              Meta_minus              Meta_minus              Meta_minus
+keycode  13 =   equal           plus            equal           plus            equal                   equal                   Meta_equal              Meta_equal              Meta_equal              Meta_equal
+keycode  14 =   Delete          Delete          Delete          Delete          BackSpace               BackSpace               Meta_Delete             Meta_Delete             Meta_Delete             Meta_Delete
+keycode  15 =   Tab             Tab             Tab             Tab             Tab                     Tab                     Meta_Tab                Meta_Tab                Meta_Tab                Meta_Tab
+keycode  16 =   +q              +Q              +U+0439         +U+0419         Control_q               Control_q               Meta_q                  Meta_q                  Meta_q                  Meta_q                  Meta_Control_q          Meta_Control_q
+keycode  17 =   +w              +W              +U+0446         +U+0426         Control_w               Control_w               Meta_w                  Meta_w                  Meta_w                  Meta_w                  Meta_Control_w          Meta_Control_w
+keycode  18 =   +e              +E              +U+0443         +U+0423         Control_e               Control_e               Meta_e                  Meta_e                  Meta_e                  Meta_e                  Meta_Control_e          Meta_Control_e
+keycode  19 =   +r              +R              +U+043a         +U+041a         Control_r               Control_r               Meta_r                  Meta_r                  Meta_r                  Meta_r                  Meta_Control_r          Meta_Control_r
+keycode  20 =   +t              +T              +U+0435         +U+0415         Control_t               Control_t               Meta_t                  Meta_t                  Meta_t                  Meta_t                  Meta_Control_t          Meta_Control_t
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt =================== alt cyr =============== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
+keycode  21 =   +y              +Y              +U+043d         +U+041d         Control_y               Control_y               Meta_y                  Meta_y                  Meta_y                  Meta_y                  Meta_Control_y          Meta_Control_y
+keycode  22 =   +u              +U              +U+0433         +U+0413         Control_u               Control_u               Meta_u                  Meta_u                  Meta_u                  Meta_u                  Meta_Control_u          Meta_Control_u
+keycode  23 =   +i              +I              +U+0448         +U+0428         Control_i               Control_i               Meta_i                  Meta_i                  Meta_i                  Meta_i                  Meta_Control_i          Meta_Control_i
+keycode  24 =   +o              +O              +U+0449         +U+0429         Control_o               Control_o               Meta_o                  Meta_o                  Meta_o                  Meta_o                  Meta_Control_o          Meta_Control_o
+keycode  25 =   +p              +P              +U+0437         +U+0417         Control_p               Control_p               Meta_p                  Meta_p                  Meta_p                  Meta_p                  Meta_Control_p          Meta_Control_p
+keycode  26 =   bracketleft     braceleft       +U+0445         +U+0425         Escape                  Escape                  Meta_bracketleft        Meta_bracketleft        Meta_bracketleft        Meta_bracketleft
+keycode  27 =   bracketright    braceright      +U+044a         +U+042a         Control_bracketright    Control_bracketright
+keycode  28 =   Return
+# LCtrl
+#keycode  29 =
+keycode  30 =   +a              +A              +U+0444         +U+0424         Control_a               Control_a               Meta_a                  Meta_a                  Meta_a                  Meta_a                  Meta_Control_a          Meta_Control_a
+keycode  31 =   +s              +S              +U+044b         +U+042b         Control_s               Control_s               Meta_s                  Meta_s                  Meta_s                  Meta_s                  Meta_Control_s          Meta_Control_s
+keycode  32 =   +d              +D              +U+0432         +U+0412         Control_d               Control_d               Meta_d                  Meta_d                  Meta_d                  Meta_d                  Meta_Control_d          Meta_Control_d
+keycode  33 =   +f              +F              +U+0430         +U+0410         Control_f               Control_f               Meta_f                  Meta_f                  Meta_f                  Meta_f                  Meta_Control_f          Meta_Control_f
+keycode  34 =   +g              +G              +U+043f         +U+041f         Control_g               Control_g               Meta_g                  Meta_g                  Meta_g                  Meta_g                  Meta_Control_g          Meta_Control_g
+keycode  35 =   +h              +H              +U+0440         +U+0420         Control_h               Control_h               Meta_h                  Meta_h                  Meta_h                  Meta_h                  Meta_Control_h          Meta_Control_h
+keycode  36 =   +j              +J              +U+043e         +U+041e         Control_j               Control_j               Meta_j                  Meta_j                  Meta_j                  Meta_j                  Meta_Control_j          Meta_Control_j
+keycode  37 =   +k              +K              +U+043b         +U+041b         Control_k               Control_k               Meta_k                  Meta_k                  Meta_k                  Meta_k                  Meta_Control_k          Meta_Control_k
+keycode  38 =   +l              +L              +U+0434         +U+0414         Control_l               Control_l               Meta_l                  Meta_l                  Meta_l                  Meta_l                  Meta_Control_l          Meta_Control_l
+keycode  39 =   semicolon       colon           +U+0436         +U+0416         semicolon               semicolon               Meta_semicolon          Meta_semicolon          Meta_semicolon          Meta_semicolon
+keycode  40 =   apostrophe      quotedbl        +U+044d         +U+042d         Control_g               Control_g               Meta_apostrophe         Meta_apostrophe         Meta_apostrophe         Meta_apostrophe
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt =================== alt cyr =============== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
+keycode  41 =   grave           asciitilde      grave           asciitilde      nul                     nul                     Meta_grave              Meta_grave              Meta_grave              Meta_grave
+# LShift
+#keycode  42 =
+keycode  43 =   backslash       bar             backslash       bar             Control_backslash       Control_backslash       Meta_backslash          Meta_backslash          Meta_backslash          Meta_backslash
+keycode  44 =   +z              +Z              +U+044f         +U+042f         Control_z               Control_z               Meta_z                  Meta_z                  Meta_z                  Meta_z                  Meta_Control_z          Meta_Control_z
+keycode  45 =   +x              +X              +U+0447         +U+0427         Control_x               Control_x               Meta_x                  Meta_x                  Meta_x                  Meta_x                  Meta_Control_x          Meta_Control_x
+keycode  46 =   +c              +C              +U+0441         +U+0421         Control_c               Control_c               Meta_c                  Meta_c                  Meta_c                  Meta_c                  Meta_Control_c          Meta_Control_c
+keycode  47 =   +v              +V              +U+043c         +U+041c         Control_v               Control_v               Meta_v                  Meta_v                  Meta_v                  Meta_v                  Meta_Control_v          Meta_Control_v
+keycode  48 =   +b              +B              +U+0438         +U+0418         Control_b               Control_b               Meta_b                  Meta_b                  Meta_b                  Meta_b                  Meta_Control_b          Meta_Control_b
+keycode  49 =   +n              +N              +U+0442         +U+0422         Control_n               Control_n               Meta_n                  Meta_n                  Meta_n                  Meta_n                  Meta_Control_n          Meta_Control_n
+keycode  50 =   +m              +M              +U+044c         +U+042c         Control_m               Control_m               Meta_m                  Meta_m                  Meta_m                  Meta_m                  Meta_Control_m          Meta_Control_m
+keycode  51 =   comma           less            +U+0431         +U+0411         comma                   comma                   Meta_comma              Meta_comma              Meta_comma              Meta_comma
+keycode  52 =   period          greater         +U+044e         +U+042e         Compose                 Compose                 Meta_period             Meta_period             Meta_period             Meta_period
+keycode  53 =   slash           question        slash           question        Delete                  Delete                  Meta_slash              Meta_question           Meta_slash              Meta_question           Meta_question           Meta_question
+# RShift
+#keycode  54 =
+keycode  55 =   KP_Multiply
+keycode  56 =   Alt
+keycode  57 =   space           space           space           space           nul                     nul                     Meta_space              Meta_space              Meta_space              Meta_space
+keycode  58 =   Caps_Lock
+keycode  59 =   F1              F11             F1              F11             F1                      F1                      Console_1               Console_1               Console_1               Console_1               Console_1               Console_1
+keycode  60 =   F2              F12             F2              F12             F2                      F2                      Console_2               Console_2               Console_2               Console_2               Console_2               Console_2
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt =================== alt cyr =============== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
+keycode  61 =   F3              F13             F3              F13             F3                      F3                      Console_3               Console_3               Console_3               Console_3               Console_3               Console_3
+keycode  62 =   F4              F14             F4              F14             F4                      F4                      Console_4               Console_4               Console_4               Console_4               Console_4               Console_4
+keycode  63 =   F5              F15             F5              F15             F5                      F5                      Console_5               Console_5               Console_5               Console_5               Console_5               Console_5
+keycode  64 =   F6              F16             F6              F16             F6                      F6                      Console_6               Console_6               Console_6               Console_6               Console_6               Console_6
+keycode  65 =   F7              F17             F7              F17             F7                      F7                      Console_7               Console_7               Console_7               Console_7               Console_7               Console_7
+keycode  66 =   F8              F18             F8              F18             F8                      F8                      Console_8               Console_8               Console_8               Console_8               Console_8               Console_8
+keycode  67 =   F9              F19             F9              F19             F9                      F9                      Console_9               Console_9               Console_9               Console_9               Console_9               Console_9
+keycode  68 =   F10             F20             F10             F20             F10                     F10                     Console_10              Console_10              Console_10              Console_10              Console_10              Console_10
+keycode  69 =   Num_Lock        Bare_Num_Lock   Num_Lock        Bare_Num_Lock
+keycode  70 =   Scroll_Lock     Show_Memory     Scroll_Lock     Show_Memory     Show_State              Show_State
+keycode  71 =   KP_7            KP_7            KP_7            KP_7            KP_7                    KP_7                    Ascii_7                 Ascii_7                 Ascii_7                 Ascii_7
+keycode  72 =   KP_8            KP_8            KP_8            KP_8            KP_8                    KP_8                    Ascii_8                 Ascii_8                 Ascii_8                 Ascii_8
+keycode  73 =   KP_9            KP_9            KP_9            KP_9            KP_9                    KP_9                    Ascii_9                 Ascii_9                 Ascii_9                 Ascii_9
+keycode  74 =   KP_Subtract     KP_Subtract     KP_Subtract     KP_Subtract     KP_Subtract             KP_Subtract             KP_Subtract             KP_Subtract             KP_Subtract             KP_Subtract
+keycode  75 =   KP_4            KP_4            KP_4            KP_4            KP_4                    KP_4                    Ascii_4                 Ascii_4                 Ascii_4                 Ascii_4
+keycode  76 =   KP_5            KP_5            KP_5            KP_5            KP_5                    KP_5                    Ascii_5                 Ascii_5                 Ascii_5                 Ascii_5
+keycode  77 =   KP_6            KP_6            KP_6            KP_6            KP_6                    KP_6                    Ascii_6                 Ascii_6                 Ascii_6                 Ascii_6
+keycode  78 =   KP_Add          KP_Add          KP_Add          KP_Add          KP_Add                  KP_Add                  KP_Add                  KP_Add                  KP_Add                  KP_Add
+keycode  79 =   KP_1            KP_1            KP_1            KP_1            KP_1                    KP_1                    Ascii_1                 Ascii_1                 Ascii_1                 Ascii_1
+keycode  80 =   KP_2            KP_2            KP_2            KP_2            KP_2                    KP_2                    Ascii_2                 Ascii_2                 Ascii_2                 Ascii_2
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt =================== alt cyr =============== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
+keycode  81 =   KP_3            KP_3            KP_3            KP_3            KP_3                    KP_3                    Ascii_3                 Ascii_3                 Ascii_3                 Ascii_3
+keycode  82 =   KP_0            KP_0            KP_0            KP_0            KP_0                    KP_0                    Ascii_0                 Ascii_0                 Ascii_0                 Ascii_0
+keycode  83 =   KP_Period       KP_Period       KP_Period       KP_Period       KP_Period               KP_Period               KP_Period               KP_Period               KP_Period               KP_Period               Boot                    Boot
+keycode  84 =   Last_Console
+keycode  85 =
+keycode  86 =   less            greater         less            greater         less                    less                    Meta_less               Meta_less               Meta_less               Meta_less
+keycode  87 =   F11             F11             F11             F11             F11                     F11                     Console_11              Console_11              Console_11              Console_11              Console_11              Console_11
+keycode  88 =   F12             F12             F12             F12             F12                     F12                     Console_12              Console_12              Console_12              Console_12              Console_12              Console_12
+keycode  89 =
+keycode  90 =
+keycode  91 =
+keycode  92 =
+keycode  93 =
+keycode  94 =
+keycode  95 =
+keycode  96 =   KP_Enter
+# RControl
+#keycode  97 =
+keycode  98 =   KP_Divide
+keycode  99 =   Control_backslash
+# RAlt
+#keycode 100 =
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt shift ============= alt cyr =============== alt shift cyr ========= ctrlalt =============== ctrlalt cyr ===========
+keycode 101 =   Break
+keycode 102 =   Find
+keycode 103 =   Up
+keycode 104 =   Prior           Scroll_Backward Prior           Scroll_Backward Prior                   Prior                   Prior                   Prior                   Prior                   Prior                   Prior                   Prior
+keycode 105 =   Left            Left            Left            Left            Left                    Left                    Left                    Left                    Left                    Left                    Decr_Console            Decr_Console
+keycode 106 =   Right           Right           Right           Right           Right                   Right                   Right                   Right                   Right                   Right                   Incr_Console            Incr_Console
+keycode 107 =   Select
+keycode 108 =   Down
+keycode 109 =   Next            Scroll_Forward  Next            Scroll_Forward  Next                    Next                    Next                    Next                    Next                    Next                    Next                    Next
+keycode 110 =   Insert
+keycode 111 =   Remove          Remove          Remove          Remove          Remove                  Remove                  Remove                  Remove                  Remove                  Remove                  Boot                    Boot
+keycode 112 =   Macro
+keycode 113 =   F13
+keycode 114 =   F14
+keycode 115 =   Help
+keycode 116 =   Do
+keycode 117 =   F17
+keycode 118 =   KP_MinPlus
+keycode 119 =   Pause
+keycode 120 =
+#============== plain ========= shift========== plain cyr ===== shift cyr ===== ctrl ================== ctrl cyr ============== alt =================== alt =================== alt cyr =============== alt cyr =============== ctrlalt =============== ctrlalt cyr ===========
+keycode 121 =
+keycode 122 =
+keycode 123 =
+keycode 124 =
+# LWin
+#keycode 125 =
+# RWin
+#keycode 126 =
+# RMenu
+keycode 127 =
+
+string F1 = "\033[[A"
+string F2 = "\033[[B"
+string F3 = "\033[[C"
+string F4 = "\033[[D"
+string F5 = "\033[[E"
+string F6 = "\033[17~"
+string F7 = "\033[18~"
+string F8 = "\033[19~"
+string F9 = "\033[20~"
+string F10 = "\033[21~"
+string F11 = "\033[23~"
+string F12 = "\033[24~"
+string F13 = "\033[25~"
+string F14 = "\033[26~"
+string F15 = "\033[28~"
+string F16 = "\033[29~"
+string F17 = "\033[31~"
+string F18 = "\033[32~"
+string F19 = "\033[33~"
+string F20 = "\033[34~"
+string Find = "\033[1~"
+string Insert = "\033[2~"
+string Remove = "\033[3~"
+string Select = "\033[4~"
+string Prior = "\033[5~"
+string Next = "\033[6~"
+string Macro = "\033[M"
+string Pause = "\033[P"
diff -urpN busybox-1.28.4/examples/var_service/ifplugd_if/ifplugd_handler busybox-1.29.0/examples/var_service/ifplugd_if/ifplugd_handler
--- busybox-1.28.4/examples/var_service/ifplugd_if/ifplugd_handler	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/var_service/ifplugd_if/ifplugd_handler	2018-07-02 15:55:14.000000000 +0200
@@ -3,13 +3,18 @@
 # $1: interface
 # $2: state
 
-if test -d "/var/service/dhcp_$1"; then
-	if test x"$2" = x"down"; then
-		echo "Downing /var/service/dhcp_$1"
-		sv d "/var/service/dhcp_$1"
-	fi
-	if test x"$2" = x"up"; then
-		echo "Upping /var/service/dhcp_$1"
-		sv u "/var/service/dhcp_$1"
-	fi
+if test x"$2" = x"down"; then
+	echo "Downing dhcp_$1"
+	svc -d "dhcp_$1"
+	echo "Downing zcip_$1"
+	svc -d "zcip_$1"
 fi
+if test x"$2" = x"up"; then
+	echo "Upping dhcp_$1"
+	svc -u "dhcp_$1"
+	echo "Upping zcip_$1"
+	svc -u "zcip_$1"
+fi
+# Parent ifplugd exits if we exit with nonzero.
+# Do not startle it:
+exit 0
diff -urpN busybox-1.28.4/examples/var_service/ifplugd_if/run busybox-1.29.0/examples/var_service/ifplugd_if/run
--- busybox-1.28.4/examples/var_service/ifplugd_if/run	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/examples/var_service/ifplugd_if/run	2018-07-02 15:55:14.000000000 +0200
@@ -16,7 +16,7 @@ exec \
 env - PATH="$PATH" \
 softlimit \
 setuidgid root \
-ifplugd -apqns -t3 -u8 -d8 -i "$if" -r "$pwd/ifplugd_handler"
+ifplugd -aqlns -t3 -u8 -d8 -i "$if" -r "$pwd/ifplugd_handler"
 
 # We use -t3 to wake ifplugd up less often.
 # If after three tests (3*3=9 > 8) link state seen to be different,
@@ -24,19 +24,26 @@ ifplugd -apqns -t3 -u8 -d8 -i "$if" -r "
 # IOW: short link losses will be ignored, longer ones
 # will trigger DHCP reconfiguration and such (see handler code).
 
-#-a       Do not up interface automatically
-#-p       Dont run script on daemon startup
-#-q       Dont run script on daemon quit
+# -l makes ifplugd run either "up" or "down" script on startup.
+# For example, if wired eth cable is unplugged, this stops dhcp service
+# from pointlessly trying to get a lease.
+# -q means that stopping monitoring does not stop dhcp/zcip/etc:
+# presumably, admin decided to control them manually.
+
+#-a       Don't up interface automatically
+#-p       Don't run "up" script on startup
+#-q       Don't run "down" script on exit
+#-l       Always run script on startup
 #-n       Do not daemonize
 #-s       Do not log to syslog
 #-t SECS  Poll time in seconds
 #-u SECS  Delay before running script after link up
 #-d SECS  Delay after link down
 #-i IFACE Interface
-#-r PROG  Script to run
-#-f/-F    Treat link detection error as link down/link up (otherwise exit on error)
 #-M       Monitor creation/destruction of interface (otherwise it must exist)
+#-r PROG  Script to run
 #-x ARG   Extra argument for script
-#-I       Dont exit on nonzero exit code from script
-#-l       Run script on startup even if no cable is detected
+#-I       Don't exit on nonzero exit code from script
+#-f/-F    Treat link detection error as link down/link up (otherwise exit on error)
 #-m MODE  API mode (mii, priv, ethtool, wlan, auto)
+#-k       Kill running daemon
diff -urpN busybox-1.28.4/examples/var_service/tftpd/run busybox-1.29.0/examples/var_service/tftpd/run
--- busybox-1.28.4/examples/var_service/tftpd/run	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/examples/var_service/tftpd/run	2018-07-02 15:55:14.000000000 +0200
@@ -7,7 +7,7 @@ exec </dev/null
 user=root # for bind to port 69
 
 exec \
-env - \
+env - PATH="$PATH" \
 softlimit \
 setuidgid "$user" \
 udpsvd -v -c 10 -l localhost \
diff -urpN busybox-1.28.4/findutils/Config.src busybox-1.29.0/findutils/Config.src
--- busybox-1.28.4/findutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/findutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Finding Utilities"
diff -urpN busybox-1.28.4/findutils/find.c busybox-1.29.0/findutils/find.c
--- busybox-1.28.4/findutils/find.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/findutils/find.c	2018-07-02 15:55:14.000000000 +0200
@@ -263,7 +263,7 @@
 //usage:     "\n	-regex PATTERN	Match path to regex PATTERN"
 //usage:	)
 //usage:	IF_FEATURE_FIND_TYPE(
-//usage:     "\n	-type X		File type is X (one of: f,d,l,b,c,...)"
+//usage:     "\n	-type X		File type is X (one of: f,d,l,b,c,s,p)"
 //usage:	)
 //usage:	IF_FEATURE_FIND_PERM(
 //usage:     "\n	-perm MASK	At least one mask bit (+MASK), all bits (-MASK),"
diff -urpN busybox-1.28.4/findutils/xargs.c busybox-1.29.0/findutils/xargs.c
--- busybox-1.28.4/findutils/xargs.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/findutils/xargs.c	2018-07-02 15:55:14.000000000 +0200
@@ -496,16 +496,16 @@ static char* FAST_FUNC process_stdin_wit
 static int xargs_ask_confirmation(void)
 {
 	FILE *tty_stream;
-	int c, savec;
+	int r;
 
 	tty_stream = xfopen_for_read(CURRENT_TTY);
+
 	fputs(" ?...", stderr);
-	fflush_all();
-	c = savec = getc(tty_stream);
-	while (c != EOF && c != '\n')
-		c = getc(tty_stream);
+	r = bb_ask_y_confirmation_FILE(tty_stream);
+
 	fclose(tty_stream);
-	return (savec == 'y' || savec == 'Y');
+
+	return r;
 }
 #else
 # define xargs_ask_confirmation() 1
diff -urpN busybox-1.28.4/include/bb_archive.h busybox-1.29.0/include/bb_archive.h
--- busybox-1.28.4/include/bb_archive.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/include/bb_archive.h	2018-07-02 15:55:14.000000000 +0200
@@ -64,8 +64,8 @@ typedef struct archive_handle_t {
 	/* Currently processed file's header */
 	file_header_t *file_header;
 
-	/* List of symlink placeholders */
-	llist_t *symlink_placeholders;
+	/* List of link placeholders */
+	llist_t *link_placeholders;
 
 	/* Process the header component, e.g. tar -t */
 	void FAST_FUNC (*action_header)(const file_header_t *);
@@ -117,6 +117,10 @@ typedef struct archive_handle_t {
 	const char *ar__name;
 	struct archive_handle_t *ar__out;
 #endif
+#if ENABLE_FEATURE_AR_LONG_FILENAMES
+	char *ar__long_names;
+	unsigned ar__long_name_size;
+#endif
 } archive_handle_t;
 /* bits in ah_flags */
 #define ARCHIVE_RESTORE_DATE        (1 << 0)
@@ -199,10 +203,11 @@ void seek_by_jump(int fd, off_t amount)
 void seek_by_read(int fd, off_t amount) FAST_FUNC;
 
 const char *strip_unsafe_prefix(const char *str) FAST_FUNC;
-void create_or_remember_symlink(llist_t **symlink_placeholders,
+void create_or_remember_link(llist_t **link_placeholders,
 		const char *target,
-		const char *linkname) FAST_FUNC;
-void create_symlinks_from_list(llist_t *list) FAST_FUNC;
+		const char *linkname,
+		int hard_link) FAST_FUNC;
+void create_links_from_list(llist_t *list) FAST_FUNC;
 
 void data_align(archive_handle_t *archive_handle, unsigned boundary) FAST_FUNC;
 const llist_t *find_list_entry(const llist_t *list, const char *filename) FAST_FUNC;
@@ -210,7 +215,7 @@ const llist_t *find_list_entry2(const ll
 
 /* A bit of bunzip2 internals are exposed for compressed help support: */
 typedef struct bunzip_data bunzip_data;
-int start_bunzip(bunzip_data **bdp, int in_fd, const void *inbuf, int len) FAST_FUNC;
+int start_bunzip(void *, bunzip_data **bdp, int in_fd, const void *inbuf, int len) FAST_FUNC;
 /* NB: read_bunzip returns < 0 on error, or the number of *unfilled* bytes
  * in outbuf. IOW: on EOF returns len ("all bytes are not filled"), not 0: */
 int read_bunzip(bunzip_data *bd, char *outbuf, int len) FAST_FUNC;
@@ -255,6 +260,21 @@ int bbunpack(char **argv,
 		char* FAST_FUNC (*make_new_name)(char *filename, const char *expected_ext),
 		const char *expected_ext
 ) FAST_FUNC;
+#define BBUNPK_OPTSTR "cfkvq"
+#define BBUNPK_OPTSTRLEN  5
+#define BBUNPK_OPTSTRMASK ((1 << BBUNPK_OPTSTRLEN) - 1)
+enum {
+	BBUNPK_OPT_STDOUT     = 1 << 0,
+	BBUNPK_OPT_FORCE      = 1 << 1,
+	/* only some decompressors: */
+	BBUNPK_OPT_KEEP       = 1 << 2,
+	BBUNPK_OPT_VERBOSE    = 1 << 3,
+	BBUNPK_OPT_QUIET      = 1 << 4,
+	/* not included in BBUNPK_OPTSTR: */
+	BBUNPK_OPT_DECOMPRESS = 1 << 5,
+	BBUNPK_OPT_TEST       = 1 << 6,
+	BBUNPK_SEAMLESS_MAGIC = (1 << 31) * ENABLE_ZCAT * SEAMLESS_COMPRESSION,
+};
 
 void check_errors_in_children(int signo);
 #if BB_MMU
diff -urpN busybox-1.28.4/include/libbb.h busybox-1.29.0/include/libbb.h
--- busybox-1.28.4/include/libbb.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/include/libbb.h	2018-07-02 15:55:14.000000000 +0200
@@ -41,6 +41,7 @@
 #include <poll.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
+#include <sys/resource.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/time.h>
@@ -484,6 +485,7 @@ DIR *xopendir(const char *path) FAST_FUN
 DIR *warn_opendir(const char *path) FAST_FUNC;
 
 char *xmalloc_realpath(const char *path) FAST_FUNC RETURNS_MALLOC;
+char *xmalloc_realpath_coreutils(const char *path) FAST_FUNC RETURNS_MALLOC;
 char *xmalloc_readlink(const char *path) FAST_FUNC RETURNS_MALLOC;
 char *xmalloc_readlink_or_warn(const char *path) FAST_FUNC RETURNS_MALLOC;
 /* !RETURNS_MALLOC: it's a realloc-like function */
@@ -636,8 +638,14 @@ void setsockopt_reuseaddr(int fd) FAST_F
 int setsockopt_keepalive(int fd) FAST_FUNC;
 int setsockopt_broadcast(int fd) FAST_FUNC;
 int setsockopt_bindtodevice(int fd, const char *iface) FAST_FUNC;
+int bb_getsockname(int sockfd, void *addr, socklen_t addrlen) FAST_FUNC;
 /* NB: returns port in host byte order */
 unsigned bb_lookup_port(const char *port, const char *protocol, unsigned default_port) FAST_FUNC;
+#if ENABLE_FEATURE_ETC_SERVICES
+# define bb_lookup_std_port(portstr, protocol, portnum) bb_lookup_port(portstr, protocol, portnum)
+#else
+# define bb_lookup_std_port(portstr, protocol, portnum) (portnum)
+#endif
 typedef struct len_and_sockaddr {
 	socklen_t len;
 	union {
@@ -772,7 +780,8 @@ static inline tls_state_t *new_tls_state
 	return tls;
 }
 void tls_handshake(tls_state_t *tls, const char *sni) FAST_FUNC;
-void tls_run_copy_loop(tls_state_t *tls) FAST_FUNC;
+#define TLSLOOP_EXIT_ON_LOCAL_EOF (1 << 0)
+void tls_run_copy_loop(tls_state_t *tls, unsigned flags) FAST_FUNC;
 
 
 void socket_want_pktinfo(int fd) FAST_FUNC;
@@ -786,6 +795,7 @@ ssize_t recv_from_to(int fd, void *buf,
 		socklen_t sa_size) FAST_FUNC;
 
 uint16_t inet_cksum(uint16_t *addr, int len) FAST_FUNC;
+int parse_pasv_epsv(char *buf) FAST_FUNC;
 
 /* 0 if argv[0] is NULL: */
 unsigned string_array_len(char **argv) FAST_FUNC;
@@ -908,7 +918,7 @@ extern void xprint_and_close_file(FILE *
  * end of line. If end isn't NULL, length of the chunk is stored in it.
  * Returns NULL if EOF/error.
  */
-extern char *bb_get_chunk_from_file(FILE *file, int *end) FAST_FUNC;
+extern char *bb_get_chunk_from_file(FILE *file, size_t *end) FAST_FUNC;
 /* Reads up to (and including) TERMINATING_STRING: */
 extern char *xmalloc_fgets_str(FILE *file, const char *terminating_string) FAST_FUNC RETURNS_MALLOC;
 /* Same, with limited max size, and returns the length (excluding NUL): */
@@ -1274,20 +1284,21 @@ extern smallint syslog_level;
 extern smallint logmode;
 extern uint8_t xfunc_error_retval;
 extern void (*die_func)(void);
-extern void xfunc_die(void) NORETURN FAST_FUNC;
-extern void bb_show_usage(void) NORETURN FAST_FUNC;
-extern void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
-extern void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
-extern void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
-extern void bb_simple_perror_msg(const char *s) FAST_FUNC;
-extern void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
-extern void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
-extern void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
-extern void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
-extern void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
-extern void bb_perror_nomsg(void) FAST_FUNC;
-extern void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
-extern void bb_logenv_override(void) FAST_FUNC;
+void xfunc_die(void) NORETURN FAST_FUNC;
+void bb_show_usage(void) NORETURN FAST_FUNC;
+void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_perror_msg(const char *s) FAST_FUNC;
+void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
+void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
+void bb_perror_nomsg(void) FAST_FUNC;
+void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
+void bb_die_memory_exhausted(void) NORETURN FAST_FUNC;
+void bb_logenv_override(void) FAST_FUNC;
 
 /* We need to export XXX_main from libbusybox
  * only if we build "individual" binaries
@@ -1364,7 +1375,7 @@ struct hwtype {
 	int   FAST_FUNC (*activate)(int fd);
 	int suppress_null_addr;
 };
-extern smallint interface_opt_a;
+#define IFNAME_SHOW_DOWNED_TOO ((char*)(intptr_t)1)
 int display_interfaces(char *ifname) FAST_FUNC;
 int in_ether(const char *bufp, struct sockaddr *sap) FAST_FUNC;
 #if ENABLE_FEATURE_HWIB
@@ -1404,11 +1415,13 @@ extern int set_loop(char **devname, cons
 #define BB_LO_FLAGS_READ_ONLY 1
 #define BB_LO_FLAGS_AUTOCLEAR 4
 
-/* Like bb_ask below, but asks on stdin with no timeout.  */
-char *bb_ask_stdin(const char * prompt) FAST_FUNC;
-//TODO: pass buf pointer or return allocated buf (avoid statics)?
-char *bb_ask(const int fd, int timeout, const char * prompt) FAST_FUNC;
-int bb_ask_confirmation(void) FAST_FUNC;
+/* Returns malloced str */
+char *bb_ask_noecho(int fd, int timeout, const char *prompt) FAST_FUNC;
+/* Like bb_ask_noecho, but asks on stdin with no timeout.  */
+char *bb_ask_noecho_stdin(const char *prompt) FAST_FUNC;
+
+int bb_ask_y_confirmation_FILE(FILE *fp) FAST_FUNC;
+int bb_ask_y_confirmation(void) FAST_FUNC;
 
 /* Returns -1 if input is invalid. current_mode is a base for e.g. "u+rw" */
 int bb_parse_mode(const char* s, unsigned cur_mode) FAST_FUNC;
@@ -1485,6 +1498,7 @@ extern void run_shell(const char *shell,
  */
 const char *get_shell_name(void) FAST_FUNC;
 
+#if ENABLE_FEATURE_SETPRIV_CAPABILITIES || ENABLE_RUN_INIT
 unsigned cap_name_to_number(const char *cap) FAST_FUNC;
 void printf_cap(const char *pfx, unsigned cap_no) FAST_FUNC;
 void drop_capability(int cap_ordinal) FAST_FUNC;
@@ -1496,9 +1510,7 @@ struct caps { \
 	struct __user_cap_data_struct data[2]; \
 }
 void getcaps(void *caps) FAST_FUNC;
-
-unsigned cap_name_to_number(const char *name) FAST_FUNC;
-void printf_cap(const char *pfx, unsigned cap_no) FAST_FUNC;
+#endif
 
 #if ENABLE_SELINUX
 extern void renew_current_security_context(void) FAST_FUNC;
@@ -1591,9 +1603,11 @@ int get_terminal_width_height(int fd, un
 int get_terminal_width(int fd) FAST_FUNC;
 
 int tcsetattr_stdin_TCSANOW(const struct termios *tp) FAST_FUNC;
-#define TERMIOS_CLEAR_ISIG (1 << 0)
-#define TERMIOS_RAW_CRNL   (1 << 1)
-#define TERMIOS_RAW_INPUT  (1 << 2)
+#define TERMIOS_CLEAR_ISIG      (1 << 0)
+#define TERMIOS_RAW_CRNL_INPUT  (1 << 1)
+#define TERMIOS_RAW_CRNL_OUTPUT (1 << 2)
+#define TERMIOS_RAW_CRNL        (TERMIOS_RAW_CRNL_INPUT|TERMIOS_RAW_CRNL_OUTPUT)
+#define TERMIOS_RAW_INPUT       (1 << 3)
 int get_termios_and_make_raw(int fd, struct termios *newterm, struct termios *oldterm, int flags) FAST_FUNC;
 int set_termios_to_raw(int fd, struct termios *oldterm, int flags) FAST_FUNC;
 
@@ -1928,6 +1942,8 @@ typedef struct md5_ctx_t md5sha_ctx_t;
 
 extern uint32_t *global_crc32_table;
 uint32_t *crc32_filltable(uint32_t *tbl256, int endian) FAST_FUNC;
+uint32_t *crc32_new_table_le(void) FAST_FUNC;
+uint32_t *global_crc32_new_table_le(void) FAST_FUNC;
 uint32_t crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table) FAST_FUNC;
 uint32_t crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table) FAST_FUNC;
 
@@ -1944,6 +1960,7 @@ typedef struct bb_progress_t {
 	unsigned last_update_sec;
 	unsigned last_change_sec;
 	unsigned start_sec;
+	/*unsigned last_eta;*/
 	const char *curfile;
 } bb_progress_t;
 
@@ -2006,10 +2023,16 @@ extern const char bb_path_wtmp_file[] AL
 
 #define bb_dev_null "/dev/null"
 extern const char bb_busybox_exec_path[] ALIGN1;
-/* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
- * but I want to save a few bytes here */
-extern const char bb_PATH_root_path[] ALIGN1; /* "PATH=/sbin:/usr/sbin:/bin:/usr/bin" */
+/* allow default system PATH to be extended via CFLAGS */
+#ifndef BB_ADDITIONAL_PATH
+#define BB_ADDITIONAL_PATH ""
+#endif
+#define BB_PATH_ROOT_PATH "PATH=/sbin:/usr/sbin:/bin:/usr/bin" BB_ADDITIONAL_PATH
+extern const char bb_PATH_root_path[] ALIGN1; /* BB_PATH_ROOT_PATH */
 #define bb_default_root_path (bb_PATH_root_path + sizeof("PATH"))
+/* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
+ * but I want to save a few bytes here:
+ */
 #define bb_default_path      (bb_PATH_root_path + sizeof("PATH=/sbin:/usr/sbin"))
 
 extern const int const_int_0;
diff -urpN busybox-1.28.4/include/liblzo_interface.h busybox-1.29.0/include/liblzo_interface.h
--- busybox-1.28.4/include/liblzo_interface.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/include/liblzo_interface.h	2018-07-02 15:55:14.000000000 +0200
@@ -49,12 +49,10 @@ int lzo1x_999_compress_level(const uint8
 
 /* decompression */
 //int lzo1x_decompress(const uint8_t* src, unsigned src_len,
-//		uint8_t* dst, unsigned* dst_len,
-//		void* wrkmem /* NOT USED */);
+//		uint8_t* dst, unsigned* dst_len /*, void* wrkmem */);
 /* safe decompression with overrun testing */
 int lzo1x_decompress_safe(const uint8_t* src, unsigned src_len,
-		uint8_t* dst, unsigned* dst_len,
-		void* wrkmem /* NOT USED */);
+		uint8_t* dst, unsigned* dst_len	/*, void* wrkmem */);
 
 #define LZO_E_OK                    0
 #define LZO_E_ERROR                 (-1)
diff -urpN busybox-1.28.4/init/Config.src busybox-1.29.0/init/Config.src
--- busybox-1.28.4/init/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/init/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Init Utilities"
diff -urpN busybox-1.28.4/init/halt.c busybox-1.29.0/init/halt.c
--- busybox-1.28.4/init/halt.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/init/halt.c	2018-07-02 15:55:14.000000000 +0200
@@ -24,6 +24,17 @@
 //config:	help
 //config:	Stop all processes and reboot the system.
 //config:
+//config:config FEATURE_WAIT_FOR_INIT
+//config:	bool "Before signaling init, make sure it is ready for it"
+//config:	default y
+//config:	depends on HALT || POWEROFF || REBOOT
+//config:	help
+//config:	In rare cases, poweroff may be commanded by firmware to OS
+//config:	even before init process exists. On Linux, this spawns
+//config:	"/sbin/poweroff" very early. This option adds code
+//config:	which checks that init is ready to receive poweroff
+//config:	commands. Code size increase of ~80 bytes.
+//config:
 //config:config FEATURE_CALL_TELINIT
 //config:	bool "Call telinit on shutdown and reboot"
 //config:	default y
@@ -108,6 +119,47 @@ static void write_wtmp(void)
 #define write_wtmp() ((void)0)
 #endif
 
+#if ENABLE_FEATURE_WAIT_FOR_INIT
+/* In Linux, "poweroff" may be spawned even before init.
+ * For example, with ACPI:
+ * linux/drivers/acpi/bus.c:
+ *  static void sb_notify_work(struct work_struct *dummy)
+ *      orderly_poweroff(true);
+ * linux/kernel/reboot.c:
+ *  static int run_cmd(const char *cmd)
+ *      ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
+ *  poweroff_cmd[] = "/sbin/poweroff";
+ *  static int __orderly_poweroff(bool force)
+ *      ret = run_cmd(poweroff_cmd);
+ *
+ * We want to make sure init exists and listens to signals.
+ */
+static int init_was_not_there(void)
+{
+	enum { initial = 5 }; /* 5 seconds should be plenty for timeout */
+	int cnt = initial - 1;
+
+	/* Just existence of PID 1 does not mean it installed
+	 * the handlers already.
+	 */
+#if 0
+	while (kill(1, 0) != 0 && --cnt >= 0)
+		sleep(1);
+#endif
+	/* ... so let's wait for some evidence a usual startup event,
+	 * mounting of /proc, happened. By that time init should be ready
+	 * for signals.
+	 */
+	while (access("/proc/meminfo", F_OK) != 0 && --cnt >= 0)
+		sleep(1);
+
+	/* Does it look like init wasn't there? */
+	return (cnt != initial - 1);
+}
+#else
+  /* Assume it's always there */
+# define init_was_not_there() 0
+#endif
 
 int halt_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int halt_main(int argc UNUSED_PARAM, char **argv)
@@ -171,6 +223,8 @@ int halt_main(int argc UNUSED_PARAM, cha
 			if (!ENABLE_FEATURE_CALL_TELINIT) {
 				/* bbox init assumed */
 				rc = kill(1, signals[which]);
+				if (init_was_not_there())
+					rc = kill(1, signals[which]);
 			} else {
 				/* SysV style init assumed */
 				/* runlevels:
diff -urpN busybox-1.28.4/init/init.c busybox-1.29.0/init/init.c
--- busybox-1.28.4/init/init.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/init/init.c	2018-07-02 15:55:14.000000000 +0200
@@ -128,8 +128,8 @@
 #define DEBUG_SEGV_HANDLER 0
 
 #include "libbb.h"
+#include "common_bufsiz.h"
 #include <syslog.h>
-#include <sys/resource.h>
 #ifdef __linux__
 # include <linux/vt.h>
 # include <sys/sysinfo.h>
@@ -203,7 +203,6 @@
  */
 #define RESTART     0x80
 
-
 /* A linked list of init_actions, to be read from inittab */
 struct init_action {
 	struct init_action *next;
@@ -213,11 +212,17 @@ struct init_action {
 	char command[1];
 };
 
-static struct init_action *init_action_list = NULL;
-
+struct globals {
+	struct init_action *init_action_list;
 #if !ENABLE_FEATURE_INIT_SYSLOG
-static const char *log_console = VC_5;
+	const char *log_console;
 #endif
+} FIX_ALIASING;
+#define G (*(struct globals*)bb_common_bufsiz1)
+#define INIT_G() do { \
+	setup_common_bufsiz(); \
+	IF_NOT_FEATURE_INIT_SYSLOG(G.log_console = VC_5;) \
+} while (0)
 
 enum {
 	L_LOG = 0x1,
@@ -265,10 +270,10 @@ static void message(int where, const cha
 
 		if (log_fd < 0) {
 			log_fd = STDERR_FILENO;
-			if (log_console) {
-				log_fd = device_open(log_console, O_WRONLY | O_NONBLOCK | O_NOCTTY);
+			if (G.log_console) {
+				log_fd = device_open(G.log_console, O_WRONLY | O_NONBLOCK | O_NOCTTY);
 				if (log_fd < 0) {
-					bb_error_msg("can't log to %s", log_console);
+					bb_error_msg("can't log to %s", G.log_console);
 					where = L_CONSOLE;
 				} else {
 					close_on_exec_on(log_fd);
@@ -328,7 +333,7 @@ static void console_init(void)
 		if (!s || strcmp(s, "linux") == 0)
 			putenv((char*)"TERM=vt102");
 # if !ENABLE_FEATURE_INIT_SYSLOG
-		log_console = NULL;
+		G.log_console = NULL;
 # endif
 	} else
 #endif
@@ -562,7 +567,7 @@ static struct init_action *mark_terminat
 
 	if (pid > 0) {
 		update_utmp_DEAD_PROCESS(pid);
-		for (a = init_action_list; a; a = a->next) {
+		for (a = G.init_action_list; a; a = a->next) {
 			if (a->pid == pid) {
 				a->pid = 0;
 				return a;
@@ -596,7 +601,7 @@ static void run_actions(int action_type)
 {
 	struct init_action *a;
 
-	for (a = init_action_list; a; a = a->next) {
+	for (a = G.init_action_list; a; a = a->next) {
 		if (!(a->action_type & action_type))
 			continue;
 
@@ -630,7 +635,7 @@ static void new_init_action(uint8_t acti
 	 * To achieve that, if we find a matching entry, we move it
 	 * to the end.
 	 */
-	nextp = &init_action_list;
+	nextp = &G.init_action_list;
 	while ((a = *nextp) != NULL) {
 		/* Don't enter action if it's already in the list.
 		 * This prevents losing running RESPAWNs.
@@ -845,7 +850,7 @@ static void exec_restart_action(void)
 {
 	struct init_action *a;
 
-	for (a = init_action_list; a; a = a->next) {
+	for (a = G.init_action_list; a; a = a->next) {
 		if (!(a->action_type & RESTART))
 			continue;
 
@@ -923,7 +928,7 @@ static void reload_inittab(void)
 	message(L_LOG, "reloading /etc/inittab");
 
 	/* Disable old entries */
-	for (a = init_action_list; a; a = a->next)
+	for (a = G.init_action_list; a; a = a->next)
 		a->action_type = 0;
 
 	/* Append new entries, or modify existing entries
@@ -936,14 +941,14 @@ static void reload_inittab(void)
 #if ENABLE_FEATURE_KILL_REMOVED
 	/* Kill stale entries */
 	/* Be nice and send SIGTERM first */
-	for (a = init_action_list; a; a = a->next)
+	for (a = G.init_action_list; a; a = a->next)
 		if (a->action_type == 0 && a->pid != 0)
 			kill(a->pid, SIGTERM);
 	if (CONFIG_FEATURE_KILL_DELAY) {
 		/* NB: parent will wait in NOMMU case */
 		if ((BB_MMU ? fork() : vfork()) == 0) { /* child */
 			sleep(CONFIG_FEATURE_KILL_DELAY);
-			for (a = init_action_list; a; a = a->next)
+			for (a = G.init_action_list; a; a = a->next)
 				if (a->action_type == 0 && a->pid != 0)
 					kill(a->pid, SIGKILL);
 			_exit(EXIT_SUCCESS);
@@ -955,7 +960,7 @@ static void reload_inittab(void)
 	 * We never rerun SYSINIT entries anyway,
 	 * removing them too saves a few bytes
 	 */
-	nextp = &init_action_list;
+	nextp = &G.init_action_list;
 	while ((a = *nextp) != NULL) {
 		/*
 		 * Why pid == 0 check?
@@ -1046,6 +1051,8 @@ static void sleep_much(void)
 int init_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int init_main(int argc UNUSED_PARAM, char **argv)
 {
+	INIT_G();
+
 	if (argv[1] && strcmp(argv[1], "-q") == 0) {
 		return kill(1, SIGHUP);
 	}
diff -urpN busybox-1.28.4/klibc-utils/Config.src busybox-1.29.0/klibc-utils/Config.src
--- busybox-1.28.4/klibc-utils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/klibc-utils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "klibc-utils"
diff -urpN busybox-1.28.4/klibc-utils/nuke.c busybox-1.29.0/klibc-utils/nuke.c
--- busybox-1.28.4/klibc-utils/nuke.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/klibc-utils/nuke.c	2018-07-02 15:55:14.000000000 +0200
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config NUKE
-//config:	bool "nuke"
+//config:	bool "nuke (2.4 kb)"
 //config:	default y
 //config:	help
 //config:	Alias to "rm -rf".
diff -urpN busybox-1.28.4/klibc-utils/resume.c busybox-1.29.0/klibc-utils/resume.c
--- busybox-1.28.4/klibc-utils/resume.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/klibc-utils/resume.c	2018-07-02 15:55:14.000000000 +0200
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config RESUME
-//config:	bool "resume"
+//config:	bool "resume (3.3 kb)"
 //config:	default y
 //config:	help
 //config:	Resume from saved "suspend-to-disk" image
diff -urpN busybox-1.28.4/klibc-utils/run-init.c busybox-1.29.0/klibc-utils/run-init.c
--- busybox-1.28.4/klibc-utils/run-init.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/klibc-utils/run-init.c	2018-07-02 15:55:14.000000000 +0200
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config RUN_INIT
-//config:	bool "run-init"
+//config:	bool "run-init (7.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.28.4/libbb/Config.src busybox-1.29.0/libbb/Config.src
--- busybox-1.28.4/libbb/Config.src	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 comment "Library Tuning"
@@ -76,6 +76,18 @@ config FEATURE_ETC_NETWORKS
 	a rarely used feature which allows you to use names
 	instead of IP/mask pairs in route command.
 
+config FEATURE_ETC_SERVICES
+	bool "Consult /etc/services even for well-known ports"
+	default n
+	help
+	Look up e.g. "telnet" and "http" in /etc/services file
+	instead of assuming ports 23 and 80.
+	This is almost never necessary (everybody uses standard ports),
+	and it makes sense to avoid reading this file.
+	If you disable this option, in the cases where port is explicitly
+	specified as a service name (e.g. "telnet HOST PORTNAME"),
+	it will still be looked up in /etc/services.
+
 config FEATURE_EDITING
 	bool "Command line editing"
 	default y
@@ -149,6 +161,11 @@ config FEATURE_EDITING_FANCY_PROMPT
 	Setting this option allows for prompts to use things like \w and
 	\$ and escape codes.
 
+config FEATURE_EDITING_WINCH
+	bool "Enable automatic tracking of window size changes"
+	default y
+	depends on FEATURE_EDITING
+
 config FEATURE_EDITING_ASK_TERMINAL
 	bool "Query cursor position from terminal"
 	default n
diff -urpN busybox-1.28.4/libbb/Kbuild.src busybox-1.29.0/libbb/Kbuild.src
--- busybox-1.28.4/libbb/Kbuild.src	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/Kbuild.src	2018-07-02 15:55:14.000000000 +0200
@@ -143,7 +143,8 @@ lib-$(CONFIG_DELGROUP) += update_passwd.
 lib-$(CONFIG_DELUSER) += update_passwd.o
 
 lib-$(CONFIG_FTPD) += pw_encrypt.o correct_password.o
-lib-$(CONFIG_PASSWD) += pw_encrypt.o update_passwd.o obscure.o
+lib-$(CONFIG_PASSWD) += pw_encrypt.o update_passwd.o
+lib-$(CONFIG_FEATURE_PASSWD_WEAK_CHECK) += obscure.o
 lib-$(CONFIG_CHPASSWD) += pw_encrypt.o update_passwd.o
 lib-$(CONFIG_CRYPTPW) += pw_encrypt.o
 lib-$(CONFIG_MKPASSWD) += pw_encrypt.o
diff -urpN busybox-1.28.4/libbb/appletlib.c busybox-1.29.0/libbb/appletlib.c
--- busybox-1.28.4/libbb/appletlib.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/appletlib.c	2018-07-02 15:55:14.000000000 +0200
@@ -102,14 +102,21 @@ static const char *unpack_usage_messages
 	char *outbuf = NULL;
 	bunzip_data *bd;
 	int i;
+	jmp_buf jmpbuf;
 
-	i = start_bunzip(&bd,
+	/* Setup for I/O error handling via longjmp */
+	i = setjmp(jmpbuf);
+	if (i == 0) {
+		i = start_bunzip(&jmpbuf,
+			&bd,
 			/* src_fd: */ -1,
 			/* inbuf:  */ packed_usage,
-			/* len:    */ sizeof(packed_usage));
-	/* read_bunzip can longjmp to start_bunzip, and ultimately
-	 * end up here with i != 0 on read data errors! Not trivial */
-	if (!i) {
+			/* len:    */ sizeof(packed_usage)
+		);
+	}
+	/* read_bunzip can longjmp and end up here with i != 0
+	 * on read data errors! Not trivial */
+	if (i == 0) {
 		/* Cannot use xmalloc: will leak bd in NOFORK case! */
 		outbuf = malloc_or_warn(sizeof(UNPACKED_USAGE));
 		if (outbuf)
diff -urpN busybox-1.28.4/libbb/ask_confirmation.c busybox-1.29.0/libbb/ask_confirmation.c
--- busybox-1.28.4/libbb/ask_confirmation.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/ask_confirmation.c	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 /* vi: set sw=4 ts=4: */
 /*
- * bb_ask_confirmation implementation for busybox
+ * bb_ask_y_confirmation implementation for busybox
  *
  * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
@@ -8,15 +8,16 @@
  */
 #include "libbb.h"
 
-/* Read a line from stdin.  If the first non-whitespace char is 'y' or 'Y',
+/* Read a line from fp.  If the first non-whitespace char is 'y' or 'Y',
  * return 1.  Otherwise return 0.
  */
-int FAST_FUNC bb_ask_confirmation(void)
+int FAST_FUNC bb_ask_y_confirmation_FILE(FILE *fp)
 {
 	char first = 0;
 	int c;
 
-	while (((c = getchar()) != EOF) && (c != '\n')) {
+	fflush_all();
+	while (((c = fgetc(fp)) != EOF) && (c != '\n')) {
 		if (first == 0 && !isblank(c)) {
 			first = c|0x20;
 		}
@@ -24,3 +25,8 @@ int FAST_FUNC bb_ask_confirmation(void)
 
 	return first == 'y';
 }
+
+int FAST_FUNC bb_ask_y_confirmation(void)
+{
+	return bb_ask_y_confirmation_FILE(stdin);
+}
diff -urpN busybox-1.28.4/libbb/bb_askpass.c busybox-1.29.0/libbb/bb_askpass.c
--- busybox-1.28.4/libbb/bb_askpass.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/bb_askpass.c	2018-07-02 15:55:14.000000000 +0200
@@ -13,16 +13,9 @@ static void askpass_timeout(int UNUSED_P
 {
 }
 
-char* FAST_FUNC bb_ask_stdin(const char *prompt)
+char* FAST_FUNC bb_ask_noecho(int fd, int timeout, const char *prompt)
 {
-	return bb_ask(STDIN_FILENO, 0, prompt);
-}
-char* FAST_FUNC bb_ask(const int fd, int timeout, const char *prompt)
-{
-	/* Was static char[BIGNUM] */
-	enum { sizeof_passwd = 128 };
-
-	char *passwd;
+#define MAX_LINE 0xfff
 	char *ret;
 	int i;
 	struct sigaction sa, oldsa;
@@ -37,16 +30,17 @@ char* FAST_FUNC bb_ask(const int fd, int
 
 	tcgetattr(fd, &oldtio);
 	tio = oldtio;
-#if 0
-	/* Switch off UPPERCASE->lowercase conversion (never used since 198x)
-	 * and XON/XOFF (why we want to mess with this??)
+	/* Switch off echo. ECHOxyz meaning:
+	 * ECHO    echo input chars
+	 * ECHOE   echo BS-SP-BS on erase character
+	 * ECHOK   echo kill char specially, not as ^c (ECHOKE controls how exactly)
+	 * ECHOKE  erase all input via BS-SP-BS on kill char (else go to next line)
+	 * ECHOCTL Echo ctrl chars as ^c (else echo verbatim:
+	 *         e.g. up arrow emits "ESC-something" and thus moves cursor up!)
+	 * ECHONL  Echo NL even if ECHO is not set
+	 * ECHOPRT On erase, echo erased chars
+	 *         [qwe<BS><BS><BS> input looks like "qwe\ewq/" on screen]
 	 */
-# ifndef IUCLC
-#  define IUCLC 0
-# endif
-	tio.c_iflag &= ~(IUCLC|IXON|IXOFF|IXANY);
-#endif
-	/* Switch off echo */
 	tio.c_lflag &= ~(ECHO|ECHOE|ECHOK|ECHONL);
 	tcsetattr(fd, TCSANOW, &tio);
 
@@ -60,21 +54,30 @@ char* FAST_FUNC bb_ask(const int fd, int
 		alarm(timeout);
 	}
 
-	passwd = auto_string(xmalloc(sizeof_passwd));
-	ret = passwd;
+	ret = NULL;
 	i = 0;
 	while (1) {
-		int r = read(fd, &ret[i], 1);
+		int r;
+
+		/* User input is uber-slow, no need to optimize reallocs.
+		 * Grow it on every char.
+		 */
+		ret = xrealloc(ret, i + 2);
+		r = read(fd, &ret[i], 1);
+
 		if ((i == 0 && r == 0) /* EOF (^D) with no password */
-		 || r < 0
+		 || r < 0 /* read is interrupted by timeout or ^C */
 		) {
-			/* read is interrupted by timeout or ^C */
+			ret[i] = '\0'; /* paranoia */
+			nuke_str(ret); /* paranoia */
+			free(ret);
 			ret = NULL;
 			break;
 		}
+
 		if (r == 0 /* EOF */
 		 || ret[i] == '\r' || ret[i] == '\n' /* EOL */
-		 || ++i == sizeof_passwd-1 /* line limit */
+		 || ++i == MAX_LINE /* line limit */
 		) {
 			ret[i] = '\0';
 			break;
@@ -90,3 +93,7 @@ char* FAST_FUNC bb_ask(const int fd, int
 	fflush_all();
 	return ret;
 }
+char* FAST_FUNC bb_ask_noecho_stdin(const char *prompt)
+{
+	return bb_ask_noecho(STDIN_FILENO, 0, prompt);
+}
diff -urpN busybox-1.28.4/libbb/bb_getsockname.c busybox-1.29.0/libbb/bb_getsockname.c
--- busybox-1.28.4/libbb/bb_getsockname.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/libbb/bb_getsockname.c	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,19 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Utility routines.
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//kbuild:lib-y += bb_getsockname.o
+
+#include "libbb.h"
+
+int FAST_FUNC bb_getsockname(int sockfd, void *addr, socklen_t addrlen)
+{
+	/* The usefullness of this function is that for getsockname(),
+	 * addrlen must go on stack (to _have_ an address to be passed),
+	 * but many callers do not need its modified value.
+	 * By using this shim, they can avoid unnecessary stack spillage.
+	 */
+	return getsockname(sockfd, (struct sockaddr *)addr, &addrlen);
+}
diff -urpN busybox-1.28.4/libbb/capability.c busybox-1.29.0/libbb/capability.c
--- busybox-1.28.4/libbb/capability.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/capability.c	2018-07-02 15:55:14.000000000 +0200
@@ -3,7 +3,8 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-//kbuild:lib-$(CONFIG_PLATFORM_LINUX) += capability.o
+//kbuild:lib-$(CONFIG_FEATURE_SETPRIV_CAPABILITIES) += capability.o
+//kbuild:lib-$(CONFIG_RUN_INIT) += capability.o
 
 #include <linux/capability.h>
 // #include <sys/capability.h>
diff -urpN busybox-1.28.4/libbb/copy_file.c busybox-1.29.0/libbb/copy_file.c
--- busybox-1.28.4/libbb/copy_file.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/copy_file.c	2018-07-02 15:55:14.000000000 +0200
@@ -48,7 +48,7 @@ static int ask_and_unlink(const char *de
 		// (No "opening without O_EXCL", no "unlink only if -f")
 		// Or else we will end up having 3 open()s!
 		fprintf(stderr, "%s: overwrite '%s'? ", applet_name, dest);
-		if (!bb_ask_confirmation())
+		if (!bb_ask_y_confirmation())
 			return 0; /* not allowed to overwrite */
 	}
 	if (unlink(dest) < 0) {
diff -urpN busybox-1.28.4/libbb/correct_password.c busybox-1.29.0/libbb/correct_password.c
--- busybox-1.28.4/libbb/correct_password.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/correct_password.c	2018-07-02 15:55:14.000000000 +0200
@@ -106,7 +106,7 @@ int FAST_FUNC ask_and_check_password_ext
 	if (!pw_pass[0]) /* empty password field? */
 		return CHECKPASS_PW_HAS_EMPTY_PASSWORD;
 
-	plaintext = bb_ask(STDIN_FILENO, timeout, prompt);
+	plaintext = bb_ask_noecho(STDIN_FILENO, timeout, prompt);
 	if (!plaintext) {
 		/* EOF (such as ^D) or error (such as ^C) or timeout */
 		return -1;
diff -urpN busybox-1.28.4/libbb/crc32.c busybox-1.29.0/libbb/crc32.c
--- busybox-1.28.4/libbb/crc32.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/crc32.c	2018-07-02 15:55:14.000000000 +0200
@@ -41,6 +41,16 @@ uint32_t* FAST_FUNC crc32_filltable(uint
 
 	return crc_table - 256;
 }
+/* Common uses: */
+uint32_t* FAST_FUNC crc32_new_table_le(void)
+{
+	return crc32_filltable(NULL, 0);
+}
+uint32_t* FAST_FUNC global_crc32_new_table_le(void)
+{
+	global_crc32_table = crc32_new_table_le();
+	return global_crc32_table;
+}
 
 uint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)
 {
diff -urpN busybox-1.28.4/libbb/dump.c busybox-1.29.0/libbb/dump.c
--- busybox-1.28.4/libbb/dump.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/dump.c	2018-07-02 15:55:14.000000000 +0200
@@ -464,11 +464,9 @@ static const char conv_str[] ALIGN1 =
 	"\v"  "\\""v""\0"
 	;
 
-
 static void conv_c(PR *pr, unsigned char *p)
 {
 	const char *str = conv_str;
-	char buf[10];
 
 	do {
 		if (*p == *str) {
@@ -482,7 +480,9 @@ static void conv_c(PR *pr, unsigned char
 		*pr->cchar = 'c';
 		printf(pr->fmt, *p);
 	} else {
-		sprintf(buf, "%03o", (int) *p);
+		char buf[4];
+		/* gcc-8.0.1 needs lots of casts to shut up */
+		sprintf(buf, "%03o", (unsigned)(uint8_t)*p);
 		str = buf;
  strpr:
 		*pr->cchar = 's';
diff -urpN busybox-1.28.4/libbb/executable.c busybox-1.29.0/libbb/executable.c
--- busybox-1.28.4/libbb/executable.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/executable.c	2018-07-02 15:55:14.000000000 +0200
@@ -25,7 +25,8 @@ int FAST_FUNC file_is_executable(const c
  *  you may call find_executable again with this PATHp to continue
  *  (if it's not NULL).
  * return NULL otherwise; (PATHp is undefined)
- * in all cases (*PATHp) contents will be trashed (s/:/NUL/).
+ * in all cases (*PATHp) contents are temporarily modified
+ * but are restored on return (s/:/NUL/ and back).
  */
 char* FAST_FUNC find_executable(const char *filename, char **PATHp)
 {
@@ -41,14 +42,17 @@ char* FAST_FUNC find_executable(const ch
 
 	p = *PATHp;
 	while (p) {
+		int ex;
+
 		n = strchr(p, ':');
-		if (n)
-			*n++ = '\0';
+		if (n) *n = '\0';
 		p = concat_path_file(
 			p[0] ? p : ".", /* handle "::" case */
 			filename
 		);
-		if (file_is_executable(p)) {
+		ex = file_is_executable(p);
+		if (n) *n++ = ':';
+		if (ex) {
 			*PATHp = n;
 			return p;
 		}
@@ -64,10 +68,8 @@ char* FAST_FUNC find_executable(const ch
  */
 int FAST_FUNC executable_exists(const char *filename)
 {
-	char *path = xstrdup(getenv("PATH"));
-	char *tmp = path;
-	char *ret = find_executable(filename, &tmp);
-	free(path);
+	char *path = getenv("PATH");
+	char *ret = find_executable(filename, &path);
 	free(ret);
 	return ret != NULL;
 }
diff -urpN busybox-1.28.4/libbb/get_line_from_file.c busybox-1.29.0/libbb/get_line_from_file.c
--- busybox-1.28.4/libbb/get_line_from_file.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/get_line_from_file.c	2018-07-02 15:55:14.000000000 +0200
@@ -10,16 +10,19 @@
  */
 #include "libbb.h"
 
-char* FAST_FUNC bb_get_chunk_from_file(FILE *file, int *end)
+char* FAST_FUNC bb_get_chunk_from_file(FILE *file, size_t *end)
 {
 	int ch;
-	unsigned idx = 0;
+	size_t idx = 0;
 	char *linebuf = NULL;
 
 	while ((ch = getc(file)) != EOF) {
 		/* grow the line buffer as necessary */
-		if (!(idx & 0xff))
+		if (!(idx & 0xff)) {
+			if (idx == ((size_t)-1) - 0xff)
+				bb_die_memory_exhausted();
 			linebuf = xrealloc(linebuf, idx + 0x100);
+		}
 		linebuf[idx++] = (char) ch;
 		if (ch == '\0')
 			break;
@@ -44,14 +47,12 @@ char* FAST_FUNC bb_get_chunk_from_file(F
 /* Get line, including trailing \n if any */
 char* FAST_FUNC xmalloc_fgets(FILE *file)
 {
-	int i;
-
-	return bb_get_chunk_from_file(file, &i);
+	return bb_get_chunk_from_file(file, NULL);
 }
 /* Get line.  Remove trailing \n */
 char* FAST_FUNC xmalloc_fgetline(FILE *file)
 {
-	int i;
+	size_t i;
 	char *c = bb_get_chunk_from_file(file, &i);
 
 	if (i && c[--i] == '\n')
diff -urpN busybox-1.28.4/libbb/lineedit.c busybox-1.29.0/libbb/lineedit.c
--- busybox-1.28.4/libbb/lineedit.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/lineedit.c	2018-07-02 15:55:14.000000000 +0200
@@ -151,9 +151,11 @@ struct lineedit_statics {
 	unsigned num_matches;
 #endif
 
+#if ENABLE_FEATURE_EDITING_WINCH
 	unsigned SIGWINCH_saved;
 	volatile unsigned SIGWINCH_count;
 	volatile smallint ok_to_redraw;
+#endif
 
 #if ENABLE_FEATURE_EDITING_VI
 # define DELBUFSIZ 128
@@ -165,8 +167,10 @@ struct lineedit_statics {
 	smallint sent_ESC_br6n;
 #endif
 
+#if ENABLE_FEATURE_EDITING_WINCH
 	/* Largish struct, keeping it last results in smaller code */
 	struct sigaction SIGWINCH_handler;
+#endif
 };
 
 /* See lineedit_ptr_hack.c */
@@ -426,7 +430,8 @@ static void put_till_end_and_adv_cursor(
 static void goto_new_line(void)
 {
 	put_till_end_and_adv_cursor();
-	if (cmdedit_x != 0)
+	/* "cursor == 0" is only if prompt is "" and user input is empty */
+	if (cursor == 0 || cmdedit_x != 0)
 		bb_putchar('\n');
 }
 
@@ -2030,6 +2035,7 @@ static void parse_and_put_prompt(const c
 }
 #endif
 
+#if ENABLE_FEATURE_EDITING_WINCH
 static void cmdedit_setwidth(void)
 {
 	int new_y;
@@ -2054,6 +2060,7 @@ static void win_changed(int nsig UNUSED_
 		S.SIGWINCH_count++;
 	}
 }
+#endif
 
 static int lineedit_read_key(char *read_key_buffer, int timeout)
 {
@@ -2072,9 +2079,9 @@ static int lineedit_read_key(char *read_
 		 *
 		 * Note: read_key sets errno to 0 on success.
 		 */
-		S.ok_to_redraw = 1;
+		IF_FEATURE_EDITING_WINCH(S.ok_to_redraw = 1;)
 		ic = read_key(STDIN_FILENO, read_key_buffer, timeout);
-		S.ok_to_redraw = 0;
+		IF_FEATURE_EDITING_WINCH(S.ok_to_redraw = 0;)
 		if (errno) {
 #if ENABLE_UNICODE_SUPPORT
 			if (errno == EAGAIN && unicode_idx != 0)
@@ -2408,11 +2415,12 @@ int FAST_FUNC read_line_input(line_input
 	parse_and_put_prompt(prompt);
 	ask_terminal();
 
+#if ENABLE_FEATURE_EDITING_WINCH
 	/* Install window resize handler (NB: after *all* init is complete) */
 	S.SIGWINCH_handler.sa_handler = win_changed;
 	S.SIGWINCH_handler.sa_flags = SA_RESTART;
 	sigaction(SIGWINCH, &S.SIGWINCH_handler, &S.SIGWINCH_handler);
-
+#endif
 	read_key_buffer[0] = 0;
 	while (1) {
 		/*
@@ -2424,6 +2432,7 @@ int FAST_FUNC read_line_input(line_input
 		 * in one place.
 		 */
 		int32_t ic, ic_raw;
+#if ENABLE_FEATURE_EDITING_WINCH
 		unsigned count;
 
 		count = S.SIGWINCH_count;
@@ -2431,7 +2440,7 @@ int FAST_FUNC read_line_input(line_input
 			S.SIGWINCH_saved = count;
 			cmdedit_setwidth();
 		}
-
+#endif
 		ic = ic_raw = lineedit_read_key(read_key_buffer, timeout);
 
 #if ENABLE_FEATURE_REVERSE_SEARCH
@@ -2868,8 +2877,10 @@ int FAST_FUNC read_line_input(line_input
 
 	/* restore initial_settings */
 	tcsetattr_stdin_TCSANOW(&initial_settings);
+#if ENABLE_FEATURE_EDITING_WINCH
 	/* restore SIGWINCH handler */
 	sigaction_set(SIGWINCH, &S.SIGWINCH_handler);
+#endif
 	fflush_all();
 
 	len = command_len;
diff -urpN busybox-1.28.4/libbb/loop.c busybox-1.29.0/libbb/loop.c
--- busybox-1.28.4/libbb/loop.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/loop.c	2018-07-02 15:55:14.000000000 +0200
@@ -106,6 +106,10 @@ int FAST_FUNC set_loop(char **device, co
 		return -errno;
 	}
 
+//TODO: use LOOP_CTL_GET_FREE instead of trying every loopN in sequence? a-la:
+// fd = open("/dev/loop-control", O_RDWR);
+// loopN = ioctl(fd, LOOP_CTL_GET_FREE);
+//
 	/* Find a loop device.  */
 	try = *device ? *device : dev;
 	/* 1048575 (0xfffff) is a max possible minor number in Linux circa 2010 */
diff -urpN busybox-1.28.4/libbb/make_directory.c busybox-1.29.0/libbb/make_directory.c
--- busybox-1.28.4/libbb/make_directory.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/make_directory.c	2018-07-02 15:55:14.000000000 +0200
@@ -92,6 +92,7 @@ int FAST_FUNC bb_make_directory(char *pa
 			}
 		}
 
+		//bb_error_msg("mkdir '%s'", path);
 		if (mkdir(path, 0777) < 0) {
 			/* If we failed for any other reason than the directory
 			 * already exists, output a diagnostic and return -1 */
@@ -118,13 +119,16 @@ int FAST_FUNC bb_make_directory(char *pa
 			/* Done.  If necessary, update perms on the newly
 			 * created directory.  Failure to update here _is_
 			 * an error. */
-			if ((mode != -1) && (chmod(path, mode) < 0)) {
-				fail_msg = "set permissions of";
-				if (flags & FILEUTILS_IGNORE_CHMOD_ERR) {
-					flags = 0;
-					goto print_err;
+			if (mode != -1) {
+				//bb_error_msg("chmod 0%03lo mkdir '%s'", mode, path);
+				if (chmod(path, mode) < 0) {
+					fail_msg = "set permissions of";
+					if (flags & FILEUTILS_IGNORE_CHMOD_ERR) {
+						flags = 0;
+						goto print_err;
+					}
+					break;
 				}
-				break;
 			}
 			goto ret0;
 		}
diff -urpN busybox-1.28.4/libbb/messages.c busybox-1.29.0/libbb/messages.c
--- busybox-1.28.4/libbb/messages.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/messages.c	2018-07-02 15:55:14.000000000 +0200
@@ -6,11 +6,6 @@
  */
 #include "libbb.h"
 
-/* allow default system PATH to be extended via CFLAGS */
-#ifndef BB_ADDITIONAL_PATH
-#define BB_ADDITIONAL_PATH ""
-#endif
-
 /* allow version to be extended, via CFLAGS */
 #ifndef BB_EXTRA_VERSION
 #define BB_EXTRA_VERSION " ("AUTOCONF_TIMESTAMP")"
@@ -36,8 +31,7 @@ const char bb_busybox_exec_path[] ALIGN1
 const char bb_default_login_shell[] ALIGN1 = LIBBB_DEFAULT_LOGIN_SHELL;
 /* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
  * but I want to save a few bytes here. Check libbb.h before changing! */
-const char bb_PATH_root_path[] ALIGN1 =
-	"PATH=/sbin:/usr/sbin:/bin:/usr/bin" BB_ADDITIONAL_PATH;
+const char bb_PATH_root_path[] ALIGN1 = BB_PATH_ROOT_PATH;
 
 
 //const int const_int_1 = 1;
diff -urpN busybox-1.28.4/libbb/missing_syscalls.c busybox-1.29.0/libbb/missing_syscalls.c
--- busybox-1.28.4/libbb/missing_syscalls.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/missing_syscalls.c	2018-07-02 15:55:14.000000000 +0200
@@ -3,14 +3,13 @@
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
-
 //kbuild:lib-y += missing_syscalls.o
 
-/*#include <linux/timex.h> - for struct timex, but may collide with <time.h> */
-#include <sys/syscall.h>
 #include "libbb.h"
 
 #if defined(ANDROID) || defined(__ANDROID__)
+/*# include <linux/timex.h> - for struct timex, but may collide with <time.h> */
+# include <sys/syscall.h>
 pid_t getsid(pid_t pid)
 {
 	return syscall(__NR_getsid, pid);
diff -urpN busybox-1.28.4/libbb/progress.c busybox-1.29.0/libbb/progress.c
--- busybox-1.28.4/libbb/progress.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/progress.c	2018-07-02 15:55:14.000000000 +0200
@@ -57,6 +57,9 @@ void FAST_FUNC bb_progress_init(bb_progr
 	p->last_update_sec = p->start_sec;
 	p->last_change_sec = p->start_sec;
 	p->last_size = 0;
+#if 0
+	p->last_eta = INT_MAX;
+#endif
 }
 
 /* File already had beg_size bytes.
@@ -71,10 +74,9 @@ void FAST_FUNC bb_progress_update(bb_pro
 		uoff_t transferred,
 		uoff_t totalsize)
 {
-	uoff_t beg_and_transferred;
+	char numbuf5[6]; /* 5 + 1 for NUL */
 	unsigned since_last_update, elapsed;
 	int notty;
-	int kiloscale;
 
 	//transferred = 1234; /* use for stall detection testing */
 	//totalsize = 0; /* use for unknown size download testing */
@@ -95,74 +97,69 @@ void FAST_FUNC bb_progress_update(bb_pro
 		return;
 	}
 
-	kiloscale = 0;
+	/* Before we lose real, unscaled sizes, produce human-readable size string */
+	smart_ulltoa5(beg_size + transferred, numbuf5, " kMGTPEZY")[0] = '\0';
+
 	/*
 	 * Scale sizes down if they are close to overflowing.
 	 * This allows calculations like (100 * transferred / totalsize)
 	 * without risking overflow: we guarantee 10 highest bits to be 0.
 	 * Introduced error is less than 1 / 2^12 ~= 0.025%
 	 */
-	if (ULONG_MAX > 0xffffffff || sizeof(off_t) == 4 || sizeof(off_t) != 8) {
-		/*
-		 * 64-bit CPU || small off_t: in either case,
-		 * >> is cheap, single-word operation.
-		 * ... || strange off_t: also use this code
-		 * (it is safe, just suboptimal wrt code size),
-		 * because 32/64 optimized one works only for 64-bit off_t.
-		 */
-		if (totalsize >= (1 << 22)) {
-			totalsize >>= 10;
-			beg_size >>= 10;
-			transferred >>= 10;
-			kiloscale = 1;
-		}
-	} else {
-		/* 32-bit CPU and 64-bit off_t.
-		 * Use a 40-bit shift, it is easier to do on 32-bit CPU.
-		 */
-/* ONE suppresses "warning: shift count >= width of type" */
-#define ONE (sizeof(off_t) > 4)
-		if (totalsize >= (uoff_t)(1ULL << 54*ONE)) {
-			totalsize = (uint32_t)(totalsize >> 32*ONE) >> 8;
-			beg_size = (uint32_t)(beg_size >> 32*ONE) >> 8;
-			transferred = (uint32_t)(transferred >> 32*ONE) >> 8;
-			kiloscale = 4;
-		}
+	while (totalsize >= (1 << 20)) {
+		totalsize >>= 8;
+		beg_size >>= 8;
+		transferred >>= 8;
 	}
+	/* If they were huge, now they are scaled down to [1048575,4096] range.
+	 * (N * totalsize) won't overflow 32 bits for N up to 4096.
+	 */
+#if ULONG_MAX == 0xffffffff
+/* 32-bit CPU, uoff_t arithmetic is complex on it, cast variables to narrower types */
+# define totalsize   ((unsigned)totalsize)
+# define beg_size    ((unsigned)beg_size)
+# define transferred ((unsigned)transferred)
+#endif
 
 	notty = !isatty(STDERR_FILENO);
 
 	if (ENABLE_UNICODE_SUPPORT)
-		fprintf(stderr, "\r%s" + notty, p->curfile);
+		fprintf(stderr, "\r%s " + notty, p->curfile);
 	else
-		fprintf(stderr, "\r%-20.20s" + notty, p->curfile);
-
-	beg_and_transferred = beg_size + transferred;
+		fprintf(stderr, "\r%-20.20s " + notty, p->curfile);
 
 	if (totalsize != 0) {
 		int barlength;
-		unsigned ratio = 100 * beg_and_transferred / totalsize;
-		fprintf(stderr, "%4u%%", ratio);
+		unsigned beg_and_transferred; /* does not need uoff_t, see scaling code */
+		unsigned ratio;
 
-		barlength = get_terminal_width(2) - 49;
-		if (barlength > 0) {
-			/* god bless gcc for variable arrays :) */
-			char buf[barlength + 1];
-			unsigned stars = (unsigned)barlength * beg_and_transferred / totalsize;
-			memset(buf, ' ', barlength);
-			buf[barlength] = '\0';
-			memset(buf, '*', stars);
-			fprintf(stderr, " |%s|", buf);
+		beg_and_transferred = beg_size + transferred;
+		ratio = 100 * beg_and_transferred / totalsize;
+		/* can't overflow ^^^^^^^^^^^^^^^ */
+		fprintf(stderr, "%3u%% ", ratio);
+
+		barlength = get_terminal_width(2) - 48;
+		/*
+		 * Must reject barlength <= 0 (terminal too narrow). While at it,
+		 * also reject: 1-char bar (useless), 2-char bar (ridiculous).
+		 */
+		if (barlength > 2) {
+			if (barlength > 999)
+				barlength = 999;
+			{
+				/* god bless gcc for variable arrays :) */
+				char buf[barlength + 1];
+				unsigned stars = (unsigned)barlength * beg_and_transferred / totalsize;
+				/* can't overflow ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
+				memset(buf, ' ', barlength);
+				buf[barlength] = '\0';
+				memset(buf, '*', stars);
+				fprintf(stderr, "|%s| ", buf);
+			}
 		}
 	}
 
-	while (beg_and_transferred >= 100000) {
-		beg_and_transferred >>= 10;
-		kiloscale++;
-	}
-	/* see http://en.wikipedia.org/wiki/Tera */
-	fprintf(stderr, "%6u%c", (unsigned)beg_and_transferred, " kMGTPEZY"[kiloscale]);
-#define beg_and_transferred dont_use_beg_and_transferred_below()
+	fputs(numbuf5, stderr); /* "NNNNk" */
 
 	since_last_update = elapsed - p->last_change_sec;
 	if ((unsigned)transferred != p->last_size) {
@@ -184,18 +181,30 @@ void FAST_FUNC bb_progress_update(bb_pro
 		fprintf(stderr, " --:--:-- ETA");
 	} else {
 		unsigned eta, secs, hours;
+		unsigned bytes;
 
-		totalsize -= beg_size; /* now it's "total to upload" */
+		bytes = totalsize - beg_size;
 
 		/* Estimated remaining time =
-		 * estimated_sec_to_dl_totalsize_bytes - elapsed_sec =
-		 * totalsize / average_bytes_sec_so_far - elapsed =
-		 * totalsize / (transferred/elapsed) - elapsed =
-		 * totalsize * elapsed / transferred - elapsed
+		 * estimated_sec_to_dl_bytes - elapsed_sec =
+		 * bytes / average_bytes_sec_so_far - elapsed =
+		 * bytes / (transferred/elapsed) - elapsed =
+		 * bytes * elapsed / transferred - elapsed
 		 */
-		eta = totalsize * elapsed / transferred - elapsed;
+		eta = (unsigned long)bytes * elapsed / transferred - elapsed;
+		/* if 32bit, can overflow ^^^^^^^^^^, but this would only show bad ETA */
 		if (eta >= 1000*60*60)
 			eta = 1000*60*60 - 1;
+#if 0
+		/* To prevent annoying "back-and-forth" estimation jitter,
+		 * if new ETA is larger than the last just by a few seconds,
+		 * disregard it, and show last one. The end result is that
+		 * ETA usually only decreases, unless download slows down a lot.
+		 */
+		if ((unsigned)(eta - p->last_eta) < 10)
+			eta = p->last_eta;
+		p->last_eta = eta;
+#endif
 		secs = eta % 3600;
 		hours = eta / 3600;
 		fprintf(stderr, "%3u:%02u:%02u ETA", hours, secs / 60, secs % 60);
diff -urpN busybox-1.28.4/libbb/pw_encrypt.c busybox-1.29.0/libbb/pw_encrypt.c
--- busybox-1.28.4/libbb/pw_encrypt.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/pw_encrypt.c	2018-07-02 15:55:14.000000000 +0200
@@ -6,6 +6,7 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+#include <crypt.h>
 #include "libbb.h"
 
 /* static const uint8_t ascii64[] ALIGN1 =
diff -urpN busybox-1.28.4/libbb/remove_file.c busybox-1.29.0/libbb/remove_file.c
--- busybox-1.28.4/libbb/remove_file.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/remove_file.c	2018-07-02 15:55:14.000000000 +0200
@@ -39,9 +39,9 @@ int FAST_FUNC remove_file(const char *pa
 		if ((!(flags & FILEUTILS_FORCE) && access(path, W_OK) < 0 && isatty(0))
 		 || (flags & FILEUTILS_INTERACTIVE)
 		) {
-			fprintf(stderr, "%s: descend into directory '%s'? ", applet_name,
-					path);
-			if (!bb_ask_confirmation())
+			fprintf(stderr, "%s: descend into directory '%s'? ",
+					applet_name, path);
+			if (!bb_ask_y_confirmation())
 				return 0;
 		}
 
@@ -67,8 +67,9 @@ int FAST_FUNC remove_file(const char *pa
 		}
 
 		if (flags & FILEUTILS_INTERACTIVE) {
-			fprintf(stderr, "%s: remove directory '%s'? ", applet_name, path);
-			if (!bb_ask_confirmation())
+			fprintf(stderr, "%s: remove directory '%s'? ",
+					applet_name, path);
+			if (!bb_ask_y_confirmation())
 				return status;
 		}
 
@@ -92,7 +93,7 @@ int FAST_FUNC remove_file(const char *pa
 	 || (flags & FILEUTILS_INTERACTIVE)
 	) {
 		fprintf(stderr, "%s: remove '%s'? ", applet_name, path);
-		if (!bb_ask_confirmation())
+		if (!bb_ask_y_confirmation())
 			return 0;
 	}
 
diff -urpN busybox-1.28.4/libbb/skip_whitespace.c busybox-1.29.0/libbb/skip_whitespace.c
--- busybox-1.28.4/libbb/skip_whitespace.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/skip_whitespace.c	2018-07-02 15:55:14.000000000 +0200
@@ -32,7 +32,6 @@ char* FAST_FUNC skip_non_whitespace(cons
 
 char* FAST_FUNC skip_dev_pfx(const char *tty_name)
 {
-	if (is_prefixed_with(tty_name, "/dev/"))
-		tty_name += 5;
-	return (char*)tty_name;
+	char *unprefixed = is_prefixed_with(tty_name, "/dev/");
+	return unprefixed ? unprefixed : (char*)tty_name;
 }
diff -urpN busybox-1.28.4/libbb/vfork_daemon_rexec.c busybox-1.29.0/libbb/vfork_daemon_rexec.c
--- busybox-1.28.4/libbb/vfork_daemon_rexec.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/vfork_daemon_rexec.c	2018-07-02 15:55:14.000000000 +0200
@@ -14,14 +14,6 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-#include <sys/prctl.h>
-#ifndef PR_SET_NAME
-#define PR_SET_NAME 15
-#endif
-#ifndef PR_GET_NAME
-#define PR_GET_NAME 16
-#endif
-
 #include "busybox.h" /* uses applet tables */
 #include "NUM_APPLETS.h"
 
@@ -29,6 +21,13 @@
 #define NOEXEC_SUPPORT ((NUM_APPLETS > 1) && (ENABLE_FEATURE_PREFER_APPLETS || ENABLE_FEATURE_SH_STANDALONE))
 
 #if defined(__linux__) && (NUM_APPLETS > 1)
+# include <sys/prctl.h>
+# ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+# endif
+# ifndef PR_GET_NAME
+# define PR_GET_NAME 16
+# endif
 void FAST_FUNC set_task_comm(const char *comm)
 {
 	/* okay if too long (truncates) */
diff -urpN busybox-1.28.4/libbb/wfopen.c busybox-1.29.0/libbb/wfopen.c
--- busybox-1.28.4/libbb/wfopen.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/wfopen.c	2018-07-02 15:55:14.000000000 +0200
@@ -42,7 +42,7 @@ static FILE* xfdopen_helper(unsigned fd_
 {
 	FILE* fp = fdopen(fd_and_rw_bit >> 1, fd_and_rw_bit & 1 ? "w" : "r");
 	if (!fp)
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 	return fp;
 }
 FILE* FAST_FUNC xfdopen_for_read(int fd)
diff -urpN busybox-1.28.4/libbb/xfuncs.c busybox-1.29.0/libbb/xfuncs.c
--- busybox-1.28.4/libbb/xfuncs.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/libbb/xfuncs.c	2018-07-02 15:55:14.000000000 +0200
@@ -59,24 +59,23 @@ char* FAST_FUNC strncpy_IFNAMSIZ(char *d
  * A truncated result contains the first few digits of the result ala strncpy.
  * Returns a pointer past last generated digit, does _not_ store NUL.
  */
-void BUG_sizeof(void);
 char* FAST_FUNC utoa_to_buf(unsigned n, char *buf, unsigned buflen)
 {
 	unsigned i, out, res;
 
 	if (buflen) {
 		out = 0;
+
+		BUILD_BUG_ON(sizeof(n) != 4 && sizeof(n) != 8);
 		if (sizeof(n) == 4)
 		// 2^32-1 = 4294967295
 			i = 1000000000;
-#if UINT_MAX > 4294967295 /* prevents warning about "const too large" */
+#if UINT_MAX > 0xffffffff /* prevents warning about "const too large" */
 		else
 		if (sizeof(n) == 8)
 		// 2^64-1 = 18446744073709551615
 			i = 10000000000000000000;
 #endif
-		else
-			BUG_sizeof();
 		for (; i; i /= 10) {
 			res = n / i;
 			n = n % i;
@@ -331,7 +330,6 @@ int FAST_FUNC get_termios_and_make_raw(i
 	newterm->c_cc[VMIN] = 1;
 	/* no timeout (reads block forever) */
 	newterm->c_cc[VTIME] = 0;
-	if (flags & TERMIOS_RAW_CRNL) {
 /* IXON, IXOFF, and IXANY:
  * IXOFF=1: sw flow control is enabled on input queue:
  * tty transmits a STOP char when input queue is close to full
@@ -341,9 +339,12 @@ int FAST_FUNC get_termios_and_make_raw(i
  * and resume sending if START is received, or if any char
  * is received and IXANY=1.
  */
+	if (flags & TERMIOS_RAW_CRNL_INPUT) {
 		/* IXON=0: XON/XOFF chars are treated as normal chars (why we do this?) */
 		/* dont convert CR to NL on input */
 		newterm->c_iflag &= ~(IXON | ICRNL);
+	}
+	if (flags & TERMIOS_RAW_CRNL_OUTPUT) {
 		/* dont convert NL to CR+NL on output */
 		newterm->c_oflag &= ~(ONLCR);
 		/* Maybe clear more c_oflag bits? Usually, only OPOST and ONLCR are set.
@@ -364,9 +365,12 @@ int FAST_FUNC get_termios_and_make_raw(i
 #ifndef IXANY
 # define IXANY 0
 #endif
-		/* IXOFF=0: disable sending XON/XOFF if input buf is full */
-		/* IXON=0: input XON/XOFF chars are not special */
-		/* dont convert anything on input */
+		/* IXOFF=0: disable sending XON/XOFF if input buf is full
+		 * IXON=0: input XON/XOFF chars are not special
+		 * BRKINT=0: dont send SIGINT on break
+		 * IMAXBEL=0: dont echo BEL on input line too long
+		 * INLCR,ICRNL,IUCLC: dont convert anything on input
+		 */
 		newterm->c_iflag &= ~(IXOFF|IXON|IXANY|BRKINT|INLCR|ICRNL|IUCLC|IMAXBEL);
 	}
 	return r;
diff -urpN busybox-1.28.4/libbb/xfuncs_printf.c busybox-1.29.0/libbb/xfuncs_printf.c
--- busybox-1.28.4/libbb/xfuncs_printf.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/xfuncs_printf.c	2018-07-02 15:55:14.000000000 +0200
@@ -25,6 +25,11 @@
  * fail, so callers never need to check for errors.  If it returned, it
  * succeeded. */
 
+void FAST_FUNC bb_die_memory_exhausted(void)
+{
+	bb_error_msg_and_die(bb_msg_memory_exhausted);
+}
+
 #ifndef DMALLOC
 /* dmalloc provides variants of these that do abort() on failure.
  * Since dmalloc's prototypes overwrite the impls here as they are
@@ -44,7 +49,7 @@ void* FAST_FUNC xmalloc(size_t size)
 {
 	void *ptr = malloc(size);
 	if (ptr == NULL && size != 0)
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 	return ptr;
 }
 
@@ -55,7 +60,7 @@ void* FAST_FUNC xrealloc(void *ptr, size
 {
 	ptr = realloc(ptr, size);
 	if (ptr == NULL && size != 0)
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 	return ptr;
 }
 #endif /* DMALLOC */
@@ -79,7 +84,7 @@ char* FAST_FUNC xstrdup(const char *s)
 	t = strdup(s);
 
 	if (t == NULL)
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 
 	return t;
 }
@@ -327,14 +332,14 @@ char* FAST_FUNC xasprintf(const char *fo
 	va_end(p);
 
 	if (r < 0)
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 	return string_ptr;
 }
 
 void FAST_FUNC xsetenv(const char *key, const char *value)
 {
 	if (setenv(key, value, 1))
-		bb_error_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 }
 
 /* Handles "VAR=VAL" strings, even those which are part of environ
diff -urpN busybox-1.28.4/libbb/xreadlink.c busybox-1.29.0/libbb/xreadlink.c
--- busybox-1.28.4/libbb/xreadlink.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/libbb/xreadlink.c	2018-07-02 15:55:14.000000000 +0200
@@ -122,3 +122,33 @@ char* FAST_FUNC xmalloc_realpath(const c
 	return xstrdup(realpath(path, buf));
 #endif
 }
+
+char* FAST_FUNC xmalloc_realpath_coreutils(const char *path)
+{
+	char *buf;
+
+	errno = 0;
+	buf = xmalloc_realpath(path);
+	/*
+	 * There is one case when "readlink -f" and
+	 * "realpath" from coreutils succeed,
+	 * even though file does not exist, such as:
+	 *     /tmp/file_does_not_exist
+	 * (the directory must exist).
+	 */
+	if (!buf && errno == ENOENT) {
+		char *last_slash = strrchr(path, '/');
+		if (last_slash) {
+			*last_slash++ = '\0';
+			buf = xmalloc_realpath(path);
+			if (buf) {
+				unsigned len = strlen(buf);
+				buf = xrealloc(buf, len + strlen(last_slash) + 2);
+				buf[len++] = '/';
+				strcpy(buf + len, last_slash);
+			}
+		}
+	}
+
+	return buf;
+}
diff -urpN busybox-1.28.4/loginutils/Config.src busybox-1.29.0/loginutils/Config.src
--- busybox-1.28.4/loginutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/loginutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Login/Password Management Utilities"
diff -urpN busybox-1.28.4/loginutils/cryptpw.c busybox-1.29.0/loginutils/cryptpw.c
--- busybox-1.28.4/loginutils/cryptpw.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/loginutils/cryptpw.c	2018-07-02 15:55:14.000000000 +0200
@@ -133,8 +133,8 @@ int cryptpw_main(int argc UNUSED_PARAM,
 	if (!password) {
 		/* Only mkpasswd, and only from tty, prompts.
 		 * Otherwise it is a plain read. */
-		password = (ENABLE_MKPASSWD && isatty(STDIN_FILENO) && applet_name[0] == 'm')
-			? bb_ask_stdin("Password: ")
+		password = (ENABLE_MKPASSWD && applet_name[0] == 'm' && isatty(STDIN_FILENO))
+			? bb_ask_noecho_stdin("Password: ")
 			: xmalloc_fgetline(stdin)
 		;
 		/* may still be NULL on EOF/error */
diff -urpN busybox-1.28.4/loginutils/login.c busybox-1.29.0/loginutils/login.c
--- busybox-1.28.4/loginutils/login.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/loginutils/login.c	2018-07-02 15:55:14.000000000 +0200
@@ -64,7 +64,6 @@
 #include "libbb.h"
 #include "common_bufsiz.h"
 #include <syslog.h>
-#include <sys/resource.h>
 
 #if ENABLE_SELINUX
 # include <selinux/selinux.h>  /* for is_selinux_enabled()  */
diff -urpN busybox-1.28.4/loginutils/passwd.c busybox-1.29.0/loginutils/passwd.c
--- busybox-1.28.4/loginutils/passwd.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/loginutils/passwd.c	2018-07-02 15:55:14.000000000 +0200
@@ -39,7 +39,6 @@
 
 #include "libbb.h"
 #include <syslog.h>
-#include <sys/resource.h> /* setrlimit */
 
 static char* new_password(const struct passwd *pw, uid_t myuid, const char *algo)
 {
@@ -52,7 +51,7 @@ static char* new_password(const struct p
 	if (myuid != 0 && pw->pw_passwd[0]) {
 		char *encrypted;
 
-		orig = bb_ask_stdin("Old password: "); /* returns ptr to static */
+		orig = bb_ask_noecho_stdin("Old password: "); /* returns ptr to static */
 		if (!orig)
 			goto err_ret;
 		encrypted = pw_encrypt(orig, pw->pw_passwd, 1); /* returns malloced str */
@@ -65,11 +64,9 @@ static char* new_password(const struct p
 		if (ENABLE_FEATURE_CLEAN_UP)
 			free(encrypted);
 	}
-	orig = xstrdup(orig); /* or else bb_ask_stdin() will destroy it */
-	newp = bb_ask_stdin("New password: "); /* returns ptr to static */
+	newp = bb_ask_noecho_stdin("New password: "); /* returns ptr to static */
 	if (!newp)
 		goto err_ret;
-	newp = xstrdup(newp); /* we are going to bb_ask_stdin() again, so save it */
 	if (ENABLE_FEATURE_PASSWD_WEAK_CHECK
 	 && obscure(orig, newp, pw)
 	 && myuid != 0
@@ -77,7 +74,7 @@ static char* new_password(const struct p
 		goto err_ret; /* non-root is not allowed to have weak passwd */
 	}
 
-	cp = bb_ask_stdin("Retype password: ");
+	cp = bb_ask_noecho_stdin("Retype password: ");
 	if (!cp)
 		goto err_ret;
 	if (strcmp(cp, newp) != 0) {
@@ -99,6 +96,7 @@ static char* new_password(const struct p
 	if (ENABLE_FEATURE_CLEAN_UP) free(newp);
 
 	nuke_str(cp);
+	if (ENABLE_FEATURE_CLEAN_UP) free(cp);
 	return ret;
 }
 
diff -urpN busybox-1.28.4/mailutils/mail.c busybox-1.29.0/mailutils/mail.c
--- busybox-1.28.4/mailutils/mail.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/mailutils/mail.c	2018-07-02 15:55:14.000000000 +0200
@@ -163,8 +163,8 @@ void FAST_FUNC encode_base64(char *fname
 void FAST_FUNC get_cred_or_die(int fd)
 {
 	if (isatty(fd)) {
-		G.user = xstrdup(bb_ask(fd, /* timeout: */ 0, "User: "));
-		G.pass = xstrdup(bb_ask(fd, /* timeout: */ 0, "Password: "));
+		G.user = bb_ask_noecho(fd, /* timeout: */ 0, "User: ");
+		G.pass = bb_ask_noecho(fd, /* timeout: */ 0, "Password: ");
 	} else {
 		G.user = xmalloc_reads(fd, /* maxsize: */ NULL);
 		G.pass = xmalloc_reads(fd, /* maxsize: */ NULL);
diff -urpN busybox-1.28.4/mailutils/popmaildir.c busybox-1.29.0/mailutils/popmaildir.c
--- busybox-1.28.4/mailutils/popmaildir.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/mailutils/popmaildir.c	2018-07-02 15:55:14.000000000 +0200
@@ -45,8 +45,8 @@
 //usage:     "\n	-k		Keep retrieved messages on the server"
 //usage:     "\n	-t SEC		Network timeout"
 //usage:	IF_FEATURE_POPMAILDIR_DELIVERY(
-//usage:     "\n	-F \"PROG ARGS\"	Filter program (may be repeated)"
-//usage:     "\n	-M \"PROG ARGS\"	Delivery program"
+//usage:     "\n	-F 'PROG ARGS'	Filter program (may be repeated)"
+//usage:     "\n	-M 'PROG ARGS'	Delivery program"
 //usage:	)
 //usage:     "\n"
 //usage:     "\nFetch from plain POP3 server:"
@@ -265,7 +265,7 @@ int popmaildir_main(int argc UNUSED_PARA
 
 		// atomically move message to ./new/
 		target = xstrdup(filename);
-		strncpy(target, "new", 3);
+		memcpy(target, "new", 3);
 		// ... or just stop receiving on failure
 		if (rename_or_warn(filename, target))
 			break;
diff -urpN busybox-1.28.4/miscutils/Config.src busybox-1.29.0/miscutils/Config.src
--- busybox-1.28.4/miscutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/miscutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Miscellaneous Utilities"
diff -urpN busybox-1.28.4/miscutils/bbconfig.c busybox-1.29.0/miscutils/bbconfig.c
--- busybox-1.28.4/miscutils/bbconfig.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/miscutils/bbconfig.c	2018-07-02 15:55:14.000000000 +0200
@@ -44,13 +44,22 @@ int bbconfig_main(int argc UNUSED_PARAM,
 {
 #if ENABLE_FEATURE_COMPRESS_BBCONFIG
 	bunzip_data *bd;
-	int i = start_bunzip(&bd,
+	int i;
+	jmp_buf jmpbuf;
+
+	/* Setup for I/O error handling via longjmp */
+	i = setjmp(jmpbuf);
+	if (i == 0) {
+		i = start_bunzip(&jmpbuf,
+			&bd,
 			/* src_fd: */ -1,
 			/* inbuf:  */ bbconfig_config_bz2,
-			/* len:    */ sizeof(bbconfig_config_bz2));
-	/* read_bunzip can longjmp to start_bunzip, and ultimately
-	 * end up here with i != 0 on read data errors! Not trivial */
-	if (!i) {
+			/* len:    */ sizeof(bbconfig_config_bz2)
+		);
+	}
+	/* read_bunzip can longjmp and end up here with i != 0
+	 * on read data errors! Not trivial */
+	if (i == 0) {
 		/* Cannot use xmalloc: will leak bd in NOFORK case! */
 		char *outbuf = malloc_or_warn(sizeof(bbconfig_config));
 		if (outbuf) {
diff -urpN busybox-1.28.4/miscutils/fbsplash.c busybox-1.29.0/miscutils/fbsplash.c
--- busybox-1.28.4/miscutils/fbsplash.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/miscutils/fbsplash.c	2018-07-02 15:55:14.000000000 +0200
@@ -54,7 +54,7 @@
 //usage:     "\n	-d	Framebuffer device (default /dev/fb0)"
 //usage:     "\n	-i	Config file (var=value):"
 //usage:     "\n			BAR_LEFT,BAR_TOP,BAR_WIDTH,BAR_HEIGHT"
-//usage:     "\n			BAR_R,BAR_G,BAR_B"
+//usage:     "\n			BAR_R,BAR_G,BAR_B,IMG_LEFT,IMG_TOP"
 //usage:     "\n	-f	Control pipe (else exit after drawing image)"
 //usage:     "\n			commands: 'NN' (% for progress bar) or 'exit'"
 
@@ -73,7 +73,7 @@ struct globals {
 	FILE *logfile_fd;	// log file
 #endif
 	unsigned char *addr;	// pointer to framebuffer memory
-	unsigned ns[7];		// n-parameters
+	unsigned ns[9];		// n-parameters
 	const char *image_filename;
 	struct fb_var_screeninfo scr_var;
 	struct fb_fix_screeninfo scr_fix;
@@ -95,6 +95,8 @@ struct globals {
 #define nbar_colr	ns[4]	// progress bar color red component
 #define nbar_colg	ns[5]	// progress bar color green component
 #define nbar_colb	ns[6]	// progress bar color blue component
+#define img_posx	ns[7]	// image horizontal position
+#define img_posy	ns[8]	// image vertical position
 
 #if DEBUG
 #define DEBUG_MESSAGE(strMessage, args...) \
@@ -426,10 +428,10 @@ static void fb_drawimage(void)
 	line_size = width*3;
 	pixline = xmalloc(line_size);
 
-	if (width > G.scr_var.xres)
-		width = G.scr_var.xres;
-	if (height > G.scr_var.yres)
-		height = G.scr_var.yres;
+	if ((width + G.img_posx) > G.scr_var.xres)
+		width = G.scr_var.xres - G.img_posx;
+	if ((height + G.img_posy) > G.scr_var.yres)
+		height = G.scr_var.yres - G.img_posy;
 	for (j = 0; j < height; j++) {
 		unsigned char *pixel;
 		unsigned char *src;
@@ -437,7 +439,7 @@ static void fb_drawimage(void)
 		if (fread(pixline, 1, line_size, theme_file) != line_size)
 			bb_error_msg_and_die("bad PPM file '%s'", G.image_filename);
 		pixel = pixline;
-		src = G.addr + j * G.scr_fix.line_length;
+		src = G.addr + (G.img_posy + j) * G.scr_fix.line_length + G.img_posx * G.bytes_per_pixel;
 		for (i = 0; i < width; i++) {
 			unsigned thispix = fb_pixel_value(pixel[0], pixel[1], pixel[2]);
 			fb_write_pixel(src, thispix);
@@ -460,6 +462,7 @@ static void init(const char *cfg_filenam
 		"BAR_WIDTH\0" "BAR_HEIGHT\0"
 		"BAR_LEFT\0" "BAR_TOP\0"
 		"BAR_R\0" "BAR_G\0" "BAR_B\0"
+		"IMG_LEFT\0" "IMG_TOP\0"
 #if DEBUG
 		"DEBUG\0"
 #endif
@@ -472,10 +475,10 @@ static void init(const char *cfg_filenam
 		int i = index_in_strings(param_names, token[0]);
 		if (i < 0)
 			bb_error_msg_and_die("syntax error: %s", token[0]);
-		if (i >= 0 && i < 7)
+		if (i >= 0 && i < 9)
 			G.ns[i] = val;
 #if DEBUG
-		if (i == 7) {
+		if (i == 9) {
 			G.bdebug_messages = val;
 			if (G.bdebug_messages)
 				G.logfile_fd = xfopen_for_write("/tmp/fbsplash.log");
diff -urpN busybox-1.28.4/miscutils/flash_eraseall.c busybox-1.29.0/miscutils/flash_eraseall.c
--- busybox-1.28.4/miscutils/flash_eraseall.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/miscutils/flash_eraseall.c	2018-07-02 15:55:14.000000000 +0200
@@ -101,7 +101,7 @@ int flash_eraseall_main(int argc UNUSED_
 	if (flags & OPTION_J) {
 		uint32_t *crc32_table;
 
-		crc32_table = crc32_filltable(NULL, 0);
+		crc32_table = crc32_new_table_le();
 
 		cleanmarker.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
 		cleanmarker.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
diff -urpN busybox-1.28.4/miscutils/hexedit.c busybox-1.29.0/miscutils/hexedit.c
--- busybox-1.28.4/miscutils/hexedit.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/miscutils/hexedit.c	2018-07-02 15:55:14.000000000 +0200
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config HEXEDIT
-//config:	bool "hexedit"
+//config:	bool "hexedit (20 kb)"
 //config:	default y
 //config:	help
 //config:	Edit file in hexadecimal.
diff -urpN busybox-1.28.4/miscutils/i2c_tools.c busybox-1.29.0/miscutils/i2c_tools.c
--- busybox-1.28.4/miscutils/i2c_tools.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/miscutils/i2c_tools.c	2018-07-02 15:55:14.000000000 +0200
@@ -421,8 +421,7 @@ static void check_write_funcs(int fd, in
 static void confirm_or_abort(void)
 {
 	fprintf(stderr, "Continue? [y/N] ");
-	fflush_all();
-	if (!bb_ask_confirmation())
+	if (!bb_ask_y_confirmation())
 		bb_error_msg_and_die("aborting");
 }
 
diff -urpN busybox-1.28.4/miscutils/less.c busybox-1.29.0/miscutils/less.c
--- busybox-1.28.4/miscutils/less.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/miscutils/less.c	2018-07-02 15:55:14.000000000 +0200
@@ -99,17 +99,34 @@
 //config:	bool "Enable -N (dynamic switching of line numbers)"
 //config:	default y
 //config:	depends on FEATURE_LESS_DASHCMD
+//config:
+//config:config FEATURE_LESS_RAW
+//config:	bool "Enable -R ('raw control characters')"
+//config:	default y
+//config:	depends on FEATURE_LESS_DASHCMD
+//config:	help
+//config:	This is essential for less applet to work with tools that use colors
+//config:	and paging, such as git, systemd tools or nmcli.
+//config:
+//config:config FEATURE_LESS_ENV
+//config:	bool "Take options from $LESS environment variable"
+//config:	default y
+//config:	depends on FEATURE_LESS_DASHCMD
+//config:	help
+//config:	This is essential for less applet to work with tools that use colors
+//config:	and paging, such as git, systemd tools or nmcli.
 
 //applet:IF_LESS(APPLET(less, BB_DIR_USR_BIN, BB_SUID_DROP))
 
 //kbuild:lib-$(CONFIG_LESS) += less.o
 
 //usage:#define less_trivial_usage
-//usage:       "[-E" IF_FEATURE_LESS_REGEXP("I")IF_FEATURE_LESS_FLAGS("Mm")
-//usage:       "N" IF_FEATURE_LESS_TRUNCATE("S") "h~] [FILE]..."
+//usage:       "[-EF" IF_FEATURE_LESS_REGEXP("I")IF_FEATURE_LESS_FLAGS("Mm")
+//usage:       "N" IF_FEATURE_LESS_TRUNCATE("S") IF_FEATURE_LESS_RAW("R") "h~] [FILE]..."
 //usage:#define less_full_usage "\n\n"
 //usage:       "View FILE (or stdin) one screenful at a time\n"
 //usage:     "\n	-E	Quit once the end of a file is reached"
+//usage:     "\n	-F	Quit if entire file fits on first screen"
 //usage:	IF_FEATURE_LESS_REGEXP(
 //usage:     "\n	-I	Ignore case in all searches"
 //usage:	)
@@ -121,6 +138,9 @@
 //usage:	IF_FEATURE_LESS_TRUNCATE(
 //usage:     "\n	-S	Truncate long lines"
 //usage:	)
+//usage:	IF_FEATURE_LESS_RAW(
+//usage:     "\n	-R	Remove color escape codes in input"
+//usage:	)
 //usage:     "\n	-~	Suppress ~s displayed past EOF"
 
 #include <sched.h>  /* sched_yield() */
@@ -156,7 +176,9 @@ enum {
 	FLAG_N = 1 << 3,
 	FLAG_TILDE = 1 << 4,
 	FLAG_I = 1 << 5,
-	FLAG_S = (1 << 6) * ENABLE_FEATURE_LESS_TRUNCATE,
+	FLAG_F = 1 << 6,
+	FLAG_S = (1 << 7) * ENABLE_FEATURE_LESS_TRUNCATE,
+	FLAG_R = (1 << 8) * ENABLE_FEATURE_LESS_RAW,
 /* hijack command line options variable for internal state vars */
 	LESS_STATE_MATCH_BACKWARDS = 1 << 15,
 };
@@ -207,6 +229,9 @@ struct globals {
 	regex_t pattern;
 	smallint pattern_valid;
 #endif
+#if ENABLE_FEATURE_LESS_RAW
+	smallint in_escape;
+#endif
 #if ENABLE_FEATURE_LESS_ASK_TERMINAL
 	smallint winsize_err;
 #endif
@@ -255,7 +280,6 @@ struct globals {
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
 	less_gets_pos = -1; \
 	empty_line_marker = "~"; \
-	num_files = 1; \
 	current_file = 1; \
 	eof_error = 1; \
 	terminated = 1; \
@@ -514,6 +538,26 @@ static void read_lines(void)
 				*--p = '\0';
 				continue;
 			}
+#if ENABLE_FEATURE_LESS_RAW
+			if (option_mask32 & FLAG_R) {
+				if (c == '\033')
+					goto discard;
+				if (G.in_escape) {
+					if (isdigit(c)
+					 || c == '['
+					 || c == ';'
+					 || c == 'm'
+					) {
+ discard:
+						G.in_escape = (c != 'm');
+						readpos++;
+						continue;
+					}
+					/* Hmm, unexpected end of "ESC [ N ; N m" sequence */
+					G.in_escape = 0;
+				}
+			}
+#endif
 			{
 				size_t new_last_line_pos = last_line_pos + 1;
 				if (c == '\t') {
@@ -864,11 +908,12 @@ static void buffer_print(void)
 		else
 			print_ascii(buffer[i]);
 	}
-	if ((option_mask32 & FLAG_E)
+	if ((option_mask32 & (FLAG_E|FLAG_F))
 	 && eof_error <= 0
-	 && (max_fline - cur_fline) <= max_displayed_line
 	) {
-		less_exit(EXIT_SUCCESS);
+		i = option_mask32 & FLAG_F ? 0 : cur_fline;
+		if (max_fline - i <= max_displayed_line)
+			less_exit(EXIT_SUCCESS);
 	}
 	status_print();
 }
@@ -1772,12 +1817,37 @@ int less_main(int argc, char **argv)
 	 * -s: condense many empty lines to one
 	 *     (used by some setups for manpage display)
 	 */
-	getopt32(argv, "EMmN~I" IF_FEATURE_LESS_TRUNCATE("S") /*ignored:*/"s");
-	argc -= optind;
+	getopt32(argv, "EMmN~IF"
+		IF_FEATURE_LESS_TRUNCATE("S")
+		IF_FEATURE_LESS_RAW("R")
+		/*ignored:*/"s"
+	);
 	argv += optind;
-	num_files = argc;
+	num_files = argc - optind;
 	files = argv;
 
+	/* Tools typically pass LESS="FRSXMK".
+	 * The options we don't understand are ignored. */
+	if (ENABLE_FEATURE_LESS_ENV) {
+		char *c = getenv("LESS");
+		if (c) while (*c) switch (*c++) {
+		case 'F':
+			option_mask32 |= FLAG_F;
+			break;
+		case 'M':
+			option_mask32 |= FLAG_M;
+			break;
+		case 'R':
+			option_mask32 |= FLAG_R;
+			break;
+		case 'S':
+			option_mask32 |= FLAG_S;
+			break;
+		default:
+			break;
+		}
+	}
+
 	/* Another popular pager, most, detects when stdout
 	 * is not a tty and turns into cat. This makes sense. */
 	if (!isatty(STDOUT_FILENO))
@@ -1786,7 +1856,6 @@ int less_main(int argc, char **argv)
 	if (!num_files) {
 		if (isatty(STDIN_FILENO)) {
 			/* Just "less"? No args and no redirection? */
-			bb_error_msg("missing filename");
 			bb_show_usage();
 		}
 	} else {
@@ -1822,7 +1891,7 @@ int less_main(int argc, char **argv)
 	G.kbd_fd_orig_flags = ndelay_on(tty_fd);
 	kbd_fd = tty_fd; /* save in a global */
 
-	get_termios_and_make_raw(tty_fd, &term_less, &term_orig, TERMIOS_RAW_CRNL);
+	get_termios_and_make_raw(tty_fd, &term_less, &term_orig, TERMIOS_RAW_CRNL_INPUT);
 
 	IF_FEATURE_LESS_ASK_TERMINAL(G.winsize_err =) get_terminal_width_height(tty_fd, &width, &max_displayed_line);
 	/* 20: two tabstops + 4 */
diff -urpN busybox-1.28.4/miscutils/nandwrite.c busybox-1.29.0/miscutils/nandwrite.c
--- busybox-1.28.4/miscutils/nandwrite.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/miscutils/nandwrite.c	2018-07-02 15:55:14.000000000 +0200
@@ -53,6 +53,15 @@
 #include "libbb.h"
 #include <mtd/mtd-user.h>
 
+/* Old headers call it MTD_MODE_RAW.
+ * FIXME: In kernel headers, MTD_FILE_MODE_RAW is not a define,
+ * it's an enum. How I can test for existence of an enum?
+ */
+#if !defined(MTD_FILE_MODE_RAW)
+# define MTD_FILE_MODE_RAW 3
+#endif
+
+
 #define IS_NANDDUMP  (ENABLE_NANDDUMP && (!ENABLE_NANDWRITE || (applet_name[4] == 'd')))
 #define IS_NANDWRITE (ENABLE_NANDWRITE && (!ENABLE_NANDDUMP || (applet_name[4] != 'd')))
 
diff -urpN busybox-1.28.4/miscutils/setfattr.c busybox-1.29.0/miscutils/setfattr.c
--- busybox-1.28.4/miscutils/setfattr.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/miscutils/setfattr.c	2018-07-02 15:55:14.000000000 +0200
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SETFATTR
-//config:	bool "setfattr"
+//config:	bool "setfattr (3.6 kb)"
 //config:	default y
 //config:	help
 //config:	Set/delete extended attributes on files
diff -urpN busybox-1.28.4/miscutils/time.c busybox-1.29.0/miscutils/time.c
--- busybox-1.28.4/miscutils/time.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/miscutils/time.c	2018-07-02 15:55:14.000000000 +0200
@@ -32,7 +32,6 @@
 //usage:     "\n	-a	Append (else overwrite)"
 
 #include "libbb.h"
-#include <sys/resource.h> /* getrusage */
 
 /* Information on the resources used by a child process.  */
 typedef struct {
diff -urpN busybox-1.28.4/modutils/Config.src busybox-1.29.0/modutils/Config.src
--- busybox-1.28.4/modutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/modutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Linux Module Utilities"
diff -urpN busybox-1.28.4/networking/Config.src busybox-1.29.0/networking/Config.src
--- busybox-1.28.4/networking/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Networking Utilities"
diff -urpN busybox-1.28.4/networking/arping.c busybox-1.29.0/networking/arping.c
--- busybox-1.28.4/networking/arping.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/arping.c	2018-07-02 15:55:14.000000000 +0200
@@ -11,7 +11,6 @@
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Ping hosts by ARP packets.
-//config:
 
 //applet:IF_ARPING(APPLET(arping, BB_DIR_USR_SBIN, BB_SUID_DROP))
 
@@ -29,6 +28,7 @@
 //usage:     "\n	-A		ARP answer mode, update your neighbors"
 //usage:     "\n	-c N		Stop after sending N ARP requests"
 //usage:     "\n	-w TIMEOUT	Seconds to wait for ARP reply"
+//NB: in iputils-s20160308, iface is mandatory, no default
 //usage:     "\n	-I IFACE	Interface to use (default eth0)"
 //usage:     "\n	-s SRC_IP	Sender IP address"
 //usage:     "\n	DST_IP		Target IP address"
@@ -45,21 +45,29 @@
 #define MONOTONIC_US() ((unsigned)monotonic_us())
 
 enum {
-	DAD = 1,
-	UNSOLICITED = 2,
-	ADVERT = 4,
-	QUIET = 8,
-	QUIT_ON_REPLY = 16,
-	BCAST_ONLY = 32,
-	UNICASTING = 64
+	UNSOLICITED   = 1 << 0,
+	DAD           = 1 << 1,
+	ADVERT        = 1 << 2,
+	QUIET         = 1 << 3,
+	QUIT_ON_REPLY = 1 << 4,
+	BCAST_ONLY    = 1 << 5,
+	UNICASTING    = 1 << 6,
+	TIMEOUT       = 1 << 7,
 };
+#define GETOPT32(str_timeout, device, source) \
+	getopt32(argv, "^" \
+		"UDAqfbc:+w:I:s:" \
+		/* DAD also sets quit_on_reply, */ \
+		/* advert also sets unsolicited: */ \
+		"\0" "=1:Df:AU", \
+		&count, &str_timeout, &device, &source \
+	);
 
 struct globals {
 	struct in_addr src;
 	struct in_addr dst;
 	struct sockaddr_ll me;
 	struct sockaddr_ll he;
-	int sock_fd;
 
 	int count; // = -1;
 	unsigned last;
@@ -71,13 +79,17 @@ struct globals {
 	unsigned received;
 	unsigned brd_recv;
 	unsigned req_recv;
+
+	/* should be in main(), but are here to reduce stack use: */
+	struct ifreq ifr;
+	struct sockaddr_in probe_saddr;
+	sigset_t sset;
+	unsigned char packet[4096];
 } FIX_ALIASING;
-#define G (*(struct globals*)bb_common_bufsiz1)
 #define src        (G.src       )
 #define dst        (G.dst       )
 #define me         (G.me        )
 #define he         (G.he        )
-#define sock_fd    (G.sock_fd   )
 #define count      (G.count     )
 #define last       (G.last      )
 #define timeout_us (G.timeout_us)
@@ -87,26 +99,25 @@ struct globals {
 #define received   (G.received  )
 #define brd_recv   (G.brd_recv  )
 #define req_recv   (G.req_recv  )
+//#define G (*(struct globals*)bb_common_bufsiz1)
+#define G (*ptr_to_globals)
 #define INIT_G() do { \
-	setup_common_bufsiz(); \
+	/*setup_common_bufsiz();*/ \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
 	count = -1; \
 } while (0)
 
-// If GNUisms are not available...
-//static void *mempcpy(void *_dst, const void *_src, int n)
-//{
-//	memcpy(_dst, _src, n);
-//	return (char*)_dst + n;
-//}
+#define sock_fd 3
 
 static int send_pack(struct in_addr *src_addr,
-			struct in_addr *dst_addr, struct sockaddr_ll *ME,
+			struct in_addr *dst_addr,
+			struct sockaddr_ll *ME,
 			struct sockaddr_ll *HE)
 {
 	int err;
 	unsigned char buf[256];
 	struct arphdr *ah = (struct arphdr *) buf;
-	unsigned char *p = (unsigned char *) (ah + 1);
+	unsigned char *p;
 
 	ah->ar_hrd = htons(ARPHRD_ETHER);
 	ah->ar_pro = htons(ETH_P_IP);
@@ -114,6 +125,7 @@ static int send_pack(struct in_addr *src
 	ah->ar_pln = 4;
 	ah->ar_op = option_mask32 & ADVERT ? htons(ARPOP_REPLY) : htons(ARPOP_REQUEST);
 
+	p = (unsigned char *) (ah + 1);
 	p = mempcpy(p, &ME->sll_addr, ah->ar_hln);
 	p = mempcpy(p, src_addr, 4);
 
@@ -139,10 +151,10 @@ static void finish(void)
 {
 	if (!(option_mask32 & QUIET)) {
 		printf("Sent %u probe(s) (%u broadcast(s))\n"
-			"Received %u repl%s"
+			"Received %u response(s)"
 			" (%u request(s), %u broadcast(s))\n",
 			sent, brd_sent,
-			received, (received == 1) ? "ies" : "y",
+			received,
 			req_recv, brd_recv);
 	}
 	if (option_mask32 & DAD)
@@ -180,15 +192,10 @@ static void recv_pack(unsigned char *buf
 	struct arphdr *ah = (struct arphdr *) buf;
 	unsigned char *p = (unsigned char *) (ah + 1);
 	struct in_addr src_ip, dst_ip;
+
 	/* moves below assume in_addr is 4 bytes big, ensure that */
-	struct BUG_in_addr_must_be_4 {
-		char BUG_in_addr_must_be_4[
-			sizeof(struct in_addr) == 4 ? 1 : -1
-		];
-		char BUG_s_addr_must_be_4[
-			sizeof(src_ip.s_addr) == 4 ? 1 : -1
-		];
-	};
+	BUILD_BUG_ON(sizeof(struct in_addr) != 4);
+	BUILD_BUG_ON(sizeof(src_ip.s_addr) != 4);
 
 	/* Filter out wild packets */
 	if (FROM->sll_pkttype != PACKET_HOST
@@ -209,8 +216,10 @@ static void recv_pack(unsigned char *buf
 	if (ah->ar_pro != htons(ETH_P_IP)
 	 || (ah->ar_pln != 4)
 	 || (ah->ar_hln != me.sll_halen)
-	 || (len < (int)(sizeof(*ah) + 2 * (4 + ah->ar_hln))))
+	 || (len < (int)(sizeof(*ah) + 2 * (4 + ah->ar_hln)))
+	) {
 		return;
+	}
 
 	move_from_unaligned32(src_ip.s_addr, p + ah->ar_hln);
 	move_from_unaligned32(dst_ip.s_addr, p + ah->ar_hln + 4 + ah->ar_hln);
@@ -242,6 +251,7 @@ static void recv_pack(unsigned char *buf
 	if (!(option_mask32 & QUIET)) {
 		int s_printed = 0;
 
+//TODO: arping from iputils-s20160308 print upprcase hex in MAC, follow them?
 		printf("%scast re%s from %s [%02x:%02x:%02x:%02x:%02x:%02x]",
 			FROM->sll_pkttype == PACKET_HOST ? "Uni" : "Broad",
 			ah->ar_op == htons(ARPOP_REPLY) ? "ply" : "quest",
@@ -249,14 +259,14 @@ static void recv_pack(unsigned char *buf
 			p[0], p[1], p[2], p[3], p[4], p[5]
 		);
 		if (dst_ip.s_addr != src.s_addr) {
-			printf("for %s ", inet_ntoa(dst_ip));
+			printf("for %s", inet_ntoa(dst_ip));
 			s_printed = 1;
 		}
 		if (memcmp(p + ah->ar_hln + 4, me.sll_addr, ah->ar_hln)) {
 			unsigned char *pp = p + ah->ar_hln + 4;
 			if (!s_printed)
-				printf("for ");
-			printf("[%02x:%02x:%02x:%02x:%02x:%02x]",
+				printf(" for");
+			printf(" [%02x:%02x:%02x:%02x:%02x:%02x]",
 				pp[0], pp[1], pp[2], pp[3], pp[4], pp[5]
 			);
 		}
@@ -288,12 +298,11 @@ int arping_main(int argc UNUSED_PARAM, c
 	const char *device = "eth0";
 	char *source = NULL;
 	char *target;
-	unsigned char *packet;
 	char *err_str;
 
 	INIT_G();
 
-	sock_fd = xsocket(AF_PACKET, SOCK_DGRAM, 0);
+	xmove_fd(xsocket(AF_PACKET, SOCK_DGRAM, 0), sock_fd);
 
 	// If you ever change BB_SUID_DROP to BB_SUID_REQUIRE,
 	// drop suid root privileges here:
@@ -303,41 +312,30 @@ int arping_main(int argc UNUSED_PARAM, c
 		unsigned opt;
 		char *str_timeout;
 
-		/* Dad also sets quit_on_reply.
-		 * Advert also sets unsolicited.
-		 */
-		opt = getopt32(argv, "^" "DUAqfbc:+w:I:s:" "\0" "=1:Df:AU",
-				&count, &str_timeout, &device, &source
-		);
-		if (opt & 0x80) /* -w: timeout */
+		opt = GETOPT32(str_timeout, device, source);
+		if (opt & TIMEOUT)
 			timeout_us = xatou_range(str_timeout, 0, INT_MAX/2000000) * 1000000 + 500000;
-		//if (opt & 0x200) /* -s: source */
-		option_mask32 &= 0x3f; /* set respective flags */
 	}
 
 	target = argv[optind];
 	err_str = xasprintf("interface %s %%s", device);
 	xfunc_error_retval = 2;
 
-	{
-		struct ifreq ifr;
-
-		memset(&ifr, 0, sizeof(ifr));
-		strncpy_IFNAMSIZ(ifr.ifr_name, device);
-		/* We use ifr.ifr_name in error msg so that problem
-		 * with truncated name will be visible */
-		ioctl_or_perror_and_die(sock_fd, SIOCGIFINDEX, &ifr, err_str, "not found");
-		me.sll_ifindex = ifr.ifr_ifindex;
-
-		xioctl(sock_fd, SIOCGIFFLAGS, (char *) &ifr);
-
-		if (!(ifr.ifr_flags & IFF_UP)) {
-			bb_error_msg_and_die(err_str, "is down");
-		}
-		if (ifr.ifr_flags & (IFF_NOARP | IFF_LOOPBACK)) {
-			bb_error_msg(err_str, "is not ARPable");
-			return (option_mask32 & DAD ? 0 : 2);
-		}
+	/*memset(&G.ifr, 0, sizeof(G.ifr)); - zeroed by INIT_G */
+	strncpy_IFNAMSIZ(G.ifr.ifr_name, device);
+	ioctl_or_perror_and_die(sock_fd, SIOCGIFINDEX, &G.ifr, err_str, "not found");
+	me.sll_ifindex = G.ifr.ifr_ifindex;
+
+	xioctl(sock_fd, SIOCGIFFLAGS, (char *) &G.ifr);
+
+	if (!(G.ifr.ifr_flags & IFF_UP)) {
+		bb_error_msg_and_die(err_str, "is down");
+	}
+	if (G.ifr.ifr_flags & (IFF_NOARP | IFF_LOOPBACK)) {
+		bb_error_msg(err_str, "is not ARPable");
+		BUILD_BUG_ON(DAD != 2);
+		/* exit 0 if DAD, else exit 2 */
+		return (~option_mask32 & DAD);
 	}
 
 	/* if (!inet_aton(target, &dst)) - not needed */ {
@@ -356,33 +354,29 @@ int arping_main(int argc UNUSED_PARAM, c
 		src = dst;
 
 	if (!(option_mask32 & DAD) || src.s_addr) {
-		struct sockaddr_in saddr;
+		/*struct sockaddr_in probe_saddr;*/
 		int probe_fd = xsocket(AF_INET, SOCK_DGRAM, 0);
 
 		setsockopt_bindtodevice(probe_fd, device);
-		memset(&saddr, 0, sizeof(saddr));
-		saddr.sin_family = AF_INET;
+
+		/*memset(&G.probe_saddr, 0, sizeof(G.probe_saddr)); - zeroed by INIT_G */
+		G.probe_saddr.sin_family = AF_INET;
 		if (src.s_addr) {
 			/* Check that this is indeed our IP */
-			saddr.sin_addr = src;
-			xbind(probe_fd, (struct sockaddr *) &saddr, sizeof(saddr));
+			G.probe_saddr.sin_addr = src;
+			xbind(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 		} else { /* !(option_mask32 & DAD) case */
 			/* Find IP address on this iface */
-			socklen_t alen = sizeof(saddr);
-
-			saddr.sin_port = htons(1025);
-			saddr.sin_addr = dst;
+			G.probe_saddr.sin_port = htons(1025);
+			G.probe_saddr.sin_addr = dst;
 
 			if (setsockopt_SOL_SOCKET_1(probe_fd, SO_DONTROUTE) != 0)
 				bb_perror_msg("setsockopt(%s)", "SO_DONTROUTE");
-			xconnect(probe_fd, (struct sockaddr *) &saddr, sizeof(saddr));
-			getsockname(probe_fd, (struct sockaddr *) &saddr, &alen);
-			//never happens:
-			//if (getsockname(probe_fd, (struct sockaddr *) &saddr, &alen) == -1)
-			//	bb_perror_msg_and_die("getsockname");
-			if (saddr.sin_family != AF_INET)
+			xconnect(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
+			bb_getsockname(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
+			if (G.probe_saddr.sin_family != AF_INET)
 				bb_error_msg_and_die("no IP address configured");
-			src = saddr.sin_addr;
+			src = G.probe_saddr.sin_addr;
 		}
 		close(probe_fd);
 	}
@@ -392,48 +386,53 @@ int arping_main(int argc UNUSED_PARAM, c
 	me.sll_protocol = htons(ETH_P_ARP);
 	xbind(sock_fd, (struct sockaddr *) &me, sizeof(me));
 
-	{
-		socklen_t alen = sizeof(me);
-		getsockname(sock_fd, (struct sockaddr *) &me, &alen);
-		//never happens:
-		//if (getsockname(sock_fd, (struct sockaddr *) &me, &alen) == -1)
-		//	bb_perror_msg_and_die("getsockname");
-	}
+	bb_getsockname(sock_fd, (struct sockaddr *) &me, sizeof(me));
+	//never happens:
+	//if (getsockname(sock_fd, (struct sockaddr *) &me, &alen) == -1)
+	//	bb_perror_msg_and_die("getsockname");
 	if (me.sll_halen == 0) {
 		bb_error_msg(err_str, "is not ARPable (no ll address)");
-		return (option_mask32 & DAD ? 0 : 2);
+		BUILD_BUG_ON(DAD != 2);
+		/* exit 0 if DAD, else exit 2 */
+		return (~option_mask32 & DAD);
 	}
 	he = me;
 	memset(he.sll_addr, -1, he.sll_halen);
 
 	if (!(option_mask32 & QUIET)) {
 		/* inet_ntoa uses static storage, can't use in same printf */
-		printf("ARPING to %s", inet_ntoa(dst));
-		printf(" from %s via %s\n", inet_ntoa(src), device);
+		printf("ARPING %s", inet_ntoa(dst));
+		printf(" from %s %s\n", inet_ntoa(src), device);
 	}
 
+	/*sigemptyset(&G.sset); - zeroed by INIT_G */
+	sigaddset(&G.sset, SIGALRM);
+	sigaddset(&G.sset, SIGINT);
 	signal_SA_RESTART_empty_mask(SIGINT,  (void (*)(int))finish);
 	signal_SA_RESTART_empty_mask(SIGALRM, (void (*)(int))catcher);
 
+	/* Send the first packet, arm ALRM */
 	catcher();
 
-	packet = xmalloc(4096);
 	while (1) {
-		sigset_t sset, osset;
 		struct sockaddr_ll from;
 		socklen_t alen = sizeof(from);
 		int cc;
 
-		cc = recvfrom(sock_fd, packet, 4096, 0, (struct sockaddr *) &from, &alen);
+		/* Unblock SIGALRM so that the previously called alarm()
+		 * can prevent recvfrom from blocking forever in case the
+		 * inherited procmask is blocking SIGALRM.
+		 */
+		sigprocmask(SIG_UNBLOCK, &G.sset, NULL);
+
+		cc = recvfrom(sock_fd, G.packet, sizeof(G.packet), 0, (struct sockaddr *) &from, &alen);
+
+		/* Don't allow SIGALRMs while we process the reply */
+		sigprocmask(SIG_BLOCK, &G.sset, NULL);
 		if (cc < 0) {
 			bb_perror_msg("recvfrom");
 			continue;
 		}
-		sigemptyset(&sset);
-		sigaddset(&sset, SIGALRM);
-		sigaddset(&sset, SIGINT);
-		sigprocmask(SIG_BLOCK, &sset, &osset);
-		recv_pack(packet, cc, &from);
-		sigprocmask(SIG_SETMASK, &osset, NULL);
+		recv_pack(G.packet, cc, &from);
 	}
 }
diff -urpN busybox-1.28.4/networking/ftpd.c busybox-1.29.0/networking/ftpd.c
--- busybox-1.28.4/networking/ftpd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ftpd.c	2018-07-02 15:55:14.000000000 +0200
@@ -57,7 +57,7 @@
 //usage:       "[-wvS]"IF_FEATURE_FTPD_AUTHENTICATION(" [-a USER]")" [-t N] [-T N] [DIR]"
 //usage:#define ftpd_full_usage "\n\n"
 //usage:	IF_NOT_FEATURE_FTPD_AUTHENTICATION(
-//usage:       "Anonymous FTP server. Accesses by clients occur under ftpd's UID.\n"
+//usage:       "Anonymous FTP server. Client access occurs under ftpd's UID.\n"
 //usage:	)
 //usage:	IF_FEATURE_FTPD_AUTHENTICATION(
 //usage:       "FTP server. "
@@ -66,9 +66,15 @@
 //usage:       "Should be used as inetd service, inetd.conf line:\n"
 //usage:       "	21 stream tcp nowait root ftpd ftpd /files/to/serve\n"
 //usage:       "Can be run from tcpsvd:\n"
-//usage:       "	tcpsvd -vE 0.0.0.0 21 ftpd /files/to/serve\n"
+//usage:       "	tcpsvd -vE 0.0.0.0 21 ftpd /files/to/serve"
+//usage:     "\n"
 //usage:     "\n	-w	Allow upload"
 //usage:	IF_FEATURE_FTPD_AUTHENTICATION(
+//usage:     "\n	-A	No login required, client access occurs under ftpd's UID"
+//
+// if !FTPD_AUTHENTICATION, -A is accepted too, but not shown in --help
+// since it's the only supported mode in that configuration
+//
 //usage:     "\n	-a USER	Enable 'anonymous' login and map it to USER"
 //usage:	)
 //usage:     "\n	-v	Log errors to stderr. -vv: verbose log"
@@ -171,9 +177,13 @@ struct globals {
 	char msg_ok [(sizeof("NNN " MSG_OK ) + 3) & 0xfffc];
 	char msg_err[(sizeof("NNN " MSG_ERR) + 3) & 0xfffc];
 } FIX_ALIASING;
-#define G (*(struct globals*)bb_common_bufsiz1)
+#define G (*ptr_to_globals)
+/* ^^^ about 75 bytes smaller code than this: */
+//#define G (*(struct globals*)bb_common_bufsiz1)
 #define INIT_G() do { \
-	setup_common_bufsiz(); \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	/*setup_common_bufsiz();*/ \
+	\
 	/* Moved to main */ \
 	/*strcpy(G.msg_ok  + 4, MSG_OK );*/ \
 	/*strcpy(G.msg_err + 4, MSG_ERR);*/ \
@@ -258,7 +268,7 @@ cmdio_write(uint32_t status_str, const c
 static void
 cmdio_write_ok(unsigned status)
 {
-	*(uint32_t *) G.msg_ok = status;
+	*(bb__aliased_uint32_t *) G.msg_ok = status;
 	xwrite(STDOUT_FILENO, G.msg_ok, sizeof("NNN " MSG_OK) - 1);
 	if (G.verbose > 1)
 		verbose_log(G.msg_ok);
@@ -269,7 +279,7 @@ cmdio_write_ok(unsigned status)
 static void
 cmdio_write_error(unsigned status)
 {
-	*(uint32_t *) G.msg_err = status;
+	*(bb__aliased_uint32_t *) G.msg_err = status;
 	xwrite(STDOUT_FILENO, G.msg_err, sizeof("NNN " MSG_ERR) - 1);
 	if (G.verbose > 0)
 		verbose_log(G.msg_err);
@@ -599,7 +609,7 @@ static void
 handle_rest(void)
 {
 	/* When ftp_arg == NULL simply restart from beginning */
-	G.restart_pos = G.ftp_arg ? xatoi_positive(G.ftp_arg) : 0;
+	G.restart_pos = G.ftp_arg ? XATOOFF(G.ftp_arg) : 0;
 	WRITE_OK(FTP_RESTOK);
 }
 
@@ -1151,11 +1161,12 @@ enum {
 #if !BB_MMU
 	OPT_l = (1 << 0),
 	OPT_1 = (1 << 1),
-	OPT_A = (1 << 2),
 #endif
-	OPT_v = (1 << ((!BB_MMU) * 3 + 0)),
-	OPT_S = (1 << ((!BB_MMU) * 3 + 1)),
-	OPT_w = (1 << ((!BB_MMU) * 3 + 2)) * ENABLE_FEATURE_FTPD_WRITE,
+	BIT_A =        (!BB_MMU) * 2,
+	OPT_A = (1 << (BIT_A + 0)),
+	OPT_v = (1 << (BIT_A + 1)),
+	OPT_S = (1 << (BIT_A + 2)),
+	OPT_w = (1 << (BIT_A + 3)) * ENABLE_FEATURE_FTPD_WRITE,
 };
 
 int ftpd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -1175,24 +1186,25 @@ int ftpd_main(int argc UNUSED_PARAM, cha
 	verbose_S = 0;
 	G.timeout = 2 * 60;
 #if BB_MMU
-	opts = getopt32(argv, "^"    "vS"
-		IF_FEATURE_FTPD_WRITE("w") "t:+T:+" IF_FEATURE_FTPD_AUTHENTICATION("a:")
+	opts = getopt32(argv, "^"   "AvS" IF_FEATURE_FTPD_WRITE("w")
+		"t:+T:+" IF_FEATURE_FTPD_AUTHENTICATION("a:")
 		"\0" "vv:SS",
 		&G.timeout, &abs_timeout, IF_FEATURE_FTPD_AUTHENTICATION(&anon_opt,)
 		&G.verbose, &verbose_S
 	);
 #else
-	opts = getopt32(argv, "^" "l1AvS"
-		IF_FEATURE_FTPD_WRITE("w") "t:+T:+" IF_FEATURE_FTPD_AUTHENTICATION("a:")
+	opts = getopt32(argv, "^" "l1AvS" IF_FEATURE_FTPD_WRITE("w")
+		"t:+T:+" IF_FEATURE_FTPD_AUTHENTICATION("a:")
 		"\0" "vv:SS",
 		&G.timeout, &abs_timeout, IF_FEATURE_FTPD_AUTHENTICATION(&anon_opt,)
 		&G.verbose, &verbose_S
 	);
 	if (opts & (OPT_l|OPT_1)) {
-		/* Our secret backdoor to ls */
+		/* Our secret backdoor to ls: see popen_ls() */
 		if (fchdir(3) != 0)
 			_exit(127);
 		/* memset(&G, 0, sizeof(G)); - ls_main does it */
+		/* NB: in this case -A has a different meaning: like "ls -A" */
 		return ls_main(/*argc_unused*/ 0, argv);
 	}
 #endif
@@ -1250,30 +1262,32 @@ int ftpd_main(int argc UNUSED_PARAM, cha
 	signal(SIGALRM, timeout_handler);
 
 #if ENABLE_FEATURE_FTPD_AUTHENTICATION
-	while (1) {
-		uint32_t cmdval = cmdio_get_cmd_and_arg();
-		if (cmdval == const_USER) {
-			if (anon_opt && strcmp(G.ftp_arg, "anonymous") == 0) {
-				pw = getpwnam(anon_opt);
-				if (pw)
-					break; /* does not even ask for password */
-			}
-			pw = getpwnam(G.ftp_arg);
-			cmdio_write_raw(STR(FTP_GIVEPWORD)" Please specify password\r\n");
-		} else if (cmdval == const_PASS) {
-			if (check_password(pw, G.ftp_arg) > 0) {
-				break;	/* login success */
+	if (!(opts & OPT_A)) {
+		while (1) {
+			uint32_t cmdval = cmdio_get_cmd_and_arg();
+			if (cmdval == const_USER) {
+				if (anon_opt && strcmp(G.ftp_arg, "anonymous") == 0) {
+					pw = getpwnam(anon_opt);
+					if (pw)
+						break; /* does not even ask for password */
+				}
+				pw = getpwnam(G.ftp_arg);
+				cmdio_write_raw(STR(FTP_GIVEPWORD)" Specify password\r\n");
+			} else if (cmdval == const_PASS) {
+				if (check_password(pw, G.ftp_arg) > 0) {
+					break;	/* login success */
+				}
+				cmdio_write_raw(STR(FTP_LOGINERR)" Login failed\r\n");
+				pw = NULL;
+			} else if (cmdval == const_QUIT) {
+				WRITE_OK(FTP_GOODBYE);
+				return 0;
+			} else {
+				cmdio_write_raw(STR(FTP_LOGINERR)" Login with USER+PASS\r\n");
 			}
-			cmdio_write_raw(STR(FTP_LOGINERR)" Login failed\r\n");
-			pw = NULL;
-		} else if (cmdval == const_QUIT) {
-			WRITE_OK(FTP_GOODBYE);
-			return 0;
-		} else {
-			cmdio_write_raw(STR(FTP_LOGINERR)" Login with USER and PASS\r\n");
 		}
+		WRITE_OK(FTP_LOGINOK);
 	}
-	WRITE_OK(FTP_LOGINOK);
 #endif
 
 	/* Do this after auth, else /etc/passwd is not accessible */
@@ -1305,7 +1319,9 @@ int ftpd_main(int argc UNUSED_PARAM, cha
 	}
 
 #if ENABLE_FEATURE_FTPD_AUTHENTICATION
-	change_identity(pw);
+	if (pw)
+		change_identity(pw);
+	/* else: -A is in effect */
 #endif
 
 	/* RFC-959 Section 5.1
diff -urpN busybox-1.28.4/networking/ftpgetput.c busybox-1.29.0/networking/ftpgetput.c
--- busybox-1.28.4/networking/ftpgetput.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ftpgetput.c	2018-07-02 15:55:14.000000000 +0200
@@ -152,46 +152,16 @@ static void ftp_login(void)
 
 static int xconnect_ftpdata(void)
 {
-	char *buf_ptr;
-	unsigned port_num;
+	int port_num;
 
-/*
-TODO: PASV command will not work for IPv6. RFC2428 describes
-IPv6-capable "extended PASV" - EPSV.
-
-"EPSV [protocol]" asks server to bind to and listen on a data port
-in specified protocol. Protocol is 1 for IPv4, 2 for IPv6.
-If not specified, defaults to "same as used for control connection".
-If server understood you, it should answer "229 <some text>(|||port|)"
-where "|" are literal pipe chars and "port" is ASCII decimal port#.
-
-There is also an IPv6-capable replacement for PORT (EPRT),
-but we don't need that.
-
-NB: PASV may still work for some servers even over IPv6.
-For example, vsftp happily answers
-"227 Entering Passive Mode (0,0,0,0,n,n)" and proceeds as usual.
-
-TODO2: need to stop ignoring IP address in PASV response.
-*/
-
-	if (ftpcmd("PASV", NULL) != 227) {
+	if (ENABLE_FEATURE_IPV6 && ftpcmd("EPSV", NULL) == 229) {
+		/* good */
+	} else if (ftpcmd("PASV", NULL) != 227) {
 		ftp_die("PASV");
 	}
-
-	/* Response is "NNN garbageN1,N2,N3,N4,P1,P2[)garbage]
-	 * Server's IP is N1.N2.N3.N4 (we ignore it)
-	 * Server's port for data connection is P1*256+P2 */
-	buf_ptr = strrchr(buf, ')');
-	if (buf_ptr) *buf_ptr = '\0';
-
-	buf_ptr = strrchr(buf, ',');
-	*buf_ptr = '\0';
-	port_num = xatoul_range(buf_ptr + 1, 0, 255);
-
-	buf_ptr = strrchr(buf, ',');
-	*buf_ptr = '\0';
-	port_num += xatoul_range(buf_ptr + 1, 0, 255) * 256;
+	port_num = parse_pasv_epsv(buf);
+	if (port_num < 0)
+		ftp_die("PASV");
 
 	set_nport(&lsa->u.sa, htons(port_num));
 	return xconnect_stream(lsa);
@@ -339,7 +309,7 @@ int ftpgetput_main(int argc UNUSED_PARAM
 	INIT_G();
 	/* Set default values */
 	user = "anonymous";
-	password = "busybox@";
+	password = "busybox";
 
 	/*
 	 * Decipher the command line
diff -urpN busybox-1.28.4/networking/httpd.c busybox-1.29.0/networking/httpd.c
--- busybox-1.28.4/networking/httpd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/httpd.c	2018-07-02 15:55:14.000000000 +0200
@@ -392,7 +392,10 @@ static const struct {
 struct globals {
 	int verbose;            /* must be int (used by getopt32) */
 	smallint flg_deny_all;
-
+#if ENABLE_FEATURE_HTTPD_GZIP
+	/* client can handle gzip / we are going to send gzip */
+	smallint content_gzip;
+#endif
 	unsigned rmt_ip;        /* used for IP-based allow/deny rules */
 	time_t last_mod;
 	char *rmt_ip_str;       /* for $REMOTE_ADDR and $REMOTE_PORT */
@@ -440,14 +443,15 @@ struct globals {
 #if ENABLE_FEATURE_HTTPD_PROXY
 	Htaccess_Proxy *proxy;
 #endif
-#if ENABLE_FEATURE_HTTPD_GZIP
-	/* client can handle gzip / we are going to send gzip */
-	smallint content_gzip;
-#endif
 };
 #define G (*ptr_to_globals)
 #define verbose           (G.verbose          )
 #define flg_deny_all      (G.flg_deny_all     )
+#if ENABLE_FEATURE_HTTPD_GZIP
+# define content_gzip     (G.content_gzip     )
+#else
+# define content_gzip     0
+#endif
 #define rmt_ip            (G.rmt_ip           )
 #define bind_addr_or_port (G.bind_addr_or_port)
 #define g_query           (G.g_query          )
@@ -481,11 +485,6 @@ enum {
 #define hdr_cnt           (G.hdr_cnt          )
 #define http_error_page   (G.http_error_page  )
 #define proxy             (G.proxy            )
-#if ENABLE_FEATURE_HTTPD_GZIP
-# define content_gzip     (G.content_gzip     )
-#else
-# define content_gzip     0
-#endif
 #define INIT_G() do { \
 	setup_common_bufsiz(); \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
@@ -944,7 +943,7 @@ static char *encodeString(const char *st
 		if (isalnum(ch))
 			*p++ = ch;
 		else
-			p += sprintf(p, "&#%d;", (unsigned char) ch);
+			p += sprintf(p, "&#%u;", (unsigned char) ch);
 	}
 	*p = '\0';
 	return out;
@@ -1040,20 +1039,21 @@ static void log_and_exit(void)
  * second packet is delayed for any reason.
  * responseNum - the result code to send.
  */
-static void send_headers(int responseNum)
+static void send_headers(unsigned responseNum)
 {
 	static const char RFC1123FMT[] ALIGN1 = "%a, %d %b %Y %H:%M:%S GMT";
 	/* Fixed size 29-byte string. Example: Sun, 06 Nov 1994 08:49:37 GMT */
 	char date_str[40]; /* using a bit larger buffer to paranoia reasons */
 
+	struct tm tm;
 	const char *responseString = "";
 	const char *infoString = NULL;
 #if ENABLE_FEATURE_HTTPD_ERROR_PAGES
 	const char *error_page = NULL;
 #endif
+	unsigned len;
 	unsigned i;
 	time_t timer = time(NULL);
-	int len;
 
 	for (i = 0; i < ARRAY_SIZE(http_response_type); i++) {
 		if (http_response_type[i] == responseNum) {
@@ -1074,18 +1074,24 @@ static void send_headers(int responseNum
 	 * always fit into those kbytes.
 	 */
 
-	strftime(date_str, sizeof(date_str), RFC1123FMT, gmtime(&timer));
+	strftime(date_str, sizeof(date_str), RFC1123FMT, gmtime_r(&timer, &tm));
+	/* ^^^ using gmtime_r() instead of gmtime() to not use static data */
 	len = sprintf(iobuf,
-			"HTTP/1.0 %d %s\r\n"
-			"Content-type: %s\r\n"
+			"HTTP/1.0 %u %s\r\n"
 			"Date: %s\r\n"
 			"Connection: close\r\n",
 			responseNum, responseString,
-			/* if it's error message, then it's HTML */
-			(responseNum == HTTP_OK ? found_mime_type : "text/html"),
 			date_str
 	);
 
+	if (responseNum != HTTP_OK || found_mime_type) {
+		len += sprintf(iobuf + len,
+				"Content-type: %s\r\n",
+				/* if it's error message, then it's HTML */
+				(responseNum != HTTP_OK ? "text/html" : found_mime_type)
+		);
+	}
+
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	if (responseNum == HTTP_UNAUTHORIZED) {
 		len += sprintf(iobuf + len,
@@ -1128,7 +1134,7 @@ static void send_headers(int responseNum
 #endif
 
 	if (file_size != -1) {    /* file */
-		strftime(date_str, sizeof(date_str), RFC1123FMT, gmtime(&last_mod));
+		strftime(date_str, sizeof(date_str), RFC1123FMT, gmtime_r(&last_mod, &tm));
 #if ENABLE_FEATURE_HTTPD_RANGES
 		if (responseNum == HTTP_PARTIAL_CONTENT) {
 			len += sprintf(iobuf + len,
@@ -1145,9 +1151,9 @@ static void send_headers(int responseNum
 			"Accept-Ranges: bytes\r\n"
 #endif
 			"Last-Modified: %s\r\n"
-			"%s %"OFF_FMT"u\r\n",
+			"%s-Length: %"OFF_FMT"u\r\n",
 				date_str,
-				content_gzip ? "Transfer-Length:" : "Content-Length:",
+				content_gzip ? "Transfer" : "Content",
 				file_size
 		);
 	}
@@ -1159,8 +1165,8 @@ static void send_headers(int responseNum
 	iobuf[len++] = '\n';
 	if (infoString) {
 		len += sprintf(iobuf + len,
-				"<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\n"
-				"<BODY><H1>%d %s</H1>\n"
+				"<HTML><HEAD><TITLE>%u %s</TITLE></HEAD>\n"
+				"<BODY><H1>%u %s</H1>\n"
 				"%s\n"
 				"</BODY></HTML>\n",
 				responseNum, responseString,
@@ -1298,9 +1304,9 @@ static NOINLINE void cgi_io_loop_and_exi
 				continue;
 			}
 			if (DEBUG && WIFEXITED(status))
-				bb_error_msg("CGI exited, status=%d", WEXITSTATUS(status));
+				bb_error_msg("CGI exited, status=%u", WEXITSTATUS(status));
 			if (DEBUG && WIFSIGNALED(status))
-				bb_error_msg("CGI killed, signal=%d", WTERMSIG(status));
+				bb_error_msg("CGI killed, signal=%u", WTERMSIG(status));
 #endif
 			break;
 		}
@@ -1531,7 +1537,7 @@ static void send_cgi_and_exit(
 	if (G.http_accept_language)
 		setenv1("HTTP_ACCEPT_LANGUAGE", G.http_accept_language);
 	if (post_len)
-		putenv(xasprintf("CONTENT_LENGTH=%d", post_len));
+		putenv(xasprintf("CONTENT_LENGTH=%u", post_len));
 	if (cookie)
 		setenv1("HTTP_COOKIE", cookie);
 	if (content_type)
@@ -1682,8 +1688,8 @@ static NOINLINE void send_file_and_exit(
 	 * (happens if you abort downloads from local httpd): */
 	signal(SIGPIPE, SIG_IGN);
 
-	/* If not found, default is "application/octet-stream" */
-	found_mime_type = "application/octet-stream";
+	/* If not found, default is to not send "Content-type:" */
+	/*found_mime_type = NULL; - already is */
 	suffix = strrchr(url, '.');
 	if (suffix) {
 		static const char suffixTable[] ALIGN1 =
@@ -2541,11 +2547,9 @@ static void mini_httpd_nommu(int server_
 	 */
 	while (1) {
 		int n;
-		len_and_sockaddr fromAddr;
 
 		/* Wait for connections... */
-		fromAddr.len = LSA_SIZEOF_SA;
-		n = accept(server_socket, &fromAddr.u.sa, &fromAddr.len);
+		n = accept(server_socket, NULL, NULL);
 		if (n < 0)
 			continue;
 
@@ -2732,7 +2736,7 @@ int httpd_main(int argc UNUSED_PARAM, ch
 
 	xfunc_error_retval = 0;
 	if (opt & OPT_INETD)
-		mini_httpd_inetd();
+		mini_httpd_inetd(); /* never returns */
 #if BB_MMU
 	if (!(opt & OPT_FOREGROUND))
 		bb_daemonize(0); /* don't change current directory */
diff -urpN busybox-1.28.4/networking/ifconfig.c busybox-1.29.0/networking/ifconfig.c
--- busybox-1.28.4/networking/ifconfig.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ifconfig.c	2018-07-02 15:55:14.000000000 +0200
@@ -338,6 +338,7 @@ int ifconfig_main(int argc UNUSED_PARAM,
 	char *p;
 	/*char host[128];*/
 	const char *host = NULL; /* make gcc happy */
+	IF_FEATURE_IFCONFIG_STATUS(char *show_all_param;)
 
 	did_flags = 0;
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
@@ -349,15 +350,16 @@ int ifconfig_main(int argc UNUSED_PARAM,
 	++argv;
 
 #if ENABLE_FEATURE_IFCONFIG_STATUS
-	if (argv[0] && (argv[0][0] == '-' && argv[0][1] == 'a' && !argv[0][2])) {
-		interface_opt_a = 1;
+	show_all_param = NULL;
+	if (argv[0] && argv[0][0] == '-' && argv[0][1] == 'a' && !argv[0][2]) {
 		++argv;
+		show_all_param = IFNAME_SHOW_DOWNED_TOO;
 	}
 #endif
 
 	if (!argv[0] || !argv[1]) { /* one or no args */
 #if ENABLE_FEATURE_IFCONFIG_STATUS
-		return display_interfaces(argv[0] /* can be NULL */);
+		return display_interfaces(argv[0] ? argv[0] : show_all_param);
 #else
 		bb_error_msg_and_die("no support for status display");
 #endif
diff -urpN busybox-1.28.4/networking/ifplugd.c busybox-1.29.0/networking/ifplugd.c
--- busybox-1.28.4/networking/ifplugd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ifplugd.c	2018-07-02 15:55:14.000000000 +0200
@@ -367,7 +367,7 @@ static void up_iface(void)
 		/* Let user know we mess up with interface */
 		bb_error_msg("upping interface");
 		if (network_ioctl(SIOCSIFFLAGS, &ifrequest, "setting interface flags") < 0) {
-			if (errno != ENODEV)
+			if (errno != ENODEV && errno != EADDRNOTAVAIL)
 				xfunc_die();
 			G.iface_exists = 0;
 			return;
@@ -686,6 +686,8 @@ int ifplugd_main(int argc UNUSED_PARAM,
 			goto exiting;
 		default:
 			bb_got_signal = 0;
+		/* do not clear bb_got_signal if already 0, this can lose signals */
+		case 0:
 			break;
 		}
 
diff -urpN busybox-1.28.4/networking/ifupdown.c busybox-1.29.0/networking/ifupdown.c
--- busybox-1.28.4/networking/ifupdown.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ifupdown.c	2018-07-02 15:55:14.000000000 +0200
@@ -138,6 +138,7 @@
 //usage:     "\n	-v	Print out what would happen before doing it"
 //usage:     "\n	-f	Force deconfiguration"
 
+#include <net/if.h>
 #include "libbb.h"
 #include "common_bufsiz.h"
 /* After libbb.h, since it needs sys/types.h on some systems */
@@ -503,6 +504,8 @@ static int FAST_FUNC static_up6(struct i
 
 static int FAST_FUNC static_down6(struct interface_defn_t *ifd, execfn *exec)
 {
+	if (!if_nametoindex(ifd->iface))
+		return 1; /* already gone */
 # if ENABLE_FEATURE_IFUPDOWN_IP
 	return execute("ip link set %iface% down", ifd, exec);
 # else
@@ -598,6 +601,9 @@ static int FAST_FUNC static_up(struct in
 static int FAST_FUNC static_down(struct interface_defn_t *ifd, execfn *exec)
 {
 	int result;
+
+	if (!if_nametoindex(ifd->iface))
+		return 2; /* already gone */
 # if ENABLE_FEATURE_IFUPDOWN_IP
 	/* Optional "label LBL" is necessary if interface is an alias (eth0:0),
 	 * otherwise "ip addr flush dev eth0:0" flushes all addresses on eth0.
diff -urpN busybox-1.28.4/networking/inetd.c busybox-1.29.0/networking/inetd.c
--- busybox-1.28.4/networking/inetd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/inetd.c	2018-07-02 15:55:14.000000000 +0200
@@ -246,7 +246,11 @@
 #if ENABLE_FEATURE_INETD_RPC
 # if defined(__UCLIBC__) && ! defined(__UCLIBC_HAS_RPC__)
 #  warning "You probably need to build uClibc with UCLIBC_HAS_RPC for NFS support"
-   /* not #error, since user may be using e.g. libtirpc instead */
+   /* not #error, since user may be using e.g. libtirpc instead.
+    * This might work:
+    * CONFIG_EXTRA_CFLAGS="-I/usr/include/tirpc"
+    * CONFIG_EXTRA_LDLIBS="tirpc"
+    */
 # endif
 # include <rpc/rpc.h>
 # include <rpc/pmap_clnt.h>
@@ -497,10 +501,9 @@ static void register_rpc(servtab_t *sep)
 {
 	int n;
 	struct sockaddr_in ir_sin;
-	socklen_t size;
 
-	size = sizeof(ir_sin);
-	if (getsockname(sep->se_fd, (struct sockaddr *) &ir_sin, &size) < 0) {
+	if (bb_getsockname(sep->se_fd, (struct sockaddr *) &ir_sin, sizeof(ir_sin)) < 0) {
+//TODO: verify that such failure is even possible in Linux kernel
 		bb_perror_msg("getsockname");
 		return;
 	}
diff -urpN busybox-1.28.4/networking/interface.c busybox-1.29.0/networking/interface.c
--- busybox-1.28.4/networking/interface.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/interface.c	2018-07-02 15:55:14.000000000 +0200
@@ -318,31 +318,37 @@ struct interface {
 	char name[IFNAMSIZ];                    /* interface name        */
 	short type;                             /* if type               */
 	short flags;                            /* various flags         */
+	int tx_queue_len;                       /* transmit queue length */
+
+	/* these should be contiguous, zeroed in one go in if_fetch(): */
+#define FIRST_TO_ZERO metric
 	int metric;                             /* routing metric        */
 	int mtu;                                /* MTU value             */
-	int tx_queue_len;                       /* transmit queue length */
 	struct ifmap map;                       /* hardware setup        */
 	struct sockaddr addr;                   /* IP address            */
 	struct sockaddr dstaddr;                /* P-P IP address        */
 	struct sockaddr broadaddr;              /* IP broadcast address  */
 	struct sockaddr netmask;                /* IP network mask       */
-	int has_ip;
 	char hwaddr[32];                        /* HW address            */
-	int statistics_valid;
+#define LAST_TO_ZERO hwaddr
+
+	smallint has_ip;
+	smallint statistics_valid;
 	struct user_net_device_stats stats;     /* statistics            */
+#if 0 /* UNUSED */
 	int keepalive;                          /* keepalive value for SLIP */
 	int outfill;                            /* outfill value for SLIP */
+#endif
 };
 
-
-smallint interface_opt_a;	/* show all interfaces */
-
-static struct interface *int_list, *int_last;
+struct iface_list {
+	struct interface *int_list, *int_last;
+};
 
 
 #if 0
 /* like strcmp(), but knows about numbers */
-except that the freshly added calls to xatoul() brf on ethernet aliases with
+except that the freshly added calls to xatoul() barf on ethernet aliases with
 uClibc with e.g.: ife->name='lo'  name='eth0:1'
 static int nstrcmp(const char *a, const char *b)
 {
@@ -368,11 +374,11 @@ static int nstrcmp(const char *a, const
 }
 #endif
 
-static struct interface *add_interface(char *name)
+static struct interface *add_interface(struct iface_list *ilist, char *name)
 {
 	struct interface *ife, **nextp, *new;
 
-	for (ife = int_last; ife; ife = ife->prev) {
+	for (ife = ilist->int_last; ife; ife = ife->prev) {
 		int n = /*n*/strcmp(ife->name, name);
 
 		if (n == 0)
@@ -383,43 +389,43 @@ static struct interface *add_interface(c
 
 	new = xzalloc(sizeof(*new));
 	strncpy_IFNAMSIZ(new->name, name);
-	nextp = ife ? &ife->next : &int_list;
+
+	nextp = ife ? &ife->next : &ilist->int_list;
 	new->prev = ife;
 	new->next = *nextp;
 	if (new->next)
 		new->next->prev = new;
 	else
-		int_last = new;
+		ilist->int_last = new;
 	*nextp = new;
 	return new;
 }
 
-static char *get_name(char *name, char *p)
+static char *get_name(char name[IFNAMSIZ], char *p)
 {
-	/* Extract <name> from nul-terminated p where p matches
-	 * <name>: after leading whitespace.
-	 * If match is not made, set name empty and return unchanged p
+	/* Extract NAME from nul-terminated p of the form "<whitespace>NAME:"
+	 * If match is not made, set NAME to "" and return unchanged p.
 	 */
 	char *nameend;
-	char *namestart = skip_whitespace(p);
+	char *namestart;
 
-	nameend = namestart;
-	while (*nameend && *nameend != ':' && !isspace(*nameend))
-		nameend++;
-	if (*nameend == ':') {
-		if ((nameend - namestart) < IFNAMSIZ) {
+	nameend = namestart = skip_whitespace(p);
+
+	for (;;) {
+		if ((nameend - namestart) >= IFNAMSIZ)
+			break; /* interface name too large - return "" */
+		if (*nameend == ':') {
 			memcpy(name, namestart, nameend - namestart);
 			name[nameend - namestart] = '\0';
-			p = nameend;
-		} else {
-			/* Interface name too large */
-			name[0] = '\0';
+			return nameend + 1;
 		}
-	} else {
-		/* trailing ':' not found - return empty */
-		name[0] = '\0';
+		nameend++;
+		/* isspace, NUL, any control char? */
+		if ((unsigned char)*nameend <= (unsigned char)' ')
+			break; /* trailing ':' not found - return "" */
 	}
-	return p + 1;
+	name[0] = '\0';
+	return p;
 }
 
 /* If scanf supports size qualifiers for %n conversions, then we can
@@ -435,7 +441,10 @@ static char *get_name(char *name, char *
 /*	"%llu%llu%lu%lu%lu%lu%lu%lu%llu%llu%lu%lu%lu%lu%lu%lu" */
 /* }; */
 
-	/* Lie about the size of the int pointed to for %n. */
+/* We use %n for unavailable data in older versions of /proc/net/dev formats.
+ * This results in bogus stores to ife->FOO members corresponding to
+ * %n specifiers (even the size of integers may not match).
+ */
 #if INT_MAX == LONG_MAX
 static const char *const ss_fmt[] = {
 	"%n%llu%u%u%u%u%n%n%n%llu%u%u%u%u%u",
@@ -448,7 +457,6 @@ static const char *const ss_fmt[] = {
 	"%llu%llu%lu%lu%lu%lu%n%n%llu%llu%lu%lu%lu%lu%lu",
 	"%llu%llu%lu%lu%lu%lu%lu%lu%llu%llu%lu%lu%lu%lu%lu%lu"
 };
-
 #endif
 
 static void get_dev_fields(char *bp, struct interface *ife, int procnetdev_vsn)
@@ -456,22 +464,22 @@ static void get_dev_fields(char *bp, str
 	memset(&ife->stats, 0, sizeof(struct user_net_device_stats));
 
 	sscanf(bp, ss_fmt[procnetdev_vsn],
-		   &ife->stats.rx_bytes, /* missing for 0 */
+		   &ife->stats.rx_bytes, /* missing for v0 */
 		   &ife->stats.rx_packets,
 		   &ife->stats.rx_errors,
 		   &ife->stats.rx_dropped,
 		   &ife->stats.rx_fifo_errors,
 		   &ife->stats.rx_frame_errors,
-		   &ife->stats.rx_compressed, /* missing for <= 1 */
-		   &ife->stats.rx_multicast, /* missing for <= 1 */
-		   &ife->stats.tx_bytes, /* missing for 0 */
+		   &ife->stats.rx_compressed, /* missing for v0, v1 */
+		   &ife->stats.rx_multicast, /* missing for v0, v1 */
+		   &ife->stats.tx_bytes, /* missing for v0 */
 		   &ife->stats.tx_packets,
 		   &ife->stats.tx_errors,
 		   &ife->stats.tx_dropped,
 		   &ife->stats.tx_fifo_errors,
 		   &ife->stats.collisions,
 		   &ife->stats.tx_carrier_errors,
-		   &ife->stats.tx_compressed /* missing for <= 1 */
+		   &ife->stats.tx_compressed /* missing for v0, v1 */
 		   );
 
 	if (procnetdev_vsn <= 1) {
@@ -494,31 +502,25 @@ static int procnetdev_version(char *buf)
 	return 0;
 }
 
-static int if_readconf(void)
+static void if_readconf(struct iface_list *ilist)
 {
 	int numreqs = 30;
 	struct ifconf ifc;
 	struct ifreq *ifr;
-	int n, err = -1;
+	int n;
 	int skfd;
 
 	ifc.ifc_buf = NULL;
 
 	/* SIOCGIFCONF currently seems to only work properly on AF_INET sockets
 	   (as of 2.1.128) */
-	skfd = socket(AF_INET, SOCK_DGRAM, 0);
-	if (skfd < 0) {
-		bb_perror_msg("error: no inet socket available");
-		return -1;
-	}
+	skfd = xsocket(AF_INET, SOCK_DGRAM, 0);
 
 	for (;;) {
 		ifc.ifc_len = sizeof(struct ifreq) * numreqs;
 		ifc.ifc_buf = xrealloc(ifc.ifc_buf, ifc.ifc_len);
 
-		if (ioctl_or_warn(skfd, SIOCGIFCONF, &ifc) < 0) {
-			goto out;
-		}
+		xioctl(skfd, SIOCGIFCONF, &ifc);
 		if (ifc.ifc_len == (int)(sizeof(struct ifreq) * numreqs)) {
 			/* assume it overflowed and try again */
 			numreqs += 10;
@@ -529,67 +531,54 @@ static int if_readconf(void)
 
 	ifr = ifc.ifc_req;
 	for (n = 0; n < ifc.ifc_len; n += sizeof(struct ifreq)) {
-		add_interface(ifr->ifr_name);
+		add_interface(ilist, ifr->ifr_name);
 		ifr++;
 	}
-	err = 0;
 
- out:
 	close(skfd);
 	free(ifc.ifc_buf);
-	return err;
 }
 
-static int if_readlist_proc(char *target)
+static int if_readlist_proc(struct iface_list *ilist, char *ifname)
 {
-	static smallint proc_read;
-
 	FILE *fh;
 	char buf[512];
 	struct interface *ife;
-	int err, procnetdev_vsn;
-
-	if (proc_read)
-		return 0;
-	if (!target)
-		proc_read = 1;
+	int procnetdev_vsn;
+	int ret;
 
 	fh = fopen_or_warn(_PATH_PROCNET_DEV, "r");
 	if (!fh) {
-		return if_readconf();
+		return 0; /* "not found" */
 	}
 	fgets(buf, sizeof buf, fh);	/* eat line */
 	fgets(buf, sizeof buf, fh);
 
 	procnetdev_vsn = procnetdev_version(buf);
 
-	err = 0;
+	ret = 0;
 	while (fgets(buf, sizeof buf, fh)) {
-		char *s, name[128];
+		char *s, name[IFNAMSIZ];
 
 		s = get_name(name, buf);
-		ife = add_interface(name);
+		ife = add_interface(ilist, name);
 		get_dev_fields(s, ife, procnetdev_vsn);
 		ife->statistics_valid = 1;
-		if (target && strcmp(target, name) == 0)
+		if (ifname && strcmp(ifname, name) == 0) {
+			ret = 1; /* found */
 			break;
-	}
-	if (ferror(fh)) {
-		bb_perror_msg(_PATH_PROCNET_DEV);
-		err = -1;
-		proc_read = 0;
+		}
 	}
 	fclose(fh);
-	return err;
+	return ret;
 }
 
-static int if_readlist(void)
+static void if_readlist(struct iface_list *ilist, char *ifname)
 {
-	int err = if_readlist_proc(NULL);
+	int found = if_readlist_proc(ilist, ifname);
 	/* Needed in order to get ethN:M aliases */
-	if (!err)
-		err = if_readconf();
-	return err;
+	if (!found)
+		if_readconf(ilist);
 }
 
 /* Fetch the interface configuration from the kernel. */
@@ -608,24 +597,29 @@ static int if_fetch(struct interface *if
 	}
 	ife->flags = ifr.ifr_flags;
 
+	/* set up default values if ioctl's would fail */
+	ife->tx_queue_len = -1;	/* unknown value */
+	memset(&ife->FIRST_TO_ZERO, 0,
+		offsetof(struct interface, LAST_TO_ZERO)
+			- offsetof(struct interface, FIRST_TO_ZERO)
+		+ sizeof(ife->LAST_TO_ZERO)
+	);
+
 	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-	memset(ife->hwaddr, 0, 32);
 	if (ioctl(skfd, SIOCGIFHWADDR, &ifr) >= 0)
 		memcpy(ife->hwaddr, ifr.ifr_hwaddr.sa_data, 8);
 
+//er.... why this _isnt_ inside if()?
 	ife->type = ifr.ifr_hwaddr.sa_family;
 
 	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-	ife->metric = 0;
 	if (ioctl(skfd, SIOCGIFMETRIC, &ifr) >= 0)
 		ife->metric = ifr.ifr_metric;
 
 	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-	ife->mtu = 0;
 	if (ioctl(skfd, SIOCGIFMTU, &ifr) >= 0)
 		ife->mtu = ifr.ifr_mtu;
 
-	memset(&ife->map, 0, sizeof(struct ifmap));
 #ifdef SIOCGIFMAP
 	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
 	if (ioctl(skfd, SIOCGIFMAP, &ifr) == 0)
@@ -634,31 +628,24 @@ static int if_fetch(struct interface *if
 
 #ifdef HAVE_TXQUEUELEN
 	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-	ife->tx_queue_len = -1;	/* unknown value */
 	if (ioctl(skfd, SIOCGIFTXQLEN, &ifr) >= 0)
 		ife->tx_queue_len = ifr.ifr_qlen;
-#else
-	ife->tx_queue_len = -1;	/* unknown value */
 #endif
 
 	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
 	ifr.ifr_addr.sa_family = AF_INET;
-	memset(&ife->addr, 0, sizeof(struct sockaddr));
 	if (ioctl(skfd, SIOCGIFADDR, &ifr) == 0) {
 		ife->has_ip = 1;
 		ife->addr = ifr.ifr_addr;
 		strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-		memset(&ife->dstaddr, 0, sizeof(struct sockaddr));
 		if (ioctl(skfd, SIOCGIFDSTADDR, &ifr) >= 0)
 			ife->dstaddr = ifr.ifr_dstaddr;
 
 		strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-		memset(&ife->broadaddr, 0, sizeof(struct sockaddr));
 		if (ioctl(skfd, SIOCGIFBRDADDR, &ifr) >= 0)
 			ife->broadaddr = ifr.ifr_broadaddr;
 
 		strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
-		memset(&ife->netmask, 0, sizeof(struct sockaddr));
 		if (ioctl(skfd, SIOCGIFNETMASK, &ifr) >= 0)
 			ife->netmask = ifr.ifr_netmask;
 	}
@@ -1020,10 +1007,12 @@ static void ife_print(struct interface *
 
 	/* DONT FORGET TO ADD THE FLAGS IN ife_print_short */
 	printf(" MTU:%d  Metric:%d", ptr->mtu, ptr->metric ? ptr->metric : 1);
+#if 0
 #ifdef SIOCSKEEPALIVE
 	if (ptr->outfill || ptr->keepalive)
 		printf("  Outfill:%d  Keepalive:%d", ptr->outfill, ptr->keepalive);
 #endif
+#endif
 	bb_putchar('\n');
 
 	/* If needed, display the interface statistics. */
@@ -1077,67 +1066,44 @@ static void ife_print(struct interface *
 	bb_putchar('\n');
 }
 
-static int do_if_print(struct interface *ife) /*, int *opt_a)*/
+static int do_if_print(struct interface *ife, int show_downed_too)
 {
 	int res;
 
 	res = do_if_fetch(ife);
 	if (res >= 0) {
-		if ((ife->flags & IFF_UP) || interface_opt_a)
+		if ((ife->flags & IFF_UP) || show_downed_too)
 			ife_print(ife);
 	}
 	return res;
 }
 
-static struct interface *lookup_interface(char *name)
-{
-	struct interface *ife = NULL;
-
-	if (if_readlist_proc(name) < 0)
-		return NULL;
-	ife = add_interface(name);
-	return ife;
-}
-
-#ifdef UNUSED
-static int for_all_interfaces(int (*doit) (struct interface *, void *),
-							void *cookie)
+int FAST_FUNC display_interfaces(char *ifname)
 {
 	struct interface *ife;
+	int res;
+	struct iface_list ilist;
 
-	if (!int_list && (if_readlist() < 0))
-		return -1;
-	for (ife = int_list; ife; ife = ife->next) {
-		int err = doit(ife, cookie);
-		if (err)
-			return err;
-	}
-	return 0;
-}
-#endif
+	ilist.int_list = NULL;
+	ilist.int_last = NULL;
+	if_readlist(&ilist, ifname != IFNAME_SHOW_DOWNED_TOO ? ifname : NULL);
 
-/* for ipv4 add/del modes */
-static int if_print(char *ifname)
-{
-	struct interface *ife;
-	int res;
+	if (!ifname || ifname == IFNAME_SHOW_DOWNED_TOO) {
+		for (ife = ilist.int_list; ife; ife = ife->next) {
 
-	if (!ifname) {
-		/*res = for_all_interfaces(do_if_print, &interface_opt_a);*/
-		if (!int_list && (if_readlist() < 0))
-			return -1;
-		for (ife = int_list; ife; ife = ife->next) {
-			int err = do_if_print(ife); /*, &interface_opt_a);*/
-			if (err)
-				return err;
+			BUILD_BUG_ON((int)(intptr_t)IFNAME_SHOW_DOWNED_TOO != 1);
+
+			res = do_if_print(ife, (int)(intptr_t)ifname);
+			if (res < 0)
+				goto ret;
 		}
 		return 0;
 	}
-	ife = lookup_interface(ifname);
-	res = do_if_fetch(ife);
-	if (res >= 0)
-		ife_print(ife);
-	return res;
+
+	ife = add_interface(&ilist, ifname);
+	res = do_if_print(ife, /*show_downed_too:*/ 1);
+ ret:
+	return (res < 0); /* status < 0 == 1 -- error */
 }
 
 #if ENABLE_FEATURE_HWIB
@@ -1153,12 +1119,3 @@ int FAST_FUNC in_ib(const char *bufp, st
 	return 0;
 }
 #endif
-
-int FAST_FUNC display_interfaces(char *ifname)
-{
-	int status;
-
-	status = if_print(ifname);
-
-	return (status < 0); /* status < 0 == 1 -- error */
-}
diff -urpN busybox-1.28.4/networking/ip.c busybox-1.29.0/networking/ip.c
--- busybox-1.28.4/networking/ip.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ip.c	2018-07-02 15:55:14.000000000 +0200
@@ -155,11 +155,61 @@
 //usage:
 //--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iplink_trivial_usage
-//usage:       "set IFACE [up|down] [arp on|off] | show [IFACE]"
-//usage:#define iplink_full_usage "\n\n"
-//usage:       "iplink set IFACE [up|down] [arp on|off] [multicast on|off] [promisc on|off]\n"
-//usage:       "	[mtu NUM] [name NAME] [qlen NUM] [address MAC]\n"
+//usage:       /*Usage:iplink*/"set IFACE [up|down] [arp on|off] [multicast on|off]\n"
+//usage:       "	[promisc on|off] [mtu NUM] [name NAME] [qlen NUM] [address MAC]\n"
+//usage:       "	[master IFACE | nomaster]"
+// * short help shows only "set" command, long help continues (with just one "\n")
+// * and shows all other commands:
+//usage:#define iplink_full_usage "\n"
+//usage:       "iplink add [link IFACE] IFACE [address MAC] type TYPE [ARGS]\n"
+//usage:       "iplink delete IFACE type TYPE [ARGS]\n"
+//usage:       "	TYPE ARGS := vlan VLANARGS | vrf table NUM\n"
+//usage:       "	VLANARGS := id VLANID [protocol 802.1q|802.1ad] [reorder_hdr on|off]\n"
+//usage:       "		[gvrp on|off] [mvrp on|off] [loose_binding on|off]\n"
 //usage:       "iplink show [IFACE]"
+//upstream man ip-link:
+//=====================
+//ip link add [link DEV] [ name ] NAME
+//                   [ txqueuelen PACKETS ]
+//                   [ address LLADDR ]
+//                   [ broadcast LLADDR ]
+//                   [ mtu MTU ] [index IDX ]
+//                   [ numtxqueues QUEUE_COUNT ]
+//                   [ numrxqueues QUEUE_COUNT ]
+//                   type TYPE [ ARGS ]
+//       ip link delete { DEVICE | dev DEVICE | group DEVGROUP } type TYPE [ ARGS ]
+//       ip link set { DEVICE | dev DEVICE | group DEVGROUP } [ { up | down } ]
+//                      [ arp { on | off } ]
+//                      [ dynamic { on | off } ]
+//                      [ multicast { on | off } ]
+//                      [ allmulticast { on | off } ]
+//                      [ promisc { on | off } ]
+//                      [ trailers { on | off } ]
+//                      [ txqueuelen PACKETS ]
+//                      [ name NEWNAME ]
+//                      [ address LLADDR ]
+//                      [ broadcast LLADDR ]
+//                      [ mtu MTU ]
+//                      [ netns { PID | NAME } ]
+//                      [ link-netnsid ID ]
+//	      [ alias NAME ]
+//                      [ vf NUM [ mac LLADDR ]
+//		   [ vlan VLANID [ qos VLAN-QOS ] ]
+//		   [ rate TXRATE ]
+//		   [ spoofchk { on | off} ]
+//		   [ query_rss { on | off} ]
+//		   [ state { auto | enable | disable} ] ]
+//		   [ trust { on | off} ] ]
+//	      [ master DEVICE ]
+//	      [ nomaster ]
+//	      [ addrgenmode { eui64 | none | stable_secret | random } ]
+//                      [ protodown { on | off } ]
+//       ip link show [ DEVICE | group GROUP ] [up] [master DEV] [type TYPE]
+//       ip link help [ TYPE ]
+//TYPE := { vlan | veth | vcan | dummy | ifb | macvlan | macvtap |
+//          bridge | bond | ipoib | ip6tnl | ipip | sit | vxlan |
+//          gre | gretap | ip6gre | ip6gretap | vti | nlmon |
+//          bond_slave | ipvlan | geneve | bridge_slave | vrf }
 //usage:
 //--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iproute_trivial_usage
diff -urpN busybox-1.28.4/networking/isrv_identd.c busybox-1.29.0/networking/isrv_identd.c
--- busybox-1.28.4/networking/isrv_identd.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/isrv_identd.c	2018-07-02 15:55:14.000000000 +0200
@@ -159,7 +159,7 @@ int fakeidentd_main(int argc UNUSED_PARA
 	fd = 0;
 	if (!(opt & OPT_inetdwait)) {
 		fd = create_and_bind_stream_or_die(bind_address,
-				bb_lookup_port("identd", "tcp", 113));
+				bb_lookup_std_port("identd", "tcp", 113));
 		xlisten(fd, 5);
 	}
 
diff -urpN busybox-1.28.4/networking/libiproute/Kbuild.src busybox-1.29.0/networking/libiproute/Kbuild.src
--- busybox-1.28.4/networking/libiproute/Kbuild.src	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/libiproute/Kbuild.src	2018-07-02 15:55:14.000000000 +0200
@@ -12,6 +12,12 @@ INSERT
 lib-$(CONFIG_SLATTACH) += \
 	utils.o
 
+lib-$(CONFIG_TC) += \
+	libnetlink.o \
+	ll_map.o \
+	ll_proto.o \
+	utils.o
+
 lib-$(CONFIG_IP) += \
 	ip_parse_common_args.o \
 	libnetlink.o \
diff -urpN busybox-1.28.4/networking/libiproute/ipaddress.c busybox-1.29.0/networking/libiproute/ipaddress.c
--- busybox-1.28.4/networking/libiproute/ipaddress.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/libiproute/ipaddress.c	2018-07-02 15:55:14.000000000 +0200
@@ -570,7 +570,10 @@ int FAST_FUNC ipaddr_list_or_flush(char
 	}
 
 	for (l = linfo; l; l = l->next) {
-		if (no_link || print_linkinfo(&l->h) == 0) {
+		if (no_link
+		 || (oneline || print_linkinfo(&l->h) == 0)
+		/* ^^^^^^^^^ "ip -oneline a" does not print link info */
+		) {
 			struct ifinfomsg *ifi = NLMSG_DATA(&l->h);
 			if (G_filter.family != AF_PACKET)
 				print_selected_addrinfo(ifi->ifi_index, ainfo);
diff -urpN busybox-1.28.4/networking/libiproute/iplink.c busybox-1.29.0/networking/libiproute/iplink.c
--- busybox-1.28.4/networking/libiproute/iplink.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/libiproute/iplink.c	2018-07-02 15:55:14.000000000 +0200
@@ -128,16 +128,40 @@ static void set_mtu(char *dev, int mtu)
 }
 
 /* Exits on error */
+static void set_master(char *dev, int master)
+{
+	struct rtnl_handle rth;
+	struct {
+		struct nlmsghdr  n;
+		struct ifinfomsg i;
+		char             buf[1024];
+	} req;
+
+	memset(&req, 0, sizeof(req));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
+	req.n.nlmsg_flags = NLM_F_REQUEST;
+	req.n.nlmsg_type = RTM_NEWLINK;
+	req.i.ifi_family = preferred_family;
+
+	xrtnl_open(&rth);
+	req.i.ifi_index = xll_name_to_index(dev);
+	//printf("master %i for %i\n", master, req.i.ifi_index);
+	addattr_l(&req.n, sizeof(req), IFLA_MASTER, &master, 4);
+	if (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL) < 0)
+		xfunc_die();
+}
+
+/* Exits on error */
 static int get_address(char *dev, int *htype)
 {
 	struct ifreq ifr;
 	struct sockaddr_ll me;
-	socklen_t alen;
 	int s;
 
 	s = xsocket(PF_PACKET, SOCK_DGRAM, 0);
 
-	memset(&ifr, 0, sizeof(ifr));
+	/*memset(&ifr, 0, sizeof(ifr)); - SIOCGIFINDEX does not need to clear all */
 	strncpy_IFNAMSIZ(ifr.ifr_name, dev);
 	xioctl(s, SIOCGIFINDEX, &ifr);
 
@@ -146,8 +170,7 @@ static int get_address(char *dev, int *h
 	me.sll_ifindex = ifr.ifr_ifindex;
 	me.sll_protocol = htons(ETH_P_LOOP);
 	xbind(s, (struct sockaddr*)&me, sizeof(me));
-	alen = sizeof(me);
-	getsockname(s, (struct sockaddr*)&me, &alen);
+	bb_getsockname(s, (struct sockaddr*)&me, sizeof(me));
 	//never happens:
 	//if (getsockname(s, (struct sockaddr*)&me, &alen) == -1)
 	//	bb_perror_msg_and_die("getsockname");
@@ -202,6 +225,7 @@ static int do_set(char **argv)
 	uint32_t flags = 0;
 	int qlen = -1;
 	int mtu = -1;
+	int master = -1;
 	char *newaddr = NULL;
 	char *newbrd = NULL;
 	struct ifreq ifr0, ifr1;
@@ -211,9 +235,11 @@ static int do_set(char **argv)
 	static const char keywords[] ALIGN1 =
 		"up\0""down\0""name\0""mtu\0""qlen\0""multicast\0"
 		"arp\0""promisc\0""address\0"
+		"master\0""nomaster\0"
 		"dev\0" /* must be last */;
 	enum { ARG_up = 0, ARG_down, ARG_name, ARG_mtu, ARG_qlen, ARG_multicast,
 		ARG_arp, ARG_promisc, ARG_addr,
+		ARG_master, ARG_nomaster,
 		ARG_dev };
 	enum { PARM_on = 0, PARM_off };
 	smalluint key;
@@ -245,6 +271,11 @@ static int do_set(char **argv)
 		} else if (key == ARG_addr) {
 			NEXT_ARG();
 			newaddr = *argv;
+		} else if (key == ARG_master) {
+			NEXT_ARG();
+			master = xll_name_to_index(*argv);
+		} else if (key == ARG_nomaster) {
+			master = 0;
 		} else if (key >= ARG_dev) {
 			/* ^^^^^^ ">=" here results in "dev IFACE" treated as default */
 			if (key == ARG_dev) {
@@ -429,6 +460,9 @@ static int do_set(char **argv)
 	if (mtu != -1) {
 		set_mtu(dev, mtu);
 	}
+	if (master != -1) {
+		set_master(dev, master);
+	}
 	if (mask)
 		do_chflags(dev, flags, mask);
 	return 0;
@@ -527,6 +561,24 @@ static void vlan_parse_opt(char **argv,
 		addattr_l(n, size, IFLA_VLAN_FLAGS, &flags, sizeof(flags));
 }
 
+static void vrf_parse_opt(char **argv, struct nlmsghdr *n, unsigned int size)
+{
+/* IFLA_VRF_TABLE is an enum, not a define -
+ * can't test "defined(IFLA_VRF_TABLE)".
+ */
+#if !defined(IFLA_VRF_MAX)
+# define IFLA_VRF_TABLE 1
+#endif
+	uint32_t table;
+
+	if (strcmp(*argv, "table") != 0)
+		invarg_1_to_2(*argv, "type vrf");
+
+	NEXT_ARG();
+	table = get_u32(*argv, "table");
+	addattr_l(n, size, IFLA_VRF_TABLE, &table, sizeof(table));
+}
+
 #ifndef NLMSG_TAIL
 #define NLMSG_TAIL(nmsg) \
 	((struct rtattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
@@ -565,6 +617,8 @@ static int do_add_or_delete(char **argv,
 	if (rtm == RTM_NEWLINK)
 		req.n.nlmsg_flags |= NLM_F_CREATE|NLM_F_EXCL;
 
+	/* NB: update iplink_full_usage if you extend this code */
+
 	while (*argv) {
 		arg = index_in_substrings(keywords, *argv);
 		if (arg == ARG_type) {
@@ -584,7 +638,7 @@ static int do_add_or_delete(char **argv,
 		} else if (arg == ARG_address) {
 			NEXT_ARG();
 			address_str = *argv;
-			dbg("address_str:'%s'", name_str);
+			dbg("address_str:'%s'", address_str);
 		} else {
 			if (arg == ARG_dev) {
 				if (dev_str)
@@ -611,6 +665,8 @@ static int do_add_or_delete(char **argv,
 
 			if (strcmp(type_str, "vlan") == 0)
 				vlan_parse_opt(argv, &req.n, sizeof(req));
+			else if (strcmp(type_str, "vrf") == 0)
+				vrf_parse_opt(argv, &req.n, sizeof(req));
 
 			data->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;
 		}
@@ -653,6 +709,8 @@ int FAST_FUNC do_iplink(char **argv)
 {
 	static const char keywords[] ALIGN1 =
 		"add\0""delete\0""set\0""show\0""lst\0""list\0";
+
+	xfunc_error_retval = 2; //TODO: move up to "ip"? Is it the common rule for all "ip" tools?
 	if (*argv) {
 		int key = index_in_substrings(keywords, *argv);
 		if (key < 0) /* invalid argument */
diff -urpN busybox-1.28.4/networking/libiproute/libnetlink.c busybox-1.29.0/networking/libiproute/libnetlink.c
--- busybox-1.28.4/networking/libiproute/libnetlink.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/libiproute/libnetlink.c	2018-07-02 15:55:14.000000000 +0200
@@ -15,16 +15,13 @@
 
 void FAST_FUNC xrtnl_open(struct rtnl_handle *rth/*, unsigned subscriptions*/)
 {
-	socklen_t addr_len;
-
 	memset(rth, 0, sizeof(*rth));
 	rth->fd = xsocket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
 	rth->local.nl_family = AF_NETLINK;
 	/*rth->local.nl_groups = subscriptions;*/
 
 	xbind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local));
-	addr_len = sizeof(rth->local);
-	getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len);
+	bb_getsockname(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local));
 
 /* too much paranoia
 	if (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0)
diff -urpN busybox-1.28.4/networking/nc_bloaty.c busybox-1.29.0/networking/nc_bloaty.c
--- busybox-1.28.4/networking/nc_bloaty.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/nc_bloaty.c	2018-07-02 15:55:14.000000000 +0200
@@ -791,7 +791,7 @@ int nc_main(int argc UNUSED_PARAM, char
 		"np:s:uvw:+"/* -w N */ IF_NC_SERVER("lk")
 		IF_NC_EXTRA("i:o:z")
 			"\0"
-			"?2:vv:ll", /* max 2 params; -v and -l are counters */
+			"?2:vv"IF_NC_SERVER(":ll"), /* max 2 params; -v and -l are counters */
 		&str_p, &str_s, &o_wait
 		IF_NC_EXTRA(, &str_i, &str_o)
 			, &o_verbose IF_NC_SERVER(, &cnt_l)
diff -urpN busybox-1.28.4/networking/netstat.c busybox-1.29.0/networking/netstat.c
--- busybox-1.28.4/networking/netstat.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/netstat.c	2018-07-02 15:55:14.000000000 +0200
@@ -397,8 +397,11 @@ static char *ip_port_str(struct sockaddr
 	/* Code which used "*" for INADDR_ANY is removed: it's ambiguous
 	 * in IPv6, while "0.0.0.0" is not. */
 
-	host = numeric ? xmalloc_sockaddr2dotted_noport(addr)
-	               : xmalloc_sockaddr2host_noport(addr);
+	host = NULL;
+	if (!numeric)
+		host = xmalloc_sockaddr2host_noport(addr);
+	if (!host)
+		host = xmalloc_sockaddr2dotted_noport(addr);
 
 	host_port = xasprintf("%s:%s", host, get_sname(htons(port), proto, numeric));
 	free(host);
diff -urpN busybox-1.28.4/networking/nslookup.c busybox-1.29.0/networking/nslookup.c
--- busybox-1.28.4/networking/nslookup.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/nslookup.c	2018-07-02 15:55:14.000000000 +0200
@@ -1,31 +1,31 @@
 /* vi: set sw=4 ts=4: */
-/*
- * Mini nslookup implementation for busybox
- *
- * Copyright (C) 1999,2000 by Lineo, inc. and John Beppu
- * Copyright (C) 1999,2000,2001 by John Beppu <beppu@codepoet.org>
- *
- * Correct default name server display and explicit name server option
- * added by Ben Zeckel <bzeckel@hmc.edu> June 2001
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
+
 //config:config NSLOOKUP
 //config:	bool "nslookup (4.5 kb)"
 //config:	default y
 //config:	help
 //config:	nslookup is a tool to query Internet name servers.
+//config:
+//config:config FEATURE_NSLOOKUP_BIG
+//config:	bool "Use internal resolver code instead of libc"
+//config:	depends on NSLOOKUP
+//config:	default y
+//config:
+//config:config FEATURE_NSLOOKUP_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on FEATURE_NSLOOKUP_BIG && LONG_OPTS
 
 //applet:IF_NSLOOKUP(APPLET(nslookup, BB_DIR_USR_BIN, BB_SUID_DROP))
 
 //kbuild:lib-$(CONFIG_NSLOOKUP) += nslookup.o
 
 //usage:#define nslookup_trivial_usage
-//usage:       "[HOST] [SERVER]"
+//usage:       IF_FEATURE_NSLOOKUP_BIG("[-type=QUERY_TYPE] [-debug] ") "HOST [DNS_SERVER]"
 //usage:#define nslookup_full_usage "\n\n"
-//usage:       "Query the nameserver for the IP address of the given HOST\n"
-//usage:       "optionally using a specified DNS server"
-//usage:
+//usage:       "Query DNS about HOST"
+//usage:       IF_FEATURE_NSLOOKUP_BIG("\n")
+//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,any")
 //usage:#define nslookup_example_usage
 //usage:       "$ nslookup localhost\n"
 //usage:       "Server:     default\n"
@@ -35,7 +35,26 @@
 //usage:       "Address:    127.0.0.1\n"
 
 #include <resolv.h>
+#include <net/if.h>	/* for IFNAMSIZ */
+//#include <arpa/inet.h>
+//#include <netdb.h>
 #include "libbb.h"
+#include "common_bufsiz.h"
+
+
+#if !ENABLE_FEATURE_NSLOOKUP_BIG
+
+/*
+ * Mini nslookup implementation for busybox
+ *
+ * Copyright (C) 1999,2000 by Lineo, inc. and John Beppu
+ * Copyright (C) 1999,2000,2001 by John Beppu <beppu@codepoet.org>
+ *
+ * Correct default name server display and explicit name server option
+ * added by Ben Zeckel <bzeckel@hmc.edu> June 2001
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
 
 /*
  * I'm only implementing non-interactive mode;
@@ -207,3 +226,709 @@ int nslookup_main(int argc, char **argv)
 
 	return print_host(argv[1], "Name:");
 }
+
+
+#else /****** A version from LEDE / OpenWRT ******/
+
+/*
+ * musl compatible nslookup
+ *
+ * Copyright (C) 2017 Jo-Philipp Wich <jo@mein.io>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#if 0
+# define dbg(...) fprintf(stderr, __VA_ARGS__)
+#else
+# define dbg(...) ((void)0)
+#endif
+
+struct ns {
+	const char *name;
+	len_and_sockaddr *lsa;
+	int failures;
+	int replies;
+};
+
+struct query {
+	const char *name;
+	unsigned qlen;
+//	unsigned latency;
+//	uint8_t rcode;
+	unsigned char query[512];
+//	unsigned char reply[512];
+};
+
+static const struct {
+	unsigned char type;
+	char name[7];
+} qtypes[] = {
+	{ ns_t_soa,   "SOA"   },
+	{ ns_t_ns,    "NS"    },
+	{ ns_t_a,     "A"     },
+#if ENABLE_FEATURE_IPV6
+	{ ns_t_aaaa,  "AAAA"  },
+#endif
+	{ ns_t_cname, "CNAME" },
+	{ ns_t_mx,    "MX"    },
+	{ ns_t_txt,   "TXT"   },
+	{ ns_t_ptr,   "PTR"   },
+	{ ns_t_any,   "ANY"   },
+};
+
+static const char *const rcodes[] = {
+	"NOERROR",    // 0
+	"FORMERR",    // 1
+	"SERVFAIL",   // 2
+	"NXDOMAIN",   // 3
+	"NOTIMP",     // 4
+	"REFUSED",    // 5
+	"YXDOMAIN",   // 6
+	"YXRRSET",    // 7
+	"NXRRSET",    // 8
+	"NOTAUTH",    // 9
+	"NOTZONE",    // 10
+	"11",         // 11 not assigned
+	"12",         // 12 not assigned
+	"13",         // 13 not assigned
+	"14",         // 14 not assigned
+	"15",         // 15 not assigned
+};
+
+#if ENABLE_FEATURE_IPV6
+static const char v4_mapped[12] = { 0,0,0,0, 0,0,0,0, 0,0,0xff,0xff };
+#endif
+
+struct globals {
+	unsigned default_port;
+	unsigned default_retry;
+	unsigned default_timeout;
+	unsigned query_count;
+	unsigned serv_count;
+	struct ns *server;
+	struct query *query;
+} FIX_ALIASING;
+#define G (*(struct globals*)bb_common_bufsiz1)
+#define INIT_G() do { \
+	setup_common_bufsiz(); \
+	G.default_port = 53; \
+	G.default_retry = 2; \
+	G.default_timeout = 5; \
+} while (0)
+
+enum {
+	OPT_debug = (1 << 0),
+};
+
+static int parse_reply(const unsigned char *msg, size_t len)
+{
+	HEADER *header;
+
+	ns_msg handle;
+	ns_rr rr;
+	int i, n, rdlen;
+	const char *format = NULL;
+	char astr[INET6_ADDRSTRLEN], dname[MAXDNAME];
+	const unsigned char *cp;
+
+	header = (HEADER *)msg;
+	if (!header->aa)
+		printf("Non-authoritative answer:\n");
+
+	if (ns_initparse(msg, len, &handle) != 0) {
+		//printf("Unable to parse reply: %s\n", strerror(errno));
+		return -1;
+	}
+
+	for (i = 0; i < ns_msg_count(handle, ns_s_an); i++) {
+		if (ns_parserr(&handle, ns_s_an, i, &rr) != 0) {
+			//printf("Unable to parse resource record: %s\n", strerror(errno));
+			return -1;
+		}
+
+		rdlen = ns_rr_rdlen(rr);
+
+		switch (ns_rr_type(rr))
+		{
+		case ns_t_a:
+			if (rdlen != 4) {
+				dbg("unexpected A record length %d\n", rdlen);
+				return -1;
+			}
+			inet_ntop(AF_INET, ns_rr_rdata(rr), astr, sizeof(astr));
+			printf("Name:\t%s\nAddress: %s\n", ns_rr_name(rr), astr);
+			break;
+
+#if ENABLE_FEATURE_IPV6
+		case ns_t_aaaa:
+			if (rdlen != 16) {
+				dbg("unexpected AAAA record length %d\n", rdlen);
+				return -1;
+			}
+			inet_ntop(AF_INET6, ns_rr_rdata(rr), astr, sizeof(astr));
+			/* bind-utils-9.11.3 uses the same format for A and AAAA answers */
+			printf("Name:\t%s\nAddress: %s\n", ns_rr_name(rr), astr);
+			break;
+#endif
+
+		case ns_t_ns:
+			if (!format)
+				format = "%s\tnameserver = %s\n";
+			/* fall through */
+
+		case ns_t_cname:
+			if (!format)
+				format = "%s\tcanonical name = %s\n";
+			/* fall through */
+
+		case ns_t_ptr:
+			if (!format)
+				format = "%s\tname = %s\n";
+			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
+					ns_rr_rdata(rr), dname, sizeof(dname)) < 0
+			) {
+				//printf("Unable to uncompress domain: %s\n", strerror(errno));
+				return -1;
+			}
+			printf(format, ns_rr_name(rr), dname);
+			break;
+
+		case ns_t_mx:
+			if (rdlen < 2) {
+				printf("MX record too short\n");
+				return -1;
+			}
+			n = ns_get16(ns_rr_rdata(rr));
+			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
+					ns_rr_rdata(rr) + 2, dname, sizeof(dname)) < 0
+			) {
+				//printf("Cannot uncompress MX domain: %s\n", strerror(errno));
+				return -1;
+			}
+			printf("%s\tmail exchanger = %d %s\n", ns_rr_name(rr), n, dname);
+			break;
+
+		case ns_t_txt:
+			if (rdlen < 1) {
+				//printf("TXT record too short\n");
+				return -1;
+			}
+			n = *(unsigned char *)ns_rr_rdata(rr);
+			if (n > 0) {
+				memset(dname, 0, sizeof(dname));
+				memcpy(dname, ns_rr_rdata(rr) + 1, n);
+				printf("%s\ttext = \"%s\"\n", ns_rr_name(rr), dname);
+			}
+			break;
+
+		case ns_t_soa:
+			if (rdlen < 20) {
+				dbg("SOA record too short:%d\n", rdlen);
+				return -1;
+			}
+
+			printf("%s\n", ns_rr_name(rr));
+
+			cp = ns_rr_rdata(rr);
+			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
+			                       cp, dname, sizeof(dname));
+			if (n < 0) {
+				//printf("Unable to uncompress domain: %s\n", strerror(errno));
+				return -1;
+			}
+
+			printf("\torigin = %s\n", dname);
+			cp += n;
+
+			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
+			                       cp, dname, sizeof(dname));
+			if (n < 0) {
+				//printf("Unable to uncompress domain: %s\n", strerror(errno));
+				return -1;
+			}
+
+			printf("\tmail addr = %s\n", dname);
+			cp += n;
+
+			printf("\tserial = %lu\n", ns_get32(cp));
+			cp += 4;
+
+			printf("\trefresh = %lu\n", ns_get32(cp));
+			cp += 4;
+
+			printf("\tretry = %lu\n", ns_get32(cp));
+			cp += 4;
+
+			printf("\texpire = %lu\n", ns_get32(cp));
+			cp += 4;
+
+			printf("\tminimum = %lu\n", ns_get32(cp));
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return i;
+}
+
+/*
+ * Function logic borrowed & modified from musl libc, res_msend.c
+ * G.query_count is always > 0.
+ */
+static int send_queries(struct ns *ns)
+{
+	unsigned char reply[512];
+	uint8_t rcode;
+	len_and_sockaddr *local_lsa;
+	struct pollfd pfd;
+	int servfail_retry = 0;
+	int n_replies = 0;
+//	int save_idx = 0;
+	unsigned retry_interval;
+	unsigned timeout = G.default_timeout * 1000;
+	unsigned tstart, tsent, tcur;
+
+	pfd.events = POLLIN;
+	pfd.fd = xsocket_type(&local_lsa, ns->lsa->u.sa.sa_family, SOCK_DGRAM);
+	/*
+	 * local_lsa has "null" address and port 0 now.
+	 * bind() ensures we have a *particular port* selected by kernel
+	 * and remembered in fd, thus later recv(fd)
+	 * receives only packets sent to this port.
+	 */
+	xbind(pfd.fd, &local_lsa->u.sa, local_lsa->len);
+	free(local_lsa);
+	/* Make read/writes know the destination */
+	xconnect(pfd.fd, &ns->lsa->u.sa, ns->lsa->len);
+	ndelay_on(pfd.fd);
+
+	retry_interval = timeout / G.default_retry;
+	tstart = tcur = monotonic_ms();
+	goto send;
+
+	while (tcur - tstart < timeout) {
+		int qn;
+		int recvlen;
+
+		if (tcur - tsent >= retry_interval) {
+ send:
+			for (qn = 0; qn < G.query_count; qn++) {
+				if (G.query[qn].qlen == 0)
+					continue; /* this one was replied already */
+
+				if (write(pfd.fd, G.query[qn].query, G.query[qn].qlen) < 0) {
+					bb_perror_msg("write to '%s'", ns->name);
+					n_replies = -1; /* "no go, try next server" */
+					goto ret;
+				}
+				dbg("query %u sent\n", qn);
+			}
+			tsent = tcur;
+			servfail_retry = 2 * G.query_count;
+		}
+
+		/* Wait for a response, or until time to retry */
+		if (poll(&pfd, 1, retry_interval - (tcur - tsent)) <= 0)
+			goto next;
+
+		recvlen = read(pfd.fd, reply, sizeof(reply));
+		if (recvlen < 0) {
+			bb_perror_msg("read");
+ next:
+			tcur = monotonic_ms();
+			continue;
+		}
+
+		if (ns->replies++ == 0) {
+			printf("Server:\t\t%s\n", ns->name);
+			printf("Address:\t%s\n\n",
+				auto_string(xmalloc_sockaddr2dotted(&ns->lsa->u.sa))
+			);
+			/* In "Address", bind-utils-9.11.3 show port after a hash: "1.2.3.4#53" */
+			/* Should we do the same? */
+		}
+
+		/* Non-identifiable packet */
+		if (recvlen < 4) {
+			dbg("read is too short:%d\n", recvlen);
+			goto next;
+		}
+
+		/* Find which query this answer goes with, if any */
+//		qn = save_idx;
+		qn = 0;
+		for (;;) {
+			if (memcmp(reply, G.query[qn].query, 2) == 0) {
+				dbg("response matches query %u\n", qn);
+				break;
+			}
+			if (++qn >= G.query_count) {
+				dbg("response does not match any query\n");
+				goto next;
+			}
+		}
+
+		if (G.query[qn].qlen == 0) {
+			dbg("dropped duplicate response to query %u\n", qn);
+			goto next;
+		}
+
+		rcode = reply[3] & 0x0f;
+		dbg("query %u rcode:%s\n", qn, rcodes[rcode]);
+
+		/* Retry immediately on SERVFAIL */
+		if (rcode == 2) {
+			ns->failures++;
+			if (servfail_retry) {
+				servfail_retry--;
+				write(pfd.fd, G.query[qn].query, G.query[qn].qlen);
+				dbg("query %u resent\n", qn);
+				goto next;
+			}
+		}
+
+		/* Process reply */
+		G.query[qn].qlen = 0; /* flag: "reply received" */
+		tcur = monotonic_ms();
+#if 1
+		if (option_mask32 & OPT_debug) {
+			printf("Query #%d completed in %ums:\n", qn, tcur - tstart);
+		}
+		if (rcode != 0) {
+			printf("** server can't find %s: %s\n",
+					G.query[qn].name, rcodes[rcode]);
+		} else {
+			if (parse_reply(reply, recvlen) < 0)
+				printf("*** Can't find %s: Parse error\n", G.query[qn].name);
+		}
+		bb_putchar('\n');
+		n_replies++;
+		if (n_replies >= G.query_count)
+			goto ret;
+#else
+//used to store replies and process them later
+		G.query[qn].latency = tcur - tstart;
+		n_replies++;
+		if (qn != save_idx) {
+			/* "wrong" receive buffer, move to correct one */
+			memcpy(G.query[qn].reply, G.query[save_idx].reply, recvlen);
+			continue;
+		}
+		/* G.query[0..save_idx] have replies, move to next one, if exists */
+		for (;;) {
+			save_idx++;
+			if (save_idx >= G.query_count)
+				goto ret; /* all are full: we have all results */
+			if (!G.query[save_idx].rlen)
+				break; /* this one is empty */
+		}
+#endif
+	} /* while() */
+
+ ret:
+	close(pfd.fd);
+
+	return n_replies;
+}
+
+static void add_ns(const char *addr)
+{
+	struct ns *ns;
+	unsigned count;
+
+	dbg("%s: addr:'%s'\n", __func__, addr);
+
+	count = G.serv_count++;
+
+	G.server = xrealloc_vector(G.server, /*8=2^3:*/ 3, count);
+	ns = &G.server[count];
+	ns->name = addr;
+	ns->lsa = xhost2sockaddr(addr, G.default_port);
+	/*ns->replies = 0; - already is */
+	/*ns->failures = 0; - already is */
+}
+
+static void parse_resolvconf(void)
+{
+	FILE *resolv;
+
+	resolv = fopen("/etc/resolv.conf", "r");
+	if (resolv) {
+		char line[128], *p;
+
+		while (fgets(line, sizeof(line), resolv)) {
+			p = strtok(line, " \t\n");
+
+			if (!p || strcmp(p, "nameserver") != 0)
+				continue;
+
+			p = strtok(NULL, " \t\n");
+
+			if (!p)
+				continue;
+
+			add_ns(xstrdup(p));
+		}
+
+		fclose(resolv);
+	}
+}
+
+static void add_query(int type, const char *dname)
+{
+	struct query *new_q;
+	unsigned count;
+	ssize_t qlen;
+
+	count = G.query_count++;
+
+	G.query = xrealloc_vector(G.query, /*2=2^1:*/ 1, count);
+	new_q = &G.query[count];
+
+	dbg("new query#%u type %u for '%s'\n", count, type, dname);
+	new_q->name = dname;
+
+	qlen = res_mkquery(QUERY, dname, C_IN, type,
+			/*data:*/ NULL, /*datalen:*/ 0,
+			/*newrr:*/ NULL,
+			new_q->query, sizeof(new_q->query)
+	);
+	new_q->qlen = qlen;
+}
+
+static char *make_ptr(const char *addrstr)
+{
+	unsigned char addr[16];
+
+#if ENABLE_FEATURE_IPV6
+	if (inet_pton(AF_INET6, addrstr, addr)) {
+		if (memcmp(addr, v4_mapped, 12) != 0) {
+			int i;
+			char resbuf[80];
+			char *ptr = resbuf;
+			for (i = 0; i < 16; i++) {
+				*ptr++ = 0x20 | bb_hexdigits_upcase[(unsigned char)addr[15 - i] & 0xf];
+				*ptr++ = '.';
+				*ptr++ = 0x20 | bb_hexdigits_upcase[(unsigned char)addr[15 - i] >> 4];
+				*ptr++ = '.';
+			}
+			strcpy(ptr, "ip6.arpa");
+			return xstrdup(resbuf);
+		}
+		return xasprintf("%u.%u.%u.%u.in-addr.arpa",
+				addr[15], addr[14], addr[13], addr[12]);
+	}
+#endif
+
+	if (inet_pton(AF_INET, addrstr, addr)) {
+		return xasprintf("%u.%u.%u.%u.in-addr.arpa",
+		        addr[3], addr[2], addr[1], addr[0]);
+	}
+
+	return NULL;
+}
+
+int nslookup_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int nslookup_main(int argc UNUSED_PARAM, char **argv)
+{
+	unsigned types;
+	int rc;
+	int err;
+
+	INIT_G();
+
+	/* manpage: "Options can also be specified on the command line
+	 * if they precede the arguments and are prefixed with a hyphen."
+	 */
+	types = 0;
+	argv++;
+	for (;;) {
+		const char *options =
+// bind-utils-9.11.3 accept these:
+// class=   cl=
+// type=    ty= querytype= query= qu= q=
+// domain=  do=
+// port=    po=
+// timeout= t=
+// retry=   ret=
+// ndots=
+// recurse
+// norecurse
+// defname
+// nodefname
+// vc
+// novc
+// debug
+// nodebug
+// d2
+// nod2
+// search
+// nosearch
+// sil
+// fail
+// nofail
+// ver (prints version and exits)
+			"type\0"      /* 0 */
+			"querytype\0" /* 1 */
+			"port\0"      /* 2 */
+			"retry\0"     /* 3 */
+			"debug\0"     /* 4 */
+			"t\0" /* disambiguate with "type": else -t=2 fails */
+			"timeout\0"   /* 6 */
+			"";
+		int i;
+		char *arg;
+		char *val;
+
+		if (!*argv)
+			bb_show_usage();
+		if (argv[0][0] != '-')
+			break;
+
+		/* Separate out "=val" part */
+		arg = (*argv++) + 1;
+		val = strchrnul(arg, '=');
+		if (*val)
+			*val++ = '\0';
+
+		i = index_in_substrings(options, arg);
+		//bb_error_msg("i:%d arg:'%s' val:'%s'", i, arg, val);
+		if (i < 0)
+			bb_show_usage();
+
+		if (i <= 1) {
+			for (i = 0;; i++) {
+				if (i == ARRAY_SIZE(qtypes))
+					bb_error_msg_and_die("invalid query type \"%s\"", val);
+				if (strcasecmp(qtypes[i].name, val) == 0)
+					break;
+			}
+			types |= (1 << i);
+			continue;
+		}
+		if (i == 2) {
+			G.default_port = xatou_range(val, 1, 0xffff);
+		}
+		if (i == 3) {
+			G.default_retry = xatou_range(val, 1, INT_MAX);
+		}
+		if (i == 4) {
+			option_mask32 |= OPT_debug;
+		}
+		if (i > 4) {
+			G.default_timeout = xatou_range(val, 1, INT_MAX / 1000);
+		}
+	}
+
+	if (types == 0) {
+		/* No explicit type given, guess query type.
+		 * If we can convert the domain argument into a ptr (means that
+		 * inet_pton() could read it) we assume a PTR request, else
+		 * we issue A+AAAA queries and switch to an output format
+		 * mimicking the one of the traditional nslookup applet.
+		 */
+		char *ptr;
+
+		ptr = make_ptr(argv[0]);
+		if (ptr) {
+			add_query(T_PTR, ptr);
+		} else {
+			add_query(T_A, argv[0]);
+#if ENABLE_FEATURE_IPV6
+			add_query(T_AAAA, argv[0]);
+#endif
+		}
+	} else {
+		int c;
+		for (c = 0; c < ARRAY_SIZE(qtypes); c++) {
+			if (types & (1 << c))
+				add_query(qtypes[c].type, argv[0]);
+		}
+	}
+
+	/* Use given DNS server if present */
+	if (argv[1]) {
+		if (argv[2])
+			bb_show_usage();
+		add_ns(argv[1]);
+	} else {
+		parse_resolvconf();
+		/* Fall back to localhost if we could not find NS in resolv.conf */
+		if (G.serv_count == 0)
+			add_ns("127.0.0.1");
+	}
+
+	for (rc = 0; rc < G.serv_count;) {
+		int c;
+
+		c = send_queries(&G.server[rc]);
+		if (c > 0) {
+			/* more than zero replies received */
+#if 0 /* which version does this? */
+			if (option_mask32 & OPT_debug) {
+				printf("Replies:\t%d\n", G.server[rc].replies);
+				printf("Failures:\t%d\n\n", G.server[rc].failures);
+			}
+#endif
+			break;
+//FIXME: we "break" even though some queries may still be not answered, and other servers may know them?
+		}
+		/* c = 0: timed out waiting for replies */
+		/* c < 0: error (message already printed) */
+		rc++;
+		if (rc >= G.serv_count) {
+//
+// NB: bind-utils-9.11.3 behavior (all to stdout, not stderr):
+//
+// $ nslookup gmail.com 8.8.8.8
+// ;; connection timed out; no servers could be reached
+//
+// Using TCP mode:
+// $ nslookup -vc gmail.com 8.8.8.8; echo EXITCODE:$?
+//     <~10 sec>
+// ;; Connection to 8.8.8.8#53(8.8.8.8) for gmail.com failed: timed out.
+//     <~10 sec>
+// ;; Connection to 8.8.8.8#53(8.8.8.8) for gmail.com failed: timed out.
+//     <~10 sec>
+// ;; connection timed out; no servers could be reached
+// ;; Connection to 8.8.8.8#53(8.8.8.8) for gmail.com failed: timed out.
+//     <empty line>
+// EXITCODE:1
+// $ _
+			printf(";; connection timed out; no servers could be reached\n\n");
+			return EXIT_FAILURE;
+		}
+	}
+
+	err = 0;
+	for (rc = 0; rc < G.query_count; rc++) {
+		if (G.query[rc].qlen) {
+			printf("*** Can't find %s: No answer\n", G.query[rc].name);
+			err = 1;
+		}
+	}
+	if (err) /* should this affect exicode too? */
+		bb_putchar('\n');
+
+	if (ENABLE_FEATURE_CLEAN_UP) {
+		free(G.server);
+		free(G.query);
+	}
+
+	return EXIT_SUCCESS;
+}
+
+#endif
diff -urpN busybox-1.28.4/networking/ntpd.c busybox-1.29.0/networking/ntpd.c
--- busybox-1.28.4/networking/ntpd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ntpd.c	2018-07-02 15:55:14.000000000 +0200
@@ -93,11 +93,10 @@
 
 #include "libbb.h"
 #include <math.h>
-#include <netinet/ip.h> /* For IPTOS_LOWDELAY definition */
-#include <sys/resource.h> /* setpriority */
+#include <netinet/ip.h> /* For IPTOS_DSCP_AF21 definition */
 #include <sys/timex.h>
-#ifndef IPTOS_LOWDELAY
-# define IPTOS_LOWDELAY 0x10
+#ifndef IPTOS_DSCP_AF21
+# define IPTOS_DSCP_AF21 0x48
 #endif
 
 
@@ -165,8 +164,12 @@
  * Using exact power of 2 (1/8) results in smaller code
  */
 #define SLEW_THRESHOLD 0.125
+//^^^^^^^^^^^^^^^^^^^^^^^^^^ TODO: man adjtimex about tmx.offset:
+// "Since Linux 2.6.26, the supplied value is clamped to the range (-0.5s, +0.5s)"
+// - can use this larger value instead?
+
 /* Stepout threshold (sec). std ntpd uses 900 (11 mins (!)) */
-#define WATCH_THRESHOLD  128
+//UNUSED: #define WATCH_THRESHOLD  128
 /* NB: set WATCH_THRESHOLD to ~60 when debugging to save time) */
 //UNUSED: #define PANIC_THRESHOLD 1000    /* panic threshold (sec) */
 
@@ -419,6 +422,7 @@ struct globals {
 	uint8_t  discipline_state;      // doc calls it c.state
 	uint8_t  poll_exp;              // s.poll
 	int      polladj_count;         // c.count
+	int      FREQHOLD_cnt;
 	long     kernel_freq_drift;
 	peer_t   *last_update_peer;
 	double   last_update_offset;    // c.last
@@ -906,7 +910,7 @@ send_query_to_peer(peer_t *p)
 #if ENABLE_FEATURE_IPV6
 		if (family == AF_INET)
 #endif
-			setsockopt_int(fd, IPPROTO_IP, IP_TOS, IPTOS_LOWDELAY);
+			setsockopt_int(fd, IPPROTO_IP, IP_TOS, IPTOS_DSCP_AF21);
 		free(local_lsa);
 	}
 
@@ -1034,6 +1038,7 @@ step_time(double offset)
 	tval = tvn.tv_sec;
 	strftime_YYYYMMDDHHMMSS(buf, sizeof(buf), &tval);
 	bb_error_msg("setting time to %s.%06u (offset %+fs)", buf, (unsigned)tvn.tv_usec, offset);
+	//maybe? G.FREQHOLD_cnt = 0;
 
 	/* Correct various fields which contain time-relative values: */
 
@@ -1709,39 +1714,96 @@ update_local_clock(peer_t *p)
 	tmx.freq = G.discipline_freq_drift * 65536e6;
 #endif
 	tmx.modes = ADJ_OFFSET | ADJ_STATUS | ADJ_TIMECONST;// | ADJ_MAXERROR | ADJ_ESTERROR;
-	tmx.constant = (int)G.poll_exp - 4;
-	/* EXPERIMENTAL.
-	 * The below if statement should be unnecessary, but...
-	 * It looks like Linux kernel's PLL is far too gentle in changing
-	 * tmx.freq in response to clock offset. Offset keeps growing
-	 * and eventually we fall back to smaller poll intervals.
-	 * We can make correction more aggressive (about x2) by supplying
-	 * PLL time constant which is one less than the real one.
-	 * To be on a safe side, let's do it only if offset is significantly
-	 * larger than jitter.
-	 */
-	if (G.offset_to_jitter_ratio >= TIMECONST_HACK_GATE)
-		tmx.constant--;
+
 	tmx.offset = (long)(offset * 1000000); /* usec */
 	if (SLEW_THRESHOLD < STEP_THRESHOLD) {
 		if (tmx.offset > (long)(SLEW_THRESHOLD * 1000000)) {
 			tmx.offset = (long)(SLEW_THRESHOLD * 1000000);
-			tmx.constant--;
 		}
 		if (tmx.offset < -(long)(SLEW_THRESHOLD * 1000000)) {
 			tmx.offset = -(long)(SLEW_THRESHOLD * 1000000);
-			tmx.constant--;
 		}
 	}
-	if (tmx.constant < 0)
-		tmx.constant = 0;
 
 	tmx.status = STA_PLL;
+	if (G.FREQHOLD_cnt != 0) {
+		/* man adjtimex on STA_FREQHOLD:
+		 * "Normally adjustments made via ADJ_OFFSET result in dampened
+		 * frequency adjustments also being made.
+		 * This flag prevents the small frequency adjustment from being
+		 * made when correcting for an ADJ_OFFSET value."
+		 *
+		 * Use this flag for a few first adjustments at the beginning
+		 * of ntpd execution, otherwise even relatively small initial
+		 * offset tend to cause largish changes to in-kernel tmx.freq.
+		 * If ntpd was restarted due to e.g. switch to another network,
+		 * this destroys already well-established tmx.freq value.
+		 */
+		if (G.FREQHOLD_cnt < 0) {
+			/* Initialize it */
+// Example: a laptop whose clock runs slower when hibernated,
+// after wake up it still has good tmx.freq, but accumulated ~0.5 sec offset:
+// Run with code where initial G.FREQHOLD_cnt was always 8:
+//15:17:52.947 no valid datapoints, no peer selected
+//15:17:56.515 update from:<IP> offset:+0.485133 delay:0.157762 jitter:0.209310 clock drift:-1.393ppm tc:4
+//15:17:57.719 update from:<IP> offset:+0.483825 delay:0.158070 jitter:0.181159 clock drift:-1.393ppm tc:4
+//15:17:59.925 update from:<IP> offset:+0.479504 delay:0.158147 jitter:0.156657 clock drift:-1.393ppm tc:4
+//15:18:33.322 update from:<IP> offset:+0.428119 delay:0.158317 jitter:0.138071 clock drift:-1.393ppm tc:4
+//15:19:06.718 update from:<IP> offset:+0.376932 delay:0.158276 jitter:0.122075 clock drift:-1.393ppm tc:4
+//15:19:39.114 update from:<IP> offset:+0.327022 delay:0.158384 jitter:0.108538 clock drift:-1.393ppm tc:4
+//15:20:12.715 update from:<IP> offset:+0.275596 delay:0.158297 jitter:0.097292 clock drift:-1.393ppm tc:4
+//15:20:45.111 update from:<IP> offset:+0.225715 delay:0.158271 jitter:0.087841 clock drift:-1.393ppm tc:4
+// If allwed to continue, it would start increasing tmx.freq now.
+// Instead, it was ^Ced, and started anew:
+//15:21:15.043 no valid datapoints, no peer selected
+//15:21:17.408 update from:<IP> offset:+0.175910 delay:0.158314 jitter:0.076683 clock drift:-1.393ppm tc:4
+//15:21:19.774 update from:<IP> offset:+0.171784 delay:0.158401 jitter:0.066436 clock drift:-1.393ppm tc:4
+//15:21:22.140 update from:<IP> offset:+0.171660 delay:0.158592 jitter:0.057536 clock drift:-1.393ppm tc:4
+//15:21:22.140 update from:<IP> offset:+0.167126 delay:0.158507 jitter:0.049792 clock drift:-1.393ppm tc:4
+//15:21:55.696 update from:<IP> offset:+0.115223 delay:0.158277 jitter:0.050240 clock drift:-1.393ppm tc:4
+//15:22:29.093 update from:<IP> offset:+0.068051 delay:0.158243 jitter:0.049405 clock drift:-1.393ppm tc:5
+//15:23:02.490 update from:<IP> offset:+0.051632 delay:0.158215 jitter:0.043545 clock drift:-1.393ppm tc:5
+//15:23:34.726 update from:<IP> offset:+0.039984 delay:0.158157 jitter:0.038106 clock drift:-1.393ppm tc:5
+// STA_FREQHOLD no longer set, started increasing tmx.freq now:
+//15:24:06.961 update from:<IP> offset:+0.030968 delay:0.158190 jitter:0.033306 clock drift:+2.387ppm tc:5
+//15:24:40.357 update from:<IP> offset:+0.023648 delay:0.158211 jitter:0.029072 clock drift:+5.454ppm tc:5
+//15:25:13.774 update from:<IP> offset:+0.018068 delay:0.157660 jitter:0.025288 clock drift:+7.728ppm tc:5
+//15:26:19.173 update from:<IP> offset:+0.010057 delay:0.157969 jitter:0.022255 clock drift:+8.361ppm tc:6
+//15:27:26.602 update from:<IP> offset:+0.006737 delay:0.158103 jitter:0.019316 clock drift:+8.792ppm tc:6
+//15:28:33.030 update from:<IP> offset:+0.004513 delay:0.158294 jitter:0.016765 clock drift:+9.080ppm tc:6
+//15:29:40.617 update from:<IP> offset:+0.002787 delay:0.157745 jitter:0.014543 clock drift:+9.258ppm tc:6
+//15:30:47.045 update from:<IP> offset:+0.001324 delay:0.157709 jitter:0.012594 clock drift:+9.342ppm tc:6
+//15:31:53.473 update from:<IP> offset:+0.000007 delay:0.158142 jitter:0.010922 clock drift:+9.343ppm tc:6
+//15:32:58.902 update from:<IP> offset:-0.000728 delay:0.158222 jitter:0.009454 clock drift:+9.298ppm tc:6
+			/*
+			 * This expression would choose 15 in the above example.
+			 */
+			G.FREQHOLD_cnt = 8 + ((unsigned)(abs(tmx.offset)) >> 16);
+		}
+		G.FREQHOLD_cnt--;
+		tmx.status |= STA_FREQHOLD;
+	}
 	if (G.ntp_status & LI_PLUSSEC)
 		tmx.status |= STA_INS;
 	if (G.ntp_status & LI_MINUSSEC)
 		tmx.status |= STA_DEL;
 
+	tmx.constant = (int)G.poll_exp - 4;
+	/* EXPERIMENTAL.
+	 * The below if statement should be unnecessary, but...
+	 * It looks like Linux kernel's PLL is far too gentle in changing
+	 * tmx.freq in response to clock offset. Offset keeps growing
+	 * and eventually we fall back to smaller poll intervals.
+	 * We can make correction more aggressive (about x2) by supplying
+	 * PLL time constant which is one less than the real one.
+	 * To be on a safe side, let's do it only if offset is significantly
+	 * larger than jitter.
+	 */
+	if (G.offset_to_jitter_ratio >= TIMECONST_HACK_GATE)
+		tmx.constant--;
+	if (tmx.constant < 0)
+		tmx.constant = 0;
+
 	//tmx.esterror = (uint32_t)(clock_jitter * 1e6);
 	//tmx.maxerror = (uint32_t)((sys_rootdelay / 2 + sys_rootdisp) * 1e6);
 	rc = adjtimex(&tmx);
@@ -2227,6 +2289,7 @@ static NOINLINE void ntp_init(char **arg
 	if (BURSTPOLL != 0)
 		G.poll_exp = BURSTPOLL; /* speeds up initial sync */
 	G.last_script_run = G.reftime = G.last_update_recv_time = gettime1900d(); /* sets G.cur_time too */
+	G.FREQHOLD_cnt = -1;
 
 	/* Parse options */
 	peers = NULL;
@@ -2257,7 +2320,7 @@ static NOINLINE void ntp_init(char **arg
 				xfunc_die();
 		}
 		socket_want_pktinfo(G_listen_fd);
-		setsockopt_int(G_listen_fd, IPPROTO_IP, IP_TOS, IPTOS_LOWDELAY);
+		setsockopt_int(G_listen_fd, IPPROTO_IP, IP_TOS, IPTOS_DSCP_AF21);
 	}
 #endif
 	/* I hesitate to set -20 prio. -15 should be high enough for timekeeping */
diff -urpN busybox-1.28.4/networking/parse_pasv_epsv.c busybox-1.29.0/networking/parse_pasv_epsv.c
--- busybox-1.28.4/networking/parse_pasv_epsv.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/networking/parse_pasv_epsv.c	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * Utility routines.
+ *
+ * Copyright (C) 2018 Denys Vlasenko
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+//kbuild:lib-$(CONFIG_FTPGET) += parse_pasv_epsv.o
+//kbuild:lib-$(CONFIG_FTPPUT) += parse_pasv_epsv.o
+//kbuild:lib-$(CONFIG_WGET) += parse_pasv_epsv.o
+
+#include "libbb.h"
+
+int FAST_FUNC parse_pasv_epsv(char *buf)
+{
+/*
+ * PASV command will not work for IPv6. RFC2428 describes
+ * IPv6-capable "extended PASV" - EPSV.
+ *
+ * "EPSV [protocol]" asks server to bind to and listen on a data port
+ * in specified protocol. Protocol is 1 for IPv4, 2 for IPv6.
+ * If not specified, defaults to "same as used for control connection".
+ * If server understood you, it should answer "229 <some text>(|||port|)"
+ * where "|" are literal pipe chars and "port" is ASCII decimal port#.
+ *
+ * There is also an IPv6-capable replacement for PORT (EPRT),
+ * but we don't need that.
+ *
+ * NB: PASV may still work for some servers even over IPv6.
+ * For example, vsftp happily answers
+ * "227 Entering Passive Mode (0,0,0,0,n,n)" and proceeds as usual.
+ */
+	char *ptr;
+	int port;
+
+	if (!ENABLE_FEATURE_IPV6 || buf[2] == '7' /* "227" */) {
+		/* Response is "227 garbageN1,N2,N3,N4,P1,P2[)garbage]"
+		 * Server's IP is N1.N2.N3.N4 (we ignore it)
+		 * Server's port for data connection is P1*256+P2 */
+		ptr = strrchr(buf, ')');
+		if (ptr) *ptr = '\0';
+
+		ptr = strrchr(buf, ',');
+		if (!ptr) return -1;
+		*ptr = '\0';
+		port = xatou_range(ptr + 1, 0, 255);
+
+		ptr = strrchr(buf, ',');
+		if (!ptr) return -1;
+		*ptr = '\0';
+		port += xatou_range(ptr + 1, 0, 255) * 256;
+	} else {
+		/* Response is "229 garbage(|||P1|)"
+		 * Server's port for data connection is P1 */
+		ptr = strrchr(buf, '|');
+		if (!ptr) return -1;
+		*ptr = '\0';
+
+		ptr = strrchr(buf, '|');
+		if (!ptr) return -1;
+		*ptr = '\0';
+		port = xatou_range(ptr + 1, 0, 65535);
+	}
+
+	return port;
+}
diff -urpN busybox-1.28.4/networking/ping.c busybox-1.29.0/networking/ping.c
--- busybox-1.28.4/networking/ping.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ping.c	2018-07-02 15:55:14.000000000 +0200
@@ -74,6 +74,7 @@
 //usage:	)
 //usage:     "\n	-c CNT		Send only CNT pings"
 //usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default 56)"
+//usage:     "\n	-A		Ping as soon as reply is recevied"
 //usage:     "\n	-t TTL		Set TTL"
 //usage:     "\n	-I IFACE/IP	Source interface or IP address"
 //usage:     "\n	-W SEC		Seconds to wait for the first response (default 10)"
@@ -90,6 +91,7 @@
 //usage:       "Send ICMP ECHO_REQUEST packets to network hosts\n"
 //usage:     "\n	-c CNT		Send only CNT pings"
 //usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default 56)"
+//usage:     "\n	-A		Ping as soon as reply is recevied"
 //usage:     "\n	-I IFACE/IP	Source interface or IP address"
 //usage:     "\n	-q		Quiet, only display output at start"
 //usage:     "\n			and when finished"
@@ -348,20 +350,21 @@ static int common_ping_main(sa_family_t
 /* Full(er) version */
 
 /* -c NUM, -t NUM, -w NUM, -W NUM */
-#define OPT_STRING "qvc:+s:t:+w:+W:+I:np:4"IF_PING6("6")
+#define OPT_STRING "qvAc:+s:t:+w:+W:+I:np:4"IF_PING6("6")
 enum {
 	OPT_QUIET = 1 << 0,
 	OPT_VERBOSE = 1 << 1,
-	OPT_c = 1 << 2,
-	OPT_s = 1 << 3,
-	OPT_t = 1 << 4,
-	OPT_w = 1 << 5,
-	OPT_W = 1 << 6,
-	OPT_I = 1 << 7,
-	/*OPT_n = 1 << 8, - ignored */
-	OPT_p = 1 << 9,
-	OPT_IPV4 = 1 << 10,
-	OPT_IPV6 = (1 << 11) * ENABLE_PING6,
+	OPT_A = 1 << 2,
+	OPT_c = 1 << 3,
+	OPT_s = 1 << 4,
+	OPT_t = 1 << 5,
+	OPT_w = 1 << 6,
+	OPT_W = 1 << 7,
+	OPT_I = 1 << 8,
+	/*OPT_n = 1 << 9, - ignored */
+	OPT_p = 1 << 10,
+	OPT_IPV4 = 1 << 11,
+	OPT_IPV6 = (1 << 12) * ENABLE_PING6,
 };
 
 
@@ -377,9 +380,9 @@ struct globals {
 	uint8_t pattern;
 	unsigned tmin, tmax; /* in us */
 	unsigned long long tsum; /* in us, sum of all times */
-	unsigned deadline;
+	unsigned cur_us; /* low word only, we don't need more */
+	unsigned deadline_us;
 	unsigned timeout;
-	unsigned total_secs;
 	unsigned sizeof_rcv_packet;
 	char *rcv_packet; /* [datalen + MAXIPLEN + MAXICMPLEN] */
 	void *snd_packet; /* [datalen + ipv4/ipv6_const] */
@@ -405,9 +408,7 @@ struct globals {
 #define tmin         (G.tmin        )
 #define tmax         (G.tmax        )
 #define tsum         (G.tsum        )
-#define deadline     (G.deadline    )
 #define timeout      (G.timeout     )
-#define total_secs   (G.total_secs  )
 #define hostname     (G.hostname    )
 #define dotted       (G.dotted      )
 #define pingaddr     (G.pingaddr    )
@@ -455,7 +456,7 @@ static void print_stats_and_exit(int jun
 			tmax / 1000, tmax % 1000);
 	}
 	/* if condition is true, exit with 1 -- 'failure' */
-	exit(nrecv == 0 || (deadline && nrecv < pingcount));
+	exit(nrecv == 0 || (G.deadline_us && nrecv < pingcount));
 }
 
 static void sendping_tail(void (*sp)(int), int size_pkt)
@@ -467,22 +468,23 @@ static void sendping_tail(void (*sp)(int
 
 	size_pkt += datalen;
 
+	if (G.deadline_us) {
+		unsigned n = G.cur_us - G.deadline_us;
+		if ((int)n >= 0)
+			print_stats_and_exit(0);
+	}
+
 	/* sizeof(pingaddr) can be larger than real sa size, but I think
 	 * it doesn't matter */
 	sz = xsendto(pingsock, G.snd_packet, size_pkt, &pingaddr.sa, sizeof(pingaddr));
 	if (sz != size_pkt)
 		bb_error_msg_and_die(bb_msg_write_error);
 
-	if (pingcount == 0 || deadline || G.ntransmitted < pingcount) {
+	if (pingcount == 0 || G.ntransmitted < pingcount) {
 		/* Didn't send all pings yet - schedule next in 1s */
 		signal(SIGALRM, sp);
-		if (deadline) {
-			total_secs += PINGINTERVAL;
-			if (total_secs >= deadline)
-				signal(SIGALRM, print_stats_and_exit);
-		}
 		alarm(PINGINTERVAL);
-	} else { /* -c NN, and all NN are sent (and no deadline) */
+	} else { /* -c NN, and all NN are sent */
 		/* Wait for the last ping to come back.
 		 * -W timeout: wait for a response in seconds.
 		 * Affects only timeout in absence of any responses,
@@ -516,7 +518,7 @@ static void sendping4(int junk UNUSED_PA
 	 */
 	/*if (datalen >= 4)*/
 		/* No hton: we'll read it back on the same machine */
-		*(uint32_t*)&pkt->icmp_dun = monotonic_us();
+		*(uint32_t*)&pkt->icmp_dun = G.cur_us = monotonic_us();
 
 	pkt->icmp_cksum = inet_cksum((uint16_t *) pkt, datalen + ICMP_MINLEN);
 
@@ -535,7 +537,7 @@ static void sendping6(int junk UNUSED_PA
 	pkt->icmp6_id = myid;
 
 	/*if (datalen >= 4)*/
-		*(bb__aliased_uint32_t*)(&pkt->icmp6_data8[4]) = monotonic_us();
+		*(bb__aliased_uint32_t*)(&pkt->icmp6_data8[4]) = G.cur_us = monotonic_us();
 
 	//TODO? pkt->icmp_cksum = inet_cksum(...);
 
@@ -632,7 +634,7 @@ static void unpack_tail(int sz, uint32_t
 	puts(dupmsg);
 	fflush_all();
 }
-static void unpack4(char *buf, int sz, struct sockaddr_in *from)
+static int unpack4(char *buf, int sz, struct sockaddr_in *from)
 {
 	struct icmp *icmppkt;
 	struct iphdr *iphdr;
@@ -640,7 +642,7 @@ static void unpack4(char *buf, int sz, s
 
 	/* discard if too short */
 	if (sz < (datalen + ICMP_MINLEN))
-		return;
+		return 0;
 
 	/* check IP header */
 	iphdr = (struct iphdr *) buf;
@@ -648,7 +650,7 @@ static void unpack4(char *buf, int sz, s
 	sz -= hlen;
 	icmppkt = (struct icmp *) (buf + hlen);
 	if (icmppkt->icmp_id != myid)
-		return;				/* not our ping */
+		return 0;				/* not our ping */
 
 	if (icmppkt->icmp_type == ICMP_ECHOREPLY) {
 		uint16_t recv_seq = ntohs(icmppkt->icmp_seq);
@@ -659,25 +661,28 @@ static void unpack4(char *buf, int sz, s
 		unpack_tail(sz, tp,
 			inet_ntoa(*(struct in_addr *) &from->sin_addr.s_addr),
 			recv_seq, iphdr->ttl);
-	} else if (icmppkt->icmp_type != ICMP_ECHO) {
+		return 1;
+	}
+	if (icmppkt->icmp_type != ICMP_ECHO) {
 		bb_error_msg("warning: got ICMP %d (%s)",
 				icmppkt->icmp_type,
 				icmp_type_name(icmppkt->icmp_type));
 	}
+	return 0;
 }
 #if ENABLE_PING6
-static void unpack6(char *packet, int sz, struct sockaddr_in6 *from, int hoplimit)
+static int unpack6(char *packet, int sz, struct sockaddr_in6 *from, int hoplimit)
 {
 	struct icmp6_hdr *icmppkt;
 	char buf[INET6_ADDRSTRLEN];
 
 	/* discard if too short */
 	if (sz < (datalen + sizeof(struct icmp6_hdr)))
-		return;
+		return 0;
 
 	icmppkt = (struct icmp6_hdr *) packet;
 	if (icmppkt->icmp6_id != myid)
-		return;				/* not our ping */
+		return 0;				/* not our ping */
 
 	if (icmppkt->icmp6_type == ICMP6_ECHO_REPLY) {
 		uint16_t recv_seq = ntohs(icmppkt->icmp6_seq);
@@ -689,11 +694,14 @@ static void unpack6(char *packet, int sz
 			inet_ntop(AF_INET6, &from->sin6_addr,
 					buf, sizeof(buf)),
 			recv_seq, hoplimit);
-	} else if (icmppkt->icmp6_type != ICMP6_ECHO_REQUEST) {
+		return 1;
+	}
+	if (icmppkt->icmp6_type != ICMP6_ECHO_REQUEST) {
 		bb_error_msg("warning: got ICMP %d (%s)",
 				icmppkt->icmp6_type,
 				icmp6_type_name(icmppkt->icmp6_type));
 	}
+	return 0;
 }
 #endif
 
@@ -726,6 +734,7 @@ static void ping4(len_and_sockaddr *lsa)
 	signal(SIGINT, print_stats_and_exit);
 
 	/* start the ping's going ... */
+ send_ping:
 	sendping4(0);
 
 	/* listen for replies */
@@ -741,9 +750,12 @@ static void ping4(len_and_sockaddr *lsa)
 				bb_perror_msg("recvfrom");
 			continue;
 		}
-		unpack4(G.rcv_packet, c, &from);
+		c = unpack4(G.rcv_packet, c, &from);
 		if (pingcount && G.nreceived >= pingcount)
 			break;
+		if (c && (option_mask32 & OPT_A)) {
+			goto send_ping;
+		}
 	}
 }
 #if ENABLE_PING6
@@ -794,10 +806,6 @@ static void ping6(len_and_sockaddr *lsa)
 
 	signal(SIGINT, print_stats_and_exit);
 
-	/* start the ping's going ... */
-	sendping6(0);
-
-	/* listen for replies */
 	msg.msg_name = &from;
 	msg.msg_namelen = sizeof(from);
 	msg.msg_iov = &iov;
@@ -805,12 +813,18 @@ static void ping6(len_and_sockaddr *lsa)
 	msg.msg_control = control_buf;
 	iov.iov_base = G.rcv_packet;
 	iov.iov_len = G.sizeof_rcv_packet;
+
+	/* start the ping's going ... */
+ send_ping:
+	sendping6(0);
+
+	/* listen for replies */
 	while (1) {
 		int c;
 		struct cmsghdr *mp;
 		int hoplimit = -1;
-		msg.msg_controllen = sizeof(control_buf);
 
+		msg.msg_controllen = sizeof(control_buf);
 		c = recvmsg(pingsock, &msg, 0);
 		if (c < 0) {
 			if (errno != EINTR)
@@ -827,9 +841,12 @@ static void ping6(len_and_sockaddr *lsa)
 				move_from_unaligned_int(hoplimit, CMSG_DATA(mp));
 			}
 		}
-		unpack6(G.rcv_packet, c, &from, hoplimit);
+		c = unpack6(G.rcv_packet, c, &from, hoplimit);
 		if (pingcount && G.nreceived >= pingcount)
 			break;
+		if (c && (option_mask32 & OPT_A)) {
+			goto send_ping;
+		}
 	}
 }
 #endif
@@ -875,7 +892,7 @@ static int common_ping_main(int opt, cha
 			OPT_STRING
 			/* exactly one arg; -v and -q don't mix */
 			"\0" "=1:q--v:v--q",
-			&pingcount, &str_s, &opt_ttl, &deadline, &timeout, &str_I, &str_p
+			&pingcount, &str_s, &opt_ttl, &G.deadline_us, &timeout, &str_I, &str_p
 	);
 	if (opt & OPT_s)
 		datalen = xatou16(str_s); // -s
@@ -889,6 +906,10 @@ static int common_ping_main(int opt, cha
 	}
 	if (opt & OPT_p)
 		G.pattern = xstrtou_range(str_p, 16, 0, 255);
+	if (G.deadline_us) {
+		unsigned d = G.deadline_us < INT_MAX/1000000 ? G.deadline_us : INT_MAX/1000000;
+		G.deadline_us = 1 | ((d * 1000000) + monotonic_us());
+	}
 
 	myid = (uint16_t) getpid();
 	hostname = argv[optind];
@@ -911,7 +932,7 @@ static int common_ping_main(int opt, cha
 
 	dotted = xmalloc_sockaddr2dotted_noport(&lsa->u.sa);
 	ping(lsa);
-	print_stats_and_exit(EXIT_SUCCESS);
+	print_stats_and_exit(0);
 	/*return EXIT_SUCCESS;*/
 }
 #endif /* FEATURE_FANCY_PING */
diff -urpN busybox-1.28.4/networking/route.c busybox-1.29.0/networking/route.c
--- busybox-1.28.4/networking/route.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/route.c	2018-07-02 15:55:14.000000000 +0200
@@ -444,7 +444,7 @@ static NOINLINE void INET6_setroute(int
 
 	if (devname) {
 		struct ifreq ifr;
-		memset(&ifr, 0, sizeof(ifr));
+		/*memset(&ifr, 0, sizeof(ifr)); - SIOCGIFINDEX does not need to clear all */
 		strncpy_IFNAMSIZ(ifr.ifr_name, devname);
 		xioctl(skfd, SIOCGIFINDEX, &ifr);
 		rt.rtmsg_ifindex = ifr.ifr_ifindex;
diff -urpN busybox-1.28.4/networking/ssl_client.c busybox-1.29.0/networking/ssl_client.c
--- busybox-1.28.4/networking/ssl_client.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/ssl_client.c	2018-07-02 15:55:14.000000000 +0200
@@ -15,7 +15,7 @@
 //kbuild:lib-$(CONFIG_SSL_CLIENT) += ssl_client.o
 
 //usage:#define ssl_client_trivial_usage
-//usage:       "-s FD [-r FD] [-n SNI]"
+//usage:       "[-e] -s FD [-r FD] [-n SNI]"
 //usage:#define ssl_client_full_usage ""
 
 #include "libbb.h"
@@ -30,26 +30,28 @@ int ssl_client_main(int argc UNUSED_PARA
 	// INIT_G();
 
 	tls = new_tls_state();
-	opt = getopt32(argv, "s:+r:+n:", &tls->ofd, &tls->ifd, &sni);
-	if (!(opt & 2)) {
+	opt = getopt32(argv, "es:+r:+n:", &tls->ofd, &tls->ifd, &sni);
+	if (!(opt & (1<<2))) {
 		/* -r N defaults to -s N */
 		tls->ifd = tls->ofd;
 	}
 
-	if (!(opt & 3)) {
+	if (!(opt & (3<<1))) {
 		if (!argv[1])
 			bb_show_usage();
 		/* Undocumented debug feature: without -s and -r, takes HOST arg and connects to it */
 		//
 		// Talk to kernel.org:
-		// printf "GET / HTTP/1.1\r\nHost: kernel.org\r\n\r\n" | ./busybox ssl_client kernel.org
+		// printf "GET / HTTP/1.1\r\nHost: kernel.org\r\n\r\n" | busybox ssl_client kernel.org
 		if (!sni)
 			sni = argv[1];
 		tls->ifd = tls->ofd = create_and_connect_stream_or_die(argv[1], 443);
 	}
 
 	tls_handshake(tls, sni);
-	tls_run_copy_loop(tls);
+
+	BUILD_BUG_ON(TLSLOOP_EXIT_ON_LOCAL_EOF != 1);
+	tls_run_copy_loop(tls, /*flags*/ opt & 1);
 
 	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.28.4/networking/tc.c busybox-1.29.0/networking/tc.c
--- busybox-1.28.4/networking/tc.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/tc.c	2018-07-02 15:55:14.000000000 +0200
@@ -6,22 +6,20 @@
  *
  * Bernhard Reutner-Fischer adjusted for busybox
  */
+//config:config TC
+//config:	bool "tc (3.1 kb)"
+//config:	default y
+//config:	help
+//config:	Show / manipulate traffic control settings
+//config:
+//config:config FEATURE_TC_INGRESS
+//config:	bool "Enable ingress"
+//config:	default y
+//config:	depends on TC
 
-/* Was disabled in 2008 by Bernhard, not known why.
---//config:#config TC
---//config:#	bool "tc"
---//config:#	default y
---//config:#	help
---//config:#	  Show / manipulate traffic control settings
---//config:#
---//config:#config FEATURE_TC_INGRESS
---//config:#	default y
---//config:#	depends on TC
---
---//applet:IF_TC(APPLET(tc, BB_DIR_SBIN, BB_SUID_DROP))
---
---//kbuild:lib-$(CONFIG_TC) += tc.o
-*/
+//applet:IF_TC(APPLET(tc, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_TC) += tc.o
 
 //usage:#define tc_trivial_usage
 /* //usage: "[OPTIONS] OBJECT CMD [dev STRING]" */
@@ -52,6 +50,17 @@
 #include "libiproute/rt_names.h"
 #include <linux/pkt_sched.h> /* for the TC_H_* macros */
 
+/* This is the deprecated multiqueue interface */
+#ifndef TCA_PRIO_MAX
+enum
+{
+	TCA_PRIO_UNSPEC,
+	TCA_PRIO_MQ,
+	__TCA_PRIO_MAX
+};
+#define TCA_PRIO_MAX    (__TCA_PRIO_MAX - 1)
+#endif
+
 #define parse_rtattr_nested(tb, max, rta) \
 	(parse_rtattr((tb), (max), RTA_DATA(rta), RTA_PAYLOAD(rta)))
 
@@ -188,11 +197,13 @@ static void print_rate(char *buf, int le
 	}
 }
 
+#if 0
 /* This is "pfifo_fast".  */
 static int prio_parse_opt(int argc, char **argv, struct nlmsghdr *n)
 {
 	return 0;
 }
+#endif
 static int prio_print_opt(struct rtattr *opt)
 {
 	int i;
@@ -215,11 +226,13 @@ static int prio_print_opt(struct rtattr
 	return 0;
 }
 
+#if 0
 /* Class Based Queue */
 static int cbq_parse_opt(int argc, char **argv, struct nlmsghdr *n)
 {
 	return 0;
 }
+#endif
 static int cbq_print_opt(struct rtattr *opt)
 {
 	struct rtattr *tb[TCA_CBQ_MAX+1];
@@ -312,8 +325,10 @@ static int cbq_print_opt(struct rtattr *
 	return 0;
 }
 
-static int print_qdisc(const struct sockaddr_nl *who UNUSED_PARAM,
-						struct nlmsghdr *hdr, void *arg UNUSED_PARAM)
+static FAST_FUNC int print_qdisc(
+		const struct sockaddr_nl *who UNUSED_PARAM,
+		struct nlmsghdr *hdr,
+		void *arg UNUSED_PARAM)
 {
 	struct tcmsg *msg = NLMSG_DATA(hdr);
 	int len = hdr->nlmsg_len;
@@ -368,8 +383,10 @@ static int print_qdisc(const struct sock
 	return 0;
 }
 
-static int print_class(const struct sockaddr_nl *who UNUSED_PARAM,
-						struct nlmsghdr *hdr, void *arg UNUSED_PARAM)
+static FAST_FUNC int print_class(
+		const struct sockaddr_nl *who UNUSED_PARAM,
+		struct nlmsghdr *hdr,
+		void *arg UNUSED_PARAM)
 {
 	struct tcmsg *msg = NLMSG_DATA(hdr);
 	int len = hdr->nlmsg_len;
@@ -436,8 +453,10 @@ static int print_class(const struct sock
 	return 0;
 }
 
-static int print_filter(const struct sockaddr_nl *who UNUSED_PARAM,
-						struct nlmsghdr *hdr, void *arg UNUSED_PARAM)
+static FAST_FUNC int print_filter(
+		const struct sockaddr_nl *who UNUSED_PARAM,
+		struct nlmsghdr *hdr UNUSED_PARAM,
+		void *arg UNUSED_PARAM)
 {
 	return 0;
 }
@@ -455,6 +474,12 @@ int tc_main(int argc UNUSED_PARAM, char
 		"replace\0"
 		"show\0""list\0"
 		;
+	enum {
+		CMD_add = 0, CMD_del, CMD_change,
+		CMD_link,
+		CMD_replace,
+		CMD_show
+	};
 	static const char args[] ALIGN1 =
 		"dev\0" /* qdisc, class, filter */
 		"root\0" /* class, filter */
@@ -464,9 +489,15 @@ int tc_main(int argc UNUSED_PARAM, char
 		"classid\0" /* change: for class use "handle" */
 		"preference\0""priority\0""protocol\0" /* filter */
 		;
-	enum { CMD_add = 0, CMD_del, CMD_change, CMD_link, CMD_replace, CMD_show };
-	enum { ARG_dev = 0, ARG_root, ARG_parent, ARG_qdisc,
-			ARG_handle, ARG_classid, ARG_pref, ARG_prio, ARG_proto};
+	enum {
+		ARG_dev = 0,
+		ARG_root,
+		ARG_parent,
+		ARG_qdisc,
+		ARG_handle,
+		ARG_classid,
+		ARG_pref, ARG_prio, ARG_proto
+	};
 	struct rtnl_handle rth;
 	struct tcmsg msg;
 	int ret, obj, cmd, arg;
@@ -491,9 +522,12 @@ int tc_main(int argc UNUSED_PARAM, char
 			invarg_1_to_2(*argv, argv[-1]);
 		argv++;
 	}
+
 	memset(&msg, 0, sizeof(msg));
-	msg.tcm_family = AF_UNSPEC;
+	if (AF_UNSPEC != 0)
+		msg.tcm_family = AF_UNSPEC;
 	ll_init_map(&rth);
+
 	while (*argv) {
 		arg = index_in_substrings(args, *argv);
 		if (arg == ARG_dev) {
@@ -530,7 +564,8 @@ int tc_main(int argc UNUSED_PARAM, char
 			msg.tcm_parent = TC_H_ROOT;
 			if (obj == OBJ_filter)
 				filter_parent = TC_H_ROOT;
-		} else if (arg == ARG_parent) {
+		} else
+		if (arg == ARG_parent) {
 			uint32_t handle;
 			if (msg.tcm_parent)
 				duparg(*argv, "parent");
@@ -539,23 +574,31 @@ int tc_main(int argc UNUSED_PARAM, char
 			msg.tcm_parent = handle;
 			if (obj == OBJ_filter)
 				filter_parent = handle;
-		} else if (arg == ARG_handle) { /* filter::list */
+		} else
+		if (arg == ARG_handle) { /* filter::list */
 			if (msg.tcm_handle)
 				duparg(*argv, "handle");
 			/* reject LONG_MIN || LONG_MAX */
 			/* TODO: for fw
 			slash = strchr(handle, '/');
 			if (slash != NULL)
-				   *slash = '\0';
+				*slash = '\0';
 			 */
 			msg.tcm_handle = get_u32(*argv, "handle");
 			/* if (slash) {if (get_u32(uint32_t &mask, slash+1, NULL)) inv mask; addattr32(n, MAX_MSG, TCA_FW_MASK, mask); */
-		} else if (arg == ARG_classid && obj == OBJ_class && cmd == CMD_change){
-		} else if (arg == ARG_pref || arg == ARG_prio) { /* filter::list */
+		} else
+		if (arg == ARG_classid
+		 && obj == OBJ_class
+		 && cmd == CMD_change
+		) {
+			/* TODO */
+		} else
+		if (arg == ARG_pref || arg == ARG_prio) { /* filter::list */
 			if (filter_prio)
 				duparg(*argv, "priority");
 			filter_prio = get_u32(*argv, "priority");
-		} else if (arg == ARG_proto) { /* filter::list */
+		} else
+		if (arg == ARG_proto) { /* filter::list */
 			uint16_t tmp;
 			if (filter_proto)
 				duparg(*argv, "protocol");
@@ -564,6 +607,7 @@ int tc_main(int argc UNUSED_PARAM, char
 			filter_proto = tmp;
 		}
 	}
+
 	if (cmd >= CMD_show) { /* show or list */
 		if (obj == OBJ_filter)
 			msg.tcm_info = TC_H_MAKE(filter_prio<<16, filter_proto);
diff -urpN busybox-1.28.4/networking/tcpudp.c busybox-1.29.0/networking/tcpudp.c
--- busybox-1.28.4/networking/tcpudp.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/tcpudp.c	2018-07-02 15:55:14.000000000 +0200
@@ -127,6 +127,7 @@ struct globals {
 	unsigned cur_per_host;
 	unsigned cnum;
 	unsigned cmax;
+	struct hcc *cc;
 	char **env_cur;
 	char *env_var[1]; /* actually bigger */
 } FIX_ALIASING;
@@ -229,7 +230,7 @@ static void sig_child_handler(int sig UN
 
 	while ((pid = wait_any_nohang(&wstat)) > 0) {
 		if (max_per_host)
-			ipsvd_perhost_remove(pid);
+			ipsvd_perhost_remove(G.cc, pid);
 		if (cnum)
 			cnum--;
 		if (verbose)
@@ -323,7 +324,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 	sslser = user;
 	client = 0;
 	if ((getuid() == 0) && !(opts & OPT_u)) {
-		xfunc_exitcode = 100;
+		xfunc_error_retval = 100;
 		bb_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (opts & OPT_u)
@@ -352,7 +353,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 	signal(SIGPIPE, SIG_IGN);
 
 	if (max_per_host)
-		ipsvd_perhost_init(cmax);
+		G.cc = ipsvd_perhost_init(cmax);
 
 	local_port = bb_lookup_port(argv[1], tcp ? "tcp" : "udp", 0);
 	lsa = xhost2sockaddr(argv[0], local_port);
@@ -427,7 +428,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 		/* Drop connection immediately if cur_per_host > max_per_host
 		 * (minimizing load under SYN flood) */
 		remote_addr = xmalloc_sockaddr2dotted_noport(&remote.u.sa);
-		cur_per_host = ipsvd_perhost_add(remote_addr, max_per_host, &hccp);
+		cur_per_host = ipsvd_perhost_add(G.cc, remote_addr, max_per_host, &hccp);
 		if (cur_per_host > max_per_host) {
 			/* ipsvd_perhost_add detected that max is exceeded
 			 * (and did not store ip in connection table) */
diff -urpN busybox-1.28.4/networking/tcpudp_perhost.c busybox-1.29.0/networking/tcpudp_perhost.c
--- busybox-1.28.4/networking/tcpudp_perhost.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/tcpudp_perhost.c	2018-07-02 15:55:14.000000000 +0200
@@ -10,25 +10,21 @@
 #include "libbb.h"
 #include "tcpudp_perhost.h"
 
-static struct hcc *cc;
-static unsigned cclen;
-
-/* to be optimized */
-
-void ipsvd_perhost_init(unsigned c)
+struct hcc* FAST_FUNC ipsvd_perhost_init(unsigned c)
 {
 //	free(cc);
-	cc = xzalloc(c * sizeof(*cc));
-	cclen = c;
+	struct hcc *cc = xzalloc((c + 1) * sizeof(*cc));
+	cc[c].pid = -1; /* "end" marker */
+	return cc;
 }
 
-unsigned ipsvd_perhost_add(char *ip, unsigned maxconn, struct hcc **hccpp)
+unsigned FAST_FUNC ipsvd_perhost_add(struct hcc *cc, char *ip, unsigned maxconn, struct hcc **hccpp)
 {
 	unsigned i;
 	unsigned conn = 1;
 	int freepos = -1;
 
-	for (i = 0; i < cclen; ++i) {
+	for (i = 0; cc[i].pid >= 0; ++i) {
 		if (!cc[i].ip) {
 			freepos = i;
 			continue;
@@ -46,10 +42,10 @@ unsigned ipsvd_perhost_add(char *ip, uns
 	return conn;
 }
 
-void ipsvd_perhost_remove(int pid)
+void FAST_FUNC ipsvd_perhost_remove(struct hcc *cc, int pid)
 {
 	unsigned i;
-	for (i = 0; i < cclen; ++i) {
+	for (i = 0; cc[i].pid >= 0; ++i) {
 		if (cc[i].pid == pid) {
 			free(cc[i].ip);
 			cc[i].ip = NULL;
@@ -59,7 +55,7 @@ void ipsvd_perhost_remove(int pid)
 	}
 }
 
-//void ipsvd_perhost_free(void)
+//void ipsvd_perhost_free(struct hcc *cc)
 //{
 //	free(cc);
 //}
diff -urpN busybox-1.28.4/networking/tcpudp_perhost.h busybox-1.29.0/networking/tcpudp_perhost.h
--- busybox-1.28.4/networking/tcpudp_perhost.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/tcpudp_perhost.h	2018-07-02 15:55:14.000000000 +0200
@@ -14,7 +14,7 @@ struct hcc {
 	int pid;
 };
 
-void ipsvd_perhost_init(unsigned);
+struct hcc* FAST_FUNC ipsvd_perhost_init(unsigned);
 
 /* Returns number of already opened connects to this ips, including this one.
  * ip should be a malloc'ed ptr.
@@ -22,12 +22,12 @@ void ipsvd_perhost_init(unsigned);
  * and pointer to table entry if stored in *hccpp
  * (useful for storing pid later).
  * Else ip is NOT inserted (you must take care of it - free() etc) */
-unsigned ipsvd_perhost_add(char *ip, unsigned maxconn, struct hcc **hccpp);
+unsigned FAST_FUNC ipsvd_perhost_add(struct hcc *cc, char *ip, unsigned maxconn, struct hcc **hccpp);
 
 /* Finds and frees element with pid */
-void ipsvd_perhost_remove(int pid);
+void FAST_FUNC ipsvd_perhost_remove(struct hcc *cc, int pid);
 
 //unsigned ipsvd_perhost_setpid(int pid);
-//void ipsvd_perhost_free(void);
+//void ipsvd_perhost_free(struct hcc *cc);
 
 POP_SAVED_FUNCTION_VISIBILITY
diff -urpN busybox-1.28.4/networking/telnet.c busybox-1.29.0/networking/telnet.c
--- busybox-1.28.4/networking/telnet.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/telnet.c	2018-07-02 15:55:14.000000000 +0200
@@ -89,12 +89,6 @@
 # define TELOPT_NAWS  31  /* window size */
 #endif
 
-#ifdef DOTRACE
-# define TRACE(x, y) do { if (x) printf y; } while (0)
-#else
-# define TRACE(x, y)
-#endif
-
 enum {
 	DATABUFSIZE = 128,
 	IACBUFSIZE  = 128,
@@ -627,10 +621,6 @@ int telnet_main(int argc UNUSED_PARAM, c
 
 	INIT_G();
 
-#if ENABLE_FEATURE_TELNET_WIDTH
-	get_terminal_width_height(0, &G.win_width, &G.win_height);
-#endif
-
 #if ENABLE_FEATURE_TELNET_TTYPE
 	G.ttype = getenv("TERM");
 #endif
@@ -653,7 +643,8 @@ int telnet_main(int argc UNUSED_PARAM, c
 	if (!*argv)
 		bb_show_usage();
 	host = *argv++;
-	port = bb_lookup_port(*argv ? *argv++ : "telnet", "tcp", 23);
+	port = *argv ? bb_lookup_port(*argv++, "tcp", 23)
+		: bb_lookup_std_port("telnet", "tcp", 23);
 	if (*argv) /* extra params?? */
 		bb_show_usage();
 
@@ -661,6 +652,11 @@ int telnet_main(int argc UNUSED_PARAM, c
 
 	setsockopt_keepalive(netfd);
 
+#if ENABLE_FEATURE_TELNET_WIDTH
+	get_terminal_width_height(0, &G.win_width, &G.win_height);
+//TODO: support dynamic resize?
+#endif
+
 	signal(SIGINT, record_signo);
 
 	ufds[0].fd = STDIN_FILENO;
@@ -684,7 +680,6 @@ int telnet_main(int argc UNUSED_PARAM, c
 			len = safe_read(STDIN_FILENO, G.buf, DATABUFSIZE);
 			if (len <= 0)
 				doexit(EXIT_SUCCESS);
-			TRACE(0, ("Read con: %d\n", len));
 			handle_net_output(len);
 		}
 
@@ -694,7 +689,6 @@ int telnet_main(int argc UNUSED_PARAM, c
 				full_write1_str("Connection closed by foreign host\r\n");
 				doexit(EXIT_FAILURE);
 			}
-			TRACE(0, ("Read netfd (%d): %d\n", netfd, len));
 			handle_net_input(len);
 		}
 	} /* while (1) */
diff -urpN busybox-1.28.4/networking/tls.c busybox-1.29.0/networking/tls.c
--- busybox-1.28.4/networking/tls.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/tls.c	2018-07-02 15:55:14.000000000 +0200
@@ -806,8 +806,6 @@ static int tls_xread_record(tls_state_t
 			 || xhdr->proto_min != TLS_MIN
 			) {
 				sz = total < target ? total : target;
-				if (sz > 24)
-					sz = 24; /* don't flood */
 				bad_record_die(tls, expected, sz);
 			}
 			dbg("xhdr type:%d ver:%d.%d len:%d\n",
@@ -1084,6 +1082,8 @@ static void find_key_in_der_cert(tls_sta
  * We need Certificate.tbsCertificate.subjectPublicKeyInfo.publicKey
  */
 	uint8_t *end = der + len;
+	uint8_t tag_class, pc, tag_number;
+	int version_present;
 
 	/* enter "Certificate" item: [der, end) will be only Cert */
 	der = enter_der_item(der, &end);
@@ -1091,8 +1091,24 @@ static void find_key_in_der_cert(tls_sta
 	/* enter "tbsCertificate" item: [der, end) will be only tbsCert */
 	der = enter_der_item(der, &end);
 
+	/*
+	 * Skip version field only if it is present. For a v1 certificate, the
+	 * version field won't be present since v1 is the default value for the
+	 * version field and fields with default values should be omitted (see
+	 * RFC 5280 sections 4.1 and 4.1.2.1). If the version field is present
+	 * it will have a tag class of 2 (context-specific), bit 6 as 1
+	 * (constructed), and a tag number of 0 (see ITU-T X.690 sections 8.1.2
+	 * and 8.14).
+	 */
+	tag_class = der[0] >> 6; /* bits 8-7 */
+	pc = (der[0] & 32) >> 5; /* bit 6 */
+	tag_number = der[0] & 31; /* bits 5-1 */
+	version_present = tag_class == 2 && pc == 1 && tag_number == 0;
+	if (version_present) {
+		der = skip_der_item(der, end); /* version */
+	}
+
 	/* skip up to subjectPublicKeyInfo */
-	der = skip_der_item(der, end); /* version */
 	der = skip_der_item(der, end); /* serialNumber */
 	der = skip_der_item(der, end); /* signatureAlgo */
 	der = skip_der_item(der, end); /* issuer */
@@ -1727,7 +1743,7 @@ static void tls_xwrite(tls_state_t *tls,
 // openssl s_server -key key.pem -cert server.pem -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher NULL
 // openssl s_client -connect 127.0.0.1:4433 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher NULL-SHA256
 
-void FAST_FUNC tls_run_copy_loop(tls_state_t *tls)
+void FAST_FUNC tls_run_copy_loop(tls_state_t *tls, unsigned flags)
 {
 	int inbuf_size;
 	const int INBUF_STEP = 4 * 1024;
@@ -1762,6 +1778,8 @@ void FAST_FUNC tls_run_copy_loop(tls_sta
 				 */
 				pfds[0].fd = -1;
 				tls_free_outbuf(tls); /* mem usage optimization */
+				if (flags & TLSLOOP_EXIT_ON_LOCAL_EOF)
+					break;
 			} else {
 				if (nread == inbuf_size) {
 					/* TLS has per record overhead, if input comes fast,
diff -urpN busybox-1.28.4/networking/udhcp/Config.src busybox-1.29.0/networking/udhcp/Config.src
--- busybox-1.28.4/networking/udhcp/Config.src	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 config UDHCPD
@@ -94,7 +94,7 @@ config FEATURE_UDHCPC_SANITIZEOPT
 config UDHCPC_DEFAULT_SCRIPT
 	string "Absolute path to config script"
 	default "/usr/share/udhcpc/default.script"
-	depends on UDHCPC
+	depends on UDHCPC || UDHCPC6
 	help
 	This script is called after udhcpc receives an answer. See
 	examples/udhcp for a working example. Normally it is safe
diff -urpN busybox-1.28.4/networking/udhcp/common.c busybox-1.29.0/networking/udhcp/common.c
--- busybox-1.28.4/networking/udhcp/common.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/common.c	2018-07-02 15:55:14.000000000 +0200
@@ -378,34 +378,30 @@ int FAST_FUNC udhcp_str2nip(const char *
  * Called to parse "udhcpc -x OPTNAME:OPTVAL"
  * and to parse udhcpd.conf's "opt OPTNAME OPTVAL" directives.
  */
-/* helper for the helper */
-static char *allocate_tempopt_if_needed(
+/* helper: add an option to the opt_list */
+#if !ENABLE_UDHCPC6
+#define attach_option(opt_list, optflag, buffer, length, dhcpv6) \
+	attach_option(opt_list, optflag, buffer, length)
+#endif
+static NOINLINE void attach_option(
+		struct option_set **opt_list,
 		const struct dhcp_optflag *optflag,
 		char *buffer,
-		int *length_p)
+		int length,
+		bool dhcpv6)
 {
+	IF_NOT_UDHCPC6(bool dhcpv6 = 0;)
+	struct option_set *existing;
 	char *allocated = NULL;
+
 	if ((optflag->flags & OPTION_TYPE_MASK) == OPTION_BIN) {
 		const char *end;
 		allocated = xstrdup(buffer); /* more than enough */
 		end = hex2bin(allocated, buffer, 255);
 		if (errno)
 			bb_error_msg_and_die("malformed hex string '%s'", buffer);
-		*length_p = end - allocated;
+		length = end - allocated;
 	}
-	return allocated;
-}
-/* helper: add an option to the opt_list */
-static NOINLINE void attach_option(
-		struct option_set **opt_list,
-		const struct dhcp_optflag *optflag,
-		char *buffer,
-		int length)
-{
-	struct option_set *existing;
-	char *allocated;
-
-	allocated = allocate_tempopt_if_needed(optflag, buffer, &length);
 #if ENABLE_FEATURE_UDHCP_RFC3397
 	if ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {
 		/* reuse buffer and length for RFC1035-formatted string */
@@ -420,10 +416,21 @@ static NOINLINE void attach_option(
 		/* make a new option */
 		log2("attaching option %02x to list", optflag->code);
 		new = xmalloc(sizeof(*new));
-		new->data = xmalloc(length + OPT_DATA);
-		new->data[OPT_CODE] = optflag->code;
-		new->data[OPT_LEN] = length;
-		memcpy(new->data + OPT_DATA, (allocated ? allocated : buffer), length);
+		if (!dhcpv6) {
+			new->data = xmalloc(length + OPT_DATA);
+			new->data[OPT_CODE] = optflag->code;
+			new->data[OPT_LEN] = length;
+			memcpy(new->data + OPT_DATA, (allocated ? allocated : buffer),
+					length);
+		} else {
+			new->data = xmalloc(length + D6_OPT_DATA);
+			new->data[D6_OPT_CODE] = optflag->code >> 8;
+			new->data[D6_OPT_CODE + 1] = optflag->code & 0xff;
+			new->data[D6_OPT_LEN] = length >> 8;
+			new->data[D6_OPT_LEN + 1] = length & 0xff;
+			memcpy(new->data + D6_OPT_DATA, (allocated ? allocated : buffer),
+					length);
+		}
 
 		curr = opt_list;
 		while (*curr && (*curr)->data[OPT_CODE] < optflag->code)
@@ -460,15 +467,17 @@ static NOINLINE void attach_option(
 	free(allocated);
 }
 
-int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg, const struct dhcp_optflag *optflags, const char *option_strings)
+int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg,
+		const struct dhcp_optflag *optflags, const char *option_strings,
+		bool dhcpv6)
 {
 	struct option_set **opt_list = arg;
-	char *opt, *val;
+	char *opt;
 	char *str;
 	const struct dhcp_optflag *optflag;
-	struct dhcp_optflag bin_optflag;
+	struct dhcp_optflag userdef_optflag;
 	unsigned optcode;
-	int retval, length;
+	int retval;
 	/* IP_PAIR needs 8 bytes, STATIC_ROUTES needs 9 max */
 	char buffer[9] ALIGNED(4);
 	uint16_t *result_u16 = (uint16_t *) buffer;
@@ -476,28 +485,41 @@ int FAST_FUNC udhcp_str2optset(const cha
 
 	/* Cheat, the only *const* str possible is "" */
 	str = (char *) const_str;
-	opt = strtok(str, " \t=");
+	opt = strtok(str, " \t=:");
 	if (!opt)
 		return 0;
 
 	optcode = bb_strtou(opt, NULL, 0);
 	if (!errno && optcode < 255) {
-		/* Raw (numeric) option code */
-		bin_optflag.flags = OPTION_BIN;
-		bin_optflag.code = optcode;
-		optflag = &bin_optflag;
+		/* Raw (numeric) option code.
+		 * Initially assume binary (hex-str), but if "str" or 'str'
+		 * is seen later, switch to STRING.
+		 */
+		userdef_optflag.flags = OPTION_BIN;
+		userdef_optflag.code = optcode;
+		optflag = &userdef_optflag;
 	} else {
 		optflag = &optflags[udhcp_option_idx(opt, option_strings)];
 	}
 
+	/* Loop to handle OPTION_LIST case, else execute just once */
 	retval = 0;
 	do {
-		val = strtok(NULL, ", \t");
+		int length;
+		char *val;
+
+		if (optflag->flags == OPTION_BIN) {
+			val = strtok(NULL, ""); /* do not split "'q w e'" */
+			trim(val);
+		} else
+			val = strtok(NULL, ", \t");
 		if (!val)
 			break;
+
 		length = dhcp_option_lengths[optflag->flags & OPTION_TYPE_MASK];
 		retval = 0;
 		opt = buffer; /* new meaning for variable opt */
+
 		switch (optflag->flags & OPTION_TYPE_MASK) {
 		case OPTION_IP:
 			retval = udhcp_str2nip(val, buffer);
@@ -510,6 +532,7 @@ int FAST_FUNC udhcp_str2optset(const cha
 			if (retval)
 				retval = udhcp_str2nip(val, buffer + 4);
 			break;
+case_OPTION_STRING:
 		case OPTION_STRING:
 		case OPTION_STRING_HOST:
 #if ENABLE_FEATURE_UDHCP_RFC3397
@@ -577,14 +600,28 @@ int FAST_FUNC udhcp_str2optset(const cha
 			}
 			break;
 		}
-		case OPTION_BIN: /* handled in attach_option() */
+		case OPTION_BIN:
+			/* Raw (numeric) option code. Is it a string? */
+			if (val[0] == '"' || val[0] == '\'') {
+				char delim = val[0];
+				char *end = last_char_is(val + 1, delim);
+				if (end) {
+					*end = '\0';
+					val++;
+					userdef_optflag.flags = OPTION_STRING;
+					goto case_OPTION_STRING;
+				}
+			}
+			/* No: hex-str option, handled in attach_option() */
 			opt = val;
 			retval = 1;
+			break;
 		default:
 			break;
 		}
+
 		if (retval)
-			attach_option(opt_list, optflag, opt, length);
+			attach_option(opt_list, optflag, opt, length, dhcpv6);
 	} while (retval && (optflag->flags & OPTION_LIST));
 
 	return retval;
diff -urpN busybox-1.28.4/networking/udhcp/common.h busybox-1.29.0/networking/udhcp/common.h
--- busybox-1.28.4/networking/udhcp/common.h	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/common.h	2018-07-02 15:55:14.000000000 +0200
@@ -164,6 +164,10 @@ enum {
 #define OPT_CODE                0
 #define OPT_LEN                 1
 #define OPT_DATA                2
+/* Offsets in option byte sequence for DHCPv6 */
+#define D6_OPT_CODE				0
+#define D6_OPT_LEN				2
+#define D6_OPT_DATA				4
 /* Bits in "overload" option */
 #define OPTION_FIELD            0
 #define FILE_FIELD              1
@@ -290,10 +294,15 @@ void udhcp_dump_packet(struct dhcp_packe
 /* 2nd param is "uint32_t*" */
 int FAST_FUNC udhcp_str2nip(const char *str, void *arg);
 /* 2nd param is "struct option_set**" */
+#if !ENABLE_UDHCPC6
+#define udhcp_str2optset(str, arg, optflags, option_strings, dhcpv6) \
+	udhcp_str2optset(str, arg, optflags, option_strings)
+#endif
 int FAST_FUNC udhcp_str2optset(const char *str,
 		void *arg,
 		const struct dhcp_optflag *optflags,
-		const char *option_strings);
+		const char *option_strings,
+		bool dhcpv6);
 
 #if ENABLE_UDHCPC || ENABLE_UDHCPD
 void udhcp_init_header(struct dhcp_packet *packet, char type) FAST_FUNC;
@@ -308,9 +317,7 @@ int udhcp_send_raw_packet(struct dhcp_pa
 
 int udhcp_send_kernel_packet(struct dhcp_packet *dhcp_pkt,
 		uint32_t source_nip, int source_port,
-		uint32_t dest_nip, int dest_port,
-		int send_flags
-) FAST_FUNC;
+		uint32_t dest_nip, int dest_port) FAST_FUNC;
 
 void udhcp_sp_setup(void) FAST_FUNC;
 void udhcp_sp_fd_set(struct pollfd *pfds, int extra_fd) FAST_FUNC;
diff -urpN busybox-1.28.4/networking/udhcp/d6_common.h busybox-1.29.0/networking/udhcp/d6_common.h
--- busybox-1.28.4/networking/udhcp/d6_common.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/d6_common.h	2018-07-02 15:55:14.000000000 +0200
@@ -128,11 +128,15 @@ struct d6_option {
 #define D6_OPT_TZ_POSIX      41
 #define D6_OPT_TZ_NAME       42
 
+#define D6_OPT_BOOT_URL      59
+#define D6_OPT_BOOT_PARAM    60
+
 /*** Other shared functions ***/
 
 struct client6_data_t {
 	struct d6_option *server_id;
 	struct d6_option *ia_na;
+	struct d6_option *ia_pd;
 	char **env_ptr;
 	unsigned env_idx;
 	/* link-local IPv6 address */
diff -urpN busybox-1.28.4/networking/udhcp/d6_dhcpc.c busybox-1.29.0/networking/udhcp/d6_dhcpc.c
--- busybox-1.28.4/networking/udhcp/d6_dhcpc.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/d6_dhcpc.c	2018-07-02 15:55:14.000000000 +0200
@@ -38,6 +38,14 @@
 //config:	help
 //config:	You can request POSIX timezone with "-O tz" and timezone name
 //config:	with "-O timezone".
+//config:
+//config:config FEATURE_UDHCPC6_RFC5970
+//config:	bool "Support RFC 5970 (Network Boot)"
+//config:	default y
+//config:	depends on UDHCPC6
+//config:	help
+//config:	You can request bootfile-url with "-O bootfile_url" and
+//config:	bootfile-params with "-O bootfile_params".
 
 //applet:IF_UDHCPC6(APPLET(udhcpc6, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -71,6 +79,12 @@ static const struct dhcp_optflag d6_optf
 	{ OPTION_STRING,                                D6_OPT_TZ_POSIX },
 	{ OPTION_STRING,                                D6_OPT_TZ_NAME },
 #endif
+#if ENABLE_FEATURE_UDHCPC6_RFC5970
+	{ OPTION_STRING,                                D6_OPT_BOOT_URL },
+	{ OPTION_STRING,                                D6_OPT_BOOT_PARAM },
+#endif
+	{ OPTION_STRING,                                0xd1 }, /* DHCP_PXE_CONF_FILE */
+	{ OPTION_STRING,                                0xd2 }, /* DHCP_PXE_PATH_PREFIX */
 	{ 0, 0 }
 };
 /* Must match d6_optflags[] order */
@@ -86,6 +100,12 @@ static const char d6_option_strings[] AL
 	"tz" "\0"       /* D6_OPT_TZ_POSIX */
 	"timezone" "\0" /* D6_OPT_TZ_NAME */
 #endif
+#if ENABLE_FEATURE_UDHCPC6_RFC5970
+	"bootfile_url" "\0" /* D6_OPT_BOOT_URL */
+	"bootfile_param" "\0" /* D6_OPT_BOOT_PARAM */
+#endif
+	"pxeconffile" "\0" /* DHCP_PXE_CONF_FILE  */
+	"pxepathprefix" "\0" /* DHCP_PXE_PATH_PREFIX  */
 	"\0";
 
 #if ENABLE_LONG_OPTS
@@ -96,6 +116,7 @@ static const char udhcpc6_longopts[] ALI
 	"quit\0"           No_argument       "q"
 	"release\0"        No_argument       "R"
 	"request\0"        Required_argument "r"
+	"requestprefix\0"  No_argument       "d"
 	"script\0"         Required_argument "s"
 	"timeout\0"        Required_argument "T"
 	"retries\0"        Required_argument "t"
@@ -128,8 +149,9 @@ enum {
 	OPT_o = 1 << 12,
 	OPT_x = 1 << 13,
 	OPT_f = 1 << 14,
+	OPT_d = 1 << 15,
 /* The rest has variable bit positions, need to be clever */
-	OPTBIT_f = 14,
+	OPTBIT_d = 15,
 	USE_FOR_MMU(             OPTBIT_b,)
 	///IF_FEATURE_UDHCPC_ARPING(OPTBIT_a,)
 	IF_FEATURE_UDHCP_PORT(   OPTBIT_P,)
@@ -193,8 +215,37 @@ static char** new_env(void)
 	return &client6_data.env_ptr[client6_data.env_idx++];
 }
 
+static char *string_option_to_env(const uint8_t *option,
+		const uint8_t *option_end)
+{
+	const char *ptr, *name = NULL;
+	unsigned val_len;
+	int i;
+
+	ptr = d6_option_strings;
+	i = 0;
+	while (*ptr) {
+		if (d6_optflags[i].code == option[1]) {
+			name = ptr;
+			goto found;
+		}
+		ptr += strlen(ptr) + 1;
+		i++;
+	}
+	bb_error_msg("can't find option name for 0x%x, skipping", option[1]);
+	return NULL;
+
+ found:
+	val_len = (option[2] << 8) | option[3];
+	if (val_len + &option[D6_OPT_DATA] > option_end) {
+		bb_error_msg("option data exceeds option length");
+		return NULL;
+	}
+	return xasprintf("%s=%.*s", name, val_len, (char*)option + 4);
+}
+
 /* put all the parameters into the environment */
-static void option_to_env(uint8_t *option, uint8_t *option_end)
+static void option_to_env(const uint8_t *option, const uint8_t *option_end)
 {
 #if ENABLE_FEATURE_UDHCPC6_RFC3646
 	int addrs, option_offset;
@@ -237,6 +288,10 @@ static void option_to_env(uint8_t *optio
  * |                        valid-lifetime                         |
  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  */
+			/* Make sure payload contains an address */
+			if (option[3] < 24)
+				break;
+
 			sprint_nip6(ipv6str, option + 4);
 			*new_env() = xasprintf("ipv6=%s", ipv6str);
 
@@ -352,13 +407,23 @@ static void option_to_env(uint8_t *optio
 			*new_env() = xasprintf("tz_name=%.*s", (int)option[3], (char*)option + 4);
 			break;
 #endif
+		case D6_OPT_BOOT_URL:
+		case D6_OPT_BOOT_PARAM:
+		case 0xd1: /* DHCP_PXE_CONF_FILE */
+		case 0xd2: /* DHCP_PXE_PATH_PREFIX */
+			{
+			char *tmp = string_option_to_env(option, option_end);
+			if (tmp)
+				*new_env() = tmp;
+			break;
+			}
 		}
 		len_m4 -= 4 + option[3];
 		option += 4 + option[3];
 	}
 }
 
-static char **fill_envp(struct d6_packet *packet)
+static char **fill_envp(const uint8_t *option, const uint8_t *option_end)
 {
 	char **envp, **curr;
 
@@ -367,8 +432,8 @@ static char **fill_envp(struct d6_packet
 
 	*new_env() = xasprintf("interface=%s", client_config.interface);
 
-	if (packet)
-		option_to_env(packet->d6_options, packet->d6_options + sizeof(packet->d6_options));
+	if (option)
+		option_to_env(option, option_end);
 
 	envp = curr = client6_data.env_ptr;
 	while (*curr)
@@ -378,12 +443,13 @@ static char **fill_envp(struct d6_packet
 }
 
 /* Call a script with a par file and env vars */
-static void d6_run_script(struct d6_packet *packet, const char *name)
+static void d6_run_script(const uint8_t *option, const uint8_t *option_end,
+		const char *name)
 {
 	char **envp, **curr;
 	char *argv[3];
 
-	envp = fill_envp(packet);
+	envp = fill_envp(option, option_end);
 
 	/* call script */
 	log1("executing %s %s", client_config.script, name);
@@ -399,6 +465,11 @@ static void d6_run_script(struct d6_pack
 	free(envp);
 }
 
+/* Call a script with a par file and no env var */
+static void d6_run_script_no_option(const char *name)
+{
+	d6_run_script(NULL, NULL, name);
+}
 
 /*** Sending/receiving packets ***/
 
@@ -424,8 +495,10 @@ static uint8_t *init_d6_packet(struct d6
 
 static uint8_t *add_d6_client_options(uint8_t *ptr)
 {
+	struct option_set *curr;
 	uint8_t *start = ptr;
 	unsigned option;
+	uint16_t len;
 
 	ptr += 4;
 	for (option = 1; option < 256; option++) {
@@ -448,7 +521,12 @@ static uint8_t *add_d6_client_options(ui
 	ptr = mempcpy(ptr, &opt_fqdn_req, sizeof(opt_fqdn_req));
 #endif
 	/* Add -x options if any */
-	//...
+	curr = client_config.options;
+	while (curr) {
+		len = (curr->data[D6_OPT_LEN] << 8) | curr->data[D6_OPT_LEN + 1];
+		ptr = mempcpy(ptr, curr->data, D6_OPT_DATA + len);
+		curr = curr->next;
+	}
 
 	return ptr;
 }
@@ -561,18 +639,33 @@ static NOINLINE int send_d6_discover(uin
 
 	/* Create new IA_NA, optionally with included IAADDR with requested IP */
 	free(client6_data.ia_na);
-	len = requested_ipv6 ? 2+2+4+4+4 + 2+2+16+4+4 : 2+2+4+4+4;
-	client6_data.ia_na = xzalloc(len);
-	client6_data.ia_na->code = D6_OPT_IA_NA;
-	client6_data.ia_na->len = len - 4;
-	*(uint32_t*)client6_data.ia_na->data = rand(); /* IAID */
-	if (requested_ipv6) {
-		struct d6_option *iaaddr = (void*)(client6_data.ia_na->data + 4+4+4);
-		iaaddr->code = D6_OPT_IAADDR;
-		iaaddr->len = 16+4+4;
-		memcpy(iaaddr->data, requested_ipv6, 16);
+	client6_data.ia_na = NULL;
+	if (option_mask32 & OPT_r) {
+		len = requested_ipv6 ? 2+2+4+4+4 + 2+2+16+4+4 : 2+2+4+4+4;
+		client6_data.ia_na = xzalloc(len);
+		client6_data.ia_na->code = D6_OPT_IA_NA;
+		client6_data.ia_na->len = len - 4;
+		*(uint32_t*)client6_data.ia_na->data = rand(); /* IAID */
+		if (requested_ipv6) {
+			struct d6_option *iaaddr = (void*)(client6_data.ia_na->data + 4+4+4);
+			iaaddr->code = D6_OPT_IAADDR;
+			iaaddr->len = 16+4+4;
+			memcpy(iaaddr->data, requested_ipv6, 16);
+		}
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, len);
+	}
+
+	/* IA_PD */
+	free(client6_data.ia_pd);
+	client6_data.ia_pd = NULL;
+	if (option_mask32 & OPT_d) {
+		len = 2+2+4+4+4;
+		client6_data.ia_pd = xzalloc(len);
+		client6_data.ia_pd->code = D6_OPT_IA_PD;
+		client6_data.ia_pd->len = len - 4;
+		*(uint32_t*)client6_data.ia_pd->data = rand(); /* IAID */
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, len);
 	}
-	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, len);
 
 	/* Add options:
 	 * "param req" option according to -O, options specified with -x
@@ -625,7 +718,11 @@ static NOINLINE int send_d6_select(uint3
 	/* server id */
 	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains requested IP) */
-	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	if (client6_data.ia_na)
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	/* IA PD */
+	if (client6_data.ia_pd)
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, client6_data.ia_pd->len + 2+2);
 
 	/* Add options:
 	 * "param req" option according to -O, options specified with -x
@@ -694,7 +791,11 @@ static NOINLINE int send_d6_renew(uint32
 	/* server id */
 	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains requested IP) */
-	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	if (client6_data.ia_na)
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	/* IA PD */
+	if (client6_data.ia_pd)
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, client6_data.ia_pd->len + 2+2);
 
 	/* Add options:
 	 * "param req" option according to -O, options specified with -x
@@ -702,15 +803,13 @@ static NOINLINE int send_d6_renew(uint32
 	opt_ptr = add_d6_client_options(opt_ptr);
 
 	bb_error_msg("sending %s", "renew");
-	if (server_ipv6) {
+	if (server_ipv6)
 		return d6_send_kernel_packet(
 			&packet, (opt_ptr - (uint8_t*) &packet),
 			our_cur_ipv6, CLIENT_PORT6,
 			server_ipv6, SERVER_PORT6,
 			client_config.ifindex
-			/* TODO? send_flags: MSG_DONTROUTE (see IPv4 code for reason why) */
 		);
-	}
 	return d6_mcast_from_client_config_ifindex(&packet, opt_ptr);
 }
 
@@ -725,7 +824,11 @@ static int send_d6_release(struct in6_ad
 	/* server id */
 	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains our current IP) */
-	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	if (client6_data.ia_na)
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	/* IA PD */
+	if (client6_data.ia_pd)
+		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, client6_data.ia_pd->len + 2+2);
 
 	bb_error_msg("sending %s", "release");
 	return d6_send_kernel_packet(
@@ -940,7 +1043,7 @@ static void perform_renew(void)
 		state = RENEW_REQUESTED;
 		break;
 	case RENEW_REQUESTED: /* impatient are we? fine, square 1 */
-		d6_run_script(NULL, "deconfig");
+		d6_run_script_no_option("deconfig");
 	case REQUESTING:
 	case RELEASED:
 		change_listen_mode(LISTEN_RAW);
@@ -969,7 +1072,7 @@ static void perform_d6_release(struct in
  * Users requested to be notified in all cases, even if not in one
  * of the states above.
  */
-	d6_run_script(NULL, "deconfig");
+	d6_run_script_no_option("deconfig");
 	change_listen_mode(LISTEN_NONE);
 	state = RELEASED;
 }
@@ -1001,44 +1104,9 @@ static void client_background(void)
 //usage:# define IF_UDHCP_VERBOSE(...)
 //usage:#endif
 //usage:#define udhcpc6_trivial_usage
-//usage:       "[-fbnq"IF_UDHCP_VERBOSE("v")"oR] [-i IFACE] [-r IP] [-s PROG] [-p PIDFILE]\n"
+//usage:       "[-fbnq"IF_UDHCP_VERBOSE("v")"odR] [-i IFACE] [-r IPv6] [-s PROG] [-p PIDFILE]\n"
 //usage:       "	[-x OPT:VAL]... [-O OPT]..." IF_FEATURE_UDHCP_PORT(" [-P N]")
 //usage:#define udhcpc6_full_usage "\n"
-//usage:	IF_LONG_OPTS(
-//usage:     "\n	-i,--interface IFACE	Interface to use (default eth0)"
-//usage:     "\n	-p,--pidfile FILE	Create pidfile"
-//usage:     "\n	-s,--script PROG	Run PROG at DHCP events (default "CONFIG_UDHCPC_DEFAULT_SCRIPT")"
-//usage:     "\n	-B,--broadcast		Request broadcast replies"
-//usage:     "\n	-t,--retries N		Send up to N discover packets"
-//usage:     "\n	-T,--timeout N		Pause between packets (default 3 seconds)"
-//usage:     "\n	-A,--tryagain N		Wait N seconds after failure (default 20)"
-//usage:     "\n	-f,--foreground		Run in foreground"
-//usage:	USE_FOR_MMU(
-//usage:     "\n	-b,--background		Background if lease is not obtained"
-//usage:	)
-//usage:     "\n	-n,--now		Exit if lease is not obtained"
-//usage:     "\n	-q,--quit		Exit after obtaining lease"
-//usage:     "\n	-R,--release		Release IP on exit"
-//usage:     "\n	-S,--syslog		Log to syslog too"
-//usage:	IF_FEATURE_UDHCP_PORT(
-//usage:     "\n	-P,--client-port N	Use port N (default 546)"
-//usage:	)
-////usage:	IF_FEATURE_UDHCPC_ARPING(
-////usage:     "\n	-a,--arping		Use arping to validate offered address"
-////usage:	)
-//usage:     "\n	-O,--request-option OPT	Request option OPT from server (cumulative)"
-//usage:     "\n	-o,--no-default-options	Don't request any options (unless -O is given)"
-//usage:     "\n	-r,--request IP		Request this IP address"
-//usage:     "\n	-x OPT:VAL		Include option OPT in sent packets (cumulative)"
-//usage:     "\n				Examples of string, numeric, and hex byte opts:"
-//usage:     "\n				-x hostname:bbox - option 12"
-//usage:     "\n				-x lease:3600 - option 51 (lease time)"
-//usage:     "\n				-x 0x3d:0100BEEFC0FFEE - option 61 (client id)"
-//usage:	IF_UDHCP_VERBOSE(
-//usage:     "\n	-v			Verbose"
-//usage:	)
-//usage:	)
-//usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-i IFACE	Interface to use (default eth0)"
 //usage:     "\n	-p FILE		Create pidfile"
 //usage:     "\n	-s PROG		Run PROG at DHCP events (default "CONFIG_UDHCPC_DEFAULT_SCRIPT")"
@@ -1062,16 +1130,17 @@ static void client_background(void)
 ////usage:	)
 //usage:     "\n	-O OPT		Request option OPT from server (cumulative)"
 //usage:     "\n	-o		Don't request any options (unless -O is given)"
-//usage:     "\n	-r IP		Request this IP address"
+//usage:     "\n	-r IPv6		Request this address ('no' to not request any IP)"
+//usage:     "\n	-d		Request prefix"
 //usage:     "\n	-x OPT:VAL	Include option OPT in sent packets (cumulative)"
 //usage:     "\n			Examples of string, numeric, and hex byte opts:"
 //usage:     "\n			-x hostname:bbox - option 12"
 //usage:     "\n			-x lease:3600 - option 51 (lease time)"
 //usage:     "\n			-x 0x3d:0100BEEFC0FFEE - option 61 (client id)"
+//usage:     "\n			-x 14:'\"dumpfile\"' - option 14 (shell-quoted)"
 //usage:	IF_UDHCP_VERBOSE(
 //usage:     "\n	-v		Verbose"
 //usage:	)
-//usage:	)
 //usage:     "\nSignals:"
 //usage:     "\n	USR1	Renew lease"
 //usage:     "\n	USR2	Release lease"
@@ -1099,6 +1168,8 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	int retval;
 
 	setup_common_bufsiz();
+	/* We want random_xid to be random */
+	srand(monotonic_us());
 
 	/* Default options */
 	IF_FEATURE_UDHCP_PORT(SERVER_PORT6 = 547;)
@@ -1109,7 +1180,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	/* Parse command line */
 	opt = getopt32long(argv, "^"
 		/* O,x: list; -T,-t,-A take numeric param */
-		"i:np:qRr:s:T:+t:+SA:+O:*ox:*f"
+		"i:np:qRr:s:T:+t:+SA:+O:*ox:*fd"
 		USE_FOR_MMU("b")
 		///IF_FEATURE_UDHCPC_ARPING("a")
 		IF_FEATURE_UDHCP_PORT("P:")
@@ -1125,10 +1196,15 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		IF_UDHCP_VERBOSE(, &dhcp_verbose)
 	);
 	requested_ipv6 = NULL;
+	option_mask32 |= OPT_r;
 	if (opt & OPT_r) {
-		if (inet_pton(AF_INET6, str_r, &ipv6_buf) <= 0)
-			bb_error_msg_and_die("bad IPv6 address '%s'", str_r);
-		requested_ipv6 = &ipv6_buf;
+		if (strcmp(str_r, "no") == 0) {
+			option_mask32 -= OPT_r;
+		} else {
+			if (inet_pton(AF_INET6, str_r, &ipv6_buf) <= 0)
+				bb_error_msg_and_die("bad IPv6 address '%s'", str_r);
+			requested_ipv6 = &ipv6_buf;
+		}
 	}
 #if ENABLE_FEATURE_UDHCP_PORT
 	if (opt & OPT_P) {
@@ -1154,15 +1230,12 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		}
 	}
 	while (list_x) {
-		char *optstr = llist_pop(&list_x);
-		char *colon = strchr(optstr, ':');
-		if (colon)
-			*colon = ' ';
-		/* now it looks similar to udhcpd's config file line:
-		 * "optname optval", using the common routine: */
-		udhcp_str2optset(optstr, &client_config.options, d6_optflags, d6_option_strings);
-		if (colon)
-			*colon = ':'; /* restore it for NOMMU reexec */
+		char *optstr = xstrdup(llist_pop(&list_x));
+		udhcp_str2optset(optstr, &client_config.options,
+				d6_optflags, d6_option_strings,
+				/*dhcpv6:*/ 1
+		);
+		free(optstr);
 	}
 
 	if (d6_read_interface(client_config.interface,
@@ -1200,19 +1273,15 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 
 	/* Make sure fd 0,1,2 are open */
 	bb_sanitize_stdio();
-	/* Equivalent of doing a fflush after every \n */
-	setlinebuf(stdout);
 	/* Create pidfile */
 	write_pidfile(client_config.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
 	bb_error_msg("started, v"BB_VER);
 	/* Set up the signal pipe */
 	udhcp_sp_setup();
-	/* We want random_xid to be random... */
-	srand(monotonic_us());
 
 	state = INIT_SELECTING;
-	d6_run_script(NULL, "deconfig");
+	d6_run_script_no_option("deconfig");
 	change_listen_mode(LISTEN_RAW);
 	packet_num = 0;
 	timeout = 0;
@@ -1293,7 +1362,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					continue;
 				}
  leasefail:
-				d6_run_script(NULL, "leasefail");
+				d6_run_script_no_option("leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
 					bb_error_msg("no lease, forking to background");
@@ -1367,7 +1436,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				}
 				/* Timed out, enter init state */
 				bb_error_msg("lease lost, entering init state");
-				d6_run_script(NULL, "deconfig");
+				d6_run_script_no_option("deconfig");
 				state = INIT_SELECTING;
 				client_config.first_secs = 0; /* make secs field count from 0 */
 				/*timeout = 0; - already is */
@@ -1464,15 +1533,20 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		case REBINDING:
 			if (packet.d6_msg_type == D6_MSG_REPLY) {
 				uint32_t lease_seconds;
-				struct d6_option *option, *iaaddr;
+				struct d6_option *option;
+				unsigned address_timeout;
+				unsigned prefix_timeout;
  type_is_ok:
+				address_timeout = 0;
+				prefix_timeout = 0;
 				option = d6_find_option(packet.d6_options, packet_end, D6_OPT_STATUS_CODE);
 				if (option && (option->data[0] | option->data[1]) != 0) {
 					/* return to init state */
 					bb_error_msg("received DHCP NAK (%u)", option->data[4]);
-					d6_run_script(&packet, "nak");
+					d6_run_script(packet.d6_options,
+							packet_end, "nak");
 					if (state != REQUESTING)
-						d6_run_script(NULL, "deconfig");
+						d6_run_script_no_option("deconfig");
 					change_listen_mode(LISTEN_RAW);
 					sleep(3); /* avoid excessive network traffic */
 					state = INIT_SELECTING;
@@ -1588,45 +1662,89 @@ int udhcpc6_main(int argc UNUSED_PARAM,
  * .                                                               .
  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  */
-				free(client6_data.ia_na);
-				client6_data.ia_na = d6_copy_option(packet.d6_options, packet_end, D6_OPT_IA_NA);
-				if (!client6_data.ia_na) {
-					bb_error_msg("no %s option, ignoring packet", "IA_NA");
-					continue;
-				}
-				if (client6_data.ia_na->len < (4 + 4 + 4) + (2 + 2 + 16 + 4 + 4)) {
-					bb_error_msg("IA_NA option is too short:%d bytes", client6_data.ia_na->len);
-					continue;
-				}
-				iaaddr = d6_find_option(client6_data.ia_na->data + 4 + 4 + 4,
-						client6_data.ia_na->data + client6_data.ia_na->len,
-						D6_OPT_IAADDR
-				);
-				if (!iaaddr) {
-					bb_error_msg("no %s option, ignoring packet", "IAADDR");
-					continue;
+				if (option_mask32 & OPT_r) {
+					struct d6_option *iaaddr;
+
+					free(client6_data.ia_na);
+					client6_data.ia_na = d6_copy_option(packet.d6_options, packet_end, D6_OPT_IA_NA);
+					if (!client6_data.ia_na) {
+						bb_error_msg("no %s option, ignoring packet", "IA_NA");
+						continue;
+					}
+					if (client6_data.ia_na->len < (4 + 4 + 4) + (2 + 2 + 16 + 4 + 4)) {
+						bb_error_msg("%s option is too short:%d bytes",
+							"IA_NA", client6_data.ia_na->len);
+						continue;
+					}
+					iaaddr = d6_find_option(client6_data.ia_na->data + 4 + 4 + 4,
+							client6_data.ia_na->data + client6_data.ia_na->len,
+							D6_OPT_IAADDR
+					);
+					if (!iaaddr) {
+						bb_error_msg("no %s option, ignoring packet", "IAADDR");
+						continue;
+					}
+					if (iaaddr->len < (16 + 4 + 4)) {
+						bb_error_msg("%s option is too short:%d bytes",
+							"IAADDR", iaaddr->len);
+						continue;
+					}
+					/* Note: the address is sufficiently aligned for cast:
+					 * we _copied_ IA-NA, and copy is always well-aligned.
+					 */
+					requested_ipv6 = (struct in6_addr*) iaaddr->data;
+					move_from_unaligned32(lease_seconds, iaaddr->data + 16 + 4);
+					lease_seconds = ntohl(lease_seconds);
+/// TODO: check for 0 lease time?
+					bb_error_msg("%s obtained, lease time %u",
+						"IPv6", /*inet_ntoa(temp_addr),*/ (unsigned)lease_seconds);
+					address_timeout = lease_seconds;
 				}
-				if (iaaddr->len < (16 + 4 + 4)) {
-					bb_error_msg("IAADDR option is too short:%d bytes", iaaddr->len);
-					continue;
+				if (option_mask32 & OPT_d) {
+					struct d6_option *iaprefix;
+
+					free(client6_data.ia_pd);
+					client6_data.ia_pd = d6_copy_option(packet.d6_options, packet_end, D6_OPT_IA_PD);
+					if (!client6_data.ia_pd) {
+						bb_error_msg("no %s option, ignoring packet", "IA_PD");
+						continue;
+					}
+					if (client6_data.ia_pd->len < (4 + 4 + 4) + (2 + 2 + 4 + 4 + 1 + 16)) {
+						bb_error_msg("%s option is too short:%d bytes",
+							"IA_PD", client6_data.ia_pd->len);
+						continue;
+					}
+					iaprefix = d6_find_option(client6_data.ia_pd->data + 4 + 4 + 4,
+							client6_data.ia_pd->data + client6_data.ia_pd->len,
+							D6_OPT_IAPREFIX
+					);
+					if (!iaprefix) {
+						bb_error_msg("no %s option, ignoring packet", "IAPREFIX");
+						continue;
+					}
+					if (iaprefix->len < (4 + 4 + 1 + 16)) {
+						bb_error_msg("%s option is too short:%d bytes",
+							"IAPREFIX", iaprefix->len);
+						continue;
+					}
+					move_from_unaligned32(lease_seconds, iaprefix->data + 4);
+					lease_seconds = ntohl(lease_seconds);
+					bb_error_msg("%s obtained, lease time %u",
+						"prefix", /*inet_ntoa(temp_addr),*/ (unsigned)lease_seconds);
+					prefix_timeout = lease_seconds;
 				}
-				/* Note: the address is sufficiently aligned for cast:
-				 * we _copied_ IA-NA, and copy is always well-aligned.
-				 */
-				requested_ipv6 = (struct in6_addr*) iaaddr->data;
-				move_from_unaligned32(lease_seconds, iaaddr->data + 16 + 4);
-				lease_seconds = ntohl(lease_seconds);
-				/* paranoia: must not be too small and not prone to overflows */
-				if (lease_seconds < 0x10)
-					lease_seconds = 0x10;
-/// TODO: check for 0 lease time?
-				if (lease_seconds > 0x7fffffff / 1000)
-					lease_seconds = 0x7fffffff / 1000;
+				if (!address_timeout)
+					address_timeout = prefix_timeout;
+				if (!prefix_timeout)
+					prefix_timeout = address_timeout;
+				/* note: "int timeout" will not overflow even with 0xffffffff inputs here: */
+				timeout = (prefix_timeout < address_timeout ? prefix_timeout : address_timeout) / 2;
+				/* paranoia: must not be too small */
+				if (timeout < 0x10)
+					timeout = 0x10;
 				/* enter bound state */
-				timeout = lease_seconds / 2;
-				bb_error_msg("lease obtained, lease time %u",
-					/*inet_ntoa(temp_addr),*/ (unsigned)lease_seconds);
-				d6_run_script(&packet, state == REQUESTING ? "bound" : "renew");
+				d6_run_script(packet.d6_options, packet_end,
+					(state == REQUESTING ? "bound" : "renew"));
 
 				state = BOUND;
 				change_listen_mode(LISTEN_NONE);
diff -urpN busybox-1.28.4/networking/udhcp/d6_socket.c busybox-1.29.0/networking/udhcp/d6_socket.c
--- busybox-1.28.4/networking/udhcp/d6_socket.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/d6_socket.c	2018-07-02 15:55:14.000000000 +0200
@@ -16,7 +16,6 @@ int FAST_FUNC d6_read_interface(const ch
 	struct ifaddrs *ifap, *ifa;
 
 	getifaddrs(&ifap);
-
 	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
 		struct sockaddr_in6 *sip6;
 
@@ -29,9 +28,9 @@ int FAST_FUNC d6_read_interface(const ch
 			struct sockaddr_ll *sll = (struct sockaddr_ll*)(ifa->ifa_addr);
 			memcpy(mac, sll->sll_addr, 6);
 			log2("MAC %02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
-			log2("ifindex %d", sll->sll_ifindex);
 			*ifindex = sll->sll_ifindex;
-			retval &= (0xf - (1<<0));
+			log2("ifindex %d", *ifindex);
+			retval &= (3 - (1<<0));
 		}
 #if 0
 		if (ifa->ifa_addr->sa_family == AF_INET) {
@@ -54,11 +53,33 @@ int FAST_FUNC d6_read_interface(const ch
 				nip6->s6_addr[12], nip6->s6_addr[13],
 				nip6->s6_addr[14], nip6->s6_addr[15]
 			);
-			retval &= (0xf - (1<<1));
+			retval &= (3 - (1<<1));
 		}
 	}
-
 	freeifaddrs(ifap);
+
+	if (retval & (1<<0)) {
+		/* This iface has no MAC (e.g. ppp), generate a random one */
+		struct ifreq ifr;
+		int fd;
+
+		/*memset(&ifr, 0, sizeof(ifr)); - SIOCGIFINDEX does not need to clear all */
+		strncpy_IFNAMSIZ(ifr.ifr_name, interface);
+		fd = xsocket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
+		if (ioctl(fd, SIOCGIFINDEX, &ifr) == 0) {
+			*ifindex = ifr.ifr_ifindex;
+			log2("ifindex %d", *ifindex);
+			if (((uint32_t*)mac)[0] == 0) {
+				/* invent a fictitious MAC (once) */
+				((uint32_t*)mac)[0] = rand();
+				((uint16_t*)mac)[2] = rand();
+				mac[0] &= 0xfc; /* make sure it's not bcast */
+			}
+			retval &= (3 - (1<<0));
+		}
+		close(fd);
+	}
+
 	if (retval == 0)
 		return retval;
 
diff -urpN busybox-1.28.4/networking/udhcp/dhcpc.c busybox-1.29.0/networking/udhcp/dhcpc.c
--- busybox-1.28.4/networking/udhcp/dhcpc.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/dhcpc.c	2018-07-02 15:55:14.000000000 +0200
@@ -693,16 +693,10 @@ static int raw_bcast_from_client_config_
 
 static int bcast_or_ucast(struct dhcp_packet *packet, uint32_t ciaddr, uint32_t server)
 {
-	if (server) {
-		/* Without MSG_DONTROUTE, the packet was seen routed over
-		 * _other interface_ if server ID is bogus (example: 1.1.1.1).
-		 */
+	if (server)
 		return udhcp_send_kernel_packet(packet,
 			ciaddr, CLIENT_PORT,
-			server, SERVER_PORT,
-			/*send_flags: "to hosts only on directly connected networks" */ MSG_DONTROUTE
-		);
-	}
+			server, SERVER_PORT);
 	return raw_bcast_from_client_config_ifindex(packet, ciaddr);
 }
 
@@ -1224,6 +1218,7 @@ static void client_background(void)
 //usage:     "\n			-x hostname:bbox - option 12"
 //usage:     "\n			-x lease:3600 - option 51 (lease time)"
 //usage:     "\n			-x 0x3d:0100BEEFC0FFEE - option 61 (client id)"
+//usage:     "\n			-x 14:'\"dumpfile\"' - option 14 (shell-quoted)"
 //usage:     "\n	-F NAME		Ask server to update DNS mapping for NAME"
 //usage:     "\n	-V VENDOR	Vendor identifier (default 'udhcp VERSION')"
 //usage:     "\n	-C		Don't send MAC as client identifier"
@@ -1335,15 +1330,12 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		}
 	}
 	while (list_x) {
-		char *optstr = llist_pop(&list_x);
-		char *colon = strchr(optstr, ':');
-		if (colon)
-			*colon = ' ';
-		/* now it looks similar to udhcpd's config file line:
-		 * "optname optval", using the common routine: */
-		udhcp_str2optset(optstr, &client_config.options, dhcp_optflags, dhcp_option_strings);
-		if (colon)
-			*colon = ':'; /* restore it for NOMMU reexec */
+		char *optstr = xstrdup(llist_pop(&list_x));
+		udhcp_str2optset(optstr, &client_config.options,
+				dhcp_optflags, dhcp_option_strings,
+				/*dhcpv6:*/ 0
+		);
+		free(optstr);
 	}
 
 	if (udhcp_read_interface(client_config.interface,
@@ -1386,8 +1378,6 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 
 	/* Make sure fd 0,1,2 are open */
 	bb_sanitize_stdio();
-	/* Equivalent of doing a fflush after every \n */
-	setlinebuf(stdout);
 	/* Create pidfile */
 	write_pidfile(client_config.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
@@ -1731,8 +1721,10 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					/* paranoia: must not be too small and not prone to overflows */
 					if (lease_seconds < 0x10)
 						lease_seconds = 0x10;
-					if (lease_seconds > 0x7fffffff / 1000)
-						lease_seconds = 0x7fffffff / 1000;
+					//if (lease_seconds > 0x7fffffff)
+					//	lease_seconds = 0x7fffffff;
+					//^^^not necessary since "timeout = lease_seconds / 2"
+					//does not overflow even for 0xffffffff.
 				}
 #if ENABLE_FEATURE_UDHCPC_ARPING
 				if (opt & OPT_a) {
diff -urpN busybox-1.28.4/networking/udhcp/dhcpd.c busybox-1.29.0/networking/udhcp/dhcpd.c
--- busybox-1.28.4/networking/udhcp/dhcpd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/dhcpd.c	2018-07-02 15:55:14.000000000 +0200
@@ -45,7 +45,7 @@
 #include "dhcpd.h"
 
 /* globals */
-struct dyn_lease *g_leases;
+#define g_leases ((struct dyn_lease*)ptr_to_globals)
 /* struct server_config_t server_config is in bb_common_bufsiz1 */
 
 /* Takes the address of the pointer to the static_leases linked list,
@@ -362,7 +362,10 @@ static int FAST_FUNC read_staticlease(co
 }
 
 static int FAST_FUNC read_optset(const char *line, void *arg) {
-	return udhcp_str2optset(line, arg, dhcp_optflags, dhcp_option_strings);
+	return udhcp_str2optset(line, arg,
+			dhcp_optflags, dhcp_option_strings,
+			/*dhcpv6:*/ 0
+	);
 }
 
 struct config_keyword {
@@ -588,9 +591,7 @@ static void send_packet_to_relay(struct
 
 	udhcp_send_kernel_packet(dhcp_pkt,
 			server_config.server_nip, SERVER_PORT,
-			dhcp_pkt->gateway_nip, SERVER_PORT,
-			/*send_flags:*/ 0
-	);
+			dhcp_pkt->gateway_nip, SERVER_PORT);
 }
 
 static void send_packet(struct dhcp_packet *dhcp_pkt, int force_broadcast)
@@ -859,8 +860,6 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 
 	/* Make sure fd 0,1,2 are open */
 	bb_sanitize_stdio();
-	/* Equivalent of doing a fflush after every \n */
-	setlinebuf(stdout);
 
 	/* Create pidfile */
 	write_pidfile(server_config.pidfile);
@@ -883,7 +882,9 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 		server_config.max_leases = num_ips;
 	}
 
-	g_leases = xzalloc(server_config.max_leases * sizeof(g_leases[0]));
+	/* this sets g_leases */
+	SET_PTR_TO_GLOBALS(xzalloc(server_config.max_leases * sizeof(g_leases[0])));
+
 	read_leases(server_config.lease_file);
 
 	if (udhcp_read_interface(server_config.interface,
diff -urpN busybox-1.28.4/networking/udhcp/dhcprelay.c busybox-1.29.0/networking/udhcp/dhcprelay.c
--- busybox-1.28.4/networking/udhcp/dhcprelay.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/dhcprelay.c	2018-07-02 15:55:14.000000000 +0200
@@ -254,7 +254,7 @@ static void pass_to_client(struct dhcp_p
 }
 
 int dhcprelay_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int dhcprelay_main(int argc, char **argv)
+int dhcprelay_main(int argc UNUSED_PARAM, char **argv)
 {
 	struct sockaddr_in server_addr;
 	char **iface_list;
@@ -269,11 +269,11 @@ int dhcprelay_main(int argc, char **argv
 	server_addr.sin_port = htons(SERVER_PORT);
 
 	/* dhcprelay CLIENT_IFACE1[,CLIENT_IFACE2...] SERVER_IFACE [SERVER_IP] */
-	if (argc == 4) {
+	if (!argv[1] || !argv[2])
+		bb_show_usage();
+	if (argv[3]) {
 		if (!inet_aton(argv[3], &server_addr.sin_addr))
 			bb_perror_msg_and_die("bad server IP");
-	} else if (argc != 3) {
-		bb_show_usage();
 	}
 
 	iface_list = make_iface_list(argv + 1, &num_sockets);
diff -urpN busybox-1.28.4/networking/udhcp/packet.c busybox-1.29.0/networking/udhcp/packet.c
--- busybox-1.28.4/networking/udhcp/packet.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/networking/udhcp/packet.c	2018-07-02 15:55:14.000000000 +0200
@@ -189,8 +189,7 @@ int FAST_FUNC udhcp_send_raw_packet(stru
 /* Let the kernel do all the work for packet generation */
 int FAST_FUNC udhcp_send_kernel_packet(struct dhcp_packet *dhcp_pkt,
 		uint32_t source_nip, int source_port,
-		uint32_t dest_nip, int dest_port,
-		int send_flags)
+		uint32_t dest_nip, int dest_port)
 {
 	struct sockaddr_in sa;
 	unsigned padding;
@@ -227,8 +226,8 @@ int FAST_FUNC udhcp_send_kernel_packet(s
 	padding = DHCP_OPTIONS_BUFSIZE - 1 - udhcp_end_option(dhcp_pkt->options);
 	if (padding > DHCP_SIZE - 300)
 		padding = DHCP_SIZE - 300;
-	result = send(fd, dhcp_pkt, DHCP_SIZE - padding, send_flags);
-	msg = "send";
+	result = safe_write(fd, dhcp_pkt, DHCP_SIZE - padding);
+	msg = "write";
  ret_close:
 	close(fd);
 	if (result < 0) {
diff -urpN busybox-1.28.4/networking/wget.c busybox-1.29.0/networking/wget.c
--- busybox-1.28.4/networking/wget.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/networking/wget.c	2018-07-02 15:55:14.000000000 +0200
@@ -48,6 +48,7 @@
 //config:
 //config:config FEATURE_WGET_HTTPS
 //config:	bool "Support HTTPS using internal TLS code"
+//it also enables FTPS support, but it's not well tested yet
 //config:	default y
 //config:	depends on WGET
 //config:	select TLS
@@ -136,6 +137,7 @@
 //usage:       "Retrieve files via HTTP or FTP\n"
 //usage:	IF_FEATURE_WGET_LONG_OPTIONS(
 //usage:     "\n	--spider	Only check URL existence: $? is 0 if exists"
+///////:     "\n	--no-check-certificate	Don't validate the server's certificate"
 //usage:	)
 //usage:     "\n	-c		Continue retrieval of aborted transfer"
 //usage:     "\n	-q		Quiet"
@@ -176,6 +178,9 @@ struct host_info {
 static const char P_FTP[] ALIGN1 = "ftp";
 static const char P_HTTP[] ALIGN1 = "http";
 #if SSL_SUPPORTED
+# if ENABLE_FEATURE_WGET_HTTPS
+static const char P_FTPS[] ALIGN1 = "ftps";
+# endif
 static const char P_HTTPS[] ALIGN1 = "https";
 #endif
 
@@ -267,6 +272,7 @@ enum {
 	WGET_OPT_HEADER     = (1 << 10) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
 	WGET_OPT_POST_DATA  = (1 << 11) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
 	WGET_OPT_SPIDER     = (1 << 12) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
+	WGET_OPT_NO_CHECK_CERT = (1 << 13) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
 };
 
 enum {
@@ -348,15 +354,6 @@ static char *base64enc(const char *str)
 }
 #endif
 
-static char* sanitize_string(char *s)
-{
-	unsigned char *p = (void *) s;
-	while (*p >= ' ')
-		p++;
-	*p = '\0';
-	return s;
-}
-
 #if ENABLE_FEATURE_WGET_TIMEOUT
 static void alarm_handler(int sig UNUSED_PARAM)
 {
@@ -414,27 +411,54 @@ static FILE *open_socket(len_and_sockadd
 	/* hopefully it understands what ESPIPE means... */
 	fp = fdopen(fd, "r+");
 	if (!fp)
-		bb_perror_msg_and_die(bb_msg_memory_exhausted);
+		bb_die_memory_exhausted();
 
 	return fp;
 }
 
+/* We balk at any control chars in other side's messages.
+ * This prevents nasty surprises (e.g. ESC sequences) in "Location:" URLs
+ * and error messages.
+ *
+ * The only exception is tabs, which are converted to (one) space:
+ * HTTP's "headers: <whitespace> values" may have those.
+ */
+static char* sanitize_string(char *s)
+{
+	unsigned char *p = (void *) s;
+	while (*p) {
+		if (*p < ' ') {
+			if (*p != '\t')
+				break;
+			*p = ' ';
+		}
+		p++;
+	}
+	*p = '\0';
+	return s;
+}
+
 /* Returns '\n' if it was seen, else '\0'. Trims at first '\r' or '\n' */
-static char fgets_and_trim(FILE *fp, const char *fmt)
+static char fgets_trim_sanitize(FILE *fp, const char *fmt)
 {
 	char c;
 	char *buf_ptr;
 
 	set_alarm();
-	if (fgets(G.wget_buf, sizeof(G.wget_buf) - 1, fp) == NULL)
+	if (fgets(G.wget_buf, sizeof(G.wget_buf), fp) == NULL)
 		bb_perror_msg_and_die("error getting response");
 	clear_alarm();
 
 	buf_ptr = strchrnul(G.wget_buf, '\n');
 	c = *buf_ptr;
+#if 1
+	/* Disallow any control chars: trim at first char < 0x20 */
+	sanitize_string(G.wget_buf);
+#else
 	*buf_ptr = '\0';
 	buf_ptr = strchrnul(G.wget_buf, '\r');
 	*buf_ptr = '\0';
+#endif
 
 	log_io("< %s", G.wget_buf);
 
@@ -458,8 +482,10 @@ static int ftpcmd(const char *s1, const
 		log_io("> %s%s", s1, s2);
 	}
 
+	/* Read until "Nxx something" is received */
+	G.wget_buf[3] = 0;
 	do {
-		fgets_and_trim(fp, "%s\n");
+		fgets_trim_sanitize(fp, "%s\n");
 	} while (!isdigit(G.wget_buf[0]) || G.wget_buf[3] != ' ');
 
 	G.wget_buf[3] = '\0';
@@ -481,21 +507,27 @@ static void parse_url(const char *src_ur
 		*p = '\0';
 		h->host = p + 3;
 		if (strcmp(url, P_FTP) == 0) {
-			h->port = bb_lookup_port(P_FTP, "tcp", 21);
+			h->port = bb_lookup_std_port(P_FTP, "tcp", 21);
 		} else
 #if SSL_SUPPORTED
+# if ENABLE_FEATURE_WGET_HTTPS
+		if (strcmp(url, P_FTPS) == 0) {
+			h->port = bb_lookup_std_port(P_FTPS, "tcp", 990);
+			h->protocol = P_FTPS;
+		} else
+# endif
 		if (strcmp(url, P_HTTPS) == 0) {
-			h->port = bb_lookup_port(P_HTTPS, "tcp", 443);
+			h->port = bb_lookup_std_port(P_HTTPS, "tcp", 443);
 			h->protocol = P_HTTPS;
 		} else
 #endif
 		if (strcmp(url, P_HTTP) == 0) {
  http:
-			h->port = bb_lookup_port(P_HTTP, "tcp", 80);
+			h->port = bb_lookup_std_port(P_HTTP, "tcp", 80);
 			h->protocol = P_HTTP;
 		} else {
 			*p = ':';
-			bb_error_msg_and_die("not an http or ftp url: %s", sanitize_string(url));
+			bb_error_msg_and_die("not an http or ftp url: %s", url);
 		}
 	} else {
 		// GNU wget is user-friendly and falls back to http://
@@ -509,7 +541,7 @@ static void parse_url(const char *src_ur
 	//   and saves 'index.html?var=a%2Fb' (we save 'b')
 	// wget 'http://busybox.net?login=john@doe':
 	//   request: 'GET /?login=john@doe HTTP/1.0'
-	//   saves: 'index.html?login=john@doe' (we save '?login=john@doe')
+	//   saves: 'index.html?login=john@doe' (we save 'login=john@doe')
 	// wget 'http://busybox.net#test/test':
 	//   request: 'GET / HTTP/1.0'
 	//   saves: 'index.html' (we save 'test')
@@ -523,13 +555,13 @@ static void parse_url(const char *src_ur
 	} else if (*sp == '/') {
 		*sp = '\0';
 		h->path = sp + 1;
-	} else { // '#' or '?'
+	} else {
+		// sp points to '#' or '?'
+		// Note:
 		// http://busybox.net?login=john@doe is a valid URL
-		// memmove converts to:
-		// http:/busybox.nett?login=john@doe...
-		memmove(h->host - 1, h->host, sp - h->host);
-		h->host--;
-		sp[-1] = '\0';
+		// (without '/' between ".net" and "?"),
+		// can't store NUL at sp[-1] - this destroys hostname.
+		*sp++ = '\0';
 		h->path = sp;
 	}
 
@@ -550,13 +582,13 @@ static void parse_url(const char *src_ur
 	 */
 }
 
-static char *gethdr(FILE *fp)
+static char *get_sanitized_hdr(FILE *fp)
 {
 	char *s, *hdrval;
 	int c;
 
 	/* retrieve header line */
-	c = fgets_and_trim(fp, "  %s\n");
+	c = fgets_trim_sanitize(fp, "  %s\n");
 
 	/* end of the headers? */
 	if (G.wget_buf[0] == '\0')
@@ -578,7 +610,7 @@ static char *gethdr(FILE *fp)
 
 	/* verify we are at the end of the header name */
 	if (*s != ':')
-		bb_error_msg_and_die("bad header line: %s", sanitize_string(G.wget_buf));
+		bb_error_msg_and_die("bad header line: %s", G.wget_buf);
 
 	/* locate the start of the header value */
 	*s++ = '\0';
@@ -602,87 +634,6 @@ static void reset_beg_range_to_zero(void
 	/* ftruncate(G.output_fd, 0); */
 }
 
-static FILE* prepare_ftp_session(FILE **dfpp, struct host_info *target, len_and_sockaddr *lsa)
-{
-	FILE *sfp;
-	char *str;
-	int port;
-
-	if (!target->user)
-		target->user = xstrdup("anonymous:busybox@");
-
-	sfp = open_socket(lsa);
-	if (ftpcmd(NULL, NULL, sfp) != 220)
-		bb_error_msg_and_die("%s", sanitize_string(G.wget_buf + 4));
-
-	/*
-	 * Splitting username:password pair,
-	 * trying to log in
-	 */
-	str = strchr(target->user, ':');
-	if (str)
-		*str++ = '\0';
-	switch (ftpcmd("USER ", target->user, sfp)) {
-	case 230:
-		break;
-	case 331:
-		if (ftpcmd("PASS ", str, sfp) == 230)
-			break;
-		/* fall through (failed login) */
-	default:
-		bb_error_msg_and_die("ftp login: %s", sanitize_string(G.wget_buf + 4));
-	}
-
-	ftpcmd("TYPE I", NULL, sfp);
-
-	/*
-	 * Querying file size
-	 */
-	if (ftpcmd("SIZE ", target->path, sfp) == 213) {
-		G.content_len = BB_STRTOOFF(G.wget_buf + 4, NULL, 10);
-		if (G.content_len < 0 || errno) {
-			bb_error_msg_and_die("SIZE value is garbage");
-		}
-		G.got_clen = 1;
-	}
-
-	/*
-	 * Entering passive mode
-	 */
-	if (ftpcmd("PASV", NULL, sfp) != 227) {
- pasv_error:
-		bb_error_msg_and_die("bad response to %s: %s", "PASV", sanitize_string(G.wget_buf));
-	}
-	// Response is "227 garbageN1,N2,N3,N4,P1,P2[)garbage]
-	// Server's IP is N1.N2.N3.N4 (we ignore it)
-	// Server's port for data connection is P1*256+P2
-	str = strrchr(G.wget_buf, ')');
-	if (str) str[0] = '\0';
-	str = strrchr(G.wget_buf, ',');
-	if (!str) goto pasv_error;
-	port = xatou_range(str+1, 0, 255);
-	*str = '\0';
-	str = strrchr(G.wget_buf, ',');
-	if (!str) goto pasv_error;
-	port += xatou_range(str+1, 0, 255) * 256;
-	set_nport(&lsa->u.sa, htons(port));
-
-	*dfpp = open_socket(lsa);
-
-	if (G.beg_range != 0) {
-		sprintf(G.wget_buf, "REST %"OFF_FMT"u", G.beg_range);
-		if (ftpcmd(G.wget_buf, NULL, sfp) == 350)
-			G.content_len -= G.beg_range;
-		else
-			reset_beg_range_to_zero();
-	}
-
-	if (ftpcmd("RETR ", target->path, sfp) > 150)
-		bb_error_msg_and_die("bad response to %s: %s", "RETR", sanitize_string(G.wget_buf));
-
-	return sfp;
-}
-
 #if ENABLE_FEATURE_WGET_OPENSSL
 static int spawn_https_helper_openssl(const char *host, unsigned port)
 {
@@ -759,12 +710,15 @@ static int spawn_https_helper_openssl(co
 #endif
 
 #if ENABLE_FEATURE_WGET_HTTPS
-static void spawn_ssl_client(const char *host, int network_fd)
+static void spawn_ssl_client(const char *host, int network_fd, int flags)
 {
 	int sp[2];
 	int pid;
 	char *servername, *p;
 
+	if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT))
+		bb_error_msg("note: TLS certificate validation not implemented");
+
 	servername = xstrdup(host);
 	p = strrchr(servername, ':');
 	if (p) *p = '\0';
@@ -784,17 +738,19 @@ static void spawn_ssl_client(const char
 			tls_state_t *tls = new_tls_state();
 			tls->ifd = tls->ofd = network_fd;
 			tls_handshake(tls, servername);
-			tls_run_copy_loop(tls);
+			tls_run_copy_loop(tls, flags);
 			exit(0);
 		} else {
-			char *argv[5];
+			char *argv[6];
+
 			xmove_fd(network_fd, 3);
 			argv[0] = (char*)"ssl_client";
 			argv[1] = (char*)"-s3";
 			//TODO: if (!is_ip_address(servername))...
 			argv[2] = (char*)"-n";
 			argv[3] = servername;
-			argv[4] = NULL;
+			argv[4] = (flags & TLSLOOP_EXIT_ON_LOCAL_EOF ? (char*)"-e" : NULL);
+			argv[5] = NULL;
 			BB_EXECVP(argv[0], argv);
 			bb_perror_msg_and_die("can't execute '%s'", argv[0]);
 		}
@@ -808,6 +764,96 @@ static void spawn_ssl_client(const char
 }
 #endif
 
+static FILE* prepare_ftp_session(FILE **dfpp, struct host_info *target, len_and_sockaddr *lsa)
+{
+	FILE *sfp;
+	char *pass;
+	int port;
+
+	sfp = open_socket(lsa);
+#if ENABLE_FEATURE_WGET_HTTPS
+	if (target->protocol == P_FTPS)
+		spawn_ssl_client(target->host, fileno(sfp), TLSLOOP_EXIT_ON_LOCAL_EOF);
+#endif
+
+	if (ftpcmd(NULL, NULL, sfp) != 220)
+		bb_error_msg_and_die("%s", G.wget_buf);
+		/* note: ftpcmd() sanitizes G.wget_buf, ok to print */
+
+	/* Split username:password pair */
+	pass = (char*)"busybox"; /* password for "anonymous" */
+	if (target->user) {
+		pass = strchr(target->user, ':');
+		if (pass)
+			*pass++ = '\0';
+	}
+
+	/* Log in */
+	switch (ftpcmd("USER ", target->user ?: "anonymous", sfp)) {
+	case 230:
+		break;
+	case 331:
+		if (ftpcmd("PASS ", pass, sfp) == 230)
+			break;
+		/* fall through (failed login) */
+	default:
+		bb_error_msg_and_die("ftp login: %s", G.wget_buf);
+	}
+
+	ftpcmd("TYPE I", NULL, sfp);
+
+	/* Query file size */
+	if (ftpcmd("SIZE ", target->path, sfp) == 213) {
+		G.content_len = BB_STRTOOFF(G.wget_buf + 4, NULL, 10);
+		if (G.content_len < 0 || errno) {
+			bb_error_msg_and_die("bad SIZE value '%s'", G.wget_buf + 4);
+		}
+		G.got_clen = 1;
+	}
+
+	/* Enter passive mode */
+	if (ENABLE_FEATURE_IPV6 && ftpcmd("EPSV", NULL, sfp) == 229) {
+		/* good */
+	} else
+	if (ftpcmd("PASV", NULL, sfp) != 227) {
+ pasv_error:
+		bb_error_msg_and_die("bad response to %s: %s", "PASV", G.wget_buf);
+	}
+	port = parse_pasv_epsv(G.wget_buf);
+	if (port < 0)
+		goto pasv_error;
+
+	set_nport(&lsa->u.sa, htons(port));
+
+	*dfpp = open_socket(lsa);
+
+#if ENABLE_FEATURE_WGET_HTTPS
+	if (target->protocol == P_FTPS) {
+		/* "PROT P" enables encryption of data stream.
+		 * Without it (or with "PROT C"), data is sent unencrypted.
+		 */
+		if (ftpcmd("PROT P", NULL, sfp) == 200)
+			spawn_ssl_client(target->host, fileno(*dfpp), /*flags*/ 0);
+	}
+#endif
+
+	if (G.beg_range != 0) {
+		sprintf(G.wget_buf, "REST %"OFF_FMT"u", G.beg_range);
+		if (ftpcmd(G.wget_buf, NULL, sfp) == 350)
+			G.content_len -= G.beg_range;
+		else
+			reset_beg_range_to_zero();
+	}
+
+//TODO: needs ftp-escaping 0xff and '\n' bytes here.
+//Or disallow '\n' altogether via sanitize_string() in parse_url().
+//But 0xff's are possible in valid utf8 filenames.
+	if (ftpcmd("RETR ", target->path, sfp) > 150)
+		bb_error_msg_and_die("bad response to %s: %s", "RETR", G.wget_buf);
+
+	return sfp;
+}
+
 static void NOINLINE retrieve_file_data(FILE *dfp)
 {
 #if ENABLE_FEATURE_WGET_STATUSBAR || ENABLE_FEATURE_WGET_TIMEOUT
@@ -924,11 +970,19 @@ static void NOINLINE retrieve_file_data(
 		if (!G.chunked)
 			break;
 
-		fgets_and_trim(dfp, NULL); /* Eat empty line */
+		/* Each chunk ends with "\r\n" - eat it */
+		fgets_trim_sanitize(dfp, NULL);
  get_clen:
-		fgets_and_trim(dfp, NULL);
+		/* chunk size format is "HEXNUM[;name[=val]]\r\n" */
+		fgets_trim_sanitize(dfp, NULL);
+		errno = 0;
 		G.content_len = STRTOOFF(G.wget_buf, NULL, 16);
-		/* FIXME: error check? */
+		/*
+		 * Had a bug with inputs like "ffffffff0001f400"
+		 * smashing the heap later. Ensure >= 0.
+		 */
+		if (G.content_len < 0 || errno)
+			bb_error_msg_and_die("bad chunk length '%s'", G.wget_buf);
 		if (G.content_len == 0)
 			break; /* all done! */
 		G.got_clen = 1;
@@ -965,7 +1019,6 @@ static void download_one_url(const char
 	len_and_sockaddr *lsa;
 	FILE *sfp;                      /* socket to web/ftp server         */
 	FILE *dfp;                      /* socket to ftp server (data)      */
-	char *proxy = NULL;
 	char *fname_out_alloc;
 	char *redirected_path = NULL;
 	struct host_info server;
@@ -981,13 +1034,14 @@ static void download_one_url(const char
 	/* Use the proxy if necessary */
 	use_proxy = (strcmp(G.proxy_flag, "off") != 0);
 	if (use_proxy) {
-		proxy = getenv(target.protocol == P_FTP ? "ftp_proxy" : "http_proxy");
+		char *proxy = getenv(target.protocol[0] == 'f' ? "ftp_proxy" : "http_proxy");
 //FIXME: what if protocol is https? Ok to use http_proxy?
 		use_proxy = (proxy && proxy[0]);
 		if (use_proxy)
 			parse_url(proxy, &server);
 	}
 	if (!use_proxy) {
+		server.protocol = target.protocol;
 		server.port = target.port;
 		if (ENABLE_FEATURE_IPV6) {
 			//free(server.allocated); - can't be non-NULL
@@ -1042,7 +1096,7 @@ static void download_one_url(const char
 	/*G.content_len = 0; - redundant, got_clen = 0 is enough */
 	G.got_clen = 0;
 	G.chunked = 0;
-	if (use_proxy || target.protocol != P_FTP) {
+	if (use_proxy || target.protocol[0] != 'f' /*not ftp[s]*/) {
 		/*
 		 *  HTTP session
 		 */
@@ -1052,7 +1106,7 @@ static void download_one_url(const char
 		/* Open socket to http(s) server */
 #if ENABLE_FEATURE_WGET_OPENSSL
 		/* openssl (and maybe internal TLS) support is configured */
-		if (target.protocol == P_HTTPS) {
+		if (server.protocol == P_HTTPS) {
 			/* openssl-based helper
 			 * Inconvenient API since we can't give it an open fd
 			 */
@@ -1060,7 +1114,7 @@ static void download_one_url(const char
 # if ENABLE_FEATURE_WGET_HTTPS
 			if (fd < 0) { /* no openssl? try internal */
 				sfp = open_socket(lsa);
-				spawn_ssl_client(server.host, fileno(sfp));
+				spawn_ssl_client(server.host, fileno(sfp), /*flags*/ 0);
 				goto socket_opened;
 			}
 # else
@@ -1068,7 +1122,7 @@ static void download_one_url(const char
 # endif
 			sfp = fdopen(fd, "r+");
 			if (!sfp)
-				bb_perror_msg_and_die(bb_msg_memory_exhausted);
+				bb_die_memory_exhausted();
 			goto socket_opened;
 		}
 		sfp = open_socket(lsa);
@@ -1076,8 +1130,8 @@ static void download_one_url(const char
 #elif ENABLE_FEATURE_WGET_HTTPS
 		/* Only internal TLS support is configured */
 		sfp = open_socket(lsa);
-		if (target.protocol == P_HTTPS)
-			spawn_ssl_client(server.host, fileno(sfp));
+		if (server.protocol == P_HTTPS)
+			spawn_ssl_client(server.host, fileno(sfp), /*flags*/ 0);
 #else
 		/* ssl (https) support is not configured */
 		sfp = open_socket(lsa);
@@ -1156,7 +1210,7 @@ static void download_one_url(const char
 		 * Retrieve HTTP response line and check for "200" status code.
 		 */
  read_response:
-		fgets_and_trim(sfp, "  %s\n");
+		fgets_trim_sanitize(sfp, "  %s\n");
 
 		str = G.wget_buf;
 		str = skip_non_whitespace(str);
@@ -1167,7 +1221,7 @@ static void download_one_url(const char
 		switch (status) {
 		case 0:
 		case 100:
-			while (gethdr(sfp) != NULL)
+			while (get_sanitized_hdr(sfp) != NULL)
 				/* eat all remaining headers */;
 			goto read_response;
 
@@ -1231,13 +1285,13 @@ However, in real world it was observed t
 			/* Partial Content even though we did not ask for it??? */
 			/* fall through */
 		default:
-			bb_error_msg_and_die("server returned error: %s", sanitize_string(G.wget_buf));
+			bb_error_msg_and_die("server returned error: %s", G.wget_buf);
 		}
 
 		/*
 		 * Retrieve HTTP headers.
 		 */
-		while ((str = gethdr(sfp)) != NULL) {
+		while ((str = get_sanitized_hdr(sfp)) != NULL) {
 			static const char keywords[] ALIGN1 =
 				"content-length\0""transfer-encoding\0""location\0";
 			enum {
@@ -1245,7 +1299,7 @@ However, in real world it was observed t
 			};
 			smalluint key;
 
-			/* gethdr converted "FOO:" string to lowercase */
+			/* get_sanitized_hdr converted "FOO:" string to lowercase */
 
 			/* strip trailing whitespace */
 			char *s = strchrnul(str, '\0') - 1;
@@ -1257,14 +1311,14 @@ However, in real world it was observed t
 			if (key == KEY_content_length) {
 				G.content_len = BB_STRTOOFF(str, NULL, 10);
 				if (G.content_len < 0 || errno) {
-					bb_error_msg_and_die("content-length %s is garbage", sanitize_string(str));
+					bb_error_msg_and_die("content-length %s is garbage", str);
 				}
 				G.got_clen = 1;
 				continue;
 			}
 			if (key == KEY_transfer_encoding) {
 				if (strcmp(str_tolower(str), "chunked") != 0)
-					bb_error_msg_and_die("transfer encoding '%s' is not supported", sanitize_string(str));
+					bb_error_msg_and_die("transfer encoding '%s' is not supported", str);
 				G.chunked = 1;
 			}
 			if (key == KEY_location && status >= 300) {
@@ -1273,7 +1327,7 @@ However, in real world it was observed t
 				fclose(sfp);
 				if (str[0] == '/') {
 					free(redirected_path);
-					target.path = redirected_path = xstrdup(str+1);
+					target.path = redirected_path = xstrdup(str + 1);
 					/* lsa stays the same: it's on the same server */
 				} else {
 					parse_url(str, &target);
@@ -1320,7 +1374,7 @@ However, in real world it was observed t
 		/* It's ftp. Close data connection properly */
 		fclose(dfp);
 		if (ftpcmd(NULL, NULL, sfp) != 226)
-			bb_error_msg_and_die("ftp error: %s", sanitize_string(G.wget_buf + 4));
+			bb_error_msg_and_die("ftp error: %s", G.wget_buf);
 		/* ftpcmd("QUIT", NULL, sfp); - why bother? */
 	}
 	fclose(sfp);
@@ -1353,10 +1407,9 @@ IF_DESKTOP(	"tries\0"            Require
 		"header\0"           Required_argument "\xff"
 		"post-data\0"        Required_argument "\xfe"
 		"spider\0"           No_argument       "\xfd"
+		"no-check-certificate\0" No_argument   "\xfc"
 		/* Ignored (we always use PASV): */
 IF_DESKTOP(	"passive-ftp\0"      No_argument       "\xf0")
-		/* Ignored (we don't do ssl) */
-IF_DESKTOP(	"no-check-certificate\0" No_argument   "\xf0")
 		/* Ignored (we don't support caching) */
 IF_DESKTOP(	"no-cache\0"         No_argument       "\xf0")
 IF_DESKTOP(	"no-verbose\0"       No_argument       "\xf0")
@@ -1416,6 +1469,7 @@ IF_DESKTOP(	"no-parent\0"        No_argu
 	if (option_mask32 & WGET_OPT_HEADER) bb_error_msg("--header");
 	if (option_mask32 & WGET_OPT_POST_DATA) bb_error_msg("--post-data");
 	if (option_mask32 & WGET_OPT_SPIDER) bb_error_msg("--spider");
+	if (option_mask32 & WGET_OPT_NO_CHECK_CERT) bb_error_msg("--no-check-certificate");
 	exit(0);
 #endif
 	argv += optind;
diff -urpN busybox-1.28.4/printutils/Config.src busybox-1.29.0/printutils/Config.src
--- busybox-1.28.4/printutils/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/printutils/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Print Utilities"
diff -urpN busybox-1.28.4/procps/Config.src busybox-1.29.0/procps/Config.src
--- busybox-1.28.4/procps/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/procps/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Process Utilities"
diff -urpN busybox-1.28.4/procps/mpstat.c busybox-1.29.0/procps/mpstat.c
--- busybox-1.28.4/procps/mpstat.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/procps/mpstat.c	2018-07-02 15:55:14.000000000 +0200
@@ -840,7 +840,7 @@ static int get_irqcpu_nr(const char *f,
 //usage:     "\n	-u			Report CPU utilization"
 
 int mpstat_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int mpstat_main(int UNUSED_PARAM argc, char **argv)
+int mpstat_main(int argc UNUSED_PARAM, char **argv)
 {
 	char *opt_irq_fmt;
 	char *opt_set_cpu;
diff -urpN busybox-1.28.4/procps/powertop.c busybox-1.29.0/procps/powertop.c
--- busybox-1.28.4/procps/powertop.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/procps/powertop.c	2018-07-02 15:55:14.000000000 +0200
@@ -686,7 +686,7 @@ static void show_timerstats(void)
 //usage:       "Analyze power consumption on Intel-based laptops"
 
 int powertop_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int powertop_main(int UNUSED_PARAM argc, char UNUSED_PARAM **argv)
+int powertop_main(int argc UNUSED_PARAM, char UNUSED_PARAM **argv)
 {
 	ullong cur_usage[MAX_CSTATE_COUNT];
 	ullong cur_duration[MAX_CSTATE_COUNT];
diff -urpN busybox-1.28.4/procps/top.c busybox-1.29.0/procps/top.c
--- busybox-1.28.4/procps/top.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/procps/top.c	2018-07-02 15:55:14.000000000 +0200
@@ -180,7 +180,7 @@ struct globals {
 #else
 	cmp_funcp sort_function[SORT_DEPTH];
 	struct save_hist *prev_hist;
-	int prev_hist_count;
+	unsigned prev_hist_count;
 	jiffy_counts_t cur_jif, prev_jif;
 	/* int hist_iterations; */
 	unsigned total_pcpu;
@@ -189,7 +189,7 @@ struct globals {
 #if ENABLE_FEATURE_TOP_SMP_CPU
 	/* Per CPU samples: current and last */
 	jiffy_counts_t *cpu_jif, *cpu_prev_jif;
-	int num_cpus;
+	unsigned num_cpus;
 #endif
 #if ENABLE_FEATURE_TOP_INTERACTIVE
 	char kbd_input[KEYCODE_BUFFER_SIZE];
@@ -355,7 +355,8 @@ static void do_stats(void)
 {
 	top_status_t *cur;
 	pid_t pid;
-	int i, last_i, n;
+	int n;
+	unsigned i, last_i;
 	struct save_hist *new_hist;
 
 	get_jiffy_counts();
@@ -607,7 +608,6 @@ static NOINLINE void display_process_lis
 	};
 
 	top_status_t *s;
-	char vsz_str_buf[8];
 	unsigned long total_memory = display_header(scr_width, &lines_rem); /* or use total_vsz? */
 	/* xxx_shift and xxx_scale variables allow us to replace
 	 * expensive divides with multiply and shift */
@@ -688,19 +688,18 @@ static NOINLINE void display_process_lis
 		lines_rem = ntop - G_scroll_ofs;
 	s = top + G_scroll_ofs;
 	while (--lines_rem >= 0) {
+		char vsz_str_buf[8];
 		unsigned col;
+
 		CALC_STAT(pmem, (s->vsz*pmem_scale + pmem_half) >> pmem_shift);
 #if ENABLE_FEATURE_TOP_CPU_USAGE_PERCENTAGE
 		CALC_STAT(pcpu, (s->pcpu*pcpu_scale + pcpu_half) >> pcpu_shift);
 #endif
 
-		if (s->vsz >= 100000)
-			sprintf(vsz_str_buf, "%6ldm", s->vsz/1024);
-		else
-			sprintf(vsz_str_buf, "%7lu", s->vsz);
+		smart_ulltoa5(s->vsz, vsz_str_buf, " mgtpezy");
 		/* PID PPID USER STAT VSZ %VSZ [%CPU] COMMAND */
 		col = snprintf(line_buf, scr_width,
-				"\n" "%5u%6u %-8.8s %s%s" FMT
+				"\n" "%5u%6u %-8.8s %s  %.5s" FMT
 				IF_FEATURE_TOP_SMP_PROCESS(" %3d")
 				IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE(FMT)
 				" ",
@@ -710,7 +709,7 @@ static NOINLINE void display_process_lis
 				IF_FEATURE_TOP_SMP_PROCESS(, s->last_seen_on_cpu)
 				IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE(, SHOW_STAT(pcpu))
 		);
-		if ((int)(col + 1) < scr_width)
+		if ((int)(scr_width - col) > 1)
 			read_cmdline(line_buf + col, scr_width - col, s->pid, s->comm);
 		fputs(line_buf, stdout);
 		/* printf(" %d/%d %lld/%lld", s->pcpu, total_pcpu,
@@ -897,7 +896,8 @@ enum {
 		| PSSCAN_PID
 		| PSSCAN_SMAPS
 		| PSSCAN_COMM,
-	EXIT_MASK = (unsigned)-1,
+	EXIT_MASK = 0,
+	NO_RESCAN_MASK = (unsigned)-1,
 };
 
 #if ENABLE_FEATURE_TOP_INTERACTIVE
@@ -935,7 +935,7 @@ static unsigned handle_input(unsigned sc
 		}
 		if (c == KEYCODE_HOME) {
 			G_scroll_ofs = 0;
-			break;
+			goto normalize_ofs;
 		}
 		if (c == KEYCODE_END) {
 			G_scroll_ofs = ntop - G.lines / 2;
@@ -952,7 +952,7 @@ static unsigned handle_input(unsigned sc
 				G_scroll_ofs = ntop - 1;
 			if (G_scroll_ofs < 0)
 				G_scroll_ofs = 0;
-			break;
+			return NO_RESCAN_MASK;
 		}
 
 		c |= 0x20; /* lowercase */
@@ -1157,6 +1157,7 @@ int top_main(int argc UNUSED_PARAM, char
 #endif
 
 	while (scan_mask != EXIT_MASK) {
+		IF_FEATURE_TOP_INTERACTIVE(unsigned new_mask;)
 		procps_status_t *p = NULL;
 
 		if (OPT_BATCH_MODE) {
@@ -1234,21 +1235,32 @@ int top_main(int argc UNUSED_PARAM, char
 #else
 			qsort(top, ntop, sizeof(top_status_t), (void*)(sort_function[0]));
 #endif
-			display_process_list(G.lines, col);
 		}
 #if ENABLE_FEATURE_TOPMEM
 		else { /* TOPMEM */
 			qsort(topmem, ntop, sizeof(topmem_status_t), (void*)topmem_sort);
+		}
+#endif
+ IF_FEATURE_TOP_INTERACTIVE(display:)
+		IF_FEATURE_TOPMEM(if (scan_mask != TOPMEM_MASK)) {
+			display_process_list(G.lines, col);
+		}
+#if ENABLE_FEATURE_TOPMEM
+		else { /* TOPMEM */
 			display_topmem_process_list(G.lines, col);
 		}
 #endif
-		clearmems();
 		if (iterations >= 0 && !--iterations)
 			break;
 #if !ENABLE_FEATURE_TOP_INTERACTIVE
+		clearmems();
 		sleep(interval);
 #else
-		scan_mask = handle_input(scan_mask, interval);
+		new_mask = handle_input(scan_mask, interval);
+		if (new_mask == NO_RESCAN_MASK)
+			goto display;
+		scan_mask = new_mask;
+		clearmems();
 #endif
 	} /* end of "while (not Q)" */
 
diff -urpN busybox-1.28.4/runit/Config.src busybox-1.29.0/runit/Config.src
--- busybox-1.28.4/runit/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/runit/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Runit Utilities"
diff -urpN busybox-1.28.4/runit/chpst.c busybox-1.29.0/runit/chpst.c
--- busybox-1.28.4/runit/chpst.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/runit/chpst.c	2018-07-02 15:55:14.000000000 +0200
@@ -135,7 +135,6 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 //usage:     "\n			a SIGXCPU after N seconds"
 
 #include "libbb.h"
-#include <sys/resource.h> /* getrlimit */
 
 /*
 Five applets here: chpst, envdir, envuidgid, setuidgid, softlimit.
diff -urpN busybox-1.28.4/runit/sv.c busybox-1.29.0/runit/sv.c
--- busybox-1.28.4/runit/sv.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/runit/sv.c	2018-07-02 15:55:14.000000000 +0200
@@ -163,7 +163,7 @@ Exit Codes
 //config:config SV_DEFAULT_SERVICE_DIR
 //config:	string "Default directory for services"
 //config:	default "/var/service"
-//config:	depends on SV
+//config:	depends on SV || SVC || SVOK
 //config:	help
 //config:	Default directory for services.
 //config:	Defaults to "/var/service"
@@ -173,13 +173,22 @@ Exit Codes
 //config:	default y
 //config:	help
 //config:	svc controls the state of services monitored by the runsv supervisor.
-//config:	It is comaptible with daemontools command with the same name.
+//config:	It is compatible with daemontools command with the same name.
+//config:
+//config:config SVOK
+//config:	bool "svok"
+//config:	default y
+//config:	help
+//config:	svok checks whether runsv supervisor is running.
+//config:	It is compatible with daemontools command with the same name.
 
-//applet:IF_SV( APPLET_NOEXEC(sv,  sv,  BB_DIR_USR_BIN, BB_SUID_DROP, sv ))
-//applet:IF_SVC(APPLET_NOEXEC(svc, svc, BB_DIR_USR_BIN, BB_SUID_DROP, svc))
+//applet:IF_SV(  APPLET_NOEXEC(sv,   sv,   BB_DIR_USR_BIN, BB_SUID_DROP, sv  ))
+//applet:IF_SVC( APPLET_NOEXEC(svc,  svc,  BB_DIR_USR_BIN, BB_SUID_DROP, svc ))
+//applet:IF_SVOK(APPLET_NOEXEC(svok, svok, BB_DIR_USR_BIN, BB_SUID_DROP, svok))
 
 //kbuild:lib-$(CONFIG_SV) += sv.o
 //kbuild:lib-$(CONFIG_SVC) += sv.o
+//kbuild:lib-$(CONFIG_SVOK) += sv.o
 
 #include <sys/file.h>
 #include "libbb.h"
@@ -213,6 +222,7 @@ struct globals {
 #define str_equal(s,t) (strcmp((s), (t)) == 0)
 
 
+#if ENABLE_SV || ENABLE_SVC
 static void fatal_cannot(const char *m1) NORETURN;
 static void fatal_cannot(const char *m1)
 {
@@ -615,7 +625,7 @@ static int sv(char **argv)
 	service = argv;
 	while ((x = *service) != NULL) {
 		if (x[0] != '/' && x[0] != '.'
-		 && x[0] != '\0' && x[strlen(x) - 1] != '/'
+		 && !last_char_is(x, '/')
 		) {
 			if (chdir(varservice) == -1)
 				goto chdir_failed_0;
@@ -679,6 +689,7 @@ static int sv(char **argv)
 	}
 	return rc > 99 ? 99 : rc;
 }
+#endif
 
 #if ENABLE_SV
 int sv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -741,4 +752,42 @@ int svc_main(int argc UNUSED_PARAM, char
 
 	return 0;
 }
+#endif
+
+//usage:#define svok_trivial_usage
+//usage:       "SERVICE_DIR"
+//usage:#define svok_full_usage "\n\n"
+//usage:       "Check whether runsv supervisor is running.\n"
+//usage:       "Exit code is 0 if it does, 100 if it does not,\n"
+//usage:       "111 (with error message) if SERVICE_DIR does not exist."
+#if ENABLE_SVOK
+int svok_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int svok_main(int argc UNUSED_PARAM, char **argv)
+{
+	const char *dir = argv[1];
+
+	if (!dir)
+		bb_show_usage();
+
+	xfunc_error_retval = 111;
+
+	/*
+	 * daemontools has no concept of "default service dir", runit does.
+	 * Let's act as runit.
+	 */
+	if (dir[0] != '/' && dir[0] != '.'
+	 && !last_char_is(dir, '/')
+	) {
+		xchdir(CONFIG_SV_DEFAULT_SERVICE_DIR);
+	}
+
+	xchdir(dir);
+	if (open("supervise/ok", O_WRONLY) < 0) {
+		if (errno == ENOENT || errno == ENXIO)
+			return 100;
+		bb_perror_msg_and_die("can't open '%s'", "supervise/ok");
+	}
+
+	return 0;
+}
 #endif
diff -urpN busybox-1.28.4/runit/svlogd.c busybox-1.29.0/runit/svlogd.c
--- busybox-1.28.4/runit/svlogd.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/runit/svlogd.c	2018-07-02 15:55:14.000000000 +0200
@@ -347,11 +347,13 @@ static unsigned pmatch(const char *p, co
 /* NUL terminated */
 static void fmt_time_human_30nul(char *s, char dt_delim)
 {
+	struct tm tm;
 	struct tm *ptm;
 	struct timeval tv;
 
 	gettimeofday(&tv, NULL);
-	ptm = gmtime(&tv.tv_sec);
+	ptm = gmtime_r(&tv.tv_sec, &tm);
+	/* ^^^ using gmtime_r() instead of gmtime() to not use static data */
 	sprintf(s, "%04u-%02u-%02u%c%02u:%02u:%02u.%06u000",
 		(unsigned)(1900 + ptm->tm_year),
 		(unsigned)(ptm->tm_mon + 1),
diff -urpN busybox-1.28.4/scripts/bb_release busybox-1.29.0/scripts/bb_release
--- busybox-1.28.4/scripts/bb_release	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/scripts/bb_release	2018-07-02 15:55:14.000000000 +0200
@@ -15,20 +15,8 @@ VERSION=`ls busybox-*.tar.gz | sed 's/bu
 
 zcat busybox-$VERSION.tar.gz | bzip2 > busybox-$VERSION.tar.bz2
 
-test -f busybox-$VERSION.tar.gz || { echo "no busybox-$VERSION.tar.gz"; exit 1; }
-test -f busybox-$VERSION.tar.bz2 || { echo "no busybox-$VERSION.tar.bz2"; exit 1; }
-
-signit()
-{
-echo "$1 released `date -r $1 -R`
-
-MD5:  `md5sum $1`
-SHA1: `sha1sum $1`
-
-To verify this signature, you can obtain my public key
-from http://busybox.net/~vda/vda_pubkey.gpg
-" | gpg --clearsign > "$1.sign"
-}
-
-signit busybox-$VERSION.tar.gz
-signit busybox-$VERSION.tar.bz2
+for releasefile in busybox-$VERSION.tar.gz busybox-$VERSION.tar.bz2; do
+    test -f $releasefile || { echo "no $releasefile"; exit 1; }
+    gpg --detach-sign $releasefile
+    sha256sum $releasefile > $releasefile.sha256
+done
diff -urpN busybox-1.28.4/scripts/kconfig/confdata.c busybox-1.29.0/scripts/kconfig/confdata.c
--- busybox-1.28.4/scripts/kconfig/confdata.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/scripts/kconfig/confdata.c	2018-07-02 15:55:14.000000000 +0200
@@ -334,7 +334,9 @@ int conf_write(const char *name)
 	struct symbol *sym;
 	struct menu *menu;
 	const char *basename;
-	char dirname[128], tmpname[128], newname[128];
+	char dirname[128];
+	char tmpname[256];
+	char newname[256];
 	int type, l;
 	const char *str;
 	time_t now;
diff -urpN busybox-1.28.4/scripts/kconfig/mconf.c busybox-1.29.0/scripts/kconfig/mconf.c
--- busybox-1.28.4/scripts/kconfig/mconf.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/scripts/kconfig/mconf.c	2018-07-02 15:55:14.000000000 +0200
@@ -27,6 +27,10 @@
 #include <unistd.h>
 #include <locale.h>
 
+#ifndef SIGWINCH
+#define SIGWINCH 28
+#endif
+
 #define LKC_DIRECT_LINK
 #include "lkc.h"
 
diff -urpN busybox-1.28.4/scripts/randomtest busybox-1.29.0/scripts/randomtest
--- busybox-1.28.4/scripts/randomtest	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/scripts/randomtest	2018-07-02 15:55:14.000000000 +0200
@@ -57,6 +57,8 @@ if test x"$LIBC" = x"glibc"; then
 	| grep -v CONFIG_FEATURE_2_4_MODULES \
 	| grep -v CONFIG_FEATURE_USE_BSS_TAIL \
 	| grep -v CONFIG_DEBUG_SANITIZE \
+	| grep -v CONFIG_FEATURE_MOUNT_NFS \
+	| grep -v CONFIG_FEATURE_INETD_RPC \
 	>.config.new
 	mv .config.new .config
 	echo '# CONFIG_STATIC is not set' >>.config
@@ -66,6 +68,9 @@ if test x"$LIBC" = x"glibc"; then
 	echo '# CONFIG_FEATURE_2_4_MODULES is not set' >>.config
 	echo '# CONFIG_FEATURE_USE_BSS_TAIL is not set' >>.config
 	echo '# CONFIG_DEBUG_SANITIZE is not set' >>.config
+	# 2018: current glibc versions no longer include rpc/rpc.h
+	echo '# CONFIG_FEATURE_MOUNT_NFS is not set' >>.config
+	echo '# CONFIG_FEATURE_INETD_RPC is not set' >>.config
 fi
 
 # If uclibc, build static, and remove some things
@@ -86,6 +91,7 @@ if test x"$LIBC" = x"uclibc"; then
 	| grep -v CONFIG_UNSHARE \
 	| grep -v CONFIG_FALLOCATE \
 	| grep -v CONFIG_UDHCPC6 \
+	| grep -v CONFIG_NSLOOKUP \
 	| grep -v CONFIG_ASH_INTERNAL_GLOB \
 	>.config.new
 	mv .config.new .config
@@ -103,6 +109,7 @@ if test x"$LIBC" = x"uclibc"; then
 	echo '# CONFIG_UNSHARE is not set' >>.config
 	echo '# CONFIG_FALLOCATE is not set' >>.config
 	echo '# CONFIG_UDHCPC6 is not set' >>.config
+	echo '# CONFIG_NSLOOKUP is not set' >>.config
 	echo 'CONFIG_ASH_INTERNAL_GLOB=y' >>.config
 fi
 
diff -urpN busybox-1.28.4/selinux/Config.src busybox-1.29.0/selinux/Config.src
--- busybox-1.28.4/selinux/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/selinux/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "SELinux Utilities"
diff -urpN busybox-1.28.4/shell/Config.src busybox-1.29.0/shell/Config.src
--- busybox-1.28.4/shell/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Shells"
diff -urpN busybox-1.28.4/shell/ash.c busybox-1.29.0/shell/ash.c
--- busybox-1.28.4/shell/ash.c	2018-04-01 13:04:11.000000000 +0200
+++ busybox-1.29.0/shell/ash.c	2018-07-02 15:55:14.000000000 +0200
@@ -51,6 +51,22 @@
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
 //config:
+//config:config ASH_BASH_SOURCE_CURDIR
+//config:	bool "'source' and '.' builtins search current directory after $PATH"
+//config:	default n   # do not encourage non-standard behavior
+//config:	depends on ASH_BASH_COMPAT
+//config:	help
+//config:	This is not compliant with standards. Avoid if possible.
+//config:
+//config:config ASH_BASH_NOT_FOUND_HOOK
+//config:	bool "command_not_found_handle hook support"
+//config:	default y
+//config:	depends on ASH_BASH_COMPAT
+//config:	help
+//config:	Enable support for the 'command_not_found_handle' hook function,
+//config:	from GNU bash, which allows for alternative command not found
+//config:	handling.
+//config:
 //config:config ASH_JOB_CONTROL
 //config:	bool "Job control"
 //config:	default y
@@ -161,7 +177,6 @@
 
 #define JOBS ENABLE_ASH_JOB_CONTROL
 
-#include <setjmp.h>
 #include <fnmatch.h>
 #include <sys/times.h>
 #include <sys/utsname.h> /* for setting $HOSTNAME */
@@ -182,7 +197,20 @@
 #define IF_BASH_PATTERN_SUBST       IF_ASH_BASH_COMPAT
 #define    BASH_SUBSTR          ENABLE_ASH_BASH_COMPAT
 #define IF_BASH_SUBSTR              IF_ASH_BASH_COMPAT
-/* [[ EXPR ]] */
+/* BASH_TEST2: [[ EXPR ]]
+ * Status of [[ support:
+ * We replace && and || with -a and -o
+ * TODO:
+ * singleword+noglob expansion:
+ *   v='a b'; [[ $v = 'a b' ]]; echo 0:$?
+ *   [[ /bin/n* ]]; echo 0:$?
+ * -a/-o are not AND/OR ops! (they are just strings)
+ * quoting needs to be considered (-f is an operator, "-f" and ""-f are not; etc)
+ * = is glob match operator, not equality operator: STR = GLOB
+ * (in GLOB, quoting is significant on char-by-char basis: a*cd"*")
+ * == same as =
+ * add =~ regex match operator: STR =~ REGEX
+ */
 #define    BASH_TEST2           (ENABLE_ASH_BASH_COMPAT * ENABLE_ASH_TEST)
 #define    BASH_SOURCE          ENABLE_ASH_BASH_COMPAT
 #define    BASH_PIPEFAIL        ENABLE_ASH_BASH_COMPAT
@@ -242,6 +270,9 @@ typedef long arith_t;
 #ifndef F_DUPFD_CLOEXEC
 # define F_DUPFD_CLOEXEC F_DUPFD
 #endif
+#ifndef O_CLOEXEC
+# define O_CLOEXEC 0
+#endif
 #ifndef PIPE_BUF
 # define PIPE_BUF 4096           /* amount of buffering in a pipe */
 #endif
@@ -250,6 +281,19 @@ typedef long arith_t;
 # error "Do not even bother, ash will not run on NOMMU machine"
 #endif
 
+/* We use a trick to have more optimized code (fewer pointer reloads):
+ *  ash.c:   extern struct globals *const ash_ptr_to_globals;
+ *  ash_ptr_hack.c: struct globals *ash_ptr_to_globals;
+ * This way, compiler in ash.c knows the pointer can not change.
+ *
+ * However, this may break on weird arches or toolchains. In this case,
+ * set "-DBB_GLOBAL_CONST=''" in CONFIG_EXTRA_CFLAGS to disable
+ * this optimization.
+ */
+#ifndef BB_GLOBAL_CONST
+# define BB_GLOBAL_CONST const
+#endif
+
 
 /* ============ Hash table sizes. Configurable. */
 
@@ -315,6 +359,8 @@ struct globals_misc {
 	/* shell level: 0 for the main shell, 1 for its children, and so on */
 	int shlvl;
 #define rootshell (!shlvl)
+	int errlinno;
+
 	char *minusc;  /* argument to -c option */
 
 	char *curdir; // = nullstr;     /* current working directory */
@@ -385,13 +431,14 @@ struct globals_misc {
 #endif
 	pid_t backgndpid;        /* pid of last background process */
 };
-extern struct globals_misc *const ash_ptr_to_globals_misc;
+extern struct globals_misc *BB_GLOBAL_CONST ash_ptr_to_globals_misc;
 #define G_misc (*ash_ptr_to_globals_misc)
 #define exitstatus        (G_misc.exitstatus )
 #define back_exitstatus   (G_misc.back_exitstatus )
 #define job_warning       (G_misc.job_warning)
 #define rootpid     (G_misc.rootpid    )
 #define shlvl       (G_misc.shlvl      )
+#define errlinno    (G_misc.errlinno   )
 #define minusc      (G_misc.minusc     )
 #define curdir      (G_misc.curdir     )
 #define physdir     (G_misc.physdir    )
@@ -726,6 +773,7 @@ union node;
 
 struct ncmd {
 	smallint type; /* Nxxxx */
+	int linno;
 	union node *assign;
 	union node *args;
 	union node *redirect;
@@ -739,6 +787,7 @@ struct npipe {
 
 struct nredir {
 	smallint type;
+	int linno;
 	union node *n;
 	union node *redirect;
 };
@@ -758,6 +807,7 @@ struct nif {
 
 struct nfor {
 	smallint type;
+	int linno;
 	union node *args;
 	union node *body;
 	char *var;
@@ -765,6 +815,7 @@ struct nfor {
 
 struct ncase {
 	smallint type;
+	int linno;
 	union node *expr;
 	union node *cases;
 };
@@ -776,6 +827,13 @@ struct nclist {
 	union node *body;
 };
 
+struct ndefun {
+	smallint type;
+	int linno;
+	char *text;
+	union node *body;
+};
+
 struct narg {
 	smallint type;
 	union node *next;
@@ -827,6 +885,7 @@ union node {
 	struct nfor nfor;
 	struct ncase ncase;
 	struct nclist nclist;
+	struct ndefun ndefun;
 	struct narg narg;
 	struct nfile nfile;
 	struct ndup ndup;
@@ -1256,7 +1315,6 @@ struct parsefile {
 
 static struct parsefile basepf;        /* top level input file */
 static struct parsefile *g_parsefile = &basepf;  /* current input file */
-static int startlinno;                 /* line # where last token started */
 static char *commandname;              /* currently executing command */
 
 
@@ -1270,7 +1328,7 @@ ash_vmsg(const char *msg, va_list ap)
 		if (strcmp(arg0, commandname))
 			fprintf(stderr, "%s: ", commandname);
 		if (!iflag || g_parsefile->pf_fd > 0)
-			fprintf(stderr, "line %d: ", startlinno);
+			fprintf(stderr, "line %d: ", errlinno);
 	}
 	vfprintf(stderr, msg, ap);
 	newline_and_flush(stderr);
@@ -1323,6 +1381,7 @@ static void raise_error_syntax(const cha
 static void
 raise_error_syntax(const char *msg)
 {
+	errlinno = g_parsefile->linno;
 	ash_msg_and_raise_error("syntax error: %s", msg);
 	/* NOTREACHED */
 }
@@ -1445,7 +1504,7 @@ struct globals_memstack {
 	size_t g_stacknleft; // = MINSIZE;
 	struct stack_block stackbase;
 };
-extern struct globals_memstack *const ash_ptr_to_globals_memstack;
+extern struct globals_memstack *BB_GLOBAL_CONST ash_ptr_to_globals_memstack;
 #define G_memstack (*ash_ptr_to_globals_memstack)
 #define g_stackp     (G_memstack.g_stackp    )
 #define g_stacknxt   (G_memstack.g_stacknxt  )
@@ -1535,7 +1594,7 @@ sstrdup(const char *p)
 	return memcpy(stalloc(len), p, len);
 }
 
-static inline void
+static ALWAYS_INLINE void
 grabstackblock(size_t len)
 {
 	stalloc(len);
@@ -2010,6 +2069,7 @@ static const struct {
 #if ENABLE_ASH_GETOPTS
 	{ VSTRFIXED|VTEXTFIXED       , defoptindvar, getoptsreset    },
 #endif
+	{ VSTRFIXED|VTEXTFIXED       , NULL /* inited to linenovar */, NULL },
 #if ENABLE_ASH_RANDOM_SUPPORT
 	{ VSTRFIXED|VTEXTFIXED|VUNSET|VDYNAMIC, "RANDOM", change_random },
 #endif
@@ -2030,25 +2090,18 @@ struct globals_var {
 	int preverrout_fd;   /* stderr fd: usually 2, unless redirect moved it */
 	struct var *vartab[VTABSIZE];
 	struct var varinit[ARRAY_SIZE(varinit_data)];
+	int lineno;
+	char linenovar[sizeof("LINENO=") + sizeof(int)*3];
 };
-extern struct globals_var *const ash_ptr_to_globals_var;
+extern struct globals_var *BB_GLOBAL_CONST ash_ptr_to_globals_var;
 #define G_var (*ash_ptr_to_globals_var)
 #define shellparam    (G_var.shellparam   )
 //#define redirlist     (G_var.redirlist    )
 #define preverrout_fd (G_var.preverrout_fd)
 #define vartab        (G_var.vartab       )
 #define varinit       (G_var.varinit      )
-#define INIT_G_var() do { \
-	unsigned i; \
-	(*(struct globals_var**)&ash_ptr_to_globals_var) = xzalloc(sizeof(G_var)); \
-	barrier(); \
-	for (i = 0; i < ARRAY_SIZE(varinit_data); i++) { \
-		varinit[i].flags    = varinit_data[i].flags; \
-		varinit[i].var_text = varinit_data[i].var_text; \
-		varinit[i].var_func = varinit_data[i].var_func; \
-	} \
-} while (0)
-
+#define lineno        (G_var.lineno       )
+#define linenovar     (G_var.linenovar    )
 #define vifs      varinit[0]
 #if ENABLE_ASH_MAIL
 # define vmail    (&vifs)[1]
@@ -2062,14 +2115,28 @@ extern struct globals_var *const ash_ptr
 #define vps4      (&vps2)[1]
 #if ENABLE_ASH_GETOPTS
 # define voptind  (&vps4)[1]
+# define vlineno  (&voptind)[1]
 # if ENABLE_ASH_RANDOM_SUPPORT
-#  define vrandom (&voptind)[1]
+#  define vrandom (&vlineno)[1]
 # endif
 #else
+# define vlineno  (&vps4)[1]
 # if ENABLE_ASH_RANDOM_SUPPORT
-#  define vrandom (&vps4)[1]
+#  define vrandom (&vlineno)[1]
 # endif
 #endif
+#define INIT_G_var() do { \
+	unsigned i; \
+	(*(struct globals_var**)&ash_ptr_to_globals_var) = xzalloc(sizeof(G_var)); \
+	barrier(); \
+	for (i = 0; i < ARRAY_SIZE(varinit_data); i++) { \
+		varinit[i].flags    = varinit_data[i].flags; \
+		varinit[i].var_text = varinit_data[i].var_text; \
+		varinit[i].var_func = varinit_data[i].var_func; \
+	} \
+	strcpy(linenovar, "LINENO="); \
+	vlineno.var_text = linenovar; \
+} while (0)
 
 /*
  * The following macros access the values of the above variables.
@@ -2205,8 +2272,12 @@ lookupvar(const char *name)
 		if (v->flags & VDYNAMIC)
 			v->var_func(NULL);
 #endif
-		if (!(v->flags & VUNSET))
+		if (!(v->flags & VUNSET)) {
+			if (v == &vlineno && v->var_text == linenovar) {
+				fmtstr(linenovar+7, sizeof(linenovar)-7, "%d", lineno);
+			}
 			return var_end(v->var_text);
+		}
 	}
 	return NULL;
 }
@@ -3916,12 +3987,13 @@ setjobctl(int on)
 					goto out;
 		}
 		/* fd is a tty at this point */
-		fd = fcntl(fd, F_DUPFD, 10);
+		fd = fcntl(fd, F_DUPFD_CLOEXEC, 10);
 		if (ofd >= 0) /* if it is "/dev/tty", close. If 0/1/2, don't */
 			close(ofd);
 		if (fd < 0)
 			goto out; /* F_DUPFD failed */
-		close_on_exec_on(fd);
+		if (F_DUPFD_CLOEXEC == F_DUPFD) /* if old libc (w/o F_DUPFD_CLOEXEC) */
+			close_on_exec_on(fd);
 		while (1) { /* while we are in the background */
 			pgrp = tcgetpgrp(fd);
 			if (pgrp < 0) {
@@ -4810,7 +4882,7 @@ cmdtxt(union node *n)
 		p = "; done";
 		goto dodo;
 	case NDEFUN:
-		cmdputs(n->narg.text);
+		cmdputs(n->ndefun.text);
 		p = "() { ... }";
 		goto dotail2;
 	case NCMD:
@@ -5331,7 +5403,7 @@ openredirect(union node *redir)
 				f = open(fname, O_WRONLY, 0666);
 				if (f < 0)
 					goto ecreate;
-				if (fstat(f, &sb) < 0 && S_ISREG(sb.st_mode)) {
+				if (!fstat(f, &sb) && S_ISREG(sb.st_mode)) {
 					close(f);
 					errno = EEXIST;
 					goto ecreate;
@@ -5371,13 +5443,14 @@ savefd(int from)
 	int newfd;
 	int err;
 
-	newfd = fcntl(from, F_DUPFD, 10);
+	newfd = fcntl(from, F_DUPFD_CLOEXEC, 10);
 	err = newfd < 0 ? errno : 0;
 	if (err != EBADF) {
 		if (err)
 			ash_msg_and_raise_perror("%d", from);
 		close(from);
-		fcntl(newfd, F_SETFD, FD_CLOEXEC);
+		if (F_DUPFD_CLOEXEC == F_DUPFD)
+			close_on_exec_on(newfd);
 	}
 
 	return newfd;
@@ -5402,7 +5475,7 @@ dup_CLOEXEC(int fd, int avoid_fd)
 	newfd = fcntl(fd, F_DUPFD_CLOEXEC, avoid_fd + 1);
 	if (newfd >= 0) {
 		if (F_DUPFD_CLOEXEC == F_DUPFD) /* if old libc (w/o F_DUPFD_CLOEXEC) */
-			fcntl(newfd, F_SETFD, FD_CLOEXEC);
+			close_on_exec_on(newfd);
 	} else { /* newfd < 0 */
 		if (errno == EBUSY)
 			goto repeat;
@@ -5416,7 +5489,7 @@ xdup_CLOEXEC_and_close(int fd, int avoid
 {
 	int newfd;
  repeat:
-	newfd = fcntl(fd, F_DUPFD, avoid_fd + 1);
+	newfd = fcntl(fd, F_DUPFD_CLOEXEC, avoid_fd + 1);
 	if (newfd < 0) {
 		if (errno == EBUSY)
 			goto repeat;
@@ -5427,7 +5500,8 @@ xdup_CLOEXEC_and_close(int fd, int avoid
 			return fd;
 		ash_msg_and_raise_perror("%d", newfd);
 	}
-	fcntl(newfd, F_SETFD, FD_CLOEXEC);
+	if (F_DUPFD_CLOEXEC == F_DUPFD)
+		close_on_exec_on(newfd);
 	close(fd);
 	return newfd;
 }
@@ -5786,6 +5860,26 @@ ash_arith(const char *s)
 	return result;
 }
 #endif
+#if BASH_SUBSTR
+# if ENABLE_FEATURE_SH_MATH
+static int substr_atoi(const char *s)
+{
+	arith_t t = ash_arith(s);
+	if (sizeof(t) > sizeof(int)) {
+		/* clamp very large or very large negative nums for ${v:N:M}:
+		 * else "${v:0:0x100000001}" would work as "${v:0:1}"
+		 */
+		if (t > INT_MAX)
+			t = INT_MAX;
+		if (t < INT_MIN)
+			t = INT_MIN;
+	}
+	return t;
+}
+# else
+#  define substr_atoi(s) number(s)
+# endif
+#endif
 
 /*
  * expandarg flags
@@ -5806,10 +5900,9 @@ ash_arith(const char *s)
  * performs globbing, and thus diverges from what we do).
  */
 #define EXP_CASE        0x10    /* keeps quotes around for CASE pattern */
-#define EXP_QPAT        0x20    /* pattern in quoted parameter expansion */
-#define EXP_VARTILDE2   0x40    /* expand tildes after colons only */
-#define EXP_WORD        0x80    /* expand word in parameter expansion */
-#define EXP_QUOTED      0x100   /* expand word in double quotes */
+#define EXP_VARTILDE2   0x20    /* expand tildes after colons only */
+#define EXP_WORD        0x40    /* expand word in parameter expansion */
+#define EXP_QUOTED      0x80    /* expand word in double quotes */
 /*
  * rmescape() flags
  */
@@ -5817,10 +5910,9 @@ ash_arith(const char *s)
 #define RMESCAPE_GLOB   0x2     /* Add backslashes for glob */
 #define RMESCAPE_GROW   0x8     /* Grow strings instead of stalloc */
 #define RMESCAPE_HEAP   0x10    /* Malloc strings instead of stalloc */
-#define RMESCAPE_SLASH  0x20    /* Stop globbing after slash */
 
 /* Add CTLESC when necessary. */
-#define QUOTES_ESC     (EXP_FULL | EXP_CASE | EXP_QPAT)
+#define QUOTES_ESC     (EXP_FULL | EXP_CASE)
 /* Do not skip NUL characters. */
 #define QUOTES_KEEPNUL EXP_TILDE
 
@@ -5895,7 +5987,10 @@ ifsbreakup(char *string, struct arglist
 		realifs = ifsset() ? ifsval() : defifs;
 		ifsp = &ifsfirst;
 		do {
+			int afternul;
+
 			p = string + ifsp->begoff;
+			afternul = nulonly;
 			nulonly = ifsp->nulonly;
 			ifs = nulonly ? nullstr : realifs;
 			ifsspc = 0;
@@ -5907,7 +6002,7 @@ ifsbreakup(char *string, struct arglist
 					p++;
 					continue;
 				}
-				if (!nulonly)
+				if (!(afternul || nulonly))
 					ifsspc = (strchr(defifs, *p) != NULL);
 				/* Ignore IFS whitespace at start */
 				if (q == start && ifsspc) {
@@ -5998,19 +6093,21 @@ esclen(const char *start, const char *p)
 /*
  * Remove any CTLESC characters from a string.
  */
+#if !BASH_PATTERN_SUBST
+#define rmescapes(str, flag, slash_position) \
+	rmescapes(str, flag)
+#endif
 static char *
-rmescapes(char *str, int flag)
+rmescapes(char *str, int flag, int *slash_position)
 {
 	static const char qchars[] ALIGN1 = {
 		IF_BASH_PATTERN_SUBST('/',) CTLESC, CTLQUOTEMARK, '\0' };
 
 	char *p, *q, *r;
-	unsigned inquotes;
 	unsigned protect_against_glob;
 	unsigned globbing;
-	IF_BASH_PATTERN_SUBST(unsigned slash = flag & RMESCAPE_SLASH;)
 
-	p = strpbrk(str, qchars IF_BASH_PATTERN_SUBST(+ !slash));
+	p = strpbrk(str, qchars IF_BASH_PATTERN_SUBST(+ !slash_position));
 	if (!p)
 		return str;
 
@@ -6037,18 +6134,21 @@ rmescapes(char *str, int flag)
 		}
 	}
 
-	inquotes = 0;
 	globbing = flag & RMESCAPE_GLOB;
 	protect_against_glob = globbing;
 	while (*p) {
 		if ((unsigned char)*p == CTLQUOTEMARK) {
-// Note: both inquotes and protect_against_glob only affect whether
+// Note: protect_against_glob only affect whether
 // CTLESC,<ch> gets converted to <ch> or to \<ch>
-			inquotes = ~inquotes;
 			p++;
 			protect_against_glob = globbing;
 			continue;
 		}
+		if (*p == '\\') {
+			/* naked back slash */
+			protect_against_glob = 0;
+			goto copy;
+		}
 		if ((unsigned char)*p == CTLESC) {
 			p++;
 #if DEBUG
@@ -6074,26 +6174,23 @@ rmescapes(char *str, int flag)
 				if (*p == '*'
 				 || *p == '?'
 				 || *p == '['
-				 || *p == '\\' /* case '\' in \\ ) echo ok;; *) echo WRONG;; esac */
-				 || *p == ']' /* case ']' in [a\]] ) echo ok;; *) echo WRONG;; esac */
-				 || *p == '-' /* case '-' in [a\-c]) echo ok;; *) echo WRONG;; esac */
-				 || *p == '!' /* case '!' in [\!] ) echo ok;; *) echo WRONG;; esac */
+				 || *p == '\\' /* case '\' in \\    ) echo ok;; *) echo WRONG;; esac */
+				 || *p == ']'  /* case ']' in [a\]] ) echo ok;; *) echo WRONG;; esac */
+				 || *p == '-'  /* case '-' in [a\-c]) echo ok;; *) echo WRONG;; esac */
+				 || *p == '!'  /* case '!' in [\!]  ) echo ok;; *) echo WRONG;; esac */
 				/* Some libc support [^negate], that's why "^" also needs love */
-				 || *p == '^' /* case '^' in [\^] ) echo ok;; *) echo WRONG;; esac */
+				 || *p == '^'  /* case '^' in [\^]  ) echo ok;; *) echo WRONG;; esac */
 				) {
 					*q++ = '\\';
 				}
 			}
-		} else if (*p == '\\' && !inquotes) {
-			/* naked back slash */
-			protect_against_glob = 0;
-			goto copy;
 		}
 #if BASH_PATTERN_SUBST
-		else if (*p == '/' && slash) {
-			/* stop handling globbing and mark location of slash */
-			globbing = slash = 0;
-			*p = CTLESC;
+		else if (slash_position && p == str + *slash_position) {
+			/* stop handling globbing */
+			globbing = 0;
+			*slash_position = q - r;
+			slash_position = NULL;
 		}
 #endif
 		protect_against_glob = globbing;
@@ -6117,7 +6214,7 @@ rmescapes(char *str, int flag)
 static char *
 preglob(const char *pattern, int flag)
 {
-	return rmescapes((char *)pattern, flag | RMESCAPE_GLOB);
+	return rmescapes((char *)pattern, flag | RMESCAPE_GLOB, NULL);
 }
 
 /*
@@ -6460,7 +6557,7 @@ expari(int flag)
 	expdest = p;
 
 	if (flag & QUOTES_ESC)
-		rmescapes(p + 1, 0);
+		rmescapes(p + 1, 0, NULL);
 
 	len = cvtnum(ash_arith(p + 1));
 
@@ -6568,12 +6665,12 @@ argstr(char *p, int flags)
 		case CTLENDVAR: /* ??? */
 			goto breakloop;
 		case CTLQUOTEMARK:
-			inquotes ^= EXP_QUOTED;
 			/* "$@" syntax adherence hack */
-			if (inquotes && !memcmp(p, dolatstr + 1, DOLATSTRLEN - 1)) {
-				p = evalvar(p + 1, flags | inquotes) + 1;
+			if (!inquotes && !memcmp(p, dolatstr + 1, DOLATSTRLEN - 1)) {
+				p = evalvar(p + 1, flags | EXP_QUOTED) + 1;
 				goto start;
 			}
+			inquotes ^= EXP_QUOTED;
  addquote:
 			if (flags & QUOTES_ESC) {
 				p--;
@@ -6584,16 +6681,6 @@ argstr(char *p, int flags)
 		case CTLESC:
 			startloc++;
 			length++;
-
-			/*
-			 * Quoted parameter expansion pattern: remove quote
-			 * unless inside inner quotes or we have a literal
-			 * backslash.
-			 */
-			if (((flags | inquotes) & (EXP_QPAT | EXP_QUOTED)) ==
-			    EXP_QPAT && *p != '\\')
-				break;
-
 			goto addquote;
 		case CTLVAR:
 			TRACE(("argstr: evalvar('%s')\n", p));
@@ -6748,20 +6835,67 @@ subevalvar(char *p, char *varname, int s
 	char *rmesc, *rmescend;
 	char *str;
 	int amount, resetloc;
+	int argstr_flags;
 	IF_BASH_PATTERN_SUBST(int workloc;)
-	IF_BASH_PATTERN_SUBST(char *repl = NULL;)
+	IF_BASH_PATTERN_SUBST(int slash_pos;)
+	IF_BASH_PATTERN_SUBST(char *repl;)
 	int zero;
 	char *(*scan)(char*, char*, char*, char*, int, int);
 
 	//bb_error_msg("subevalvar(p:'%s',varname:'%s',strloc:%d,subtype:%d,startloc:%d,varflags:%x,quotes:%d)",
 	//		p, varname, strloc, subtype, startloc, varflags, quotes);
 
-	argstr(p, EXP_TILDE | (subtype != VSASSIGN && subtype != VSQUESTION ?
-			(flag & (EXP_QUOTED | EXP_QPAT) ? EXP_QPAT : EXP_CASE) : 0)
-	);
+#if BASH_PATTERN_SUBST
+	/* For "${v/pattern/repl}", we must find the delimiter _before_
+	 * argstr() call expands possible variable references in pattern:
+	 * think about "v=a; a=a/; echo ${v/$a/r}" case.
+	 */
+	repl = NULL;
+	if (subtype == VSREPLACE || subtype == VSREPLACEALL) {
+		/* Find '/' and replace with NUL */
+		repl = p;
+		for (;;) {
+			/* Handle escaped slashes, e.g. "${v/\//_}" (they are CTLESC'ed by this point) */
+			if (*repl == '\0') {
+				repl = NULL;
+				break;
+			}
+			if (*repl == '/') {
+				*repl = '\0';
+				break;
+			}
+			if ((unsigned char)*repl == CTLESC && repl[1])
+				repl++;
+			repl++;
+		}
+	}
+#endif
+	argstr_flags = EXP_TILDE;
+	if (subtype != VSASSIGN
+	 && subtype != VSQUESTION
+#if BASH_SUBSTR
+	 && subtype != VSSUBSTR
+#endif
+	) {
+		/* EXP_CASE keeps CTLESC's */
+		argstr_flags = EXP_TILDE | EXP_CASE;
+	}
+	argstr(p, argstr_flags);
+	//bb_error_msg("str0:'%s'", (char *)stackblock() + strloc);
+#if BASH_PATTERN_SUBST
+	slash_pos = -1;
+	if (repl) {
+		slash_pos = expdest - ((char *)stackblock() + strloc);
+		STPUTC('/', expdest);
+		//bb_error_msg("repl+1:'%s'", repl + 1);
+		argstr(repl + 1, EXP_TILDE); /* EXP_TILDE: echo "${v/x/~}" expands ~ ! */
+		*repl = '/';
+	}
+#endif
 	STPUTC('\0', expdest);
 	argbackq = saveargbackq;
 	startp = (char *)stackblock() + startloc;
+	//bb_error_msg("str1:'%s'", (char *)stackblock() + strloc);
 
 	switch (subtype) {
 	case VSASSIGN:
@@ -6781,13 +6915,10 @@ subevalvar(char *p, char *varname, int s
 
 		loc = str = stackblock() + strloc;
 
-# if !ENABLE_FEATURE_SH_MATH
-#  define ash_arith number
-# endif
 		/* Read POS in ${var:POS:LEN} */
 		colon = strchr(loc, ':');
 		if (colon) *colon = '\0';
-		pos = ash_arith(loc);
+		pos = substr_atoi(loc);
 		if (colon) *colon = ':';
 
 		/* Read LEN in ${var:POS:LEN} */
@@ -6795,7 +6926,6 @@ subevalvar(char *p, char *varname, int s
 		/* *loc != '\0', guaranteed by parser */
 		if (quotes) {
 			char *ptr;
-
 			/* Adjust the length by the number of escapes */
 			for (ptr = startp; ptr < (str - 1); ptr++) {
 				if ((unsigned char)*ptr == CTLESC) {
@@ -6807,19 +6937,15 @@ subevalvar(char *p, char *varname, int s
 		orig_len = len;
 		if (*loc++ == ':') {
 			/* ${var::LEN} */
-			len = ash_arith(loc);
+			len = substr_atoi(loc);
 		} else {
 			/* Skip POS in ${var:POS:LEN} */
 			len = orig_len;
-			while (*loc && *loc != ':') {
+			while (*loc && *loc != ':')
 				loc++;
-			}
-			if (*loc++ == ':') {
-				len = ash_arith(loc);
-			}
+			if (*loc++ == ':')
+				len = substr_atoi(loc);
 		}
-#  undef ash_arith
-
 		if (pos < 0) {
 			/* ${VAR:$((-n)):l} starts n chars from the end */
 			pos = orig_len + pos;
@@ -6859,6 +6985,8 @@ subevalvar(char *p, char *varname, int s
 	resetloc = expdest - (char *)stackblock();
 
 #if BASH_PATTERN_SUBST
+	repl = NULL;
+
 	/* We'll comeback here if we grow the stack while handling
 	 * a VSREPLACE or VSREPLACEALL, since our pointers into the
 	 * stack will need rebasing, and we'll need to remove our work
@@ -6873,8 +7001,10 @@ subevalvar(char *p, char *varname, int s
 
 	rmesc = startp;
 	rmescend = (char *)stackblock() + strloc;
+	//bb_error_msg("str7:'%s'", rmescend);
 	if (quotes) {
-		rmesc = rmescapes(startp, RMESCAPE_ALLOC | RMESCAPE_GROW);
+//TODO: how to handle slash_pos here if string changes (shortens?)
+		rmesc = rmescapes(startp, RMESCAPE_ALLOC | RMESCAPE_GROW, NULL);
 		if (rmesc != startp) {
 			rmescend = expdest;
 			startp = (char *)stackblock() + startloc;
@@ -6887,12 +7017,13 @@ subevalvar(char *p, char *varname, int s
 	 * The result is a_\_z_c (not a\_\_z_c)!
 	 *
 	 * The search pattern and replace string treat backslashes differently!
-	 * RMESCAPE_SLASH causes preglob to work differently on the pattern
+	 * "&slash_pos" causes rmescapes() to work differently on the pattern
 	 * and string.  It's only used on the first call.
 	 */
-	preglob(str, IF_BASH_PATTERN_SUBST(
-		(subtype == VSREPLACE || subtype == VSREPLACEALL) && !repl ?
-			RMESCAPE_SLASH : ) 0);
+	//bb_error_msg("str8:'%s' slash_pos:%d", str, slash_pos);
+	rmescapes(str, RMESCAPE_GLOB,
+		repl ? NULL : (slash_pos < 0 ? NULL : &slash_pos)
+	);
 
 #if BASH_PATTERN_SUBST
 	workloc = expdest - (char *)stackblock();
@@ -6901,11 +7032,12 @@ subevalvar(char *p, char *varname, int s
 		char *idx, *end;
 
 		if (!repl) {
-			repl = strchr(str, CTLESC);
-			if (repl)
+			//bb_error_msg("str9:'%s' slash_pos:%d", str, slash_pos);
+			repl = nullstr;
+			if (slash_pos >= 0) {
+				repl = str + slash_pos;
 				*repl++ = '\0';
-			else
-				repl = nullstr;
+			}
 		}
 		//bb_error_msg("str:'%s' repl:'%s'", str, repl);
 
@@ -7071,7 +7203,7 @@ varvalue(char *name, int varflags, int f
 	case '-':
 		expdest = makestrspace(NOPTS, expdest);
 		for (i = NOPTS - 1; i >= 0; i--) {
-			if (optlist[i]) {
+			if (optlist[i] && optletters(i)) {
 				USTPUTC(optletters(i), expdest);
 				len++;
 			}
@@ -7425,7 +7557,7 @@ expandmeta(struct strlist *str /*, int f
 			INT_ON;
  nometa:
 			*exparg.lastp = str;
-			rmescapes(str->text, 0);
+			rmescapes(str->text, 0, NULL);
 			exparg.lastp = &str->next;
 			break;
 		default:	/* GLOB_NOSPACE */
@@ -7443,9 +7575,16 @@ expandmeta(struct strlist *str /*, int f
 /*
  * Do metacharacter (i.e. *, ?, [...]) expansion.
  */
-static void
-expmeta(char *expdir, char *enddir, char *name)
-{
+typedef struct exp_t {
+	char *dir;
+	unsigned dir_max;
+} exp_t;
+static void
+expmeta(exp_t *exp, char *name, unsigned name_len, unsigned expdir_len)
+{
+#define expdir exp->dir
+#define expdir_max exp->dir_max
+	char *enddir = expdir + expdir_len;
 	char *p;
 	const char *cp;
 	char *start;
@@ -7488,15 +7627,15 @@ expmeta(char *expdir, char *enddir, char
 		}
 	}
 	if (metaflag == 0) {    /* we've reached the end of the file name */
-		if (enddir != expdir)
-			metaflag++;
+		if (!expdir_len)
+			return;
 		p = name;
 		do {
 			if (*p == '\\')
 				p++;
 			*enddir++ = *p;
 		} while (*p++);
-		if (metaflag == 0 || lstat(expdir, &statb) >= 0)
+		if (lstat(expdir, &statb) == 0)
 			addfname(expdir);
 		return;
 	}
@@ -7509,19 +7648,14 @@ expmeta(char *expdir, char *enddir, char
 			*enddir++ = *p++;
 		} while (p < start);
 	}
-	if (enddir == expdir) {
+	*enddir = '\0';
+	cp = expdir;
+	expdir_len = enddir - cp;
+	if (!expdir_len)
 		cp = ".";
-	} else if (enddir == expdir + 1 && *expdir == '/') {
-		cp = "/";
-	} else {
-		cp = expdir;
-		enddir[-1] = '\0';
-	}
 	dirp = opendir(cp);
 	if (dirp == NULL)
 		return;
-	if (enddir != expdir)
-		enddir[-1] = '/';
 	if (*endname == 0) {
 		atend = 1;
 	} else {
@@ -7529,6 +7663,7 @@ expmeta(char *expdir, char *enddir, char
 		*endname = '\0';
 		endname += esc + 1;
 	}
+	name_len -= endname - name;
 	matchdot = 0;
 	p = start;
 	if (*p == '\\')
@@ -7543,16 +7678,30 @@ expmeta(char *expdir, char *enddir, char
 				strcpy(enddir, dp->d_name);
 				addfname(expdir);
 			} else {
-				for (p = enddir, cp = dp->d_name; (*p++ = *cp++) != '\0';)
-					continue;
-				p[-1] = '/';
-				expmeta(expdir, p, endname);
+				unsigned offset;
+				unsigned len;
+
+				p = stpcpy(enddir, dp->d_name);
+				*p = '/';
+
+				offset = p - expdir + 1;
+				len = offset + name_len + NAME_MAX;
+				if (len > expdir_max) {
+					len += PATH_MAX;
+					expdir = ckrealloc(expdir, len);
+					expdir_max = len;
+				}
+
+				expmeta(exp, endname, name_len, offset);
+				enddir = expdir + expdir_len;
 			}
 		}
 	}
 	closedir(dirp);
 	if (!atend)
 		endname[-esc - 1] = esc ? '\\' : '/';
+#undef expdir
+#undef expdir_max
 }
 
 static struct strlist *
@@ -7625,10 +7774,11 @@ expandmeta(struct strlist *str /*, int f
 	/* TODO - EXP_REDIR */
 
 	while (str) {
-		char *expdir;
+		exp_t exp;
 		struct strlist **savelastp;
 		struct strlist *sp;
 		char *p;
+		unsigned len;
 
 		if (fflag)
 			goto nometa;
@@ -7638,13 +7788,12 @@ expandmeta(struct strlist *str /*, int f
 
 		INT_OFF;
 		p = preglob(str->text, RMESCAPE_ALLOC | RMESCAPE_HEAP);
-		{
-			int i = strlen(str->text);
-//BUGGY estimation of how long expanded name can be
-			expdir = ckmalloc(i < 2048 ? 2048 : i+1);
-		}
-		expmeta(expdir, expdir, p);
-		free(expdir);
+		len = strlen(p);
+		exp.dir_max = len + PATH_MAX;
+		exp.dir = ckmalloc(exp.dir_max);
+
+		expmeta(&exp, p, len, 0);
+		free(exp.dir);
 		if (p != str->text)
 			free(p);
 		INT_ON;
@@ -7654,7 +7803,7 @@ expandmeta(struct strlist *str /*, int f
 			 */
  nometa:
 			*exparg.lastp = str;
-			rmescapes(str->text, 0);
+			rmescapes(str->text, 0, NULL);
 			exparg.lastp = &str->next;
 		} else {
 			*exparg.lastp = NULL;
@@ -8581,6 +8730,9 @@ calcsize(int funcblocksize, union node *
 		funcblocksize = calcsize(funcblocksize, n->nclist.next);
 		break;
 	case NDEFUN:
+		funcblocksize = calcsize(funcblocksize, n->ndefun.body);
+		funcblocksize += SHELL_ALIGN(strlen(n->ndefun.text) + 1);
+		break;
 	case NARG:
 		funcblocksize = sizenodelist(funcblocksize, n->narg.backquote);
 		funcblocksize += SHELL_ALIGN(strlen(n->narg.text) + 1); /* was funcstringsize += ... */
@@ -8656,6 +8808,7 @@ copynode(union node *n)
 		new->ncmd.redirect = copynode(n->ncmd.redirect);
 		new->ncmd.args = copynode(n->ncmd.args);
 		new->ncmd.assign = copynode(n->ncmd.assign);
+		new->ncmd.linno = n->ncmd.linno;
 		break;
 	case NPIPE:
 		new->npipe.cmdlist = copynodelist(n->npipe.cmdlist);
@@ -8666,6 +8819,7 @@ copynode(union node *n)
 	case NSUBSHELL:
 		new->nredir.redirect = copynode(n->nredir.redirect);
 		new->nredir.n = copynode(n->nredir.n);
+		new->nredir.linno = n->nredir.linno;
 		break;
 	case NAND:
 	case NOR:
@@ -8684,10 +8838,12 @@ copynode(union node *n)
 		new->nfor.var = nodeckstrdup(n->nfor.var);
 		new->nfor.body = copynode(n->nfor.body);
 		new->nfor.args = copynode(n->nfor.args);
+		new->nfor.linno = n->nfor.linno;
 		break;
 	case NCASE:
 		new->ncase.cases = copynode(n->ncase.cases);
 		new->ncase.expr = copynode(n->ncase.expr);
+		new->ncase.linno = n->ncase.linno;
 		break;
 	case NCLIST:
 		new->nclist.body = copynode(n->nclist.body);
@@ -8695,6 +8851,10 @@ copynode(union node *n)
 		new->nclist.next = copynode(n->nclist.next);
 		break;
 	case NDEFUN:
+		new->ndefun.body = copynode(n->ndefun.body);
+		new->ndefun.text = nodeckstrdup(n->ndefun.text);
+		new->ndefun.linno = n->ndefun.linno;
+		break;
 	case NARG:
 		new->narg.backquote = copynodelist(n->narg.backquote);
 		new->narg.text = nodeckstrdup(n->narg.text);
@@ -8763,7 +8923,7 @@ defun(union node *func)
 	INT_OFF;
 	entry.cmdtype = CMDFUNCTION;
 	entry.u.func = copyfunc(func);
-	addcmdentry(func->narg.text, &entry);
+	addcmdentry(func->ndefun.text, &entry);
 	INT_ON;
 }
 
@@ -8773,8 +8933,8 @@ defun(union node *func)
 #define SKIPFUNC       (1 << 2)
 static smallint evalskip;       /* set to SKIPxxx if we are skipping commands */
 static int skipcount;           /* number of levels to skip */
-static int funcnest;            /* depth of function calls */
 static int loopnest;            /* current loop nesting level */
+static int funcline;            /* starting line number of current function, or 0 if not in a function */
 
 /* Forward decl way out to parsing code - dotrap needs it */
 static int evalstring(char *s, int flags);
@@ -8869,6 +9029,9 @@ evaltree(union node *n, int flags)
 		status = !evaltree(n->nnot.com, EV_TESTED);
 		goto setstatus;
 	case NREDIR:
+		errlinno = lineno = n->nredir.linno;
+		if (funcline)
+			lineno -= funcline - 1;
 		expredir(n->nredir.redirect);
 		pushredir(n->nredir.redirect);
 		status = redirectsafe(n->nredir.redirect, REDIR_PUSH);
@@ -9023,6 +9186,10 @@ evalfor(union node *n, int flags)
 	struct stackmark smark;
 	int status = 0;
 
+	errlinno = lineno = n->ncase.linno;
+	if (funcline)
+		lineno -= funcline - 1;
+
 	setstackmark(&smark);
 	arglist.list = NULL;
 	arglist.lastp = &arglist.list;
@@ -9054,6 +9221,10 @@ evalcase(union node *n, int flags)
 	struct stackmark smark;
 	int status = 0;
 
+	errlinno = lineno = n->ncase.linno;
+	if (funcline)
+		lineno -= funcline - 1;
+
 	setstackmark(&smark);
 	arglist.list = NULL;
 	arglist.lastp = &arglist.list;
@@ -9088,6 +9259,10 @@ evalsubshell(union node *n, int flags)
 	int backgnd = (n->type == NBACKGND); /* FORK_BG(1) if yes, else FORK_FG(0) */
 	int status;
 
+	errlinno = lineno = n->nredir.linno;
+	if (funcline)
+		lineno -= funcline - 1;
+
 	expredir(n->nredir.redirect);
 	if (!backgnd && (flags & EV_EXIT) && !may_have_traps)
 		goto nofork;
@@ -9395,8 +9570,10 @@ evalfun(struct funcnode *func, int argc,
 	struct jmploc *volatile savehandler;
 	struct jmploc jmploc;
 	int e;
+	int savefuncline;
 
 	saveparam = shellparam;
+	savefuncline = funcline;
 	savehandler = exception_handler;
 	e = setjmp(jmploc.loc);
 	if (e) {
@@ -9406,7 +9583,7 @@ evalfun(struct funcnode *func, int argc,
 	exception_handler = &jmploc;
 	shellparam.malloced = 0;
 	func->count++;
-	funcnest++;
+	funcline = func->n.ndefun.linno;
 	INT_ON;
 	shellparam.nparam = argc - 1;
 	shellparam.p = argv + 1;
@@ -9415,11 +9592,11 @@ evalfun(struct funcnode *func, int argc,
 	shellparam.optoff = -1;
 #endif
 	pushlocalvars();
-	evaltree(func->n.narg.next, flags & EV_TESTED);
+	evaltree(func->n.ndefun.body, flags & EV_TESTED);
 	poplocalvars(0);
  funcdone:
 	INT_OFF;
-	funcnest--;
+	funcline = savefuncline;
 	freefunc(func);
 	freeparam(&shellparam);
 	shellparam = saveparam;
@@ -9783,6 +9960,10 @@ evalcommand(union node *cmd, int flags)
 	char **nargv;
 	smallint cmd_is_exec;
 
+	errlinno = lineno = cmd->ncmd.linno;
+	if (funcline)
+		lineno -= funcline - 1;
+
 	/* First expand the arguments. */
 	TRACE(("evalcommand(0x%lx, %d) called\n", (long)cmd, flags));
 	setstackmark(&smark);
@@ -9828,7 +10009,7 @@ evalcommand(union node *cmd, int flags)
 	*nargv = NULL;
 
 	lastarg = NULL;
-	if (iflag && funcnest == 0 && argc > 0)
+	if (iflag && funcline == 0 && argc > 0)
 		lastarg = nargv[-1];
 
 	expredir(cmd->ncmd.redirect);
@@ -9958,7 +10139,9 @@ evalcommand(union node *cmd, int flags)
 	switch (cmdentry.cmdtype) {
 	default: {
 
-#if ENABLE_FEATURE_SH_NOFORK && NUM_APPLETS > 1
+#if ENABLE_FEATURE_SH_STANDALONE \
+ && ENABLE_FEATURE_SH_NOFORK \
+ && NUM_APPLETS > 1
 /* (1) BUG: if variables are set, we need to fork, or save/restore them
  *     around run_nofork_applet() call.
  * (2) Should this check also be done in forkshell()?
@@ -10514,6 +10697,34 @@ pgetc_eatbnl(void)
 	return c;
 }
 
+struct synstack {
+	smalluint syntax;
+	uint8_t innerdq   :1;
+	uint8_t varpushed :1;
+	uint8_t dblquote  :1;
+	int varnest;		/* levels of variables expansion */
+	int dqvarnest;		/* levels of variables expansion within double quotes */
+	int parenlevel;		/* levels of parens in arithmetic */
+	struct synstack *prev;
+	struct synstack *next;
+};
+
+static void
+synstack_push(struct synstack **stack, struct synstack *next, int syntax)
+{
+	memset(next, 0, sizeof(*next));
+	next->syntax = syntax;
+	next->next = *stack;
+	(*stack)->prev = next;
+	*stack = next;
+}
+
+static ALWAYS_INLINE void
+synstack_pop(struct synstack **stack)
+{
+	*stack = (*stack)->next;
+}
+
 /*
  * To handle the "." command, a stack of input files is used.  Pushfile
  * adds a new entry to the stack and popfile restores the previous level.
@@ -10604,7 +10815,7 @@ setinputfile(const char *fname, int flag
 	int fd;
 
 	INT_OFF;
-	fd = open(fname, O_RDONLY);
+	fd = open(fname, O_RDONLY | O_CLOEXEC);
 	if (fd < 0) {
 		if (flags & INPUT_NOFILE_OK)
 			goto out;
@@ -10613,8 +10824,9 @@ setinputfile(const char *fname, int flag
 	}
 	if (fd < 10)
 		fd = savefd(fd);
-	else
+	else if (O_CLOEXEC == 0) /* old libc */
 		close_on_exec_on(fd);
+
 	setinputfd(fd, flags & INPUT_PUSH_FILE);
  out:
 	INT_ON;
@@ -11334,7 +11546,7 @@ parsefname(void)
 		if (quoteflag == 0)
 			n->type = NXHERE;
 		TRACE(("Here document %d\n", n->type));
-		rmescapes(wordtext, 0);
+		rmescapes(wordtext, 0, NULL);
 		here->eofmark = wordtext;
 		here->next = NULL;
 		if (heredoclist == NULL)
@@ -11359,6 +11571,7 @@ simplecmd(void)
 	union node *vars, **vpp;
 	union node **rpp, *redir;
 	int savecheckkwd;
+	int savelinno;
 #if BASH_TEST2
 	smallint double_brackets_flag = 0;
 #endif
@@ -11372,6 +11585,7 @@ simplecmd(void)
 	rpp = &redir;
 
 	savecheckkwd = CHKALIAS;
+	savelinno = g_parsefile->linno;
 	for (;;) {
 		int t;
 		checkkwd = savecheckkwd;
@@ -11427,10 +11641,12 @@ simplecmd(void)
 				case TLP:
 					function_flag = 0;
 					break;
+# if BASH_TEST2
 				case TWORD:
 					if (strcmp("[[", wordtext) == 0)
 						goto do_func;
 					/* fall through */
+# endif
 				default:
 					raise_error_unexpected_syntax(-1);
 				}
@@ -11461,7 +11677,9 @@ simplecmd(void)
 				}
 				n->type = NDEFUN;
 				checkkwd = CHKNL | CHKKWD | CHKALIAS;
-				n->narg.next = parse_command();
+				n->ndefun.text = n->narg.text;
+				n->ndefun.linno = g_parsefile->linno;
+				n->ndefun.body = parse_command();
 				return n;
 			}
 			IF_BASH_FUNCTION(function_flag = 0;)
@@ -11476,7 +11694,9 @@ simplecmd(void)
 	*vpp = NULL;
 	*rpp = NULL;
 	n = stzalloc(sizeof(struct ncmd));
-	n->type = NCMD;
+	if (NCMD != 0)
+		n->type = NCMD;
+	n->ncmd.linno = savelinno;
 	n->ncmd.args = args;
 	n->ncmd.assign = vars;
 	n->ncmd.redirect = redir;
@@ -11492,10 +11712,13 @@ parse_command(void)
 	union node *redir, **rpp;
 	union node **rpp2;
 	int t;
+	int savelinno;
 
 	redir = NULL;
 	rpp2 = &redir;
 
+	savelinno = g_parsefile->linno;
+
 	switch (readtoken()) {
 	default:
 		raise_error_unexpected_syntax(-1);
@@ -11546,6 +11769,7 @@ parse_command(void)
 			raise_error_syntax("bad for loop variable");
 		n1 = stzalloc(sizeof(struct nfor));
 		n1->type = NFOR;
+		n1->nfor.linno = savelinno;
 		n1->nfor.var = wordtext;
 		checkkwd = CHKNL | CHKKWD | CHKALIAS;
 		if (readtoken() == TIN) {
@@ -11586,6 +11810,7 @@ parse_command(void)
 	case TCASE:
 		n1 = stzalloc(sizeof(struct ncase));
 		n1->type = NCASE;
+		n1->ncase.linno = savelinno;
 		if (readtoken() != TWORD)
 			raise_error_unexpected_syntax(TWORD);
 		n1->ncase.expr = n2 = stzalloc(sizeof(struct narg));
@@ -11637,6 +11862,7 @@ parse_command(void)
 	case TLP:
 		n1 = stzalloc(sizeof(struct nredir));
 		n1->type = NSUBSHELL;
+		n1->nredir.linno = savelinno;
 		n1->nredir.n = list(0);
 		/*n1->nredir.redirect = NULL; - stzalloc did it */
 		t = TRP;
@@ -11670,6 +11896,7 @@ parse_command(void)
 		if (n1->type != NSUBSHELL) {
 			n2 = stzalloc(sizeof(struct nredir));
 			n2->type = NREDIR;
+			n2->nredir.linno = savelinno;
 			n2->nredir.n = n1;
 			n1 = n2;
 		}
@@ -11760,21 +11987,13 @@ readtoken1(int c, int syntax, char *eofm
 	size_t len;
 	struct nodelist *bqlist;
 	smallint quotef;
-	smallint dblquote;
 	smallint oldstyle;
-	IF_FEATURE_SH_MATH(smallint prevsyntax;) /* syntax before arithmetic */
 	smallint pssyntax;   /* we are expanding a prompt string */
-	int varnest;         /* levels of variables expansion */
-	IF_FEATURE_SH_MATH(int arinest;)    /* levels of arithmetic expansion */
-	IF_FEATURE_SH_MATH(int parenlevel;) /* levels of parens in arithmetic */
-	int dqvarnest;       /* levels of variables expansion within double quotes */
-
 	IF_BASH_DOLLAR_SQUOTE(smallint bash_dollar_squote = 0;)
+	/* syntax stack */
+	struct synstack synbase = { };
+	struct synstack *synstack = &synbase;
 
-	startlinno = g_parsefile->linno;
-	bqlist = NULL;
-	quotef = 0;
-	IF_FEATURE_SH_MATH(prevsyntax = 0;)
 #if ENABLE_ASH_EXPAND_PRMT
 	pssyntax = (syntax == PSSYNTAX);
 	if (pssyntax)
@@ -11782,11 +12001,12 @@ readtoken1(int c, int syntax, char *eofm
 #else
 	pssyntax = 0; /* constant */
 #endif
-	dblquote = (syntax == DQSYNTAX);
-	varnest = 0;
-	IF_FEATURE_SH_MATH(arinest = 0;)
-	IF_FEATURE_SH_MATH(parenlevel = 0;)
-	dqvarnest = 0;
+	synstack->syntax = syntax;
+
+	if (syntax == DQSYNTAX)
+		synstack->dblquote = 1;
+	quotef = 0;
+	bqlist = NULL;
 
 	STARTSTACKSTR(out);
  loop:
@@ -11794,10 +12014,13 @@ readtoken1(int c, int syntax, char *eofm
 	CHECKEND();     /* set c to PEOF if at end of here document */
 	for (;;) {      /* until end of line or end of word */
 		CHECKSTRSPACE(4, out);  /* permit 4 calls to USTPUTC */
-		switch (SIT(c, syntax)) {
+		switch (SIT(c, synstack->syntax)) {
 		case CNL:       /* '\n' */
-			if (syntax == BASESYNTAX)
+			if (synstack->syntax == BASESYNTAX
+			 && !synstack->varnest
+			) {
 				goto endword;   /* exit outer loop */
+			}
 			USTPUTC(c, out);
 			nlprompt();
 			c = pgetc();
@@ -11816,13 +12039,13 @@ readtoken1(int c, int syntax, char *eofm
 				if (c & 0x100) {
 					/* Unknown escape. Encode as '\z' */
 					c = (unsigned char)c;
-					if (eofmark == NULL || dblquote)
+					if (eofmark == NULL || synstack->dblquote)
 						USTPUTC(CTLESC, out);
 					USTPUTC('\\', out);
 				}
 			}
 #endif
-			if (eofmark == NULL || dblquote)
+			if (!eofmark || synstack->dblquote || synstack->varnest)
 				USTPUTC(CTLESC, out);
 			USTPUTC(c, out);
 			break;
@@ -11839,13 +12062,17 @@ readtoken1(int c, int syntax, char *eofm
 					USTPUTC(CTLESC, out);
 					USTPUTC('\\', out);
 				}
-				/* Backslash is retained if we are in "str" and next char isn't special */
-				if (dblquote
+				/* Backslash is retained if we are in "str"
+				 * and next char isn't dquote-special.
+				 */
+				if (synstack->dblquote
 				 && c != '\\'
 				 && c != '`'
 				 && c != '$'
-				 && (c != '"' || eofmark != NULL)
+				 && (c != '"' || (eofmark != NULL && !synstack->varnest))
+				 && (c != '}' || !synstack->varnest)
 				) {
+					USTPUTC(CTLESC, out); /* protect '\' from glob */
 					USTPUTC('\\', out);
 				}
 				USTPUTC(CTLESC, out);
@@ -11854,56 +12081,62 @@ readtoken1(int c, int syntax, char *eofm
 			}
 			break;
 		case CSQUOTE:
-			syntax = SQSYNTAX;
+			synstack->syntax = SQSYNTAX;
  quotemark:
 			if (eofmark == NULL) {
 				USTPUTC(CTLQUOTEMARK, out);
 			}
 			break;
 		case CDQUOTE:
-			syntax = DQSYNTAX;
-			dblquote = 1;
+			synstack->syntax = DQSYNTAX;
+			synstack->dblquote = 1;
+ toggledq:
+			if (synstack->varnest)
+				synstack->innerdq ^= 1;
 			goto quotemark;
 		case CENDQUOTE:
 			IF_BASH_DOLLAR_SQUOTE(bash_dollar_squote = 0;)
-			if (eofmark != NULL && varnest == 0) {
+			if (eofmark != NULL && synstack->varnest == 0) {
 				USTPUTC(c, out);
-			} else {
-				if (dqvarnest == 0) {
-					syntax = BASESYNTAX;
-					dblquote = 0;
-				}
-				quotef = 1;
-				goto quotemark;
+				break;
 			}
-			break;
+
+			if (synstack->dqvarnest == 0) {
+				synstack->syntax = BASESYNTAX;
+				synstack->dblquote = 0;
+			}
+
+			quotef = 1;
+
+			if (c == '"')
+				goto toggledq;
+
+			goto quotemark;
 		case CVAR:      /* '$' */
 			PARSESUB();             /* parse substitution */
 			break;
 		case CENDVAR:   /* '}' */
-			if (varnest > 0) {
-				varnest--;
-				if (dqvarnest > 0) {
-					dqvarnest--;
-				}
+			if (!synstack->innerdq && synstack->varnest > 0) {
+				if (!--synstack->varnest && synstack->varpushed)
+					synstack_pop(&synstack);
+				else if (synstack->dqvarnest > 0)
+					synstack->dqvarnest--;
 				c = CTLENDVAR;
 			}
 			USTPUTC(c, out);
 			break;
 #if ENABLE_FEATURE_SH_MATH
 		case CLP:       /* '(' in arithmetic */
-			parenlevel++;
+			synstack->parenlevel++;
 			USTPUTC(c, out);
 			break;
 		case CRP:       /* ')' in arithmetic */
-			if (parenlevel > 0) {
-				parenlevel--;
+			if (synstack->parenlevel > 0) {
+				synstack->parenlevel--;
 			} else {
 				if (pgetc_eatbnl() == ')') {
 					c = CTLENDARI;
-					if (--arinest == 0) {
-						syntax = prevsyntax;
-					}
+					synstack_pop(&synstack);
 				} else {
 					/*
 					 * unbalanced parens
@@ -11916,6 +12149,12 @@ readtoken1(int c, int syntax, char *eofm
 			break;
 #endif
 		case CBQUOTE:   /* '`' */
+			if (checkkwd & CHKEOFMARK) {
+				quotef = 1;
+				USTPUTC('`', out);
+				break;
+			}
+
 			PARSEBACKQOLD();
 			break;
 		case CENDFILE:
@@ -11923,7 +12162,7 @@ readtoken1(int c, int syntax, char *eofm
 		case CIGN:
 			break;
 		default:
-			if (varnest == 0) {
+			if (synstack->varnest == 0) {
 #if BASH_REDIR_OUTPUT
 				if (c == '&') {
 //Can't call pgetc_eatbnl() here, this requires three-deep pungetc()
@@ -11942,13 +12181,12 @@ readtoken1(int c, int syntax, char *eofm
  endword:
 
 #if ENABLE_FEATURE_SH_MATH
-	if (syntax == ARISYNTAX)
+	if (synstack->syntax == ARISYNTAX)
 		raise_error_syntax("missing '))'");
 #endif
-	if (syntax != BASESYNTAX && eofmark == NULL)
+	if (synstack->syntax != BASESYNTAX && eofmark == NULL)
 		raise_error_syntax("unterminated quoted string");
-	if (varnest != 0) {
-		startlinno = g_parsefile->linno;
+	if (synstack->varnest != 0) {
 		/* { */
 		raise_error_syntax("missing '}'");
 	}
@@ -12049,7 +12287,7 @@ parseredir: {
 	np = stzalloc(sizeof(struct nfile));
 	if (c == '>') {
 		np->nfile.fd = 1;
-		c = pgetc();
+		c = pgetc_eatbnl();
 		if (c == '>')
 			np->type = NAPPEND;
 		else if (c == '|')
@@ -12071,7 +12309,7 @@ parseredir: {
 #endif
 	else { /* c == '<' */
 		/*np->nfile.fd = 0; - stzalloc did it */
-		c = pgetc();
+		c = pgetc_eatbnl();
 		switch (c) {
 		case '<':
 			if (sizeof(struct nfile) != sizeof(struct nhere)) {
@@ -12081,7 +12319,7 @@ parseredir: {
 			np->type = NHERE;
 			heredoc = stzalloc(sizeof(struct heredoc));
 			heredoc->here = np;
-			c = pgetc();
+			c = pgetc_eatbnl();
 			if (c == '-') {
 				heredoc->striptabs = 1;
 			} else {
@@ -12130,7 +12368,7 @@ parsesub: {
 	 || (c != '(' && c != '{' && !is_name(c) && !is_special(c))
 	) {
 #if BASH_DOLLAR_SQUOTE
-		if (syntax != DQSYNTAX && c == '\'')
+		if (synstack->syntax != DQSYNTAX && c == '\'')
 			bash_dollar_squote = 1;
 		else
 #endif
@@ -12150,6 +12388,8 @@ parsesub: {
 		}
 	} else {
 		/* $VAR, $<specialchar>, ${...}, or PEOA/PEOF */
+		smalluint newsyn = synstack->syntax;
+
 		USTPUTC(CTLVAR, out);
 		typeloc = out - (char *)stackblock();
 		STADJUST(1, out);
@@ -12208,6 +12448,8 @@ parsesub: {
 			static const char types[] ALIGN1 = "}-+?=";
 			/* ${VAR...} but not $VAR or ${#VAR} */
 			/* c == first char after VAR */
+			int cc = c;
+
 			switch (c) {
 			case ':':
 				c = pgetc_eatbnl();
@@ -12232,21 +12474,24 @@ parsesub: {
 				break;
 			}
 			case '%':
-			case '#': {
-				int cc = c;
+			case '#':
 				subtype = (c == '#' ? VSTRIMLEFT : VSTRIMRIGHT);
 				c = pgetc_eatbnl();
-				if (c != cc)
-					goto badsub;
-				subtype++;
+				if (c == cc)
+					subtype++;
+				else
+					pungetc();
+
+				newsyn = BASESYNTAX;
 				break;
-			}
 #if BASH_PATTERN_SUBST
 			case '/':
 				/* ${v/[/]pattern/repl} */
 //TODO: encode pattern and repl separately.
-// Currently ${v/$var_with_slash/repl} is horribly broken
+// Currently cases like: v=1;echo ${v/$((1/1))/ONE}
+// are broken (should print "ONE")
 				subtype = VSREPLACE;
+				newsyn = BASESYNTAX;
 				c = pgetc_eatbnl();
 				if (c != '/')
 					goto badsub;
@@ -12258,11 +12503,26 @@ parsesub: {
  badsub:
 			pungetc();
 		}
+
+		if (newsyn == ARISYNTAX)
+			newsyn = DQSYNTAX;
+
+		if ((newsyn != synstack->syntax || synstack->innerdq)
+		 && subtype != VSNORMAL
+		) {
+			synstack_push(&synstack,
+				synstack->prev ?: alloca(sizeof(*synstack)),
+				newsyn);
+
+			synstack->varpushed = 1;
+			synstack->dblquote = newsyn != BASESYNTAX;
+		}
+
 		((unsigned char *)stackblock())[typeloc] = subtype;
 		if (subtype != VSNORMAL) {
-			varnest++;
-			if (dblquote)
-				dqvarnest++;
+			synstack->varnest++;
+			if (synstack->dblquote)
+				synstack->dqvarnest++;
 		}
 		STPUTC('=', out);
 	}
@@ -12311,25 +12571,15 @@ parsebackq: {
 			int pc;
 
 			setprompt_if(needprompt, 2);
-			pc = pgetc();
+			pc = pgetc_eatbnl();
 			switch (pc) {
 			case '`':
 				goto done;
 
 			case '\\':
-				pc = pgetc();
-				if (pc == '\n') {
-					nlprompt();
-					/*
-					 * If eating a newline, avoid putting
-					 * the newline into the new character
-					 * stream (via the STPUTC after the
-					 * switch).
-					 */
-					continue;
-				}
+				pc = pgetc(); /* or pgetc_eatbnl()? why (example)? */
 				if (pc != '\\' && pc != '`' && pc != '$'
-				 && (!dblquote || pc != '"')
+				 && (!synstack->dblquote || pc != '"')
 				) {
 					STPUTC('\\', pout);
 				}
@@ -12340,7 +12590,6 @@ parsebackq: {
 
 			case PEOF:
 			IF_ASH_ALIAS(case PEOA:)
-				startlinno = g_parsefile->linno;
 				raise_error_syntax("EOF in backquote substitution");
 
 			case '\n':
@@ -12405,10 +12654,11 @@ parsebackq: {
  * Parse an arithmetic expansion (indicate start of one and set state)
  */
 parsearith: {
-	if (++arinest == 1) {
-		prevsyntax = syntax;
-		syntax = ARISYNTAX;
-	}
+
+	synstack_push(&synstack,
+			synstack->prev ?: alloca(sizeof(*synstack)),
+			ARISYNTAX);
+	synstack->dblquote = 1;
 	USTPUTC(CTLARI, out);
 	goto parsearith_return;
 }
@@ -12422,8 +12672,6 @@ parsearith: {
  *      quoted.
  * If the token is TREDIR, then we set redirnode to a structure containing
  *      the redirection.
- * In all cases, the variable startlinno is set to the number of the line
- *      on which the token starts.
  *
  * [Change comment:  here documents and internal procedures]
  * [Readtoken shouldn't have any arguments.  Perhaps we should make the
@@ -12461,9 +12709,8 @@ xxreadtoken(void)
 		return lasttoken;
 	}
 	setprompt_if(needprompt, 2);
-	startlinno = g_parsefile->linno;
 	for (;;) {                      /* until token or start of word found */
-		c = pgetc();
+		c = pgetc_eatbnl();
 		if (c == ' ' || c == '\t' IF_ASH_ALIAS( || c == PEOA))
 			continue;
 
@@ -12472,11 +12719,7 @@ xxreadtoken(void)
 				continue;
 			pungetc();
 		} else if (c == '\\') {
-			if (pgetc() != '\n') {
-				pungetc();
-				break; /* return readtoken1(...) */
-			}
-			nlprompt();
+			break; /* return readtoken1(...) */
 		} else {
 			const char *p;
 
@@ -12491,7 +12734,7 @@ xxreadtoken(void)
 					break; /* return readtoken1(...) */
 
 				if ((int)(p - xxreadtoken_chars) >= xxreadtoken_singles) {
-					int cc = pgetc();
+					int cc = pgetc_eatbnl();
 					if (cc == c) {    /* double occurrence? */
 						p += xxreadtoken_doubles + 1;
 					} else {
@@ -12522,9 +12765,8 @@ xxreadtoken(void)
 		return lasttoken;
 	}
 	setprompt_if(needprompt, 2);
-	startlinno = g_parsefile->linno;
 	for (;;) {      /* until token or start of word found */
-		c = pgetc();
+		c = pgetc_eatbnl();
 		switch (c) {
 		case ' ': case '\t':
 		IF_ASH_ALIAS(case PEOA:)
@@ -12534,30 +12776,23 @@ xxreadtoken(void)
 				continue;
 			pungetc();
 			continue;
-		case '\\':
-			if (pgetc() == '\n') {
-				nlprompt();
-				continue;
-			}
-			pungetc();
-			goto breakloop;
 		case '\n':
 			nlnoprompt();
 			RETURN(TNL);
 		case PEOF:
 			RETURN(TEOF);
 		case '&':
-			if (pgetc() == '&')
+			if (pgetc_eatbnl() == '&')
 				RETURN(TAND);
 			pungetc();
 			RETURN(TBACKGND);
 		case '|':
-			if (pgetc() == '|')
+			if (pgetc_eatbnl() == '|')
 				RETURN(TOR);
 			pungetc();
 			RETURN(TPIPE);
 		case ';':
-			if (pgetc() == ';')
+			if (pgetc_eatbnl() == ';')
 				RETURN(TENDCASE);
 			pungetc();
 			RETURN(TSEMI);
@@ -12565,11 +12800,9 @@ xxreadtoken(void)
 			RETURN(TLP);
 		case ')':
 			RETURN(TRP);
-		default:
-			goto breakloop;
 		}
+		break;
 	}
- breakloop:
 	return readtoken1(c, BASESYNTAX, (char *)NULL, 0);
 #undef RETURN
 }
@@ -12914,10 +13147,14 @@ find_dot_file(char *name)
 		if (fullname != name)
 			stunalloc(fullname);
 	}
+	/* not found in PATH */
 
-	/* not found in the PATH */
+#if ENABLE_ASH_BASH_SOURCE_CURDIR
+	return name;
+#else
 	ash_msg_and_raise_error("%s: not found", name);
 	/* NOTREACHED */
+#endif
 }
 
 static int FAST_FUNC
@@ -13172,8 +13409,21 @@ find_command(char *name, struct cmdentry
 	/* We failed.  If there was an entry for this command, delete it */
 	if (cmdp && updatetbl)
 		delete_cmd_entry();
-	if (act & DO_ERR)
+	if (act & DO_ERR) {
+#if ENABLE_ASH_BASH_NOT_FOUND_HOOK
+		struct tblentry *hookp = cmdlookup("command_not_found_handle", 0);
+		if (hookp && hookp->cmdtype == CMDFUNCTION) {
+			char *argv[3];
+			argv[0] = (char*) "command_not_found_handle";
+			argv[1] = name;
+			argv[2] = NULL;
+			evalfun(hookp->param.func, 2, argv, 0);
+			entry->cmdtype = CMDUNKNOWN;
+			return;
+		}
+#endif
 		ash_msg("%s: %s", name, errmsg(e, "not found"));
+	}
 	entry->cmdtype = CMDUNKNOWN;
 	return;
 
@@ -13733,7 +13983,7 @@ init(void)
 
 
 //usage:#define ash_trivial_usage
-//usage:	"[-/+OPTIONS] [-/+o OPT]... [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS]]"
+//usage:	"[-/+OPTIONS] [-/+o OPT]... [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS] / -s [ARGS]]"
 //usage:#define ash_full_usage "\n\n"
 //usage:	"Unix shell interpreter"
 
diff -urpN busybox-1.28.4/shell/ash_LINENO.patch busybox-1.29.0/shell/ash_LINENO.patch
--- busybox-1.28.4/shell/ash_LINENO.patch	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_LINENO.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,498 +0,0 @@
-This patch is a backport from dash of the combination of:
-	[SHELL] Add preliminary LINENO support
-	[VAR] Fix varinit ordering that broke fc
-	[SHELL] Improve LINENO support
-
-Applies cleanly on top of:
-	commit 9832bbaba966f0e52e183f10cd93fad7f8f643fe
-	Date: Tue Aug 15 15:44:41 2017 +0200
-
-Testsuite needs some tweaks (line numbers in some messages change).
-
-Unfortunately, it is somewhat big:
-
-function                                             old     new   delta
-parse_command                                       1581    1658     +77
-calcsize                                             203     272     +69
-copynode                                             195     257     +62
-lookupvar                                             59     108     +49
-evaltree                                             494     534     +40
-evalfor                                              152     187     +35
-evalcase                                             278     313     +35
-evalcommand                                         1547    1581     +34
-evalsubshell                                         169     199     +30
-linenovar                                              -      22     +22
-raise_error_syntax                                    11      29     +18
-evalfun                                              266     280     +14
-varinit_data                                          96     108     +12
-cmdtxt                                               626     631      +5
-lineno                                                 -       4      +4
-funcline                                               -       4      +4
-ash_vmsg                                             144     141      -3
-startlinno                                             4       -      -4
-funcnest                                               4       -      -4
-xxreadtoken                                          272     259     -13
-readtoken1                                          2635    2594     -41
-------------------------------------------------------------------------------
-(add/remove: 3/2 grow/shrink: 13/3 up/down: 510/-65)          Total: 445 bytes
-   text	   data	    bss	    dec	    hex	filename
- 912030	    563	   5844	 918437	  e03a5	busybox_old
- 912473	    587	   5844	 918904	  e0578	busybox_unstripped
-
-diff --git a/shell/ash.c b/shell/ash.c
-index 703802f..93a3814 100644
---- a/shell/ash.c
-+++ b/shell/ash.c
-@@ -312,6 +312,8 @@ struct globals_misc {
- 	/* shell level: 0 for the main shell, 1 for its children, and so on */
- 	int shlvl;
- #define rootshell (!shlvl)
-+	int errlinno;
-+
- 	char *minusc;  /* argument to -c option */
- 
- 	char *curdir; // = nullstr;     /* current working directory */
-@@ -389,6 +391,7 @@ extern struct globals_misc *const ash_ptr_to_globals_misc;
- #define job_warning       (G_misc.job_warning)
- #define rootpid     (G_misc.rootpid    )
- #define shlvl       (G_misc.shlvl      )
-+#define errlinno    (G_misc.errlinno   )
- #define minusc      (G_misc.minusc     )
- #define curdir      (G_misc.curdir     )
- #define physdir     (G_misc.physdir    )
-@@ -723,6 +726,7 @@ union node;
- 
- struct ncmd {
- 	smallint type; /* Nxxxx */
-+	int linno;
- 	union node *assign;
- 	union node *args;
- 	union node *redirect;
-@@ -736,6 +740,7 @@ struct npipe {
- 
- struct nredir {
- 	smallint type;
-+	int linno;
- 	union node *n;
- 	union node *redirect;
- };
-@@ -755,6 +760,7 @@ struct nif {
- 
- struct nfor {
- 	smallint type;
-+	int linno;
- 	union node *args;
- 	union node *body;
- 	char *var;
-@@ -762,6 +768,7 @@ struct nfor {
- 
- struct ncase {
- 	smallint type;
-+	int linno;
- 	union node *expr;
- 	union node *cases;
- };
-@@ -773,6 +780,13 @@ struct nclist {
- 	union node *body;
- };
- 
-+struct ndefun {
-+	smallint type;
-+	int linno;
-+	char *text;
-+	union node *body;
-+};
-+
- struct narg {
- 	smallint type;
- 	union node *next;
-@@ -824,6 +838,7 @@ union node {
- 	struct nfor nfor;
- 	struct ncase ncase;
- 	struct nclist nclist;
-+	struct ndefun ndefun;
- 	struct narg narg;
- 	struct nfile nfile;
- 	struct ndup ndup;
-@@ -1253,7 +1268,6 @@ struct parsefile {
- 
- static struct parsefile basepf;        /* top level input file */
- static struct parsefile *g_parsefile = &basepf;  /* current input file */
--static int startlinno;                 /* line # where last token started */
- static char *commandname;              /* currently executing command */
- 
- 
-@@ -1267,7 +1281,7 @@ ash_vmsg(const char *msg, va_list ap)
- 		if (strcmp(arg0, commandname))
- 			fprintf(stderr, "%s: ", commandname);
- 		if (!iflag || g_parsefile->pf_fd > 0)
--			fprintf(stderr, "line %d: ", startlinno);
-+			fprintf(stderr, "line %d: ", errlinno);
- 	}
- 	vfprintf(stderr, msg, ap);
- 	newline_and_flush(stderr);
-@@ -1327,6 +1341,7 @@ static void raise_error_syntax(const char *) NORETURN;
- static void
- raise_error_syntax(const char *msg)
- {
-+	errlinno = g_parsefile->linno;
- 	ash_msg_and_raise_error("syntax error: %s", msg);
- 	/* NOTREACHED */
- }
-@@ -1993,6 +2008,9 @@ static void changepath(const char *) FAST_FUNC;
- static void change_random(const char *) FAST_FUNC;
- #endif
- 
-+static int lineno;
-+static char linenovar[sizeof("LINENO=%d") + sizeof(int)*3] = "LINENO=";
-+
- static const struct {
- 	int flags;
- 	const char *var_text;
-@@ -2014,6 +2032,7 @@ static const struct {
- #if ENABLE_ASH_GETOPTS
- 	{ VSTRFIXED|VTEXTFIXED       , defoptindvar, getoptsreset    },
- #endif
-+	{ VSTRFIXED|VTEXTFIXED       , linenovar   , NULL            },
- #if ENABLE_ASH_RANDOM_SUPPORT
- 	{ VSTRFIXED|VTEXTFIXED|VUNSET|VDYNAMIC, "RANDOM", change_random },
- #endif
-@@ -2066,12 +2085,14 @@ extern struct globals_var *const ash_ptr_to_globals_var;
- #define vps4      (&vps2)[1]
- #if ENABLE_ASH_GETOPTS
- # define voptind  (&vps4)[1]
-+# define vlineno  (&voptind)[1]
- # if ENABLE_ASH_RANDOM_SUPPORT
--#  define vrandom (&voptind)[1]
-+#  define vrandom (&vlineno)[1]
- # endif
- #else
-+# define vlineno  (&vps4)[1]
- # if ENABLE_ASH_RANDOM_SUPPORT
--#  define vrandom (&vps4)[1]
-+#  define vrandom (&vlineno)[1]
- # endif
- #endif
- 
-@@ -2209,8 +2230,12 @@ lookupvar(const char *name)
- 		if (v->flags & VDYNAMIC)
- 			v->var_func(NULL);
- #endif
--		if (!(v->flags & VUNSET))
-+		if (!(v->flags & VUNSET)) {
-+			if (v == &vlineno && v->var_text == linenovar) {
-+				fmtstr(linenovar+7, sizeof(linenovar)-7, "%d", lineno);
-+			}
- 			return var_end(v->var_text);
-+		}
- 	}
- 	return NULL;
- }
-@@ -4783,7 +4808,7 @@ cmdtxt(union node *n)
- 		p = "; done";
- 		goto dodo;
- 	case NDEFUN:
--		cmdputs(n->narg.text);
-+		cmdputs(n->ndefun.text);
- 		p = "() { ... }";
- 		goto dotail2;
- 	case NCMD:
-@@ -8551,6 +8576,9 @@ calcsize(int funcblocksize, union node *n)
- 		funcblocksize = calcsize(funcblocksize, n->nclist.next);
- 		break;
- 	case NDEFUN:
-+		funcblocksize = calcsize(funcblocksize, n->ndefun.body);
-+		funcblocksize += SHELL_ALIGN(strlen(n->ndefun.text) + 1);
-+		break;
- 	case NARG:
- 		funcblocksize = sizenodelist(funcblocksize, n->narg.backquote);
- 		funcblocksize += SHELL_ALIGN(strlen(n->narg.text) + 1); /* was funcstringsize += ... */
-@@ -8626,6 +8654,7 @@ copynode(union node *n)
- 		new->ncmd.redirect = copynode(n->ncmd.redirect);
- 		new->ncmd.args = copynode(n->ncmd.args);
- 		new->ncmd.assign = copynode(n->ncmd.assign);
-+		new->ncmd.linno = n->ncmd.linno;
- 		break;
- 	case NPIPE:
- 		new->npipe.cmdlist = copynodelist(n->npipe.cmdlist);
-@@ -8636,6 +8665,7 @@ copynode(union node *n)
- 	case NSUBSHELL:
- 		new->nredir.redirect = copynode(n->nredir.redirect);
- 		new->nredir.n = copynode(n->nredir.n);
-+		new->nredir.linno = n->nredir.linno;
- 		break;
- 	case NAND:
- 	case NOR:
-@@ -8654,10 +8684,12 @@ copynode(union node *n)
- 		new->nfor.var = nodeckstrdup(n->nfor.var);
- 		new->nfor.body = copynode(n->nfor.body);
- 		new->nfor.args = copynode(n->nfor.args);
-+		new->nfor.linno = n->nfor.linno;
- 		break;
- 	case NCASE:
- 		new->ncase.cases = copynode(n->ncase.cases);
- 		new->ncase.expr = copynode(n->ncase.expr);
-+		new->ncase.linno = n->ncase.linno;
- 		break;
- 	case NCLIST:
- 		new->nclist.body = copynode(n->nclist.body);
-@@ -8665,6 +8697,10 @@ copynode(union node *n)
- 		new->nclist.next = copynode(n->nclist.next);
- 		break;
- 	case NDEFUN:
-+		new->ndefun.body = copynode(n->ndefun.body);
-+		new->ndefun.text = nodeckstrdup(n->ndefun.text);
-+		new->ndefun.linno = n->ndefun.linno;
-+		break;
- 	case NARG:
- 		new->narg.backquote = copynodelist(n->narg.backquote);
- 		new->narg.text = nodeckstrdup(n->narg.text);
-@@ -8733,7 +8769,7 @@ defun(union node *func)
- 	INT_OFF;
- 	entry.cmdtype = CMDFUNCTION;
- 	entry.u.func = copyfunc(func);
--	addcmdentry(func->narg.text, &entry);
-+	addcmdentry(func->ndefun.text, &entry);
- 	INT_ON;
- }
- 
-@@ -8743,8 +8779,8 @@ defun(union node *func)
- #define SKIPFUNC       (1 << 2)
- static smallint evalskip;       /* set to SKIPxxx if we are skipping commands */
- static int skipcount;           /* number of levels to skip */
--static int funcnest;            /* depth of function calls */
- static int loopnest;            /* current loop nesting level */
-+static int funcline;            /* starting line number of current function, or 0 if not in a function */
- 
- /* Forward decl way out to parsing code - dotrap needs it */
- static int evalstring(char *s, int flags);
-@@ -8839,6 +8875,9 @@ evaltree(union node *n, int flags)
- 		status = !evaltree(n->nnot.com, EV_TESTED);
- 		goto setstatus;
- 	case NREDIR:
-+		errlinno = lineno = n->nredir.linno;
-+		if (funcline)
-+			lineno -= funcline - 1;
- 		expredir(n->nredir.redirect);
- 		pushredir(n->nredir.redirect);
- 		status = redirectsafe(n->nredir.redirect, REDIR_PUSH);
-@@ -8993,6 +9032,10 @@ evalfor(union node *n, int flags)
- 	struct stackmark smark;
- 	int status = 0;
- 
-+	errlinno = lineno = n->ncase.linno;
-+	if (funcline)
-+		lineno -= funcline - 1;
-+
- 	setstackmark(&smark);
- 	arglist.list = NULL;
- 	arglist.lastp = &arglist.list;
-@@ -9024,6 +9067,10 @@ evalcase(union node *n, int flags)
- 	struct stackmark smark;
- 	int status = 0;
- 
-+	errlinno = lineno = n->ncase.linno;
-+	if (funcline)
-+		lineno -= funcline - 1;
-+
- 	setstackmark(&smark);
- 	arglist.list = NULL;
- 	arglist.lastp = &arglist.list;
-@@ -9058,6 +9105,10 @@ evalsubshell(union node *n, int flags)
- 	int backgnd = (n->type == NBACKGND); /* FORK_BG(1) if yes, else FORK_FG(0) */
- 	int status;
- 
-+	errlinno = lineno = n->nredir.linno;
-+	if (funcline)
-+		lineno -= funcline - 1;
-+
- 	expredir(n->nredir.redirect);
- 	if (!backgnd && (flags & EV_EXIT) && !may_have_traps)
- 		goto nofork;
-@@ -9365,8 +9416,10 @@ evalfun(struct funcnode *func, int argc, char **argv, int flags)
- 	struct jmploc *volatile savehandler;
- 	struct jmploc jmploc;
- 	int e;
-+	int savefuncline;
- 
- 	saveparam = shellparam;
-+	savefuncline = funcline;
- 	savehandler = exception_handler;
- 	e = setjmp(jmploc.loc);
- 	if (e) {
-@@ -9376,7 +9429,7 @@ evalfun(struct funcnode *func, int argc, char **argv, int flags)
- 	exception_handler = &jmploc;
- 	shellparam.malloced = 0;
- 	func->count++;
--	funcnest++;
-+	funcline = func->n.ndefun.linno;
- 	INT_ON;
- 	shellparam.nparam = argc - 1;
- 	shellparam.p = argv + 1;
-@@ -9385,11 +9438,11 @@ evalfun(struct funcnode *func, int argc, char **argv, int flags)
- 	shellparam.optoff = -1;
- #endif
- 	pushlocalvars();
--	evaltree(func->n.narg.next, flags & EV_TESTED);
-+	evaltree(func->n.ndefun.body, flags & EV_TESTED);
- 	poplocalvars(0);
-  funcdone:
- 	INT_OFF;
--	funcnest--;
-+	funcline = savefuncline;
- 	freefunc(func);
- 	freeparam(&shellparam);
- 	shellparam = saveparam;
-@@ -9753,6 +9806,10 @@ evalcommand(union node *cmd, int flags)
- 	char **nargv;
- 	smallint cmd_is_exec;
- 
-+	errlinno = lineno = cmd->ncmd.linno;
-+	if (funcline)
-+		lineno -= funcline - 1;
-+
- 	/* First expand the arguments. */
- 	TRACE(("evalcommand(0x%lx, %d) called\n", (long)cmd, flags));
- 	setstackmark(&smark);
-@@ -9798,7 +9855,7 @@ evalcommand(union node *cmd, int flags)
- 	*nargv = NULL;
- 
- 	lastarg = NULL;
--	if (iflag && funcnest == 0 && argc > 0)
-+	if (iflag && funcline == 0 && argc > 0)
- 		lastarg = nargv[-1];
- 
- 	expredir(cmd->ncmd.redirect);
-@@ -11317,6 +11374,7 @@ simplecmd(void)
- 	union node *vars, **vpp;
- 	union node **rpp, *redir;
- 	int savecheckkwd;
-+	int savelinno;
- #if BASH_TEST2
- 	smallint double_brackets_flag = 0;
- #endif
-@@ -11330,6 +11388,7 @@ simplecmd(void)
- 	rpp = &redir;
- 
- 	savecheckkwd = CHKALIAS;
-+	savelinno = g_parsefile->linno;
- 	for (;;) {
- 		int t;
- 		checkkwd = savecheckkwd;
-@@ -11419,7 +11478,9 @@ simplecmd(void)
- 				}
- 				n->type = NDEFUN;
- 				checkkwd = CHKNL | CHKKWD | CHKALIAS;
--				n->narg.next = parse_command();
-+				n->ndefun.text = n->narg.text;
-+				n->ndefun.linno = g_parsefile->linno;
-+				n->ndefun.body = parse_command();
- 				return n;
- 			}
- 			IF_BASH_FUNCTION(function_flag = 0;)
-@@ -11435,6 +11496,7 @@ simplecmd(void)
- 	*rpp = NULL;
- 	n = stzalloc(sizeof(struct ncmd));
- 	n->type = NCMD;
-+	n->ncmd.linno = savelinno;
- 	n->ncmd.args = args;
- 	n->ncmd.assign = vars;
- 	n->ncmd.redirect = redir;
-@@ -11450,10 +11512,13 @@ parse_command(void)
- 	union node *redir, **rpp;
- 	union node **rpp2;
- 	int t;
-+	int savelinno;
- 
- 	redir = NULL;
- 	rpp2 = &redir;
- 
-+	savelinno = g_parsefile->linno;
-+
- 	switch (readtoken()) {
- 	default:
- 		raise_error_unexpected_syntax(-1);
-@@ -11504,6 +11569,7 @@ parse_command(void)
- 			raise_error_syntax("bad for loop variable");
- 		n1 = stzalloc(sizeof(struct nfor));
- 		n1->type = NFOR;
-+		n1->nfor.linno = savelinno;
- 		n1->nfor.var = wordtext;
- 		checkkwd = CHKNL | CHKKWD | CHKALIAS;
- 		if (readtoken() == TIN) {
-@@ -11544,6 +11610,7 @@ parse_command(void)
- 	case TCASE:
- 		n1 = stzalloc(sizeof(struct ncase));
- 		n1->type = NCASE;
-+		n1->ncase.linno = savelinno;
- 		if (readtoken() != TWORD)
- 			raise_error_unexpected_syntax(TWORD);
- 		n1->ncase.expr = n2 = stzalloc(sizeof(struct narg));
-@@ -11595,6 +11662,7 @@ parse_command(void)
- 	case TLP:
- 		n1 = stzalloc(sizeof(struct nredir));
- 		n1->type = NSUBSHELL;
-+		n1->nredir.linno = savelinno;
- 		n1->nredir.n = list(0);
- 		/*n1->nredir.redirect = NULL; - stzalloc did it */
- 		t = TRP;
-@@ -11628,6 +11696,7 @@ parse_command(void)
- 		if (n1->type != NSUBSHELL) {
- 			n2 = stzalloc(sizeof(struct nredir));
- 			n2->type = NREDIR;
-+			n2->nredir.linno = savelinno;
- 			n2->nredir.n = n1;
- 			n1 = n2;
- 		}
-@@ -11726,10 +11795,8 @@ readtoken1(int c, int syntax, char *eofmark, int striptabs)
- 	IF_FEATURE_SH_MATH(int arinest;)    /* levels of arithmetic expansion */
- 	IF_FEATURE_SH_MATH(int parenlevel;) /* levels of parens in arithmetic */
- 	int dqvarnest;       /* levels of variables expansion within double quotes */
--
- 	IF_BASH_DOLLAR_SQUOTE(smallint bash_dollar_squote = 0;)
- 
--	startlinno = g_parsefile->linno;
- 	bqlist = NULL;
- 	quotef = 0;
- 	IF_FEATURE_SH_MATH(prevsyntax = 0;)
-@@ -11906,7 +11973,6 @@ readtoken1(int c, int syntax, char *eofmark, int striptabs)
- 	if (syntax != BASESYNTAX && eofmark == NULL)
- 		raise_error_syntax("unterminated quoted string");
- 	if (varnest != 0) {
--		startlinno = g_parsefile->linno;
- 		/* { */
- 		raise_error_syntax("missing '}'");
- 	}
-@@ -12298,7 +12364,6 @@ parsebackq: {
- 
- 			case PEOF:
- 			IF_ASH_ALIAS(case PEOA:)
--				startlinno = g_parsefile->linno;
- 				raise_error_syntax("EOF in backquote substitution");
- 
- 			case '\n':
-@@ -12380,8 +12445,6 @@ parsearith: {
-  *      quoted.
-  * If the token is TREDIR, then we set redirnode to a structure containing
-  *      the redirection.
-- * In all cases, the variable startlinno is set to the number of the line
-- *      on which the token starts.
-  *
-  * [Change comment:  here documents and internal procedures]
-  * [Readtoken shouldn't have any arguments.  Perhaps we should make the
-@@ -12419,7 +12482,6 @@ xxreadtoken(void)
- 		return lasttoken;
- 	}
- 	setprompt_if(needprompt, 2);
--	startlinno = g_parsefile->linno;
- 	for (;;) {                      /* until token or start of word found */
- 		c = pgetc();
- 		if (c == ' ' || c == '\t' IF_ASH_ALIAS( || c == PEOA))
-@@ -12480,7 +12542,6 @@ xxreadtoken(void)
- 		return lasttoken;
- 	}
- 	setprompt_if(needprompt, 2);
--	startlinno = g_parsefile->linno;
- 	for (;;) {      /* until token or start of word found */
- 		c = pgetc();
- 		switch (c) {
diff -urpN busybox-1.28.4/shell/ash_test/ash-arith/arith-postinc.right busybox-1.29.0/shell/ash_test/ash-arith/arith-postinc.right
--- busybox-1.28.4/shell/ash_test/ash-arith/arith-postinc.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-arith/arith-postinc.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+1 1
+1 1
+1 1
+1 1
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-arith/arith-postinc.tests busybox-1.29.0/shell/ash_test/ash-arith/arith-postinc.tests
--- busybox-1.28.4/shell/ash_test/ash-arith/arith-postinc.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-arith/arith-postinc.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+echo 1 $((0++1))
+echo 1 $((0--1))
+x=-1; echo 1 $((0-$x))
+x=+1; echo 1 $((0+$x))
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-arith/arith.right busybox-1.29.0/shell/ash_test/ash-arith/arith.right
--- busybox-1.28.4/shell/ash_test/ash-arith/arith.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-arith/arith.right	2018-07-02 15:55:14.000000000 +0200
@@ -126,6 +126,10 @@ ghi
 ./arith2.sub: line 5: arithmetic syntax error
 5 5
 1 1
+6 6
+2 2
+3 3
+1 1
 4 4
 0 0
 ./arith2.sub: line 42: arithmetic syntax error
diff -urpN busybox-1.28.4/shell/ash_test/ash-arith/arith2.sub busybox-1.29.0/shell/ash_test/ash-arith/arith2.sub
--- busybox-1.28.4/shell/ash_test/ash-arith/arith2.sub	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-arith/arith2.sub	2018-07-02 15:55:14.000000000 +0200
@@ -23,14 +23,14 @@
 echo 5 $(( 4 + ++a ))
 echo 1 $a
 
-# ash doesn't handle it right...
-#ash# echo 6 $(( 4+++a ))
-#ash# echo 2 $a
+# this is treated as 4 + ++a
+echo 6 $(( 4+++a ))
+echo 2 $a
       a=2
 
-# ash doesn't handle it right...
-#ash# echo 3 $(( 4---a ))
-#ash# echo 1 $a
+# this is treated as 4 - --a
+echo 3 $(( 4---a ))
+echo 1 $a
       a=1
 
 echo 4 $(( 4 - -- a ))
diff -urpN busybox-1.28.4/shell/ash_test/ash-arith/arith_nested1.right busybox-1.29.0/shell/ash_test/ash-arith/arith_nested1.right
--- busybox-1.28.4/shell/ash_test/ash-arith/arith_nested1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-arith/arith_nested1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+1
diff -urpN busybox-1.28.4/shell/ash_test/ash-arith/arith_nested1.tests busybox-1.29.0/shell/ash_test/ash-arith/arith_nested1.tests
--- busybox-1.28.4/shell/ash_test/ash-arith/arith_nested1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-arith/arith_nested1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+echo $(( ( $((1)) ) ))
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backquote1.right busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backquote1.right
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backquote1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backquote1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+heredoc1
+Ok1:0
+heredoc2
+EO`false`F
+Ok2:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backquote1.tests busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backquote1.tests
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backquote1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backquote1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,10 @@
+cat <<EO`true`F
+heredoc1
+EO`true`F
+echo Ok1:$?
+
+cat <<EO`true`F
+heredoc2
+EO`false`F
+EO`true`F
+echo Ok2:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backslash1.right busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backslash1.right
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backslash1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backslash1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,43 @@
+Quoted heredoc:
+a\
+	b
+a\\
+	b
+ 123456 -$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+	-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+ 123456 `echo  v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-'`
+ 123456 $(echo v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-')
+c\
+
+Unquoted heredoc:
+a	b
+a\
+	b
+ 123456 -qwerty-\t-\-\"-\'-`-\--\z-\*-\?-
+	-qwerty-\t-\-\"-\'-`-\--\z-\*-\?-
+ 123456 v-$a-\t-\-\"-\x-`-\--\z-\*-\?-
+ 123456 v-$a-\t-\\-\"-\x-\`-\--\z-\*-\?-
+cEOF2
+
+Quoted -heredoc:
+a\
+b
+a\\
+b
+ 123456 -$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+ 123456 `echo  v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-'`
+ 123456 $(echo v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-')
+c\
+
+Unquoted -heredoc:
+a	b
+a\
+b
+ 123456 -qwerty-\t-\-\"-\'-`-\--\z-\*-\?-
+-qwerty-\t-\-\"-\'-`-\--\z-\*-\?-
+ 123456 v-$a-\t-\-\"-\x-`-\--\z-\*-\?-
+ 123456 v-$a-\t-\\-\"-\x-\`-\--\z-\*-\?-
+cEOF4
+
+Done: 0
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backslash1.tests busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backslash1.tests
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_backslash1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_backslash1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,70 @@
+# Test for correct handling of backslashes.
+# Note that some lines in each heredoc start with a tab.
+
+a=qwerty
+
+echo Quoted heredoc:
+cat <<"EOF1"
+a\
+	b
+a\\
+	b
+ 123456 -$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+	-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+ 123456 `echo  v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-'`
+ 123456 $(echo v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-')
+c\
+EOF1
+echo
+
+echo Unquoted heredoc:
+cat <<EOF2
+a\
+	b
+a\\
+	b
+ 123456 -$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+	-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+ 123456 `echo  v'-$a-\t-\\-\"-\x-\`-\--\z-\*-\?-'`
+ 123456 $(echo v'-$a-\t-\\-\"-\x-\`-\--\z-\*-\?-')
+c\
+EOF2
+EOF2
+echo
+
+echo Quoted -heredoc:
+cat <<-"EOF3"
+a\
+	b
+a\\
+	b
+ 123456 -$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+	-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+ 123456 `echo  v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-'`
+ 123456 $(echo v'-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-')
+c\
+	EOF3
+# In -heredoc case the marker is detected even if it is indented.
+echo
+
+echo Unquoted -heredoc:
+cat <<-EOF4
+a\
+	b
+a\\
+	b
+ 123456 -$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+	-$a-\t-\\-\"-\'-\`-\--\z-\*-\?-
+ 123456 `echo  v'-$a-\t-\\-\"-\x-\`-\--\z-\*-\?-'`
+ 123456 $(echo v'-$a-\t-\\-\"-\x-\`-\--\z-\*-\?-')
+c\
+EOF4
+	EOF4
+# The marker is not detected if preceding line ends in backslash.
+# TODO: marker should be detected even if it is split by line continuation:
+# EOF\
+# 4
+# but currently hush doesn't do it. (Tab before "4" is not allowed, though.)
+echo
+
+echo "Done: $?"
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.right busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.right
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+heredoc0
+Ok0:0
+heredoc1
+Ok1:0
+heredoc2
+Ok2:0
+heredoc3
+Ok4:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.tests busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.tests
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,25 @@
+cat <\
+<\
+EOF
+heredoc0
+EOF
+echo Ok0:$?
+
+cat <<\
+ EOF
+heredoc1
+EOF
+echo Ok1:$?
+
+cat <<\
+- EOF
+heredoc2
+	EOF
+echo Ok2:$?
+
+cat <\
+<\
+- EOF
+heredoc3
+	EOF
+echo Ok4:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_var_expand1.right busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_var_expand1.right
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_var_expand1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_var_expand1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+
+Ok1:0
+
+Ok2:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_var_expand1.tests busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_var_expand1.tests
--- busybox-1.28.4/shell/ash_test/ash-heredoc/heredoc_var_expand1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-heredoc/heredoc_var_expand1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,11 @@
+x='*'
+
+cat <<- EOF
+	${x#'*'}
+EOF
+echo Ok1:$?
+
+cat <<EOF
+${x#'*'}
+EOF
+echo Ok2:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/assignment5.right busybox-1.29.0/shell/ash_test/ash-misc/assignment5.right
--- busybox-1.28.4/shell/ash_test/ash-misc/assignment5.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/assignment5.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+Zero1:0
+Zero2:0
+Zero3:0
+Zero4:0 x:1 y:1
+Three:3 x:1 y:1
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/assignment5.tests busybox-1.29.0/shell/ash_test/ash-misc/assignment5.tests
--- busybox-1.28.4/shell/ash_test/ash-misc/assignment5.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/assignment5.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,9 @@
+true;  a=1; echo Zero1:$?
+false; a=1; echo Zero2:$?
+false || a=1; echo Zero3:$?
+
+false || x=$? y=`echo $?`; echo Zero4:$? x:$x y:$y
+false || x=$? y=`echo $?; exit 3`; echo Three:$? x:$x y:$y
+
+#ash sets z=1 instead of z=3. disabled for now
+#false || x=$? y=`echo $?; exit 3` z=`echo $?`; echo x:$x y:$y z:$z
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/control_char1.right busybox-1.29.0/shell/ash_test/ash-misc/control_char1.right
--- busybox-1.28.4/shell/ash_test/ash-misc/control_char1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/control_char1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+
+b#c
+Done:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/control_char1.tests busybox-1.29.0/shell/ash_test/ash-misc/control_char1.tests
--- busybox-1.28.4/shell/ash_test/ash-misc/control_char1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/control_char1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+echo 
+echo 'b#c'
+echo Done:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/control_char2.right busybox-1.29.0/shell/ash_test/ash-misc/control_char2.right
--- busybox-1.28.4/shell/ash_test/ash-misc/control_char2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/control_char2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+
+Done:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/control_char2.tests busybox-1.29.0/shell/ash_test/ash-misc/control_char2.tests
--- busybox-1.28.4/shell/ash_test/ash-misc/control_char2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/control_char2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+c=`printf '\3'`
+eval "echo $c"
+echo Done:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/for_with_bslashes.right busybox-1.29.0/shell/ash_test/ash-misc/for_with_bslashes.right
--- busybox-1.28.4/shell/ash_test/ash-misc/for_with_bslashes.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-misc/for_with_bslashes.right	2018-07-02 15:55:14.000000000 +0200
@@ -5,4 +5,5 @@ b"c
 b'c
 b$c
 b`true`c
+b#c
 Zero:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/for_with_bslashes.tests busybox-1.29.0/shell/ash_test/ash-misc/for_with_bslashes.tests
--- busybox-1.28.4/shell/ash_test/ash-misc/for_with_bslashes.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-misc/for_with_bslashes.tests	2018-07-02 15:55:14.000000000 +0200
@@ -1,9 +1,5 @@
-# UNFIXED BUG.
-# commented-out words contain ^C character.
-# It's a SPECIAL_VAR_SYMBOL, for now hush does not escape it.
-# When it is fixed, update this test.
-
-for a in 'a' 'b\c' 'b\\c' 'b"c' "b'c" 'b$c' 'b`true`c' ### 'b#c'
+# last word contains ^C character.
+for a in 'a' 'b\c' 'b\\c' 'b"c' "b'c" 'b$c' 'b`true`c' 'b#c'
 do
     echo $a
 done
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/func5.right busybox-1.29.0/shell/ash_test/ash-misc/func5.right
--- busybox-1.28.4/shell/ash_test/ash-misc/func5.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-misc/func5.right	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,3 @@
 1
 2
 3
-1
-2
-3
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/func5.tests busybox-1.29.0/shell/ash_test/ash-misc/func5.tests
--- busybox-1.28.4/shell/ash_test/ash-misc/func5.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-misc/func5.tests	2018-07-02 15:55:14.000000000 +0200
@@ -6,8 +6,3 @@ f 2
 
 f() ( echo $1 )
 f 3
-
-f() for i in 1 2 3; do
-	echo $i
-done
-f
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/func_compound1.right busybox-1.29.0/shell/ash_test/ash-misc/func_compound1.right
--- busybox-1.28.4/shell/ash_test/ash-misc/func_compound1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/func_compound1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+1
+2
+3
diff -urpN busybox-1.28.4/shell/ash_test/ash-misc/func_compound1.tests busybox-1.29.0/shell/ash_test/ash-misc/func_compound1.tests
--- busybox-1.28.4/shell/ash_test/ash-misc/func_compound1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-misc/func_compound1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+f() for i in 1 2 3; do
+	echo $i
+done
+f
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_eof1.right busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_eof1.right
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_eof1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_eof1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+ok\
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_eof1.tests busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_eof1.tests
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_eof1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_eof1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+eval 'echo ok\'
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline1.right busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline1.right
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+and1
+and2
+or1
+ok
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline1.tests busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline1.tests
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+echo and1 &\
+& echo and2
+
+echo or1 |\
+| echo NOT SHOWN
+
+case w in a) echo SKIP;\
+; w) echo ok;; esac;
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline2.right busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline2.right
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+Line with one backslash:
+\
+
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline2.tests busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline2.tests
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+echo Line with one backslash:
+echo '\
+'
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline3.right busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline3.right
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+a:[a]
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline3.tests busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline3.tests
--- busybox-1.28.4/shell/ash_test/ash-parsing/bkslash_newline3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/bkslash_newline3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+for s in 	\
+a; do
+	echo "a:[$s]"
+done
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/starquoted3.right busybox-1.29.0/shell/ash_test/ash-parsing/starquoted3.right
--- busybox-1.28.4/shell/ash_test/ash-parsing/starquoted3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/starquoted3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+<a>
+<>
diff -urpN busybox-1.28.4/shell/ash_test/ash-parsing/starquoted3.tests busybox-1.29.0/shell/ash_test/ash-parsing/starquoted3.tests
--- busybox-1.28.4/shell/ash_test/ash-parsing/starquoted3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-parsing/starquoted3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+set -- a ""; space=" "; printf "<%s>\n" "$@"$space
diff -urpN busybox-1.28.4/shell/ash_test/ash-psubst/emptytick.right busybox-1.29.0/shell/ash_test/ash-psubst/emptytick.right
--- busybox-1.28.4/shell/ash_test/ash-psubst/emptytick.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-psubst/emptytick.right	2018-07-02 15:55:14.000000000 +0200
@@ -1,8 +1,8 @@
 0
 0
-./emptytick.tests: line 3: : Permission denied
+./emptytick.tests: line 1: : Permission denied
 127
-./emptytick.tests: line 4: : Permission denied
+./emptytick.tests: line 1: : Permission denied
 127
 0
 0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case1.right busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case1.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,10 @@
+ok1
+ok2
+ok3
+ok4
+ok5
+Ok:0
+ok6
+ok7
+ok8
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case1.tests busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case1.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,38 @@
+# Case argument is globbed, match patterns are not.
+# This caught some bugs in the past.
+
+case z in
+\z  ) echo ok1 ;;
+*   ) echo BUG ;;
+esac
+case \z in
+z   ) echo ok2 ;;
+*   ) echo BUG ;;
+esac
+case \z in
+\z  ) echo ok3 ;;
+*   ) echo BUG ;;
+esac
+case z in
+\z  ) echo ok4 ;;
+*   ) echo BUG ;;
+esac
+case \\z in
+\\z ) echo ok5 ;;
+*   ) echo BUG ;;
+esac
+echo Ok:$?
+
+case "\z" in
+"\z"  ) echo ok6 ;;
+*     ) echo BUG ;;
+esac
+case "\\z" in
+"\\z" ) echo ok7 ;;
+*     ) echo BUG ;;
+esac
+case "\\\z" in
+"\\\z") echo ok8 ;;
+*     ) echo BUG ;;
+esac
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case2.right busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case2.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+ok1
+ok2
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case2.tests busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case2.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_case2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_case2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,13 @@
+x='\abc'
+
+case "$x" in
+\\*) echo ok1;;
+*)   echo BUG1;;
+esac
+
+case $x in
+\\*) echo ok2;;
+*)   echo BUG2;;
+esac
+
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp.right busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+Nothing:
+Nothing:
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp.tests busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,16 @@
+x='a]'
+#
+# \] is not a valid escape for ] in set glob expression.
+# Glob sets have no escaping at all:
+# ] can be in a set if it is the first char: []abc],
+# dash can be in a set if it is first or last: [abc-],
+# [ and \ need no protections at all: [a[b\c] is a valid set of 5 chars.
+#
+# bash-4.3.43 misinterprets [a\]] as "set of 'a' or ']'".
+# Correct interpretation is "set of 'a' or '\', followed by ']'".
+#
+echo Nothing:${x#[a\]]}
+echo Nothing:"${x#[a\]]}"
+echo Nothing:${x%[a\]]}
+echo Nothing:"${x%[a\]]}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp1.right busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp1.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+Nothing:
+Nothing:
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp1.tests busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp1.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/bkslash_in_varexp1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/bkslash_in_varexp1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+x=a
+echo Nothing:${x#[]a]}
+echo Nothing:"${x#[]a]}"
+echo Nothing:${x%[]a]}
+echo Nothing:"${x%[]a]}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/case_glob1.right busybox-1.29.0/shell/ash_test/ash-quoting/case_glob1.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/case_glob1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/case_glob1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+s
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/case_glob1.tests busybox-1.29.0/shell/ash_test/ash-quoting/case_glob1.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/case_glob1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/case_glob1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+g='[3](a)(b)(c)'
+s='[3](a)(b)(c)'
+case $g in
+"$s")   echo s
+        ;;
+*)      echo "*"
+        ;;
+esac
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.right busybox-1.29.0/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+\/a\/bc\/def\/file
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.tests busybox-1.29.0/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/dollar_repl_slash_bash2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+var="/a/bc/def/file"
+echo "${var//\//\\/}"
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/mode_x.right busybox-1.29.0/shell/ash_test/ash-quoting/mode_x.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/mode_x.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-quoting/mode_x.right	2018-07-02 15:55:14.000000000 +0200
@@ -3,8 +3,8 @@
 + true '%s\n' one 'two '"'"'three' four
 + this=command
 + 'this=command'
-./mode_x.tests: line 1: this=command: not found
+./mode_x.tests: line 10: this=command: not found
 + true
 + true
 + 'if' true
-./mode_x.tests: line 1: if: not found
+./mode_x.tests: line 14: if: not found
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/quote_in_varexp1.right busybox-1.29.0/shell/ash_test/ash-quoting/quote_in_varexp1.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/quote_in_varexp1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/quote_in_varexp1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+''
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/quote_in_varexp1.tests busybox-1.29.0/shell/ash_test/ash-quoting/quote_in_varexp1.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/quote_in_varexp1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/quote_in_varexp1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+x="''''"; echo "${x#"${x+''}"''}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp.right busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+z
+z
+y
+y
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp.tests busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+x=yz
+echo ${x#'y'}
+echo "${x#'y'}"
+echo ${x%'z'}
+echo "${x%'z'}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp1.right busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp1.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp1.tests busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp1.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+x='\\\\'
+printf Nothing:'%s\n' ${x#\\\\\\\\}
+printf Nothing:'%s\n' "${x#\\\\\\\\}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp2.right busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp2.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp2.tests busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp2.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+x='\\\\'
+printf Nothing:'%s\n' ${x#'\\\\'}
+printf Nothing:'%s\n' "${x#'\\\\'}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp3.right busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp3.right
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+B
diff -urpN busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp3.tests busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp3.tests
--- busybox-1.28.4/shell/ash_test/ash-quoting/squote_in_varexp3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-quoting/squote_in_varexp3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+x=\'B; echo "${x#\'}"
diff -urpN busybox-1.28.4/shell/ash_test/ash-redir/redir_exec1.right busybox-1.29.0/shell/ash_test/ash-redir/redir_exec1.right
--- busybox-1.28.4/shell/ash_test/ash-redir/redir_exec1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-redir/redir_exec1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+./redir_exec1.tests: line 1: can't create /cant/be/created: nonexistent directory
+First
diff -urpN busybox-1.28.4/shell/ash_test/ash-redir/redir_exec1.tests busybox-1.29.0/shell/ash_test/ash-redir/redir_exec1.tests
--- busybox-1.28.4/shell/ash_test/ash-redir/redir_exec1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-redir/redir_exec1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+v=`echo First >&2` exec >/cant/be/created
+echo One:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/param_expand_alt2.right busybox-1.29.0/shell/ash_test/ash-vars/param_expand_alt2.right
--- busybox-1.28.4/shell/ash_test/ash-vars/param_expand_alt2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/param_expand_alt2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+Unquoted: H H
+Quoted: H
+H
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/param_expand_alt2.tests busybox-1.29.0/shell/ash_test/ash-vars/param_expand_alt2.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/param_expand_alt2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/param_expand_alt2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,7 @@
+echo Unquoted: H${$+
+}H
+
+echo Quoted: "H${$+
+}H"
+
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/param_expand_bash_substring.right busybox-1.29.0/shell/ash_test/ash-vars/param_expand_bash_substring.right
--- busybox-1.28.4/shell/ash_test/ash-vars/param_expand_bash_substring.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-vars/param_expand_bash_substring.right	2018-07-02 15:55:14.000000000 +0200
@@ -3,6 +3,7 @@ SHELL: line 1: syntax error: bad substit
 SHELL: line 1: syntax error: bad substitution
 SHELL: line 1: syntax error: bad substitution
 SHELL: line 1: syntax error: missing '}'
+0
 1    =||
 1:1  =||
 1:1:2=||
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/param_expand_bash_substring.tests busybox-1.29.0/shell/ash_test/ash-vars/param_expand_bash_substring.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/param_expand_bash_substring.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-vars/param_expand_bash_substring.tests	2018-07-02 15:55:14.000000000 +0200
@@ -11,7 +11,7 @@ export var=0123456789
 "$THIS_SH" -c 'echo ${var:}' SHELL
 
 # then some funky ones
-# UNFIXED BUG: this should work: "$THIS_SH" -c 'echo ${?:0}'
+"$THIS_SH" -c 'echo ${?:0}' SHELL
 
 # now some valid ones
 set --; echo "1    =|${1}|"
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_LINENO1.right busybox-1.29.0/shell/ash_test/ash-vars/var_LINENO1.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_LINENO1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_LINENO1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+2:2
+3:3
+4:4
+5:5
+2:2
+3:3
+4:4
+5:5
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_LINENO1.tests busybox-1.29.0/shell/ash_test/ash-vars/var_LINENO1.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/var_LINENO1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_LINENO1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+env | grep ^LINENO
+echo 2:$LINENO
+echo 3:$LINENO >&2 \
+| { sleep 0.1; echo 4:$LINENO; }
+echo 5:$LINENO
+test "$1" || . ./var_LINENO1.tests norepeat
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash3.right busybox-1.29.0/shell/ash_test/ash-vars/var_bash3.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash3.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash3.right	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 1 a041#c
 2 a041#c
-3 a\041#c
+3 a041#c
 4 a\041#c
 5 a\041#c
 6 a\041#c
@@ -17,4 +17,4 @@
 17 a\tc
 18 a\tc
 19 atc
-20 a\tc
+20 atc
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash4.right busybox-1.29.0/shell/ash_test/ash-vars/var_bash4.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash4.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash4.right	2018-07-02 15:55:14.000000000 +0200
@@ -3,26 +3,26 @@ Replace str:   _\\_\z_
 Pattern:       single backslash and star: "replace literal star"
 Unquoted:      a_\_z_b\*c
 Unquoted =:    a_\_z_b\*c
-Quoted:        a_\_\z_b\*c
-Quoted =:      a_\_\z_b\*c
+Quoted:        a_\_z_b\*c
+Quoted =:      a_\_z_b\*c
 Pattern:       double backslash and star: "replace backslash and everything after it"
 Unquoted:      a*b_\_z_
 Unquoted =:    a*b_\_z_
-Quoted:        a*b_\_\z_
-Quoted =:      a*b_\_\z_
+Quoted:        a*b_\_z_
+Quoted =:      a*b_\_z_
 
 Source:        a\bc
 Replace str:   _\\_\z_
 Pattern:       single backslash and b: "replace b"
 Unquoted:      a\_\_z_c
 Unquoted =:    a\_\_z_c
-Quoted:        a\_\_\z_c
-Quoted =:      a\_\_\z_c
+Quoted:        a\_\_z_c
+Quoted =:      a\_\_z_c
 Pattern:       double backslash and b: "replace backslash and b"
 Unquoted:      a_\_z_c
 Unquoted =:    a_\_z_c
-Quoted:        a_\_\z_c
-Quoted =:      a_\_\z_c
+Quoted:        a_\_z_c
+Quoted =:      a_\_z_c
 
 Source:        a\bc
 Replace str:   _\\_\z_ (as variable $s)
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash6.right busybox-1.29.0/shell/ash_test/ash-vars/var_bash6.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash6.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash6.right	2018-07-02 15:55:14.000000000 +0200
@@ -1,5 +1,5 @@
 Expected Actual
 a*z    : a*z
-\z     : \z
+z      : z
 a1z a2z: a1z a2z
 z      : z
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash6.tests busybox-1.29.0/shell/ash_test/ash-vars/var_bash6.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash6.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash6.tests	2018-07-02 15:55:14.000000000 +0200
@@ -3,7 +3,7 @@
 >a1z; >a2z;
           echo 'Expected' 'Actual'
 v='a bz'; echo 'a*z    :' "${v/a*z/a*z}"
-v='a bz'; echo '\z     :' "${v/a*z/\z}"
+v='a bz'; echo 'z      :' "${v/a*z/\z}"
 v='a bz'; echo 'a1z a2z:' ${v/a*z/a*z}
 v='a bz'; echo 'z      :' ${v/a*z/\z}
 rm a1z a2z
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash7.right busybox-1.29.0/shell/ash_test/ash-vars/var_bash7.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash7.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash7.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+B
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash7.tests busybox-1.29.0/shell/ash_test/ash-vars/var_bash7.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash7.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash7.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+x=AB; echo "${x#$'\x41'}"
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.right busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+v
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.tests busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_pattern.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+v=v
+echo ${v//}
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_var.right busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_var.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_var.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_var.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+
+Ok:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+v=''
+echo ${v/*/w}
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_wordsplit_ifs4.right busybox-1.29.0/shell/ash_test/ash-vars/var_wordsplit_ifs4.right
--- busybox-1.28.4/shell/ash_test/ash-vars/var_wordsplit_ifs4.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_wordsplit_ifs4.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+|x|
+Ok1:0
+|x|
+||
+Ok2:0
diff -urpN busybox-1.28.4/shell/ash_test/ash-vars/var_wordsplit_ifs4.tests busybox-1.29.0/shell/ash_test/ash-vars/var_wordsplit_ifs4.tests
--- busybox-1.28.4/shell/ash_test/ash-vars/var_wordsplit_ifs4.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-vars/var_wordsplit_ifs4.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+IFS=": "; x=" "; set x $x; for v; do echo "|$v|"; done
+echo Ok1:$?
+IFS=": "; x=":"; set x $x; for v; do echo "|$v|"; done
+echo Ok2:$?
diff -urpN busybox-1.28.4/shell/ash_test/ash-z_slow/many_ifs.right busybox-1.29.0/shell/ash_test/ash-z_slow/many_ifs.right
--- busybox-1.28.4/shell/ash_test/ash-z_slow/many_ifs.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-z_slow/many_ifs.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+# tests 6856 passed 6856 failed 0
diff -urpN busybox-1.28.4/shell/ash_test/ash-z_slow/many_ifs.tests busybox-1.29.0/shell/ash_test/ash-z_slow/many_ifs.tests
--- busybox-1.28.4/shell/ash_test/ash-z_slow/many_ifs.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/ash_test/ash-z_slow/many_ifs.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,257 @@
+# Usage: $SHELL ifs.sh
+#
+# This script generates 6856 tests for the set(1) and read(1)
+# builtins w.r.t. IFS whitespace and non-whitespace characters.
+# Each failed test produces one line on the standard output that
+# contains the test along with the expected and actual results.
+# The last output line contains the test result counts.  ordered>0
+# are the number of tests where IFS=": " produced different results
+# than IFS=" :".  If a test fails the same way for IFS=": " and
+# IFS=" :" then the second output line is suppressed.
+
+TESTS=6856
+
+ksh_read=0
+echo 1 | read ksh_read
+ksh_arith=0
+eval '((ksh_arith+=1))' 2>/dev/null
+
+failed=0
+ordered=0
+passed=0
+
+split()
+{
+	i=$1 s=$2 r=$3 S='' R=''
+	for ifs in ': ' ' :'
+	do	IFS=$ifs
+		set x $i
+		shift
+		IFS=' '
+		g="[$#]"
+		while	:
+		do	case $# in
+			0)	break ;;
+			esac
+			g="$g($1)"
+			shift
+		done
+		case $g in
+		"$s")	case $ksh_arith in
+			1)	((passed+=1)) ;;
+			*)	passed=`expr $passed + 1` ;;
+			esac
+			case $S in
+			'')	S=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+			;;
+		"$S")	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			;;
+		*)	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			case $s in
+			"$S")	;;
+			?0*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#]\" # expected \"$s\" got \"$g\"" ;;
+			?1*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)\" # expected \"$s\" got \"$g\"" ;;
+			?2*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)(\$2)\" # expected \"$s\" got \"$g\"" ;;
+			?3*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)(\$2)(\$3)\" # expected \"$s\" got \"$g\"" ;;
+			*)	echo TEST ERROR i="'$i'" s="'$s'" ;;
+			esac
+			case $S in
+			'')	S=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+		esac
+		case $ksh_read in
+		1)	echo "$i" | IFS=$ifs read x y; g="($x)($y)" ;;
+		*)	g=`export ifs; echo "$i" | ( IFS=$ifs; read x y; echo "($x)($y)" )` ;;
+		esac
+		case $g in
+		"$r")	case $ksh_arith in
+			1)	((passed+=1)) ;;
+			*)	passed=`expr $passed + 1` ;;
+			esac
+			case $R in
+			'')	R=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+			;;
+		"$R")	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			;;
+		*)	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			case $r in
+			"$R")	;;
+			*)	echo "echo \"$i\" | ( IFS=\"$ifs\" read x y; echo \"(\$x)(\$y)\" ) # expected \"$r\" got \"$g\"" ;;
+			esac
+			case $R in
+			'')	R=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+			;;
+		esac
+	done
+}
+
+for str in 	\
+	'-'	\
+	'a'	\
+	'- -'	\
+	'- a'	\
+	'a -'	\
+	'a b'	\
+	'- - -'	\
+	'- - a'	\
+	'- a -'	\
+	'- a b'	\
+	'a - -'	\
+	'a - b'	\
+	'a b -'	\
+	'a b c'	\
+
+do
+	IFS=' '
+	set x $str
+
+	shift
+	case $# in
+	0)	continue ;;
+	esac
+
+	f1=$1
+	case $f1 in
+	'-')	f1='' ;;
+	esac
+
+	shift
+	case $# in
+	0)	for d0 in '' ' '
+		do
+			for d1 in '' ' ' ':' ' :' ': ' ' : '
+			do
+				case $f1$d1 in
+				'')	split "$d0$f1$d1" "[0]" "()()" ;;
+				' ')	;;
+				*)	split "$d0$f1$d1" "[1]($f1)" "($f1)()" ;;
+				esac
+			done
+		done
+		continue
+		;;
+	esac
+	f2=$1
+	case $f2 in
+	'-')	f2='' ;;
+	esac
+
+	shift
+	case $# in
+	0)	for d0 in '' ' '
+		do
+			for d1 in ' ' ':' ' :' ': ' ' : '
+			do
+				case ' ' in
+				$f1$d1|$d1$f2)	continue ;;
+				esac
+				for d2 in '' ' ' ':' ' :' ': ' ' : '
+				do
+					case $f2$d2 in
+					'')	split "$d0$f1$d1$f2$d2" "[1]($f1)" "($f1)()" ;;
+					' ')	;;
+					*)	split "$d0$f1$d1$f2$d2" "[2]($f1)($f2)" "($f1)($f2)" ;;
+					esac
+				done
+			done
+		done
+		continue
+		;;
+	esac
+	f3=$1
+	case $f3 in
+	'-')	f3='' ;;
+	esac
+
+	shift
+	case $# in
+	0)	for d0 in '' ' '
+		do
+			for d1 in ':' ' :' ': ' ' : '
+			do
+				case ' ' in
+				$f1$d1|$d1$f2)	continue ;;
+				esac
+				for d2 in ' ' ':' ' :' ': ' ' : '
+				do
+					case $f2$d2 in
+					' ')	continue ;;
+					esac
+					case ' ' in
+					$f2$d2|$d2$f3)	continue ;;
+					esac
+					for d3 in '' ' ' ':' ' :' ': ' ' : '
+					do
+						case $f3$d3 in
+						'')	split "$d0$f1$d1$f2$d2$f3$d3" "[2]($f1)($f2)" "($f1)($f2)" ;;
+						' ')	;;
+						*)	x=$f2$d2$f3$d3
+							x=${x# } #was x=${x#' '} hush needs fixing for this to work
+							x=${x% } #was x=${x%' '}
+							split "$d0$f1$d1$f2$d2$f3$d3" "[3]($f1)($f2)($f3)" "($f1)($x)"
+							;;
+						esac
+					done
+				done
+			done
+		done
+		continue
+		;;
+	esac
+done
+case $ksh_arith in
+1)	((tests=passed+failed)) ;;
+*)	tests=`expr $passed + $failed` ;;
+esac
+case $ordered in
+0)	ordered="" ;;
+*)	ordered=" ordered $ordered" ;;
+esac
+case $tests in
+$TESTS)	fatal="" ;;
+*)	fatal=" -- fundamental IFS error -- $TESTS tests expected"
+esac
+echo "# tests $tests passed $passed failed $failed$ordered$fatal"
diff -urpN busybox-1.28.4/shell/hush.c busybox-1.29.0/shell/hush.c
--- busybox-1.28.4/shell/hush.c	2018-04-01 13:04:11.000000000 +0200
+++ busybox-1.29.0/shell/hush.c	2018-07-02 15:55:14.000000000 +0200
@@ -47,17 +47,13 @@
  *      follow IFS rules more precisely, including update semantics
  *      tilde expansion
  *      aliases
- *      builtins mandated by standards we don't support:
- *          [un]alias, command, fc:
- *          command -v CMD: print "/path/to/CMD"
- *              prints "CMD" for builtins
- *              prints "alias ALIAS='EXPANSION'" for aliases
- *              prints nothing and sets $? to 1 if not found
- *          command -V CMD: print "CMD is /path/CMD|a shell builtin|etc"
- *          command [-p] CMD: run CMD, even if a function CMD also exists
- *              (can use this to override standalone shell as well)
- *              -p: use default $PATH
+ *      "command" missing features:
+ *          command -p CMD: run CMD using default $PATH
+ *              (can use this to override standalone shell as well?)
  *          command BLTIN: disables special-ness (e.g. errors do not abort)
+ *          command -V CMD1 CMD2 CMD3 (multiple args) (not in standard)
+ *      builtins mandated by standards we don't support:
+ *          [un]alias, fc:
  *          fc -l[nr] [BEG] [END]: list range of commands in history
  *          fc [-e EDITOR] [BEG] [END]: edit/rerun range of commands
  *          fc -s [PAT=REP] [CMD]: rerun CMD, replacing PAT with REP
@@ -83,20 +79,18 @@
  *      Some builtins mandated by standards:
  *          newgrp [GRP]: not a builtin in bash but a suid binary
  *              which spawns a new shell with new group ID
- *      In bash, export builtin is special, its arguments are assignments
- *          and therefore expansion of them should be "one-word" expansion:
- *              $ export i=`echo 'a  b'` # export has one arg: "i=a  b"
- *          compare with:
- *              $ ls i=`echo 'a  b'`     # ls has two args: "i=a" and "b"
- *              ls: cannot access i=a: No such file or directory
- *              ls: cannot access b: No such file or directory
- *          Note1: same applies to local builtin.
- *          Note2: bash 3.2.33(1) does this only if export word itself
- *          is not quoted:
- *              $ export i=`echo 'aaa  bbb'`; echo "$i"
- *              aaa  bbb
- *              $ "export" i=`echo 'aaa  bbb'`; echo "$i"
- *              aaa
+ *
+ * Status of [[ support:
+ * [[ args ]] are CMD_SINGLEWORD_NOGLOB:
+ *   v='a b'; [[ $v = 'a b' ]]; echo 0:$?
+ *   [[ /bin/n* ]]; echo 0:$?
+ * TODO:
+ * &&/|| are AND/OR ops, -a/-o are not
+ * quoting needs to be considered (-f is an operator, "-f" and ""-f are not; etc)
+ * = is glob match operator, not equality operator: STR = GLOB
+ * (in GLOB, quoting is significant on char-by-char basis: a*cd"*")
+ * == same as =
+ * add =~ regex match operator: STR =~ REGEX
  */
 //config:config HUSH
 //config:	bool "hush (64 kb)"
@@ -124,6 +118,18 @@
 //config:	help
 //config:	Enable {abc,def} extension.
 //config:
+//config:config HUSH_LINENO_VAR
+//config:	bool "$LINENO variable"
+//config:	default y
+//config:	depends on HUSH_BASH_COMPAT
+//config:
+//config:config HUSH_BASH_SOURCE_CURDIR
+//config:	bool "'source' and '.' builtins search current directory after $PATH"
+//config:	default n   # do not encourage non-standard behavior
+//config:	depends on HUSH_BASH_COMPAT
+//config:	help
+//config:	This is not compliant with standards. Avoid if possible.
+//config:
 //config:config HUSH_INTERACTIVE
 //config:	bool "Interactive mode"
 //config:	default y
@@ -253,6 +259,11 @@
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
 //config:
+//config:config HUSH_COMMAND
+//config:	bool "command builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
 //config:config HUSH_TRAP
 //config:	bool "trap builtin"
 //config:	default y
@@ -313,13 +324,13 @@
 //kbuild:lib-$(CONFIG_BASH_IS_HUSH) += hush.o match.o shell_common.o
 //kbuild:lib-$(CONFIG_HUSH_RANDOM_SUPPORT) += random.o
 
-/* -i (interactive) and -s (read stdin) are also accepted,
- * but currently do nothing, therefore aren't shown in help.
+/* -i (interactive) is also accepted,
+ * but does nothing, therefore not shown in help.
  * NOMMU-specific options are not meant to be used by users,
  * therefore we don't show them either.
  */
 //usage:#define hush_trivial_usage
-//usage:	"[-enxl] [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS]]"
+//usage:	"[-enxl] [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS] / -s [ARGS]]"
 //usage:#define hush_full_usage "\n\n"
 //usage:	"Unix shell interpreter"
 
@@ -441,6 +452,7 @@
 #define debug_printf_redir(...)  do {} while (0)
 #define debug_printf_list(...)   do {} while (0)
 #define debug_printf_subst(...)  do {} while (0)
+#define debug_printf_prompt(...) do {} while (0)
 #define debug_printf_clean(...)  do {} while (0)
 
 #define ERR_PTR ((void*)(long)1)
@@ -462,7 +474,10 @@
 # define MINUS_PLUS_EQUAL_QUESTION ("%#:-=+?" + 3)
 #endif
 
-#define SPECIAL_VAR_SYMBOL   3
+#define SPECIAL_VAR_SYMBOL_STR "\3"
+#define SPECIAL_VAR_SYMBOL       3
+/* The "variable" with name "\1" emits string "\3". Testcase: "echo ^C" */
+#define SPECIAL_VAR_QUOTED_SVS   1
 
 struct variable;
 
@@ -473,7 +488,6 @@ static const char hush_version_str[] ALI
  */
 #if !BB_MMU
 typedef struct nommu_save_t {
-	char **new_env;
 	struct variable *old_vars;
 	char **argv;
 	char **argv_from_re_execing;
@@ -520,7 +534,6 @@ typedef struct o_string {
 	 * possibly empty one: word"", wo''rd etc. */
 	smallint has_quoted_part;
 	smallint has_empty_slot;
-	smallint o_assignment; /* 0:maybe, 1:yes, 2:no */
 } o_string;
 enum {
 	EXP_FLAG_SINGLEWORD     = 0x80, /* must be 0x80 */
@@ -529,13 +542,6 @@ enum {
 	 * by prepending \ to *, ?, [, \ */
 	EXP_FLAG_ESC_GLOB_CHARS = 0x1,
 };
-enum {
-	MAYBE_ASSIGNMENT      = 0,
-	DEFINITELY_ASSIGNMENT = 1,
-	NOT_ASSIGNMENT        = 2,
-	/* Not an assignment, but next word may be: "if v=xyz cmd;" */
-	WORD_IS_KEYWORD       = 3,
-};
 /* Used for initialization: o_string foo = NULL_O_STRING; */
 #define NULL_O_STRING { NULL }
 
@@ -550,9 +556,6 @@ static const char *const assignment_flag
 
 typedef struct in_str {
 	const char *p;
-#if ENABLE_HUSH_INTERACTIVE
-	smallint promptmode; /* 0: PS1, 1: PS2 */
-#endif
 	int peek_buf[2];
 	int last_char;
 	FILE *file;
@@ -607,12 +610,17 @@ typedef enum redir_type {
 
 struct command {
 	pid_t pid;                  /* 0 if exited */
-	int assignment_cnt;         /* how many argv[i] are assignments? */
+	unsigned assignment_cnt;    /* how many argv[i] are assignments? */
+#if ENABLE_HUSH_LINENO_VAR
+	unsigned lineno;
+#endif
 	smallint cmd_type;          /* CMD_xxx */
 #define CMD_NORMAL   0
 #define CMD_SUBSHELL 1
-#if BASH_TEST2
-/* used for "[[ EXPR ]]" */
+#if BASH_TEST2 || ENABLE_HUSH_LOCAL || ENABLE_HUSH_EXPORT || ENABLE_HUSH_READONLY
+/* used for "[[ EXPR ]]", and to prevent word splitting and globbing in
+ * "export v=t*"
+ */
 # define CMD_SINGLEWORD_NOGLOB 2
 #endif
 #if ENABLE_HUSH_FUNCTIONS
@@ -690,9 +698,11 @@ struct parse_context {
 	struct command *command;
 	/* last redirect in command->redirects list */
 	struct redir_struct *pending_redirect;
+	o_string word;
 #if !BB_MMU
 	o_string as_string;
 #endif
+	smallint is_assignment; /* 0:maybe, 1:yes, 2:no, 3:keyword */
 #if HAS_KEYWORDS
 	smallint ctx_res_w;
 	smallint ctx_inverted; /* "! cmd | cmd" */
@@ -713,6 +723,13 @@ struct parse_context {
 	struct parse_context *stack;
 #endif
 };
+enum {
+	MAYBE_ASSIGNMENT      = 0,
+	DEFINITELY_ASSIGNMENT = 1,
+	NOT_ASSIGNMENT        = 2,
+	/* Not an assignment, but next word may be: "if v=xyz cmd;" */
+	WORD_IS_KEYWORD       = 3,
+};
 
 /* On program start, environ points to initial environment.
  * putenv adds new pointers into it, unsetenv removes them.
@@ -723,10 +740,8 @@ struct parse_context {
 struct variable {
 	struct variable *next;
 	char *varstr;        /* points to "name=" portion */
-#if ENABLE_HUSH_LOCAL
-	unsigned func_nest_level;
-#endif
 	int max_len;         /* if > 0, name is part of initial env; else name is malloced */
+	uint16_t var_nest_level;
 	smallint flg_export; /* putenv should be done on this var */
 	smallint flg_read_only;
 };
@@ -824,7 +839,7 @@ struct globals {
 	 * _AND_ if we decided to act interactively */
 	int interactive_fd;
 	const char *PS1;
-	const char *PS2;
+	IF_FEATURE_EDITING_FANCY_PROMPT(const char *PS2;)
 # define G_interactive_fd (G.interactive_fd)
 #else
 # define G_interactive_fd 0
@@ -872,6 +887,9 @@ struct globals {
 #else
 # define G_x_mode 0
 #endif
+#if ENABLE_HUSH_INTERACTIVE
+	smallint promptmode; /* 0: PS1, 1: PS2 */
+#endif
 	smallint flag_SIGINT;
 #if ENABLE_HUSH_LOOPS
 	smallint flag_break_continue;
@@ -887,8 +905,9 @@ struct globals {
 # define G_flag_return_in_progress 0
 #endif
 	smallint exiting; /* used to prevent EXIT trap recursion */
-	/* These four support $?, $#, and $1 */
+	/* These support $?, $#, and $1 */
 	smalluint last_exitcode;
+	smalluint expand_exitcode;
 	smalluint last_bg_pid_exitcode;
 #if ENABLE_HUSH_SET
 	/* are global_argv and global_argv[1..n] malloced? (note: not [0]) */
@@ -911,15 +930,17 @@ struct globals {
 	unsigned getopt_count;
 #endif
 	const char *ifs;
+	char *ifs_whitespace; /* = G.ifs or malloced */
 	const char *cwd;
 	struct variable *top_var;
 	char **expanded_assignments;
+	struct variable **shadowed_vars_pp;
+	unsigned var_nest_level;
 #if ENABLE_HUSH_FUNCTIONS
-	struct function *top_func;
 # if ENABLE_HUSH_LOCAL
-	struct variable **shadowed_vars_pp;
-	unsigned func_nest_level;
+	unsigned func_nest_level; /* solely to prevent "local v" in non-functions */
 # endif
+	struct function *top_func;
 #endif
 	/* Signal and trap handling */
 #if ENABLE_HUSH_FAST
@@ -927,6 +948,10 @@ struct globals {
 	unsigned handled_SIGCHLD;
 	smallint we_have_children;
 #endif
+#if ENABLE_HUSH_LINENO_VAR
+	unsigned lineno;
+	char *lineno_var;
+#endif
 	struct FILE_list *FILE_list;
 	/* Which signals have non-DFL handler (even with no traps set)?
 	 * Set at the start to:
@@ -1238,6 +1263,10 @@ static const struct built_in_command blt
 # define debug_printf_subst(...) (indent(), fdprintf(2, __VA_ARGS__))
 #endif
 
+#ifndef debug_printf_prompt
+# define debug_printf_prompt(...) (indent(), fdprintf(2, __VA_ARGS__))
+#endif
+
 #ifndef debug_printf_clean
 # define debug_printf_clean(...) (indent(), fdprintf(2, __VA_ARGS__))
 # define DEBUG_CLEAN 1
@@ -1384,7 +1413,7 @@ static void syntax_error_unexpected_ch(u
 #endif
 
 
-#if ENABLE_HUSH_INTERACTIVE
+#if ENABLE_HUSH_INTERACTIVE && ENABLE_FEATURE_EDITING_FANCY_PROMPT
 static void cmdedit_update_prompt(void);
 #else
 # define cmdedit_update_prompt() ((void)0)
@@ -1398,8 +1427,19 @@ static char *unbackslash(char *src)
 {
 	char *dst = src = strchrnul(src, '\\');
 	while (1) {
-		if (*src == '\\')
+		if (*src == '\\') {
 			src++;
+			if (*src != '\0') {
+				/* \x -> x */
+				*dst++ = *src++;
+				continue;
+			}
+			/* else: "\<nul>". Do not delete this backslash.
+			 * Testcase: eval 'echo ok\'
+			 */
+			*dst++ = '\\';
+			/* fallthrough */
+		}
 		if ((*dst++ = *src++) == '\0')
 			break;
 	}
@@ -1927,7 +1967,7 @@ static void hush_exit(int exitcode)
 	if (G.exiting <= 0 && G_traps && G_traps[0] && G_traps[0][0]) {
 		char *argv[3];
 		/* argv[0] is unused */
-		argv[1] = G_traps[0];
+		argv[1] = xstrdup(G_traps[0]); /* copy, since EXIT trap handler may modify G_traps[0] */
 		argv[2] = NULL;
 		G.exiting = 1; /* prevent EXIT trap recursion */
 		/* Note: G_traps[0] is not cleared!
@@ -1988,10 +2028,12 @@ static int check_and_run_traps(void)
 				smalluint save_rcode;
 				char *argv[3];
 				/* argv[0] is unused */
-				argv[1] = G_traps[sig];
+				argv[1] = xstrdup(G_traps[sig]);
+				/* why strdup? trap can modify itself: trap 'trap "echo oops" INT' INT */
 				argv[2] = NULL;
 				save_rcode = G.last_exitcode;
 				builtin_eval(argv);
+				free(argv[1]);
 //FIXME: shouldn't it be set to 128 + sig instead?
 				G.last_exitcode = save_rcode;
 				last_sig = sig;
@@ -2111,33 +2153,58 @@ static const char* FAST_FUNC get_local_v
 	return NULL;
 }
 
+static void handle_changed_special_names(const char *name, unsigned name_len)
+{
+	if (ENABLE_HUSH_INTERACTIVE && ENABLE_FEATURE_EDITING_FANCY_PROMPT
+	 && name_len == 3 && name[0] == 'P' && name[1] == 'S'
+	) {
+		cmdedit_update_prompt();
+		return;
+	}
+
+	if ((ENABLE_HUSH_LINENO_VAR || ENABLE_HUSH_GETOPTS)
+	 && name_len == 6
+	) {
+#if ENABLE_HUSH_LINENO_VAR
+		if (strncmp(name, "LINENO", 6) == 0) {
+			G.lineno_var = NULL;
+			return;
+		}
+#endif
+#if ENABLE_HUSH_GETOPTS
+		if (strncmp(name, "OPTIND", 6) == 0) {
+			G.getopt_count = 0;
+			return;
+		}
+#endif
+	}
+}
+
 /* str holds "NAME=VAL" and is expected to be malloced.
  * We take ownership of it.
  */
 #define SETFLAG_EXPORT   (1 << 0)
 #define SETFLAG_UNEXPORT (1 << 1)
 #define SETFLAG_MAKE_RO  (1 << 2)
-#define SETFLAG_LOCAL_SHIFT    3
+#define SETFLAG_VARLVL_SHIFT   3
 static int set_local_var(char *str, unsigned flags)
 {
-	struct variable **var_pp;
+	struct variable **cur_pp;
 	struct variable *cur;
 	char *free_me = NULL;
 	char *eq_sign;
 	int name_len;
-	IF_HUSH_LOCAL(unsigned local_lvl = (flags >> SETFLAG_LOCAL_SHIFT);)
+	unsigned local_lvl = (flags >> SETFLAG_VARLVL_SHIFT);
 
 	eq_sign = strchr(str, '=');
-	if (!eq_sign) { /* not expected to ever happen? */
-		free(str);
-		return -1;
-	}
+	if (HUSH_DEBUG && !eq_sign)
+		bb_error_msg_and_die("BUG in setvar");
 
 	name_len = eq_sign - str + 1; /* including '=' */
-	var_pp = &G.top_var;
-	while ((cur = *var_pp) != NULL) {
+	cur_pp = &G.top_var;
+	while ((cur = *cur_pp) != NULL) {
 		if (strncmp(cur->varstr, str, name_len) != 0) {
-			var_pp = &cur->next;
+			cur_pp = &cur->next;
 			continue;
 		}
 
@@ -2155,15 +2222,7 @@ static int set_local_var(char *str, unsi
 			unsetenv(str);
 			*eq_sign = '=';
 		}
-#if ENABLE_HUSH_LOCAL
-		if (cur->func_nest_level < local_lvl) {
-			/* New variable is declared as local,
-			 * and existing one is global, or local
-			 * from enclosing function.
-			 * Remove and save old one: */
-			*var_pp = cur->next;
-			cur->next = *G.shadowed_vars_pp;
-			*G.shadowed_vars_pp = cur;
+		if (cur->var_nest_level < local_lvl) {
 			/* bash 3.2.33(1) and exported vars:
 			 * # export z=z
 			 * # f() { local z=a; env | grep ^z; }
@@ -2174,17 +2233,46 @@ static int set_local_var(char *str, unsi
 			 */
 			if (cur->flg_export)
 				flags |= SETFLAG_EXPORT;
+			/* New variable is local ("local VAR=VAL" or
+			 * "VAR=VAL cmd")
+			 * and existing one is global, or local
+			 * on a lower level that new one.
+			 * Remove it from global variable list:
+			 */
+			*cur_pp = cur->next;
+			if (G.shadowed_vars_pp) {
+				/* Save in "shadowed" list */
+				debug_printf_env("shadowing %s'%s'/%u by '%s'/%u\n",
+					cur->flg_export ? "exported " : "",
+					cur->varstr, cur->var_nest_level, str, local_lvl
+				);
+				cur->next = *G.shadowed_vars_pp;
+				*G.shadowed_vars_pp = cur;
+			} else {
+				/* Came from pseudo_exec_argv(), no need to save: delete it */
+				debug_printf_env("shadow-deleting %s'%s'/%u by '%s'/%u\n",
+					cur->flg_export ? "exported " : "",
+					cur->varstr, cur->var_nest_level, str, local_lvl
+				);
+				if (cur->max_len == 0) /* allocated "VAR=VAL"? */
+					free_me = cur->varstr; /* then free it later */
+				free(cur);
+			}
 			break;
 		}
-#endif
+
 		if (strcmp(cur->varstr + name_len, eq_sign + 1) == 0) {
+			debug_printf_env("assignement '%s' does not change anything\n", str);
  free_and_exp:
 			free(str);
 			goto exp;
 		}
+
+		/* Replace the value in the found "struct variable" */
 		if (cur->max_len != 0) {
-			if (cur->max_len >= strlen(str)) {
+			if (cur->max_len >= strnlen(str, cur->max_len + 1)) {
 				/* This one is from startup env, reuse space */
+				debug_printf_env("reusing startup env for '%s'\n", str);
 				strcpy(cur->varstr, str);
 				goto free_and_exp;
 			}
@@ -2202,11 +2290,12 @@ static int set_local_var(char *str, unsi
 		goto set_str_and_exp;
 	}
 
-	/* Not found - create new variable struct */
+	/* Not found or shadowed - create new variable struct */
+	debug_printf_env("%s: alloc new var '%s'/%u\n", __func__, str, local_lvl);
 	cur = xzalloc(sizeof(*cur));
-	IF_HUSH_LOCAL(cur->func_nest_level = local_lvl;)
-	cur->next = *var_pp;
-	*var_pp = cur;
+	cur->var_nest_level = local_lvl;
+	cur->next = *cur_pp;
+	*cur_pp = cur;
 
  set_str_and_exp:
 	cur->varstr = str;
@@ -2218,20 +2307,13 @@ static int set_local_var(char *str, unsi
 #endif
 	if (flags & SETFLAG_EXPORT)
 		cur->flg_export = 1;
-	if (name_len == 4 && cur->varstr[0] == 'P' && cur->varstr[1] == 'S')
-		cmdedit_update_prompt();
-#if ENABLE_HUSH_GETOPTS
-	/* defoptindvar is a "OPTIND=..." constant string */
-	if (strncmp(cur->varstr, defoptindvar, 7) == 0)
-		G.getopt_count = 0;
-#endif
 	if (cur->flg_export) {
 		if (flags & SETFLAG_UNEXPORT) {
 			cur->flg_export = 0;
 			/* unsetenv was already done */
 		} else {
 			int i;
-			debug_printf_env("%s: putenv '%s'\n", __func__, cur->varstr);
+			debug_printf_env("%s: putenv '%s'/%u\n", __func__, cur->varstr, cur->var_nest_level);
 			i = putenv(cur->varstr);
 			/* only now we can free old exported malloced string */
 			free(free_me);
@@ -2239,6 +2321,9 @@ static int set_local_var(char *str, unsi
 		}
 	}
 	free(free_me);
+
+	handle_changed_special_names(cur->varstr, name_len - 1);
+
 	return 0;
 }
 
@@ -2248,62 +2333,48 @@ static void set_pwd_var(unsigned flag)
 	set_local_var(xasprintf("PWD=%s", get_cwd(/*force:*/ 1)), flag);
 }
 
+#if ENABLE_HUSH_UNSET || ENABLE_HUSH_GETOPTS
 static int unset_local_var_len(const char *name, int name_len)
 {
 	struct variable *cur;
-	struct variable **var_pp;
+	struct variable **cur_pp;
 
-	if (!name)
-		return EXIT_SUCCESS;
-#if ENABLE_HUSH_GETOPTS
-	if (name_len == 6 && strncmp(name, "OPTIND", 6) == 0)
-		G.getopt_count = 0;
-#endif
-	var_pp = &G.top_var;
-	while ((cur = *var_pp) != NULL) {
-		if (strncmp(cur->varstr, name, name_len) == 0 && cur->varstr[name_len] == '=') {
+	cur_pp = &G.top_var;
+	while ((cur = *cur_pp) != NULL) {
+		if (strncmp(cur->varstr, name, name_len) == 0
+		 && cur->varstr[name_len] == '='
+		) {
 			if (cur->flg_read_only) {
 				bb_error_msg("%s: readonly variable", name);
 				return EXIT_FAILURE;
 			}
-			*var_pp = cur->next;
+
+			*cur_pp = cur->next;
 			debug_printf_env("%s: unsetenv '%s'\n", __func__, cur->varstr);
 			bb_unsetenv(cur->varstr);
-			if (name_len == 3 && cur->varstr[0] == 'P' && cur->varstr[1] == 'S')
-				cmdedit_update_prompt();
 			if (!cur->max_len)
 				free(cur->varstr);
 			free(cur);
-			return EXIT_SUCCESS;
+
+			break;
 		}
-		var_pp = &cur->next;
+		cur_pp = &cur->next;
 	}
+
+	/* Handle "unset PS1" et al even if did not find the variable to unset */
+	handle_changed_special_names(name, name_len);
+
 	return EXIT_SUCCESS;
 }
 
-#if ENABLE_HUSH_UNSET || ENABLE_HUSH_GETOPTS
 static int unset_local_var(const char *name)
 {
 	return unset_local_var_len(name, strlen(name));
 }
 #endif
 
-static void unset_vars(char **strings)
-{
-	char **v;
-
-	if (!strings)
-		return;
-	v = strings;
-	while (*v) {
-		const char *eq = strchrnul(*v, '=');
-		unset_local_var_len(*v, (int)(eq - *v));
-		v++;
-	}
-	free(strings);
-}
-
-#if BASH_HOSTNAME_VAR || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_READ || ENABLE_HUSH_GETOPTS
+#if BASH_HOSTNAME_VAR || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_READ || ENABLE_HUSH_GETOPTS \
+ || (ENABLE_HUSH_INTERACTIVE && ENABLE_FEATURE_EDITING_FANCY_PROMPT)
 static void FAST_FUNC set_local_var_from_halves(const char *name, const char *val)
 {
 	char *var = xasprintf("%s=%s", name, val);
@@ -2324,22 +2395,27 @@ static void add_vars(struct variable *va
 		var->next = G.top_var;
 		G.top_var = var;
 		if (var->flg_export) {
-			debug_printf_env("%s: restoring exported '%s'\n", __func__, var->varstr);
+			debug_printf_env("%s: restoring exported '%s'/%u\n", __func__, var->varstr, var->var_nest_level);
 			putenv(var->varstr);
 		} else {
-			debug_printf_env("%s: restoring variable '%s'\n", __func__, var->varstr);
+			debug_printf_env("%s: restoring variable '%s'/%u\n", __func__, var->varstr, var->var_nest_level);
 		}
 		var = next;
 	}
 }
 
-static struct variable *set_vars_and_save_old(char **strings)
+/* We put strings[i] into variable table and possibly putenv them.
+ * If variable is read only, we can free the strings[i]
+ * which attempts to overwrite it.
+ * The strings[] vector itself is freed.
+ */
+static void set_vars_and_save_old(char **strings)
 {
 	char **s;
-	struct variable *old = NULL;
 
 	if (!strings)
-		return old;
+		return;
+
 	s = strings;
 	while (*s) {
 		struct variable *var_p;
@@ -2366,19 +2442,20 @@ static struct variable *set_vars_and_sav
 					do { *p = p[1]; p++; } while (*p);
 					goto next;
 				}
-				/* Remove variable from global linked list */
-				debug_printf_env("%s: removing '%s'\n", __func__, var_p->varstr);
-				*var_pp = var_p->next;
-				/* Add it to returned list */
-				var_p->next = old;
-				old = var_p;
+				/* below, set_local_var() with nest level will
+				 * "shadow" (remove) this variable from
+				 * global linked list.
+				 */
 			}
-			set_local_var(*s, SETFLAG_EXPORT);
+			debug_printf_env("%s: env override '%s'/%u\n", __func__, *s, G.var_nest_level);
+			set_local_var(*s, (G.var_nest_level << SETFLAG_VARLVL_SHIFT) | SETFLAG_EXPORT);
+		} else if (HUSH_DEBUG) {
+			bb_error_msg_and_die("BUG in varexp4");
 		}
- next:
 		s++;
+ next: ;
 	}
-	return old;
+	free(strings);
 }
 
 
@@ -2414,36 +2491,36 @@ static void reinit_unicode_for_hush(void
  *	\
  * It exercises a lot of corner cases.
  */
+# if ENABLE_FEATURE_EDITING_FANCY_PROMPT
 static void cmdedit_update_prompt(void)
 {
-	if (ENABLE_FEATURE_EDITING_FANCY_PROMPT) {
-		G.PS1 = get_local_var_value("PS1");
-		if (G.PS1 == NULL)
-			G.PS1 = "\\w \\$ ";
-		G.PS2 = get_local_var_value("PS2");
-	} else {
-		G.PS1 = NULL;
-	}
+	G.PS1 = get_local_var_value("PS1");
+	if (G.PS1 == NULL)
+		G.PS1 = "";
+	G.PS2 = get_local_var_value("PS2");
 	if (G.PS2 == NULL)
-		G.PS2 = "> ";
+		G.PS2 = "";
 }
-static const char *setup_prompt_string(int promptmode)
+# endif
+static const char *setup_prompt_string(void)
 {
 	const char *prompt_str;
-	debug_printf("setup_prompt_string %d ", promptmode);
-	if (!ENABLE_FEATURE_EDITING_FANCY_PROMPT) {
-		/* Set up the prompt */
-		if (promptmode == 0) { /* PS1 */
+
+	debug_printf_prompt("%s promptmode:%d\n", __func__, G.promptmode);
+
+	IF_FEATURE_EDITING_FANCY_PROMPT(    prompt_str = G.PS2;)
+	IF_NOT_FEATURE_EDITING_FANCY_PROMPT(prompt_str = "> ";)
+	if (G.promptmode == 0) { /* PS1 */
+		if (!ENABLE_FEATURE_EDITING_FANCY_PROMPT) {
+			/* No fancy prompts supported, (re)generate "CURDIR $ " by hand */
 			free((char*)G.PS1);
 			/* bash uses $PWD value, even if it is set by user.
 			 * It uses current dir only if PWD is unset.
 			 * We always use current dir. */
 			G.PS1 = xasprintf("%s %c ", get_cwd(0), (geteuid() != 0) ? '$' : '#');
-			prompt_str = G.PS1;
-		} else
-			prompt_str = G.PS2;
-	} else
-		prompt_str = (promptmode == 0) ? G.PS1 : G.PS2;
+		}
+		prompt_str = G.PS1;
+	}
 	debug_printf("prompt_str '%s'\n", prompt_str);
 	return prompt_str;
 }
@@ -2452,7 +2529,7 @@ static int get_user_input(struct in_str
 	int r;
 	const char *prompt_str;
 
-	prompt_str = setup_prompt_string(i->promptmode);
+	prompt_str = setup_prompt_string();
 # if ENABLE_FEATURE_EDITING
 	for (;;) {
 		reinit_unicode_for_hush();
@@ -2522,7 +2599,8 @@ static int fgetc_interactive(struct in_s
 	if (G_interactive_fd && i->file == stdin) {
 		/* Returns first char (or EOF), the rest is in i->p[] */
 		ch = get_user_input(i);
-		i->promptmode = 1; /* PS2 */
+		G.promptmode = 1; /* PS2 */
+		debug_printf_prompt("%s promptmode=%d\n", __func__, G.promptmode);
 	} else {
 		/* Not stdin: script file, sourced file, etc */
 		do ch = fgetc(i->file); while (ch == '\0');
@@ -2577,6 +2655,12 @@ static int i_getch(struct in_str *i)
  out:
 	debug_printf("file_get: got '%c' %d\n", ch, ch);
 	i->last_char = ch;
+#if ENABLE_HUSH_LINENO_VAR
+	if (ch == '\n') {
+		G.lineno++;
+		debug_printf_parse("G.lineno++ = %u\n", G.lineno);
+	}
+#endif
 	return ch;
 }
 
@@ -2650,10 +2734,45 @@ static int i_peek2(struct in_str *i)
 	return ch;
 }
 
+static int i_getch_and_eat_bkslash_nl(struct in_str *input)
+{
+	for (;;) {
+		int ch, ch2;
+
+		ch = i_getch(input);
+		if (ch != '\\')
+			return ch;
+		ch2 = i_peek(input);
+		if (ch2 != '\n')
+			return ch;
+		/* backslash+newline, skip it */
+		i_getch(input);
+	}
+}
+
+/* Note: this function _eats_ \<newline> pairs, safe to use plain
+ * i_getch() after it instead of i_getch_and_eat_bkslash_nl().
+ */
+static int i_peek_and_eat_bkslash_nl(struct in_str *input)
+{
+	for (;;) {
+		int ch, ch2;
+
+		ch = i_peek(input);
+		if (ch != '\\')
+			return ch;
+		ch2 = i_peek2(input);
+		if (ch2 != '\n')
+			return ch;
+		/* backslash+newline, skip it */
+		i_getch(input);
+		i_getch(input);
+	}
+}
+
 static void setup_file_in_str(struct in_str *i, FILE *f)
 {
 	memset(i, 0, sizeof(*i));
-	/* i->promptmode = 0; - PS1 (memset did it) */
 	i->file = f;
 	/* i->p = NULL; */
 }
@@ -2661,7 +2780,6 @@ static void setup_file_in_str(struct in_
 static void setup_string_in_str(struct in_str *i, const char *s)
 {
 	memset(i, 0, sizeof(*i));
-	/* i->promptmode = 0; - PS1 (memset did it) */
 	/*i->file = NULL */;
 	i->p = s;
 }
@@ -3078,7 +3196,7 @@ static int glob_brace(char *pattern, o_s
 				return o_save_ptr_helper(o, n);
 			}
 			if (gr == GLOB_NOSPACE)
-				bb_error_msg_and_die(bb_msg_memory_exhausted);
+				bb_die_memory_exhausted();
 			/* GLOB_ABORTED? Only happens with GLOB_ERR flag,
 			 * but we didn't specify it. Paranoia again. */
 			bb_error_msg_and_die("glob error %d on '%s'", gr, pattern);
@@ -3180,7 +3298,7 @@ static int perform_glob(o_string *o, int
 			goto literal;
 		}
 		if (gr == GLOB_NOSPACE)
-			bb_error_msg_and_die(bb_msg_memory_exhausted);
+			bb_die_memory_exhausted();
 		/* GLOB_ABORTED? Only happens with GLOB_ERR flag,
 		 * but we didn't specify it. Paranoia again. */
 		bb_error_msg_and_die("glob error %d on '%s'", gr, pattern);
@@ -3377,8 +3495,13 @@ static void debug_print_tree(struct pipe
 
 	pin = 0;
 	while (pi) {
-		fdprintf(2, "%*spipe %d res_word=%s followup=%d %s\n", lvl*2, "",
-				pin, RES[pi->res_word], pi->followup, PIPE[pi->followup]);
+		fdprintf(2, "%*spipe %d %sres_word=%s followup=%d %s\n",
+				lvl*2, "",
+				pin,
+				(IF_HAS_KEYWORDS(pi->pi_inverted ? "! " :) ""),
+				RES[pi->res_word],
+				pi->followup, PIPE[pi->followup]
+		);
 		prn = 0;
 		while (prn < pi->num_cmds) {
 			struct command *command = &pi->cmds[prn];
@@ -3387,6 +3510,9 @@ static void debug_print_tree(struct pipe
 			fdprintf(2, "%*s cmd %d assignment_cnt:%d",
 					lvl*2, "", prn,
 					command->assignment_cnt);
+#if ENABLE_HUSH_LINENO_VAR
+			fdprintf(2, " LINENO:%u", command->lineno);
+#endif
 			if (command->group) {
 				fdprintf(2, " group %s: (argv=%p)%s%s\n",
 						CMDTYPE[command->cmd_type],
@@ -3459,6 +3585,10 @@ static int done_command(struct parse_con
 	ctx->command = command = &pi->cmds[pi->num_cmds];
  clear_and_ret:
 	memset(command, 0, sizeof(*command));
+#if ENABLE_HUSH_LINENO_VAR
+	command->lineno = G.lineno;
+	debug_printf_parse("command->lineno = G.lineno (%u)\n", G.lineno);
+#endif
 	return pi->num_cmds; /* used only for 0/nonzero check */
 }
 
@@ -3567,6 +3697,8 @@ static void done_pipe(struct parse_conte
 static void initialize_context(struct parse_context *ctx)
 {
 	memset(ctx, 0, sizeof(*ctx));
+	if (MAYBE_ASSIGNMENT != 0)
+		ctx->is_assignment = MAYBE_ASSIGNMENT;
 	ctx->pipe = ctx->list_head = new_pipe();
 	/* Create the memory for command, roughly:
 	 * ctx->pipe->cmds = new struct command;
@@ -3646,9 +3778,9 @@ static const struct reserved_combo* matc
 	}
 	return NULL;
 }
-/* Return 0: not a keyword, 1: keyword
+/* Return NULL: not a keyword, else: keyword
  */
-static int reserved_word(o_string *word, struct parse_context *ctx)
+static const struct reserved_combo* reserved_word(struct parse_context *ctx)
 {
 # if ENABLE_HUSH_CASE
 	static const struct reserved_combo reserved_match = {
@@ -3657,11 +3789,11 @@ static int reserved_word(o_string *word,
 # endif
 	const struct reserved_combo *r;
 
-	if (word->has_quoted_part)
+	if (ctx->word.has_quoted_part)
 		return 0;
-	r = match_reserved_word(word);
+	r = match_reserved_word(&ctx->word);
 	if (!r)
-		return 0;
+		return r; /* NULL */
 
 	debug_printf("found reserved word %s, res %d\n", r->literal, r->res);
 # if ENABLE_HUSH_CASE
@@ -3676,7 +3808,7 @@ static int reserved_word(o_string *word,
 			ctx->ctx_res_w = RES_SNTX;
 		}
 		ctx->ctx_inverted = 1;
-		return 1;
+		return r;
 	}
 	if (r->flag & FLAG_START) {
 		struct parse_context *old;
@@ -3686,9 +3818,9 @@ static int reserved_word(o_string *word,
 		initialize_context(ctx);
 		ctx->stack = old;
 	} else if (/*ctx->ctx_res_w == RES_NONE ||*/ !(ctx->old_flag & (1 << r->res))) {
-		syntax_error_at(word->data);
+		syntax_error_at(ctx->word.data);
 		ctx->ctx_res_w = RES_SNTX;
-		return 1;
+		return r;
 	} else {
 		/* "{...} fi" is ok. "{...} if" is not
 		 * Example:
@@ -3699,8 +3831,8 @@ static int reserved_word(o_string *word,
 
 	ctx->ctx_res_w = r->res;
 	ctx->old_flag = r->flag;
-	word->o_assignment = r->assignment_flag;
-	debug_printf_parse("word->o_assignment='%s'\n", assignment_flag[word->o_assignment]);
+	ctx->is_assignment = r->assignment_flag;
+	debug_printf_parse("ctx->is_assignment='%s'\n", assignment_flag[ctx->is_assignment]);
 
 	if (ctx->old_flag & FLAG_END) {
 		struct parse_context *old;
@@ -3738,7 +3870,7 @@ static int reserved_word(o_string *word,
 		*ctx = *old;   /* physical copy */
 		free(old);
 	}
-	return 1;
+	return r;
 }
 #endif /* HAS_KEYWORDS */
 
@@ -3746,12 +3878,12 @@ static int reserved_word(o_string *word,
  * Normal return is 0. Syntax errors return 1.
  * Note: on return, word is reset, but not o_free'd!
  */
-static int done_word(o_string *word, struct parse_context *ctx)
+static int done_word(struct parse_context *ctx)
 {
 	struct command *command = ctx->command;
 
-	debug_printf_parse("done_word entered: '%s' %p\n", word->data, command);
-	if (word->length == 0 && !word->has_quoted_part) {
+	debug_printf_parse("done_word entered: '%s' %p\n", ctx->word.data, command);
+	if (ctx->word.length == 0 && !ctx->word.has_quoted_part) {
 		debug_printf_parse("done_word return 0: true null, ignored\n");
 		return 0;
 	}
@@ -3759,17 +3891,29 @@ static int done_word(o_string *word, str
 	if (ctx->pending_redirect) {
 		/* We do not glob in e.g. >*.tmp case. bash seems to glob here
 		 * only if run as "bash", not "sh" */
-		/* http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
+		/* http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html
 		 * "2.7 Redirection
-		 * ...the word that follows the redirection operator
-		 * shall be subjected to tilde expansion, parameter expansion,
-		 * command substitution, arithmetic expansion, and quote
-		 * removal. Pathname expansion shall not be performed
+		 * If the redirection operator is "<<" or "<<-", the word
+		 * that follows the redirection operator shall be
+		 * subjected to quote removal; it is unspecified whether
+		 * any of the other expansions occur. For the other
+		 * redirection operators, the word that follows the
+		 * redirection operator shall be subjected to tilde
+		 * expansion, parameter expansion, command substitution,
+		 * arithmetic expansion, and quote removal.
+		 * Pathname expansion shall not be performed
 		 * on the word by a non-interactive shell; an interactive
 		 * shell may perform it, but shall do so only when
 		 * the expansion would result in one word."
 		 */
-		ctx->pending_redirect->rd_filename = xstrdup(word->data);
+//bash does not do parameter/command substitution or arithmetic expansion
+//for _heredoc_ redirection word: these constructs look for exact eof marker
+// as written:
+// <<EOF$t
+// <<EOF$((1))
+// <<EOF`true`  [this case also makes heredoc "quoted", a-la <<"EOF". Probably bash-4.3.43 bug]
+
+		ctx->pending_redirect->rd_filename = xstrdup(ctx->word.data);
 		/* Cater for >\file case:
 		 * >\a creates file a; >\\a, >"\a", >"\\a" create file \a
 		 * Same with heredocs:
@@ -3778,17 +3922,17 @@ static int done_word(o_string *word, str
 		if (ctx->pending_redirect->rd_type == REDIRECT_HEREDOC) {
 			unbackslash(ctx->pending_redirect->rd_filename);
 			/* Is it <<"HEREDOC"? */
-			if (word->has_quoted_part) {
+			if (ctx->word.has_quoted_part) {
 				ctx->pending_redirect->rd_dup |= HEREDOC_QUOTED;
 			}
 		}
-		debug_printf_parse("word stored in rd_filename: '%s'\n", word->data);
+		debug_printf_parse("word stored in rd_filename: '%s'\n", ctx->word.data);
 		ctx->pending_redirect = NULL;
 	} else {
 #if HAS_KEYWORDS
 # if ENABLE_HUSH_CASE
 		if (ctx->ctx_dsemicolon
-		 && strcmp(word->data, "esac") != 0 /* not "... pattern) cmd;; esac" */
+		 && strcmp(ctx->word.data, "esac") != 0 /* not "... pattern) cmd;; esac" */
 		) {
 			/* already done when ctx_dsemicolon was set to 1: */
 			/* ctx->ctx_res_w = RES_MATCH; */
@@ -3804,25 +3948,65 @@ static int done_word(o_string *word, str
 		 && ctx->ctx_res_w != RES_CASE
 # endif
 		) {
-			int reserved = reserved_word(word, ctx);
-			debug_printf_parse("checking for reserved-ness: %d\n", reserved);
+			const struct reserved_combo *reserved;
+			reserved = reserved_word(ctx);
+			debug_printf_parse("checking for reserved-ness: %d\n", !!reserved);
 			if (reserved) {
-				o_reset_to_empty_unquoted(word);
+# if ENABLE_HUSH_LINENO_VAR
+/* Case:
+ * "while ...; do
+ *	cmd ..."
+ * If we don't close the pipe _now_, immediately after "do", lineno logic
+ * sees "cmd" as starting at "do" - i.e., at the previous line.
+ */
+				if (0
+				 IF_HUSH_IF(|| reserved->res == RES_THEN)
+				 IF_HUSH_IF(|| reserved->res == RES_ELIF)
+				 IF_HUSH_IF(|| reserved->res == RES_ELSE)
+				 IF_HUSH_LOOPS(|| reserved->res == RES_DO)
+				) {
+					done_pipe(ctx, PIPE_SEQ);
+				}
+# endif
+				o_reset_to_empty_unquoted(&ctx->word);
 				debug_printf_parse("done_word return %d\n",
 						(ctx->ctx_res_w == RES_SNTX));
 				return (ctx->ctx_res_w == RES_SNTX);
 			}
-# if BASH_TEST2
-			if (strcmp(word->data, "[[") == 0) {
+# if defined(CMD_SINGLEWORD_NOGLOB)
+			if (0
+#  if BASH_TEST2
+			 || strcmp(ctx->word.data, "[[") == 0
+#  endif
+			/* In bash, local/export/readonly are special, args
+			 * are assignments and therefore expansion of them
+			 * should be "one-word" expansion:
+			 *  $ export i=`echo 'a  b'` # one arg: "i=a  b"
+			 * compare with:
+			 *  $ ls i=`echo 'a  b'`     # two args: "i=a" and "b"
+			 *  ls: cannot access i=a: No such file or directory
+			 *  ls: cannot access b: No such file or directory
+			 * Note: bash 3.2.33(1) does this only if export word
+			 * itself is not quoted:
+			 *  $ export i=`echo 'aaa  bbb'`; echo "$i"
+			 *  aaa  bbb
+			 *  $ "export" i=`echo 'aaa  bbb'`; echo "$i"
+			 *  aaa
+			 */
+			 IF_HUSH_LOCAL(   || strcmp(ctx->word.data, "local") == 0)
+			 IF_HUSH_EXPORT(  || strcmp(ctx->word.data, "export") == 0)
+			 IF_HUSH_READONLY(|| strcmp(ctx->word.data, "readonly") == 0)
+			) {
 				command->cmd_type = CMD_SINGLEWORD_NOGLOB;
 			}
 			/* fall through */
 # endif
 		}
-#endif
+#endif /* HAS_KEYWORDS */
+
 		if (command->group) {
 			/* "{ echo foo; } echo bar" - bad */
-			syntax_error_at(word->data);
+			syntax_error_at(ctx->word.data);
 			debug_printf_parse("done_word return 1: syntax error, "
 					"groups and arglists don't mix\n");
 			return 1;
@@ -3830,41 +4014,26 @@ static int done_word(o_string *word, str
 
 		/* If this word wasn't an assignment, next ones definitely
 		 * can't be assignments. Even if they look like ones. */
-		if (word->o_assignment != DEFINITELY_ASSIGNMENT
-		 && word->o_assignment != WORD_IS_KEYWORD
+		if (ctx->is_assignment != DEFINITELY_ASSIGNMENT
+		 && ctx->is_assignment != WORD_IS_KEYWORD
 		) {
-			word->o_assignment = NOT_ASSIGNMENT;
+			ctx->is_assignment = NOT_ASSIGNMENT;
 		} else {
-			if (word->o_assignment == DEFINITELY_ASSIGNMENT) {
+			if (ctx->is_assignment == DEFINITELY_ASSIGNMENT) {
 				command->assignment_cnt++;
 				debug_printf_parse("++assignment_cnt=%d\n", command->assignment_cnt);
 			}
-			debug_printf_parse("word->o_assignment was:'%s'\n", assignment_flag[word->o_assignment]);
-			word->o_assignment = MAYBE_ASSIGNMENT;
-		}
-		debug_printf_parse("word->o_assignment='%s'\n", assignment_flag[word->o_assignment]);
-
-		if (word->has_quoted_part
-		 /* optimization: and if it's ("" or '') or ($v... or `cmd`...): */
-		 && (word->data[0] == '\0' || word->data[0] == SPECIAL_VAR_SYMBOL)
-		 /* (otherwise it's known to be not empty and is already safe) */
-		) {
-			/* exclude "$@" - it can expand to no word despite "" */
-			char *p = word->data;
-			while (p[0] == SPECIAL_VAR_SYMBOL
-			    && (p[1] & 0x7f) == '@'
-			    && p[2] == SPECIAL_VAR_SYMBOL
-			) {
-				p += 3;
-			}
+			debug_printf_parse("ctx->is_assignment was:'%s'\n", assignment_flag[ctx->is_assignment]);
+			ctx->is_assignment = MAYBE_ASSIGNMENT;
 		}
-		command->argv = add_string_to_strings(command->argv, xstrdup(word->data));
+		debug_printf_parse("ctx->is_assignment='%s'\n", assignment_flag[ctx->is_assignment]);
+		command->argv = add_string_to_strings(command->argv, xstrdup(ctx->word.data));
 		debug_print_strings("word appended to argv", command->argv);
 	}
 
 #if ENABLE_HUSH_LOOPS
 	if (ctx->ctx_res_w == RES_FOR) {
-		if (word->has_quoted_part
+		if (ctx->word.has_quoted_part
 		 || !is_well_formed_var_name(command->argv[0], '\0')
 		) {
 			/* bash says just "not a valid identifier" */
@@ -3885,7 +4054,7 @@ static int done_word(o_string *word, str
 	}
 #endif
 
-	o_reset_to_empty_unquoted(word);
+	o_reset_to_empty_unquoted(&ctx->word);
 
 	debug_printf_parse("done_word return 0\n");
 	return 0;
@@ -3956,7 +4125,7 @@ static int parse_redirect(struct parse_c
 		if (dup_num == REDIRFD_SYNTAX_ERR)
 			return 1;
 	} else {
-		int ch = i_peek(input);
+		int ch = i_peek_and_eat_bkslash_nl(input);
 		dup_num = (ch == '-'); /* HEREDOC_SKIPTABS bit is 1 */
 		if (dup_num) { /* <<-... */
 			ch = i_getch(input);
@@ -3966,7 +4135,7 @@ static int parse_redirect(struct parse_c
 	}
 
 	if (style == REDIRECT_OVERWRITE && dup_num == REDIRFD_TO_FILE) {
-		int ch = i_peek(input);
+		int ch = i_peek_and_eat_bkslash_nl(input);
 		if (ch == '|') {
 			/* >|FILE redirect ("clobbering" >).
 			 * Since we do not support "set -o noclobber" yet,
@@ -4169,25 +4338,26 @@ static struct pipe *parse_stream(char **
 		int end_trigger);
 
 
-#if !ENABLE_HUSH_FUNCTIONS
-#define parse_group(dest, ctx, input, ch) \
-	parse_group(ctx, input, ch)
-#endif
-static int parse_group(o_string *dest, struct parse_context *ctx,
+static int parse_group(struct parse_context *ctx,
 	struct in_str *input, int ch)
 {
-	/* dest contains characters seen prior to ( or {.
+	/* ctx->word contains characters seen prior to ( or {.
 	 * Typically it's empty, but for function defs,
 	 * it contains function name (without '()'). */
+#if BB_MMU
+# define as_string NULL
+#else
+	char *as_string = NULL;
+#endif
 	struct pipe *pipe_list;
 	int endch;
 	struct command *command = ctx->command;
 
 	debug_printf_parse("parse_group entered\n");
 #if ENABLE_HUSH_FUNCTIONS
-	if (ch == '(' && !dest->has_quoted_part) {
-		if (dest->length)
-			if (done_word(dest, ctx))
+	if (ch == '(' && !ctx->word.has_quoted_part) {
+		if (ctx->word.length)
+			if (done_word(ctx))
 				return 1;
 		if (!command->argv)
 			goto skip; /* (... */
@@ -4207,7 +4377,7 @@ static int parse_group(o_string *dest, s
 		do
 			ch = i_getch(input);
 		while (ch == ' ' || ch == '\t' || ch == '\n');
-		if (ch != '{') {
+		if (ch != '{' && ch != '(') {
 			syntax_error_unexpected_ch(ch);
 			return 1;
 		}
@@ -4219,8 +4389,8 @@ static int parse_group(o_string *dest, s
 
 #if 0 /* Prevented by caller */
 	if (command->argv /* word [word]{... */
-	 || dest->length /* word{... */
-	 || dest->has_quoted_part /* ""{... */
+	 || ctx->word.length /* word{... */
+	 || ctx->word.has_quoted_part /* ""{... */
 	) {
 		syntax_error(NULL);
 		debug_printf_parse("parse_group return 1: "
@@ -4229,13 +4399,13 @@ static int parse_group(o_string *dest, s
 	}
 #endif
 
-#if ENABLE_HUSH_FUNCTIONS
- skip:
-#endif
+ IF_HUSH_FUNCTIONS(skip:)
+
 	endch = '}';
 	if (ch == '(') {
 		endch = ')';
-		command->cmd_type = CMD_SUBSHELL;
+		IF_HUSH_FUNCTIONS(if (command->cmd_type != CMD_FUNCDEF))
+			command->cmd_type = CMD_SUBSHELL;
 	} else {
 		/* bash does not allow "{echo...", requires whitespace */
 		ch = i_peek(input);
@@ -4251,71 +4421,54 @@ static int parse_group(o_string *dest, s
 		}
 	}
 
-	{
-#if BB_MMU
-# define as_string NULL
-#else
-		char *as_string = NULL;
-#endif
-		pipe_list = parse_stream(&as_string, input, endch);
+	pipe_list = parse_stream(&as_string, input, endch);
 #if !BB_MMU
-		if (as_string)
-			o_addstr(&ctx->as_string, as_string);
+	if (as_string)
+		o_addstr(&ctx->as_string, as_string);
 #endif
-		/* empty ()/{} or parse error? */
-		if (!pipe_list || pipe_list == ERR_PTR) {
-			/* parse_stream already emitted error msg */
-			if (!BB_MMU)
-				free(as_string);
-			debug_printf_parse("parse_group return 1: "
-				"parse_stream returned %p\n", pipe_list);
-			return 1;
-		}
-		command->group = pipe_list;
+
+	/* empty ()/{} or parse error? */
+	if (!pipe_list || pipe_list == ERR_PTR) {
+		/* parse_stream already emitted error msg */
+		if (!BB_MMU)
+			free(as_string);
+		debug_printf_parse("parse_group return 1: "
+			"parse_stream returned %p\n", pipe_list);
+		return 1;
+	}
 #if !BB_MMU
-		as_string[strlen(as_string) - 1] = '\0'; /* plink ')' or '}' */
-		command->group_as_string = as_string;
-		debug_printf_parse("end of group, remembering as:'%s'\n",
-				command->group_as_string);
+	as_string[strlen(as_string) - 1] = '\0'; /* plink ')' or '}' */
+	command->group_as_string = as_string;
+	debug_printf_parse("end of group, remembering as:'%s'\n",
+			command->group_as_string);
 #endif
-#undef as_string
-	}
-	debug_printf_parse("parse_group return 0\n");
-	return 0;
-	/* command remains "open", available for possible redirects */
-}
 
-static int i_getch_and_eat_bkslash_nl(struct in_str *input)
-{
-	for (;;) {
-		int ch, ch2;
+#if ENABLE_HUSH_FUNCTIONS
+	/* Convert "f() (cmds)" to "f() {(cmds)}" */
+	if (command->cmd_type == CMD_FUNCDEF && endch == ')') {
+		struct command *cmd2;
+
+		cmd2 = xzalloc(sizeof(*cmd2));
+		cmd2->cmd_type = CMD_SUBSHELL;
+		cmd2->group = pipe_list;
+# if !BB_MMU
+//UNTESTED!
+		cmd2->group_as_string = command->group_as_string;
+		command->group_as_string = xasprintf("(%s)", command->group_as_string);
+# endif
 
-		ch = i_getch(input);
-		if (ch != '\\')
-			return ch;
-		ch2 = i_peek(input);
-		if (ch2 != '\n')
-			return ch;
-		/* backslash+newline, skip it */
-		i_getch(input);
+		pipe_list = new_pipe();
+		pipe_list->cmds = cmd2;
+		pipe_list->num_cmds = 1;
 	}
-}
+#endif
 
-static int i_peek_and_eat_bkslash_nl(struct in_str *input)
-{
-	for (;;) {
-		int ch, ch2;
+	command->group = pipe_list;
 
-		ch = i_peek(input);
-		if (ch != '\\')
-			return ch;
-		ch2 = i_peek2(input);
-		if (ch2 != '\n')
-			return ch;
-		/* backslash+newline, skip it */
-		i_getch(input);
-		i_getch(input);
-	}
+	debug_printf_parse("parse_group return 0\n");
+	return 0;
+	/* command remains "open", available for possible redirects */
+#undef as_string
 }
 
 #if ENABLE_HUSH_TICK || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_DOLLAR_OPS
@@ -4425,6 +4578,11 @@ static int add_till_closing_bracket(o_st
 # endif
 	end_ch &= (DOUBLE_CLOSE_CHAR_FLAG - 1);
 
+#if ENABLE_HUSH_INTERACTIVE
+	G.promptmode = 1; /* PS2 */
+#endif
+	debug_printf_prompt("%s promptmode=%d\n", __func__, G.promptmode);
+
 	while (1) {
 		ch = i_getch(input);
 		if (ch == EOF) {
@@ -4433,7 +4591,7 @@ static int add_till_closing_bracket(o_st
 		}
 		if (ch == end_ch
 # if BASH_SUBSTR || BASH_PATTERN_SUBST
-			|| ch == end_char2
+		 || ch == end_char2
 # endif
 		) {
 			if (!dbl)
@@ -4445,6 +4603,7 @@ static int add_till_closing_bracket(o_st
 			}
 		}
 		o_addchr(dest, ch);
+		//bb_error_msg("%s:o_addchr('%c')", __func__, ch);
 		if (ch == '(' || ch == '{') {
 			ch = (ch == '(' ? ')' : '}');
 			if (!add_till_closing_bracket(dest, input, ch))
@@ -4474,7 +4633,7 @@ static int add_till_closing_bracket(o_st
 			/* \x. Copy verbatim. Important for  \(, \) */
 			ch = i_getch(input);
 			if (ch == EOF) {
-				syntax_error_unterm_ch(')');
+				syntax_error_unterm_ch(end_ch);
 				return 0;
 			}
 #if 0
@@ -4485,9 +4644,11 @@ static int add_till_closing_bracket(o_st
 			}
 #endif
 			o_addchr(dest, ch);
+			//bb_error_msg("%s:o_addchr('%c') after '\\'", __func__, ch);
 			continue;
 		}
 	}
+	debug_printf_parse("%s return '%s' ch:'%c'\n", __func__, dest->data, ch);
 	return ch;
 }
 #endif /* ENABLE_HUSH_TICK || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_DOLLAR_OPS */
@@ -4506,9 +4667,10 @@ static int parse_dollar(o_string *as_str
 
 	debug_printf_parse("parse_dollar entered: ch='%c'\n", ch);
 	if (isalpha(ch)) {
+ make_var:
 		ch = i_getch(input);
 		nommu_addchr(as_string, ch);
- make_var:
+ /*make_var1:*/
 		o_addchr(dest, SPECIAL_VAR_SYMBOL);
 		while (1) {
 			debug_printf_parse(": '%c'\n", ch);
@@ -4701,19 +4863,22 @@ static int parse_dollar(o_string *as_str
 	}
 #endif
 	case '_':
+		goto make_var;
+#if 0
+	/* TODO: $_ and $-: */
+	/* $_ Shell or shell script name; or last argument of last command
+	 * (if last command wasn't a pipe; if it was, bash sets $_ to "");
+	 * but in command's env, set to full pathname used to invoke it */
+	/* $- Option flags set by set builtin or shell options (-i etc) */
 		ch = i_getch(input);
 		nommu_addchr(as_string, ch);
 		ch = i_peek_and_eat_bkslash_nl(input);
 		if (isalnum(ch)) { /* it's $_name or $_123 */
 			ch = '_';
-			goto make_var;
+			goto make_var1;
 		}
 		/* else: it's $_ */
-	/* TODO: $_ and $-: */
-	/* $_ Shell or shell script name; or last argument of last command
-	 * (if last command wasn't a pipe; if it was, bash sets $_ to "");
-	 * but in command's env, set to full pathname used to invoke it */
-	/* $- Option flags set by set builtin or shell options (-i etc) */
+#endif
 	default:
 		o_addQchr(dest, '$');
 	}
@@ -4775,8 +4940,12 @@ static int encode_string(o_string *as_st
 			ch, ch, !!(dest->o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
 	if (process_bkslash && ch == '\\') {
 		if (next == EOF) {
-			syntax_error("\\<eof>");
-			xfunc_die();
+			/* Testcase: in interactive shell a file with
+			 *  echo "unterminated string\<eof>
+			 * is sourced.
+			 */
+			syntax_error_unterm_ch('"');
+			return 0; /* error */
 		}
 		/* bash:
 		 * "The backslash retains its special meaning [in "..."]
@@ -4833,29 +5002,28 @@ static struct pipe *parse_stream(char **
 		int end_trigger)
 {
 	struct parse_context ctx;
-	o_string dest = NULL_O_STRING;
 	int heredoc_cnt;
 
 	/* Single-quote triggers a bypass of the main loop until its mate is
-	 * found.  When recursing, quote state is passed in via dest->o_expflags.
+	 * found.  When recursing, quote state is passed in via ctx.word.o_expflags.
 	 */
 	debug_printf_parse("parse_stream entered, end_trigger='%c'\n",
 			end_trigger ? end_trigger : 'X');
 	debug_enter();
 
-	/* If very first arg is "" or '', dest.data may end up NULL.
-	 * Preventing this: */
-	o_addchr(&dest, '\0');
-	dest.length = 0;
+	initialize_context(&ctx);
+
+	/* If very first arg is "" or '', ctx.word.data may end up NULL.
+	 * Preventing this:
+	 */
+	o_addchr(&ctx.word, '\0');
+	ctx.word.length = 0;
 
 	/* We used to separate words on $IFS here. This was wrong.
 	 * $IFS is used only for word splitting when $var is expanded,
 	 * here we should use blank chars as separators, not $IFS
 	 */
 
-	if (MAYBE_ASSIGNMENT != 0)
-		dest.o_assignment = MAYBE_ASSIGNMENT;
-	initialize_context(&ctx);
 	heredoc_cnt = 0;
 	while (1) {
 		const char *is_blank;
@@ -4867,7 +5035,7 @@ static struct pipe *parse_stream(char **
 
 		ch = i_getch(input);
 		debug_printf_parse(": ch=%c (%d) escape=%d\n",
-				ch, ch, !!(dest.o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
+				ch, ch, !!(ctx.word.o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
 		if (ch == EOF) {
 			struct pipe *pi;
 
@@ -4884,10 +5052,10 @@ static struct pipe *parse_stream(char **
 				goto parse_error;
 			}
 
-			if (done_word(&dest, &ctx)) {
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
-			o_free(&dest);
+			o_free(&ctx.word);
 			done_pipe(&ctx, PIPE_SEQ);
 			pi = ctx.list_head;
 			/* If we got nothing... */
@@ -4910,18 +5078,74 @@ static struct pipe *parse_stream(char **
 			debug_printf_parse("parse_stream return %p\n", pi);
 			return pi;
 		}
+
+		/* Handle "'" and "\" first, as they won't play nice with
+		 * i_peek_and_eat_bkslash_nl() anyway:
+		 *   echo z\\
+		 * and
+		 *   echo '\
+		 *   '
+		 * would break.
+		 */
+		if (ch == '\\') {
+			ch = i_getch(input);
+			if (ch == '\n')
+				continue; /* drop \<newline>, get next char */
+			nommu_addchr(&ctx.as_string, '\\');
+			o_addchr(&ctx.word, '\\');
+			if (ch == EOF) {
+				/* Testcase: eval 'echo Ok\' */
+				/* bash-4.3.43 was removing backslash,
+				 * but 4.4.19 retains it, most other shells too
+				 */
+				continue; /* get next char */
+			}
+			/* Example: echo Hello \2>file
+			 * we need to know that word 2 is quoted
+			 */
+			ctx.word.has_quoted_part = 1;
+			nommu_addchr(&ctx.as_string, ch);
+			o_addchr(&ctx.word, ch);
+			continue; /* get next char */
+		}
 		nommu_addchr(&ctx.as_string, ch);
+		if (ch == '\'') {
+			ctx.word.has_quoted_part = 1;
+			next = i_getch(input);
+			if (next == '\'' && !ctx.pending_redirect)
+				goto insert_empty_quoted_str_marker;
+
+			ch = next;
+			while (1) {
+				if (ch == EOF) {
+					syntax_error_unterm_ch('\'');
+					goto parse_error;
+				}
+				nommu_addchr(&ctx.as_string, ch);
+				if (ch == '\'')
+					break;
+				if (ch == SPECIAL_VAR_SYMBOL) {
+					/* Convert raw ^C to corresponding special variable reference */
+					o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
+					o_addchr(&ctx.word, SPECIAL_VAR_QUOTED_SVS);
+				}
+				o_addqchr(&ctx.word, ch);
+				ch = i_getch(input);
+			}
+			continue; /* get next char */
+		}
 
 		next = '\0';
 		if (ch != '\n')
-			next = i_peek(input);
+			next = i_peek_and_eat_bkslash_nl(input);
 
-		is_special = "{}<>;&|()#'" /* special outside of "str" */
-				"\\$\"" IF_HUSH_TICK("`"); /* always special */
+		is_special = "{}<>;&|()#" /* special outside of "str" */
+				"$\"" IF_HUSH_TICK("`") /* always special */
+				SPECIAL_VAR_SYMBOL_STR;
 		/* Are { and } special here? */
 		if (ctx.command->argv /* word [word]{... - non-special */
-		 || dest.length       /* word{... - non-special */
-		 || dest.has_quoted_part     /* ""{... - non-special */
+		 || ctx.word.length       /* word{... - non-special */
+		 || ctx.word.has_quoted_part     /* ""{... - non-special */
 		 || (next != ';'             /* }; - special */
 		    && next != ')'           /* }) - special */
 		    && next != '('           /* {( - special */
@@ -4938,20 +5162,36 @@ static struct pipe *parse_stream(char **
 
 		if (!is_special && !is_blank) { /* ordinary char */
  ordinary_char:
-			o_addQchr(&dest, ch);
-			if ((dest.o_assignment == MAYBE_ASSIGNMENT
-			    || dest.o_assignment == WORD_IS_KEYWORD)
+			o_addQchr(&ctx.word, ch);
+			if ((ctx.is_assignment == MAYBE_ASSIGNMENT
+			    || ctx.is_assignment == WORD_IS_KEYWORD)
 			 && ch == '='
-			 && is_well_formed_var_name(dest.data, '=')
+			 && is_well_formed_var_name(ctx.word.data, '=')
 			) {
-				dest.o_assignment = DEFINITELY_ASSIGNMENT;
-				debug_printf_parse("dest.o_assignment='%s'\n", assignment_flag[dest.o_assignment]);
+				ctx.is_assignment = DEFINITELY_ASSIGNMENT;
+				debug_printf_parse("ctx.is_assignment='%s'\n", assignment_flag[ctx.is_assignment]);
 			}
 			continue;
 		}
 
 		if (is_blank) {
-			if (done_word(&dest, &ctx)) {
+#if ENABLE_HUSH_LINENO_VAR
+/* Case:
+ * "while ...; do<whitespace><newline>
+ *	cmd ..."
+ * would think that "cmd" starts in <whitespace> -
+ * i.e., at the previous line.
+ * We need to skip all whitespace before newlines.
+ */
+			while (ch != '\n') {
+				next = i_peek(input);
+				if (next != ' ' && next != '\t' && next != '\n')
+					break; /* next char is not ws */
+				ch = i_getch(input);
+			}
+			/* ch == last eaten whitespace char */
+#endif
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 			if (ch == '\n') {
@@ -4961,7 +5201,7 @@ static struct pipe *parse_stream(char **
 				 * "case ... in <newline> word) ..."
 				 */
 				if (IS_NULL_CMD(ctx.command)
-				 && dest.length == 0 && !dest.has_quoted_part
+				 && ctx.word.length == 0 && !ctx.word.has_quoted_part
 				) {
 					/* This newline can be ignored. But...
 					 * Without check #1, interactive shell
@@ -4996,8 +5236,8 @@ static struct pipe *parse_stream(char **
 					}
 					heredoc_cnt = 0;
 				}
-				dest.o_assignment = MAYBE_ASSIGNMENT;
-				debug_printf_parse("dest.o_assignment='%s'\n", assignment_flag[dest.o_assignment]);
+				ctx.is_assignment = MAYBE_ASSIGNMENT;
+				debug_printf_parse("ctx.is_assignment='%s'\n", assignment_flag[ctx.is_assignment]);
 				ch = ';';
 				/* note: if (is_blank) continue;
 				 * will still trigger for us */
@@ -5009,8 +5249,8 @@ static struct pipe *parse_stream(char **
 		 * Pathological example: { ""}; } should exec "}" cmd
 		 */
 		if (ch == '}') {
-			if (dest.length != 0 /* word} */
-			 || dest.has_quoted_part    /* ""} */
+			if (ctx.word.length != 0 /* word} */
+			 || ctx.word.has_quoted_part    /* ""} */
 			) {
 				goto ordinary_char;
 			}
@@ -5039,7 +5279,7 @@ static struct pipe *parse_stream(char **
 #if ENABLE_HUSH_CASE
 		 && (ch != ')'
 		    || ctx.ctx_res_w != RES_MATCH
-		    || (!dest.has_quoted_part && strcmp(dest.data, "esac") == 0)
+		    || (!ctx.word.has_quoted_part && strcmp(ctx.word.data, "esac") == 0)
 		    )
 #endif
 		) {
@@ -5056,17 +5296,17 @@ static struct pipe *parse_stream(char **
 				syntax_error_unterm_str("here document");
 				goto parse_error;
 			}
-			if (done_word(&dest, &ctx)) {
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 			done_pipe(&ctx, PIPE_SEQ);
-			dest.o_assignment = MAYBE_ASSIGNMENT;
-			debug_printf_parse("dest.o_assignment='%s'\n", assignment_flag[dest.o_assignment]);
+			ctx.is_assignment = MAYBE_ASSIGNMENT;
+			debug_printf_parse("ctx.is_assignment='%s'\n", assignment_flag[ctx.is_assignment]);
 			/* Do we sit outside of any if's, loops or case's? */
 			if (!HAS_KEYWORDS
 			IF_HAS_KEYWORDS(|| (ctx.ctx_res_w == RES_NONE && ctx.old_flag == 0))
 			) {
-				o_free(&dest);
+				o_free(&ctx.word);
 #if !BB_MMU
 				debug_printf_parse("as_string2 '%s'\n", ctx.as_string.data);
 				if (pstring)
@@ -5087,7 +5327,7 @@ static struct pipe *parse_stream(char **
 				return ctx.list_head;
 			}
 		}
- skip_end_trigger:
+
 		if (is_blank)
 			continue;
 
@@ -5095,8 +5335,8 @@ static struct pipe *parse_stream(char **
 		 * an assignment. a=1 2>z b=2: b=2 is still assignment */
 		switch (ch) {
 		case '>':
-			redir_fd = redirect_opt_num(&dest);
-			if (done_word(&dest, &ctx)) {
+			redir_fd = redirect_opt_num(&ctx.word);
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 			redir_style = REDIRECT_OVERWRITE;
@@ -5113,10 +5353,10 @@ static struct pipe *parse_stream(char **
 #endif
 			if (parse_redirect(&ctx, redir_fd, redir_style, input))
 				goto parse_error;
-			continue; /* back to top of while (1) */
+			continue; /* get next char */
 		case '<':
-			redir_fd = redirect_opt_num(&dest);
-			if (done_word(&dest, &ctx)) {
+			redir_fd = redirect_opt_num(&ctx.word);
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 			redir_style = REDIRECT_INPUT;
@@ -5139,9 +5379,9 @@ static struct pipe *parse_stream(char **
 #endif
 			if (parse_redirect(&ctx, redir_fd, redir_style, input))
 				goto parse_error;
-			continue; /* back to top of while (1) */
+			continue; /* get next char */
 		case '#':
-			if (dest.length == 0 && !dest.has_quoted_part) {
+			if (ctx.word.length == 0 && !ctx.word.has_quoted_part) {
 				/* skip "#comment" */
 				/* note: we do not add it to &ctx.as_string */
 /* TODO: in bash:
@@ -5160,115 +5400,80 @@ static struct pipe *parse_stream(char **
 					if (ch == EOF)
 						break;
 				}
-				continue; /* back to top of while (1) */
-			}
-			break;
-		case '\\':
-			if (next == '\n') {
-				/* It's "\<newline>" */
-#if !BB_MMU
-				/* Remove trailing '\' from ctx.as_string */
-				ctx.as_string.data[--ctx.as_string.length] = '\0';
-#endif
-				ch = i_getch(input); /* eat it */
-				continue; /* back to top of while (1) */
+				continue; /* get next char */
 			}
 			break;
 		}
+ skip_end_trigger:
 
-		if (dest.o_assignment == MAYBE_ASSIGNMENT
+		if (ctx.is_assignment == MAYBE_ASSIGNMENT
 		 /* check that we are not in word in "a=1 2>word b=1": */
 		 && !ctx.pending_redirect
 		) {
 			/* ch is a special char and thus this word
 			 * cannot be an assignment */
-			dest.o_assignment = NOT_ASSIGNMENT;
-			debug_printf_parse("dest.o_assignment='%s'\n", assignment_flag[dest.o_assignment]);
+			ctx.is_assignment = NOT_ASSIGNMENT;
+			debug_printf_parse("ctx.is_assignment='%s'\n", assignment_flag[ctx.is_assignment]);
 		}
 
 		/* Note: nommu_addchr(&ctx.as_string, ch) is already done */
 
 		switch (ch) {
-		case '#': /* non-comment #: "echo a#b" etc */
-			o_addQchr(&dest, ch);
-			break;
-		case '\\':
-			if (next == EOF) {
-				syntax_error("\\<eof>");
-				xfunc_die();
-			}
-			ch = i_getch(input);
-			/* note: ch != '\n' (that case does not reach this place) */
-			o_addchr(&dest, '\\');
-			/*nommu_addchr(&ctx.as_string, '\\'); - already done */
-			o_addchr(&dest, ch);
-			nommu_addchr(&ctx.as_string, ch);
-			/* Example: echo Hello \2>file
-			 * we need to know that word 2 is quoted */
-			dest.has_quoted_part = 1;
-			break;
+		case SPECIAL_VAR_SYMBOL:
+			/* Convert raw ^C to corresponding special variable reference */
+			o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
+			o_addchr(&ctx.word, SPECIAL_VAR_QUOTED_SVS);
+			/* fall through */
+		case '#':
+			/* non-comment #: "echo a#b" etc */
+			o_addchr(&ctx.word, ch);
+			continue; /* get next char */
 		case '$':
-			if (!parse_dollar(&ctx.as_string, &dest, input, /*quote_mask:*/ 0)) {
+			if (!parse_dollar(&ctx.as_string, &ctx.word, input, /*quote_mask:*/ 0)) {
 				debug_printf_parse("parse_stream parse error: "
 					"parse_dollar returned 0 (error)\n");
 				goto parse_error;
 			}
-			break;
-		case '\'':
-			dest.has_quoted_part = 1;
-			if (next == '\'' && !ctx.pending_redirect) {
+			continue; /* get next char */
+		case '"':
+			ctx.word.has_quoted_part = 1;
+			if (next == '"' && !ctx.pending_redirect) {
+				i_getch(input); /* eat second " */
  insert_empty_quoted_str_marker:
 				nommu_addchr(&ctx.as_string, next);
-				i_getch(input); /* eat second ' */
-				o_addchr(&dest, SPECIAL_VAR_SYMBOL);
-				o_addchr(&dest, SPECIAL_VAR_SYMBOL);
-			} else {
-				while (1) {
-					ch = i_getch(input);
-					if (ch == EOF) {
-						syntax_error_unterm_ch('\'');
-						goto parse_error;
-					}
-					nommu_addchr(&ctx.as_string, ch);
-					if (ch == '\'')
-						break;
-					o_addqchr(&dest, ch);
-				}
-			}
-			break;
-		case '"':
-			dest.has_quoted_part = 1;
-			if (next == '"' && !ctx.pending_redirect)
-				goto insert_empty_quoted_str_marker;
-			if (dest.o_assignment == NOT_ASSIGNMENT)
-				dest.o_expflags |= EXP_FLAG_ESC_GLOB_CHARS;
-			if (!encode_string(&ctx.as_string, &dest, input, '"', /*process_bkslash:*/ 1))
+				o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
+				o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
+				continue; /* get next char */
+			}
+			if (ctx.is_assignment == NOT_ASSIGNMENT)
+				ctx.word.o_expflags |= EXP_FLAG_ESC_GLOB_CHARS;
+			if (!encode_string(&ctx.as_string, &ctx.word, input, '"', /*process_bkslash:*/ 1))
 				goto parse_error;
-			dest.o_expflags &= ~EXP_FLAG_ESC_GLOB_CHARS;
-			break;
+			ctx.word.o_expflags &= ~EXP_FLAG_ESC_GLOB_CHARS;
+			continue; /* get next char */
 #if ENABLE_HUSH_TICK
 		case '`': {
 			USE_FOR_NOMMU(unsigned pos;)
 
-			o_addchr(&dest, SPECIAL_VAR_SYMBOL);
-			o_addchr(&dest, '`');
-			USE_FOR_NOMMU(pos = dest.length;)
-			if (!add_till_backquote(&dest, input, /*in_dquote:*/ 0))
+			o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
+			o_addchr(&ctx.word, '`');
+			USE_FOR_NOMMU(pos = ctx.word.length;)
+			if (!add_till_backquote(&ctx.word, input, /*in_dquote:*/ 0))
 				goto parse_error;
 # if !BB_MMU
-			o_addstr(&ctx.as_string, dest.data + pos);
+			o_addstr(&ctx.as_string, ctx.word.data + pos);
 			o_addchr(&ctx.as_string, '`');
 # endif
-			o_addchr(&dest, SPECIAL_VAR_SYMBOL);
-			//debug_printf_subst("SUBST RES3 '%s'\n", dest.data + pos);
-			break;
+			o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
+			//debug_printf_subst("SUBST RES3 '%s'\n", ctx.word.data + pos);
+			continue; /* get next char */
 		}
 #endif
 		case ';':
 #if ENABLE_HUSH_CASE
  case_semi:
 #endif
-			if (done_word(&dest, &ctx)) {
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 			done_pipe(&ctx, PIPE_SEQ);
@@ -5276,7 +5481,7 @@ static struct pipe *parse_stream(char **
 			/* Eat multiple semicolons, detect
 			 * whether it means something special */
 			while (1) {
-				ch = i_peek(input);
+				ch = i_peek_and_eat_bkslash_nl(input);
 				if (ch != ';')
 					break;
 				ch = i_getch(input);
@@ -5291,11 +5496,11 @@ static struct pipe *parse_stream(char **
  new_cmd:
 			/* We just finished a cmd. New one may start
 			 * with an assignment */
-			dest.o_assignment = MAYBE_ASSIGNMENT;
-			debug_printf_parse("dest.o_assignment='%s'\n", assignment_flag[dest.o_assignment]);
-			break;
+			ctx.is_assignment = MAYBE_ASSIGNMENT;
+			debug_printf_parse("ctx.is_assignment='%s'\n", assignment_flag[ctx.is_assignment]);
+			continue; /* get next char */
 		case '&':
-			if (done_word(&dest, &ctx)) {
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 			if (next == '&') {
@@ -5307,7 +5512,7 @@ static struct pipe *parse_stream(char **
 			}
 			goto new_cmd;
 		case '|':
-			if (done_word(&dest, &ctx)) {
+			if (done_word(&ctx)) {
 				goto parse_error;
 			}
 #if ENABLE_HUSH_CASE
@@ -5330,14 +5535,14 @@ static struct pipe *parse_stream(char **
 			/* "case... in [(]word)..." - skip '(' */
 			if (ctx.ctx_res_w == RES_MATCH
 			 && ctx.command->argv == NULL /* not (word|(... */
-			 && dest.length == 0 /* not word(... */
-			 && dest.has_quoted_part == 0 /* not ""(... */
+			 && ctx.word.length == 0 /* not word(... */
+			 && ctx.word.has_quoted_part == 0 /* not ""(... */
 			) {
-				continue;
+				continue; /* get next char */
 			}
 #endif
 		case '{':
-			if (parse_group(&dest, &ctx, input, ch) != 0) {
+			if (parse_group(&ctx, input, ch) != 0) {
 				goto parse_error;
 			}
 			goto new_cmd;
@@ -5355,7 +5560,7 @@ static struct pipe *parse_stream(char **
 			goto parse_error2;
 		default:
 			if (HUSH_DEBUG)
-				bb_error_msg_and_die("BUG: unexpected %c\n", ch);
+				bb_error_msg_and_die("BUG: unexpected %c", ch);
 		}
 	} /* while (1) */
 
@@ -5394,7 +5599,7 @@ static struct pipe *parse_stream(char **
 			IF_HAS_KEYWORDS(pctx = p2;)
 		} while (HAS_KEYWORDS && pctx);
 
-		o_free(&dest);
+		o_free(&ctx.word);
 #if !BB_MMU
 		if (pstring)
 			*pstring = NULL;
@@ -5409,11 +5614,10 @@ static struct pipe *parse_stream(char **
 
 /* Expansion can recurse, need forward decls: */
 #if !BASH_PATTERN_SUBST && !ENABLE_HUSH_CASE
-/* only ${var/pattern/repl} (its pattern part) needs additional mode */
-#define expand_string_to_string(str, do_unbackslash) \
+#define expand_string_to_string(str, EXP_flags, do_unbackslash) \
 	expand_string_to_string(str)
 #endif
-static char *expand_string_to_string(const char *str, int do_unbackslash);
+static char *expand_string_to_string(const char *str, int EXP_flags, int do_unbackslash);
 #if ENABLE_HUSH_TICK
 static int process_command_subs(o_string *dest, const char *s);
 #endif
@@ -5496,10 +5700,20 @@ static int expand_on_ifs(int *ended_with
 
 		/* We know str here points to at least one IFS char */
 		last_is_ifs = 1;
-		str += strspn(str, G.ifs); /* skip IFS chars */
+		str += strspn(str, G.ifs_whitespace); /* skip IFS whitespace chars */
 		if (!*str)  /* EOL - do not finalize word */
 			break;
 
+		if (G.ifs_whitespace != G.ifs /* usually false ($IFS is usually all whitespace), */
+		 && strchr(G.ifs, *str)       /* the second check would fail */
+		) {
+			/* This is a non-whitespace $IFS char */
+			/* Skip it and IFS whitespace chars, start new word */
+			str++;
+			str += strspn(str, G.ifs_whitespace);
+			goto new_word;
+		}
+
 		/* Start new word... but not always! */
 		/* Case "v=' a'; echo ''$v": we do need to finalize empty word: */
 		if (output->has_quoted_part
@@ -5510,6 +5724,7 @@ static int expand_on_ifs(int *ended_with
 		 */
 		 || (n > 0 && output->data[output->length - 1])
 		) {
+ new_word:
 			o_addchr(output, '\0');
 			debug_print_list("expand_on_ifs", output, n);
 			n = o_save_ptr(output, n);
@@ -5559,7 +5774,10 @@ static char *encode_then_expand_string(c
 	encode_string(NULL, &dest, &input, EOF, process_bkslash);
 //TODO: error check (encode_string returns 0 on error)?
 	//bb_error_msg("'%s' -> '%s'", str, dest.data);
-	exp_str = expand_string_to_string(dest.data, /*unbackslash:*/ do_unbackslash);
+	exp_str = expand_string_to_string(dest.data,
+			do_unbackslash ? EXP_FLAG_ESC_GLOB_CHARS : 0,
+			do_unbackslash
+	);
 	//bb_error_msg("'%s' -> '%s'", dest.data, exp_str);
 	o_free_unsafe(&dest);
 	return exp_str;
@@ -5613,6 +5831,10 @@ static char *replace_pattern(char *val,
 	unsigned res_len = 0;
 	unsigned repl_len = strlen(repl);
 
+	/* Null pattern never matches, including if "var" is empty */
+	if (!pattern[0])
+		return result; /* NULL, no replaces happened */
+
 	while (1) {
 		int size;
 		char *s = strstr_pattern(val, pattern, &size);
@@ -5643,9 +5865,9 @@ static char *replace_pattern(char *val,
  */
 static NOINLINE const char *expand_one_var(char **to_be_freed_pp, char *arg, char **pp)
 {
-	const char *val = NULL;
-	char *to_be_freed = NULL;
-	char *p = *pp;
+	const char *val;
+	char *to_be_freed;
+	char *p;
 	char *var;
 	char first_char;
 	char exp_op;
@@ -5654,6 +5876,9 @@ static NOINLINE const char *expand_one_v
 	char *exp_word = exp_word; /* for compiler */
 	char arg0;
 
+	val = NULL;
+	to_be_freed = NULL;
+	p = *pp;
 	*p = '\0'; /* replace trailing SPECIAL_VAR_SYMBOL */
 	var = arg;
 	exp_saveptr = arg[1] ? strchr(VAR_ENCODED_SUBST_OPS, arg[1]) : NULL;
@@ -5748,17 +5973,24 @@ static NOINLINE const char *expand_one_v
 				unsigned scan_flags = pick_scan(exp_op, *exp_word);
 				if (exp_op == *exp_word)  /* ## or %% */
 					exp_word++;
-				exp_exp_word = encode_then_expand_string(exp_word, /*process_bkslash:*/ 1, /*unbackslash:*/ 1);
+				debug_printf_expand("expand: exp_word:'%s'\n", exp_word);
+				/*
+				 * process_bkslash:1 unbackslash:1 breaks this:
+				 * a='a\\'; echo ${a%\\\\} # correct output is: a
+				 * process_bkslash:1 unbackslash:0 breaks this:
+				 * a='a}'; echo ${a%\}}    # correct output is: a
+				 */
+				exp_exp_word = encode_then_expand_string(exp_word, /*process_bkslash:*/ 0, /*unbackslash:*/ 0);
 				if (exp_exp_word)
 					exp_word = exp_exp_word;
+				debug_printf_expand("expand: exp_exp_word:'%s'\n", exp_word);
 				/* HACK ALERT. We depend here on the fact that
 				 * G.global_argv and results of utoa and get_local_var_value
 				 * are actually in writable memory:
 				 * scan_and_match momentarily stores NULs there. */
 				t = (char*)val;
 				loc = scan_and_match(t, exp_word, scan_flags);
-				//bb_error_msg("op:%c str:'%s' pat:'%s' res:'%s'",
-				//		exp_op, t, exp_word, loc);
+				debug_printf_expand("op:%c str:'%s' pat:'%s' res:'%s'\n", exp_op, t, exp_word, loc);
 				free(exp_exp_word);
 				if (loc) { /* match was found */
 					if (scan_flags & SCAN_MATCH_LEFT_HALF) /* #[#] */
@@ -5776,17 +6008,15 @@ static NOINLINE const char *expand_one_v
 			 * and if // is used, it is encoded as \:
 			 * var\pattern<SPECIAL_VAR_SYMBOL>repl<SPECIAL_VAR_SYMBOL>
 			 */
-			/* Empty variable always gives nothing: */
-			// "v=''; echo ${v/*/w}" prints "", not "w"
 			if (val && val[0]) {
 				/* pattern uses non-standard expansion.
 				 * repl should be unbackslashed and globbed
 				 * by the usual expansion rules:
-				 * >az; >bz;
-				 * v='a bz'; echo "${v/a*z/a*z}" prints "a*z"
-				 * v='a bz'; echo "${v/a*z/\z}"  prints "\z"
-				 * v='a bz'; echo ${v/a*z/a*z}   prints "az"
-				 * v='a bz'; echo ${v/a*z/\z}    prints "z"
+				 *  >az >bz
+				 *  v='a bz'; echo "${v/a*z/a*z}" #prints "a*z"
+				 *  v='a bz'; echo "${v/a*z/\z}"  #prints "z"
+				 *  v='a bz'; echo ${v/a*z/a*z}   #prints "az"
+				 *  v='a bz'; echo ${v/a*z/\z}    #prints "z"
 				 * (note that a*z _pattern_ is never globbed!)
 				 */
 				char *pattern, *repl, *t;
@@ -5798,7 +6028,7 @@ static NOINLINE const char *expand_one_v
 				exp_word = p;
 				p = strchr(p, SPECIAL_VAR_SYMBOL);
 				*p = '\0';
-				repl = encode_then_expand_string(exp_word, /*process_bkslash:*/ arg0 & 0x80, /*unbackslash:*/ 1);
+				repl = encode_then_expand_string(exp_word, /*process_bkslash:*/ 0, /*unbackslash:*/ 1);
 				debug_printf_varexp("repl:'%s'->'%s'\n", exp_word, repl);
 				/* HACK ALERT. We depend here on the fact that
 				 * G.global_argv and results of utoa and get_local_var_value
@@ -5813,6 +6043,13 @@ static NOINLINE const char *expand_one_v
 					val = to_be_freed;
 				free(pattern);
 				free(repl);
+			} else {
+				/* Empty variable always gives nothing */
+				// "v=''; echo ${v/*/w}" prints "", not "w"
+				/* Just skip "replace" part */
+				*p++ = SPECIAL_VAR_SYMBOL;
+				p = strchr(p, SPECIAL_VAR_SYMBOL);
+				*p = '\0';
 			}
 		}
 #endif /* BASH_PATTERN_SUBST */
@@ -6044,6 +6281,11 @@ static NOINLINE int expand_vars_to_list(
 			arg++;
 			cant_be_null = 0x80;
 			break;
+		case SPECIAL_VAR_QUOTED_SVS:
+			/* <SPECIAL_VAR_SYMBOL><SPECIAL_VAR_QUOTED_SVS><SPECIAL_VAR_SYMBOL> */
+			arg++;
+			val = SPECIAL_VAR_SYMBOL_STR;
+			break;
 #if ENABLE_HUSH_TICK
 		case '`': /* <SPECIAL_VAR_SYMBOL>`cmd<SPECIAL_VAR_SYMBOL> */
 			*p = '\0'; /* replace trailing <SPECIAL_VAR_SYMBOL> */
@@ -6053,6 +6295,7 @@ static NOINLINE int expand_vars_to_list(
 			 * and $IFS-split */
 			debug_printf_subst("SUBST '%s' first_ch %x\n", arg, first_ch);
 			G.last_exitcode = process_command_subs(&subst_result, arg);
+			G.expand_exitcode = G.last_exitcode;
 			debug_printf_subst("SUBST RES:%d '%s'\n", G.last_exitcode, subst_result.data);
 			val = subst_result.data;
 			goto store_val;
@@ -6154,7 +6397,7 @@ static char **expand_strvec_to_strvec(ch
 	return expand_variables(argv, EXP_FLAG_GLOB | EXP_FLAG_ESC_GLOB_CHARS);
 }
 
-#if BASH_TEST2
+#if defined(CMD_SINGLEWORD_NOGLOB)
 static char **expand_strvec_to_strvec_singleword_noglob(char **argv)
 {
 	return expand_variables(argv, EXP_FLAG_SINGLEWORD);
@@ -6162,15 +6405,16 @@ static char **expand_strvec_to_strvec_si
 #endif
 
 /* Used for expansion of right hand of assignments,
- * $((...)), heredocs, variable espansion parts.
+ * $((...)), heredocs, variable expansion parts.
  *
  * NB: should NOT do globbing!
  * "export v=/bin/c*; env | grep ^v=" outputs "v=/bin/c*"
  */
-static char *expand_string_to_string(const char *str, int do_unbackslash)
+static char *expand_string_to_string(const char *str, int EXP_flags, int do_unbackslash)
 {
 #if !BASH_PATTERN_SUBST && !ENABLE_HUSH_CASE
 	const int do_unbackslash = 1;
+	const int EXP_flags = EXP_FLAG_ESC_GLOB_CHARS;
 #endif
 	char *argv[2], **list;
 
@@ -6187,10 +6431,7 @@ static char *expand_string_to_string(con
 
 	argv[0] = (char*)str;
 	argv[1] = NULL;
-	list = expand_variables(argv, do_unbackslash
-			? EXP_FLAG_ESC_GLOB_CHARS | EXP_FLAG_SINGLEWORD
-			: EXP_FLAG_SINGLEWORD
-	);
+	list = expand_variables(argv, EXP_flags | EXP_FLAG_SINGLEWORD);
 	if (HUSH_DEBUG)
 		if (!list[0] || list[1])
 			bb_error_msg_and_die("BUG in varexp2");
@@ -6202,7 +6443,7 @@ static char *expand_string_to_string(con
 	return (char*)list;
 }
 
-/* Used for "eval" builtin and case string */
+#if 0
 static char* expand_strvec_to_string(char **argv)
 {
 	char **list;
@@ -6224,6 +6465,7 @@ static char* expand_strvec_to_string(cha
 	debug_printf_expand("strvec_to_string='%s'\n", (char*)list);
 	return (char*)list;
 }
+#endif
 
 static char **expand_assignments(char **argv, int count)
 {
@@ -6233,7 +6475,13 @@ static char **expand_assignments(char **
 	G.expanded_assignments = p = NULL;
 	/* Expand assignments into one string each */
 	for (i = 0; i < count; i++) {
-		G.expanded_assignments = p = add_string_to_strings(p, expand_string_to_string(argv[i], /*unbackslash:*/ 1));
+		p = add_string_to_strings(p,
+			expand_string_to_string(argv[i],
+				EXP_FLAG_ESC_GLOB_CHARS,
+				/*unbackslash:*/ 1
+			)
+		);
+		G.expanded_assignments = p;
 	}
 	G.expanded_assignments = NULL;
 	return p;
@@ -6472,8 +6720,10 @@ static void parse_and_run_stream(struct
 		struct pipe *pipe_list;
 
 #if ENABLE_HUSH_INTERACTIVE
-		if (end_trigger == ';')
-			inp->promptmode = 0; /* PS1 */
+		if (end_trigger == ';') {
+			G.promptmode = 0; /* PS1 */
+			debug_printf_prompt("%s promptmode=%d\n", __func__, G.promptmode);
+		}
 #endif
 		pipe_list = parse_stream(NULL, inp, end_trigger);
 		if (!pipe_list || pipe_list == ERR_PTR) { /* EOF/error */
@@ -6509,15 +6759,22 @@ static void parse_and_run_stream(struct
 static void parse_and_run_string(const char *s)
 {
 	struct in_str input;
+	//IF_HUSH_LINENO_VAR(unsigned sv = G.lineno;)
+
 	setup_string_in_str(&input, s);
 	parse_and_run_stream(&input, '\0');
+	//IF_HUSH_LINENO_VAR(G.lineno = sv;)
 }
 
 static void parse_and_run_file(FILE *f)
 {
 	struct in_str input;
+	IF_HUSH_LINENO_VAR(unsigned sv = G.lineno;)
+
+	IF_HUSH_LINENO_VAR(G.lineno = 1;)
 	setup_file_in_str(&input, f);
 	parse_and_run_stream(&input, ';');
+	IF_HUSH_LINENO_VAR(G.lineno = sv;)
 }
 
 #if ENABLE_HUSH_TICK
@@ -6630,16 +6887,16 @@ static FILE *generate_stream_from_string
 static int process_command_subs(o_string *dest, const char *s)
 {
 	FILE *fp;
-	struct in_str pipe_str;
 	pid_t pid;
 	int status, ch, eol_cnt;
 
 	fp = generate_stream_from_string(s, &pid);
 
 	/* Now send results of command back into original context */
-	setup_file_in_str(&pipe_str, fp);
 	eol_cnt = 0;
-	while ((ch = i_getch(&pipe_str)) != EOF) {
+	while ((ch = getc(fp)) != EOF) {
+		if (ch == '\0')
+			continue;
 		if (ch == '\n') {
 			eol_cnt++;
 			continue;
@@ -6936,7 +7193,8 @@ static int setup_redirects(struct comman
 				continue;
 			}
 			mode = redir_table[redir->rd_type].mode;
-			p = expand_string_to_string(redir->rd_filename, /*unbackslash:*/ 1);
+			p = expand_string_to_string(redir->rd_filename,
+				EXP_FLAG_ESC_GLOB_CHARS, /*unbackslash:*/ 1);
 			newfd = open_or_warn(p, mode);
 			free(p);
 			if (newfd < 0) {
@@ -7057,24 +7315,77 @@ static const struct built_in_command *fi
 	return find_builtin_helper(name, bltins2, &bltins2[ARRAY_SIZE(bltins2)]);
 }
 
+static void remove_nested_vars(void)
+{
+	struct variable *cur;
+	struct variable **cur_pp;
+
+	cur_pp = &G.top_var;
+	while ((cur = *cur_pp) != NULL) {
+		if (cur->var_nest_level <= G.var_nest_level) {
+			cur_pp = &cur->next;
+			continue;
+		}
+		/* Unexport */
+		if (cur->flg_export) {
+			debug_printf_env("unexporting nested '%s'/%u\n", cur->varstr, cur->var_nest_level);
+			bb_unsetenv(cur->varstr);
+		}
+		/* Remove from global list */
+		*cur_pp = cur->next;
+		/* Free */
+		if (!cur->max_len) {
+			debug_printf_env("freeing nested '%s'/%u\n", cur->varstr, cur->var_nest_level);
+			free(cur->varstr);
+		}
+		free(cur);
+	}
+}
+
+static void enter_var_nest_level(void)
+{
+	G.var_nest_level++;
+	debug_printf_env("var_nest_level++ %u\n", G.var_nest_level);
+
+	/* Try:	f() { echo -n .; f; }; f
+	 * struct variable::var_nest_level is uint16_t,
+	 * thus limiting recursion to < 2^16.
+	 * In any case, with 8 Mbyte stack SEGV happens
+	 * not too long after 2^16 recursions anyway.
+	 */
+	if (G.var_nest_level > 0xff00)
+		bb_error_msg_and_die("fatal recursion (depth %u)", G.var_nest_level);
+}
+
+static void leave_var_nest_level(void)
+{
+	G.var_nest_level--;
+	debug_printf_env("var_nest_level-- %u\n", G.var_nest_level);
+	if (HUSH_DEBUG && (int)G.var_nest_level < 0)
+		bb_error_msg_and_die("BUG: nesting underflow");
+
+	remove_nested_vars();
+}
+
 #if ENABLE_HUSH_FUNCTIONS
 static struct function **find_function_slot(const char *name)
 {
+	struct function *funcp;
 	struct function **funcpp = &G.top_func;
-	while (*funcpp) {
-		if (strcmp(name, (*funcpp)->name) == 0) {
+
+	while ((funcp = *funcpp) != NULL) {
+		if (strcmp(name, funcp->name) == 0) {
+			debug_printf_exec("found function '%s'\n", name);
 			break;
 		}
-		funcpp = &(*funcpp)->next;
+		funcpp = &funcp->next;
 	}
 	return funcpp;
 }
 
-static const struct function *find_function(const char *name)
+static ALWAYS_INLINE const struct function *find_function(const char *name)
 {
 	const struct function *funcp = *find_function_slot(name);
-	if (funcp)
-		debug_printf_exec("found function '%s'\n", name);
 	return funcp;
 }
 
@@ -7174,8 +7485,9 @@ static void exec_function(char ***to_fre
 // for "more correctness" we might want to close those extra fds here:
 //?	close_saved_fds_and_FILE_fds();
 
-	/* "we are in function, ok to use return" */
+	/* "we are in a function, ok to use return" */
 	G_flag_return_in_progress = -1;
+	enter_var_nest_level();
 	IF_HUSH_LOCAL(G.func_nest_level++;)
 
 	/* On MMU, funcp->body is always non-NULL */
@@ -7203,9 +7515,12 @@ static int run_function(const struct fun
 
 	save_and_replace_G_args(&sv, argv);
 
-	/* "we are in function, ok to use return" */
+	/* "We are in function, ok to use return" */
 	sv_flg = G_flag_return_in_progress;
 	G_flag_return_in_progress = -1;
+
+	/* Make "local" variables properly shadow previous ones */
+	IF_HUSH_LOCAL(enter_var_nest_level();)
 	IF_HUSH_LOCAL(G.func_nest_level++;)
 
 	/* On MMU, funcp->body is always non-NULL */
@@ -7220,30 +7535,9 @@ static int run_function(const struct fun
 		rc = run_list(funcp->body);
 	}
 
-# if ENABLE_HUSH_LOCAL
-	{
-		struct variable *var;
-		struct variable **var_pp;
+	IF_HUSH_LOCAL(G.func_nest_level--;)
+	IF_HUSH_LOCAL(leave_var_nest_level();)
 
-		var_pp = &G.top_var;
-		while ((var = *var_pp) != NULL) {
-			if (var->func_nest_level < G.func_nest_level) {
-				var_pp = &var->next;
-				continue;
-			}
-			/* Unexport */
-			if (var->flg_export)
-				bb_unsetenv(var->varstr);
-			/* Remove from global list */
-			*var_pp = var->next;
-			/* Free */
-			if (!var->max_len)
-				free(var->varstr);
-			free(var);
-		}
-		G.func_nest_level--;
-	}
-# endif
 	G_flag_return_in_progress = sv_flg;
 
 	restore_G_args(&sv, argv);
@@ -7333,6 +7627,32 @@ static void dump_cmd_in_x_mode(char **ar
 # define dump_cmd_in_x_mode(argv) ((void)0)
 #endif
 
+#if ENABLE_HUSH_COMMAND
+static void if_command_vV_print_and_exit(char opt_vV, char *cmd, const char *explanation)
+{
+	char *to_free;
+
+	if (!opt_vV)
+		return;
+
+	to_free = NULL;
+	if (!explanation) {
+		char *path = getenv("PATH");
+		explanation = to_free = find_executable(cmd, &path); /* path == NULL is ok */
+		if (!explanation)
+			_exit(1); /* PROG was not found */
+		if (opt_vV != 'V')
+			cmd = to_free; /* -v PROG prints "/path/to/PROG" */
+	}
+	printf((opt_vV == 'V') ? "%s is %s\n" : "%s\n", cmd, explanation);
+	free(to_free);
+	fflush_all();
+	_exit(0);
+}
+#else
+# define if_command_vV_print_and_exit(a,b,c) ((void)0)
+#endif
+
 #if BB_MMU
 #define pseudo_exec_argv(nommu_save, argv, assignment_cnt, argv_expanded) \
 	pseudo_exec_argv(argv, assignment_cnt, argv_expanded)
@@ -7353,7 +7673,11 @@ static NOINLINE void pseudo_exec_argv(no
 		char **argv, int assignment_cnt,
 		char **argv_expanded)
 {
+	const struct built_in_command *x;
+	struct variable **sv_shadowed;
 	char **new_env;
+	IF_HUSH_COMMAND(char opt_vV = 0;)
+	IF_HUSH_FUNCTIONS(const struct function *funcp;)
 
 	new_env = expand_assignments(argv, assignment_cnt);
 	dump_cmd_in_x_mode(new_env);
@@ -7367,15 +7691,15 @@ static NOINLINE void pseudo_exec_argv(no
 		_exit(EXIT_SUCCESS);
 	}
 
+	sv_shadowed = G.shadowed_vars_pp;
 #if BB_MMU
-	set_vars_and_save_old(new_env);
-	free(new_env); /* optional */
-	/* we can also destroy set_vars_and_save_old's return value,
-	 * to save memory */
+	G.shadowed_vars_pp = NULL; /* "don't save, free them instead" */
 #else
-	nommu_save->new_env = new_env;
-	nommu_save->old_vars = set_vars_and_save_old(new_env);
+	G.shadowed_vars_pp = &nommu_save->old_vars;
+	G.var_nest_level++;
 #endif
+	set_vars_and_save_old(new_env);
+	G.shadowed_vars_pp = sv_shadowed;
 
 	if (argv_expanded) {
 		argv = argv_expanded;
@@ -7394,12 +7718,47 @@ static NOINLINE void pseudo_exec_argv(no
 
 #if ENABLE_HUSH_FUNCTIONS
 	/* Check if the command matches any functions (this goes before bltins) */
-	{
-		const struct function *funcp = find_function(argv[0]);
-		if (funcp) {
-			exec_function(&nommu_save->argv_from_re_execing, funcp, argv);
+	funcp = find_function(argv[0]);
+	if (funcp)
+		exec_function(&nommu_save->argv_from_re_execing, funcp, argv);
+#endif
+
+#if ENABLE_HUSH_COMMAND
+	/* "command BAR": run BAR without looking it up among functions
+	 * "command -v BAR": print "BAR" or "/path/to/BAR"; or exit 1
+	 * "command -V BAR": print "BAR is {a function,a shell builtin,/path/to/BAR}"
+	 */
+	while (strcmp(argv[0], "command") == 0 && argv[1]) {
+		char *p;
+
+		argv++;
+		p = *argv;
+		if (p[0] != '-' || !p[1])
+			continue; /* bash allows "command command command [-OPT] BAR" */
+
+		for (;;) {
+			p++;
+			switch (*p) {
+			case '\0':
+				argv++;
+				p = *argv;
+				if (p[0] != '-' || !p[1])
+					goto after_opts;
+				continue; /* next arg is also -opts, process it too */
+			case 'v':
+			case 'V':
+				opt_vV = *p;
+				continue;
+			default:
+				bb_error_msg_and_die("%s: %s: invalid option", "command", argv[0]);
+			}
 		}
 	}
+ after_opts:
+# if ENABLE_HUSH_FUNCTIONS
+	if (opt_vV && find_function(argv[0]))
+		if_command_vV_print_and_exit(opt_vV, argv[0], "a function");
+# endif
 #endif
 
 	/* Check if the command matches any of the builtins.
@@ -7407,16 +7766,15 @@ static NOINLINE void pseudo_exec_argv(no
 	 * easier to waste a few CPU cycles than it is to figure out
 	 * if this is one of those cases.
 	 */
-	{
-		/* On NOMMU, it is more expensive to re-execute shell
-		 * just in order to run echo or test builtin.
-		 * It's better to skip it here and run corresponding
-		 * non-builtin later. */
-		const struct built_in_command *x;
-		x = BB_MMU ? find_builtin(argv[0]) : find_builtin1(argv[0]);
-		if (x) {
-			exec_builtin(&nommu_save->argv_from_re_execing, x, argv);
-		}
+	/* Why "BB_MMU ? :" difference in logic? -
+	 * On NOMMU, it is more expensive to re-execute shell
+	 * just in order to run echo or test builtin.
+	 * It's better to skip it here and run corresponding
+	 * non-builtin later. */
+	x = BB_MMU ? find_builtin(argv[0]) : find_builtin1(argv[0]);
+	if (x) {
+		if_command_vV_print_and_exit(opt_vV, argv[0], "a shell builtin");
+		exec_builtin(&nommu_save->argv_from_re_execing, x, argv);
 	}
 
 #if ENABLE_FEATURE_SH_STANDALONE
@@ -7424,6 +7782,7 @@ static NOINLINE void pseudo_exec_argv(no
 	{
 		int a = find_applet_by_name(argv[0]);
 		if (a >= 0) {
+			if_command_vV_print_and_exit(opt_vV, argv[0], "an applet");
 # if BB_MMU /* see above why on NOMMU it is not allowed */
 			if (APPLET_IS_NOEXEC(a)) {
 				/* Do not leak open fds from opened script files etc.
@@ -7457,6 +7816,7 @@ static NOINLINE void pseudo_exec_argv(no
 #if ENABLE_FEATURE_SH_STANDALONE || BB_MMU
  skip:
 #endif
+	if_command_vV_print_and_exit(opt_vV, argv[0], NULL);
 	execvp_or_die(argv);
 }
 
@@ -7469,6 +7829,15 @@ static void pseudo_exec(nommu_save_t *no
 		struct command *command,
 		char **argv_expanded)
 {
+#if ENABLE_HUSH_FUNCTIONS
+	if (command->cmd_type == CMD_FUNCDEF) {
+		/* Ignore funcdefs in pipes:
+		 * true | f() { cmd }
+		 */
+		_exit(0);
+	}
+#endif
+
 	if (command->argv) {
 		pseudo_exec_argv(nommu_save, command->argv,
 				command->assignment_cnt, argv_expanded);
@@ -7887,29 +8256,29 @@ static int checkjobs_and_fg_shell(struct
  * subshell:     ( list ) [&]
  */
 #if !ENABLE_HUSH_MODE_X
-#define redirect_and_varexp_helper(new_env_p, old_vars_p, command, squirrel, argv_expanded) \
-	redirect_and_varexp_helper(new_env_p, old_vars_p, command, squirrel)
+#define redirect_and_varexp_helper(command, squirrel, argv_expanded) \
+	redirect_and_varexp_helper(command, squirrel)
 #endif
-static int redirect_and_varexp_helper(char ***new_env_p,
-		struct variable **old_vars_p,
+static int redirect_and_varexp_helper(
 		struct command *command,
 		struct squirrel **sqp,
 		char **argv_expanded)
 {
+	/* Assignments occur before redirects. Try:
+	 * a=`sleep 1` sleep 2 3>/qwe/rty
+	 */
+
+	char **new_env = expand_assignments(command->argv, command->assignment_cnt);
+	dump_cmd_in_x_mode(new_env);
+	dump_cmd_in_x_mode(argv_expanded);
+	/* this takes ownership of new_env[i] elements, and frees new_env: */
+	set_vars_and_save_old(new_env);
+
 	/* setup_redirects acts on file descriptors, not FILEs.
 	 * This is perfect for work that comes after exec().
 	 * Is it really safe for inline use?  Experimentally,
 	 * things seem to work. */
-	int rcode = setup_redirects(command, sqp);
-	if (rcode == 0) {
-		char **new_env = expand_assignments(command->argv, command->assignment_cnt);
-		*new_env_p = new_env;
-		dump_cmd_in_x_mode(new_env);
-		dump_cmd_in_x_mode(argv_expanded);
-		if (old_vars_p)
-			*old_vars_p = set_vars_and_save_old(new_env);
-	}
-	return rcode;
+	return setup_redirects(command, sqp);
 }
 static NOINLINE int run_pipe(struct pipe *pi)
 {
@@ -7929,9 +8298,31 @@ static NOINLINE int run_pipe(struct pipe
 	/* Testcase: set -- q w e; (IFS='' echo "$*"; IFS=''; echo "$*"); echo "$*"
 	 * Result should be 3 lines: q w e, qwe, q w e
 	 */
+	if (G.ifs_whitespace != G.ifs)
+		free(G.ifs_whitespace);
 	G.ifs = get_local_var_value("IFS");
-	if (!G.ifs)
+	if (G.ifs) {
+		char *p;
+		G.ifs_whitespace = (char*)G.ifs;
+		p = skip_whitespace(G.ifs);
+		if (*p) {
+			/* Not all $IFS is whitespace */
+			char *d;
+			int len = p - G.ifs;
+			p = skip_non_whitespace(p);
+			G.ifs_whitespace = xmalloc(len + strlen(p) + 1); /* can overestimate */
+			d = mempcpy(G.ifs_whitespace, G.ifs, len);
+			while (*p) {
+				if (isspace(*p))
+					*d++ = *p;
+				p++;
+			}
+			*d = '\0';
+		}
+	} else {
 		G.ifs = defifs;
+		G.ifs_whitespace = (char*)G.ifs;
+	}
 
 	IF_HUSH_JOB(pi->pgrp = -1;)
 	pi->stopped_cmds = 0;
@@ -7979,6 +8370,12 @@ static NOINLINE int run_pipe(struct pipe
 		rcode = 1; /* exitcode if redir failed */
 		if (setup_redirects(command, &squirrel) == 0) {
 			debug_printf_exec(": run_list\n");
+//FIXME: we need to pass squirrel down into run_list()
+//for SH_STANDALONE case, or else this construct:
+// { find /proc/self/fd; true; } >FILE; cmd2
+//has no way of closing saved fd#1 for "find",
+//and in SH_STANDALONE mode, "find" is not execed,
+//therefore CLOEXEC on saved fd does not help.
 			rcode = run_list(command->group) & 0xff;
 		}
 		restore_redirects(squirrel);
@@ -7991,108 +8388,123 @@ static NOINLINE int run_pipe(struct pipe
 	argv = command->argv ? command->argv : (char **) &null_ptr;
 	{
 		const struct built_in_command *x;
-#if ENABLE_HUSH_FUNCTIONS
-		const struct function *funcp;
-#else
-		enum { funcp = 0 };
+		IF_HUSH_FUNCTIONS(const struct function *funcp;)
+		IF_NOT_HUSH_FUNCTIONS(enum { funcp = 0 };)
+		struct variable **sv_shadowed;
+		struct variable *old_vars;
+
+#if ENABLE_HUSH_LINENO_VAR
+		if (G.lineno_var)
+			strcpy(G.lineno_var + sizeof("LINENO=")-1, utoa(command->lineno));
 #endif
-		char **new_env = NULL;
-		struct variable *old_vars = NULL;
 
 		if (argv[command->assignment_cnt] == NULL) {
-			/* Assignments, but no command */
-			/* Ensure redirects take effect (that is, create files).
-			 * Try "a=t >file" */
-#if 0 /* A few cases in testsuite fail with this code. FIXME */
-			rcode = redirect_and_varexp_helper(&new_env, /*old_vars:*/ NULL, command, &squirrel, /*argv_expanded:*/ NULL);
-			/* Set shell variables */
-			if (new_env) {
-				argv = new_env;
-				while (*argv) {
-					if (set_local_var(*argv, /*flag:*/ 0)) {
-						/* assignment to readonly var / putenv error? */
-						rcode = 1;
-					}
-					argv++;
-				}
-			}
-			/* Redirect error sets $? to 1. Otherwise,
-			 * if evaluating assignment value set $?, retain it.
-			 * Try "false; q=`exit 2`; echo $?" - should print 2: */
-			if (rcode == 0)
-				rcode = G.last_exitcode;
-			/* Exit, _skipping_ variable restoring code: */
-			goto clean_up_and_ret0;
-
-#else /* Older, bigger, but more correct code */
-
+			/* Assignments, but no command.
+			 * Ensure redirects take effect (that is, create files).
+			 * Try "a=t >file"
+			 */
+			unsigned i;
+			G.expand_exitcode = 0;
+ only_assignments:
 			rcode = setup_redirects(command, &squirrel);
 			restore_redirects(squirrel);
+
 			/* Set shell variables */
 			if (G_x_mode)
 				bb_putchar_stderr('+');
-			while (*argv) {
-				char *p = expand_string_to_string(*argv, /*unbackslash:*/ 1);
+			i = 0;
+			while (i < command->assignment_cnt) {
+				char *p = expand_string_to_string(argv[i],
+						EXP_FLAG_ESC_GLOB_CHARS,
+						/*unbackslash:*/ 1
+				);
 				if (G_x_mode)
 					fprintf(stderr, " %s", p);
-				debug_printf_exec("set shell var:'%s'->'%s'\n",
-						*argv, p);
+				debug_printf_env("set shell var:'%s'->'%s'\n", *argv, p);
 				if (set_local_var(p, /*flag:*/ 0)) {
 					/* assignment to readonly var / putenv error? */
 					rcode = 1;
 				}
-				argv++;
+				i++;
 			}
 			if (G_x_mode)
 				bb_putchar_stderr('\n');
 			/* Redirect error sets $? to 1. Otherwise,
 			 * if evaluating assignment value set $?, retain it.
-			 * Try "false; q=`exit 2`; echo $?" - should print 2: */
+			 * Else, clear $?:
+			 *  false; q=`exit 2`; echo $? - should print 2
+			 *  false; x=1; echo $? - should print 0
+			 * Because of the 2nd case, we can't just use G.last_exitcode.
+			 */
 			if (rcode == 0)
-				rcode = G.last_exitcode;
+				rcode = G.expand_exitcode;
 			IF_HAS_KEYWORDS(if (pi->pi_inverted) rcode = !rcode;)
 			debug_leave();
 			debug_printf_exec("run_pipe: return %d\n", rcode);
 			return rcode;
-#endif
 		}
 
 		/* Expand the rest into (possibly) many strings each */
-#if BASH_TEST2
-		if (command->cmd_type == CMD_SINGLEWORD_NOGLOB) {
+#if defined(CMD_SINGLEWORD_NOGLOB)
+		if (command->cmd_type == CMD_SINGLEWORD_NOGLOB)
 			argv_expanded = expand_strvec_to_strvec_singleword_noglob(argv + command->assignment_cnt);
-		} else
+		else
 #endif
-		{
 			argv_expanded = expand_strvec_to_strvec(argv + command->assignment_cnt);
-		}
 
-		/* if someone gives us an empty string: `cmd with empty output` */
+		/* If someone gives us an empty string: `cmd with empty output` */
 		if (!argv_expanded[0]) {
 			free(argv_expanded);
-			debug_leave();
-			return G.last_exitcode;
+			/* `false` still has to set exitcode 1 */
+			G.expand_exitcode = G.last_exitcode;
+			goto only_assignments;
 		}
 
-#if ENABLE_HUSH_FUNCTIONS
+		old_vars = NULL;
+		sv_shadowed = G.shadowed_vars_pp;
+
 		/* Check if argv[0] matches any functions (this goes before bltins) */
-		funcp = find_function(argv_expanded[0]);
-#endif
-		x = NULL;
-		if (!funcp)
+		IF_HUSH_FUNCTIONS(funcp = find_function(argv_expanded[0]);)
+		IF_HUSH_FUNCTIONS(x = NULL;)
+		IF_HUSH_FUNCTIONS(if (!funcp))
 			x = find_builtin(argv_expanded[0]);
 		if (x || funcp) {
-			if (!funcp) {
-				if (x->b_function == builtin_exec && argv_expanded[1] == NULL) {
-					debug_printf("exec with redirects only\n");
-					rcode = setup_redirects(command, NULL);
-					/* rcode=1 can be if redir file can't be opened */
-					goto clean_up_and_ret1;
-				}
+			if (x && x->b_function == builtin_exec && argv_expanded[1] == NULL) {
+				debug_printf("exec with redirects only\n");
+				/*
+				 * Variable assignments are executed, but then "forgotten":
+				 *  a=`sleep 1;echo A` exec 3>&-; echo $a
+				 * sleeps, but prints nothing.
+				 */
+				enter_var_nest_level();
+				G.shadowed_vars_pp = &old_vars;
+				rcode = redirect_and_varexp_helper(command, /*squirrel:*/ NULL, argv_expanded);
+				G.shadowed_vars_pp = sv_shadowed;
+				/* rcode=1 can be if redir file can't be opened */
+
+				goto clean_up_and_ret1;
 			}
-			rcode = redirect_and_varexp_helper(&new_env, &old_vars, command, &squirrel, argv_expanded);
+
+			/* Bump var nesting, or this will leak exported $a:
+			 * a=b true; env | grep ^a=
+			 */
+			enter_var_nest_level();
+			/* Collect all variables "shadowed" by helper
+			 * (IOW: old vars overridden by "var1=val1 var2=val2 cmd..." syntax)
+			 * into old_vars list:
+			 */
+			G.shadowed_vars_pp = &old_vars;
+			rcode = redirect_and_varexp_helper(command, &squirrel, argv_expanded);
 			if (rcode == 0) {
 				if (!funcp) {
+					/* Do not collect *to old_vars list* vars shadowed
+					 * by e.g. "local VAR" builtin (collect them
+					 * in the previously nested list instead):
+					 * don't want them to be restored immediately
+					 * after "local" completes.
+					 */
+					G.shadowed_vars_pp = sv_shadowed;
+
 					debug_printf_exec(": builtin '%s' '%s'...\n",
 						x->b_cmd, argv_expanded[1]);
 					fflush_all();
@@ -8101,72 +8513,74 @@ static NOINLINE int run_pipe(struct pipe
 				}
 #if ENABLE_HUSH_FUNCTIONS
 				else {
-# if ENABLE_HUSH_LOCAL
-					struct variable **sv;
-					sv = G.shadowed_vars_pp;
-					G.shadowed_vars_pp = &old_vars;
-# endif
 					debug_printf_exec(": function '%s' '%s'...\n",
 						funcp->name, argv_expanded[1]);
 					rcode = run_function(funcp, argv_expanded) & 0xff;
-# if ENABLE_HUSH_LOCAL
-					G.shadowed_vars_pp = sv;
-# endif
+					/*
+					 * But do collect *to old_vars list* vars shadowed
+					 * within function execution. To that end, restore
+					 * this pointer _after_ function run:
+					 */
+					G.shadowed_vars_pp = sv_shadowed;
 				}
 #endif
 			}
- clean_up_and_ret:
-			unset_vars(new_env);
-			add_vars(old_vars);
-/* clean_up_and_ret0: */
-			restore_redirects(squirrel);
-			/*
-			 * Try "usleep 99999999" + ^C + "echo $?"
-			 * with FEATURE_SH_NOFORK=y.
-			 */
-			if (!funcp) {
-				/* It was builtin or nofork.
-				 * if this would be a real fork/execed program,
-				 * it should have died if a fatal sig was received.
-				 * But OTOH, there was no separate process,
-				 * the sig was sent to _shell_, not to non-existing
-				 * child.
-				 * Let's just handle ^C only, this one is obvious:
-				 * we aren't ok with exitcode 0 when ^C was pressed
-				 * during builtin/nofork.
+		} else
+		if (ENABLE_FEATURE_SH_NOFORK && NUM_APPLETS > 1) {
+			int n = find_applet_by_name(argv_expanded[0]);
+			if (n < 0 || !APPLET_IS_NOFORK(n))
+				goto must_fork;
+
+			enter_var_nest_level();
+			/* Collect all variables "shadowed" by helper into old_vars list */
+			G.shadowed_vars_pp = &old_vars;
+			rcode = redirect_and_varexp_helper(command, &squirrel, argv_expanded);
+			G.shadowed_vars_pp = sv_shadowed;
+
+			if (rcode == 0) {
+				debug_printf_exec(": run_nofork_applet '%s' '%s'...\n",
+					argv_expanded[0], argv_expanded[1]);
+				/*
+				 * Note: signals (^C) can't interrupt here.
+				 * We remember them and they will be acted upon
+				 * after applet returns.
+				 * This makes applets which can run for a long time
+				 * and/or wait for user input ineligible for NOFORK:
+				 * for example, "yes" or "rm" (rm -i waits for input).
 				 */
-				if (sigismember(&G.pending_set, SIGINT))
-					rcode = 128 + SIGINT;
+				rcode = run_nofork_applet(n, argv_expanded);
 			}
+		} else
+			goto must_fork;
+
+		restore_redirects(squirrel);
  clean_up_and_ret1:
-			free(argv_expanded);
-			IF_HAS_KEYWORDS(if (pi->pi_inverted) rcode = !rcode;)
-			debug_leave();
-			debug_printf_exec("run_pipe return %d\n", rcode);
-			return rcode;
-		}
+		leave_var_nest_level();
+		add_vars(old_vars);
 
-		if (ENABLE_FEATURE_SH_NOFORK && NUM_APPLETS > 1) {
-			int n = find_applet_by_name(argv_expanded[0]);
-			if (n >= 0 && APPLET_IS_NOFORK(n)) {
-				rcode = redirect_and_varexp_helper(&new_env, &old_vars, command, &squirrel, argv_expanded);
-				if (rcode == 0) {
-					debug_printf_exec(": run_nofork_applet '%s' '%s'...\n",
-						argv_expanded[0], argv_expanded[1]);
-					/*
-					 * Note: signals (^C) can't interrupt here.
-					 * We remember them and they will be acted upon
-					 * after applet returns.
-					 * This makes applets which can run for a long time
-					 * and/or wait for user input ineligible for NOFORK:
-					 * for example, "yes" or "rm" (rm -i waits for input).
-					 */
-					rcode = run_nofork_applet(n, argv_expanded);
-				}
-				goto clean_up_and_ret;
-			}
+		/*
+		 * Try "usleep 99999999" + ^C + "echo $?"
+		 * with FEATURE_SH_NOFORK=y.
+		 */
+		if (!funcp) {
+			/* It was builtin or nofork.
+			 * if this would be a real fork/execed program,
+			 * it should have died if a fatal sig was received.
+			 * But OTOH, there was no separate process,
+			 * the sig was sent to _shell_, not to non-existing
+			 * child.
+			 * Let's just handle ^C only, this one is obvious:
+			 * we aren't ok with exitcode 0 when ^C was pressed
+			 * during builtin/nofork.
+			 */
+			if (sigismember(&G.pending_set, SIGINT))
+				rcode = 128 + SIGINT;
 		}
-		/* It is neither builtin nor applet. We must fork. */
+		free(argv_expanded);
+		IF_HAS_KEYWORDS(if (pi->pi_inverted) rcode = !rcode;)
+		debug_leave();
+		debug_printf_exec("run_pipe return %d\n", rcode);
+		return rcode;
 	}
 
  must_fork:
@@ -8182,8 +8596,8 @@ static NOINLINE int run_pipe(struct pipe
 	while (cmd_no < pi->num_cmds) {
 		struct fd_pair pipefds;
 #if !BB_MMU
+		int sv_var_nest_level = G.var_nest_level;
 		volatile nommu_save_t nommu_save;
-		nommu_save.new_env = NULL;
 		nommu_save.old_vars = NULL;
 		nommu_save.argv = NULL;
 		nommu_save.argv_from_re_execing = NULL;
@@ -8203,6 +8617,11 @@ static NOINLINE int run_pipe(struct pipe
 		if (cmd_no < pi->num_cmds)
 			xpiped_pair(pipefds);
 
+#if ENABLE_HUSH_LINENO_VAR
+		if (G.lineno_var)
+			strcpy(G.lineno_var + sizeof("LINENO=")-1, utoa(command->lineno));
+#endif
+
 		command->pid = BB_MMU ? fork() : vfork();
 		if (!command->pid) { /* child */
 #if ENABLE_HUSH_JOB
@@ -8271,7 +8690,8 @@ static NOINLINE int run_pipe(struct pipe
 		/* Clean up after vforked child */
 		free(nommu_save.argv);
 		free(nommu_save.argv_from_re_execing);
-		unset_vars(nommu_save.new_env);
+		G.var_nest_level = sv_var_nest_level;
+		remove_nested_vars();
 		add_vars(nommu_save.old_vars);
 #endif
 		free(argv_expanded);
@@ -8492,8 +8912,11 @@ static int run_list(struct pipe *pi)
 #if ENABLE_HUSH_CASE
 		if (rword == RES_CASE) {
 			debug_printf_exec("CASE cond_code:%d\n", cond_code);
-			case_word = expand_strvec_to_string(pi->cmds->argv);
-			unbackslash(case_word);
+			case_word = expand_string_to_string(pi->cmds->argv[0],
+				EXP_FLAG_ESC_GLOB_CHARS, /*unbackslash:*/ 1);
+			debug_printf_exec("CASE word1:'%s'\n", case_word);
+			//unbackslash(case_word);
+			//debug_printf_exec("CASE word2:'%s'\n", case_word);
 			continue;
 		}
 		if (rword == RES_MATCH) {
@@ -8505,12 +8928,19 @@ static int run_list(struct pipe *pi)
 			/* all prev words didn't match, does this one match? */
 			argv = pi->cmds->argv;
 			while (*argv) {
-				char *pattern = expand_string_to_string(*argv, /*unbackslash:*/ 0);
+				char *pattern;
+				debug_printf_exec("expand_string_to_string('%s')\n", *argv);
+				pattern = expand_string_to_string(*argv,
+						EXP_FLAG_ESC_GLOB_CHARS,
+						/*unbackslash:*/ 0
+				);
 				/* TODO: which FNM_xxx flags to use? */
 				cond_code = (fnmatch(pattern, case_word, /*flags:*/ 0) != 0);
-				debug_printf_exec("fnmatch(pattern:'%s',str:'%s'):%d\n", pattern, case_word, cond_code);
+				debug_printf_exec("fnmatch(pattern:'%s',str:'%s'):%d\n",
+						pattern, case_word, cond_code);
 				free(pattern);
-				if (cond_code == 0) { /* match! we will execute this branch */
+				if (cond_code == 0) {
+					/* match! we will execute this branch */
 					free(case_word);
 					case_word = NULL; /* make future "word)" stop */
 					break;
@@ -8820,9 +9250,9 @@ int hush_main(int argc, char **argv)
 {
 	enum {
 		OPT_login = (1 << 0),
+		OPT_s     = (1 << 1),
 	};
 	unsigned flags;
-	int opt;
 	unsigned builtin_argc;
 	char **e;
 	struct variable *cur_var;
@@ -8838,17 +9268,19 @@ int hush_main(int argc, char **argv)
 #if !BB_MMU
 	G.argv0_for_re_execing = argv[0];
 #endif
+
 	/* Deal with HUSH_VERSION */
+	debug_printf_env("unsetenv '%s'\n", "HUSH_VERSION");
+	unsetenv("HUSH_VERSION"); /* in case it exists in initial env */
 	shell_ver = xzalloc(sizeof(*shell_ver));
 	shell_ver->flg_export = 1;
 	shell_ver->flg_read_only = 1;
 	/* Code which handles ${var<op>...} needs writable values for all variables,
 	 * therefore we xstrdup: */
 	shell_ver->varstr = xstrdup(hush_version_str);
+
 	/* Create shell local variables from the values
 	 * currently living in the environment */
-	debug_printf_env("unsetenv '%s'\n", "HUSH_VERSION");
-	unsetenv("HUSH_VERSION"); /* in case it exists in initial env */
 	G.top_var = shell_ver;
 	cur_var = G.top_var;
 	e = environ;
@@ -8870,6 +9302,14 @@ int hush_main(int argc, char **argv)
 	/* Export PWD */
 	set_pwd_var(SETFLAG_EXPORT);
 
+#if ENABLE_HUSH_INTERACTIVE && ENABLE_FEATURE_EDITING_FANCY_PROMPT
+	/* Set (but not export) PS1/2 unless already set */
+	if (!get_local_var_value("PS1"))
+		set_local_var_from_halves("PS1", "\\w \\$ ");
+	if (!get_local_var_value("PS2"))
+		set_local_var_from_halves("PS2", "> ");
+#endif
+
 #if BASH_HOSTNAME_VAR
 	/* Set (but not export) HOSTNAME unless already set */
 	if (!get_local_var_value("HOSTNAME")) {
@@ -8908,12 +9348,18 @@ int hush_main(int argc, char **argv)
 	 * OPTERR=1
 	 * OPTIND=1
 	 * IFS=$' \t\n'
-	 * PS1='\s-\v\$ '
-	 * PS2='> '
 	 * PS4='+ '
 	 */
 #endif
 
+#if ENABLE_HUSH_LINENO_VAR
+	if (ENABLE_HUSH_LINENO_VAR) {
+		char *p = xasprintf("LINENO=%*s", (int)(sizeof(int)*3), "");
+		set_local_var(p, /*flags*/ 0);
+		G.lineno_var = p; /* can't assign before set_local_var("LINENO=...") */
+	}
+#endif
+
 #if ENABLE_FEATURE_EDITING
 	G.line_input_state = new_line_input_t(FOR_SHELL);
 #endif
@@ -8935,7 +9381,7 @@ int hush_main(int argc, char **argv)
 	flags = (argv[0] && argv[0][0] == '-') ? OPT_login : 0;
 	builtin_argc = 0;
 	while (1) {
-		opt = getopt(argc, argv, "+c:exinsl"
+		int opt = getopt(argc, argv, "+c:exinsl"
 #if !BB_MMU
 				"<:$:R:V:"
 # if ENABLE_HUSH_FUNCTIONS
@@ -8993,8 +9439,7 @@ int hush_main(int argc, char **argv)
 			/* G_interactive_fd++; */
 			break;
 		case 's':
-			/* "-s" means "read from stdin", but this is how we always
-			 * operate, so simply do nothing here. */
+			flags |= OPT_s;
 			break;
 		case 'l':
 			flags |= OPT_login;
@@ -9034,6 +9479,13 @@ int hush_main(int argc, char **argv)
 			optarg++;
 			G.depth_of_loop = bb_strtou(optarg, &optarg, 16);
 # endif
+# if ENABLE_HUSH_FUNCTIONS
+			/* nommu uses re-exec trick for "... | func | ...",
+			 * should allow "return".
+			 * This accidentally allows returns in subshells.
+			 */
+			G_flag_return_in_progress = -1;
+# endif
 			break;
 		}
 		case 'R':
@@ -9097,7 +9549,8 @@ int hush_main(int argc, char **argv)
 		 */
 	}
 
-	if (G.global_argv[1]) {
+	/* -s is: hush -s ARGV1 ARGV2 (no SCRIPT) */
+	if (!(flags & OPT_s) && G.global_argv[1]) {
 		FILE *input;
 		/*
 		 * "bash <script>" (which is never interactive (unless -i?))
@@ -9216,7 +9669,7 @@ int hush_main(int argc, char **argv)
 		G_interactive_fd = dup_CLOEXEC(STDIN_FILENO, 254);
 		if (G_interactive_fd < 0) {
 			/* try to dup to any fd */
-			G_interactive_fd = dup_CLOEXEC(STDIN_FILENO);
+			G_interactive_fd = dup_CLOEXEC(STDIN_FILENO, -1);
 			if (G_interactive_fd < 0)
 				/* give up */
 				G_interactive_fd = 0;
@@ -9356,13 +9809,34 @@ static int FAST_FUNC builtin_eval(char *
 	int rcode = EXIT_SUCCESS;
 
 	argv = skip_dash_dash(argv);
-	if (*argv) {
-		char *str = expand_strvec_to_string(argv);
+	if (argv[0]) {
+		char *str = NULL;
+
+		if (argv[1]) {
+			/* "The eval utility shall construct a command by
+			 * concatenating arguments together, separating
+			 * each with a <space> character."
+			 */
+			char *p;
+			unsigned len = 0;
+			char **pp = argv;
+			do
+				len += strlen(*pp) + 1;
+			while (*++pp);
+			str = p = xmalloc(len);
+			pp = argv;
+			do {
+				p = stpcpy(p, *pp);
+				*p++ = ' ';
+			} while (*++pp);
+			p[-1] = '\0';
+		}
+
 		/* bash:
 		 * eval "echo Hi; done" ("done" is syntax error):
 		 * "echo Hi" will not execute too.
 		 */
-		parse_and_run_string(str);
+		parse_and_run_string(str ? str : argv[0]);
 		free(str);
 		rcode = G.last_exitcode;
 	}
@@ -9638,8 +10112,8 @@ static int helper_export_local(char **ar
 # if ENABLE_HUSH_LOCAL
 			/* Is this "local" bltin? */
 			if (!(flags & (SETFLAG_EXPORT|SETFLAG_UNEXPORT|SETFLAG_MAKE_RO))) {
-				unsigned lvl = flags >> SETFLAG_LOCAL_SHIFT;
-				if (var && var->func_nest_level == lvl) {
+				unsigned lvl = flags >> SETFLAG_VARLVL_SHIFT;
+				if (var && var->var_nest_level == lvl) {
 					/* "local x=abc; ...; local x" - ignore second local decl */
 					continue;
 				}
@@ -9663,6 +10137,7 @@ static int helper_export_local(char **ar
 			/* (Un)exporting/making local NAME=VALUE */
 			name = xstrdup(name);
 		}
+		debug_printf_env("%s: set_local_var('%s')\n", __func__, name);
 		if (set_local_var(name, flags))
 			return EXIT_FAILURE;
 	} while (*++argv);
@@ -9724,7 +10199,11 @@ static int FAST_FUNC builtin_local(char
 		return EXIT_FAILURE; /* bash compat */
 	}
 	argv++;
-	return helper_export_local(argv, G.func_nest_level << SETFLAG_LOCAL_SHIFT);
+	/* Since all builtins run in a nested variable level,
+	 * need to use level - 1 here. Or else the variable will be removed at once
+	 * after builtin returns.
+	 */
+	return helper_export_local(argv, (G.var_nest_level - 1) << SETFLAG_VARLVL_SHIFT);
 }
 #endif
 
@@ -9865,7 +10344,7 @@ static int FAST_FUNC builtin_set(char **
 
 	/* Nothing known, so abort */
  error:
-	bb_error_msg("set: %s: invalid option", arg);
+	bb_error_msg("%s: %s: invalid option", "set", arg);
 	return EXIT_FAILURE;
 }
 #endif
@@ -10048,6 +10527,11 @@ static int FAST_FUNC builtin_source(char
 		arg_path = find_in_path(filename);
 		if (arg_path)
 			filename = arg_path;
+		else if (!ENABLE_HUSH_BASH_SOURCE_CURDIR) {
+			errno = ENOENT;
+			bb_simple_perror_msg(filename);
+			return EXIT_FAILURE;
+		}
 	}
 	input = remember_FILE(fopen_or_warn(filename, "r"));
 	free(arg_path);
diff -urpN busybox-1.28.4/shell/hush_test/hush-arith/arith-postinc.right busybox-1.29.0/shell/hush_test/hush-arith/arith-postinc.right
--- busybox-1.28.4/shell/hush_test/hush-arith/arith-postinc.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-arith/arith-postinc.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+1 1
+1 1
+1 1
+1 1
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-arith/arith-postinc.tests busybox-1.29.0/shell/hush_test/hush-arith/arith-postinc.tests
--- busybox-1.28.4/shell/hush_test/hush-arith/arith-postinc.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-arith/arith-postinc.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+echo 1 $((0++1))
+echo 1 $((0--1))
+x=-1; echo 1 $((0-$x))
+x=+1; echo 1 $((0+$x))
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-arith/arith.right busybox-1.29.0/shell/hush_test/hush-arith/arith.right
--- busybox-1.28.4/shell/hush_test/hush-arith/arith.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-arith/arith.right	2018-07-02 15:55:14.000000000 +0200
@@ -135,6 +135,10 @@ hush: arithmetic syntax error
 hush: arithmetic syntax error
 5 5
 1 1
+6 6
+2 2
+3 3
+1 1
 4 4
 0 0
 hush: arithmetic syntax error
diff -urpN busybox-1.28.4/shell/hush_test/hush-arith/arith2.sub busybox-1.29.0/shell/hush_test/hush-arith/arith2.sub
--- busybox-1.28.4/shell/hush_test/hush-arith/arith2.sub	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-arith/arith2.sub	2018-07-02 15:55:14.000000000 +0200
@@ -23,14 +23,14 @@
 echo 5 $(( 4 + ++a ))
 echo 1 $a
 
-# ash doesn't handle it right...
-#ash# echo 6 $(( 4+++a ))
-#ash# echo 2 $a
+# this is treated as 4 + ++a
+echo 6 $(( 4+++a ))
+echo 2 $a
       a=2
 
-# ash doesn't handle it right...
-#ash# echo 3 $(( 4---a ))
-#ash# echo 1 $a
+# this is treated as 4 - --a
+echo 3 $(( 4---a ))
+echo 1 $a
       a=1
 
 echo 4 $(( 4 - -- a ))
diff -urpN busybox-1.28.4/shell/hush_test/hush-arith/arith_nested1.right busybox-1.29.0/shell/hush_test/hush-arith/arith_nested1.right
--- busybox-1.28.4/shell/hush_test/hush-arith/arith_nested1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-arith/arith_nested1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+1
diff -urpN busybox-1.28.4/shell/hush_test/hush-arith/arith_nested1.tests busybox-1.29.0/shell/hush_test/hush-arith/arith_nested1.tests
--- busybox-1.28.4/shell/hush_test/hush-arith/arith_nested1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-arith/arith_nested1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+echo $(( ( $((1)) ) ))
diff -urpN busybox-1.28.4/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.right busybox-1.29.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.right
--- busybox-1.28.4/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+heredoc0
+Ok0:0
+heredoc1
+Ok1:0
+heredoc2
+Ok2:0
+heredoc3
+Ok4:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.tests busybox-1.29.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.tests
--- busybox-1.28.4/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,25 @@
+cat <\
+<\
+EOF
+heredoc0
+EOF
+echo Ok0:$?
+
+cat <<\
+ EOF
+heredoc1
+EOF
+echo Ok1:$?
+
+cat <<\
+- EOF
+heredoc2
+	EOF
+echo Ok2:$?
+
+cat <\
+<\
+- EOF
+heredoc3
+	EOF
+echo Ok4:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/assignment5.right busybox-1.29.0/shell/hush_test/hush-misc/assignment5.right
--- busybox-1.28.4/shell/hush_test/hush-misc/assignment5.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/assignment5.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+Zero1:0
+Zero2:0
+Zero3:0
+Zero4:0 x:1 y:1
+Three:3 x:1 y:1
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/assignment5.tests busybox-1.29.0/shell/hush_test/hush-misc/assignment5.tests
--- busybox-1.28.4/shell/hush_test/hush-misc/assignment5.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/assignment5.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,9 @@
+true;  a=1; echo Zero1:$?
+false; a=1; echo Zero2:$?
+false || a=1; echo Zero3:$?
+
+false || x=$? y=`echo $?`; echo Zero4:$? x:$x y:$y
+false || x=$? y=`echo $?; exit 3`; echo Three:$? x:$x y:$y
+
+#ash sets z=1 instead of z=3. disabled for now
+#false || x=$? y=`echo $?; exit 3` z=`echo $?`; echo x:$x y:$y z:$z
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/command2.right busybox-1.29.0/shell/hush_test/hush-misc/command2.right
--- busybox-1.28.4/shell/hush_test/hush-misc/command2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/command2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+test1
+hush: can't execute './test2.sh': Permission denied
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/command2.tests busybox-1.29.0/shell/hush_test/hush-misc/command2.tests
--- busybox-1.28.4/shell/hush_test/hush-misc/command2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/command2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+echo "echo test1; ./test2.sh" >test1.sh
+echo "echo test2" >test2.sh
+
+command . ./test1.sh
+
+rm -f test1.sh test2.sh
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/control_char1.right busybox-1.29.0/shell/hush_test/hush-misc/control_char1.right
--- busybox-1.28.4/shell/hush_test/hush-misc/control_char1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/control_char1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+
+b#c
+Done:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/control_char1.tests busybox-1.29.0/shell/hush_test/hush-misc/control_char1.tests
--- busybox-1.28.4/shell/hush_test/hush-misc/control_char1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/control_char1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+echo 
+echo 'b#c'
+echo Done:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/control_char2.right busybox-1.29.0/shell/hush_test/hush-misc/control_char2.right
--- busybox-1.28.4/shell/hush_test/hush-misc/control_char2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/control_char2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+
+Done:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/control_char2.tests busybox-1.29.0/shell/hush_test/hush-misc/control_char2.tests
--- busybox-1.28.4/shell/hush_test/hush-misc/control_char2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-misc/control_char2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+c=`printf '\3'`
+eval "echo $c"
+echo Done:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/for_with_bslashes.right busybox-1.29.0/shell/hush_test/hush-misc/for_with_bslashes.right
--- busybox-1.28.4/shell/hush_test/hush-misc/for_with_bslashes.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-misc/for_with_bslashes.right	2018-07-02 15:55:14.000000000 +0200
@@ -5,4 +5,5 @@ b"c
 b'c
 b$c
 b`true`c
+b#c
 Zero:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/for_with_bslashes.tests busybox-1.29.0/shell/hush_test/hush-misc/for_with_bslashes.tests
--- busybox-1.28.4/shell/hush_test/hush-misc/for_with_bslashes.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-misc/for_with_bslashes.tests	2018-07-02 15:55:14.000000000 +0200
@@ -1,9 +1,5 @@
-# UNFIXED BUG.
-# commented-out words contain ^C character.
-# It's a SPECIAL_VAR_SYMBOL, for now hush does not escape it.
-# When it is fixed, update this test.
-
-for a in 'a' 'b\c' 'b\\c' 'b"c' "b'c" 'b$c' 'b`true`c' ### 'b#c'
+# last word contains ^C character.
+for a in 'a' 'b\c' 'b\\c' 'b"c' "b'c" 'b$c' 'b`true`c' 'b#c'
 do
     echo $a
 done
diff -urpN busybox-1.28.4/shell/hush_test/hush-misc/func5.tests busybox-1.29.0/shell/hush_test/hush-misc/func5.tests
--- busybox-1.28.4/shell/hush_test/hush-misc/func5.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-misc/func5.tests	2018-07-02 15:55:14.000000000 +0200
@@ -1,9 +1,8 @@
 f() { echo $1; }
 f 1
 
-# hush fails on this syntax, but i've never seen anyone use it ...
-#f() ( echo $1; )
+f() ( echo $1; )
 f 2
 
-#f() ( echo $1 )
+f() ( echo $1 )
 f 3
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof1.right busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof1.right
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+ok\
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof1.tests busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof1.tests
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+eval 'echo ok\'
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof2.right busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof2.right
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+hush: syntax error: unterminated "
+One:1
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof2.tests busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof2.tests
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_eof2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_eof2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+printf 'echo "unterminated string\\' >test.tmp.sh
+. ./test.tmp.sh
+echo One:$?
+rm -f test.tmp.sh
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline1.right busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline1.right
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+and1
+and2
+or1
+ok
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline1.tests busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline1.tests
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+echo and1 &\
+& echo and2
+
+echo or1 |\
+| echo NOT SHOWN
+
+case w in a) echo SKIP;\
+; w) echo ok;; esac;
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline2.right busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline2.right
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+Line with one backslash:
+\
+
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline2.tests busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline2.tests
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+echo Line with one backslash:
+echo '\
+'
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline3.right busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline3.right
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+a:[a]
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline3.tests busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline3.tests
--- busybox-1.28.4/shell/hush_test/hush-parsing/bkslash_newline3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/bkslash_newline3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+for s in 	\
+a; do
+	echo "a:[$s]"
+done
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/starquoted3.right busybox-1.29.0/shell/hush_test/hush-parsing/starquoted3.right
--- busybox-1.28.4/shell/hush_test/hush-parsing/starquoted3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/starquoted3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+<a>
+<>
diff -urpN busybox-1.28.4/shell/hush_test/hush-parsing/starquoted3.tests busybox-1.29.0/shell/hush_test/hush-parsing/starquoted3.tests
--- busybox-1.28.4/shell/hush_test/hush-parsing/starquoted3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-parsing/starquoted3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+set -- a ""; space=" "; printf "<%s>\n" "$@"$space
diff -urpN busybox-1.28.4/shell/hush_test/hush-psubst/falsetick2.right busybox-1.29.0/shell/hush_test/hush-psubst/falsetick2.right
--- busybox-1.28.4/shell/hush_test/hush-psubst/falsetick2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-psubst/falsetick2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+Two:2 v:[]
diff -urpN busybox-1.28.4/shell/hush_test/hush-psubst/falsetick2.tests busybox-1.29.0/shell/hush_test/hush-psubst/falsetick2.tests
--- busybox-1.28.4/shell/hush_test/hush-psubst/falsetick2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-psubst/falsetick2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+v=v
+v=`exit 2` `false`
+echo Two:$? v:"[$v]"
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case1.right busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case1.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,10 @@
+ok1
+ok2
+ok3
+ok4
+ok5
+Ok:0
+ok6
+ok7
+ok8
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case1.tests busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case1.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,38 @@
+# Case argument is globbed, match patterns are not.
+# This caught some bugs in the past.
+
+case z in
+\z  ) echo ok1 ;;
+*   ) echo BUG ;;
+esac
+case \z in
+z   ) echo ok2 ;;
+*   ) echo BUG ;;
+esac
+case \z in
+\z  ) echo ok3 ;;
+*   ) echo BUG ;;
+esac
+case z in
+\z  ) echo ok4 ;;
+*   ) echo BUG ;;
+esac
+case \\z in
+\\z ) echo ok5 ;;
+*   ) echo BUG ;;
+esac
+echo Ok:$?
+
+case "\z" in
+"\z"  ) echo ok6 ;;
+*     ) echo BUG ;;
+esac
+case "\\z" in
+"\\z" ) echo ok7 ;;
+*     ) echo BUG ;;
+esac
+case "\\\z" in
+"\\\z") echo ok8 ;;
+*     ) echo BUG ;;
+esac
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case2.right busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case2.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+ok1
+ok2
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case2.tests busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case2.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_case2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_case2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,13 @@
+x='\abc'
+
+case "$x" in
+\\*) echo ok1;;
+*)   echo BUG1;;
+esac
+
+case $x in
+\\*) echo ok2;;
+*)   echo BUG2;;
+esac
+
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp.right busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+Nothing:
+Nothing:
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp.tests busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,16 @@
+x='a]'
+#
+# \] is not a valid escape for ] in set glob expression.
+# Glob sets have no escaping at all:
+# ] can be in a set if it is the first char: []abc],
+# dash can be in a set if it is first or last: [abc-],
+# [ and \ need no protections at all: [a[b\c] is a valid set of 5 chars.
+#
+# bash-4.3.43 misinterprets [a\]] as "set of 'a' or ']'".
+# Correct interpretation is "set of 'a' or '\', followed by ']'".
+#
+echo Nothing:${x#[a\]]}
+echo Nothing:"${x#[a\]]}"
+echo Nothing:${x%[a\]]}
+echo Nothing:"${x%[a\]]}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp1.right busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp1.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+Nothing:
+Nothing:
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp1.tests busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp1.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/bkslash_in_varexp1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/bkslash_in_varexp1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+x=a
+echo Nothing:${x#[]a]}
+echo Nothing:"${x#[]a]}"
+echo Nothing:${x%[]a]}
+echo Nothing:"${x%[]a]}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/case_glob1.right busybox-1.29.0/shell/hush_test/hush-quoting/case_glob1.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/case_glob1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/case_glob1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+s
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/case_glob1.tests busybox-1.29.0/shell/hush_test/hush-quoting/case_glob1.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/case_glob1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/case_glob1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+g='[3](a)(b)(c)'
+s='[3](a)(b)(c)'
+case $g in
+"$s")   echo s
+        ;;
+*)      echo "*"
+        ;;
+esac
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.right busybox-1.29.0/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+\/a\/bc\/def\/file
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.tests busybox-1.29.0/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/dollar_repl_slash_bash2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+var="/a/bc/def/file"
+echo "${var//\//\\/}"
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp.right busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+z
+z
+y
+y
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp.tests busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+x=yz
+echo ${x#'y'}
+echo "${x#'y'}"
+echo ${x%'z'}
+echo "${x%'z'}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp1.right busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp1.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp1.tests busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp1.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+x='\\\\'
+printf Nothing:'%s\n' ${x#\\\\\\\\}
+printf Nothing:'%s\n' "${x#\\\\\\\\}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp2.right busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp2.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+Nothing:
+Nothing:
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp2.tests busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp2.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+x='\\\\'
+printf Nothing:'%s\n' ${x#'\\\\'}
+printf Nothing:'%s\n' "${x#'\\\\'}"
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp3.right busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp3.right
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+B
diff -urpN busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp3.tests busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp3.tests
--- busybox-1.28.4/shell/hush_test/hush-quoting/squote_in_varexp3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-quoting/squote_in_varexp3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+x=\'B; echo "${x#\'}"
diff -urpN busybox-1.28.4/shell/hush_test/hush-read/read_ifs2.right busybox-1.29.0/shell/hush_test/hush-read/read_ifs2.right
--- busybox-1.28.4/shell/hush_test/hush-read/read_ifs2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-read/read_ifs2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,9 @@
+|X|Y:Z:|
+|X|Y:Z|
+|X|Y|
+|X|Y|
+|X||
+|X||
+|||
+Whitespace should be trimmed too:
+|X|Y|
diff -urpN busybox-1.28.4/shell/hush_test/hush-read/read_ifs2.tests busybox-1.29.0/shell/hush_test/hush-read/read_ifs2.tests
--- busybox-1.28.4/shell/hush_test/hush-read/read_ifs2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-read/read_ifs2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,9 @@
+echo "X:Y:Z:" | (IFS=": " read x y; echo "|$x|$y|")
+echo "X:Y:Z"  | (IFS=": " read x y; echo "|$x|$y|")
+echo "X:Y:"   | (IFS=": " read x y; echo "|$x|$y|")
+echo "X:Y"    | (IFS=": " read x y; echo "|$x|$y|")
+echo "X:"     | (IFS=": " read x y; echo "|$x|$y|")
+echo "X"      | (IFS=": " read x y; echo "|$x|$y|")
+echo ""       | (IFS=": " read x y; echo "|$x|$y|")
+echo Whitespace should be trimmed too:
+echo "X:Y  : " | (IFS=": " read x y; echo "|$x|$y|")
diff -urpN busybox-1.28.4/shell/hush_test/hush-redir/redir_backquote1.right busybox-1.29.0/shell/hush_test/hush-redir/redir_backquote1.right
--- busybox-1.28.4/shell/hush_test/hush-redir/redir_backquote1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-redir/redir_backquote1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,11 @@
+hush: can't open '/cant/be/created': No such file or directory
+First
+One:1 v1:[]
+hush: can't open '/cant/be/created': No such file or directory
+Second
+One:1 v2:[]
+Third
+Zero:0 v3:[]
+Fourth
+Zero:0 v4:[]
+Zero:0 v5:[1]
diff -urpN busybox-1.28.4/shell/hush_test/hush-redir/redir_backquote1.tests busybox-1.29.0/shell/hush_test/hush-redir/redir_backquote1.tests
--- busybox-1.28.4/shell/hush_test/hush-redir/redir_backquote1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-redir/redir_backquote1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,19 @@
+v=v
+v=`echo First >&2` `` >/cant/be/created
+echo One:$? v1:"[$v]"
+
+v=v
+v=`echo Second >&2` `true` >/cant/be/created
+echo One:$? v2:"[$v]"
+
+v=v
+v=`echo Third >&2` `true` 2>/dev/null
+echo Zero:$? v3:"[$v]"
+
+v=v
+v=`echo Fourth >&2` `false` 2>/dev/null
+echo Zero:$? v4:"[$v]"
+
+v=v
+v=`echo $?` `false` 2>/dev/null
+echo Zero:$? v5:"[$v]"
diff -urpN busybox-1.28.4/shell/hush_test/hush-redir/redir_exec1.right busybox-1.29.0/shell/hush_test/hush-redir/redir_exec1.right
--- busybox-1.28.4/shell/hush_test/hush-redir/redir_exec1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-redir/redir_exec1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+First
+hush: can't open '/cant/be/created': No such file or directory
+One:1
diff -urpN busybox-1.28.4/shell/hush_test/hush-redir/redir_exec1.tests busybox-1.29.0/shell/hush_test/hush-redir/redir_exec1.tests
--- busybox-1.28.4/shell/hush_test/hush-redir/redir_exec1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-redir/redir_exec1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+v=`echo First >&2` exec >/cant/be/created
+echo One:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/param_expand_alt2.right busybox-1.29.0/shell/hush_test/hush-vars/param_expand_alt2.right
--- busybox-1.28.4/shell/hush_test/hush-vars/param_expand_alt2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/param_expand_alt2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+Unquoted: H H
+Quoted: H
+H
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/param_expand_alt2.tests busybox-1.29.0/shell/hush_test/hush-vars/param_expand_alt2.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/param_expand_alt2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/param_expand_alt2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,7 @@
+echo Unquoted: H${$+
+}H
+
+echo Quoted: "H${$+
+}H"
+
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/param_expand_bash_substring.right busybox-1.29.0/shell/hush_test/hush-vars/param_expand_bash_substring.right
--- busybox-1.28.4/shell/hush_test/hush-vars/param_expand_bash_substring.right	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-vars/param_expand_bash_substring.right	2018-07-02 15:55:14.000000000 +0200
@@ -3,6 +3,7 @@ hush: syntax error: unterminated ${name}
 hush: syntax error: unterminated ${name}
 hush: syntax error: unterminated ${name}
 0123456789
+0
 1    =||
 1:1  =||
 1:1:2=||
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/param_expand_bash_substring.tests busybox-1.29.0/shell/hush_test/hush-vars/param_expand_bash_substring.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/param_expand_bash_substring.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-vars/param_expand_bash_substring.tests	2018-07-02 15:55:14.000000000 +0200
@@ -11,7 +11,7 @@ export var=0123456789
 "$THIS_SH" -c 'echo ${var:}' SHELL
 
 # then some funky ones
-# UNFIXED BUG: this should work: "$THIS_SH" -c 'echo ${?:0}'
+"$THIS_SH" -c 'echo ${?:0}' SHELL
 
 # now some valid ones
 set --; echo "1    =|${1}|"
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/readonly3.right busybox-1.29.0/shell/hush_test/hush-vars/readonly3.right
--- busybox-1.28.4/shell/hush_test/hush-vars/readonly3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/readonly3.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+hush: v=2: readonly variable
+hush: v=3: readonly variable
+1
+Ok:1
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/readonly3.tests busybox-1.29.0/shell/hush_test/hush-vars/readonly3.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/readonly3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/readonly3.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+readonly v=1
+# there was a bug causing second assignment to be not checked
+v=2 v=3 echo $v
+echo Ok:$v
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_LINENO1.right busybox-1.29.0/shell/hush_test/hush-vars/var_LINENO1.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_LINENO1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_LINENO1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,8 @@
+2:2
+3:3
+4:4
+5:5
+2:2
+3:3
+4:4
+5:5
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_LINENO1.tests busybox-1.29.0/shell/hush_test/hush-vars/var_LINENO1.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_LINENO1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_LINENO1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,6 @@
+env | grep ^LINENO
+echo 2:$LINENO
+echo 3:$LINENO >&2 \
+| { sleep 0.1; echo 4:$LINENO; }
+echo 5:$LINENO
+test "$1" || . ./var_LINENO1.tests norepeat
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash3.right busybox-1.29.0/shell/hush_test/hush-vars/var_bash3.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash3.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash3.right	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 1 a041#c
 2 a041#c
-3 a\041#c
+3 a041#c
 4 a\041#c
 5 a\041#c
 6 a\041#c
@@ -17,4 +17,4 @@
 17 a\tc
 18 a\tc
 19 atc
-20 a\tc
+20 atc
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash4.right busybox-1.29.0/shell/hush_test/hush-vars/var_bash4.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash4.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash4.right	2018-07-02 15:55:14.000000000 +0200
@@ -3,26 +3,26 @@ Replace str:   _\\_\z_
 Pattern:       single backslash and star: "replace literal star"
 Unquoted:      a_\_z_b\*c
 Unquoted =:    a_\_z_b\*c
-Quoted:        a_\_\z_b\*c
-Quoted =:      a_\_\z_b\*c
+Quoted:        a_\_z_b\*c
+Quoted =:      a_\_z_b\*c
 Pattern:       double backslash and star: "replace backslash and everything after it"
 Unquoted:      a*b_\_z_
 Unquoted =:    a*b_\_z_
-Quoted:        a*b_\_\z_
-Quoted =:      a*b_\_\z_
+Quoted:        a*b_\_z_
+Quoted =:      a*b_\_z_
 
 Source:        a\bc
 Replace str:   _\\_\z_
 Pattern:       single backslash and b: "replace b"
 Unquoted:      a\_\_z_c
 Unquoted =:    a\_\_z_c
-Quoted:        a\_\_\z_c
-Quoted =:      a\_\_\z_c
+Quoted:        a\_\_z_c
+Quoted =:      a\_\_z_c
 Pattern:       double backslash and b: "replace backslash and b"
 Unquoted:      a_\_z_c
 Unquoted =:    a_\_z_c
-Quoted:        a_\_\z_c
-Quoted =:      a_\_\z_c
+Quoted:        a_\_z_c
+Quoted =:      a_\_z_c
 
 Source:        a\bc
 Replace str:   _\\_\z_ (as variable $s)
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash6.right busybox-1.29.0/shell/hush_test/hush-vars/var_bash6.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash6.right	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash6.right	2018-07-02 15:55:14.000000000 +0200
@@ -1,5 +1,5 @@
 Expected Actual
 a*z    : a*z
-\z     : \z
+z      : z
 a1z a2z: a1z a2z
 z      : z
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash6.tests busybox-1.29.0/shell/hush_test/hush-vars/var_bash6.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash6.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash6.tests	2018-07-02 15:55:14.000000000 +0200
@@ -3,7 +3,7 @@
 >a1z; >a2z;
           echo 'Expected' 'Actual'
 v='a bz'; echo 'a*z    :' "${v/a*z/a*z}"
-v='a bz'; echo '\z     :' "${v/a*z/\z}"
+v='a bz'; echo 'z      :' "${v/a*z/\z}"
 v='a bz'; echo 'a1z a2z:' ${v/a*z/a*z}
 v='a bz'; echo 'z      :' ${v/a*z/\z}
 rm a1z a2z
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.right busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+v
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.tests busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_pattern.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+v=v
+echo ${v//}
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_var.right busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_var.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_var.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_var.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+
+Ok:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_var.tests busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_var.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_bash_repl_empty_var.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_bash_repl_empty_var.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+v=''
+echo ${v/*/w}
+echo Ok:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_nested1.right busybox-1.29.0/shell/hush_test/hush-vars/var_nested1.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_nested1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_nested1.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,3 @@
+Expected:AB Actual:AB
+Expected:Ab Actual:Ab
+Expected:ab Actual:ab
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_nested1.tests busybox-1.29.0/shell/hush_test/hush-vars/var_nested1.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_nested1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_nested1.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,16 @@
+f() { a=A; b=B; }
+
+a=a
+b=b
+f
+echo Expected:AB Actual:$a$b
+
+a=a
+b=b
+b= f
+echo Expected:Ab Actual:$a$b
+
+a=a
+b=b
+a= b= f
+echo Expected:ab Actual:$a$b
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_nested2.right busybox-1.29.0/shell/hush_test/hush-vars/var_nested2.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_nested2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_nested2.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+aB
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_nested2.tests busybox-1.29.0/shell/hush_test/hush-vars/var_nested2.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_nested2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_nested2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,2 @@
+# the bug was easier to trigger in one-liner form
+a=a; b=b; f() { a=A; b=B; }; a= f; echo $a$b
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_wordsplit_ifs4.right busybox-1.29.0/shell/hush_test/hush-vars/var_wordsplit_ifs4.right
--- busybox-1.28.4/shell/hush_test/hush-vars/var_wordsplit_ifs4.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_wordsplit_ifs4.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,5 @@
+|x|
+Ok1:0
+|x|
+||
+Ok2:0
diff -urpN busybox-1.28.4/shell/hush_test/hush-vars/var_wordsplit_ifs4.tests busybox-1.29.0/shell/hush_test/hush-vars/var_wordsplit_ifs4.tests
--- busybox-1.28.4/shell/hush_test/hush-vars/var_wordsplit_ifs4.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-vars/var_wordsplit_ifs4.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,4 @@
+IFS=": "; x=" "; set x $x; for v; do echo "|$v|"; done
+echo Ok1:$?
+IFS=": "; x=":"; set x $x; for v; do echo "|$v|"; done
+echo Ok2:$?
diff -urpN busybox-1.28.4/shell/hush_test/hush-z_slow/many_ifs.right busybox-1.29.0/shell/hush_test/hush-z_slow/many_ifs.right
--- busybox-1.28.4/shell/hush_test/hush-z_slow/many_ifs.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-z_slow/many_ifs.right	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1 @@
+# tests 6856 passed 6856 failed 0
diff -urpN busybox-1.28.4/shell/hush_test/hush-z_slow/many_ifs.tests busybox-1.29.0/shell/hush_test/hush-z_slow/many_ifs.tests
--- busybox-1.28.4/shell/hush_test/hush-z_slow/many_ifs.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/shell/hush_test/hush-z_slow/many_ifs.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,257 @@
+# Usage: $SHELL ifs.sh
+#
+# This script generates 6856 tests for the set(1) and read(1)
+# builtins w.r.t. IFS whitespace and non-whitespace characters.
+# Each failed test produces one line on the standard output that
+# contains the test along with the expected and actual results.
+# The last output line contains the test result counts.  ordered>0
+# are the number of tests where IFS=": " produced different results
+# than IFS=" :".  If a test fails the same way for IFS=": " and
+# IFS=" :" then the second output line is suppressed.
+
+TESTS=6856
+
+ksh_read=0
+echo 1 | read ksh_read
+ksh_arith=0
+eval '((ksh_arith+=1))' 2>/dev/null
+
+failed=0
+ordered=0
+passed=0
+
+split()
+{
+	i=$1 s=$2 r=$3 S='' R=''
+	for ifs in ': ' ' :'
+	do	IFS=$ifs
+		set x $i
+		shift
+		IFS=' '
+		g="[$#]"
+		while	:
+		do	case $# in
+			0)	break ;;
+			esac
+			g="$g($1)"
+			shift
+		done
+		case $g in
+		"$s")	case $ksh_arith in
+			1)	((passed+=1)) ;;
+			*)	passed=`expr $passed + 1` ;;
+			esac
+			case $S in
+			'')	S=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+			;;
+		"$S")	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			;;
+		*)	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			case $s in
+			"$S")	;;
+			?0*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#]\" # expected \"$s\" got \"$g\"" ;;
+			?1*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)\" # expected \"$s\" got \"$g\"" ;;
+			?2*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)(\$2)\" # expected \"$s\" got \"$g\"" ;;
+			?3*)	echo "IFS=\"$ifs\"; x=\"$i\"; set x \$x; shift; echo \"[\$#](\$1)(\$2)(\$3)\" # expected \"$s\" got \"$g\"" ;;
+			*)	echo TEST ERROR i="'$i'" s="'$s'" ;;
+			esac
+			case $S in
+			'')	S=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+		esac
+		case $ksh_read in
+		1)	echo "$i" | IFS=$ifs read x y; g="($x)($y)" ;;
+		*)	g=`export ifs; echo "$i" | ( IFS=$ifs; read x y; echo "($x)($y)" )` ;;
+		esac
+		case $g in
+		"$r")	case $ksh_arith in
+			1)	((passed+=1)) ;;
+			*)	passed=`expr $passed + 1` ;;
+			esac
+			case $R in
+			'')	R=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+			;;
+		"$R")	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			;;
+		*)	case $ksh_arith in
+			1)	((failed+=1)) ;;
+			*)	failed=`expr $failed + 1` ;;
+			esac
+			case $r in
+			"$R")	;;
+			*)	echo "echo \"$i\" | ( IFS=\"$ifs\" read x y; echo \"(\$x)(\$y)\" ) # expected \"$r\" got \"$g\"" ;;
+			esac
+			case $R in
+			'')	R=$g
+				;;
+			"$g")	;;
+			*)	case $ksh_arith in
+				1)	((ordered+=1)) ;;
+				*)	ordered=`expr $ordered + 1` ;;
+				esac
+				;;
+			esac
+			;;
+		esac
+	done
+}
+
+for str in 	\
+	'-'	\
+	'a'	\
+	'- -'	\
+	'- a'	\
+	'a -'	\
+	'a b'	\
+	'- - -'	\
+	'- - a'	\
+	'- a -'	\
+	'- a b'	\
+	'a - -'	\
+	'a - b'	\
+	'a b -'	\
+	'a b c'	\
+
+do
+	IFS=' '
+	set x $str
+
+	shift
+	case $# in
+	0)	continue ;;
+	esac
+
+	f1=$1
+	case $f1 in
+	'-')	f1='' ;;
+	esac
+
+	shift
+	case $# in
+	0)	for d0 in '' ' '
+		do
+			for d1 in '' ' ' ':' ' :' ': ' ' : '
+			do
+				case $f1$d1 in
+				'')	split "$d0$f1$d1" "[0]" "()()" ;;
+				' ')	;;
+				*)	split "$d0$f1$d1" "[1]($f1)" "($f1)()" ;;
+				esac
+			done
+		done
+		continue
+		;;
+	esac
+	f2=$1
+	case $f2 in
+	'-')	f2='' ;;
+	esac
+
+	shift
+	case $# in
+	0)	for d0 in '' ' '
+		do
+			for d1 in ' ' ':' ' :' ': ' ' : '
+			do
+				case ' ' in
+				$f1$d1|$d1$f2)	continue ;;
+				esac
+				for d2 in '' ' ' ':' ' :' ': ' ' : '
+				do
+					case $f2$d2 in
+					'')	split "$d0$f1$d1$f2$d2" "[1]($f1)" "($f1)()" ;;
+					' ')	;;
+					*)	split "$d0$f1$d1$f2$d2" "[2]($f1)($f2)" "($f1)($f2)" ;;
+					esac
+				done
+			done
+		done
+		continue
+		;;
+	esac
+	f3=$1
+	case $f3 in
+	'-')	f3='' ;;
+	esac
+
+	shift
+	case $# in
+	0)	for d0 in '' ' '
+		do
+			for d1 in ':' ' :' ': ' ' : '
+			do
+				case ' ' in
+				$f1$d1|$d1$f2)	continue ;;
+				esac
+				for d2 in ' ' ':' ' :' ': ' ' : '
+				do
+					case $f2$d2 in
+					' ')	continue ;;
+					esac
+					case ' ' in
+					$f2$d2|$d2$f3)	continue ;;
+					esac
+					for d3 in '' ' ' ':' ' :' ': ' ' : '
+					do
+						case $f3$d3 in
+						'')	split "$d0$f1$d1$f2$d2$f3$d3" "[2]($f1)($f2)" "($f1)($f2)" ;;
+						' ')	;;
+						*)	x=$f2$d2$f3$d3
+							x=${x# } #was x=${x#' '} hush needs fixing for this to work
+							x=${x% } #was x=${x%' '}
+							split "$d0$f1$d1$f2$d2$f3$d3" "[3]($f1)($f2)($f3)" "($f1)($x)"
+							;;
+						esac
+					done
+				done
+			done
+		done
+		continue
+		;;
+	esac
+done
+case $ksh_arith in
+1)	((tests=passed+failed)) ;;
+*)	tests=`expr $passed + $failed` ;;
+esac
+case $ordered in
+0)	ordered="" ;;
+*)	ordered=" ordered $ordered" ;;
+esac
+case $tests in
+$TESTS)	fatal="" ;;
+*)	fatal=" -- fundamental IFS error -- $TESTS tests expected"
+esac
+echo "# tests $tests passed $passed failed $failed$ordered$fatal"
diff -urpN busybox-1.28.4/shell/match.c busybox-1.29.0/shell/match.c
--- busybox-1.28.4/shell/match.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/match.c	2018-07-02 15:55:14.000000000 +0200
@@ -71,9 +71,11 @@ char* FAST_FUNC scan_and_match(char *str
 		if (flags & SCAN_MATCH_LEFT_HALF) {
 			*loc = '\0';
 			r = fnmatch(pattern, string, 0);
+			//bb_error_msg("fnmatch('%s','%s',0):%d", pattern, string, r);
 			*loc = c;
 		} else {
 			r = fnmatch(pattern, loc, 0);
+			//bb_error_msg("fnmatch('%s','%s',0):%d", pattern, loc, r);
 		}
 		if (r == 0) /* match found */
 			return loc;
diff -urpN busybox-1.28.4/shell/math.c busybox-1.29.0/shell/math.c
--- busybox-1.28.4/shell/math.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/shell/math.c	2018-07-02 15:55:14.000000000 +0200
@@ -598,10 +598,24 @@ evaluate_string(arith_state_t *math_stat
 		}
 
 		/* Should be an operator */
+
+		/* Special case: NUM-- and NUM++ are not recognized if NUM
+		 * is a literal number, not a variable. IOW:
+		 * "a+++v" is a++ + v.
+		 * "7+++v" is 7 + ++v, not 7++ + v.
+		 */
+		if (lasttok == TOK_NUM && !numstackptr[-1].var /* number literal */
+		 && (expr[0] == '+' || expr[0] == '-')
+		 && (expr[1] == expr[0])
+		) {
+			//bb_error_msg("special %c%c", expr[0], expr[0]);
+			op = (expr[0] == '+' ? TOK_ADD : TOK_SUB);
+			expr += 1;
+			goto tok_found1;
+		}
+
 		p = op_tokens;
 		while (1) {
-// TODO: bash allows 7+++v, treats it as 7 + ++v
-// we treat it as 7++ + v and reject
 			/* Compare expr to current op_tokens[] element */
 			const char *e = expr;
 			while (1) {
@@ -627,6 +641,7 @@ evaluate_string(arith_state_t *math_stat
 		}
  tok_found:
 		op = p[1]; /* fetch TOK_foo value */
+ tok_found1:
 		/* NB: expr now points past the operator */
 
 		/* post grammar: a++ reduce to num */
diff -urpN busybox-1.28.4/shell/shell_common.c busybox-1.29.0/shell/shell_common.c
--- busybox-1.28.4/shell/shell_common.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/shell/shell_common.c	2018-07-02 15:55:14.000000000 +0200
@@ -18,7 +18,6 @@
  */
 #include "libbb.h"
 #include "shell_common.h"
-#include <sys/resource.h> /* getrlimit */
 
 const char defifsvar[] ALIGN1 = "IFS= \t\n";
 const char defoptindvar[] ALIGN1 = "OPTIND=1";
@@ -275,9 +274,44 @@ shell_builtin_read(void FAST_FUNC (*setv
 
 	if (argv[0]) {
 		/* Remove trailing space $IFS chars */
-		while (--bufpos >= 0 && isspace(buffer[bufpos]) && strchr(ifs, buffer[bufpos]) != NULL)
+		while (--bufpos >= 0
+		 && isspace(buffer[bufpos])
+		 && strchr(ifs, buffer[bufpos]) != NULL
+		) {
 			continue;
+		}
 		buffer[bufpos + 1] = '\0';
+
+		/* Last variable takes the entire remainder with delimiters
+		 * (sans trailing whitespace $IFS),
+		 * but ***only "if there are fewer vars than fields"(c)***!
+		 * The "X:Y:" case below: there are two fields,
+		 * and therefore last delimiter (:) is eaten:
+		 * IFS=": "
+		 * echo "X:Y:Z:"  | (read x y; echo "|$x|$y|") # |X|Y:Z:|
+		 * echo "X:Y:Z"   | (read x y; echo "|$x|$y|") # |X|Y:Z|
+		 * echo "X:Y:"    | (read x y; echo "|$x|$y|") # |X|Y|, not |X|Y:|
+		 * echo "X:Y  : " | (read x y; echo "|$x|$y|") # |X|Y|
+		 */
+		if (bufpos >= 0
+		 && strchr(ifs, buffer[bufpos]) != NULL
+		) {
+			/* There _is_ a non-whitespace IFS char */
+			/* Skip whitespace IFS char before it */
+			while (--bufpos >= 0
+			 && isspace(buffer[bufpos])
+			 && strchr(ifs, buffer[bufpos]) != NULL
+			) {
+				continue;
+			}
+			/* Are there $IFS chars? */
+			if (strcspn(buffer, ifs) >= ++bufpos) {
+				/* No: last var takes one field, not more */
+				/* So, drop trailing IFS delims */
+				buffer[bufpos] = '\0';
+			}
+		}
+
 		/* Use the remainder as a value for the next variable */
 		setvar(*argv, buffer);
 		/* Set the rest to "" */
diff -urpN busybox-1.28.4/size_single_applets.sh busybox-1.29.0/size_single_applets.sh
--- busybox-1.28.4/size_single_applets.sh	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/size_single_applets.sh	2018-07-02 15:55:14.000000000 +0200
@@ -22,7 +22,7 @@ for app; do
 	}
 	test $mintext -gt $text && {
 		mintext=$text
-		echo "New mintext from $app: $mintext"
+		echo "# New mintext from $app: $mintext"
 	}
 	eval "text_${app}=$text"
 done
@@ -31,7 +31,7 @@ for app; do
 	b="busybox_${app}"
 	test -f "$b" || continue
 	eval "text=\$text_${app}"
-	echo "$app adds $((text-mintext))"
+	echo "# $app adds $((text-mintext))"
 done
 
 grep ^IF_ include/applets.h \
@@ -60,7 +60,7 @@ grep ^IF_ include/applets.h \
 	sz_frac=$(( (sz - sz_kb*1000) ))
 	sz_f=$((sz_frac / 100))
 
-	echo -n "sed 's/bool \"$name *(*[0-9tinykbytes .]*)*\"/"
+	echo -n "sed 's/bool \"$name"'[" ](*[0-9tinykbytes .]*)*"*$/'
 	if test "$sz_kb" -ge 10; then
 		echo -n "bool \"$name (${sz_kb} kb)\""
 	elif test "$sz_kb" -gt 0 -a "$sz_f" = 0; then
diff -urpN busybox-1.28.4/sysklogd/Config.src busybox-1.29.0/sysklogd/Config.src
--- busybox-1.28.4/sysklogd/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/sysklogd/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "System Logging Utilities"
diff -urpN busybox-1.28.4/sysklogd/syslogd_and_logger.c busybox-1.29.0/sysklogd/syslogd_and_logger.c
--- busybox-1.28.4/sysklogd/syslogd_and_logger.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/sysklogd/syslogd_and_logger.c	2018-07-02 15:55:14.000000000 +0200
@@ -53,6 +53,7 @@ typedef struct _code {
 static const CODE *const bb_prioritynames = prioritynames;
 static const CODE *const bb_facilitynames = facilitynames;
 
+
 #if ENABLE_SYSLOGD
 #include "syslogd.c"
 #endif
diff -urpN busybox-1.28.4/testsuite/awk.tests busybox-1.29.0/testsuite/awk.tests
--- busybox-1.28.4/testsuite/awk.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/testsuite/awk.tests	2018-07-02 15:55:14.000000000 +0200
@@ -261,6 +261,25 @@ end d
 " \
 	"" ""
 
+prg='
+BEGIN{
+cnt = 0
+a[cnt] = "zeroth"
+a[++cnt] = "first"
+delete a[cnt--]
+print cnt
+print "[0]:" a[0]
+print "[1]:" a[1]
+}'
+testing "awk 'delete a[v--]' evaluates v-- once" \
+	"awk '$prg'" \
+	"\
+0
+[0]:zeroth
+[1]:
+" \
+	"" ""
+
 testing "awk handles empty ()" \
 	"awk 'BEGIN {print()}' 2>&1" "awk: cmd. line:1: Empty sequence\n" "" ""
 
@@ -320,5 +339,11 @@ testing "awk handles invalid for loop" \
     "awk '{ for() }' 2>&1" "awk: cmd. line:1: Unexpected token\n" "" ""
 
 # testing "description" "command" "result" "infile" "stdin"
+testing 'awk negative field access' \
+	'awk 2>&1 -- '\''{ $(-1) }'\' \
+	"awk: cmd. line:1: Access to negative field\n" \
+	'' \
+	'anything'
+
 
 exit $FAILCOUNT
diff -urpN busybox-1.28.4/testsuite/bunzip2.tests busybox-1.29.0/testsuite/bunzip2.tests
--- busybox-1.28.4/testsuite/bunzip2.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/bunzip2.tests	2018-07-02 15:55:14.000000000 +0200
@@ -552,6 +552,22 @@ if test "${0##*/}" = "bunzip2.tests"; th
 	echo "FAIL: $unpack: pbzip_4m_zeros file"
 	FAILCOUNT=$((FAILCOUNT + 1))
     fi
+
+    errout="`${bb}bunzip2 <bz2_issue_11.bz2 2>&1 >/dev/null`"
+    if test x"$errout:$?" = x"bunzip2: bunzip error -5:1"; then
+	echo "PASS: $unpack: bz2_issue_11.bz2 corrupted example"
+    else
+	echo "FAIL: $unpack: bz2_issue_11.bz2 corrupted example"
+	FAILCOUNT=$((FAILCOUNT + 1))
+    fi
+
+    errout="`${bb}bunzip2 <bz2_issue_12.bz2 2>&1 >/dev/null`"
+    if test x"$errout:$?" = x"bunzip2: bunzip error -3:1"; then
+	echo "PASS: $unpack: bz2_issue_12.bz2 corrupted example"
+    else
+	echo "FAIL: $unpack: bz2_issue_12.bz2 corrupted example"
+	FAILCOUNT=$((FAILCOUNT + 1))
+    fi
 fi
 
 exit $((FAILCOUNT <= 255 ? FAILCOUNT : 255))
diff -urpN busybox-1.28.4/testsuite/busybox.tests busybox-1.29.0/testsuite/busybox.tests
--- busybox-1.28.4/testsuite/busybox.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/testsuite/busybox.tests	2018-07-02 15:55:14.000000000 +0200
@@ -5,6 +5,7 @@
 # Licensed under GPLv2, see file LICENSE in this source tree.
 
 . ./testing.sh
+test -f "$bindir/.config" && . "$bindir/.config"
 
 ln -s `which busybox` unknown
 
@@ -18,29 +19,24 @@ test x"$CONFIG_BUSYBOX" = x"y" \
 
 HELPDUMP=`true | busybox 2>&1 | cat`
 
-# We need to test under calling the binary under other names.
-
 optional FEATURE_VERBOSE_USAGE
-testing "busybox --help busybox" "true | busybox --help busybox 2>&1 | cat" "$HELPDUMP\n\n" "" ""
+testing "busybox --help busybox" "true | busybox --help busybox 2>&1 | cat" "$HELPDUMP\n" "" ""
 SKIP=
 
 ln -s `which busybox` busybox-suffix
 for i in busybox ./busybox-suffix
 do
-	# The gratuitous "\n"s are due to a shell idiosyncrasy:
-	# environment variables seem to strip trailing whitespace.
-
-	testing "" "$i" "$HELPDUMP\n\n" "" ""
+	testing "$i" "$i 2>&1 | cat" "$HELPDUMP\n" "" ""
 
 	testing "$i unknown" "$i unknown 2>&1" \
 		"unknown: applet not found\n" "" ""
 
-	testing "$i --help" "$i --help 2>&1" "$HELPDUMP\n\n" "" ""
+	testing "$i --help" "$i --help 2>&1" "$HELPDUMP\n" "" ""
 
 	optional FEATURE_VERBOSE_USAGE CAT
 	testing "" "$i cat" "moo" "" "moo"
-	testing "$i --help cat" "$i --help cat 2>&1 | grep print" \
-		"Concatenate FILEs and print them to stdout\n" "" ""
+	testing "$i --help cat" "$i --help cat 2>&1 | grep Print" \
+		"Print FILEs to stdout\n" "" ""
 	SKIP=
 
 	testing "$i --help unknown" "$i --help unknown 2>&1" \
Binary files busybox-1.28.4/testsuite/bz2_issue_11.bz2 and busybox-1.29.0/testsuite/bz2_issue_11.bz2 differ
Binary files busybox-1.28.4/testsuite/bz2_issue_12.bz2 and busybox-1.29.0/testsuite/bz2_issue_12.bz2 differ
diff -urpN busybox-1.28.4/testsuite/bzcat.tests busybox-1.29.0/testsuite/bzcat.tests
--- busybox-1.28.4/testsuite/bzcat.tests	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/testsuite/bzcat.tests	2018-07-02 15:55:14.000000000 +0200
@@ -1,5 +1,7 @@
 #!/bin/sh
 
+test -f "$bindir/.config" && . "$bindir/.config"
+
 FAILCOUNT=0
 
 bb="busybox "
@@ -28,10 +30,11 @@ hello_bz2() {
     $ECHO -ne "\x17\x72\x45\x38\x50\x90\x5b\xb8\xe8\xa3"
 }
 
+test x"$CONFIG_ZCAT" = x"y" && \
 for ext in \
-    `test x"$CONFIG_GUNZIP"     = x"y" && echo gz` \
-    `test x"$CONFIG_BUNZIP2"    = x"y" && echo bz2` \
-    `test x"$CONFIG_UNCOMPRESS" = x"y" && echo Z`
+    `test x"$CONFIG_FEATURE_SEAMLESS_GZ"  = x"y" && echo gz` \
+    `test x"$CONFIG_FEATURE_SEAMLESS_BZ2" = x"y" && echo bz2` \
+    `test x"$CONFIG_FEATURE_SEAMLESS_Z"   = x"y" && echo Z`
 do
     prep() {
 	rm -f t1.$ext t2.$ext t_actual
@@ -45,6 +48,8 @@ do
 	    echo "PASS: $1"
 	else
 	    echo "FAIL: $1"
+	    #echo "t_actual:"
+	    #cat t_actual
 	    FAILCOUNT=$((FAILCOUNT + 1))
 	fi
     }
@@ -73,7 +78,7 @@ done
 
 # "input" file is bzipped file with "a\n" data
 testing "bzcat can print many files" \
-"$ECHO -ne '$hexdump' | bzcat input input; echo \$?" \
+"bzcat input input; echo \$?" \
 "\
 a
 a
@@ -86,16 +91,17 @@ a
 
 # "input" file is bzipped zero byte file
 testing "bzcat can handle compressed zero-length bzip2 files" \
-"$ECHO -ne '$hexdump' | bzcat input input; echo \$?" \
+"bzcat input input; echo \$?" \
 "0\n" \
 "\x42\x5a\x68\x39\x17\x72\x45\x38\x50\x90\x00\x00\x00\x00" ""
 
 ## compress algorithm
 
 # "input" file is compressed (.Z) file with "a\n" data
-test x"$CONFIG_UNCOMPRESS" = x"y" && \
+test x"$CONFIG_ZCAT" = x"y" && \
+test x"$CONFIG_FEATURE_SEAMLESS_Z" = x"y" && \
 testing "zcat can print many files" \
-"$ECHO -ne '$hexdump' | zcat input input; echo \$?" \
+"zcat input input; echo \$?" \
 "\
 a
 a
@@ -105,9 +111,10 @@ a
 " ""
 
 # "input" file is compressed (.Z) zero byte file
-test x"$CONFIG_UNCOMPRESS" = x"y" && \
+test x"$CONFIG_ZCAT" = x"y" && \
+test x"$CONFIG_FEATURE_SEAMLESS_Z" = x"y" && \
 testing "zcat can handle compressed zero-length (.Z) files" \
-"$ECHO -ne '$hexdump' | zcat input input; echo \$?" \
+"zcat input input; echo \$?" \
 "0\n" \
 "\x1f\x9d\x90\x00" ""
 
diff -urpN busybox-1.28.4/testsuite/cat.tests busybox-1.29.0/testsuite/cat.tests
--- busybox-1.28.4/testsuite/cat.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/testsuite/cat.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+# Copyright 2018 by Denys Vlasenko <vda.linux@googlemail.com>
+# Licensed under GPLv2, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "description" "command" "result" "infile" "stdin"
+optional FEATURE_CATV
+testing 'cat -e' \
+	'cat -e' \
+	'foo$\n' \
+	'' \
+	'foo\n'
+SKIP=
+
+optional FEATURE_CATV
+testing 'cat -v' \
+	'cat -v' \
+	'foo\n' \
+	'' \
+	'foo\n'
+SKIP=
+
+exit $FAILCOUNT
diff -urpN busybox-1.28.4/testsuite/grep.tests busybox-1.29.0/testsuite/grep.tests
--- busybox-1.28.4/testsuite/grep.tests	2018-04-01 13:04:11.000000000 +0200
+++ busybox-1.29.0/testsuite/grep.tests	2018-07-02 15:55:14.000000000 +0200
@@ -15,7 +15,7 @@
 
 testing "grep (exit with error)" "grep nonexistent 2> /dev/null ; echo \$?" \
 	"1\n" "" ""
-testing "grep (exit success)" "grep grep $0 > /dev/null 2>&1 ; echo \$?" "0\n" \
+testing "grep (exit success)" "grep grep '$0' > /dev/null 2>&1 ; echo \$?" "0\n" \
 	"" ""
 # Test various data sources and destinations
 
diff -urpN busybox-1.28.4/testsuite/mount.tests busybox-1.29.0/testsuite/mount.tests
--- busybox-1.28.4/testsuite/mount.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/mount.tests	2018-07-02 15:55:14.000000000 +0200
@@ -10,9 +10,11 @@ test "`id -u`" = 0 || {
 	exit 0
 }
 
+# Without MOUNT_LOOP_CREATE, the test will fail if /dev/loopN's do not exist
 if test x"$CONFIG_MKFS_MINIX" != x"y" \
 || test x"$CONFIG_FEATURE_MINIX2" != x"y" \
 || test x"$CONFIG_FEATURE_MOUNT_LOOP" != x"y" \
+|| test x"$CONFIG_FEATURE_MOUNT_LOOP_CREATE" != x"y" \
 || test x"$CONFIG_FEATURE_MOUNT_FLAGS" != x"y" \
 || test x"$CONFIG_FEATURE_DEVFS" = x"y" \
 ; then
diff -urpN busybox-1.28.4/testsuite/pidof.tests busybox-1.29.0/testsuite/pidof.tests
--- busybox-1.28.4/testsuite/pidof.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/pidof.tests	2018-07-02 15:55:14.000000000 +0200
@@ -18,15 +18,22 @@ testing "pidof (exit with success)" "pid
 
 testing "pidof this" "pidof pidof.tests | grep -o -w $$" "$$\n" "" ""
 
+test x"`cat /proc/1/comm`" = x"init" && {
 optional FEATURE_PIDOF_SINGLE
 testing "pidof -s" "pidof -s init" "1\n" "" ""
 SKIP=
+}
 
+test x"`cat /proc/1/comm`" = x"init" && {
 optional FEATURE_PIDOF_OMIT FEATURE_PIDOF_SINGLE
 # This test fails now because process name matching logic has changed,
 # but new logic is not "wrong" either... see find_pid_by_name.c comments
 #testing "pidof -o %PPID" "pidof -o %PPID pidof.tests | grep -o -w $$" "" "" ""
 testing "pidof -o %PPID NOP" "pidof -o %PPID -s init" "1\n" "" ""
+SKIP=
+}
+
+optional FEATURE_PIDOF_OMIT
 testing "pidof -o init" "pidof -o 1 init | grep -o -w 1" "" "" ""
 SKIP=
 
diff -urpN busybox-1.28.4/testsuite/printf.tests busybox-1.29.0/testsuite/printf.tests
--- busybox-1.28.4/testsuite/printf.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/printf.tests	2018-07-02 15:55:14.000000000 +0200
@@ -20,7 +20,7 @@ testing "printf produces no further outp
 	"" ""
 
 testing "printf repeatedly uses pattern for each argv" \
-	"${bb}printf '%s\n' foo \$HOME" \
+	"${bb}printf '%s\n' foo '$HOME'" \
 	"foo\n$HOME\n" \
 	"" ""
 
diff -urpN busybox-1.28.4/testsuite/pwd/pwd-prints-working-directory busybox-1.29.0/testsuite/pwd/pwd-prints-working-directory
--- busybox-1.28.4/testsuite/pwd/pwd-prints-working-directory	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/pwd/pwd-prints-working-directory	2018-07-02 15:55:14.000000000 +0200
@@ -1,4 +1,4 @@
 # shell's $PWD may leave symlinks unresolved.
 # "pwd" may be a built-in and have the same problem.
 # External pwd _can't_ have that problem (current dir on Unix is physical).
-test $(`which pwd`) = $(busybox pwd)
+test "$(`which pwd`)" = "$(busybox pwd)"
diff -urpN busybox-1.28.4/testsuite/sum.tests busybox-1.29.0/testsuite/sum.tests
--- busybox-1.28.4/testsuite/sum.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/sum.tests	2018-07-02 15:55:14.000000000 +0200
@@ -13,12 +13,12 @@
 #   test can create a file "actual" instead of writing to stdout
 
 testing "sum -r file doesn't print file's name" \
-        "sum -r $0 | grep -c $0 && echo wrongly_printed_filename || echo yes" \
+        "sum -r '$0' | grep -c '$0' && echo wrongly_printed_filename || echo yes" \
 	"0\nyes\n" "" ""
 testing "sum -r file file does print both names" \
-        "sum -r $0 $0 | grep -c $0 && echo yes || echo wrongly_omitted_filename" \
+        "sum -r '$0' '$0' | grep -c '$0' && echo yes || echo wrongly_omitted_filename" \
 	"2\nyes\n" "" ""
 testing "sum -s file does print file's name" \
-        "sum -s $0 | grep -c $0 && echo yes || echo wrongly_omitted_filename" \
+        "sum -s '$0' | grep -c '$0' && echo yes || echo wrongly_omitted_filename" \
 	"1\nyes\n" "" ""
 exit $FAILCOUNT
diff -urpN busybox-1.28.4/testsuite/tar.tests busybox-1.29.0/testsuite/tar.tests
--- busybox-1.28.4/testsuite/tar.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/tar.tests	2018-07-02 15:55:14.000000000 +0200
@@ -336,7 +336,7 @@ SKIP=
 cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
 mkdir tar.tempdir && cd tar.tempdir || exit 1
-optional FEATURE_SEAMLESS_BZ2 FEATURE_TAR_AUTODETECT
+optional FEATURE_SEAMLESS_BZ2 FEATURE_TAR_AUTODETECT LS
 testing "Symlink attack: create symlink and then write through it" '\
 exec 2>&1
 uudecode -o input && tar xvf input; echo $?
@@ -365,4 +365,22 @@ n8fYaKlioCTzL2oXYczyUUIP4u5IpwoSEwWdtoA=
 SKIP=
 cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
+mkdir tar.tempdir && cd tar.tempdir || exit 1
+optional FEATURE_TAR_CREATE
+testing "Symlinks and hardlinks coexist" '\
+mkdir dir
+>dir/a
+ln -s ../dir/a dir/b
+ln dir/b dir/c
+mkdir new
+tar cf - dir/* | tar -C new -xvf - 2>&1
+' "\
+dir/a
+dir/b
+dir/c
+" \
+"" ""
+SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
+
 exit $FAILCOUNT
diff -urpN busybox-1.28.4/testsuite/unexpand/unexpand-works-like-GNU busybox-1.29.0/testsuite/unexpand/unexpand-works-like-GNU
--- busybox-1.28.4/testsuite/unexpand/unexpand-works-like-GNU	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/unexpand/unexpand-works-like-GNU	2018-07-02 15:55:14.000000000 +0200
@@ -1,3 +1,7 @@
+# coreutils 8.25 often says "input line is too long"
+# on ELF executables. In this case, do not run the test:
+unexpand ../../busybox >/dev/null || exit 0
+
 rm -f foo bar
 echo "       y" | unexpand ../../busybox > foo
 echo "       y" | busybox unexpand ../../busybox > bar
diff -urpN busybox-1.28.4/testsuite/unlzma.tests busybox-1.29.0/testsuite/unlzma.tests
--- busybox-1.28.4/testsuite/unlzma.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/testsuite/unlzma.tests	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+. ./testing.sh
+
+# testing "test name" "commands" "expected result" "file input" "stdin"
+#   file input will be file called "input"
+#   test can create a file "actual" instead of writing to stdout
+
+# Damaged encrypted streams
+testing "unlzma (bad archive 1)" \
+	"unlzma <unlzma_issue_1.lzma >/dev/null; echo \$?" \
+"1
+" "" ""
+
+# Damaged encrypted streams
+testing "unlzma (bad archive 2)" \
+	"unlzma <unlzma_issue_2.lzma >/dev/null; echo \$?" \
+"1
+" "" ""
+
+exit $FAILCOUNT
Binary files busybox-1.28.4/testsuite/unlzma_issue_1.lzma and busybox-1.29.0/testsuite/unlzma_issue_1.lzma differ
Binary files busybox-1.28.4/testsuite/unlzma_issue_2.lzma and busybox-1.29.0/testsuite/unlzma_issue_2.lzma differ
diff -urpN busybox-1.28.4/testsuite/unzip.tests busybox-1.29.0/testsuite/unzip.tests
--- busybox-1.28.4/testsuite/unzip.tests	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/unzip.tests	2018-07-02 15:55:14.000000000 +0200
@@ -14,7 +14,7 @@
 # Create a scratch directory
 
 mkdir temp
-cd temp
+cd temp || exit $?
 
 # Create test file to work with.
 
@@ -52,7 +52,31 @@ NzITNFBLBQUKAC4JAA04Cw0EOhZQSwUGAQAABAIA
 "
 SKIP=
 
-rm *
+rm -f *
+
+optional FEATURE_UNZIP_LZMA
+testing "unzip (archive with corrupted lzma 1)" "unzip -p ../unzip_bad_lzma_1.zip 2>&1; echo \$?" \
+"unzip: removing leading '/' from member names
+unzip: corrupted data
+unzip: inflate error
+1
+" \
+"" ""
+SKIP=
+
+rm -f *
+
+optional FEATURE_UNZIP_LZMA
+testing "unzip (archive with corrupted lzma 2)" "unzip -p ../unzip_bad_lzma_2.zip 2>&1; echo \$?" \
+"unzip: removing leading '/' from member names
+unzip: corrupted data
+unzip: inflate error
+1
+" \
+"" ""
+SKIP=
+
+rm -f *
 
 # Clean up scratch directory.
 
Binary files busybox-1.28.4/testsuite/unzip_bad_lzma_1.zip and busybox-1.29.0/testsuite/unzip_bad_lzma_1.zip differ
Binary files busybox-1.28.4/testsuite/unzip_bad_lzma_2.zip and busybox-1.29.0/testsuite/unzip_bad_lzma_2.zip differ
diff -urpN busybox-1.28.4/testsuite/xargs/xargs-works busybox-1.29.0/testsuite/xargs/xargs-works
--- busybox-1.28.4/testsuite/xargs/xargs-works	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/testsuite/xargs/xargs-works	2018-07-02 15:55:14.000000000 +0200
@@ -1,4 +1,6 @@
+# FEATURE: CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM
+
 [ -n "$d" ] || d=..
-find "$d" -name \*works -type f | xargs md5sum > logfile.gnu
-find "$d" -name \*works -type f | busybox xargs md5sum > logfile.bb
+find "$d" -name \*works -type f -print0 | xargs -0 md5sum > logfile.gnu
+find "$d" -name \*works -type f -print0 | busybox xargs -0 md5sum > logfile.bb
 diff -u logfile.gnu logfile.bb
diff -urpN busybox-1.28.4/util-linux/Config.src busybox-1.29.0/util-linux/Config.src
--- busybox-1.28.4/util-linux/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/util-linux/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 menu "Linux System Utilities"
diff -urpN busybox-1.28.4/util-linux/cal.c busybox-1.29.0/util-linux/cal.c
--- busybox-1.28.4/util-linux/cal.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/cal.c	2018-07-02 15:55:14.000000000 +0200
@@ -16,7 +16,8 @@
 //config:	help
 //config:	cal is used to display a monthly calendar.
 
-//applet:IF_CAL(APPLET(cal, BB_DIR_USR_BIN, BB_SUID_DROP))
+//applet:IF_CAL(APPLET_NOEXEC(cal, cal, BB_DIR_USR_BIN, BB_SUID_DROP, cal))
+/* NOEXEC despite rare cases when it can be a "runner" (e.g. cal -n12000 takes you into years 30xx) */
 
 //kbuild:lib-$(CONFIG_CAL) += cal.o
 
diff -urpN busybox-1.28.4/util-linux/chrt.c busybox-1.29.0/util-linux/chrt.c
--- busybox-1.28.4/util-linux/chrt.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/chrt.c	2018-07-02 15:55:14.000000000 +0200
@@ -9,7 +9,7 @@
 //config:	bool "chrt (4.4 kb)"
 //config:	default y
 //config:	help
-//config:	manipulate real-time attributes of a process.
+//config:	Manipulate real-time attributes of a process.
 //config:	This requires sched_{g,s}etparam support in your libc.
 
 //applet:IF_CHRT(APPLET_NOEXEC(chrt, chrt, BB_DIR_USR_BIN, BB_SUID_DROP, chrt))
@@ -17,13 +17,15 @@
 //kbuild:lib-$(CONFIG_CHRT) += chrt.o
 
 //usage:#define chrt_trivial_usage
-//usage:       "[-prfom] [PRIO] [PID | PROG ARGS]"
+//usage:       "[-prfombi] [PRIO] [PID | PROG ARGS]"
 //usage:#define chrt_full_usage "\n\n"
 //usage:       "Change scheduling priority and class for a process\n"
 //usage:     "\n	-p	Operate on PID"
 //usage:     "\n	-r	Set SCHED_RR class"
 //usage:     "\n	-f	Set SCHED_FIFO class"
 //usage:     "\n	-o	Set SCHED_OTHER class"
+//usage:     "\n	-b	Set SCHED_BATCH class"
+//usage:     "\n	-i	Set SCHED_IDLE class"
 //usage:     "\n	-m	Show min/max priorities"
 //usage:
 //usage:#define chrt_example_usage
@@ -33,20 +35,22 @@
 
 #include <sched.h>
 #include "libbb.h"
+#ifndef SCHED_IDLE
+# define SCHED_IDLE 5
+#endif
 
 static const struct {
-	int policy;
 	char name[sizeof("SCHED_OTHER")];
 } policies[] = {
-	{SCHED_OTHER, "SCHED_OTHER"},
-	{SCHED_FIFO, "SCHED_FIFO"},
-	{SCHED_RR, "SCHED_RR"}
+	{ "SCHED_OTHER" }, /* 0:SCHED_OTHER */
+	{ "SCHED_FIFO" },  /* 1:SCHED_FIFO */
+	{ "SCHED_RR" },    /* 2:SCHED_RR */
+	{ "SCHED_BATCH" }, /* 3:SCHED_BATCH */
+	{ "" },            /* 4:SCHED_ISO */
+	{ "SCHED_IDLE" },  /* 5:SCHED_IDLE */
+	/* 6:SCHED_DEADLINE */
 };
 
-//TODO: add
-// -b, SCHED_BATCH
-// -i, SCHED_IDLE
-
 static void show_min_max(int pol)
 {
 	const char *fmt = "%s min/max priority\t: %u/%u\n";
@@ -64,6 +68,8 @@ static void show_min_max(int pol)
 #define OPT_r (1<<2)
 #define OPT_f (1<<3)
 #define OPT_o (1<<4)
+#define OPT_b (1<<5)
+#define OPT_i (1<<6)
 
 int chrt_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int chrt_main(int argc UNUSED_PARAM, char **argv)
@@ -76,20 +82,30 @@ int chrt_main(int argc UNUSED_PARAM, cha
 	const char *current_new;
 	int policy = SCHED_RR;
 
-	/* only one policy accepted */
-	opt = getopt32(argv, "^+" "mprfo" "\0" "r--fo:f--ro:o--rf");
+	opt = getopt32(argv, "^"
+			"+" "mprfobi"
+			"\0"
+			/* only one policy accepted: */
+			"r--fobi:f--robi:o--rfbi:b--rfoi:i--rfob"
+	);
 	if (opt & OPT_m) { /* print min/max and exit */
+		show_min_max(SCHED_OTHER);
 		show_min_max(SCHED_FIFO);
 		show_min_max(SCHED_RR);
-		show_min_max(SCHED_OTHER);
+		show_min_max(SCHED_BATCH);
+		show_min_max(SCHED_IDLE);
 		fflush_stdout_and_exit(EXIT_SUCCESS);
 	}
-	if (opt & OPT_r)
-		policy = SCHED_RR;
+	//if (opt & OPT_r)
+	//	policy = SCHED_RR; - default, already set
 	if (opt & OPT_f)
 		policy = SCHED_FIFO;
 	if (opt & OPT_o)
 		policy = SCHED_OTHER;
+	if (opt & OPT_b)
+		policy = SCHED_BATCH;
+	if (opt & OPT_i)
+		policy = SCHED_IDLE;
 
 	argv += optind;
 	if (!argv[0])
@@ -131,12 +147,9 @@ int chrt_main(int argc UNUSED_PARAM, cha
 		current_new += 8;
 	}
 
-	/* from the manpage of sched_getscheduler:
-	[...] sched_priority can have a value in the range 0 to 99.
-	[...] SCHED_OTHER or SCHED_BATCH must be assigned static priority 0.
-	[...] SCHED_FIFO or SCHED_RR can have static priority in 1..99 range.
-	*/
-	sp.sched_priority = xstrtou_range(priority, 0, policy != SCHED_OTHER ? 1 : 0, 99);
+	sp.sched_priority = xstrtou_range(priority, 0,
+		sched_get_priority_min(policy), sched_get_priority_max(policy)
+	);
 
 	if (sched_setscheduler(pid, policy, &sp) < 0)
 		bb_perror_msg_and_die("can't %cet pid %d's policy", 's', (int)pid);
diff -urpN busybox-1.28.4/util-linux/fdisk.c busybox-1.29.0/util-linux/fdisk.c
--- busybox-1.28.4/util-linux/fdisk.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/util-linux/fdisk.c	2018-07-02 15:55:14.000000000 +0200
@@ -2004,12 +2004,6 @@ check_consistency(const struct partition
 		printf("     phys=(%u,%u,%u) ", pec, peh, pes);
 		printf("logical=(%u,%u,%u)\n", lec, leh, les);
 	}
-
-/* Ending on cylinder boundary? */
-	if (peh != (g_heads - 1) || pes != g_sectors) {
-		printf("Partition %u does not end on cylinder boundary\n",
-			partition + 1);
-	}
 }
 
 static void
diff -urpN busybox-1.28.4/util-linux/fdisk_gpt.c busybox-1.29.0/util-linux/fdisk_gpt.c
--- busybox-1.28.4/util-linux/fdisk_gpt.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/fdisk_gpt.c	2018-07-02 15:55:14.000000000 +0200
@@ -177,7 +177,7 @@ check_gpt_label(void)
 
 	init_unicode();
 	if (!global_crc32_table) {
-		global_crc32_table = crc32_filltable(NULL, 0);
+		global_crc32_new_table_le();
 	}
 
 	crc = SWAP_LE32(gpt_hdr->hdr_crc32);
diff -urpN busybox-1.28.4/util-linux/fdisk_sgi.c busybox-1.29.0/util-linux/fdisk_sgi.c
--- busybox-1.28.4/util-linux/fdisk_sgi.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/util-linux/fdisk_sgi.c	2018-07-02 15:55:14.000000000 +0200
@@ -425,7 +425,7 @@ create_sgiinfo(void)
 	/* I keep SGI's habit to write the sgilabel to the second block */
 	sgilabel->directory[0].vol_file_start = SGI_SSWAP32(2);
 	sgilabel->directory[0].vol_file_size = SGI_SSWAP32(sizeof(sgiinfo));
-	strncpy((char*)sgilabel->directory[0].vol_file_name, "sgilabel", 8);
+	memcpy((char*)sgilabel->directory[0].vol_file_name, "sgilabel", 8);
 }
 
 static sgiinfo *fill_sgiinfo(void);
diff -urpN busybox-1.28.4/util-linux/fstrim.c busybox-1.29.0/util-linux/fstrim.c
--- busybox-1.28.4/util-linux/fstrim.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/fstrim.c	2018-07-02 15:55:14.000000000 +0200
@@ -70,7 +70,9 @@ int fstrim_main(int argc UNUSED_PARAM, c
 		;
 #endif
 
-	opts = getopt32long(argv, "^" "o:l:m:v" "\0" "=1", fstrim_longopts,
+	opts = getopt32long(argv, "^"
+			"o:l:m:v"
+			"\0" "=1", fstrim_longopts,
 			&arg_o, &arg_l, &arg_m
 	);
 
@@ -85,15 +87,21 @@ int fstrim_main(int argc UNUSED_PARAM, c
 		range.minlen = xatoull_sfx(arg_m, kmg_i_suffixes);
 
 	mp = argv[optind];
-	if (find_block_device(mp)) {
+//Wwhy bother checking that it's a blockdev?
+//	if (find_block_device(mp)) {
 		fd = xopen_nonblocking(mp);
+
+		/* On ENOTTY error, util-linux 2.31 says:
+		 * "fstrim: FILE: the discard operation is not supported"
+		 */
 		xioctl(fd, FITRIM, &range);
+
 		if (ENABLE_FEATURE_CLEAN_UP)
 			close(fd);
 
 		if (opts & OPT_v)
 			printf("%s: %llu bytes trimmed\n", mp, (unsigned long long)range.len);
 		return EXIT_SUCCESS;
-	}
+//	}
 	return EXIT_FAILURE;
 }
diff -urpN busybox-1.28.4/util-linux/ipcs.c busybox-1.29.0/util-linux/ipcs.c
--- busybox-1.28.4/util-linux/ipcs.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/ipcs.c	2018-07-02 15:55:14.000000000 +0200
@@ -101,8 +101,6 @@ union semun {
 #define TIME 4
 #define PID 5
 
-static char format;
-
 static void print_perms(int id, struct ipc_perm *ipcp)
 {
 	struct passwd *pw;
@@ -125,8 +123,7 @@ static void print_perms(int id, struct i
 	else	printf(" %-10d\n", ipcp->gid);
 }
 
-
-static NOINLINE void do_shm(void)
+static NOINLINE void do_shm(int format)
 {
 	int maxid, shmid, id;
 	struct shmid_ds shmseg;
@@ -252,8 +249,7 @@ static NOINLINE void do_shm(void)
 	}
 }
 
-
-static NOINLINE void do_sem(void)
+static NOINLINE void do_sem(int format)
 {
 	int maxid, semid, id;
 	struct semid_ds semary;
@@ -358,8 +354,7 @@ static NOINLINE void do_sem(void)
 	}
 }
 
-
-static NOINLINE void do_msg(void)
+static NOINLINE void do_msg(int format)
 {
 	int maxid, msqid, id;
 	struct msqid_ds msgque;
@@ -466,7 +461,6 @@ static NOINLINE void do_msg(void)
 	}
 }
 
-
 static void print_shm(int shmid)
 {
 	struct shmid_ds shmds;
@@ -493,7 +487,6 @@ static void print_shm(int shmid)
 	printf("change_time=%-26.24s\n\n", ctime(&shmds.shm_ctime));
 }
 
-
 static void print_msg(int msqid)
 {
 	struct msqid_ds buf;
@@ -570,9 +563,9 @@ static void print_sem(int semid)
 }
 
 //usage:#define ipcs_trivial_usage
-//usage:       "[[-smq] -i shmid] | [[-asmq] [-tcplu]]"
+//usage:       "[[-smq] -i SHMID] | [[-asmq] [-tcplu]]"
 //usage:#define ipcs_full_usage "\n\n"
-//usage:       "	-i	Show specific resource"
+//usage:       "	-i ID	Show specific resource"
 //usage:     "\nResource specification:"
 //usage:     "\n	-m	Shared memory segments"
 //usage:     "\n	-q	Message queues"
@@ -588,60 +581,57 @@ static void print_sem(int semid)
 int ipcs_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int ipcs_main(int argc UNUSED_PARAM, char **argv)
 {
-	int id = 0;
-	unsigned flags = 0;
+	int format = 0;
 	unsigned opt;
 	char *opt_i;
-#define flag_print	(1<<0)
-#define flag_msg	(1<<1)
-#define flag_sem	(1<<2)
-#define flag_shm	(1<<3)
 
 	opt = getopt32(argv, "i:aqsmtcplu", &opt_i);
-	if (opt & 0x1) { // -i
-		id = xatoi(opt_i);
-		flags |= flag_print;
-	}
-	if (opt & 0x2) flags |= flag_msg | flag_sem | flag_shm; // -a
-	if (opt & 0x4) flags |= flag_msg; // -q
-	if (opt & 0x8) flags |= flag_sem; // -s
-	if (opt & 0x10) flags |= flag_shm; // -m
-	if (opt & 0x20) format = TIME; // -t
-	if (opt & 0x40) format = CREATOR; // -c
-	if (opt & 0x80) format = PID; // -p
-	if (opt & 0x100) format = LIMITS; // -l
-	if (opt & 0x200) format = STATUS; // -u
+#define flag_msg (1<<2)
+#define flag_sem (1<<3)
+#define flag_shm (1<<4)
+	if (opt & (1<<5)) format = TIME; // -t
+	if (opt & (1<<6)) format = CREATOR; // -c
+	if (opt & (1<<7)) format = PID; // -p
+	if (opt & (1<<8)) format = LIMITS; // -l
+	if (opt & (1<<9)) format = STATUS; // -u
+
+	if (opt & (1<<0)) { // -i
+		int id;
 
-	if (flags & flag_print) {
-		if (flags & flag_shm) {
+		id = xatoi(opt_i);
+		if (opt & flag_shm) {
 			print_shm(id);
 			fflush_stdout_and_exit(EXIT_SUCCESS);
 		}
-		if (flags & flag_sem) {
+		if (opt & flag_sem) {
 			print_sem(id);
 			fflush_stdout_and_exit(EXIT_SUCCESS);
 		}
-		if (flags & flag_msg) {
+		if (opt & flag_msg) {
 			print_msg(id);
 			fflush_stdout_and_exit(EXIT_SUCCESS);
 		}
 		bb_show_usage();
 	}
 
-	if (!(flags & (flag_shm | flag_msg | flag_sem)))
-		flags |= flag_msg | flag_shm | flag_sem;
+	if ((opt & (1<<1)) // -a
+	 || !(opt & (flag_msg | flag_sem | flag_shm)) // none of -q,-s,-m == all
+	) {
+		opt |= flag_msg | flag_sem | flag_shm;
+	}
+
 	bb_putchar('\n');
 
-	if (flags & flag_msg) {
-		do_msg();
+	if (opt & flag_msg) {
+		do_msg(format);
 		bb_putchar('\n');
 	}
-	if (flags & flag_shm) {
-		do_shm();
+	if (opt & flag_shm) {
+		do_shm(format);
 		bb_putchar('\n');
 	}
-	if (flags & flag_sem) {
-		do_sem();
+	if (opt & flag_sem) {
+		do_sem(format);
 		bb_putchar('\n');
 	}
 	fflush_stdout_and_exit(EXIT_SUCCESS);
diff -urpN busybox-1.28.4/util-linux/mkfs_ext2.c busybox-1.29.0/util-linux/mkfs_ext2.c
--- busybox-1.28.4/util-linux/mkfs_ext2.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/mkfs_ext2.c	2018-07-02 15:55:14.000000000 +0200
@@ -83,11 +83,11 @@ char BUG_wrong_field_size(void);
 #define STORE_LE(field, value) \
 do { \
 	if (sizeof(field) == 4) \
-		field = SWAP_LE32(value); \
+		field = SWAP_LE32((uint32_t)(value)); \
 	else if (sizeof(field) == 2) \
-		field = SWAP_LE16(value); \
+		field = SWAP_LE16((uint16_t)(value)); \
 	else if (sizeof(field) == 1) \
-		field = (value); \
+		field = (uint8_t)(value); \
 	else \
 		BUG_wrong_field_size(); \
 } while (0)
diff -urpN busybox-1.28.4/util-linux/mkfs_vfat.c busybox-1.29.0/util-linux/mkfs_vfat.c
--- busybox-1.28.4/util-linux/mkfs_vfat.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/mkfs_vfat.c	2018-07-02 15:55:14.000000000 +0200
@@ -210,11 +210,11 @@ void BUG_unsupported_field_size(void);
 #define STORE_LE(field, value) \
 do { \
 	if (sizeof(field) == 4) \
-		field = SWAP_LE32(value); \
+		field = SWAP_LE32((uint32_t)(value)); \
 	else if (sizeof(field) == 2) \
-		field = SWAP_LE16(value); \
+		field = SWAP_LE16((uint16_t)(value)); \
 	else if (sizeof(field) == 1) \
-		field = (value); \
+		field = (uint8_t)(value); \
 	else \
 		BUG_unsupported_field_size(); \
 } while (0)
@@ -522,7 +522,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM
 		//STORE_LE(boot_blk->reserved2[3], 0,0,0);
 		STORE_LE(boot_blk->vi.ext_boot_sign, 0x29);
 		STORE_LE(boot_blk->vi.volume_id32, volume_id);
-		strncpy(boot_blk->vi.fs_type, "FAT32   ", sizeof(boot_blk->vi.fs_type));
+		memcpy(boot_blk->vi.fs_type, "FAT32   ", sizeof(boot_blk->vi.fs_type));
 		strncpy(boot_blk->vi.volume_label, volume_label, sizeof(boot_blk->vi.volume_label));
 		memcpy(boot_blk->boot_code, boot_code, sizeof(boot_code));
 		STORE_LE(boot_blk->boot_sign, BOOT_SIGN);
diff -urpN busybox-1.28.4/util-linux/mount.c busybox-1.29.0/util-linux/mount.c
--- busybox-1.28.4/util-linux/mount.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/mount.c	2018-07-02 15:55:14.000000000 +0200
@@ -244,7 +244,11 @@
  * uclibc faq entry rather than in busybox... */
 # if defined(__UCLIBC__) && ! defined(__UCLIBC_HAS_RPC__)
 #  warning "You probably need to build uClibc with UCLIBC_HAS_RPC for NFS support"
-   /* not #error, since user may be using e.g. libtirpc instead */
+   /* not #error, since user may be using e.g. libtirpc instead.
+    * This might work:
+    * CONFIG_EXTRA_CFLAGS="-I/usr/include/tirpc"
+    * CONFIG_EXTRA_LDLIBS="tirpc"
+    */
 # endif
 # include <rpc/rpc.h>
 # include <rpc/pmap_prot.h>
diff -urpN busybox-1.28.4/util-linux/rdate.c busybox-1.29.0/util-linux/rdate.c
--- busybox-1.28.4/util-linux/rdate.c	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/util-linux/rdate.c	2018-07-02 15:55:14.000000000 +0200
@@ -45,7 +45,7 @@ static time_t askremotedate(const char *
 	alarm(10);
 	signal(SIGALRM, socket_timeout);
 
-	fd = create_and_connect_stream_or_die(host, bb_lookup_port("time", "tcp", 37));
+	fd = create_and_connect_stream_or_die(host, bb_lookup_std_port("time", "tcp", 37));
 
 	if (safe_read(fd, &nett, 4) != 4)    /* read time from server */
 		bb_error_msg_and_die("%s: %s", host, "short read");
diff -urpN busybox-1.28.4/util-linux/readprofile.c busybox-1.29.0/util-linux/readprofile.c
--- busybox-1.28.4/util-linux/readprofile.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/readprofile.c	2018-07-02 15:55:14.000000000 +0200
@@ -61,27 +61,22 @@
 
 #define S_LEN 128
 
-/* These are the defaults */
-static const char defaultmap[] ALIGN1 = "/boot/System.map";
-static const char defaultpro[] ALIGN1 = "/proc/profile";
-
 int readprofile_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int readprofile_main(int argc UNUSED_PARAM, char **argv)
 {
 	FILE *map;
 	const char *mapFile, *proFile;
-	unsigned long indx = 1;
+	unsigned long indx;
 	size_t len;
-	uint64_t add0 = 0;
+	uint64_t add0;
 	unsigned int step;
 	unsigned int *buf, total, fn_len;
 	unsigned long long fn_add, next_add;     /* current and next address */
 	char fn_name[S_LEN], next_name[S_LEN];   /* current and next name */
 	char mapline[S_LEN];
 	char mode[8];
-	int maplineno = 1;
-	int header_printed;
-	int multiplier = 0;
+	int maplineno;
+	int multiplier;
 	unsigned opt;
 	enum {
 		OPT_M = (1 << 0),
@@ -106,8 +101,9 @@ int readprofile_main(int argc UNUSED_PAR
 
 #define next (current^1)
 
-	proFile = defaultpro;
-	mapFile = defaultmap;
+	proFile = "/proc/profile";
+	mapFile = "/boot/System.map";
+	multiplier = 0;
 
 	opt = getopt32(argv, "M:+m:p:nabsirv", &multiplier, &mapFile, &proFile);
 
@@ -122,7 +118,7 @@ int readprofile_main(int argc UNUSED_PAR
 		if (!optMult)
 			to_write = 1;  /* sth different from sizeof(int) */
 
-		fd = xopen(defaultpro, O_WRONLY);
+		fd = xopen("/proc/profile", O_WRONLY);
 		xwrite(fd, &multiplier, to_write);
 		close(fd);
 		return EXIT_SUCCESS;
@@ -133,12 +129,13 @@ int readprofile_main(int argc UNUSED_PAR
 	 */
 	len = MAXINT(ssize_t);
 	buf = xmalloc_xopen_read_close(proFile, &len);
+	len /= sizeof(*buf);
+
 	if (!optNative) {
-		int entries = len / sizeof(*buf);
-		int big = 0, small = 0, i;
+		int big = 0, small = 0;
 		unsigned *p;
 
-		for (p = buf+1; p < buf+entries; p++) {
+		for (p = buf+1; p < buf+len; p++) {
 			if (*p & ~0U << (sizeof(*buf)*4))
 				big++;
 			if (*p & ((1 << (sizeof(*buf)*4))-1))
@@ -147,15 +144,15 @@ int readprofile_main(int argc UNUSED_PAR
 		if (big > small) {
 			bb_error_msg("assuming reversed byte order, "
 				"use -n to force native byte order");
-			for (p = buf; p < buf+entries; p++)
-				for (i = 0; i < sizeof(*buf)/2; i++) {
-					unsigned char *b = (unsigned char *) p;
-					unsigned char tmp;
-
-					tmp = b[i];
-					b[i] = b[sizeof(*buf)-i-1];
-					b[sizeof(*buf)-i-1] = tmp;
-				}
+			BUILD_BUG_ON(sizeof(*p) > 8);
+			for (p = buf; p < buf+len; p++) {
+				if (sizeof(*p) == 2)
+					*p = bswap_16(*p);
+				if (sizeof(*p) == 4)
+					*p = bswap_32(*p);
+				if (sizeof(*p) == 8)
+					*p = bb_bswap_64(*p);
+			}
 		}
 	}
 
@@ -165,10 +162,9 @@ int readprofile_main(int argc UNUSED_PAR
 		return EXIT_SUCCESS;
 	}
 
-	total = 0;
-
 	map = xfopen_for_read(mapFile);
-
+	add0 = 0;
+	maplineno = 1;
 	while (fgets(mapline, S_LEN, map)) {
 		if (sscanf(mapline, "%llx %s %s", &fn_add, mode, fn_name) != 3)
 			bb_error_msg_and_die("%s(%i): wrong map line",
@@ -187,8 +183,11 @@ int readprofile_main(int argc UNUSED_PAR
 	/*
 	 * Main loop.
 	 */
+	total = 0;
+	indx = 1;
 	while (fgets(mapline, S_LEN, map)) {
-		unsigned int this = 0;
+		bool header_printed;
+		unsigned int this;
 
 		if (sscanf(mapline, "%llx %s %s", &next_add, mode, next_name) != 3)
 			bb_error_msg_and_die("%s(%i): wrong map line",
@@ -198,17 +197,17 @@ int readprofile_main(int argc UNUSED_PAR
 
 		/* ignore any LEADING (before a '[tT]' symbol is found)
 		   Absolute symbols */
-		if ((*mode == 'A' || *mode == '?') && total == 0) continue;
-		if (*mode != 'T' && *mode != 't'
-		 && *mode != 'W' && *mode != 'w'
-		) {
+		if ((mode[0] == 'A' || mode[0] == '?') && total == 0)
+			continue;
+		if ((mode[0]|0x20) != 't' && (mode[0]|0x20) != 'w') {
 			break;  /* only text is profiled */
 		}
 
-		if (indx >= len / sizeof(*buf))
+		if (indx >= len)
 			bb_error_msg_and_die("profile address out of range. "
 					"Wrong map file?");
 
+		this = 0;
 		while (indx < (next_add-add0)/step) {
 			if (optBins && (buf[indx] || optAll)) {
 				if (!header_printed) {
@@ -256,7 +255,7 @@ int readprofile_main(int argc UNUSED_PAR
 	}
 
 	/* clock ticks, out of kernel text - probably modules */
-	printf("%6u %s\n", buf[len/sizeof(*buf)-1], "*unknown*");
+	printf("%6u *unknown*\n", buf[len-1]);
 
 	/* trailer */
 	if (optVerbose)
diff -urpN busybox-1.28.4/util-linux/renice.c busybox-1.29.0/util-linux/renice.c
--- busybox-1.28.4/util-linux/renice.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/renice.c	2018-07-02 15:55:14.000000000 +0200
@@ -6,7 +6,6 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-
 /* Notes:
  *   Setting an absolute priority was obsoleted in SUSv2 and removed
  *   in SUSv3.  However, the common linux version of renice does
@@ -40,11 +39,6 @@
 //usage:     "\n	-u	Process user names"
 
 #include "libbb.h"
-#include <sys/resource.h>
-
-void BUG_bad_PRIO_PROCESS(void);
-void BUG_bad_PRIO_PGRP(void);
-void BUG_bad_PRIO_USER(void);
 
 int renice_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int renice_main(int argc UNUSED_PARAM, char **argv)
@@ -59,12 +53,9 @@ int renice_main(int argc UNUSED_PARAM, c
 	char *arg;
 
 	/* Yes, they are not #defines in glibc 2.4! #if won't work */
-	if (PRIO_PROCESS < CHAR_MIN || PRIO_PROCESS > CHAR_MAX)
-		BUG_bad_PRIO_PROCESS();
-	if (PRIO_PGRP < CHAR_MIN || PRIO_PGRP > CHAR_MAX)
-		BUG_bad_PRIO_PGRP();
-	if (PRIO_USER < CHAR_MIN || PRIO_USER > CHAR_MAX)
-		BUG_bad_PRIO_USER();
+	BUILD_BUG_ON(PRIO_PROCESS < CHAR_MIN || PRIO_PROCESS > CHAR_MAX);
+	BUILD_BUG_ON(PRIO_PGRP < CHAR_MIN || PRIO_PGRP > CHAR_MAX);
+	BUILD_BUG_ON(PRIO_USER < CHAR_MIN || PRIO_USER > CHAR_MAX);
 
 	arg = *++argv;
 
@@ -102,6 +93,7 @@ int renice_main(int argc UNUSED_PARAM, c
 		/* Process an ID arg. */
 		if (which == PRIO_USER) {
 			struct passwd *p;
+			/* NB: use of getpwnam makes it risky to be NOFORK, switch to getpwnam_r? */
 			p = getpwnam(arg);
 			if (!p) {
 				bb_error_msg("unknown user %s", arg);
diff -urpN busybox-1.28.4/util-linux/switch_root.c busybox-1.29.0/util-linux/switch_root.c
--- busybox-1.28.4/util-linux/switch_root.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/switch_root.c	2018-07-02 15:55:14.000000000 +0200
@@ -39,6 +39,12 @@
 #include <sys/mount.h>
 #if ENABLE_RUN_INIT
 # include <sys/prctl.h>
+# ifndef PR_CAPBSET_READ
+# define PR_CAPBSET_READ 23
+# endif
+# ifndef PR_CAPBSET_DROP
+# define PR_CAPBSET_DROP 24
+# endif
 # include <linux/capability.h>
 // #include <sys/capability.h>
 // This header is in libcap, but the functions are in libc.
diff -urpN busybox-1.28.4/util-linux/umount.c busybox-1.29.0/util-linux/umount.c
--- busybox-1.28.4/util-linux/umount.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/umount.c	2018-07-02 15:55:14.000000000 +0200
@@ -57,6 +57,7 @@
 //usage:	IF_FEATURE_MOUNT_LOOP(
 //usage:     "\n	-d	Free loop device if it has been used"
 //usage:	)
+//usage:     "\n	-t FSTYPE[,...]	Unmount only these filesystem type(s)"
 //usage:
 //usage:#define umount_example_usage
 //usage:       "$ umount /dev/hdc1\n"
@@ -81,8 +82,8 @@ static struct mntent *getmntent_r(FILE*
 }
 #endif
 
-/* ignored: -c -v -t -i */
-#define OPTION_STRING           "fldnra" "cvt:i"
+/* ignored: -c -v -i */
+#define OPTION_STRING           "fldnrat:" "cvi"
 #define OPT_FORCE               (1 << 0) // Same as MNT_FORCE
 #define OPT_LAZY                (1 << 1) // Same as MNT_DETACH
 #define OPT_FREELOOP            (1 << 2)
@@ -143,7 +144,8 @@ int umount_main(int argc UNUSED_PARAM, c
 	}
 
 	// If we're not umounting all, we need at least one argument.
-	if (!(opt & OPT_ALL) && !fstype) {
+	// Note: "-t FSTYPE" does not imply -a.
+	if (!(opt & OPT_ALL)) {
 		if (!argv[0])
 			bb_show_usage();
 		m = NULL;
diff -urpN busybox-1.28.4/util-linux/volume_id/Config.src busybox-1.29.0/util-linux/volume_id/Config.src
--- busybox-1.28.4/util-linux/volume_id/Config.src	2018-03-26 01:59:01.000000000 +0200
+++ busybox-1.29.0/util-linux/volume_id/Config.src	2018-07-02 15:55:14.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
+# see docs/Kconfig-language.txt.
 #
 
 config VOLUMEID
diff -urpN busybox-1.28.4/util-linux/volume_id/lfs.c busybox-1.29.0/util-linux/volume_id/lfs.c
--- busybox-1.28.4/util-linux/volume_id/lfs.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.29.0/util-linux/volume_id/lfs.c	2018-07-02 15:55:14.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ * volume_id - reads filesystem label and uuid
+ *
+ * Copyright (C) 2018 Sven-Göran Bergh <sgb@systemaxion.se>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config FEATURE_VOLUMEID_LFS
+//config:	bool "LittleFS filesystem"
+//config:	default y
+//config:	depends on VOLUMEID && FEATURE_BLKID_TYPE
+//config:	help
+//config:	LittleFS is a small fail-safe filesystem designed for embedded
+//config:	systems. It has strong copy-on-write guarantees and storage on disk
+//config:	is always kept in a valid state. It also provides a form of dynamic
+//config:	wear levelling for systems that can not fit a full flash translation
+//config:	layer.
+
+//kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_LFS) += lfs.o
+
+#include "volume_id_internal.h"
+
+#define LFS_SB1_OFFSET		0x10
+#define LFS_MAGIC_NAME		"littlefs"
+#define LFS_MAGIC_LEN		8
+
+// The superblock is stored in the first metadata pair, i.e the first two blocks.
+struct lfs_super_block {	// A block in a metadata pair
+// /* 0x00 */	uint32_t	rev_count;		// Revision count
+// /* 0x04 */	uint32_t	dir_size;		// Directory size
+// /* 0x08 */	uint64_t	tail_ptr;		// Tail pointer
+/* 0x10 */	uint8_t		entry_type;		// Entry type
+/* 0x11 */	uint8_t		entry_len;		// Entry length
+/* 0x12 */	uint8_t		att_len;		// Attribute length
+/* 0x13 */	uint8_t 	name_len;		// Name length
+/* 0x14 */	uint64_t	root_dir;		// Root directory
+/* 0x1C */	uint32_t	block_size;		// Block size
+/* 0x20 */	uint32_t	block_count;		// Block count
+/* 0x24 */	uint16_t	ver_major;		// Version major
+/* 0x26 */	uint16_t	ver_minor;		// Version minor
+/* 0x28 */	uint8_t		magic[LFS_MAGIC_LEN];	// Magic string "littlefs"
+// /* 0x30 */	uint32_t	crc;			// CRC-32 checksum
+} PACKED;
+
+int FAST_FUNC volume_id_probe_lfs(struct volume_id *id /*,uint64_t off*/)
+{
+	struct lfs_super_block *sb;
+
+	// Go for primary super block (ignore second sb)
+	dbg("lfs: probing at offset 0x%x", LFS_SB1_OFFSET);
+	sb = volume_id_get_buffer(id, LFS_SB1_OFFSET, sizeof(*sb));
+
+	if (!sb)
+		return -1;
+
+	if (memcmp(sb->magic, LFS_MAGIC_NAME, LFS_MAGIC_LEN) != 0)
+		return -1;
+
+	IF_FEATURE_BLKID_TYPE(id->type = LFS_MAGIC_NAME);
+
+	return 0;
+}
diff -urpN busybox-1.28.4/util-linux/volume_id/volume_id.c busybox-1.29.0/util-linux/volume_id/volume_id.c
--- busybox-1.28.4/util-linux/volume_id/volume_id.c	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/volume_id/volume_id.c	2018-07-02 15:55:14.000000000 +0200
@@ -97,6 +97,9 @@ static const probe_fptr fs1[] = {
 #if ENABLE_FEATURE_VOLUMEID_EXFAT
 	volume_id_probe_exfat,
 #endif
+#if ENABLE_FEATURE_VOLUMEID_LFS
+	volume_id_probe_lfs,
+#endif
 #if ENABLE_FEATURE_VOLUMEID_MAC
 	volume_id_probe_mac_partition_map,
 #endif
diff -urpN busybox-1.28.4/util-linux/volume_id/volume_id_internal.h busybox-1.29.0/util-linux/volume_id/volume_id_internal.h
--- busybox-1.28.4/util-linux/volume_id/volume_id_internal.h	2018-04-01 13:03:43.000000000 +0200
+++ busybox-1.29.0/util-linux/volume_id/volume_id_internal.h	2018-07-02 15:55:14.000000000 +0200
@@ -187,6 +187,8 @@ int FAST_FUNC volume_id_probe_iso9660(st
 
 int FAST_FUNC volume_id_probe_jfs(struct volume_id *id /*,uint64_t off*/);
 
+int FAST_FUNC volume_id_probe_lfs(struct volume_id *id /*,uint64_t off*/);
+
 int FAST_FUNC volume_id_probe_linux_swap(struct volume_id *id /*,uint64_t off*/);
 
 int FAST_FUNC volume_id_probe_luks(struct volume_id *id /*,uint64_t off*/);
