diff -urpN asterisk-13.9.1/.version asterisk-13.17.0/.version
--- asterisk-13.9.1/.version	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/.version	2017-07-12 13:12:08.000000000 +0200
@@ -1 +1 @@
-13.9.1
\ No newline at end of file
+13.17.0
\ No newline at end of file
diff -urpN asterisk-13.9.1/CHANGES asterisk-13.17.0/CHANGES
--- asterisk-13.9.1/CHANGES	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/CHANGES	2017-07-12 13:12:08.000000000 +0200
@@ -9,9 +9,590 @@
 ==============================================================================
 
 ------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.16.0 to Asterisk 13.17.0 ----------
+------------------------------------------------------------------------------
+
+app_voicemail
+------------------
+ * A new global option "imap_poll_logout" was added to specify whether need to
+   disconnect from the IMAP server after polling of mailboxes.
+   Default: no
+
+res_pjsip
+------------------
+ * A new endpoint option "refer_blind_progress" was added to turn off notifying
+   the progress details on Blind Transfer. If this option is not set then
+   the chan_pjsip will send NOTIFY "200 OK" immediately after "202 Accepted".
+   On default is enabled.
+   Some SIP phones like Mitel/Aastra or Snom keep the line busy until
+   receive "200 OK".
+
+ * A new endpoint option "notify_early_inuse_ringing" was added to control
+   whether to notify dialog-info state 'early' or 'confirmed' on Ringing
+   when already INUSE.
+
+ * The endpoint option 'dtmf_mode' has a new option 'auto_dtmf' added. This
+   mode works similar to 'auto' except uses DTMF INFO as fallback instead of
+   INBAND.
+
+res_agi
+------------------
+ * The EAGI() application will now look for a dialplan variable named
+   EAGI_AUDIO_FORMAT and use that format with the 'enhanced' audio pipe that
+   EAGI provides. If not specified, it will continue to use the default signed
+   linear (slin).
+
+chan_pjsip
+------------------
+ * When dialing an endpoint directly or using the PJSIP_DIAL_CONTACTS dialplan
+   function any contact which is considered unreachable due to qualify being
+   enabled will no longer be called.
+
+ * The asymmetric_rtp_codec option now also controls whether chan_pjsip will
+   send media as-is without transcoding if the codec has been negotiated in the
+   SDP. If set to "no" then Asterisk will only ever send the preferred codec
+   from the SDP, unless the remote side sends a different codec and we will
+   switch to match.
+
+Build System
+------------------
+ * Added a new PJPROJECT_CONFIGURE_OPTS environment variable which can be used
+   to pass arbitrary options to the bundled pjproject configure.
+
+ * Automatically set the bundled pjproject configure --host and --build
+   options to match those supplied for the asterisk configure.
+
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.15.0 to Asterisk 13.16.0 ----------
+------------------------------------------------------------------------------
+
+res_rtp_asterisk
+------------------
+ * Added the stun_blacklist option to rtp.conf.  Some multihomed servers have
+   IP interfaces that cannot reach the STUN server specified by stunaddr.
+   Blacklist those interface subnets from trying to send a STUN packet to find
+   the external IP address.  Attempting to send the STUN packet needlessly
+   delays processing incoming and outgoing SIP INVITEs because we will wait
+   for a response that can never come until we give up on the response.
+   Multiple subnets may be listed.
+
+Logging
+-------------------
+ * Added logger_queue_limit to the configuration options.
+   All log messages go to a queue serviced by a single thread
+   which does all the IO.  This setting controls how big that
+   queue can get (and therefore how much memory is allocated)
+   before new messages are discarded.
+   The default is 1000.
+
+res_pjsip_config_wizard
+------------------
+ * Two new parameters have been added to the pjsip config wizard.
+   Setting 'sends_line_with_registrations' to true will cause the wizard
+   to skip the creation of an identify object to match incoming requests
+   to the endpoint and instead add the line and endpoint parameters to
+   the outbound registration object.
+   Setting 'outbound_proxy' is a shortcut for adding individual
+   endpoint/outbound_proxy, aor/outbound_proxy and registration/outbound_proxy
+   parameters.
+
+res_hep_rtcp
+------------------
+ * If the 'call-id' value is specified for the uuid_type option and a
+   chan_sip channel is used the resulting HEP traffic will now contain the
+   SIP Call-ID instead of the Asterisk channel name.
+
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.14.0 to Asterisk 13.15.0 ----------
+------------------------------------------------------------------------------
+
+AMI
+------------------
+ * The 'PJSIPShowEndpoint' command's respone event of 'IdentifyDetail' now
+   contains a new optional parameter, 'MatchHeader', mapping to the new
+   configuration option 'match_header' for the corresponding 'identify' object.
+   It should be noted that since 'match_header' takes in a key: value pair, the
+   event parameter will contain a ':' as well.
+
+app_record
+------------------
+ * Added new 'u' option to Record() application which prevents Asterisk from
+   truncating silence from the end of recorded files.
+
+res_pjsip_outbound_registration
+------------------
+ * Outbound registrations are now refreshed when res_stun_monitor detects
+   a network change event has happened.
+   The 'pjsip send (un)register' CLI commands were updated to accept '*all'
+   as an argument to operate on all registrations.
+   The 'PJSIP(Un)Register' AMI commands were updated to also accept '*all'.
+
+app_voicemail
+------------------
+ * The 'Comedian Mail' prompts can now be overriden using the 'vm-login' and
+   'vm-newuser' configuration options in voicemail.conf.
+
+ * Added 'fromstring' field to the voicemail boxes. If set, it will override
+   the global 'fromstring' field on a per-mailbox basis.
+
+func_channel
+------------------
+ * Added CHANNEL(callid) to retrieve the call log tag associated with the
+   channel.  e.g., [C-00000000]  Dialplan now has access to the call log
+   search key associated with the channel so it can be saved in case there
+   is a problem with the call.
+
+res_pjsip
+------------------
+ * A new transport parameter 'symmetric_transport' has been added.
+   When a request from a dynamic contact comes in on a transport with this
+   option set to 'yes', the transport name will be saved and used for
+   subsequent outgoing requests like OPTIONS, NOTIFY and INVITE.  It's
+   saved as a contact uri parameter named 'x-ast-txp' and will display with
+   the contact uri in CLI, AMI, and ARI output.  On the outgoing request,
+   if a transport wasn't explicitly set on the endpoint AND the request URI
+   is not a hostname, the saved transport will be used and the 'x-ast-txp'
+   parameter stripped from the outgoing packet.  To facilitate recreation of
+   subscriptions on asterisk restart, a new column 'contact_uri' needed to be
+   added to the ps_subcsription_persistence table.  Since new columns were
+   added to both transport and subscription_persistence, an alembic upgrade
+   should be run to bring the database tables up to date.
+
+ * A new option, allow_overlap, has been added to endpoints which allows
+   overlap dialing functionality to be enabled or disabled. The option defaults
+   to enabled.
+
+res_pjsip_transport_websocket
+------------------
+ * Removed non-secure websocket support.  Firefox and Chrome have not allowed
+   non-secure websockets for quite some time so this shouldn't be an issue
+   for people.  Attempting to use a non-secure websocket may or may not work
+   when Asterisk attempts to send SIP requests to do something like initiate
+   call hangup.
+
+res_pjsip_endpoint_identifier_ip
+------------------
+ * A new option has been added to the 'identify' configuration object,
+   'match_header'. The 'match_header' attribute should contain a SIP
+   header: value pair that, When set, will cause inbound requests that contain
+   the matching SIP header/value pair to be associated with the corresponding
+   endpoint. This option is cumulative with the 'match' option, so that if
+   either option matches the request, the request is associated with the
+   endpoint.
+
+   In a future release, this module will be renamed to something more
+   appropriate, as it now matches inbound requests on more than just IP
+   address.
+
+res_rtp_asterisk
+-----------------
+ * The RTP layer of Asterisk now has support for RFC 5761: "Multiplexing RTP
+   Data and Control Packets on a Single Port." So far, the only channel driver
+   that supports this feature is chan_pjsip. You can set "rtcp_mux = yes" on
+   a PJSIP endpoint in pjsip.conf to enable the feature.
+
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.13.0 to Asterisk 13.14.0 ----------
+------------------------------------------------------------------------------
+
+res_pjproject
+------------------
+ * Added new CLI command "pjproject set log level".  The new command allows
+   the maximum PJPROJECT log levels to be adjusted dynamically and
+   independently from the set debug logging level like many other similar
+   module debug logging commands.
+
+ * Added new companion CLI command "pjproject show log level" to allow the
+   user to see the current maximum pjproject logging level.
+
+ * Added new pjproject.conf startup section "log_level' option to set the
+   initial maximum PJPROJECT logging level.
+
+res_pjsip_outbound_registration
+------------------
+ * Statsd no longer logs redundant status PJSIP.registrations.state changes
+   for internal state transitions that don't change the reported public status
+   state.
+
+res_pjsip_registrar
+------------------
+ * The PJSIPShowRegistrationInboundContactStatuses AMI command has been added
+   to return ContactStatusDetail events as opposed to
+   PJSIPShowRegistrationsInbound which just a dumps every defined AOR.
+
+res_pjsip
+------------------
+ * Six existing contact fields have been added to the end of the
+   ContactStatusDetail AMI event:
+   ID, AuthenticateQualify, OutboundProxy, Path, QualifyFrequency and
+   QualifyTimeout.  Existing fields have not been disturbed.
+
+res_pjsip_endpoint_identifier_ip
+------------------
+ * SRV lookups can now be done on provided hostnames to determine additional
+   source IP addresses for requests. This is configurable using the
+   "srv_lookups" option on the identify and defaults to "yes".
+
+ARI
+------------------
+ * The 'ari set debug' command has been enhanced to accept 'all' as an
+   application name.  This allows dumping of all apps even if an app
+   hasn't registered yet.
+
+ * 'ari set debug' now displays requests and responses as well as events.
+ 
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.12.0 to Asterisk 13.13.0 ----------
+------------------------------------------------------------------------------
+
+AMI
+------------------
+ * Events that reference a bridge may now contain two new optional fields:
+   - 'BridgeVideoSourceMode': the video source mode for the bridge.
+     Can be one of 'none', 'talker', or 'single'.
+   - 'BridgeVideoSource': the unique ID of the channel that is the video
+     source in this bridge, if one exists.
+
+ * A new event, BridgeVideoSourceUpdate, has been added with a class
+   authorization of CALL. The event is raised when the video source changes
+   in a multi-party mixing bridge.
+
+ARI
+------------------
+ * The bridges resource now exposes two new operations:
+   - POST /bridges/{bridgeId}/videoSource/{channelId}: Set a video source in a
+     multi-party mixing bridge
+   - DELETE /bridges/{bridgeId}/videoSource: Remove the set video source,
+     reverting to talk detection for the video source
+
+ * The bridge model in any returned response or event now contains the following
+   optional fields:
+   - video_mode: the video source mode for the bridge. Can be one of 'none',
+     'talker', or 'single'.
+   - video_source_id: the unique ID of the channel that is the video source
+     in this bridge, if one exists.
+
+ * A new event, BridgeVideoSourceChanged, has been added for bridges.
+   Applications subscribed to a bridge will receive this event when the source
+   of video changes in a mixing bridge.
+
+res_pjsip
+------------------
+ * Automatic dual stack support is now implemented. Depending on DNS resolution
+   and the transport used for sending a message the SIP signaling and SDP will
+   be updated with the correct IP address and protocol version. This means that
+   the rtp_ipv6 and t38_udptl_ipv6 options no longer have any effect. The
+   res_pjsip_multihomed module has also been moved into core res_pjsip to ensure
+   that messages are updated with the correct address information in all cases.
+
+chan_pjsip
+------------------
+ * The default behavior for RTP codecs has been changed. The sending codec will
+   now match the receiving codec. This can be turned off and behavior reverted
+   to asymmetric using the "asymmetric_rtp_codec" endpoint option. If this
+   option is set then the sending and received codec are allowed to differ.
+
+CLI Commands
+------------------
+ * Three new CLI commands have been added for ARI:
+   - ari show apps:
+      Displays a listing of all registered ARI applications.
+   - ari show app <name>:
+      Display detailed information about a registered ARI application.
+   - ari set debug <name> <on|off>:
+      Enable/disable debugging of an ARI application. When debugged, verbose
+      information will be sent to the Asterisk CLI.
+
+RTP
+------------------
+ * New setting "rtp_pt_dynamic = 96" in asterisk.conf:
+   Normally the Dynamic RTP Payload Type numbers are 96-127, which allow 32
+   formats. When you use more and receive the message "No Dynamic RTP mapping
+   available", extend the dynamic range by going for rtp_pt_dynamic = 35 (or 0)
+   instead of 96. This allows 29 (or 64) additional formats. On default this is
+   disabled and the range is 96-127 because any number below might be rejected
+   by a remote implementation; although no such broken implementation is known.
+
+Queue
+------------------
+ * A new dialplan variable, ABANDONED, is set when the call is not answered
+   by an agent.
+
+Core
+------------------
+ * The TLS core in Asterisk now supports X.509 certificate subject alternative
+   names. This way one X.509 certificate can be used for hosts that can be
+   reached under multiple DNS names or for multiple hosts.
+
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.11.0 to Asterisk 13.12.0 ----------
+------------------------------------------------------------------------------
+
+Build System
+------------------
+ * The res_digium_phone, codec_g729a, codec_silk, codec_siren7 and
+   codec_siren14 binary modules hosted at downloads.digium.com can now be
+   automatically downloaded and installed during the Asterisk install
+   process.  If selected in menuselect, when 'make install' is run, the
+   script will check the downloads site for a new version and download
+   and install it if needed.  The '--with-externals-cache' option to
+   ./configure can be used to specify a location to cache the latest
+   tarballs so they don't have to be re-downloaded for every install.
+
+app_voicemail
+------------------
+ * Added "tps_queue_high" and "tps_queue_low" options.
+   The options can modify the taskprocessor alert levels for this module.
+   Additional information can be found in the sample configuration file at
+   config/samples/voicemail.conf.sample.
+
+res_pjsip_mwi
+------------------
+ * Added "mwi_tps_queue_high" and "mwi_tps_queue_low" global configuration
+   options to tune taskprocessor alert levels.
+
+ * Added "mwi_disable_initial_unsolicited" global configuration option
+   to disable sending unsolicited MWI to all endpoints on startup.
+   Additional information can be found in the sample configuration file at
+   config/samples/pjsip.conf.sample.
+
+chan_pjsip
+------------------
+ * A new dialplan function, PJSIP_SEND_SESSION_REFRESH, has been added. When
+   invoked, a re-INVITE or UPDATE request will be sent immediately to the
+   endpoint underlying the channel. When used in combination with the existing
+   dialplan function PJSIP_MEDIA_OFFER, this allows the formats on a PJSIP
+   channel to be re-negotiated and updated after session set up.
+
+res_pjsip
+------------------
+ * A new endpoint configuration parameter 'contact_user' has been added which
+   when set will override the default user set on Contact headers in outgoing
+   requests.
+
+ * If you are using a sorcery realtime backend to store global res_pjsip
+   options (ps_globals table) then you now have to do a res_pjsip reload for
+   changes to these options to take effect.  If you are using pjsip.conf to
+   configure these options then you already had to do a reload after making
+   changes.
+
+ * Added "ignore_uri_user_options" global configuration option for
+   compatibility with an ITSP that sends URI user field options.  When enabled
+   the user field is truncated at the first semicolon.
+   Example:
+   URI: "sip:1235557890;phone-context=national@x.x.x.x;user=phone"
+   The user field is "1235557890;phone-context=national"
+   Which is truncated to this: "1235557890"
+
+   Note: The caller-id and redirecting number strings obtained from incoming
+   SIP URI user fields are now always truncated at the first semicolon.
+
+res_rtp_asterisk
+------------------
+  * An option, ice_blacklist, has been added which allows certain subnets to be
+    excluded from local ICE candidates.
+
+app_confbridge
+------------------
+  * Some sounds played into the bridge are played asynchronously. This, for
+    instance, allows a channel to immediately exit the ConfBridge without having
+    to wait for a leave announcement to play.
+
+Core
+------------------
+  * If Asterisk is built with systemd support, and run under systemd, it will
+    notify systemd of its state using sd_notify. Use 'Type=notify' in
+    asterisk.service.
+
+app_dial
+------------------
+ * Added the "Q" option which sets the Q.850/Q.931 cause on unanswered channels
+   when another channel answers the call.  The default of ANSWERED_ELSEWHERE
+   is unchanged.
+
+res_ari
+------------------
+ * ARI events will all now include a new field in the root of the JSON message,
+   'asterisk_id'.  This will be the unique ID for the Asterisk system
+   transmitting the event.  The value can be overridden using the 'entityid'
+   setting in asterisk.conf.
+
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.10.0 to Asterisk 13.11.0 ----------
+------------------------------------------------------------------------------
+
+chan_dahdi
+------------------
+ * Added "faxdetect_timeout" option.
+   The option determines how many seconds into a call before faxdetect
+   is disabled for the call.  Setting the value to zero disables the timeout.
+
+chan_sip
+------------------
+ * Session-Timers (RFC 4028) work for TCP (and TLS) transports as well now.
+   Previously Asterisk dropped calls only with UDP transports. However with
+   longer international calls via TCP, the SIP channel might break, because
+   all hops on the Internet route must stay online (have not a single power
+   outage, for example). Therefore with Session-Timers enabled (which are
+   enabled at default), you might see additional dropped calls. Consequently
+   please, consider to go for session-timers=refuse in your sip.conf.
+
+res_pjsip
+------------------
+ * Added "fax_detect_timeout" to endpoint.
+   The option determines how many seconds into a call before fax_detect
+   is disabled for the call.  Setting the value to zero disables the timeout.
+
+ * Added "subscribe_context" to endpoint.
+   If specified, incoming SUBSCRIBE requests will be searched for the matching
+   extension in the indicated context. If no "subscribe_context" is specified,
+   then the "context" setting is used.
+
+res_rtp_asterisk
+------------------
+ * The DTLS part in Asterisk now supports Perfect Forward Secrecy (PFS).
+   Enabling PFS is attempted by default, and is dependent on the configuration
+   of the module using TLS.
+   - Ephemeral ECDH (ECDHE) is enabled by default. To disable it, do not
+     specify a ECDHE cipher suite in sip.conf, for example:
+       dtlscipher=AES128-SHA
+   - Ephemeral DH (DHE) is disabled by default. To enable it, add DH parameters
+     into the private key file, e.g., sip.conf dtlsprivatekey. For example:
+       openssl dhparam -out ./dh.pem 2048
+   - Because clients expect the server to prefer PFS, and because OpenSSL sorts
+     its cipher suites by bit strength, see "openssl ciphers -v DEFAULT".
+     Consider re-ordering your cipher suites in the respective configuration
+     file. For example:
+       dtlscipher=ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256
+     which forces PFS and requires at least DTLS 1.2.
+
+------------------------------------------------------------------------------
+--- Functionality changes from Asterisk 13.9.0 to Asterisk 13.10.0 -----------
+------------------------------------------------------------------------------
+
+Core
+------------------
+ * A channel variable FORWARDERNAME is now set which indicates which channel
+   was responsible for a forwarding requests received on dial attempt.
+
+chan_multicast_rtp
+------------------
+ * Deprecated in favor of chan_rtp which is basically chan_multicast_rtp
+   renamed to chan_rtp with UnicastRTP channels added and some internal code
+   improvements.
+
+chan_rtp
+------------------
+ * The format for dialing a unicast RTP channel is:
+   UnicastRTP/<destination-addr>[/[<options>]]
+   Where <destination-addr> is something like '127.0.0.1:5060'.
+   Where <options> are in standard Asterisk flag options format:
+   c(<codec>) - Specify which codec/format to use such as 'ulaw'.
+   e(<engine>) - Specify which RTP engine to use such as 'asterisk'.
+
+ * More options are available over what chan_multicast_rtp supports.
+   The format for dialing a multicast RTP channel is:
+   MulticastRTP/<type>/<destination-addr>[/[<control-addr>][/[<options>]]]
+   Where <type> can be either 'basic' or 'linksys'.
+   Where <destination-addr> is something like '224.0.0.3:5060'.
+   Where <control-addr> is something like '127.0.0.1:5060'.
+   Where <options> are in standard Asterisk flag options format:
+   c(<codec>) - Specify which codec/format to use such as 'ulaw'.
+   i(<address>) - Specify the interface address from which multicast RTP
+     is sent.
+   l(<enable>) - Set whether packets are looped back to the sender.  The
+     enable value can be 0 to set looping to off and non-zero to set
+     looping on.
+   t(<ttl>) - Set the time-to-live (TTL) value for multicast packets.
+
+func_odbc
+------------------
+ * Added new global option "single_db_connection".
+   Enabling this option func_odbc will use a single database connection per DSN.
+   This option is enabled by default.
+
+res_fax
+------------------
+ * Added FAXMODE variable to let dialplan know what fax transport was used.
+   FAXMODE variable is set to either "audio" or "T38".
+
+res_pjsip
+------------------
+ * Added "via_addr", "via_port", "call_id" to contacts.
+   As res_pjsip_nat rewrites contact's address, only the last Via header
+   can contain the source address of registered endpoint.
+   Also Call-Id header may contain the source address of registered endpoint.
+   Added new fields ViaAddress,CallID to AMI event ContactStatus
+
+ * Endpoint IP Access Controls
+   Added new configuration Endpoint options:
+    "acl" - list of IP ACL section names in acl.conf
+    "deny" - List of IP addresses to deny access from
+    "permit" - List of IP addresses to permit access from
+    "contact_acl" - List of Contact ACL section names in acl.conf
+    "contact_deny" - List of Contact header addresses to deny
+    "contact_permit" - List of Contact header addresses to permit
+
+ * Added "reg_server" to contacts.
+   If the Asterisk system name is set in asterisk.conf, it will be stored
+   into the "reg_server" field in the ps_contacts table to facilitate
+   multi-server setups.
+
+ * When starting Asterisk, received traffic will now be ignored until Asterisk
+   has loaded all modules and is fully booted.
+
+res_hep
+------------------
+ * Added a new option, 'uuid_type', that sets the preferred source of the Homer
+   correlation UUID. The valid options are:
+   - call-id: Use the PJSIP SIP Call-ID header value
+   - channel: Use the Asterisk channel name
+   The default value is 'call-id'. In the event that a HEP module cannot find a
+   valid value using the specified 'uuid_type', the module may fallback to a
+   more readily available source for the correlation UUID.
+
+res_pjsip_info_empty
+--------------------
+ * A new module that can respond to empty Content-Type INFO packets during call.
+   Some SBCs will terminate a call if their empty INFO packets are not responded
+   to within a predefined time.
+
+res_odbc
+------------------
+ * A new option has been added, 'max_connections', which sets the maximum number
+   of concurrent connections to the database. This option defaults to 1 which
+   returns the behavior to that of Asterisk 13.7 and prior.
+
+app_confbridge
+------------------
+ * Added a bridge profile option called regcontext that allows you to
+   dynamically register the conference bridge name as an extension into
+   the specified context.  This allows tracking down conferences on multi-
+   server installations via alternate means (DUNDI for example). By default
+   this feature is not used.
+
+Codecs
+------------------
+ * Added the associated format name to 'core show codecs'.
+
+res_ari_channels
+------------------
+ * Added 'formats' to channel create/originate to allow setting the allowed
+   formats for a channel when no originator channel is available.  Especially
+   useful for Local channel creation where no other format information is
+   available.  'core show codecs' can now be used to look up suitable format
+   names.
+
+------------------------------------------------------------------------------
 --- Functionality changes from Asterisk 13.8.0 to Asterisk 13.9.0 ------------
 ------------------------------------------------------------------------------
 
+res_pjsip
+------------------
+ * Added new global option (disable_multi_domain) to pjsip.
+   Disabling Multi Domain can improve realtime performace by reducing
+   number of database requsts.
+
 chan_pjsip
 ------------------
  * Added 'pjsip show channelstats' CLI command.
@@ -124,6 +705,20 @@ res_pjsip
    dynamically create and destroy a NoOp priority 1 extension
    for a given endpoint who registers or unregisters with us.
 
+ * Endpoints and aors can now be identified by the username and realm in an
+   incoming Authorization header.  To use this feature, add "auth_username"
+   to your endpoint's "identify_by" list.  You can combine "auth_username"
+   and the original "username" to test both the From/To and Authorization
+   headers.  For endpoints, the order is controlled by the global
+   "endpoint_identifier_order" setting.  For matching aors to an endpoint
+   for inbound registration, the order is controlled by this option.
+
+ * In conjunction with the "auth_username" change, 3 new options have been
+   added to the global configuration object that control how many unidentified
+   requests over a certain period from the same IP address can be received
+   before a security altert is generated.  A new CLI command
+   "pjsip show unidentified_requests" will list the current candidates.
+
 res_pjsip_history
 ------------------
  * A new module, res_pjsip_history, has been added that provides SIP history
diff -urpN asterisk-13.9.1/ChangeLog asterisk-13.17.0/ChangeLog
--- asterisk-13.9.1/ChangeLog	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/ChangeLog	2017-07-12 13:12:08.000000000 +0200
@@ -1,24 +1,12224 @@
-2016-05-13 17:41 +0000  Asterisk Development Team <asteriskteam@digium.com>
+2017-07-12 11:12 +0000  Asterisk Development Team <asteriskteam@digium.com>
 
-	* asterisk 13.9.1 Released.
+	* asterisk 13.17.0 Released.
 
-2016-05-13 12:41 +0000 [1cff642773]  Kevin Harwell <kharwell@digium.com>
+2017-07-06 11:52 +0000  Asterisk Development Team <asteriskteam@digium.com>
 
-	* Release summaries: Remove previous versions
+	* asterisk 13.17.0-rc1 Released.
 
-2016-05-13 12:41 +0000 [03be442bf0]  Kevin Harwell <kharwell@digium.com>
+2017-07-06 05:55 +0000 [379fe65831]  George Joseph <gjoseph@digium.com>
 
-	* .version: Update for 13.9.1
+	* Fix alembic branches
 
-2016-05-13 12:41 +0000 [ee94d92141]  Kevin Harwell <kharwell@digium.com>
+	  Change-Id: I04f607f084bda9b1b7f626e8e9735c37dc751187
 
-	* .lastclean: Update for 13.9.1
+2017-07-05 07:42 +0000 [6258de458b]  Sean Bright <sean.bright@gmail.com>
 
-2016-05-13 12:41 +0000 [05da780cc7]  Kevin Harwell <kharwell@digium.com>
+	* core: Fix segfault when invoking 'data get' CLI command
 
-	* realtime: Add database scripts for 13.9.1
+	  Invoking 'data get /asterisk/core/channeltypes' caused a crash because
+	  of an assumption of a tech's capabilities to be non-NULL. The
+	  'Surrogate' tech, however, does have a NULL capabilities member,
+	  resulting in a crash.
 
-2016-05-12 14:36 +0000 [15c427c64d]  Mark Michelson <mmichelson@digium.com>
+	  ASTERISK-27108 #close
+
+	  Change-Id: I2fbe7715681f43d5565d1e1599269468c26b0e0a
+
+2017-07-03 10:59 +0000 [39d2ebbf56]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Only when different, add TCP|TLS in autodomain (SIP Domain Support).
+
+	  When sip.conf contained tcpenable=yes and autodomain=yes, the TCP domain was
+	  added in any case, because of a local Boolean-negation error of the return value
+	  of ast_sockaddr_cmp. After fixing this error for TCP and TLS, the TLS domain was
+	  still always added with tlsenable=yes, because the domains were not compared
+	  just on the address but also on the port – and TLS is always on a different port
+	  than UDP/TCP.
+
+	  ASTERISK-27106
+
+	  Change-Id: I14fe9e319e238320b094016980445ef3a5b3337c
+
+2017-07-03 10:38 +0000 [9f4b3b966e]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Fix a typo for tlsbindaddr in autodomain (SIP Domain Support).
+
+	  Because of a copy-and-paste error when the struct ast_sockaddr changed,
+	  tlsbindaddr was not added, when sip.conf contained autodomain=yes; see
+	  "show sip domains" on the command-line interface (CLI) of Asterisk.
+
+	  ASTERISK-27106
+
+	  Change-Id: I3d0957150017c223136968ef1266f275d0d6695e
+
+2017-06-30 23:57 +0000 [73520e9f58]  Corey Farrell <git@cfware.com>
+
+	* channel: Clear channel flag in error branch.
+
+	  Clear channel flag AST_FLAG_END_DTMF_ONLY in ast_waitfordigit_full when
+	  ast_read returns NULL.
+
+	  ASTERISK-27100 #close
+
+	  Change-Id: Id3039e9a4e74e0cb359f636c9fd0c9740ebf7d9d
+
+2017-06-29 18:27 +0000 [0d64cbde57]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Fix deadlock with TCP type transports.
+
+	  When a SIP message comes in on a transport, pjproject obtains the lock on
+	  the transport and pulls the data out of the socket.  Unlike UDP, the TCP
+	  transport does not allow concurrent access.  Without concurrency the
+	  transport lock is not released when the transport's message complete
+	  callback is called.  The processing continues and eventually Asterisk
+	  starts processing the SIP message.  The first thing Asterisk tries to do
+	  is determine the associated dialog of the message to determine the
+	  associated serializer.  To get the associated serializer safely requires
+	  us to get the dialog lock.
+
+	  To send a request or response message for a dialog, pjproject obtains the
+	  dialog lock and then obtains the transport lock.  Deadlock can result
+	  because of the opposite order the locks are obtained.
+
+	  * Fix the deadlock by obtaining the serializer associated with the dialog
+	  another way that doesn't involve obtaining the dialog lock.  In this case,
+	  we use an ao2 container to hold the associated endpoint and serializer.
+	  The new locks are held a brief time and won't overlap other existing lock
+	  times.
+
+	  ASTERISK-27090 #close
+
+	  Change-Id: I9ed63f4da9649e9db6ed4be29c360968917a89bd
+
+2017-06-29 18:22 +0000 [905d18e8bf]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Fix unidentified_requests hash functions.
+
+	  The OBJ_SEARCH_xxx defines should not be used as if they were individual
+	  bits.  They represent a multi-bit enumeration value field.
+
+	  Change-Id: I32abc9a475396dab02402a7014357dd94284e17b
+
+2017-06-30 08:31 +0000 [bbe68f139d]  George Joseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Allow passing configure options to bundled
+
+	  There wasn't any good way to pass options like --host or --build
+	  down to the pjproject configure which makes cross-compiling difficult.
+
+	  * Added a new PJPROJECT_CONFIGURE_OPTS environment variable which
+	    can be used to pass arbitrary options to pjproject configure.
+	  * Automatically set the pjproject configure --host and --build
+	    options to match those supplied for the asterisk configure.
+
+	  ASTERISK-27097 #close
+	  Reported-by: Kinsey Moore
+
+	  Change-Id: I5fa776e110262851173002a26ffe1172e4c35b2e
+
+2017-06-29 14:50 +0000 [6bd7c0f37c]  George Joseph <gjoseph@digium.com>
+
+	* chan_pjsip:  Fix ability to send UPDATE on COLP
+
+	  When connected_line_method is "invite", we're supposed to determine
+	  if the client can support UPDATE and if it can, send UPDATE instead
+	  of INVITE to avoid the SDP renegotiation.  Not only was pjproject
+	  not setting the PJSIP_INV_SUPPORT_UPDATE flag, we were testing
+	  that invite_tsx wasn't NULL which isn't always the case.
+
+	  * Updated chan_pjsip/update_connected_line_information to drop the
+	    requirement that invite_tsx isn't NULL.
+	  * Submitted patch to pjproject sip_inv.c that sets the
+	    PJSIP_INV_SUPPORT_UPDATE flag correctly.
+	  * Updated pjsip.conf.sample to clarify what happens when "invite"
+	    is specified.
+
+	  ASTERISK-27095
+
+	  Change-Id: Ic2381b3567b8052c616d96fbe79564c530e81560
+
+2017-06-27 04:37 +0000 [2c43ca0ac5]  Ivan Poddubny <ivan.poddubny@gmail.com>
+
+	* app_queue: Fix returning to dialplan when a queue is empty
+
+	  The fix for ASTERISK-25665 introduced a regression.
+	  The return value of queue_exec used to be 0 in case of leavewhenempty
+	  but it was changed to -1 (returned from wait_our_turn and passed
+	  transparently by queue_exec), thus leading to hangup instead of returning
+	  back to dialplan.
+
+	  This commit resets the value back to 0 in this case, restoring
+	  original behavior.
+
+	  ASTERISK-27065 #close
+	  Reported by: Marek Cervenka
+
+	  Change-Id: Id9c83b75aeda463250155e88c5004be52bbca5ac
+
+2017-06-28 09:03 +0000 [0426b1d88a]  Joshua Colp <jcolp@digium.com>
+
+	* res_rtp_asterisk: Fix issues with ICE renegotiation.
+
+	  When re-inviting to add more streams it is possible for
+	  the role of existing ICE sessions to be changed to the
+	  incorrect value. This results in subsequent refreshes
+	  within the sessions getting a role conflict and the ICE
+	  session breaking down. This change only sets the role to
+	  be the new value if an ICE renegotiation is actually
+	  going to happen, otherwise the existing role is preserved.
+
+	  As well if we encounter a situation where a unidirectional
+	  ICE negotiation happens and the other side does not send us
+	  candidates we will not store any information for sending
+	  traffic, even though we know where they are reachable. This
+	  change fixes this by using the source of the ICE traffic
+	  itself as the target if no candidates are known and we
+	  receive some ICE traffic.
+
+	  ASTERISK-27088
+
+	  Change-Id: I71228181e358917fcefc3100fad21b2fc02a59a9
+
+2017-06-08 22:50 +0000 [eb48e99bd4]  George Joseph <gjoseph@digium.com>
+
+	* bridge_native_rtp: Keep rtp instance refs on bridge_channel
+
+	  There have been reports of deadlocks caused by an attempt to send a frame
+	  to a channel's rtp instance after the channel has left the native bridge
+	  and been destroyed.  This patch effectively causes the bridge channel to
+	  keep a reference to the glue and both the audio and video rtp instances
+	  so what gets started will get stopped.
+
+	  ASTERISK-26978 #close
+	  Reported-by: Ross Beer
+
+	  Change-Id: I9e1ac49fa4af68d64826ccccd152593cf8cdb21a
+
+2017-06-27 10:46 +0000 [1f59d08924]  Torrey Searle <torrey@voxbone.com>
+
+	* res/res_pjsip_t38: fix incorrect increment of media_count
+
+	  The T38 sdp callback incorrectly has a side effect of incrementing
+	  the media_count.  This can lead to core dumps.
+
+	  Change-Id: I7bb2f4987de4046ec52cfc34e5ea0662dae32af8
+
+2017-06-15 03:12 +0000 [9fbc34d2bd]  Torrey Searle <torrey@voxbone.com>
+
+	* res_pjsip:  Add DTMF INFO Failback mode
+
+	  The existing auto dtmf mode reverts to inband if 4733 fails to be
+	  negotiated.  This patch adds a new mode auto_info which will
+	  switch to INFO instead of inband if 4733 is not available.
+
+	  ASTERISK-27066 #close
+
+	  Change-Id: Id185b11e84afd9191a2f269e8443019047765e91
+
+2017-06-21 17:57 +0000 [764d04fa87]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_mwi.c: Eliminate RAII_VAR in contact delete observer
+
+	  Change-Id: I0bc97c6608de1d1a4228826b3b3be43f162f05f3
+
+2017-06-16 18:08 +0000 [0f6a9617eb]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_mwi: update unsolicited MWI subscriptions on updating contact
+
+	  Do not need to unsubscribe/subscribe on creating the ednpoint's contact.
+	  The modified function create_mwi_subscriptions_for_endpoint adds
+	  the subscription only if it does not exist.
+
+	  The subscriptions aren't added for active contacts
+	  which are retrieved on startup from realtime
+	  if mwi_disable_initial_unsolicited=yes.
+	  Because the mwi_contact_added is not called.
+	  So the subscriptions also should be created on updating contact.
+
+	  ASTERISK-26230 #close
+
+	  Change-Id: I47e265af9296ca09aa42a316fdacac104148cee4
+
+2017-06-20 15:41 +0000 [1f9913f272]  Kevin Harwell <kharwell@digium.com>
+
+	* core_local: local channel data not being properly unref'ed and unlocked
+
+	  In an earlier version of Asterisk a local channel [un]lock all functions were
+	  added in order to keep a crash from occurring when a channel hung up too early
+	  during an attended transfer. Unfortunately, when a transfer failure occurs and
+	  depending on the timing, the local channels sometime do not get properly
+	  unlocked and deref'ed after being locked and ref'ed. This happens because the
+	  underlying local channel structure gets NULLed out before unlocking.
+
+	  This patch reworks those [un]lock functions and makes sure the values that get
+	  locked and ref'ed later get unlocked and deref'ed.
+
+	  ASTERISK-27074 #close
+
+	  Change-Id: Ice96653e29bd9d6674ed5f95feb6b448ab148b09
+
+2017-06-20 16:01 +0000 [67664fbf95]  Kevin Harwell <kharwell@digium.com>
+
+	* bridge: stuck channel(s) after failed attended transfer
+
+	  If an attended transfer failed it was possible for some of the channels
+	  involved to get "stuck" because Asterisk was not hanging up the transfer target.
+
+	  This patch ensures Asterisk hangs up the transfer target when an attended
+	  transfer failure occurs.
+
+	  ASTERISK-27075 #close
+
+	  Change-Id: I98a6ecd92d3461ab98c36f0d9451d23adaf3e5f9
+
+2017-06-19 11:28 +0000 [cecf6540dc]  Rodrigo Ramírez Norambuena <a@rodrigoramirez.com>
+
+	* cdr: fix mistake spelling of a word for Unanswered.
+
+	  Change-Id: I7a610bef369924523a445c7e849ee88cc45dc5df
+
+2017-06-19 17:21 +0000 [8f356192d1]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* app_voicemail: IMAP connection control
+
+	  A new global option "imap_poll_logout" was added to specify whether need to
+	  disconnect from the IMAP server after polling of mailboxes.
+
+	  ASTERISK-27068 #close
+
+	  Closing IMAP connection after loading mailbox from voicemail.conf
+
+	  ASTERISK-24052 #close
+
+	  Change-Id: Ib7558ba04516240a32b65f42e9be64372a0ae12a
+
+2017-06-12 16:17 +0000 [8e749c8f51]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_mwi: unsubscribe unsolicited MWI on deleting endpoint last contact
+
+	  If the endpoint's last contact is deleted unsolicited MWI has to be
+	  unsubscribed.
+
+	  ASTERISK-27051 #close
+
+	  Change-Id: I33e174e0b9dba0998927d16d6d100fda5c7254e0
+
+2017-06-16 09:31 +0000 [edfdb4dff5]  George Joseph <gjoseph@digium.com>
+
+	* res_stasis:  Plug reference leak on stolen channels
+
+	  When a stasis channel is stolen by another app, the control
+	  structure is unreffed but never unlinked from the app_controls
+	  container.  This causes the channel reference to leak.
+
+	  Added OBJ_UNLINK to the callback in channel_stolen_cb.
+
+	  Also added some additional channel lifecycle debug messages to
+	  channel.c.
+
+	  ASTERISK-27059 #close
+	  Repoorted-by: George Joseph
+
+	  Change-Id: Ib820936cd49453f20156971785e7f4f182c56e14
+
+2017-06-16 14:56 +0000 [0a40073750]  Matthew Fredrickson <creslin@digium.com>
+
+	* formats/format_g729: Fix typo in comment
+
+	  There was a typo in a comment.  This commit is to fix the typo.
+
+	  ASTERISK-27060 #close
+
+	  Change-Id: Ic2699f8dbeaacd58ccb6ec3203e853e1babe3235
+
+2017-06-12 09:23 +0000 [a6e4899612]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: New endpoint option "notify_early_inuse_ringing"
+
+	  This option was added to control whether to notify dialog-info state
+	  'early' or 'confirmed' on Ringing when already INUSE.
+	  The value "yes" is useful for some SIP phones (Cisco SPA)
+	  to be able to indicate and pick up ringing devices.
+
+	  ASTERISK-26919 #close
+
+	  Change-Id: Ie050bc30023543c7dfb4365c5be3ce58c738c711
+
+2017-03-30 09:33 +0000 [005a4afa6b]  Jan Friesse <jfriesse@redhat.com>
+
+	* res_corosync: Change thread stack size
+
+	  In Corosync 2.x libraries were changed to use LibQB IPC.
+	  Sadly LibQB IPC doesn't support copy-free access to received buffer, so
+	  Corosync libraries were rewritten to use stack as buffer. Mostly the
+	  needed stack size is quite small, but for all *_dispatch functions, 1MiB
+	  is needed.
+
+	  Asterisk function ast_pthread_create_background set stack size for new
+	  thread to much smaller AST_BACKGROUND_STACKSIZE (~500KiB).
+
+	  This results in Asterisk crash when running with Corosync 2.x.
+
+	  Patch solves this issue by creating it's own version of
+	  ast_pthread_create_background which sets stack size to much higher value
+	  (actually it's AST_BACKGROUND_STACKSIZE + 3MiB).
+
+	  Another problem may appear when "corosync show members" netconsole
+	  command is executed. It is also executed in thread and also has only
+	  500KiB stack size. Sadly it calls corosync_cfg_get_node_addrs which
+	  again needs at least 1MiB stack.
+
+	  Solution is to use HAVE_COROSYNC_CFG_STATE_TRACK as a discriminator
+	  between Corosync 1.x and 2.x. If 1.x is found, nothing changes. If 2.x
+	  is found, NodeID is displayed instead of IP address.
+
+	  ASTERISK-25370 #close
+	  Reported by: mdu113
+
+	  Change-Id: Id95b0d21ab6e708e7d74ad8786c587211676fa08
+
+2017-06-13 11:33 +0000 [7901b9853e]  George Joseph <gjoseph@digium.com>
+
+	* res_ari:  Add "module loaded" check to ari stubs
+
+	  The recent change to make the use of LOAD_DECLINE more consistent
+	  caused res_ari to unload itself before declining if the ari.conf
+	  file wasn't found.  The ari stubs though still tried to use the
+	  configuration resulting in segfaults.
+
+	  This patch creates a new CHECK_ARI_MODULE_LOADED macro which tests
+	  to see if res_ari is actually loaded and causes the stubs to also
+	  decline if it isn't.  The macro was then added to the mustache
+	  template's "load_module" function.
+
+	  ASTERISK-27026 #close
+	  Reported-by: Ronald Raikes
+
+	  Change-Id: I263d56efa628ee3c411bdcd16d49af6260c6c91d
+
+2017-06-15 13:48 +0000 [3b6c327c51]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* app_voicemail: IMAP logout on reload/unload
+
+	  Closing IMAP connection on module reload or unload.
+
+	  ASTERISK-24052 #close
+
+	  Change-Id: I2a40182aa9ef249fa6865d33570430e9ada68525
+
+2017-06-15 12:33 +0000 [b9a4ab8c8c]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_pjsip: Fix PJSIP_MEDIA_OFFER dialplan function read.
+
+	  The construction of the returned string assumed incorrectly that the
+	  supplied buffer would always be initialized as an empty string.  If it is
+	  not an empty string we could overrun the supplied buffer by the length of
+	  the non-empty buffer string plus one.  It is also theoreticaly possible
+	  for the supplied buffer to be overrun by a string terminator during a read
+	  operation even if the supplied buffer is an empty string.
+
+	  * Fix the assumption that the supplied buffer would already be an empty
+	  string.  The buffer is not guaranteed to contain an empty string by all
+	  possible callers.
+
+	  * Fix string terminator buffer overrun potential.
+
+	  Change-Id: If6a0806806527678c8554b1dcb34fd7808aa95c9
+
+2017-06-15 07:32 +0000 [4910a3bf40]  Joshua Colp <jcolp@digium.com>
+
+	* channel: Fix reference counting in ast_channel_suppress.
+
+	  The ast_channel_suppress function wrongly decremented the
+	  reference count of the underlying structure used to keep
+	  track of what should be suppressed on a channel if the
+	  function was called multiple times on the same channel.
+
+	  This change cleans up the reference counting a bit so
+	  this no longer occurs.
+
+	  ASTERISK-27016
+
+	  Change-Id: I2eed4077cb4916e6626f9f120b63b963acc5c136
+
+2017-06-14 12:34 +0000 [f1a209d5ac]  Richard Mudgett <rmudgett@digium.com>
+
+	* app_voicemail.c: Fix compile error when IMAP enabled.
+
+	  Change-Id: I2703f15b4099b4210c68eccf293105d1975c1fc1
+
+2017-06-08 12:28 +0000 [dc307af7f2]  Frederic LE FOLL <frederic.lefoll@c-s.fr>
+
+	* Core/PBX: Deadlock between dialplan execution and application unregistration.
+
+	  Not easy to reproduce, but we have noticed deadlocks when unloading a module
+	  while dialplan is handling a request.
+
+	  The deadlock is between :
+	  1) Dialplan execution: pbx_extension_helper() first taking conlock,
+	  then pbx_findapp() [when called] asking for lock on apps list.
+	  2) Application unregistration: ast_unregister_application() first taking lock
+	  on apps list, then unreference_cached_app() [when called] asking for conlock.
+
+	  As a protection, I suggest to modify ast_unregister_application(), so that it
+	  anticipates the need of conlock, before taking the lock on apps list.
+	  The side effect is a longer unavailability of conlock when unregistering an
+	  application.
+
+	  ASTERISK-27041
+
+	  Change-Id: I0db0f1eb320da6a5758cce3a47d765be1face8e2
+
+2017-06-14 11:12 +0000 [c2eea791e4]  George Joseph <gjoseph@digium.com>
+
+	* res_pjsip_pubsub:  Fix reference to released endpoint
+
+	  destroy_subscription was attempting to get the id of the
+	  subscription tree's endpoint after we'd already called ao2_cleanup
+	  on it causing a segfault.
+
+	  Moved the cleanup until after the debug statement and since
+	  endpoint could also be NULL at this point, check for that as well.
+
+	  ASTERISK-27057 #close
+	  Reported-by: Ryan Smith
+
+	  Change-Id: Ice0a7727f560cf204d870a774c6df71e159b1678
+
+2017-06-14 08:29 +0000 [2dee95cc7a]  Florian Floimair (license 6892)
+
+	* res_pjsip_session:  Correct inverted test in session_outgoing_nat_hook
+
+	  There was a typo introduced in commit 776ffd77 which was preventing
+	  the transport's external media address from being used.
+
+	  ASTERISK-27024 #close
+	  Reported-by: Christopher van de Sande
+	  patches:
+	  	patch.diff submitted by Florian Floimair (license 6892)
+
+	  Change-Id: I7ec617171eaa2d86d2680b00cf37d5088adafc27
+
+2017-06-08 17:31 +0000 [e16a669c70]  Jørgen H <asterisk.org@hovland.cx>
+
+	* res_pjsip_transport_websocket: Add NULL check in get_write_timeout
+
+	  Added check for NULL return value when calling
+	  ast_sorcery_retrieve_by_id in function get_write_timeout
+
+	  ASTERISK-27046
+
+	  Change-Id: I9357717278da631c3a1cb502c412693929b0cb41
+
+2017-06-14 08:54 +0000 [7dafe82751]  George Joseph <gjoseph@digium.com>
+
+	* res_rtp_asterisk:  Fix ssrc change for rtcp srtp
+
+	  It looks like there was a copy/paste error in ast_rtp_change_source
+	  where if there was a rtcp srtp instance, instead of updating its
+	  ssrc we were updating the srtp instance ssrc twice.
+
+	  ASTERISK-27022 #close
+	  Reported-by: Michael Walton
+
+	  Change-Id: Ic88f3aee7227b401c58745ac265ff92c19620095
+
+2017-06-08 14:38 +0000 [e414833f6e]  Joshua Colp <jcolp@digium.com>
+
+	* bridge: Add a deferred queue.
+
+	  This change adds a deferred queue to bridging. If a bridge
+	  technology determines that a frame can not be written and
+	  should be deferred it can indicate back to bridging to do so.
+	  Bridging will then requeue any deferred frames upon a new
+	  channel joining the bridge.
+
+	  This change has been leveraged for T.38 request negotiate
+	  control frames. Without the deferred queue there is a race
+	  condition between the bridge receiving the T.38 request
+	  negotiate and the second channel joining and being in the
+	  bridge. If the channel is not yet in the bridge then the T.38
+	  negotiation fails.
+
+	  A unit test has also been added that confirms that a T.38
+	  request negotiate control frame is deferred when no other
+	  channel is in the bridge and that it is requeued when a new
+	  channel joins the bridge.
+
+	  ASTERISK-26923
+
+	  Change-Id: Ie05b08523f399eae579130f4a5f562a344d2e415
+
+2017-06-13 14:17 +0000 [6cdf3191d3]  Kevin Harwell <kharwell@digium.com>
+
+	* res_pjsip_refer/session: Calls dropped during transfer
+
+	  When doing an attended transfer it's possible for the transferer, after
+	  receiving an accepted response from Asterisk, to send a BYE to Asterisk,
+	  which can then be processed before Asterisk has time to start and/or
+	  complete the transfer process. This of course causes the transfer to not
+	  complete successfully, thus dropping the call.
+
+	  This patch makes it so any BYEs received from the transferer, after the REFER,
+	  that initiate a session end are deferred until the transfer is complete. This
+	  allows the channel that would have otherwise been hung up by Asterisk to
+	  remain available throughout the transfer process.
+
+	  ASTERISK-27053 #close
+
+	  Change-Id: I43586db79079457d92d71f1fd993be9a3b409d5a
+
+2017-06-13 10:47 +0000 [0bde568669]  George Joseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Use the asterisk github mirror for download
+
+	  We now mirror the pjproject tarball and md5 at
+	  https://github.com/asterisk/third-party/tree/master/pjproject
+
+	  To improve download reliability, we now get the tarball from
+	  our mirror instead of from pjsip.org.
+
+	  ASTERISK-27052 #close
+	  Reported-by: 'alex'
+
+	  Change-Id: I60236587a8935bfa71fcc391f4e2ecb31918c08a
+
+2017-06-12 17:55 +0000 [08be5e01e8]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* app_voicemail: IMAP logout on MWI unsubscribe
+
+	  Closing IMAP connection on MWI unsubscribe.
+
+	  ASTERISK-24052 #close
+
+	  Change-Id: I4ff964026002b2817b48c20fb4239f0a880228fd
+
+2017-06-12 09:57 +0000 [59c9bbe696]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_mwi: don't create mwi subscriptions if initial unsolicited disabled
+
+	  If sending unsolicited mwi to all endpoints on startup is disabled
+	  (mwi_disable_initial_unsolicited=yes) do not need to create subscriptions.
+	  If there are many (thousands) realtime endpoints configured with unsolicited mwi
+	  and Vociemail Storage configured as ODBC or IMAP there will be huge number of
+	  DB/IMAP requests on startup.
+
+	  ASTERISK-26230 #close
+
+	  Change-Id: I50ae909639e3ee298b931a54def4b2b9e0fb86c5
+
+2017-06-06 14:54 +0000 [68de35a6a0]  David M. Lee <dlee@respoke.io>
+
+	* CFLAGS for BIND8 support
+
+	  Some systems (like macOS) require BIND_8_COMPAT to be defined so that
+	  the nameser libraries are, well, BIND8 compatible.
+
+	  Change-Id: If79fc27a64f90de1835b5aa3aadfa9be22bd16b0
+
+2017-06-11 12:06 +0000 [da3312457e]  Sean Bright <sean.bright@gmail.com>
+
+	* codecs.conf.sample: Fix max_bandwidth speling error
+
+	  Reported by Sylvain Boily via asterisk-dev mailing list.
+
+	  Change-Id: Idc7623f335aea3e144dd369ba383b9a757480a9d
+
+2017-06-08 10:54 +0000 [6a64f65fe6]  Guido Falsi <madpilot@freebsd.org>
+
+	* BuildSystem: Add patches to allow building with recent LibreSSL
+
+	  Add some #if defined checks which allow building against LibreSSL.
+	  These patchess come from OpenBSD ports:
+	  https://cvsweb.openbsd.org/cgi-bin/cvsweb/ports/telephony/asterisk/patches/
+
+	  ASTERISK-27043 #close
+	  Reported by: OpenBSD ports
+
+	  Change-Id: I2f6c08a5840b85ad4d2b75370b947ddde7a9a572
+
+2017-06-08 10:36 +0000 [44cee2f4a1]  Guido Falsi <madpilot@freebsd.org>
+
+	* BuildSystem: Fix build on FreeBSD due to missing crypt.h
+
+	  FreeBSD does not include a crypt.h include file. Definitions for
+	  crypt() and crypt_r() are in unistd.h
+
+	  ASTERISK-27042 #close
+
+	  Change-Id: Ib307ee5e384870c6af50efa89fb73722dd0c3a7e
+
+2017-06-07 15:19 +0000 [1f10c6b3b0]  Joshua Colp <jcolp@digium.com>
+
+	* chan_pjsip: Update device state when in early media.
+
+	  The chan_pjsip module uses a calculation approach for
+	  determining device state. This means that in situations
+	  where we would expect device state to change we need to
+	  tell the core to query. A scenario that was missed is
+	  when early media was signaled.
+
+	  This change adds the notification for the core to
+	  query device state when we are told that early media
+	  is being provided.
+
+	  ASTERISK-27039
+
+	  Change-Id: Iafebfd152894966344ff2e950a3cee9f59a3eb6f
+
+2017-06-07 14:32 +0000 [590ffcaf0b]  Sean Bright <sean.bright@gmail.com>
+
+	* eventfd: Disable during cross compilation
+
+	  Reported by Lonnie Abelbeck <lonnie@abelbeck.com> via private e-mail.
+
+	  Change-Id: Icc80f12b8d8d591e14a8e0ed9f1c02cbd193a89b
+
+2017-06-07 11:21 +0000 [5520b6c201]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* CHANGES: correct version for a new option 'refer_blind_progress'
+
+	  Change-Id: If4817d26a8974610827624fb8a4e56d681d6bf97
+
+2017-06-06 07:04 +0000 [996a4791ff]  Joshua Colp <jcolp@digium.com>
+
+	* pjsip: Extend 'asymmetric_rtp_codec' option to include us changing.
+
+	  PJSIP support in Asterisk differs from chan_sip in that it
+	  allows media to be sent as-is without transcoding provided
+	  the codecs were negotiated in the SDP. This is allowed
+	  according to the RFC. Support for this differs quite a lot
+	  though and some endpoints do not handle it well.
+
+	  This change extends the 'asymmetric_rtp_codec' option to
+	  also cover this case. When set to no (the default) the code
+	  behaves as chan_sip does - the best codec is selected and
+	  we will only ever send that, unless we change what we are
+	  sending if the remote side changes. When set to yes we
+	  will send media as-is without transcoding if the codec
+	  has been negotiated in the SDP.
+
+	  ASTERISK-26996
+
+	  Change-Id: Ib1647f6902a0843e8c435946f831c2159e8d1d51
+
+2017-06-06 10:04 +0000 [c093bf8072]  Sean Bright <sean.bright@gmail.com>
+
+	* res_rtp_multicast: Use consistent timestamps when possible
+
+	  When a frame destined for a MulticastRTP channel does not have timing
+	  information (such as when an 'originate' is done), we generate the RTP
+	  timestamps ourselves without regard to the number of samples we are
+	  about to send.
+
+	  Instead, use the same method as res_rtp_asterisk and 'predict' a
+	  timestamp given the number of samples. If the difference between the
+	  timestamp that we generate and the one we predict is within a specific
+	  threshold, use the predicted timestamp so that we end up with timestamps
+	  that are consistent with the number of samples we are actually sending.
+
+	  Change-Id: I2bf0db3541b1573043330421cbb114ff0f22ec1f
+
+2017-05-31 10:41 +0000 [746c2c5745]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip: Add support for returning only reachable contacts and use it.
+
+	  This introduces the ability for PJSIP code to specify filtering flags
+	  when retrieving PJSIP contacts. The first flag for use causes the
+	  query code to only retrieve contacts that are not unreachable. This
+	  change has been leveraged by both the Dial() process and the
+	  PJSIP_DIAL_CONTACTS dialplan function so they will now only attempt
+	  calls to contacts which are not unreachable.
+
+	  ASTERISK-26281
+
+	  Change-Id: I8233b4faa21ba3db114f5a42e946e4b191446f6c
+
+2017-06-05 10:45 +0000 [adfb28882b]  Kevin Harwell <kharwell@digium.com>
+
+	* channel: ast_write frame wrongly freed after call to audiohooks
+
+	  ASTERISK-26419 introduced a bug when calling ast_audiohook_write_list in
+	  ast_write. It would free the frame given to ast_write if the frame returned
+	  by ast_audiohook_write_list was different than the given one. The frame
+	  give to ast_write should never be freed within that function. It is the
+	  caller's resposibility to free the frame after writing (or when it its done
+	  with it). By freeing it within ast_write this of course led to some memory
+	  corruption problems.
+
+	  This patch makes it so the frame given to ast_write is no longer freed within
+	  the function. The frame returned by ast_audiohook_write_list is now subsequently
+	  used in ast_write and is freed later. It is freed either after translate if the
+	  frame returned by translate is different, or near the end of ast_write prior
+	  to function exit.
+
+	  ASTERISK-26973 #close
+
+	  Change-Id: I463d4ac3b736ced95de986ee74a489c7c7ab103b
+
+2017-05-31 11:45 +0000 [283cc59af7]  Sean Bright <sean.bright@gmail.com>
+
+	* pbx_builtin: Properly handle hangup during Background
+
+	  Before this patch, when a user hung up during a Background, we would
+	  stuff 0xff into a char and attempt a dialplan lookup of it. This caused
+	  problems for some realtime engines which interpreted the value as the
+	  beginning of an invalid UTF-8 sequence.
+
+	  ASTERISK-19291 #close
+	  Reported by: Andrew Nowrot
+
+	  Change-Id: I8ca6da93252d61c76ebdb46a4aa65e73ca985358
+
+2017-05-31 04:25 +0000 [dc05183f4b]  Joshua Colp <jcolp@digium.com>
+
+	* channel / app_meetme: Fix parentheses.
+
+	  ASTERISK-27025
+
+	  Change-Id: Id736b0aa4ec6b6b0f04663d64fa8d151f81fdbed
+
+2017-05-30 16:07 +0000 [cf6cf59646]  Sean Bright <sean.bright@gmail.com>
+
+	* stasis_recording: Correct ast_asprintf error checking
+
+	  ASTERISK-27021 #close
+	  Reported by: Tim Morgan
+
+	  Change-Id: I0ac061f040093e806c3b1f4e2340864f3ce4dd75
+
+2017-05-28 15:43 +0000 [70e5887906]  Sean Bright <sean.bright@gmail.com>
+
+	* format: Reintroduce smoother flags
+
+	  In review 4843 (ASTERISK-24858), we added a hack that forced a smoother
+	  creation when sending signed linear so that the byte order was adjusted
+	  during transmission. This was needed because smoother flags were lost
+	  during the new format work that was done in Asterisk 13.
+
+	  Rather than rolling that same hack into res_rtp_multicast, re-introduce
+	  smoother flags so that formats can dictate their own options.
+
+	  Change-Id: I77b835fba0e539c6ce50014a984766f63cab2c16
+
+2017-05-30 09:34 +0000 [97b003f5e2]  Sean Bright <sean.bright@gmail.com>
+
+	* format_mp3: Re-work menuselect/build issues
+
+	  Rather than removing format_mp3 from ALL_C_MODS (which caused format_mp3
+	  to not show up in menuselect), use .PHONY targets when the necessary
+	  source files are not present.
+
+	  ASTERISK-23951
+	  Reported by: Tzafrir Cohen
+
+	  Change-Id: I0a7512c51acc9e86043671795020b0de725bd9e8
+
+2017-05-30 09:43 +0000 [c10341646d]  George Joseph <gjoseph@digium.com>
+
+	* test_json:  Fix test names with reserved words
+
+	  Some of the test names were actually reserved words (true, false,
+	  int, null, string, bool).  When the jenkins test results analyzer
+	  does its thing it tries to create a map using the test names as
+	  keys and fails because they're reserved words.
+
+	  Added "type_" to those test names.
+
+	  Change-Id: I90d809f46969c78a1c605b736ff0635196a2cf1b
+
+2017-05-26 11:41 +0000 [b07b216235]  Joshua Colp <jcolp@digium.com>
+
+	* manager: Clear the flag on the other channel.
+
+	  During the channel flag audit an incorrect change was
+	  done. The flag should be cleared on the second channel.
+
+	  ASTERISK-26469
+
+	  Change-Id: I770c5a389550a2fb5a6ade942fccbb2e1d9199c8
+
+2017-05-26 11:06 +0000 [5e9cd1f20d]  Sean Bright <sean.bright@gmail.com>
+
+	* res_srtp: Add support for libsrtp2
+
+	  ASTERISK-25294 #close
+	  Reported by: Tzafrir Cohen
+
+	  ASTERISK-26976 #close
+	  Reported by: Alex
+
+	  Change-Id: I789b1c3d1ed31365bbd9339fa58ef36f48833c40
+
+2017-05-25 11:10 +0000 [72213c98e3]  Sean Bright <sean.bright@gmail.com>
+
+	* format_mp3: Don't try to build format_mp3 if we don't have sources
+
+	  ASTERISK-23951 #close
+	  Reported by: Tzafrir Cohen
+
+	  Change-Id: Iebf181d44bb735787fde4b5be863c4d7e2478a30
+
+2017-05-24 15:50 +0000 [65898c3af8]  George Joseph <gjoseph@digium.com>
+
+	* unittests:  Add a unit test that causes a SEGV and...
+
+	  ...that can only be run by explicitly calling it with
+	  'test execute category /DO_NOT_RUN/ name RAISE_SEGV'
+
+	  This allows us to more easily test CI and debugging tools that
+	  should do certain things when asterisk coredumps.
+
+	  To allow this a new member was added to the ast_test_info
+	  structure named 'explicit_only'.  If set by a test, the test
+	  will be skipped during a 'test execute all' or
+	  'test execute category ...'.
+
+	  Change-Id: Ia3a11856aae4887df9a02b6b081cc777b36eb6ed
+
+2017-05-23 15:42 +0000 [90237dca11]  Sean Bright <sean.bright@gmail.com>
+
+	* res_agi: Allow configuration of audio format of EAGI pipe
+
+	  This change allows the format of the EAGI audio pipe to be changed by
+	  setting the dialplan variable 'EAGI_AUDIO_FORMAT' to the name of one of
+	  the loaded formats.
+
+	  ASTERISK-26124 #close
+
+	  Change-Id: I7a10fad401ad2a21c68c2e7246fa357d5cee5bbd
+
+2017-05-23 13:33 +0000 [3eb7fbba72]  Sean Bright <sean.bright@gmail.com>
+
+	* res_agi: Clarify 'RECORD FILE' documentation
+
+	  Documented the 'beep' option in both the parameters list and the command
+	  description.
+
+	  ASTERISK-23839 #close
+
+	  Change-Id: I4970395c922dbdce3f7cf0f56d5b065ec9aa53ea
+
+2017-05-23 13:06 +0000 [f306e451f6]  Sean Bright <sean.bright@gmail.com>
+
+	* res_agi: Prevent crash when SET VARIABLE called without arguments
+
+	  Explicitly check that the appropriate number of arguments were passed to
+	  SET VARIABLE before attempting to reference them. Also initialize the
+	  arguments array to zeroes before populating it.
+
+	  ASTERISK-22432 #close
+
+	  Change-Id: I5143607d80a2724f749c1674f3126b04ed32ea97
+
+2017-05-23 12:35 +0000 [a007e438c3]  Sean Bright <sean.bright@gmail.com>
+
+	* res_agi: Fix malformed AGI usage response
+
+	  If the generated XML documentation for a command does not end with a \n,
+	  the postamble of the usage message does not appear on its own line.
+
+	  ASTERISK-25662 #close
+
+	  Change-Id: If190f1e9e37fe215fed95897d78d4a6e142b0020
+
+2017-05-23 12:00 +0000 [971a401ce9]  Sean Bright <sean.bright@gmail.com>
+
+	* sip.conf.sample: Clarify where DTLS settings are permitted
+
+	  ASTERISK-25101 #close
+
+	  Change-Id: I09a97793e5577b4422d0ae883fadb3f0d86725cc
+
+2017-05-23 10:06 +0000 [700ef6861a]  Sean Bright <sean.bright@gmail.com>
+
+	* res_format_attr_h26x: Trim blanks in fmtp attributes
+
+	  Some devices separate format attributes with a semicolon followed by a
+	  space, so trim blanks before trying to match them.
+
+	  ASTERISK-27008 #close
+
+	  Change-Id: Ia44cb2e4fef5c73dc541a29da79cb0e19c22d9cc
+
+2017-05-15 15:03 +0000 [6bfcb1acc7]  Joshua Colp <jcolp@digium.com>
+
+	* app_queue: Fix members showing as being in call when not.
+
+	  A change was done which added an 'in_call' flag to queue
+	  members that was set to true while talking to an agent.
+	  Unfortunately in practice this does not accurately reflect
+	  whether they are talking to an agent or not. If a Local
+	  channel is involved and a transfer is performed then the
+	  app_queue application would incorrectly think the agent
+	  was still in a call with the caller. This was done to
+	  fix a race condition between an agent becoming available
+	  by device state and the checking of the last call information
+	  for the wrapup time. There was a small window where the
+	  last call information would be the previous value instead
+	  of the new one.
+
+	  This change goes about fixing the original issue in a
+	  different way by considering the call completed if device
+	  state is received which would make the agent available
+	  and if they are currently in a call. If this occurs the
+	  last call information is updated before the agent becomes
+	  available ensuring that old information is not present
+	  when checking if the member should be called. This also
+	  improves the transfer situation by actually updating
+	  and enforcing the wrapup time.
+
+	  ASTERISK-26399
+	  ASTERISK-26400
+	  ASTERISK-26715
+	  ASTERISK-26975
+
+	  Change-Id: Ife1cb686e3173b3a6d368601adef9aff69d4beea
+
+2017-05-23 05:45 +0000 [f1b32de2c5]  Robert Mordec <r.mordec@slican.pl>
+
+	* app_confbridge: Race between removing and playing name recording while leaving
+
+	  When user leaves a conference, its channel calls async_play_sound_file()
+	  in order to play the name announcement and then unlinks the sound file.
+	  The async_play_sound_file() function adds a task to conference playback queue,
+	  which then runs playback_common() function in a different thread.
+
+	  It leads to a race condition when, in some cases, channel thread may unlink
+	  the sound file before playback_common() had a chance to open it.
+
+	  This patch creates a file deletion task, that is queued after playback.
+
+	  ASTERISK-27012 #close
+
+	  Change-Id: I412f7922d412004b80917d4e892546c15bd70dd3
+
+2017-05-22 13:51 +0000 [e91efef2bb]  Kevin Harwell <kharwell@digium.com>
+
+	* res_rtp_asterisk: rtcp mux using the wrong srtp unprotecting algorithm
+
+	  When using rtcp mux if an rtcp payload came in it would still use the srtp
+	  unprotect algorithm instead of the srtp unprotect rtcp method. Since rtcp
+	  data was being passed to the rtp unprotect method this would result in an
+	  error.
+
+	  This patch ensures that the correct unprotect method is chosen by making
+	  sure the passed in rtcp flag is appropriately set when rtcp mux is enabled
+	  and an rtcp payload is received.
+
+	  ASTERISK-26979 #close
+
+	  Change-Id: Ic5409f9d1a267f1d4785fc5aed867daaecca6241
+
+2017-05-19 10:05 +0000 [4479038073]  Sean Bright <sean.bright@gmail.com>
+
+	* chan_sip: Better ICE handling for RTCP-MUX
+
+	  If we are offered or are offering RTCP-MUX, don't consider RTCP ICE
+	  candidates. This confuses certain browsers (current Firefox for
+	  example) and causes intial audio setup delays.
+
+	  ASTERISK-26982 #close
+
+	  Change-Id: Ifeaf47e83972fe8dbe58b7fb3d6d1823400cfb91
+
+2017-04-26 09:22 +0000 [36628cc9c4]  Yasin CANER <yasin.caner@netgsm.com.tr>
+
+	* res_pjsip_session : fixed wrong From Header number On Re-invite
+
+	  ASTERISK-26964 #close
+
+	  Change-Id: I55a9caa7dc90e6c4c219cb09b5c2ec08af84a302
+
+2017-05-13 11:40 +0000 [1618203964]  Joshua Colp <jcolp@digium.com>
+
+	* asterisk: Audit locking of channel when manipulating flags.
+
+	  When manipulating flags on a channel the channel has to be
+	  locked to guarantee that nothing else is also manipulating
+	  the flags. This change introduces locking where necessary to
+	  guarantee this. It also adds helper functions that manipulate
+	  channel flags and lock to reduce repeated code.
+
+	  ASTERISK-26789
+
+	  Change-Id: I489280662dba0f4c50981bfc5b5a7073fef2db10
+
+2017-05-08 15:56 +0000 [6af2dd34af]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: New endpoint option "refer_blind_progress"
+
+	  This option was added to turn off notifying the progress details
+	  on Blind Transfer. If this option is not set then the chan_pjsip
+	  will send NOTIFY "200 OK" immediately after "202 Accepted".
+
+	  Some SIP phones like Mitel/Aastra or Snom keep the line busy until
+	  receive "200 OK".
+
+	  ASTERISK-26333 #close
+
+	  Change-Id: Id606fbff2e02e967c02138457badc399144720f2
+
+2017-05-22 20:20 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.16.0-rc1 Released.
+
+2017-04-13 17:16 +0000 [919ccdb9ac]  Mark Michelson <mmichelson@digium.com>
+
+	* AST-2017-002: Ensure transaction key buffer is large enough.
+
+	  ASTERISK-26938 #close
+
+	  Change-Id: I266490792fd8896a23be7cb92f316b7e69356413
+
+2017-04-13 17:17 +0000 [49c032abef]  Mark Michelson <mmichelson@digium.com>
+
+	* AST-2017-003: Handle zero-length body parts correctly.
+
+	  ASTERISK-26939 #close
+
+	  Change-Id: I7ea235ab39833a187db4e078f0788bd0af0a24fd
+
+2017-04-13 11:14 +0000 [1cc18d4025]  gtjoseph <gjoseph@digium.com>
+
+	* AST-2017-004: chan_skinny:  Add EOF check in skinny_session
+
+	  The while(1) loop in skinny_session wasn't checking for EOF so
+	  a packet that was longer than a header but still truncated
+	  would spin the while loop infinitely.  Not only does this
+	  permanently tie up a thread and drive a core to 100% utilization,
+	  the call of ast_log() in such a tight loop eats all available
+	  process memory.
+
+	  Added poll with timeout to top of read loop
+
+	  ASTERISK-26940 #close
+	  Reported-by: Sandro Gauci
+
+	  Change-Id: I2ce65f3c5cb24b4943a9f75b64d545a1e2cd2898
+
+2017-05-18 16:35 +0000 [c107ab4c04]  Sean Bright <sean.bright@gmail.com>
+
+	* res_hep_rtcp: Add support level to module info
+
+	  Change-Id: I5661478f9cf12d431f730e42be79323b62831e92
+
+2017-05-11 00:25 +0000 [cfeae52c0f]  Ivan Poddubny <ivan.poddubny@gmail.com>
+
+	* app_queue: Fix duplicate queue_log entries for EXITEMPTY and ABANDON
+
+	  There are 2 places in app_queue.c that log EXITEMPTY event: one in
+	  wait_our_turn, and another one in queue_exec in the loop trying to
+	  call an agent after wait_our_turn.
+
+	  In most cases it leads to logging EXITEMPTY twice.
+
+	  ABANDON is also logged on two places, and in the rare case when an agent
+	  and caller hang up simultaneously it's also possible to get duplicates
+	  in queue_log.
+
+	  This commit changes wait_our_turn to return -1 ("the caller should exit
+	  the queue") instead of 0 ("the caller's turn has arrived") in case of
+	  leaving when empty, so queue_exec skips the agent calling loop.
+
+	  Also, leave_queue is now executed only once in this case, because 2nd
+	  time is just a noop when the queue entry has already been removed.
+
+	  Also, it sets qe->handled to -1 to indicate that the call was not
+	  answered by an agent, but the necessary handling has already been done
+	  in order to avoid logging an extra ABANDON entry.
+
+	  ASTERISK-25665 #close
+	  Reported by: Ove Aursand
+
+	  Change-Id: I4578dd383bf2ac41589cf167865e8aaebcd4c11e
+
+2017-05-14 00:37 +0000 [5da91c65be]  Rodrigo Ramírez Norambuena <a@rodrigoramirez.com>
+
+	* Fix spelling queues.conf.sample file
+
+	  Change-Id: Ie1c2d83af66f27a449da09a68d987e0992627fee
+
+2017-05-12 21:04 +0000 [b67363006f]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Process initial INVITE sooner. (key exists)
+
+	  Retransmissions of an initial INVITE could be queued in the serializer
+	  before we have processed the first INVITE message.  If the first INVITE
+	  message doesn't get completely processed before the retransmissions are
+	  seen then we could try to setup the same call from the retransmissions.  A
+	  symptom of this is seeing a (key exists) message associated with an
+	  INVITE.  An earlier change attempted to address this kind of problem by
+	  calculating a distributor serializer to use for unassociated messages.
+	  Part of that change also made incoming calls keep using that distributor
+	  serializer.  (ASTERISK-26088) However, some leftover code was still
+	  deferring the INVITE processing to the session's serializer even though we
+	  were already in that serializer.  This not only is unnecessary but would
+	  cause the same call resetup problem.
+
+	  * Removed the code to defer processing the initial INVITE to the session's
+	  serializer because we are already running in that serializer.
+
+	  ASTERISK-26998 #close
+
+	  Change-Id: I1e822d82dcc650e508bc2d40d545d5de4f3421f6
+
+2017-05-08 13:40 +0000 [1bcce442d0]  Vitezslav Novy <a1@vnovy.net>
+
+	* chan_sip: Change sip_get_codec() to return correct codec list
+
+	  Return cahnnel nativeformats to fix bridge technology selection process.
+	  Same approach as in pjsip module.
+
+	  ASTERISK-26143
+	  Reported-by: Henning Holtschneider
+
+	  Change-Id: I64e863753954d6ad67a9e722df2ebc328705ad48
+
+2017-05-09 10:34 +0000 [6fba0a41f0]  Joshua Colp <jcolp@digium.com>
+
+	* tcptls: Improve error messages for TLS connections.
+
+	  This change uses the functions provided by OpenSSL to query
+	  and better construct error messages for situations where
+	  the connection encounters a problem.
+
+	  ASTERISK-26606
+
+	  Change-Id: I7ae40ce88c0dc4e185c4df1ceb3a6ccc198f075b
+
+2017-05-04 17:28 +0000 [8ec6e19c86]  Joshua Elson <joshelson@gmail.com>
+
+	* Prevent Undefined Capath Crash
+
+	  It is possible to initialize a valid config without a capath
+	  or cafile definition. This will cause a crash on a reload.
+
+	  This fix ensures capath is always allocated.
+
+	  ASTERISK-26983 #close
+
+	  Change-Id: I63ff715d9d9023427543a5b8a4ba7b0d82533c12
+
+2017-05-05 11:33 +0000 [d6325373ac]  gtjoseph <gjoseph@digium.com>
+
+	* cel_odbc:  Fix timestamp processing for microseconds
+
+	  When a column is of type timestamp, the fraction part of the event
+	  field's seconds was frequently parsed incorrectly especially if
+	  there were leading zeros.  For instance "2017-05-23 23:55:03.023"
+	  would be parsed into an int as "23" then when the timestamp was
+	  formatted again to be inserted into the database column it'd be
+	  "2017-05-23 23:55:03.23" which is now 230 milliseconds instead of
+	  23 milliseconds.  "03.000001" would be transformed to "03.1", etc.
+
+	  * If the event field is 'eventtime' and the db column is timestamp,
+	    then existing processing has already correctly formatted the
+	    timestamp so now we simply use it rather than parsing it and
+	    re-printing it. This is the most common use case anyway.
+
+	  * If the event field is other than 'eventtime' and the db column
+	    is timestamp, we now parse the seconds, including the fractional
+	    part into a double rather than 2 ints.  This preserves the
+	    magnitude and precision of the fractional part.  When we print
+	    it, we now print it as a "%09.6lf" which correctly represents the
+	    input.
+
+	  To be honest, why we parse the string timestamp into components,
+	  test the components, then print the components back into a string
+	  timestamp is beyond me.  We should use parse it, test it, then if
+	  it passes, use the original string representation in the database
+	  call.  Maybe someone thought that some implementations wouldn't
+	  take a partial timestamp string like "2017-05-06" and decided to
+	  always produce a full timestamp string even if an abbreviated one
+	  was supplied.  Anyway, I'm leaving it as it is.
+
+	  ASTERISK-25032 #close
+	  Reported-by: Etienne Lessard
+
+	  Change-Id: Id407e6221f79a5c1120e1a70bc7e893bbcaf1938
+
+2017-05-09 05:25 +0000 [10a49ab362]  Joshua Colp <jcolp@digium.com>
+
+	* res_hep_rtcp: Provide chan_sip Call-ID for RTCP messages.
+
+	  This change adds the required logic to allow the SIP
+	  Call-ID to be placed into the HEP RTCP traffic if the
+	  chan_sip module is used. In cases where the option is
+	  enabled but the channel is not either SIP or PJSIP then
+	  the code will fallback to the channel name as done
+	  previously.
+
+	  Based on the change on Nir's branch at:
+	  team/nirs/hep-chan-sip-support
+
+	  ASTERISK-26427
+
+	  Change-Id: I09ffa5f6e2fdfd99ee999650ba4e0a7aad6dc40d
+
+2017-05-08 16:11 +0000 [7d4a22bf2e]  gtjoseph <gjoseph@digium.com>
+
+	* logger:  Added logger_queue_limit to the configuration options.
+
+	  All log messages go to a queue serviced by a single thread
+	  which does all the IO.  This setting controls how big that
+	  queue can get (and therefore how much memory is allocated)
+	  before new messages are discarded. The default is 1000.
+	  Should something go bezerk and log tons of messages in a tight
+	  loop, this will prevent memory escalation.
+
+	  When the limit is reached, a WARNING is logged to that effect
+	  and messages are discarded until the queue is empty again.  At
+	  that time another WARNING will be logged with the count of
+	  discarded messages.  There's no "low water mark" for this queue
+	  because the logger thread empties the entire queue and processes it
+	  in 1 batch before going back and waiting on the queue again.
+	  Implementing a low water mark would mean additional locking as
+	  the thread processes each message and it's not worth it.
+
+	  A "test" was added to test_logger.c but since the outcome is
+	  non-deterministic, it's really just a cli command, not a unit
+	  test.
+
+	  Change-Id: Ib4520c95e1ca5325dbf584c7989ce391649836d1
+
+2017-05-04 17:32 +0000 [614eda785d]  Richard Mudgett <rmudgett@digium.com>
+
+	* netsock2.c: Made get/set addr port avoid potential uninitialized memory.
+
+	  Change-Id: I532052bd7cd95a4b3565485fc01e2a1ea07ee647
+
+2017-05-05 08:48 +0000 [c3ed63cb2c]  Joshua Colp <jcolp@digium.com>
+
+	* func_cdr: Allow empty value for CDR dialplan function.
+
+	  A regression was introduced in 12 where passing an empty value
+	  to the CDR dialplan function was not longer allowed. This
+	  change returns to the behavior of 11 where it is permitted.
+
+	  ASTERISK-26173
+
+	  Change-Id: I3f148203b54ec088007e29e30005a5de122e51c5
+
+2017-05-04 16:04 +0000 [bed6c0d04b]  gtjoseph <gjoseph@digium.com>
+
+	* app_confbridge:  Fix reference to cfg in menu_template_handler
+
+	  menu_template_handler wasn't properly accounting for the fact that
+	  it might be called both during a load/reload (which isn't really
+	  valid but not prevented) and by a dialplan function.  In both cases
+	  it was attempting to use the "pending" config which wasn't valid in
+	  the latter case.  aco_process_config is also partly to blame because
+	  it wasn't properly cleaning "pending" up when a reload was done and
+	  no changes were made.  Both of these contributed to a crash if
+	  CONFBRIDGE(menu,template) was called in a dialplan after a reload.
+
+	  * aco_process_config now sets info->internal->pending to NULL
+	    after it unrefs it although this isn't strictly necessary in the
+	    context of this fix.
+	  * menu_template_handler now uses the "current" config and silently
+	    ignores any attempt to be called as a result of someone uses the
+	    "template" parameter in the conf file.
+
+	  Luckily there's no other place in the codebase where
+	  aco_pending_config is used outside of aco_process_config.
+
+	  ASTERISK-25506 #close
+	  Reported-by: Frederic LE FOLL
+
+	  Change-Id: Ib349a17d3d088f092480b19addd7122fcaac21a7
+
+2017-04-30 16:40 +0000 [7ffd80cc04]  Joshua Colp <jcolp@digium.com>
+
+	* bridge: Fix returning to dialplan when executing Bridge() from AMI.
+
+	  When using the Bridge AMI action on the same channel multiple times
+	  it was possible for the channel to return to the wrong location in
+	  the dialplan if the other party hung up. This happened because the
+	  priority of the channel was not preserved across each action
+	  invocation and it would fail to move on to the next priority in
+	  other cases.
+
+	  This change makes it so that the priority of a channel is preserved
+	  when taking control of it from another thread and it is incremented
+	  as appropriate such that the priority reflects where the channel
+	  should next be executed in the dialplan, not where it may or may not
+	  currently be.
+
+	  The Bridge AMI action was also changed to ensure that it too
+	  starts the channels at the next location in the dialplan.
+
+	  ASTERISK-24529
+
+	  Change-Id: I52406669cf64208aef7252a65b63ade31fbf7a5a
+
+2017-05-01 13:04 +0000 [bbe90d6aed]  Kevin Harwell <kharwell@digium.com>
+
+	* res_rtp_asterisk: Clearing the remote RTCP address causes RTCP failures
+
+	  When a call gets put on hold RTP is temporarily stopped and Asterisk was
+	  setting the remote RTCP address to NULL. Then when RTCP data was received
+	  from the remote endpoint, Asterisk would be missing this information when
+	  publishing the rtcp_message stasis event. Consequently, message subscribers
+	  (in this case res_hep_rtcp) trying to parse the "from" field output the
+	  following error:
+
+	  "ast_sockaddr_split_hostport: Port missing in (null)"
+
+	  This patch makes it so the remote RTCP address is no longer set to NULL when
+	  stopping RTP. There was only one place that appeared to check if the remote
+	  RTCP address was NULL as a way to tell if RTCP was running. This patch added
+	  an additional check on the RTCP schedid for that case to make sure RTCP was
+	  truly not running.
+
+	  ASTERISK-26860 #close
+
+	  Change-Id: I6be200fb20db647e48b5138ea4b81dfa7962974b
+
+2017-05-02 11:34 +0000 [526a0081a0]  Sean Bright <sean.bright@gmail.com>
+
+	* cleanup: Change severity of fread short-read warning
+
+	  Many sound files don't have a full frame's worth of data at EOF, so the
+	  warning messages were a bit too noisy. So we demote them to debug
+	  messages.
+
+	  Change-Id: I6b617467d687658adca39170a81797a11cc766f6
+
+2017-04-26 07:58 +0000 [23db04ed93]  Thierry Magnien <thierry.magnien@gmail.com>
+
+	* channels/chan_sip.c: use binding IP address for outgoing TCP SIP connections
+
+	  For outgoing TCP connections, Asterisk uses the first IP address of the
+	  interface instead of the IP address we asked him to bind to.
+
+	  ASTERISK-26922 #close
+	  Reported-by: Ksenia
+
+	  Change-Id: I43c71ca89211dbf1838e5bcdb9be8d06d98e54eb
+
+2017-04-29 16:18 +0000 [02234e920c]  Richard Mudgett <rmudgett@digium.com>
+
+	* rtp_engine.c: Fix deadlock potential copying RTP payload maps.
+
+	  There is a theoretical potential to deadlock in
+	  ast_rtp_codecs_payloads_copy() because it locks two different
+	  ast_rtp_codecs locks.  It is theoretical because the callers of the
+	  function are either copying between a local ast_rtp_codecs struct and a
+	  RTP instance of the ast_rtp_codecs struct.  Or they are copying between
+	  the caller and callee channel RTP instances before initiating the call to
+	  the callee.  Neither of these situations could actually result in a
+	  deadlock because there cannot be another thread involved at the time.
+
+	  * Add deadlock avoidance code to ast_rtp_codecs_payloads_copy() since it
+	  locks two ast_rtp_codecs locks to perform a copy.
+
+	  This only affects v13 since this deadlock avoidance code is already in
+	  newer branches.
+
+	  Change-Id: I1aa0b168f94049bd59bbd74a85bd1e78718f09e5
+
+2017-04-29 16:11 +0000 [9d5df48968]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_t38.c: Fix deadlock in T.38 framehook.
+
+	  A deadlock can happen between a channel lock and a pjsip session media
+	  container lock.  One thread is processing a reINVITE's SDP and walking
+	  through the session's media container when it waits for the channel lock
+	  to put the determined format capabilities onto the channel.  The other
+	  thread is writing a frame to the channel and processing the T.38 frame
+	  hook.  The T.38 frame hook then waits for the pjsip session's media
+	  container lock.  The two threads are now deadlocked.
+
+	  * Made the T.38 frame hook release the channel lock before searching the
+	  session's media container.  This fix has been done to several other
+	  frame hooks to fix deadlocks.
+
+	  ASTERISK-26974 #close
+
+	  Change-Id: Ie984a76ce00bef6ec9aa239010e51e8dd74c8186
+
+2017-04-28 10:56 +0000 [623832b94e]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_outbound_authenticator_digest: Add context to log messages
+
+	  There was no context info in this module's log messages so it was
+	  impossible to toubleshoot.
+
+	  Added endpoint or host to all messages and added the realms in the
+	  challenge for the "No auth credentials for any realm" message.
+
+	  Change-Id: Ifeed2786f35fbea7d141237ae15625e472acff9b
+
+2017-04-27 08:02 +0000 [c5b9ed20fd]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_session:  Add cleanup to ast_sip_session_terminate
+
+	  If you use ast_request to create a PJSIP channel but then hang it
+	  up without causing a transaction to be sent, the session will
+	  never be destroyed.  This is due ot the fact that it's pjproject
+	  that triggers the session cleanup when the transaction ends.
+	  app_chanisavail was doing this to get more granular channel state
+	  and it's also possible for this to happen via ARI.
+
+	  * ast_sip_session_terminate was modified to explicitly call the
+	    cleanup tasks and unreference session if the invite state is NULL
+	    AND invite_tsx is NULL (meaning we never sent a transaction).
+
+	  * chan_pjsip/hangup was modified to bump session before it calls
+	    ast_sip_session_terminate to insure that session stays valid
+	    while it does its own cleanup.
+
+	  * Added test events to session_destructor for a future testsuite
+	    test.
+
+	  ASTERISK-26908 #close
+	  Reported-by: Richard Mudgett
+
+	  Change-Id: I52daf6f757184e5544c261f64f6fe9602c4680a9
+
+2017-04-26 14:20 +0000 [c853cfdc7c]  Kevin Harwell <kharwell@digium.com>
+
+	* res_pjsip/res_pjsip_callerid: NULL check on caller id name string
+
+	  It's possible for a name in a party id structure to be marked as valid, but the
+	  name string itself be NULL (for instance this is possible to do by using the
+	  dialplan CALLERID function). There were a couple of places where the name was
+	  validated, but the string itself was not checked before passing it to functions
+	  like 'strlen'. This of course caused a crashed.
+
+	  This patch adds in a NULL check before attempting to pass it into a function
+	  that is not NULL tolerant.
+
+	  ASTERISK-25823 #close
+
+	  Change-Id: Iaa6ffe9d92f598fe9e3c8ae373fadbe3dfbf1d4a
+
+2017-04-25 11:43 +0000 [4d3b4fbf22]  Kevin Harwell <kharwell@digium.com>
+
+	* vector: defaults and indexes
+
+	  Added an pre-defined integer vector declaration. This makes integer vectors
+	  easier to declare and pass around. Also, added the ability to default a vector
+	  up to a given size with a default value. Lastly, added functionality that
+	  returns the "nth" index of a matching value.
+
+	  Also, updated a unit test to test these changes.
+
+	  Change-Id: Iaf4b51b2540eda57cb43f67aa59cf1d96cdbcaa5
+
+2017-04-20 02:13 +0000 [566ad7c35d]  Jean Aunis <jean.aunis@prescom.fr>
+
+	* chan_sip: Trigger reinvite if the SDP answer is included in the SIP ACK
+
+	  Some equipments may send a re-INVITE containing an SDP in the final ACK
+	  request. If this happens in the context of direct media, the remote end
+	  should be updated with a re-INVITE.
+	  This patch queues an "update RTP peer" frame to trigger the re-INVITE,
+	  instead of the "source change" frame wich was used previously.
+
+	  ASTERISK-26951
+
+	  Change-Id: I3644d2025f20e086ea9f8f62b486172c52b5b2e6
+
+2017-04-26 08:45 +0000 [001dc2ade6]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Add --disable-libwebrtc to configure
+
+	  Without the disable, pjproject tries to build it's internal
+	  webrtc implementation which requires sse2.  This fails on
+	  platforms without sse2.
+
+	  ASTERISK-26930 #close
+	  Reported-by: abelbeck
+
+	  Change-Id: I07231f9160c35cfa42b194d3aad4e7d51fd9a410
+
+2017-04-26 05:38 +0000 [ae696132a2]  Joshua Colp <jcolp@digium.com>
+
+	* frame: Better handle interpolated frames.
+
+	  Interpolated frames are frames which contain a number of
+	  samples but have no actual data. Audiohooks did not
+	  handle this case when translating an incoming frame into
+	  signed linear. It assumed that a frame would always contain
+	  media when it may not. If this occurs audiohooks will now
+	  immediately return and not act on the frame.
+
+	  As well for users of ast_trans_frameout the function has
+	  been changed to be a bit more sane and ensure that the data
+	  pointer on a frame is set to NULL if no data is actually
+	  on the frame. This allows the various spots in Asterisk that
+	  check for an interpolated frame based on the presence of a
+	  data pointer to work as expected.
+
+	  ASTERISK-26926
+
+	  Change-Id: I7fa22f631fa28d540722ed789ce28e84c7f8662b
+
+2017-04-21 12:04 +0000 [1b50df78d0]  Sean Bright <sean.bright@gmail.com>
+
+	* cleanup: Fix fread() and fwrite() error handling
+
+	  Cleaned up some of the incorrect uses of fread() and fwrite(), mostly in
+	  the format modules. Neither of these functions will ever return a value
+	  less than 0, which we were checking for in some cases.
+
+	  I've introduced a fair amount of duplication in the format modules, but
+	  I plan to change how format modules work internally in a subsequent
+	  patch set, so this is simply a stop-gap.
+
+	  Change-Id: I8ca1cd47c20b2c0b72088bd13b9046f6977aa872
+
+2017-04-25 07:52 +0000 [c09b9dba90]  Joshua Colp <jcolp@digium.com>
+
+	* alembic: Add table for 'resource_list' PJSIP RLS type.
+
+	  This change adds an Alembic migration which adds a
+	  ps_resource_list table that can contain resource_list
+	  RLS configuration objects.
+
+	  ASTERISK-26929
+
+	  Change-Id: I7c888fafc67b3e87012de974f71ca7a5b8b1ec05
+
+2017-04-24 13:16 +0000 [1b88a3a4cf]  Sean Bright <sean.bright@gmail.com>
+
+	* res_hep: Add additional config initialization and validation
+
+	  * Initialize hepv3_runtime_data.sockfd to -1 so that our ao2 destructor
+	    does not close fd 0
+
+	  * Add logging output when the required option - capture_address - is not
+	    specified.
+
+	  * Remove a no longer relevant #define and correct related documentation
+
+	  * Pass appropriate flags to aco_option_register so that capture_address
+	    cannot be the empty string.
+
+	  ASTERISK-26953 #close
+
+	  Change-Id: Ief08441bc6596d6f1718fa810e54a5048124f076
+
+2017-04-17 19:06 +0000 [cea3742c54]  Sean Bright <sean.bright@gmail.com>
+
+	* core: Use eventfd for alert pipes on Linux when possible
+
+	  The primary win of switching to eventfd when possible is that it only
+	  uses a single file descriptor while pipe() will use two. This means for
+	  each bridge channel we're reducing the number of required file
+	  descriptors by 1, and - if you're using timerfd - we also now have 1
+	  less file descriptor per Asterisk channel.
+
+	  The API is not ideal (passing int arrays), but this is the cleanest
+	  approach I could come up with to maintain API/ABI.
+
+	  I've also removed what I believe to be an erroneous code block that
+	  checked the non-blocking flag on the pipe ends for each read. If the
+	  file descriptor is 'losing' its non-blocking mode, it is because of a
+	  bug somewhere else in our code.
+
+	  In my testing I haven't seen any measurable difference in performance.
+
+	  Change-Id: Iff0fb1573e7f7a187d5211ddc60aa8f3da3edb1d
+
+2017-04-21 12:33 +0000 [1213ac1ac5]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Send 100 Trying out earlier to prevent retransmissions.
+
+	  If ICE is enabled and a STUN server does not respond then we will block
+	  until we give up on the STUN response.  This will take nine seconds.  In
+	  the mean time the peer that sent the INVITE will send retransmissions.
+
+	  * Restructure res_pjsip_session.c:new_invite() to send a 100 Trying out
+	  earlier to prevent these retransmissions.
+
+	  ASTERISK-26890
+
+	  Change-Id: Ie3fc611e53a0eff6586ad55e4aacad81cf6319a8
+
+2017-04-21 12:07 +0000 [80fd7fd908]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Restructure ast_sip_session_alloc()
+
+	  * Restructure ast_sip_session_alloc() to need less cleanup on off nominal
+	  error paths.
+
+	  * Made ast_sip_session_alloc() and ast_sip_session_create_outgoing() avoid
+	  unnecessary ref manipulation to return a session.  This is faster than
+	  calling a function.  That function may do logging of the ref changes with
+	  REF_DEBUG enabled.
+
+	  Change-Id: I2a0affc4be51013d3f0485782c96b8fee3ddb00a
+
+2017-04-19 15:08 +0000 [98e38daf82]  Sean Bright <sean.bright@gmail.com>
+
+	* pbx: Use same thread if AST_OUTGOING_WAIT_COMPLETE specified
+
+	  Both ast_pbx_outgoing_app() and ast_pbx_outgoing_exten() cause the core
+	  to spawn a new thread to perform the dial. When AST_OUTGOING_WAIT_COMPLETE
+	  is passed to these functions, the calling thread will be blocked until
+	  the newly created channel has been hung up.
+
+	  After this patch, we run the dial on the current thread rather than
+	  spawning a new one. The only in-tree code that passes
+	  AST_OUTGOING_WAIT_COMPLETE is pbx_spool, so you should see reduced
+	  thread usage if you are using .call files.
+
+	  Change-Id: I512735d243f0a9da2bcc128f7a96dece71f2d913
+
+2017-04-19 13:23 +0000 [55f452884f]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_rtp_asterisk.c: Fix crash in RTCP DTLS operation.
+
+	  Occasionally a crash happens when processing the RTCP DTLS timeout
+	  handler.  The RTCP DTLS timeout timer could be left running if we have not
+	  completed the DTLS handshake before we place the call on hold or we
+	  attempt direct media.
+
+	  * Made ast_rtp_prop_set() stop the RTCP DTLS timer when disabling RTCP.
+
+	  * Made some sanity tweaks to ast_rtp_prop_set() when switching from
+	  standard RTCP mode to RTCP multiplexed mode.
+
+	  ASTERISK-26692 #close
+
+	  Change-Id: If6c64c79129961acfa4b3d63a864e8f6b664acc0
+
+2017-03-22 16:05 +0000 [f856cfbb51]  Richard Mudgett <rmudgett@digium.com>
+
+	* rtp_engine/res_rtp_asterisk: Fix RTP struct reentrancy crashes.
+
+	  The struct ast_rtp_instance has historically been indirectly protected
+	  from reentrancy issues by the channel lock because early channel drivers
+	  held the lock for really long times.  Holding the channel lock for such a
+	  long time has caused many deadlock problems in the past.  Along comes
+	  chan_pjsip/res_pjsip which doesn't necessarily hold the channel lock
+	  because sometimes there may not be an associated channel created yet or
+	  the channel pointer isn't available.
+
+	  In the case of ASTERISK-26835 a pjsip serializer thread was processing a
+	  message's SDP body while another thread was reading a RTP packet from the
+	  socket.  Both threads wound up changing the rtp->rtcp->local_addr_str
+	  string and interfering with each other.  The classic reentrancy problem
+	  resulted in a crash.
+
+	  In the case of ASTERISK-26853 a pjsip serializer thread was processing a
+	  message's SDP body while another thread was reading a RTP packet from the
+	  socket.  Both threads wound up processing ICE candidates in PJPROJECT and
+	  interfering with each other.  The classic reentrancy problem resulted in a
+	  crash.
+
+	  * rtp_engine.c: Make the ast_rtp_instance_xxx() calls lock the RTP
+	  instance struct.
+
+	  * rtp_engine.c: Make ICE and DTLS wrapper functions to lock the RTP
+	  instance struct for the API call.
+
+	  * res_rtp_asterisk.c: Lock the RTP instance to prevent a reentrancy
+	  problem with rtp->rtcp->local_addr_str in the scheduler thread running
+	  ast_rtcp_write().
+
+	  * res_rtp_asterisk.c: Avoid deadlock when local RTP bridging in
+	  bridge_p2p_rtp_write() because there are two RTP instance structs
+	  involved.
+
+	  * res_rtp_asterisk.c: Avoid deadlock when trying to stop scheduler
+	  callbacks.  We cannot hold the instance lock when trying to stop a
+	  scheduler callback.
+
+	  * res_rtp_asterisk.c: Remove the lock in struct dtls_details and use the
+	  struct ast_rtp_instance ao2 object lock instead.  The lock was used to
+	  synchronize two threads to prevent a race condition between starting and
+	  stopping a timeout timer.  The race condition is no longer present between
+	  dtls_perform_handshake() and __rtp_recvfrom() because the instance lock
+	  prevents these functions from overlapping each other with regards to the
+	  timeout timer.
+
+	  * res_rtp_asterisk.c: Remove the lock in struct ast_rtp and use the struct
+	  ast_rtp_instance ao2 object lock instead.  The lock was used to
+	  synchronize two threads using a condition signal to know when TURN
+	  negotiations complete.
+
+	  * res_rtp_asterisk.c: Avoid deadlock when trying to stop the TURN
+	  ioqueue_worker_thread().  We cannot hold the instance lock when trying to
+	  create or shut down the worker thread without a risk of deadlock.
+
+	  This patch exposed a race condition between a PJSIP serializer thread
+	  setting up an ICE session in ice_create() and another thread reading RTP
+	  packets.
+
+	  * res_rtp_asterisk.c:ice_create(): Set the new rtp->ice pointer after we
+	  have re-locked the RTP instance to prevent the other thread from trying to
+	  process ICE packets on an incomplete ICE session setup.
+
+	  A similar race condition is between a PJSIP serializer thread resetting up
+	  an ICE session in ice_create() and the timer_worker_thread() processing
+	  the completion of the previous ICE session.
+
+	  * res_rtp_asterisk.c:ast_rtp_on_ice_complete(): Protect against an
+	  uninitialized/null remote_address after calling
+	  update_address_with_ice_candidate().
+
+	  * res_rtp_asterisk.c: Eliminate the chance of ice_reset_session()
+	  destroying and setting the rtp->ice pointer to NULL while other threads
+	  are using it by adding an ao2 wrapper around the PJPROJECT ice pointer.
+	  Now when we have to unlock the RTP instance object to call a PJPROJECT ICE
+	  function we will hold a ref to the wrapper.  Also added some rtp->ice NULL
+	  checks after we relock the RTP instance and have to do something with the
+	  ICE structure.
+
+	  ASTERISK-26835 #close
+	  ASTERISK-26853 #close
+
+	  Change-Id: I780b39ec935dcefcce880d50c1a7261744f1d1b4
+
+2017-04-19 08:39 +0000 [dafcd97a77]  Sean Bright <sean.bright@gmail.com>
+
+	* build: Update config.guess and config.sub
+
+	  Change-Id: Id078a1df07a771808775e1053cdfe1d99c8fb172
+
+2017-04-14 13:52 +0000 [9bbfa6fda1]  Sean Bright <sean.bright@gmail.com>
+
+	* format_wav: Read 16khz wav samples properly
+
+	  When opening a PCM wave file for reading, we aren't tracking the
+	  frequency of the opened file, so we treat 16khz files as 8khz and do
+	  half reads.
+
+	  This patch also cleans up some of the data types and an unnecessarily
+	  complex `if` expression.
+
+	  ASTERISK-26613 #close
+	  Reported by: Vitaly K
+
+	  Change-Id: I05f8b263058dc573ea8ffe0c62e7964506e11815
+
+2017-04-16 19:54 +0000 [4ccaffe644]  gtjoseph <gjoseph@digium.com>
+
+	* make ari-stubs so doc periodic jobs can run
+
+	  The periodic doc job does a make ari-stubs and checks that
+	  there are no changes before generating the docs.  Since I changed
+	  the mustache template (and the generated code directly) recently
+	  and forgot to regenerate the stubs, the doc job thinks they're out
+	  of date.
+
+	  Change-Id: Ibd4bc649556615ff714d44534c45b6c2f6aa449d
+
+2017-04-14 12:51 +0000 [90c630aaa1]  Sean Bright <sean.bright@gmail.com>
+
+	* format_ogg_vorbis: Clear ogg/vorbis data structures on close
+
+	  On filestream close, we need to clear out the ogg & vorbis data
+	  structures to prevent a memory leak.
+
+	  ASTERISK-26169 #close
+	  Reported by: Ivan Myalkin
+
+	  Change-Id: Iee94c5a5d5bdafbf8b181c5c064d15d90ace8274
+
+2017-04-14 17:31 +0000 [9084c85cb1]  Richard Mudgett <rmudgett@digium.com>
+
+	* Revert "bridging:  Ensure successful T.38 negotation"
+
+	  This reverts commit 3e7c396a51b240088c475dd53e7bac9869376129.
+
+	  Change-Id: I61d49d563babff788bb557345729b200d116bd88
+
+2017-04-14 16:50 +0000 [357d1fbdcc]  Sean Bright <sean.bright@gmail.com>
+
+	* res_stun_monitor: Don't fail to load if DNS resolution fails
+
+	  res_stun_monitor will fail to load if DNS resolution of the STUN server
+	  fails. Instead, we continue without the STUN server being resolved and
+	  we will re-attempt the resolution on the STUN refresh interval.
+
+	  ASTERISK-21856 #close
+	  Reported by: Jeremy Kister
+
+	  Change-Id: I6334c54a1cc798f8a836b4b47948e0bb4ef59254
+
+2017-04-14 14:36 +0000 [ac15ebc379]  Roman S.
+
+	* format_pcm: Track actual header size of .au files
+
+	  Sun's Au file format has a minimum data offset 24 bytes, but this
+	  offset is encoded in each .au file. Instead of assuming the minimum,
+	  read the actual value and store it for later use.
+
+	  ASTERISK-20984 #close
+	  Reported by: Roman S.
+	  Patches:
+	  	asterisk-1.8.20.0-au-clicks-2.diff (license #6474) patch
+	  	uploaded by Roman S.
+
+	  Change-Id: I524022fb19ff2fd5af2cc2d669d27a780ab2057c
+
+2017-04-11 11:07 +0000 [f882ca2572]  gtjoseph <gjoseph@digium.com>
+
+	* modules:  change module LOAD_FAILUREs to LOAD_DECLINES
+
+	  In all non-pbx modules, AST_MODULE_LOAD_FAILURE has been changed
+	  to AST_MODULE_LOAD_DECLINE.  This prevents asterisk from exiting
+	  if a module can't be loaded.  If the user wishes to retain the
+	  FAILURE behavior for a specific module, they can use the "require"
+	  or "preload-require" keyword in modules.conf.
+
+	  A new API was added to logger: ast_is_logger_initialized().  This
+	  allows asterisk.c/check_init() to print to the error log once the
+	  logger subsystem is ready instead of just to stdout.  If something
+	  does fail before the logger is initialized, we now print to stderr
+	  instead of stdout.
+
+	  Change-Id: I5f4b50623d9b5a6cb7c5624a8c5c1274c13b2b25
+
+2017-04-07 16:14 +0000 [cd80af508e]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_rtp_asterisk.c: Add stun_blacklist option
+
+	  Added the stun_blacklist option to rtp.conf.  Some multihomed servers have
+	  IP interfaces that cannot reach the STUN server specified by stunaddr.
+	  Blacklist those interface subnets from trying to send a STUN packet to
+	  find the external IP address.  Attempting to send the STUN packet
+	  needlessly delays processing incoming and outgoing SIP INVITEs because we
+	  will wait for a response that can never come until we give up on the
+	  response.  Multiple subnets may be listed.
+
+	  ASTERISK-26890 #close
+
+	  Change-Id: I3ff4f729e787f00c3e6e670fe6435acce38be342
+
+2017-04-06 17:31 +0000 [f8219a2e12]  Richard Mudgett <rmudgett@digium.com>
+
+	* stun.c: Fix ast_stun_request() erratic timeout.
+
+	  If ast_stun_request() receives packets other than a STUN response then we
+	  could conceivably never exit if we continue to receive packets with less
+	  than three seconds between them.
+
+	  * Fix poll timeout to keep track of the time when we sent the STUN
+	  request.  We will now send a STUN request every three seconds regardless
+	  of how many other packets we receive while waiting for a response until we
+	  have completed three STUN request transmission cycles.
+
+	  Change-Id: Ib606cb08585e06eb50877f67b8d3bd385a85c266
+
+2017-04-06 18:30 +0000 [19b82a8644]  Richard Mudgett <rmudgett@digium.com>
+
+	* sorcery.c: Speed up ast_sorcery_retrieve_by_id()
+
+	  Return early if ast_sorcery_retrieve_by_id() is not passed an id to find.
+	  Also eliminated the RAII_VAR() usage in the function.
+
+	  Change-Id: I871dbe162a301b5ced8b4393cec27180c7c6b218
+
+2017-04-10 11:30 +0000 [aecf19e7d2]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Fix pointer use after unref.
+
+	  Change-Id: I4b6e1b0070563eeaee223cb58326f1b962ed5bc1
+
+2017-04-06 18:18 +0000 [304f652cda]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_sdp_rtp.c: Don't use deprecated transport struct member.
+
+	  * create_rtp(): Eliminate use of deprecated transport struct member.  That
+	  member and several others in the transport structure were deprecated
+	  because of an infinite loop created when using realtime configuration.
+	  See 2451d4e4550336197ee2e482750cc53f30afa352
+
+	  ASTERISK-26851
+
+	  Change-Id: I0533aa13c9ce3c6cc394e0fd2b5bf1cd1b2ef3bc
+
+2017-04-10 17:45 +0000 [bb8cd2add7]  Richard Mudgett <rmudgett@digium.com>
+
+	* tcptls.c: Cleanup TCP/TLS listener thread on abnormal exit.
+
+	  Temporarily running out of file descriptors should not terminate the
+	  listener thread.  Otherwise, when there becomes more file descriptors
+	  available, nothing is listening.
+
+	  * Added EMFILE exception to abnormal thread exit.
+
+	  * Added an abnormal TCP/TLS listener exit error message.
+
+	  * Closed the TCP/TLS listener socket on abnormal exit so Asterisk does not
+	  appear dead if something tries to connect to the socket.
+
+	  ASTERISK-26903 #close
+
+	  Change-Id: I10f2f784065136277f271159f0925927194581b5
+
+2017-04-07 08:58 +0000 [d8967ff2c0]  Torrey Searle <torrey@voxbone.com>
+
+	* strings.h:  Avoid overflows in the string hash functions
+
+	  On 2's compliment machines abs(INT_MIN) behavior is undefined and
+	  results in a negative value still being returnd.  This results in
+	  negative hash codes that can result in crashes.
+
+	  ASTERISK-26528 #close
+
+	  Change-Id: Idff550145ca2133792a61a2e212b4a3e82c6517b
+
+2017-04-08 03:05 +0000 [bbbd262ec0]  Walter Doekes <walter+github@wjd.nu>
+
+	* samples: Undo removal of include from canonicalize-app-names commit.
+
+	  This include was accidentally removed in changeset
+	  Ia79aea64de89531362e993e34230c2044a70aa93. My bad.
+
+	  Change-Id: I1d716c7f9590b4e97909fb8bca1f2ed9bd0e4082
+
+2017-04-07 08:35 +0000 [b3f4a6365e]  Joshua Colp <jcolp@digium.com>
+
+	* pjsip: Add Alembic for PUBLISH support.
+
+	  This change adds database tables for the PUBLISH support so it
+	  can be configured using realtime. A minor fix to the
+	  res_pjsip_publish_asterisk module was done so that it read the
+	  sorcery configuration from the correct section. Finally the
+	  sample configuration files have been updated.
+
+	  ASTERISK-26928
+
+	  Change-Id: I81991ae5c75af98d247f7eacd1c0b0a763675952
+
+2017-04-07 08:06 +0000 [e0e5a337fd]  Alexander Traud <pabstraud@compuserve.com>
+
+	* pjproject_bundled: Crash on pj_ssl_get_info() while ioqueue_on_read_complete().
+
+	  When the Asterisk channel driver res_pjsip offers SIP-over-TLS, sometimes, not
+	  reproducible, Asterisk crashed in pj_ssl_sock_get_info() because a NULL pointer
+	  was read. This change avoids this crash.
+
+	  ASTERISK-26927 #close
+
+	  Change-Id: I24a6011b44d1426d159742ff4421cf806a52938b
+
+2017-04-05 06:41 +0000 [3e7c396a51]  Torrey Searle <torrey@voxbone.com>
+
+	* bridging:  Ensure successful T.38 negotation
+
+	  When a T.38 happens immediatly after call establishment, the control
+	  frame can be lost because the other leg is not yet in the bridge.
+
+	  This patch detects this case an makes sure T.38 negotation happens
+	  when the 2nd leg is being made compatible with the negotating
+	  first leg
+
+	  ASTERISK-26923 #close
+
+	  Change-Id: If334125ee61ed63550d242fc9efe7987e37e1d94
+
+2017-04-04 16:20 +0000 [4e6e069491]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled: Add 3 upstream patches
+
+	  0035-r5572-svn-backport-dialog-transaction-deadlock.patch
+	  0036-r5573-svn-backport-ua-pjsua-transaction-deadlock.patch
+	  0037-r5576-svn-backport-session-timer-crash.patch
+
+	  Also removed the progress bar from wget download to stdout.
+
+	  ASTERISK-26905 #close
+	  Reported-by: Ross Beer
+
+	  Change-Id: I268fb3cf71a3bb24283ff0d24bd8b03239d81256
+
+2017-04-05 14:50 +0000 [d2a33cdedc]  gtjoseph <gjoseph@digium.com>
+
+	* sample_config:  Add samples for pubsub to pjsip.conf.sample
+
+	  Added:
+	   * outbound-publish
+	   * resource_list
+	   * inbound-publication
+	   * asterisk-publication
+
+	  Change-Id: I65043a896c35483f30a92d30b5b118359af7ba5a
+
+2017-04-05 09:10 +0000 [ab9d2fc86d]  Walter Doekes <walter+github@wjd.nu>
+
+	* samples: Canonicalize app names in extensions.conf.sample.
+
+	  This takes care of warnings by ossobv/asterisklint.
+
+	  Change-Id: Ia79aea64de89531362e993e34230c2044a70aa93
+
+2017-04-03 15:38 +0000 [6906765381]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_sdp_rtp.c: Don't alter global addr variable.
+
+	  * create_rtp(): Fix unexpected alteration of global address_rtp if a
+	  transport is bound to an address.
+
+	  * create_rtp(): Fix use of uninitialized memory if the endpoint RTP media
+	  address is invalid or the transport has an invalid address.
+
+	  ASTERISK-26851
+
+	  Change-Id: Icde42e65164a88913cb5c2601b285eebcff397b7
+
+2017-03-27 09:03 +0000 [68bde0f07d]  Corey Farrell <git@cfware.com>
+
+	* CDR: Protect from data overflow in ast_cdr_setuserfield.
+
+	  ast_cdr_setuserfield wrote to a fixed length field using strcpy. This could
+	  result in a buffer overrun when called from chan_sip or func_cdr. This patch
+	  adds a maximum bytes written to the field by using ast_copy_string instead.
+
+	  ASTERISK-26897 #close
+	  patches:
+	    0001-CDR-Protect-from-data-overflow-in-ast_cdr_setuserfie.patch submitted
+	      by Corey Farrell (license #5909)
+
+	  Change-Id: Ib23ca77e9b9e2803a450e1206af45df2d2fdf65c
+
+2017-03-25 19:01 +0000 [70e5a2655d]  Daniel Journo <dan@keshercommunications.com>
+
+	* Unused realtime MOH classes not purged on 'moh reload'
+
+	  Purge Realtime MOH classes on 'moh reload' even when musiconhold.conf
+	  hasn't changed.
+
+	  ASTERISK-25974 #close
+
+	  Change-Id: I42c78ea76528473a656f204595956c9eedcf3246
+
+2017-04-03 13:56 +0000 [27b556778d]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Fix transport ref leak.
+
+	  We were leaking a transport ref in multihomed_on_rx_message() which
+	  resulted in the FRACK about excessive ref counts.
+
+	  ASTERISK-26916 #close
+
+	  Change-Id: I7a96658a9614a060565bb9ad51cb1c9c11ee145f
+
+2017-04-03 02:30 +0000 [94bd529f9e]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Session Timers required but refused wrongly.
+
+	  SIP user-agents indicate which protocol extensions are allowed in headers
+	  like Supported and Required. Such protocol extensions are Session Timers
+	  (RFC 4028) for example. Session Timers are supported since Mantis-10665.
+	  Since ASTERISK-21721, not only the first but multiple Supported/Required
+	  headers in a message are parsed. In that change, an existing variable was
+	  re-used within a newly added do-loop. Currently, at the end of that loop,
+	  that variable is an empty string always. Previously, that variable was used
+	  within log output. However, the log output was not changed.
+
+	  ASTERISK-26915 #close
+
+	  Change-Id: I09315f31b4d78fb214bb2a9fb6c0f5e143eae990
+
+2017-03-31 16:31 +0000 [bca9685d39]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_session: Allow BYE to be sent on disconnected session.
+
+	  It is perfectly acceptable for a BYE to be sent on a disconnected
+	  session. This occurs when we respond to a challenge to the BYE
+	  for authentication credentials.
+
+	  ASTERISK-26363
+
+	  Change-Id: I6ef0ddece812fea6665a1dd2549ef44fb9d90045
+
+2017-03-30 18:28 +0000 [c701550803]  Corey Farrell <git@cfware.com>
+
+	* Forward declare 'struct ast_json' in asterisk.h
+
+	  The ast_json structure is used in many Asterisk headers and is often the
+	  only part of json.h used.  This adds a forward declaration to asterisk.h
+	  and removes the include of json.h from many headers.  The declaration
+	  has been left in endpoints.h and stasis.h to avoid problems with source
+	  files that use ast_json functions without directly including json.h.
+
+	  ari.h continues to include json.h as it uses enum
+	  ast_json_encoding_format.
+
+	  Change-Id: Id766aabce6bed56626d27e8d29f559b5e687b769
+
+2017-03-30 08:11 +0000 [754e99d517]  Sean Bright <sean.bright@gmail.com>
+
+	* cdr_pgsql: Fix buffer overflow calling libpq
+
+	  Implement the same buffer size checking done in cel_pgsql.
+
+	  ASTERISK-26896 #close
+	  Reported by: twisted
+
+	  Change-Id: Iaacfa1f1de7cb1e9414d121850d2d8c2888f3f48
+
+2017-03-28 13:01 +0000 [7954b39a50]  Walter Doekes <walter+github@wjd.nu>
+
+	* build: Fix deb build issues with fakeroot
+
+	  If DESTDIR is set, don't call ldconfig. Assume that DESTDIR is used to
+	  create a binary archive. The ldconfig call should be delegated to the
+	  archive postinst script. This fixes the case where fakeroot wraps 'make
+	  install' causing $EUID to be 0 even though it doesn't have permission to
+	  call ldconfig.
+
+	  The previous logic in configure.ac to detect and correct libdir
+	  has been removed as it was not completely accurate.  CentOS 64-bit
+	  users should again specifiy --libdir=/usr/lib64 when configuring
+	  to prevent install to /usr/lib.
+
+	  Updated Makefile:check-old-libdir to check for orphans in
+	  lib64 when installing to lib as well as orphans in lib when installing
+	  to lib64.
+
+	  Updated Makefile and main/Makefile uninstall targets to remove the
+	  orphans using the new logic.
+
+	  ASTERISK-26705
+
+	  Change-Id: I51739d4a03e60bff38be719b8d2ead0007afdd51
+
+2017-03-29 10:11 +0000 [c9648f4690]  Sean Bright <sean.bright@gmail.com>
+
+	* astobj2: Prevent potential deadlocks with ao2_global_obj_release
+
+	  The ao2_global_obj_release() function holds an exclusive lock on the
+	  global object while it is being dereferenced. Any destructors that
+	  run during this time that call ao2_global_obj_ref() will deadlock
+	  because a read lock is required.
+
+	  Instead, we make the global object inaccessible inside of the write
+	  lock and only dereference it once we have released the lock. This
+	  allows the affected destructors to fail gracefully.
+
+	  While this doesn't completely solve the referenced issue (the error
+	  message about not being able to create an IQ continues to be shown)
+	  it does solve the backtrace spew that accompanied it.
+
+	  ASTERISK-21009 #close
+	  Reported by: Marcello Ceschia
+
+	  Change-Id: Idf40ae136b5070dba22cb576ea8414fbc9939385
+
+2017-03-30 11:57 +0000 [1d1309b1ed]  Joshua Colp <jcolp@digium.com>
+
+	* Revert "Update for 13.15.0-rc1"
+
+	  This reverts commit 552cf009c0939c8b6597708135412bdc596df4bb.
+
+	  Change-Id: Ie345bea481261b761c44079e9472622040fda302
+
+2017-03-30 10:18 +0000 [3c23ebdef4]  Corey Farrell <git@cfware.com>
+
+	* CEL: Remove header declarations of non-existant functions.
+
+	  ast_cel_alloc and ast_cel_destroy do not exist in code, remove them from
+	  the headers.
+
+	  Change-Id: I99ce848e2e109e7d61771559f559b9e57973e45c
+
+2017-03-29 08:27 +0000 [ef19db9261]  Alexander Traud <pabstraud@compuserve.com>
+
+	* srtp: Allow zero as tag value for a sRTP Crypto Suite.
+
+	  ASTERISK-25490 #close
+
+	  Change-Id: I1c5fc0942c33c96d62b24203aad0f1e1a1a0131f
+
+2017-03-28 13:10 +0000 [a827892ff7]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_config_wizard: Add 2 new parameters to help with proxy config
+
+	  Two new parameters have been added to the pjsip config wizard.
+
+	   * Setting 'sends_line_with_registrations' to true will cause the wizard
+	     to skip the creation of an identify object to match incoming request
+	     to the endpoint and instead add the line and endpoint parameters to
+	     the outbound registration object.
+
+	   * Setting 'outbound_proxy' is a shortcut for adding individual
+	     endpoint/outbound_proxy, aor/outbound_proxy and
+	     registration/outbound_proxy parameters.
+
+	  Change-Id: I678e5f80765734c056620528a6d40d82736ceeb0
+
+2017-03-28 09:29 +0000 [864dda07f3]  Sean Bright <sean.bright@gmail.com>
+
+	* alembic: Turn off execute bit on non-executable python scripts
+
+	  Change-Id: I744c986da4a38aeff8c00837eb89de7841fbc86c
+
+2017-03-27 12:37 +0000 [a9529cbb21]  Richard Mudgett <rmudgett@digium.com>
+
+	* Add DTLS sanity check.
+
+	  Change-Id: Ib32612cf6c7ce9213a11b9cba82f630f8cd3564b
+
+2017-03-27 11:49 +0000 [bb68f57a03]  Josh Roberson <josh@asteriasgi.com>
+
+	* cel_pgsql.c: Fix buffer overflow calling libpq
+
+	  PQEscapeStringConn() expects the buffer passed in to be an
+	  adequitely sized buffer to write out the escaped SQL value string
+	  into.  It is possible, for large values (such as large values to
+	  Dial with a lot of devices) to have more than our 512+1 byte
+	  allocation and thus cause libpq to create a buffer overrun.
+
+	  glibc will nicely ABRT asterisk for you, citing a stack smash.
+
+	  Let's only allocate it to be as large as needed:
+	  If we have a value, then (strlen(value) * 2) + 1 (as recommended
+	  by libpq), and if we have none, just one byte to hold our null
+	  will do.
+
+	  ASTERISK-26896 #close
+
+	  Change-Id: If611c734292618ed68dde17816d09dd16667dea2
+
+2017-03-24 07:43 +0000 [79a2c26c03]  Sean Bright <sean.bright@gmail.com>
+
+	* core: Remove embedded module support
+
+	  This has not worked for some time and is no longer actively maintained.
+
+	  Change-Id: I5110b0db69c152761b58fa025cb0a53b0e544d99
+
+2017-03-27 09:35 +0000 [2c28f7a922]  Sean Bright <sean.bright@gmail.com>
+
+	* res_musiconhold: Document the 'format' option
+
+	  ASTERISK-26086 #close
+	  Reported by: Jens Bürger
+
+	  Change-Id: I6aab666c0bf01fd0c64d7a5bcb22fa7f5d41335e
+
+2017-03-27 08:58 +0000 [61fd70c250]  Sean Bright <sean.bright@gmail.com>
+
+	* res_musiconhold: Don't chdir() when scanning MoH files
+
+	  There doesn't appear to be any reason that we are chdir'ing in
+	  moh_scan_files, and in the event of an Asterisk crash, the core files
+	  may not get written because we have changed into a read-only directory.
+
+	  ASTERISK-23996 #close
+	  Reported by: Walter Doekes
+
+	  Change-Id: Iac806dce01b3335963fbd62d4b4da9a65c614354
+
+2017-03-23 09:48 +0000 [73bb08fd6a]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Use incremental backoff when a read error occurs
+
+	  If a read error occurs, we immediately attempt a reconnect without any
+	  delay. Instead, let's sleep and backoff up to 60 seconds before we try
+	  again.
+
+	  ASTERISK-24712 #close
+	  Reported by: Matthias Urlichs
+
+	  Change-Id: I6fe10ef4734837727437beab715e336777f13f48
+
+2017-03-23 05:19 +0000 [55693383e2]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Fix ref counting issue
+
+	  The only remaining reference to the endpoint is in the endpoints
+	  container, and because it is unlinked in ast_endpoint_shutdown, we don't
+	  have to explicitly cleanup the endpoint ourselves.
+
+	  Change-Id: I912a2692e52d3e2ed445b32d8ae3f9004bc2f2e8
+
+2017-03-23 09:45 +0000 [1966265562]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Try to provide useful errors messages from OpenSSL
+
+	  If any errors occur during the TLS connection setup, we currently dump a
+	  fairly generic error message. So instead we try to pull in something
+	  useful from OpenSSL to report instead.
+
+	  ASTERISK-24712
+	  Reported by: Matthias Urlichs
+
+	  Change-Id: I288500991a9681f447d92913b11fedaf426087f4
+
+2017-03-23 09:30 +0000 [03b99ae3d2]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Correctly check return value of SSL_connect
+
+	  SSL_connect returns non-zero for both success and some error conditions
+	  so simply negating is inadequate.
+
+	  Change-Id: Ifbf882896e598703b6c615407fa456d3199f95b1
+
+2017-03-24 11:29 +0000 [d9d2beba1c]  Sean Bright <sean.bright@gmail.com>
+
+	* res_pjsip_sdp_rtp: Set hangup cause for RTP timeouts
+
+	  chan_sip sets the hangup cause code to AST_CAUSE_REQUESTED_CHAN_UNAVAIL
+	  (44) when a channel is hung up due to an RTP timeout. So do the same
+	  when it happens with PJSIP for parity.
+
+	  Change-Id: I3546ebbde6460c22a27c9da1bf321711b5961ab8
+
+2017-03-23 12:07 +0000 [e6aeeabddf]  Kevin Harwell <kharwell@digium.com>
+
+	* pjproject_bundled: raise timeout value used when downloading
+
+	  After configuring Asterisk with '--with-pjproject-bundled' the configure/build
+	  process attempts to download pjproject from its download site. Currently, a
+	  timeout of 10 seconds is used that will stop the download process if pjproject
+	  has not been fully downloaded in that time. For some systems this was not enough
+	  time and the process was timing out too early.
+
+	  This patch raises the download timeout value to '60'. Also, this patch fixes
+	  another bug where the DOWNLOAD_TIMEOUT variable was not being properly exported
+	  due to a naming error. DOWNLOAD_MAX_TIMEOUT is now properly renamed to
+	  DOWNLOAD_TIMEOUT.
+
+	  ASTERISK-26814 #close
+
+	  Change-Id: Ia56e4e8a3d39db76bc8a1852b2cf07ec10b39842
+
+2017-03-22 20:33 +0000 [0939a19cff]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Correct implementation of JABBER_STATUS & JabberStatus
+
+	  The documentation for JABBER_STATUS (and the deprecated JabberStatus
+	  app) indicate that a return value of 7 indicates that the specified
+	  buddy was not in the roster. It also indicates that you can specify a
+	  "bare" JID (one without a resource). Unfortunately the actual behavior
+	  does not match the documented behavior.
+
+	  Assuming that our roster includes the buddy online and available
+	  "valid@example.org/Valid" and does *not* include the buddy
+	  "invalid@example.org", the JABBER_STATUS() function returns the
+	  following before this patch:
+
+	  +------------------------------+------------+--------------------------+
+	  | Buddy                        | Status     | Result                   |
+	  +------------------------------+------------+--------------------------+
+	  | valid@example.org            |  Online    |  7 (Not in roster)       |
+	  | valid@example.org/Valid      |  Online    |  1 (Online)              |
+	  | valid@example.org/Invalid    |  N/A       |  7 (Not in roster)       |
+	  | invalid@example.org          |  N/A       |  Error logged, no return |
+	  | invalid@example.org/Valid    |  N/A       |  Error logged, no return |
+	  +------------------------------+------------+--------------------------+
+
+	  And after this patch:
+
+	  +------------------------------+------------+--------------------------+
+	  | Buddy                        | Status     | Result                   |
+	  +------------------------------+------------+--------------------------+
+	  | valid@example.org            |  Online    |  1 (Online)              |
+	  | valid@example.org/Valid      |  Online    |  1 (Online)              |
+	  | valid@example.org/Invalid    |  N/A       |  6 (Offline)             |
+	  | invalid@example.org          |  N/A       |  7 (Not in roster)       |
+	  | invalid@example.org/Valid    |  N/A       |  7 (Not in roster)       |
+	  +------------------------------+------------+--------------------------+
+
+	  This brings the behavior in line with the documentation.
+
+	  ASTERISK-23510 #close
+	  Reported by: Anthony Critelli
+
+	  Change-Id: I9c3241035363ef4a6bdc21fabfd8ffcd9ec657bf
+
+2017-03-22 17:32 +0000 [a487f6fb97]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Don't crash when trying to send a message without a connection
+
+	  If we never establish a connection to our Jabber server, iksemel never sets up
+	  its internal transport pointer, so attempting to send a message dereferences a
+	  NULL pointer and causes a crash.
+
+	  ASTERISK-21855 #close
+	  Reported by: Jeremy Kister
+
+	  Change-Id: I204a568894e4a53ab929783ecc594a000f04d79c
+
+2017-03-22 15:40 +0000 [90fb1fca41]  Sean Bright <sean.bright@gmail.com>
+
+	* res_xmpp: Include client name in connection related error messages
+
+	  ASTERISK-25622 #close
+	  Reported by: Sean Darcy
+
+	  Change-Id: I8472cb7bfb58d411a3cfbd482da98cae2d94d1e9
+
+2017-03-21 12:32 +0000 [e196190f11]  Sebastian Gutierrez <sgutierrez@integraccs.com>
+
+	* cdr: Allow setting of user field from 'h' extension
+
+	  The CDR code previously did not allow the user field to be set
+	  from the 'h' extension in the dialplan. This change removes that
+	  limitation and allows it to be set.
+
+	  ASTERISK-26818
+
+	  Change-Id: I0fed8a79b5e408bac4e30542b8f33a61c5ed9aa6
+
+2017-03-14 23:49 +0000 [d5b480afca]  Aaron An <anjb@ti-net.com.cn>
+
+	* audiohook.c: Lost RTP packets lead to out-of-sync MixMonitor.
+
+	  Fixed a bug in function "ast_audiohook_write_frame" that checked the
+	  variable other_factory_samples and only flushed the factories, so they
+	  would be in sync, when other_factory_samples > 0. When there is not any
+	  rtp incoming the variable other_factory_samples will be 0, and although
+	  the result of "our_factory_ms - other_factory_ms" may be very large,
+	  this led to the record file not syncing.
+
+	  ASTERISK-26875 #close
+	  Reported-by: Aaron An
+	  Tested-by: Aaron An
+
+	  Change-Id: Ia4d890fb8fc1636a7188502bab35f555685aea22
+
+2017-03-23 20:33 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.15.0-rc1 Released.
+
+2017-03-23 14:03 +0000 [f1b34e6eb4]  Kevin Harwell <kharwell@digium.com>
+
+	* AMI: Updated version
+
+	  Updated the AMI version for the following reason (see CHANGES for more details):
+
+	  The 'PJSIPShowEndpoint' command's response event of 'IdentifyDetail' now
+	  contains a new optional parameter, 'MatchHeader'.
+
+	  Change-Id: I9aeac4decc89f9b464b3f026e97c7ef1acc79242
+
+2017-03-14 16:45 +0000 [398e5ec16c]  Richard Begg <asterisk@meric.id.au>
+
+	* res_pjsip_session: Enable RFC3578 overlap dialing support.
+
+	  Support for RFC3578 overlap dialling (i.e. 484 Response to partially matched
+	  destinations) as currently provided by chan_sip is missing from res_pjsip.
+	  This patch adds a new endpoint attribute (allow_overlap) [defaults to yes]
+	  which when set to yes enables 484 responses to partial destination
+	  matches rather than the current 404.
+
+	  ASTERISK-26864
+
+	  Change-Id: Iea444da3ee7c7d4f1fde1d01d138a3d7b0fe40f6
+
+2017-03-21 06:59 +0000 [218f618095]  Sean Bright <sean.bright@gmail.com>
+
+	* res_hep: Capture actual transport type in use
+
+	  Rather than hard-coding UDP, allow consumers of the HEP API to specify
+	  which protocol is in use. Update the PJSIP provider to pass in the
+	  current protocol type.
+
+	  ASTERISK-26850 #close
+
+	  Change-Id: I54bbb0a001cfe4c6a87ad4b6f2014af233349978
+
+2017-03-21 09:57 +0000 [1c8b81a2a4]  Sean Bright <sean.bright@gmail.com>
+
+	* Revert "app_queue: Handle the caller being redirected out of a queue bridge"
+
+	  This reverts commit 163e9e53dc7d84dd42721e733b7706c8147bdd27.
+
+	  Change-Id: Ief28479c77a298879dfe2c56be7ee92dc465da4b
+
+2017-03-21 08:26 +0000 [b3cc20799b]  Sean Bright <sean.bright@gmail.com>
+
+	* res_pjsip_messaging: Check URI type before dereferencing
+
+	  We aren't validating that the URI we just parsed is a SIP/SIPS one before
+	  trying to access the user, host, and port members of a possibly uninitialized
+	  structure.
+
+	  Also update the MessageSend documentation to indicate what 'from' formats are
+	  accepted.
+
+	  ASTERISK-26484 #close
+	  Reported by: Vinod Dharashive
+
+	  Change-Id: I476b5cc5f18a7713d0ee945374f2a1c164857d30
+
+2017-03-13 15:21 +0000 [91c97b5da5]  Joshua Elson <joshelson@gmail.com>
+
+	* pjsip: prevent memory corruption on creation of xml bodies
+
+	  ASTERISK-26776 #close
+
+	  Change-Id: I884b6f4e8233a355d0be687ec78d41bc0e4d3fd2
+
+2017-03-20 16:27 +0000 [7f34c11b6a]  Sean Bright <sean.bright@gmail.com>
+
+	* bridge_softmix: Ignore non-voice frames from translator
+
+	  Some codecs - codec_speex specifically - take voice frames and return
+	  other types of frames, like CNG. If we subsequently treat those as
+	  voice frames, we'll run into trouble when destroying the frame because
+	  of the requirement that each voice frame have an associated format.
+
+	  ASTERISK-26880 #close
+	  Reported by: Kirsty Tyerman
+
+	  Change-Id: I43f8450c48fb276ad8b99db8512be82949c1ca7c
+
+2017-03-18 12:30 +0000 [38cebc73a3]  Sean Bright <sean.bright@gmail.com>
+
+	* thread safety: Don't use getprotobyname()
+
+	  POSIX does not require getprotobyname() to be thread safe and some
+	  implementations use static memory which causes issues when multiple
+	  threads are used.
+
+	  Further, our usage of it today is just to ultimately get IPPROTO_TCP
+	  for calls to setsockopt(). So instead we just use IPPROTO_TCP directly.
+
+	  Change-Id: I2e14e58674808f7ce99b2f5e900d0f90d0d8da48
+
+2017-03-19 13:26 +0000 [265455bc2d]  Sean Bright <sean.bright@gmail.com>
+
+	* res_rtp_asterisk: Pass correct data length to ast_rtcp_interpret
+
+	  We are currently passing in the capacity of the read buffer instead of the
+	  number of bytes that we actually read off the wire.
+
+	  Change-Id: I60465049727d955c7f9a5e529e6f2aaff04cda36
+
+2017-03-14 09:27 +0000 [76afb9e18a]  Robert Mordec <r.mordec@slican.pl>
+
+	* app_queue: Member stuck as pending after forwarding previous call from queue
+
+	  Queue member will get stuck in pending_members if queue calls a device
+	  that is different from the one observed for state changes.
+
+	  This patch removes members from pending_members as a result of channel stasis
+	  events such as blind or attended transfers and hangup.
+
+	  ASTERISK-26862 #close
+
+	  Change-Id: I8bf6df487b9bb35726c08049ff25cdad5e357727
+
+2017-02-22 23:26 +0000 [60b372a883]  Richard Mudgett <rmudgett@digium.com>
+
+	* CHANNEL(callid): Give dialplan access to the callid.
+
+	  * Added CHANNEL(callid) to retrieve the call identifier log tag associated
+	  with the channel.  Dialplan now has access to the call log search key
+	  associated with the channel so it can be saved in case there is a problem
+	  with the call.
+
+	  ASTERISK-26878
+
+	  Change-Id: I2c97ebd928b6f3c5bc80c5729e4d3c07f453049f
+
+2017-03-16 08:42 +0000 [9a57b24e17]  Sean Bright <sean.bright@gmail.com>
+
+	* app_queue: Fix locking behavior in stasis message handlers
+
+	  The queue_stasis_data structure contains various mutable fields that require
+	  appropriate locking. Specifically, the 'dying,' 'member_uniqueid,' and
+	  'caller_uniqueid' fields need to be locked when read from or written to.
+
+	  Change-Id: I246b7dbff8447acc957a1299f6ad0ebd0fd39088
+
+2017-03-07 19:28 +0000 [8721d0bf1b]  Sean Bright <sean.bright@gmail.com>
+
+	* chan_sip: Add rtcp-mux support
+
+	  ASTERISK-26846 #close
+
+	  Change-Id: I541a1602ff55ab73684e9f8002edb9e0e745d639
+
+2017-03-16 16:50 +0000 [792171ea9e]  Richard Mudgett <rmudgett@digium.com>
+
+	* app_confbridge: Fix ConfbridgeTalking AMI event description.
+
+	  Thanks to Chris Howard for pointing this out on the wiki.
+
+	  Change-Id: I18e56de09a70e736b5d04719d45ef29cf0636705
+
+2017-03-16 16:37 +0000 [047fb7f11e]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_asterisk.c: Fix compile error if libsrtp is not installed.
+
+	  struct ast_rtcp does not define the dtls member if SRTP is not enabled.
+
+	  ASTERISK-26732
+
+	  Change-Id: Id15ea212e04490e012f2cf4a56818b4dd948875e
+
+2017-03-16 15:45 +0000 [a75f02c089]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_sdp_rtp.c: Fix cut-n-paste error
+
+	  We were inadvertenly referencing the cos_video option to determine if we
+	  should set the tos_audio and cos_audio value on the RTP instance.
+
+	  Change-Id: Ia7964f486801d39dc6f5dae570baff079e1595b0
+
+2017-03-16 10:39 +0000 [776ffd7724]  Matt Jordan <mjordan@digium.com>
+
+	* res/res_pjsip_session: Only check localnet if it is defined
+
+	  If local_net is not defined on a transport, transport_state->localnet
+	  will be NULL. ast_apply_ha will, be default, return AST_SENSE_ALLOW in
+	  this case, causing the external_media_address, if set, to be skipped.
+
+	  This patch causes us to only check if we are sending within a network if
+	  local_net is defined.
+
+	  ASTERISK-26879 #close
+
+	  Change-Id: Ib661c31a954cabc9c99f1f25c9c9a5c5b82cbbfb
+
+2017-03-14 16:22 +0000 [139bc3495f]  Richard Begg <asterisk@meric.id.au>
+
+	* res_pjsip_sdp_rtp: RTP instance does not use same IP as explicit transport
+
+	  Currently a wildcard address is used for the local RTP socket, which
+	  will not always result in the same address as used by the SIP socket
+	  (e.g. if explicit transport addresses are configured).
+	  Use the transport's host address when binding new local RTP sockets if
+	  available.
+
+	  ASTERISK-26851
+
+	  Change-Id: I098c29c9d1f79a4f970d72ba894874ac75954f1a
+
+2017-03-16 09:07 +0000 [7ea7797e12]  Joshua Colp <jcolp@digium.com>
+
+	* res_rtp_asterisk: Fix crash when RTCP is not present when DTLS is stopped.
+
+	  This change removes an assumption that when DTLS is stopped
+	  an RTCP session will be present on the RTP session. This is not
+	  always the case.
+
+	  ASTERISK-26732
+
+	  Change-Id: Ib9f7c09ce0b005efe362dbcc8795202b18f94611
+
+2017-03-07 08:33 +0000 [9b756662a8]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip:  Symmetric transports
+
+	  A new transport parameter 'symmetric_transport' has been added.
+
+	  When a request from a dynamic contact comes in on a transport with
+	  this option set to 'yes', the transport name will be saved and used
+	  for subsequent outgoing requests like OPTIONS, NOTIFY and INVITE.
+	  It's saved as a contact uri parameter named 'x-ast-txp' and will
+	  display with the contact uri in CLI, AMI, and ARI output.  On the
+	  outgoing request, if a transport wasn't explicitly set on the
+	  endpoint AND the request URI is not a hostname, the saved transport
+	  will be used and the 'x-ast-txp' parameter stripped from the
+	  outgoing packet.
+
+	  * config_transport was modified to accept and store the new parameter.
+
+	  * config_transport/transport_apply was updated to store the transport
+	    name in the pjsip_transport->info field using the pjsip_transport->pool
+	    on UDP transports.
+
+	  * A 'multihomed_on_rx_message' function was added to
+	    pjsip_message_ip_updater that, for incoming requests, retrieves the
+	    transport name from pjsip_transport->info and retrieves the transport.
+	    If transport->symmetric_transport is set, an 'x-ast-txp' uri parameter
+	    containing the transport name is added to the incoming Contact header.
+
+	  * An 'ast_sip_get_transport_name' function was added to res_pjsip.
+	    It takes an ast_sip_endpoint and a pjsip_sip_uri and returns a
+	    transport name if endpoint->transport is set or if there's an
+	    'x-ast-txp' parameter on the uri and the uri host is an ipv4 or
+	    ipv6 address.  Otherwise it returns NULL.
+
+	  * An 'ast_sip_dlg_set_transport' function was added to res_pjsip
+	    which takes an ast_sip_endpoint, a pjsip_dialog, and an optional
+	    pjsip_tpselector.  It calls ast_sip_get_transport_name() and if
+	    a non-NULL is returned, sets the selector and sets the transport
+	    on the dialog.  If a selector was passed in, it's updated.
+
+	  * res_pjsip/ast_sip_create_dialog_uac and ast_sip_create_dialog_uas
+	    were modified to call ast_sip_dlg_set_transport() instead of their
+	    original logic.
+
+	  * res_pjsip/create_out_of_dialog_request was modified to call
+	    ast_sip_get_transport_name() and pjsip_tx_data_set_transport()
+	    instead of its original logic.
+
+	  * Existing transport logic was removed from endpt_send_request
+	    since that can only be called after a create_out_of_dialog_request.
+
+	  * res_pjsip/ast_sip_create_rdata was converted to a wrapper around
+	    a new 'ast_sip_create_rdata_with_contact' function which allows
+	    a contact_uri to be specified in addition to the existing
+	    parameters.  (See below)
+
+	  * res_pjsip_pubsub/internal_pjsip_evsub_send_request was eliminated
+	    since all it did was transport selection and that is now done in
+	    ast_sip_create_dialog_uac and ast_sip_create_dialog_uas.
+
+	  * 'contact_uri' was added to subscription_persistence.  This was
+	    necessary because although the parsed rdata contact header has the
+	    x-ast-txp parameter added (if appropriate),
+	    subscription_persistence_update stores the raw packet which
+	    doesn't have it.  subscription_persistence_recreate was then
+	    updated to call ast_sip_create_rdata_with_contact with the
+	    persisted contact_uri so the recreated subscription has the
+	    correct transport info to send the NOTIFYs.
+
+	  * res_pjsip_session/internal_pjsip_inv_send_msg was eliminated since
+	    all it did was transport selection and that is now done in
+	    ast_sip_create_dialog_uac.
+
+	  * pjsip_message_ip_updater/multihomed_on_tx_message was updated
+	    to remove all traces of the x-ast-txp parameter from the
+	    outgoing headers.
+
+	  NOTE:  This change does NOT modify the behavior of permanent
+	  contacts specified on an aor.  To do so would require that the
+	  permanent contact's contact uri be updated with the x-ast-txp
+	  parameter and the aor sorcery object updated.  If we need to
+	  persue this, we need to think about cloning permanent contacts into
+	  the same store as the dynamic ones on an aor load so they can be
+	  updated without disturbing the originally configured value.
+
+	  You CAN add the x-ast-txp parameter to a permanent contact's uri
+	  but it would be much simpler to just set endpoint->transport.
+
+	  Change-Id: I4ee1f51473da32ca54b877cd158523efcef9655f
+
+2017-03-15 13:24 +0000 [adad6020be]  Richard Mudgett <rmudgett@digium.com>
+
+	* autochan/mixmonitor/chanspy: Fix unsafe channel locking and references.
+
+	  Dereferencing struct ast_autochan.chan without first calling
+	  ast_autochan_channel_lock() is unsafe because the pointer could change at
+	  any time due to a masquerade.  Unfortunately, ast_autochan_channel_lock()
+	  itself uses struct ast_autochan.chan unsafely and can result in a deadlock
+	  if the original channel happens to get destroyed after a masquerade in
+	  addition to the pointer getting changed.
+
+	  The problem is more likely to happen with v11 and earlier because
+	  masquerades are used to optimize out local channels on those versions.
+	  However, it could still happen on newer versions if the channel is
+	  executing a dialplan application when the channel is transferred or
+	  redirected.  In this situation a masquerade still must be used.
+
+	  * Added a lock to struct ast_autochan to safely be able to use
+	  ast_autochan.chan while trying to get the channel lock in
+	  ast_autochan_channel_lock().  The locking order is the channel lock then
+	  the autochan lock.  Locking in the other direction requires deadlock
+	  avoidance.
+
+	  * Fix unsafe ast_autochan.chan usages in app_mixmonitor.c.
+
+	  * Fix unsafe ast_autochan.chan usages in app_chanspy.c.
+
+	  * app_chanspy.c: Removed unused autochan parameter from next_channel().
+
+	  ASTERISK-26867
+
+	  Change-Id: Id29dd22bc0f369b44e23ca423d2f3657187cc592
+
+2017-03-07 14:13 +0000 [7bc69753bc]  Mark Michelson <mmichelson@digium.com>
+
+	* Add rtcp-mux support
+
+	  This commit adds support for RFC 5761: Multiplexing RTP Data and Control
+	  Packets on a Single Port. Specifically, it enables the feature when
+	  using chan_pjsip.
+
+	  A new option, "rtcp_mux" has been added to endpoint configuration in
+	  pjsip.conf. If set, then Asterisk will attempt to use rtcp-mux with
+	  whatever it communicates with. Asterisk follows the rules set forth in
+	  RFC 5761 with regards to falling back to standard RTCP behavior if the
+	  far end does not indicate support for rtcp-mux.
+
+	  The lion's share of the changes in this commit are in
+	  res_rtp_asterisk.c. This is because it was pretty much hard wired to
+	  have an RTP and an RTCP transport. The strategy used here is that when
+	  rtcp-mux is enabled, the current RTCP transport and its trappings (such
+	  as DTLS SSL session) are freed, and the RTCP session instead just
+	  mooches off the RTP session. This leads to a lot of specialized if
+	  statements throughout.
+
+	  ASTERISK-26732 #close
+	  Reported by Dan Jenkins
+
+	  Change-Id: If46a93ba1282418d2803e3fd7869374da8b77ab5
+
+2017-03-09 11:05 +0000 [163e9e53dc]  Sean Bright <sean.bright@gmail.com>
+
+	* app_queue: Handle the caller being redirected out of a queue bridge
+
+	  A caller can leave the Queue() application after being bridged with a
+	  member in a few ways:
+
+	    * Caller or member hangup
+	    * Caller is transferred somewhere else (blind or atx)
+	    * Caller is externally redirected elsewhere
+
+	  The first 2 scenarios are currently handled by subscribing to stasis
+	  messages, but the 3rd is not explicitly covered. If a caller is
+	  redirected away from the Queue() application, the member who was last
+	  bridged with that caller will remain in an "In use" state until the
+	  caller hangs up.
+
+	  This patch adds handling of the caller leaving the queue via
+	  redirection. We monitor the caller-member bridge, and if the caller is
+	  the one that leaves, we treat it the same as we would a caller hangup.
+
+	  ASTERISK-26400 #close
+	  Reported by: Etienne Lessard
+
+	  Change-Id: Iba160907770de5a6c9efeffc9df5a13e9ea75334
+
+2017-03-15 08:44 +0000 [7612601964]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_endpoint_identifier_ip: Don't output error if no header_match.
+
+	  This change ensures that if no header_match option is set on an
+	  identify an error message is not output stating the option is set
+	  to an invalid value.
+
+	  ASTERISK-26863
+
+	  Change-Id: I239bc6d2319dd3da24ba96a38d4d6e9b5526d62a
+
+2017-03-14 08:49 +0000 [48447313b6]  Torrey Searle <torrey@voxbone.com>
+
+	* res/res_pjsip_refer: call xfer w/o extension
+
+	  When transfering to a URI without an extension, ensure that the
+	  s extension of the dialplan is entered
+
+	  ASTERISK-26869 #close
+
+	  Change-Id: I07403df66cf93f09e00a40ab5b41bfc6f72b1525
+
+2017-03-14 16:16 +0000 [9fd9b39e8b]  Richard Mudgett <rmudgett@digium.com>
+
+	* pbx.c: Fix crash from malformed exten pattern.
+
+	  Forgetting to indicate an exten is a pattern can cause a crash if the
+	  "pattern" has a character set range.  e.g., "9999[3-5]" The crash is due
+	  to a buffer overwrite because the '-' exten eye-candy wasn't removed as
+	  expected and overran the allocated space.
+
+	  The buffer overwrite is fixed two ways in this patch.
+
+	  1) Fix ext_strncpy() to distinguish between pattern and non-pattern
+	  extens.  Now '-' characters are removed when they are eye-candy and not
+	  when they are part of a pattern character set.  Since the function is
+	  private to pbx.c, the return value now returns the number of bytes written
+	  to the destination buffer instead of the strlen() of the final buffer so
+	  the callers that care don't need to add one.
+
+	  2) Fix callers to ext_strncpy() to supply the correct available buffer
+	  size of the destination buffer.
+
+	  ASTERISK-26668
+
+	  Change-Id: I555d97411140e47e0522684062d174fbe32aa84a
+
+2017-03-14 16:51 +0000 [5389666d6f]  Richard Begg <asterisk@meric.id.au>
+
+	* chan_iax2: Reload of iax peer results in loss of host address/port
+
+	  When using a non-dynamic peer address, build_peer() invalidates the
+	  peer address structure by setting the address family to unspecified.
+	  However, if dnsmgr is enabled, the subsequent call to ast_dnsmgr_lookup()
+	  will not amend the peer address if the cache is still valid, resulting
+	  in peer connectivity failures.
+	  To fix this, we call ast_dnsmgr_refresh() instead.
+
+	  ASTERISK-26865
+
+	  Change-Id: Id8a89a2f771ebbaf32255a35fe596a6dcb97a082
+
+2017-03-14 15:12 +0000 [658d59c683]  Matt Jordan <mjordan@digium.com>
+
+	* configure: Don't use the progress bar with curl when downloading to stdout
+
+	  In some scenarios, such as when there may not be a terminal (such as
+	  inside a Docker container), curl will apparently direct the progress bar
+	  to stdout. This can cause extra data to be appended to a file curl'd
+	  down to stdout, resulting in md5 verification failures.
+
+	  This patch removes the progress bar, and tells curl to download the file
+	  silently.
+
+	  ASTERISK-26872 #close
+
+	  Change-Id: Ie860b020f627d4372b3e7ce9453de5faafeebe6c
+
+2017-03-14 07:50 +0000 [b3c2c996f1]  Matt Jordan <mjordan@digium.com>
+
+	* res_pjsip_endpoint_identifier_ip: Add an option to match requests by header
+
+	  This patch adds a new features to the endpoint identifier module,
+	  'match_header'. When set, inbound requests are matched by a provided SIP
+	  header: value pair. This option works in conjunction with the existing
+	  'match' configuration option, such that if any 'match*' attribute
+	  matches an inbound request, the request is associated with the specified
+	  endpoint.
+
+	  Since this module now identifies by more than just IP address,
+	  appropriate renaming of the module and/or variables can be done in a
+	  non-release branch.
+
+	  ASTERISK-26863 #close
+
+	  Change-Id: Icfc14835c962f92e35e67bbdb235cf0589de5453
+	  (cherry picked from commit 30f52d79d7fc9ab0b628bef2b61ea515413795a2)
+
+2017-03-14 09:55 +0000 [51985565ef]  Matt Jordan <mjordan@digium.com>
+
+	* configs/samples/hep.conf.sample: Clarify how the HEP stack works
+
+	  This patch updates the documenation in hep.conf.sample to better specify
+	  how the various HEP modules interact.
+
+	  ASTERISK-26717 #close
+
+	  Change-Id: I337fb742a89e3ec5edc7fc7a7a0295218d841124
+
+2017-03-14 09:59 +0000 [f9b791debe]  Roman Bedros (License 6842)
+
+	* funcs/func_devstate: Remove new line in Device field of during module load
+
+	  During module loading of func_devstate, Asterisk emits the current
+	  device state of all Custom device states currently stored in the AstDB.
+	  This was erroneously including a new line character ('\n') to the end of
+	  the device state, causing two new lines to be emitted in
+	  DeviceStateChange AMI events.
+
+	  Note that this only happened for those device state changes that
+	  occurred during startup. Regular device state changes for Custom device
+	  states are handled elsewhere, and did not have the newline.
+
+	  ASTERISK-26643 #close
+	  Reported by: Roman Bedros
+	  Tested by: Matt Jordan
+	  patches:
+	    ami_devstate.diff uploaded by Roman Bedros (License 6842)
+
+	  Change-Id: I1f4c02fc79c448d43bf725f5039c83d9611d7d93
+
+2017-03-14 09:37 +0000 [216e28aa95]  Matt Jordan <mjordan@digium.com>
+
+	* main/stasis_cache: Demote the ERROR message when removing a nonexistent item
+
+	  This patch demotes the ERROR message that is displayed when a
+	  nonexistent item is removed from the Stasis cache. The genesis of this
+	  demotion is due to chan_sip's realtime peers and their interaction with
+	  Asterisk's core ast_endpoint code, but ostensibly it could happen from
+	  other channel drivers as well.
+
+	  Since Mark Michelson already did an excellent job of explaining on this
+	  issue, it is quoted here for posterity:
+
+	  "Internally, when a realtime peer is retrieved, Asterisk creates an
+	  ast_endpoint structure. When that peer is destroyed, the ast_endpoint is
+	  destroyed as well. Part of the destruction of the ast_endpoint involves
+	  clearing the Stasis cache of all information about that endpoint. The
+	  problem here is that the act of creating the ast_endpoint is not enough
+	  to actually put any information in the Stasis cache. Instead, something
+	  has to happen, such as a state change, in order for the Stasis cache to
+	  have any information about that endpoint. When a device registers,
+	  chan_sip creates an ast_endpoint structure, processes the REGISTER, and
+	  then destroys the ast_endpoint. When the ast_endpoint is destroyed,
+	  there is nothing to destroy in the Stasis cache, so an error message is
+	  emitted. When you use rtcachefriends, ast_endpoint structures persist
+	  for the lifetime of the module and so you do not see this error
+	  message."
+
+	  ASTERISK-25237 #close
+
+	  Change-Id: I53cebc6b4a897a1ab9564182b75c177780feff70
+
+2017-03-12 09:21 +0000 [c8d1b915d7]  Joshua Colp <jcolp@digium.com>
+
+	* chan_pjsip: Don't assume a session will have a channel.
+
+	  When querying for PJSIP specific information using the dialplan
+	  function CHANNEL() it is possible that the underlying session
+	  will no longer have a channel associated with it. This is
+	  most likely to occur when the RTCP HEP module attempts to get
+	  the channel name. If this happens then a crash will occur.
+
+	  This change just adds a check that the channel exists on the
+	  session before querying it.
+
+	  ASTERISK-26857
+
+	  Change-Id: I113479cffff6ae64cf8ed089e9e1565223426f01
+
+2017-03-13 10:45 +0000 [6d1eb880c2]  gtjoseph <gjoseph@digium.com>
+
+	* menuselect: Add a new 'options' support type
+
+	  The Binaural Rendering patches in the master branch required
+	  menuselect to be updated with a new support type called 'option'.
+	  This allows binaural rendering to be turned on or off when
+	  bridge_softmix is built.  This patch backports the 'option'
+	  functionality to the 13 and 14 branches.
+
+	  Here's what it looks like in menuselect:
+
+	    [*] bridge_simple
+	    [*] bridge_softmix
+	        --- Module Options ---
+	    [ ] binaural_rendering_in_bridge_softmix
+
+	  To create an option for a module, you can create (or update) the
+	  menuselect-tree xml snippet in the directory where the module
+	  resides and add a member element with an 'option' support_level.
+
+	  Example (abbreviated) from bridges/bridges.xml:
+
+	  <member name="binaural_rendering_in_bridge_softmix"
+	  	displayname="Enable binaural rendering in bridge_softmix"
+	  	remove_on_change="bridges/bridge_softmix.o bridges/bridge_softmix.so">
+	  	<support_level>option</support_level>
+	  	<depend>bridge_softmix</depend>
+	  	<depend>fftw3</depend>
+	  	<defaultenabled>no</defaultenabled>
+	  </member>
+
+	  The 'name' will be added or removed from the MENUSELECT_<dir>
+	  make variable following the standard module "missing means yes"
+	  rules.
+
+	  Example (abbreviated) from bridges/Makefile:
+
+	  ifeq ($(findstring binaural_rendering,$(MENUSELECT_BRIDGES)),)
+	  bridge_softmix.o: _ASTCFLAGS+=-DBINAURAL_RENDERING
+	  bridge_softmix.so: LIBS+=$(FFTW3_LIB)
+	  endif
+
+	  Change-Id: I66d23755ed6e81f8d439cad410f2ffa7c30f25ad
+
+2017-03-10 20:29 +0000 [523de8eb8e]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Reduce the need for rebuilds
+
+	  Bundled pjproject should now only rebuild if one of the menuselect
+	  "Compiler Flags" options changes.
+
+	  Change-Id: If114a2e16b9e77af371a600d6a5e197bbf28fe43
+
+2017-03-07 08:12 +0000 [d3ef833b3b]  Jean Aunis <jean.aunis@prescom.fr>
+
+	* chan_sip: Call not cancelled after receiving a 422 response
+
+	  When receiving a 422 response, the invitestate variable must be reset to
+	  INV_CALLING.
+
+	  ASTERISK-26841
+
+	  Change-Id: Ia0502d6b02192664cefa4e75bafdd2645ce56099
+
+2017-03-05 15:26 +0000 [67c989ce78]  Daniel Journo <dan@keshercommunications.com>
+
+	* pjsip/cli_commands: pjsip show channelstats shows wrong codec
+
+	  * cli_commands.c Fixed CLI output
+
+	  ASTERISK-26822 #close
+
+	  Change-Id: I3889ef6a8f6738fc312fab42db5efacd6e452b01
+
+2017-03-07 07:37 +0000 [2a85888262]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_transport_websocket: Add support for IPv6.
+
+	  This change adds a PJSIP patch (which has been contributed upstream)
+	  to allow the registration of IPv6 transport types.
+
+	  Using this the res_pjsip_transport_websocket module now registers
+	  an IPv6 Websocket transport and uses it for the corresponding
+	  traffic.
+
+	  ASTERISK-26685
+
+	  Change-Id: Id1f9126f995b31dc38db8fdb58afd289b4ad1647
+
+2017-03-08 08:16 +0000 [bc6eeab822]  Daniel Journo <dan@keshercommunications.com>
+
+	* app_voicemail: Cannot set fromstring on a per-mailbox basis
+
+	  * apps/app_voicemail.c fromstring field added to mailbox which will
+	  override the global fromstring if set.
+
+	  ASTERISK-24562 #close
+
+	  Change-Id: I5e90e3a1ec2b2d5340b49a0db825e4bbb158b2fe
+
+2017-03-06 15:54 +0000 [d9972423d1]  Daniel Journo <dan@keshercommunications.com>
+
+	* Saynumber is trying to get "and" from "digits/" subfolder
+
+	  * say.c Changed 'digits/and' to 'vm-and' for en_GB
+
+	  ASTERISK-26598 #close
+
+	  Change-Id: If1b713e5daea6f952b339f139178d292a6c4fcfe
+
+2017-03-06 13:15 +0000 [77901a58ca]  Sean Bright <sean.bright@gmail.com>
+
+	* pbx_spool: Gracefully handle long lines in call files
+
+	  Per the linked issue, we aren't checking the buffer filled by fgets()
+	  to determine if it contains a newline, so we will fail to correctly
+	  parse the trailing portion of a long line.
+
+	  This patch increases the buffer size from 256 to 1024, and skips any
+	  line that exceeds that length, logging a warning in the process.
+
+	  ASTERISK-17067 #close
+	  Reported by: Dave Olszewski
+
+	  Change-Id: I51bcf270c1b4347ba05b43f18dc2094c76f5d7b0
+
+2017-03-02 21:27 +0000 [4271c700f7]  Richard Mudgett <rmudgett@digium.com>
+
+	* core: Cleanup ast_get_hint() usage.
+
+	  * manager.c:manager_state_cb() Fix potential use of uninitialized hint[]
+	  if a hint does not exist for the requested extension.  Ran into this when
+	  developing a testsuite test.  The AMI event ExtensionStatus came out with
+	  the hint header value containing garbage.  The AMI event PresenceStatus
+	  also had the same issue.
+
+	  * manager.c:action_extensionstate() no need to completely initialize the
+	  hint[].  Only initialize the first element.
+
+	  * pbx.c:ast_add_hint() Remove unnecessary assignment.
+
+	  * chan_sip.c: Eliminate an unneeded hint[] local variable.  We only care
+	  about the return value of ast_get_hint() there.
+
+	  Change-Id: Ia9a8786f01f93f1f917200f0a50bead0319af97b
+
+2017-02-16 04:22 +0000 [e510595c86]  Jørgen H <asterisk.org@hovland.cx>
+
+	* res_pjsip WebRTC/websockets: Fix usage of WS vs WSS.
+
+	  According to the RFC[1] WSS should only be used in the Via header
+	  for secure Websockets.
+
+	  * Use WSS in Via for secure transport.
+
+	  * Only register one transport with the WS name because it would be
+	  ambiguous.  Outgoing requests may try to find the transport by name and
+	  pjproject only finds the first one registered.  This may mess up unsecure
+	  websockets but the impact should be minimal.  Firefox and Chrome do not
+	  support anything other than secure websockets anymore.
+
+	  * Added and updated some debug messages concerning websockets.
+
+	  * security_events.c: Relax case restriction when determining security
+	  transport type.
+
+	  * The res_pjsip_nat module has been updated to not touch the transport
+	  on Websocket originating messages.
+
+	  [1] https://tools.ietf.org/html/rfc7118
+
+	  ASTERISK-26796 #close
+
+	  Change-Id: Ie3a0fb1a41101a4c1e49d875a8aa87b189e7ab12
+
+2017-03-01 07:23 +0000 [76971d4c4a]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_pgsql: Make 'require' return consistent with other backends
+
+	  res_config_pgsql should match the behavior of other realtime backend
+	  drivers so that queue_log can disable adaptive logging.
+
+	  ASTERISK-25628 #close
+	  Reported by: Dmitry Wagin
+
+	  Change-Id: Ic1fb1600c7ce10fdfb1bcdc43c5576b7e0014372
+
+2017-02-28 09:41 +0000 [fa8f6c2fc4]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_pgsql: Release table locks where appropriate
+
+	  The find_table() functions NULL or a locked table pointer. We are
+	  not consistently calling release_table() in failure paths.
+
+	  Change-Id: I6f665b455799c84b036e5b34904b82b05eab9544
+
+2017-02-28 05:41 +0000 [5b34b751a0]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* pjsip.conf.sample: user_agent: not a specific version
+
+	  Use the description of useragent from sip.conf here.
+
+	  ASTERISK-26825 #close
+
+	  Change-Id: I5b33a4aaa0ae1d793289d05e3bc09521affbf755
+
+2017-02-27 20:07 +0000 [8e6ecdade2]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_pubsub:  Remove unneeded endpoint unref
+
+	  When a subscription was being recreated and the endpoint wasn't
+	  found, we were trying to unref the endpoint.  This was causing
+	  FRACKs.  Removed the unref.
+
+	  ASTERISK-26823 #close
+
+	  Change-Id: If86d2aecff8fe853c7f38a1bfde721fcef3cd164
+
+2017-02-16 04:16 +0000 [0595c31da7]  Jørgen H <asterisk.org@hovland.cx>
+
+	* res_pjsip: Fix crash when contact has no status
+
+	  This change fixes an assumption in res_pjsip that a contact will
+	  always have a status. There is a race condition where this is
+	  not true and would crash. The status will now be unknown when
+	  this situation occurs.
+
+	  ASTERISK-26623 #close
+
+	  Change-Id: Id52d3ca4d788562d236da49990a319118f8d22b5
+
+2017-02-21 18:06 +0000 [c07bcca87e]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_outbound_registration:  Subscribe to network change events
+
+	  Outbound registration now subscribes to network change events
+	  published by res_stun_monitor and refreshes all registrations
+	  when an event happens.
+
+	  The 'pjsip send (un)register' CLI commands were updated to accept
+	  '*all' as an argument to operate on all registrations.
+
+	  The 'PJSIP(Un)Register' AMI commands were also updated to
+	  accept '*all'.
+
+	  ASTERISK-26808 #close
+
+	  Change-Id: Iad58a9e0aa5d340477fca200bf293187a6ca5a25
+
+2017-02-26 10:09 +0000 [d91f61f0b5]  Vitezslav Novy <a1@vnovy.net>
+
+	* chan_sip: Allow DTLS to be disabled when reloading.
+
+	  This change fixes a problem where removing the DTLS configuration
+	  options and reloading would not disable DTLS. This occurred
+	  because the DTLS configuration was not reset to an unconfigured
+	  state on reload.
+
+	  ASTERISK-26313
+
+	  Change-Id: I10952709cc4a7727fb50534b042bce9d64894b39
+
+2017-02-27 12:25 +0000 [3d2c119778]  gtjoseph <gjoseph@digium.com>
+
+	* build:  Warn if asterisk is installed in both 32 and 64 bit sys dirs
+
+	  ... and clean them both up on uninstall.
+
+	  We've fixed the issue where 'make install' was installing to
+	  /usr/lib on 64-bit systems that use /usr/lib64.  Now we need
+	  to clean up the remnants in /usr/lib.
+
+	  * 'make install' now prints a warning if DESTDIR/ASTLIBDIR
+	    contains 'lib64' and libasterisk* shared libraries or modules
+	    are also found in DESTDIR/ASTLIBDIR with 'lib64' transformed
+	    to 'lib'.
+
+	  * 'make uninstall' ALWAYS cleans up both DESTDIR/ASTLIBDIR and
+	    DESTDIR/ASTLIBDIR with 'lib64' transformed to 'lib'.
+
+	  ASTERISK-26705
+
+	  Change-Id: I6edddeb3c07a51e7c7ba7cac3c05e4bf3ec3f01f
+
+2017-02-27 07:02 +0000 [eac818801b]  Joshua Colp <jcolp@digium.com>
+
+	* bridge_native_rtp: Handle case where channel joins already suspended.
+
+	  The bridge_native_rtp module did not properly handle the case where
+	  a smart bridge operation occurs while a channel is suspended. In this
+	  scenario the module would incorrectly set up local or remote RTP
+	  bridging despite the media having to flow through Asterisk. The remote
+	  endpoint would see two media streams and experience wonky audio.
+
+	  The module has been changed so that it ensures both channels are
+	  not suspended when performing the native RTP bridging and this
+	  requirement has been documented in the bridge technology.
+
+	  ASTERISK-26781
+
+	  Change-Id: Id4022d73ace837d4a293106445e3ade10dbc7c7c
+
+2017-02-24 11:49 +0000 [d49af061bc]  Joshua Colp <jcolp@digium.com>
+
+	* config: Improve documentation and behavior of outbound_proxy option.
+
+	  This change updates the documentation for the outbound_proxy option
+	  to ensure it is consistently stated that a full SIP URI must be
+	  provided for the option.
+
+	  The res_pjsip_outbound_registration module has also been changed so
+	  that the provided outbound_proxy value is checked to ensure it is a
+	  URI and if not an error is output stating so.
+
+	  ASTERISK-26782
+
+	  Change-Id: I6c239a32274846fd44e65b44ad9bf6373479b593
+
+2017-02-09 18:05 +0000 [9c05ddbddd]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled: Update for pjproject 2.6
+
+	   * Removed all 2.5.5 functional patches.
+	   * Updated usages of pj_release_pool to be "safe".
+	   * Updated configure options to disable webrtc.
+	   * Updated config_site.h to disable webrtc in pjmedia.
+	   * Added Richard Mudgett's recent resolver patches.
+
+	  Change-Id: Ib400cc4dfca68b3d07ce14d314e829bfddc252c7
+
+2017-02-23 15:49 +0000 [bee55aaf2c]  gtjoseph <gjoseph@digium.com>
+
+	* build: Execute ldconfig to build cache. (take two)
+
+	  On some platforms a multiarch approach is used for libraries.
+	  The build system does not take this into account and still
+	  places libraries into the lib directory if no --libdir is
+	  specified to configure. On initial startup this results in
+	  libasteriskssl.so not being found, as it is not in the multiarch
+	  lib directory.  To make matters worse, options were being passed
+	  to ldconfig on both Linux and FreeBSD that actually prevented
+	  the rebuild of the cache.
+
+	   * Fedora has a /usr/share/config.site that automatically tells
+	     autoconf to use /usr/lib64 but CentOS does not. This logic was
+	     copied to configure.ac and modified so systems like Ubuntu,
+	     which still use /usr/lib for 64-bit systems, aren't affected.
+
+	  Now that we have them in the correct directory...
+
+	  In order for the system loader to find libasteriskssl and
+	  libasteriskpj, one of 3 things has to happen...
+
+	    - The linker cache must be rebuilt including the directory
+	      where the libasterisk* libraries were installed.  Only root
+	      can rebuild the cache.  This was busted.
+	    - We have to link the asterisk binary with an rpath pointing
+	      to the directrory where the libasterisk* libraries were
+	      installed.  This makes things very complicated and will happen
+	      over the collective dead bodies of everyone who's had to
+	      package a distribution with an rpath.
+	    - Finally, you can start asterisk with LD_LIBRARY_PATH set to the
+	      directrory where the libasterisk* libraries were installed.
+
+	  There are no other options. So...
+
+	   * The invokation of ldconfig has been moved from main/Makefile
+	     to ASTTOPDIR/Makefile, the options have been removed, and
+	     DESTDIR/ASTLIBDIR appended.  If you aren't root, you will be
+	     warned after the "Asterisk Installation Compete" banner that
+	     you must re-run 'make install' as root, manually run
+	     'ldconfig DESTDIR/ASTLIBDIR' as root, or run asterisk with
+	     LD_LIBRARY_PATH.
+
+	  ASTERISK-26705
+
+	  Change-Id: I2a64b7c33a7d3e9bde20f47e3d3ab771977af982
+
+2017-02-23 14:48 +0000 [da0cadd100]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_pgsql: Fix thread safety problems
+
+	  * A missing AST_LIST_UNLOCK() in find_table()
+
+	  * The ESCAPE_STRING() macro uses pgsqlConn under the hood and we were
+	    not consistently locking before calling it.
+
+	  * There were a handful of other places where pgsqlConn was accessed
+	    directly without appropriate locking.
+
+	  Change-Id: Iea63f0728f76985a01e95b9912c3c5c6065836ed
+
+2017-02-22 08:53 +0000 [f1963c5b8d]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_ldap: Various code improvements
+
+	  The initial motivation for this patch was to properly handle memory
+	  allocation failures - we weren't checking the return values from the
+	  various LDAP library allocation functions.
+
+	  In the process, because update_ldap() and update2_ldap() were
+	  substantially the same code, they've been consolidated.
+
+	  Change-Id: Iebcfe404177cc6860ee5087976fe97812221b822
+
+2017-02-22 13:08 +0000 [1ec796ce18]  Michael L. Young <elgueromexicano@gmail.com>
+
+	* build_tools:  Fix download_externals to allow the use of curl or wget
+
+	  Not sure if this is really a bug versus an improvement. I can see it being
+	  viewed as a bug though by some.
+
+	  The current build_tools/download_externals file depends on wget in order to
+	  download external modules.  The current build system is able to discover
+	  which tool to use for fetching remote files - either wget or curl.
+
+	  This patch takes advantage of this capability by modifying the two calls to
+	  the wget binary to instead use what was discovered by the build system.
+
+	  ASTERISK-26812 #close
+
+	  Change-Id: If9411a2554f009274d377445613ae91192d948a1
+
+2017-02-22 11:13 +0000 [5c9c097d17]  Joshua Colp <jcolp@digium.com>
+
+	* Revert "build: Execute ldconfig to build cache."
+
+	  This reverts commit d90430953c508670a67de68de400fef44f5e9fba.
+
+	  Change-Id: I758fe7ea0408f83a6df8e1774310d69f482700f6
+
+2017-02-21 10:47 +0000 [ca6d001144]  Sean Bright <sean.bright@gmail.com>
+
+	* pbx_realtime: Prevent premature extension matching
+
+	  The patterns provided by pbx_realtime were checked in the order in
+	  which they were returned from the realtime backend. If there was
+	  overlap between multiple patterns, the first one to correctly match was
+	  chosen even though it may not have been the best match.
+
+	  We now sort the patterns descending by their length and compare in that
+	  order. There may be cases where this still results in a sub-optimal
+	  match, but this patch should improve the overall behavior.
+
+	  ASTERISK-18271 #close
+	  Reported by: Charlie Smurthwaite
+
+	  Change-Id: I56d9ac15810eb1775966b669c3028e32cc7bd809
+
+2017-02-21 15:09 +0000 [0654bf637c]  Peter Racz
+
+	* pbx_dundi: DUNDi weight parameter not processed correctly
+
+	  The DUNDi weight field is not always converted from network byte order
+	  to host byte order. This can result in incorrect weight values and
+	  incorrect selection of DUNDi destinations.
+
+	  ASTERISK-18731 #close
+	  Reported by: Peter Racz
+	  Patches:
+	  	dundi_weight.patch (license #6290) patch uploaded by Peter Racz
+
+	  Change-Id: Iba3e1a700ff539db57211a7bbc26f7b22ea9a1be
+
+2017-02-21 10:47 +0000 [d5522de597]  Sean Bright <sean.bright@gmail.com>
+
+	* realtime: Fix ast_load_realtime_multientry handling
+
+	  ast_load_realtime_multientry() returns an ast_config structure whose
+	  ast_categorys are keyed with the empty strings. Several modules were
+	  giving semantic meaning to the category names causing problems at
+	  runtime.
+
+	  * app_directory: Treated the category name as the mailbox name, and
+	    would fail to direct calls to the appropriate extension after an
+	    entry was chosen.
+
+	  * app_queue: Queues, queue members, and queue rules were all affected
+	    and needed to be updated.
+
+	  * pbx_realtime: Pattern matching would never succeed because the
+	    extension entered by the user was always compared to the empty
+	    string.
+
+	  Change-Id: Ie7e44986344b0b76ea8f6ddb5879f5040c6ca8a7
+
+2017-02-21 08:56 +0000 [5eb7875243]  Sean Bright <sean.bright@gmail.com>
+
+	* realtime: Centralize some common realtime backend code
+
+	  All of the realtime backends create artificial ast_categorys to pass
+	  back into the core as query results. These categories have no filename
+	  or line number information associated with them and the backends differ
+	  slightly on how they create them. So create a couple helper macros to
+	  help make things more consistent.
+
+	  Also updated the call sites to remove redundant error messages about
+	  memory allocation failure.
+
+	  Note that res_config_ldap sets the category filename to the 'table name'
+	  but that is not read by anything in the core, so I've dropped it.
+
+	  Change-Id: I3a1fd91e0c807dea1ce3b643b0a6fe5be9002897
+
+2017-02-16 10:30 +0000 [d90430953c]  Joshua Colp <jcolp@digium.com>
+
+	* build: Execute ldconfig to build cache.
+
+	  On some platforms a multiarch approach is used for libraries.
+	  The build system does not take this into account and still
+	  places libraries into the lib directory if no --libdir is
+	  specified to configure. On initial startup this results in
+	  libasteriskssl.so not being found, as it is not in the multiarch
+	  lib directory.
+
+	  This change does the minimally invasive thing and executes
+	  ldconfig so that the libraries in the lib directory are found
+	  and their location cached. By doing so Asterisk starts up fine.
+
+	  If DESTDIR is specified, however, the old logic is executed as
+	  the install process may not have permission to alter the ldconfig
+	  cache.
+
+	  ASTERISK-26705
+
+	  Change-Id: If4eca46ac510c6fea5568256280ffdb3888d7bb4
+
+2017-01-08 20:32 +0000 [3b606093d3]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_authenticator_digest.c: Fix sorcery's immutable contract violation.
+
+	  The inbound authentication object is supposed to be immutable when it is
+	  stored in sorcery.  However, the immutable property is violated if the
+	  authentication object does not have a realm set.
+
+	  The immutable contract violation has a different effect depending upon
+	  what sorcery back end is used.  If it is the config file back end you
+	  would get the same object back until res_pjsip is reloaded.  If it is the
+	  real-time or AstDB back end you would get a new object on each query.  If
+	  it is cached you would get the same object back until it is refreshed from
+	  the database.
+
+	  Once an inbound authentication object has its realm set it may or may not
+	  get updated again if the default_realm changes.
+
+	  If the same authentication object is used for inbound and outbound
+	  authentication then the immutable violation can make it very hard to
+	  determine why the outbound authentication now fails.  The only diagnostic
+	  message is a complaint about no realms matching when it had worked
+	  earlier.  It fails because of the difference in behaviour for an empty
+	  realm setting between inbound and outbound authentication objects.
+
+	  * Fixed the sorcery object immutable violation by creating a new object
+	  and setting the default_realm on it instead.  The new object is a shallow
+	  copy for speed.
+
+	  * The auth_store thread storage no longer holds an auth ref.  It
+	  interferes with the shallow copy and never needed a ref anyway.
+
+	  ASTERISK-26799 #close
+
+	  Change-Id: I2328a52f61b78ed5fbba38180b7f183ee7e08956
+
+2017-02-04 20:17 +0000 [6208962b00]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Update artificial auth whenever default_realm changes.
+
+	  There was code attempting to update the artificial authentication object
+	  whenever the default_realm changed.  However, once the artificial
+	  authentication object was created it would never get updated.  The
+	  artificial authentication object would require a system restart for a
+	  change to the default_realm to take effect.
+
+	  ASTERISK-26799
+
+	  Change-Id: Id59036e9529c2d3ed728af2ed904dc36e7094802
+
+2017-01-01 08:02 +0000 [9f11da85a2]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Update authentication realm documentation.
+
+	  Using the same auth section for inbound and outbound authentication is not
+	  recommended.  There is a difference in meaning for an empty realm setting
+	  between inbound and outbound authentication uses.
+
+	  An empty inbound auth realm represents the global section's default_realm
+	  value when the authentication object is used to challenge an incoming
+	  request.  An empty outgoing auth realm is treated as a don't care wildcard
+	  when the authentication object is used to respond to an incoming
+	  authentication challenge.
+
+	  ASTERISK-26799
+
+	  Change-Id: Id3952f7cfa1b6683b9954f2c5d2352d2f11059ce
+
+2017-02-13 17:11 +0000 [473813311b]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjproject: Fixes to resolve DNS SRV crashes.
+
+	  * Re #1945 (misc): Don't trigger SRV complete callback when there is a
+	  parse error.
+
+	  * srv_resolver.c: Don't try to send query if already considered resolved.
+
+	  ** In resolve_hostnames() don't try to resolve a query that is already
+	  considered resolved.
+
+	  ** In resolve_hostnames() fix DNS typo in comments.
+
+	  ** In build_server_entries() move a common expression assigning to cnt
+	  earlier.
+
+	  * sip_transport.c: Fix tdata object name to actually contain the pointer.
+
+	  It helps if the logs referencing a tdata object buffer actually have a
+	  name that includes the correct pointer as part of the name.  Also since
+	  the tdata has its own pool it helps if any logs referencing the pool have
+	  the same name as the tdata object.  This change brings tdata logging in
+	  line with how tsx objects are named.
+
+	  ASTERISK-26669 #close
+	  ASTERISK-26738 #close
+
+	  Change-Id: I56af2ded25476b3e870ca586ee69ed6954ef75af
+
+2017-02-06 14:26 +0000 [d58fdae811]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Update some debug messages to get transaction name.
+
+	  * Removed overloaded unmatched response ignore.  We obviously sent the
+	  request so we shouldn't ignore it because it isn't new work.
+
+	  ASTERISK-26669
+	  ASTERISK-26738
+
+	  Change-Id: I55fb5cadc83a8e6699b347c6dc7fa32c5a617d37
+
+2017-02-04 16:00 +0000 [eb9ae4f7cb]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Record the serializer earlier on the tdata.
+
+	  When PJPROJECT needs to do a DNS resolution and there is not a cached
+	  entry available, the SIP request message goes out on the PJSIP monitor
+	  thread instead of the original serializer thread.  Thus when the response
+	  comes back it does not get processed by the original sending serializer.
+
+	  This patch records the serializer on tdata before passing a request
+	  message to PJPROJECT where it can in Asterisk code.  There are several
+	  places in PJPROJECT for outbound registration and publishing support that
+	  would need to record the serializer.  Unfortunately, without replacing the
+	  PJPROJECT DNS resolver as was done in v14 we cannot fix those without
+	  modifying PJPROJECT.
+
+	  Even if we backported the DNS resolver from v14, the outbound registration
+	  refresh timer does not go out on a serializer thread but the PJSIP monitor
+	  thread.  Fortunately, Asterisk's outbound publish support doesn't use the
+	  auto refresh timer that would also not go out under the serializer thread.
+
+	  This patch is v13 only.
+
+	  ASTERISK-26669
+	  ASTERISK-26738
+
+	  Change-Id: I9997b9ed6dbcebd2c37d6a67dc6dcee9c78914a4
+
+2017-02-20 13:38 +0000 [57f19d6efb]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjproject: Increase SENDER_WIDTH column size for 64-bit system logs.
+
+	  ASTERISK-26669
+	  ASTERISK-26738
+
+	  Change-Id: Ibae6fc8cae69a1f04df0c577c4c11200499d6fe0
+
+2017-02-20 06:28 +0000 [47daca8a2b]  Sean Bright <sean.bright@gmail.com>
+
+	* app_voicemail: vm_authenticate accesses uninitialized memory
+
+	  vm_authenticate doesn't always set the passed ast_vm_user argument, so
+	  we initialize to 0 before passing it in.
+
+	  ASTERISK-25893 #close
+	  Reported by: Filip Jenicek
+
+	  Change-Id: Ia3cc0128f93d352ed9add8d5c2f0f7232c2cbe4a
+
+2017-02-20 11:19 +0000 [06214173a9]  Joshua Colp <jcolp@digium.com>
+
+	* Revert "build: Execute ldconfig to build cache."
+
+	  This reverts commit e910dbab90ef3d628955c49f441b2c9dda1f222c.
+
+	  Change-Id: I242aa0a965a79738dc898299959c6d2e020c86bd
+
+2017-02-20 08:04 +0000 [c9ea98f9bf]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject cli:  Add object count after object lists
+
+	  When listing a container, we now print the number of objects
+	  in the container at the end of the list.
+
+	  Change-Id: I791cbc3ee9da9a2af9adc655164b5d32953df812
+
+2017-02-20 05:53 +0000 [d8972f50f4]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_ldap: Don't try to delete non-existent attributes
+
+	  OpenLDAP will raise an error when we try to delete an LDAP attribute
+	  that doesn't exist. We need to filter out LDAP_MOD_DELETE requests
+	  based on which attributes the current LDAP entry actually has. There
+	  is of course a small window of opportunity for this to still fail,
+	  but it is much less likely now.
+
+	  Change-Id: I3fe1b04472733e43151563aaf9f8b49980273e6b
+
+2017-02-20 05:49 +0000 [b980cae1f7]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_ldap: Remove extraneous line numbers from log messages
+
+	  Extraneous line numbers were being output in many log messages. These
+	  have been removed.
+
+	  Change-Id: Ice9efa3d252ee87f37fa8f5ea852fda482675431
+
+2017-02-20 05:45 +0000 [011b7be62a]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_ldap: Make memory allocation more consistent
+
+	  The code in update_ldap() and update2_ldap() was using both Asterisk's
+	  memory allocation routines as well as OpenLDAP's. I've changed it so
+	  that everything that is passed to OpenLDAP's functions are allocated
+	  with their routines.
+
+	  Change-Id: Iafec9c1fd8ea49ccc496d6316769a6a426daa804
+
+2017-02-20 05:30 +0000 [b2836dde7e]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_ldap: Fix configuration inheritance from _general
+
+	  The "_general" configuration section allows administrators to provide
+	  both general configuration options (host, port, url, etc.) as well as a
+	  global realtime-to-LDAP-attribute mapping that is a fallback if one of
+	  the later sections do not override it. This neglected to exclude the
+	  general configuration options from the mapping. As an example, during
+	  my testing, chan_sip requested 'port' from realtime, and because I did
+	  not have it defined, it pulled in the 'port' configuration option from
+	  "_general." We now filter those out explicitly.
+
+	  Change-Id: I1fc61560bf96b8ba623063cfb7e0a49c4690d778
+
+2017-02-20 05:27 +0000 [6d5e9993b2]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_ldap: Fix erroneous LDAP_MOD_REPLACE in LDAP modify
+
+	  We always treat the first change of our modification batch as a
+	  replacement when it sometimes is actually a delete. So we have to pass
+	  the correct arguments to the OpenLDAP library.
+
+	  ASTERISK-26580 #close
+	  Reported by: Nicholas John Koch
+	  Patches:
+	  	res_config_ldap.c-11.24.1.patch (license #6833) patch uploaded
+	  	by Nicholas John Koch
+
+	  Change-Id: I0741d25de07c9539f1edc6eff3696165dfb64fbe
+
+2017-02-15 11:55 +0000 [5b7c6678ae]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_sqlite3: Fix crash when loading with invalid config
+
+	  When ast_config_load() fails with CONFIG_STATUS_FILEINVALID, it has
+	  already destroyed the ast_config struct for us. Trying to do it again
+	  results in a crash.
+
+	  Change-Id: If6a5c0ca718ad428e01a1fb25beb209a9ac18bc6
+
+2017-02-17 16:57 +0000 [096496e13e]  Richard Mudgett <rmudgett@digium.com>
+
+	* tcptls.c: Add some missing allocation failure checks.
+
+	  Change-Id: I0ddf01cd3c10d3b6666d7bf68d4e206a37f4fbdb
+
+2017-02-17 17:06 +0000 [047a1e7dcc]  Sean Bright <sean.bright@gmail.com>
+
+	* pjproject-bundled: Fix checksum verification when using cURL
+
+	  ASTERISK-26802 #close
+	  Reported by: Michael L. Young
+
+	  Change-Id: Iad293080f55d4d69ab615717a15211d916eed613
+
+2017-02-16 08:38 +0000 [2cd75fe311]  Sean Bright <sean.bright@gmail.com>
+
+	* realtime: Fix LIKE escaping in SQL backends
+
+	  The realtime framework allows for components to look up values using a
+	  LIKE clause with similar syntax to SQL's. pbx_realtime uses this
+	  functionality to search for pattern matching extensions that start with
+	  an underscore (_).
+
+	  When passing an underscore to SQL's LIKE clause, it will be interpreted
+	  as a wildcard matching a single character and therefore needs to be
+	  escaped. It is (for better or for worse) the responsibility of the
+	  component that is querying realtime to escape it with a backslash before
+	  passing it in. Some RDBMs support escape characters by default, but the
+	  SQL92 standard explicitly says that there are no escape characters
+	  unless they are specified with an ESCAPE clause, e.g.
+
+	  	SELECT * FROM table WHERE column LIKE '\_%' ESCAPE '\'
+
+	  This patch instructs 3 backends - res_config_mysql, res_config_pgsql,
+	  and res_config_sqlite3 - to use the ESCAPE clause where appropriate.
+
+	  Looking through documentation and source tarballs, I was able to
+	  determine that the ESCAPE clause is supported in:
+
+	  MySQL 5.0.15   (released 2005-10-22 - earliest version available from
+	                  archives)
+	  PostgreSQL 7.1 (released 2001-04-13)
+	  SQLite 3.1.0   (released 2005-01-21)
+
+	  The versions of the relevant libraries that we depend on to access MySQL
+	  and PostgreSQL will not work on versions that old, and I've added an
+	  explicit check in res_config_sqlite3 to only use the ESCAPE clause when
+	  we have a sufficiently new version of SQLite3.
+
+	  res_config_odbc already handles the escape characters appropriately, so
+	  no changes were required there.
+
+	  ASTERISK-15858 #close
+	  Reported by: Humberto Figuera
+
+	  ASTERISK-26057 #close
+	  Reported by: Stepan
+
+	  Change-Id: I93117fbb874189ae819f4a31222df7c82cd20efa
+
+2017-02-16 10:30 +0000 [e910dbab90]  Joshua Colp <jcolp@digium.com>
+
+	* build: Execute ldconfig to build cache.
+
+	  On some platforms a multiarch approach is used for libraries.
+	  The build system does not take this into account and still
+	  places libraries into the lib directory if no --libdir is
+	  specified to configure. On initial startup this results in
+	  libasteriskssl.so not being found, as it is not in the multiarch
+	  lib directory.
+
+	  This change does the minimally invasive thing and executes
+	  ldconfig so that the libraries in the lib directory are found
+	  and their location cached. By doing so Asterisk starts up fine.
+
+	  ASTERISK-26705
+
+	  Change-Id: I6d30b6427e9d5e69470e11327c7ff203fa7da519
+
+2017-02-16 05:46 +0000 [9b02bbfa88]  Sean Bright <sean.bright@gmail.com>
+
+	* res_config_sqlite3: Properly create missing columns when necessary
+
+	  There were two specific issues resolved here:
+
+	  1) The code that iterated over the required fields
+	     (via ast_realtime_require) was broken for the RQ_INTEGER1 field
+	     type. Iteration would stop when the first RQ_INTEGER1 (0) field
+	     was encountered.
+
+	  2) sqlite3_changes() was used to try and count the number of rows
+	     returned by a SELECT statement. sqlite3_changes() only counts
+	     affected rows, so this was always returning the value from the
+	     most recent data modification statement. We now separate read-only
+	     queries from data modification queries and count rows appropriately
+	     in both cases.
+
+	  ASTERISK-23457 #close
+	  Reported by: Scott Griepentrog
+
+	  Change-Id: I91ed20494efc3fcfbc2a96ac7646999a49814884
+
+2017-02-15 14:44 +0000 [0fc27fa364]  Joshua Elson <joshelson@gmail.com>
+
+	* http: Ensure capath is defined on all http creations
+
+	  ASTERISK-26794 #close
+
+	  Change-Id: I9cbc3b6b6a8aab590f5ccde9c262a98e4d5253a1
+
+2017-02-15 23:09 +0000 [7aa731c1c7]  Igor Goncharovsky <igor.goncharovsky@gmail.com>
+
+	* chan_unistim: fix char type to have consistent behavior on ARM
+
+	  There is difference exists in behaviour of char type on x86 and ARM.
+	  On x86 by default char variable type means signed char, but in ARM
+	  unsigned char used. This make binary calculations and negative values
+	  works wrong on ARM.
+
+	  This patch change type of char variables used for store negative
+	  values and binary calculations to signed char.
+
+	  ASTERISK-26714
+
+	  Change-Id: Id78716dee9568a58419d4ef63c038affc3dfc7ab
+
+2017-02-07 13:17 +0000 [be77b845d9]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_pubsub:  Correctly implement persisted subscriptions
+
+	  This patch fixes 2 original issues and more that those 2 exposed.
+
+	  * When we send a NOTIFY, and the client either doesn't respond or
+	    responds with a non OK, pjproject only calls our
+	    pubsub_on_evsub_state callback, no others.  Since
+	    pubsub_on_evsub_state (which does the sub_tree cleanup) does not
+	    expect to be called back without the other callbacks being called
+	    first, it just returns leaving the sub_tree orphaned.  Now
+	    pubsub_on_evsub_state checks the event for PJSIP_EVENT_TSX_STATE
+	    which is what pjproject will set to tell us that it was the
+	    transaction that timed out or failed and not the subscription
+	    itself timing our or being terminated by the client. If is
+	    TSX_STATE, pubsub_on_evsub_state now does the proper cleanup
+	    regardless of the state of the subscription.
+
+	  * When a client renews a subscription, we don't update the
+	    persisted subscription with the new expires timestamp.  This causes
+	    subscription_persistence_recreate to prune the subscription if/when
+	    asterisk restarts.  Now, pubsub_on_rx_refresh calls
+	    subscription_persistence_update to apply the new expires timestamp.
+	    This exposed other issues however...
+
+	  * When creating a dialog from rdata (which sub_persistence_recreate
+	    does from the packet buffer) there must NOT be a tag on the To
+	    header (which there will be when a client refreshes a
+	    subscription).  If there is one, pjsip_dlg_create_uas will fail.
+	    To address this, subscription_persistence_update now accepts a flag
+	    that indicates that the original packet buffer must not be updated.
+	    New subscribes don't set the flag and renews do.  This makes sure
+	    that when the rdata is recreated on asterisk startup, it's done
+	    from the original subscribe packet which won't have the tag on To.
+
+	  * When creating a dialog from rdata, we were setting the dialog's
+	    remote (SUBSCRIBE) cseq to be the same as the local (NOTIFY) cseq.
+	    When the client tried to resubscribe after a restart with the
+	    correct cseq, we'd reject the request with an Invalid CSeq error.
+
+	  * The acts of creating a dialog and evsub by themselves when
+	    recreating a subscription does NOT restart pjproject's subscription
+	    timer.  The result was that even if we did correctly recreate the
+	    subscription, we never removed it if the client happened to go away
+	    or send a non-OK response to a NOTIFY.  However, there is no
+	    pjproject function exposed to just set the timer on an evsub that
+	    wasn't created by an incoming subscribe request.  To address this,
+	    we create our own timer using ast_sip_schedule_task.  This timer is
+	    used only for re-establishing subscriptions after a restart.
+
+	    An earlier approach was to add support for setting pjproject's
+	    timer (via a pjproject patch) and while that patch is still included
+	    here, we don't use that call at the moment.
+
+	  While addressing these issues, additional debugging was added and
+	  some existing messages made more useful.  A few formatting changes
+	  were also made to 'pjsip show scheduled tasks' to make displaying
+	  the subscription timers a little more friendly.
+
+	  ASTERISK-26696
+	  ASTERISK-26756
+
+	  Change-Id: I8c605fc1e3923f466a74db087d5ab6f90abce68e
+
+2017-02-15 11:03 +0000 [73133d5354]  Sean Bright <sean.bright@gmail.com>
+
+	* res_rtp_asterisk: Use PJ_ICE_MAX_CAND instead of hard-coding 16
+
+	  pjsip limits the total number of ICE candidates to PJ_ICE_MAX_CAND,
+	  which is a compile-time constant. Instead of hard-coding 16 when we
+	  enumerate local interfaces, use PJ_ICE_MAX_CAND so that we can
+	  potentially collect more interfaces if the compile time options are
+	  changed.
+
+	  Tangentially related to ASTERISK~24464
+
+	  Change-Id: I1b85509e39e33b1fed63c86261fc229ba14bbabd
+
+2017-02-03 02:25 +0000 [99b40e72ae]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* libasteriskssl: do nothing with OpenSSL >= 1.1
+
+	  OpenSSL 1.1 requires no explicit initialization. The hacks in the
+	  library are not needed. They also happen to fail running Asterisk.
+
+	  ASTERISK-26109 #close
+
+	  Change-Id: I3b3efd5d80234a4c45a8ee58dcfe25b15d9ad100
+
+2017-02-13 16:50 +0000 [4c31e03e80]  Sean Bright <sean.bright@gmail.com>
+
+	* app_voicemail: Allow 'Comedian Mail' branding to be overriden
+
+	  Original patch by John Covert, slight modifications by me.
+
+	  ASTERISK-17428 #close
+	  Reported by: John Covert
+	  Patches:
+	  	app_voicemail.c.patch (license #5512) patch uploaded by
+	          John Covert
+
+	  Change-Id: Ic3361b0782e5a5397a19ab18eb8550923a9bd6a6
+
+2017-01-20 23:59 +0000 [e97e50b68b]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* tcptls: use TLS_client_method with OpenSSL 1.1
+
+	  OpenSSL 1.1 introduced TLS_client_method() and deprecated the previous
+	  version-specific methods (such as TLSv1_client_method(). Other than
+	  being simpler to use and more correct (gain support for TLS newer that
+	  TLS1, in our case), the older ones produce a deprecation warning that
+	  fails the build in dev-mode.
+
+	  ASTERISK-26109 #close
+
+	  Change-Id: I257b1c8afd09dcb0d96cda3a41cb9f7a15d0ba07
+
+2017-01-20 23:57 +0000 [0d555f0d81]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* openssl 1.1 support: use OPENSSL_VERSION_NUMBER
+
+	  Use OPENSSL_VERSION_NUMBER instead of OPENSSL_API_COMPAT to detect
+	  the openssl 1.1 API.
+
+	  ASTERISK-26109 #close
+
+	  Change-Id: I4e448f55ef516aedf6ad154037c35577a421a458
+
+2017-01-25 16:25 +0000 [9d34df9a5e]  Ryan Rittgarn <rrittgarn@techpro.com>
+
+	* app_voicemail: VoiceMailPlayMsg did not play database stored messages
+
+	  When attempting to use VoiceMailPlayMsg with a realtime data backend
+	  the message is located, but never retrieved. This patch adds the
+	  required RETRIEVE and DISPOSE calls that will fetch the message from
+	  the database (and IMAP storage as well for that matter).
+
+	  Also, removed extraneous make_file call.
+
+	  ASTERISK-26723 #close
+
+	  Change-Id: I1e122dd53c0f3d7faa10f3c2b7e7e76a47d51b8c
+
+2017-02-14 08:12 +0000 [f99e5f4de4]  var <cbrunker@appenbutlerhill.com>
+
+	* app_record: Add option to prevent silence from being truncated
+
+	  When using Record() with the silence detection feature, the stream is
+	  written out to the given file. However, if only 'silence' is detected,
+	  this file is then truncated to the first second of the recording.
+
+	  This patch adds the 'u' option to Record() to override that behavior.
+
+	  ASTERISK-18286 #close
+	  Reported by: var
+	  Patches:
+	  	app_record-1.8.7.1.diff (license #6184) patch uploaded by var
+
+	  Change-Id: Ia1cd163483235efe2db05e52f39054288553b957
+
+2017-02-11 09:57 +0000 [ea8a610776]  Sean Bright <sean.bright@gmail.com>
+
+	* cli: Fix various CLI documentation and completion issues
+
+	  * app_minivm: Use built-in completion facilities to complete optional
+	  arguments.
+
+	  * app_voicemail: Use built-in completion facilities to complete
+	  optional arguments.
+
+	  * app_confbridge: Add missing colons after 'Usage' text.
+
+	  * chan_alsa: Use built-in completion facilities to complete optional
+	  arguments.
+
+	  * chan_sip: Use built-in completion facilities to complete optional
+	  arguments. Add completions for 'load' for 'sip show user', 'sip show
+	  peer', and 'sip qualify peer.'
+
+	  * chan_skinny: Correct and extend completions for 'skinny reset' and
+	  'skinny show line.'
+
+	  * func_odbc: Correct completions for 'odbc read' and 'odbc write'
+
+	  * main/asterisk: Correct and extend completions for 'core show file
+	  version.'
+
+	  * main/astmm: Use built-in completion facilities to complete arguments
+	  for 'memory' commands.
+
+	  * main/bridge: Correct completions for 'bridge kick.'
+
+	  * main/ccss: Use built-in completion facilities to complete arguments
+	  for 'cc cancel' command.
+
+	  * main/cli: Add 'all' completion for 'channel request hangup.' Correct
+	  completions for 'core set debug channel.' Correct completions for 'core
+	  show calls.'
+
+	  * main/pbx_app: Remove redundant completions for 'core show
+	  applications.'
+
+	  * main/pbx_hangup_handler: Remove unused completions for 'core show
+	  hanguphandlers all.'
+
+	  * res_sorcery_memory_cache: Add completion for 'reload' argument of
+	  'sorcery memory cache stale' and properly implement.
+
+	  Change-Id: Iee58c7392f6fec34ad9d596109117af87697bbca
+
+2017-01-13 11:21 +0000 [17030100ca]  Norbert Varga <vnorbix@gmail.com>
+
+	* chan_pjsip: Multidomain endpoint finding on call
+
+	  When PJSIP tries to call an endpoint with a domain (e.g. 1000@test.com),
+	  the user part is stripped down as it would be a trunk with a specified user,
+	  and only the host part is called as a PJSIP endpoint and can't be found.
+	  This is not correct in the case of a multidomain SIP account, so the stripping
+	  after the @ sign is done only if the whole endpoint (in multidomain case
+	  1000@test.com) can't be found.
+
+	  ASTERISK-26248
+
+	  Change-Id: I3a2dd6f57f3bd042df46b961eccd81d31ab202e6
+
+2017-02-13 05:05 +0000 [18f1b52601]  Joshua Colp <jcolp@digium.com>
+
+	* channel: Protect flags in ast_waitfor_nandfds operation.
+
+	  The ast_waitfor_nandfds operation will manipulate the flags
+	  of channels passed in. This was previously done without
+	  the channel lock being held. This could result in incorrect
+	  values existing for the flags if another thread manipulated
+	  the flags at the same time.
+
+	  This change locks the channel during flag manipulation.
+
+	  ASTERISK-26788
+
+	  Change-Id: I2c5c8edec17c9bdad4a93291576838cb552ca5ed
+
+2017-02-11 11:25 +0000 [a46a21642e]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip.c: Fix inconsistency between warning and action.
+
+	  The original return value corresponded to AST_SIP_AUTHENTICATION_CHALLENGE
+	  but we have no authenticator registered to create the challenge.
+
+	  Change-Id: I62368180d774b497411b80fbaabd0c80841f8512
+
+2017-02-11 11:26 +0000 [67b21dc63a]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Fix off-nominal tdata ref leak.
+
+	  Change-Id: I571f371d0956a8039b197b4dbd8af6b18843598d
+
+2017-02-09 10:01 +0000 [8936568515]  Sean Bright <sean.bright@gmail.com>
+
+	* manager: Restore Originate failure behavior from Asterisk 11
+
+	  In Asterisk 11, if the 'Originate' AMI command failed to connect the provided
+	  Channel while in extension mode, a 'failed' extension would be looked up and
+	  run. This was, I believe, unintentionally removed in 51b6c49. This patch
+	  restores that behavior.
+
+	  This also adds an enum for the various 'synchronous' modes in an attempt to
+	  make them meaningful.
+
+	  ASTERISK-26115 #close
+	  Reported by: Nasir Iqbal
+
+	  Change-Id: I8afbd06725e99610e02adb529137d4800c05345d
+
+2017-02-08 14:27 +0000 [2817f87d27]  Richard Mudgett <rmudgett@digium.com>
+
+	* core: Cleanup some channel snapshot staging anomalies.
+
+	  We shouldn't unlock the channel after starting a snapshot staging because
+	  another thread may interfere and do its own snapshot staging.
+
+	  * app_dial.c:dial_exec_full() made hold the channel lock while setting up
+	  the outgoing channel staging.  Made hold the channel lock after the called
+	  party answers while updating the caller channel staging.
+
+	  * chan_sip.c:sip_new() completed the channel staging on off-nominal exit.
+	  Also we need to use ast_hangup() instead of ast_channel_unref() at that
+	  location.
+
+	  * channel.c:__ast_channel_alloc_ap() added a comment about not needing to
+	  complete the channel snapshot staging on off-nominal exit paths.
+
+	  * rtp_engine.c:ast_rtp_instance_set_stats_vars() made hold the channel
+	  locks while staging the channels for the stats channel variables.
+
+	  Change-Id: Iefb6336893163f6447bad65568722ad5d5d8212a
+
+2017-02-10 09:35 +0000 [c7fcc4468f]  gtjoseph <gjoseph@digium.com>
+
+	* configs/samples: Fix placement of 'identify' entry in sorcery.conf
+
+	  The entry for 'identify' was incorrectly placed in the
+	  res_pjsip section when it should be in
+	  res_pjsip_endpoint_identifier_ip.
+
+	  ASTERISK-26785 #close
+
+	  Change-Id: Ia1372b12a952bfe2df6b1b1e0e725ca306a5d41a
+
+2017-02-08 11:50 +0000 [cbc23c31cf]  Mark Michelson <mmichelson@digium.com>
+
+	* Revert "Update qualifies when AOR configuration changes."
+
+	  This reverts commit 6492e91392b8fd394193e411c6eb64b45486093f.
+
+	  The change in question was intended to prevent the need to reload in
+	  order to update qualifies on contacts when an AOR changes. However, this
+	  ended up causing a deadlock instead.
+
+	  Change-Id: I1a835c90a5bb65b6dc3a1e94cddc12a4afc3d71e
+
+2017-02-07 12:01 +0000 [7e14e086cf]  nappsoft <infos@nappsoft.com> (license 6822)
+
+	* srv: Fix crash when ast_srv_lookup is used and 0 records are returned.
+
+	  When performing an SRV lookup using the ast_srv_lookup function it
+	  did not properly handle the situation where 0 records are returned.
+	  If this happened it would wrongly assume that at least one record
+	  was present.
+
+	  This change fixes the code so it will exit early if an error occurs
+	  or if 0 records are returned.
+
+	  ASTERISK-26772
+	  patches:
+	    srv_lookup.patch submitted by nappsoft (license 6822)
+
+	  Change-Id: I09b19081c74e0ad11c12bf54a257243b1bcb2351
+
+2017-02-06 11:40 +0000 [7b39d6901a]  Joshua Colp <jcolp@digium.com>
+
+	* res_stasis_device_state: Protect the adding/removing of subscriptions.
+
+	  The adding and removing of device state subscriptions did not protect
+	  fully against simultaneous manipulation. In particular the subscribe
+	  case allowed a small window where two subscriptions could be added for
+	  the same device state instead of just one.
+
+	  This change makes the code hold the subscriptions lock for the entirety
+	  of each operation to ensure that two are not occurring at the same time.
+
+	  ASTERISK-26770
+
+	  Change-Id: I3e7f8eb9d09de440c9024d2dd52029f6f20e725b
+
+2017-02-01 17:56 +0000 [c384dfd6b0]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Fix some off nominal tdata leaks.
+
+	  Change-Id: I243a4be5e7fbfe604923764969c4ee04eee89b9d
+
+2017-02-06 16:27 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.14.0-rc1 Released.
+
+2017-02-02 11:26 +0000 [70aff89e5d]  Sean Bright <sean.bright@gmail.com>
+
+	* res_odbc: Remove deprecated settings from sample configuration file
+
+	  ASTERISK-26704 #close
+	  Reported by: Anthony Messina
+
+	  Change-Id: I976a1f94cf79c5f31e76174c61f5c6a65fd6354f
+
+2017-02-01 15:56 +0000 [3aee199913]  Sean Bright <sean.bright@gmail.com>
+
+	* audiohooks:  Muting a hook can mute underlying frames
+
+	  If an audiohook is placed on a channel that does not require transcoding,
+	  muting that hook will cause the underlying frames to be muted as well.
+
+	  The original patch is from David Woolley but I have modified slightly.
+
+	  ASTERISK-21094 #close
+	  Reported by: David Woolley
+	  Patches:
+	        ASTERISK-21094-Patch-1.8-1.txt (license #5737) patch uploaded
+	        by David Woolley
+
+	  Change-Id: Ib2b68c6283e227cbeb5fa478b2d0f625dae338ed
+
+2017-02-01 13:54 +0000 [6492e91392]  Mark Michelson <mmichelson@digium.com>
+
+	* Update qualifies when AOR configuration changes.
+
+	  Prior to this change, qualifies would only update in the following
+	  cases:
+	  * A reload of res_pjsip.so was issued.
+	  * A dynamic contact was re-registered after its AOR's qualify_frequency
+	    had been changed
+	  This does not work well if you are using realtime for your AORs. You can
+	  update your database to have a new qualify_frequency, but the permanent
+	  contacts on that AOR will not have their qualifies updated. And the
+	  dynamic contacts on that AOR will not have their qualifies updated until
+	  the next registration, which could be a long time.
+
+	  This change seeks to fix this problem by making it so that whenever AOR
+	  configuration is applied, the contacts pertaining to that AOR have their
+	  qualifies updated.
+
+	  Additions from this patch:
+	  * AOR sorcery objects now have an apply handler that calls into a newly
+	    added function in the OPTIONS code. This causes all contacts
+	    associated with that AOR to re-schedule qualifies.
+	  * When it is time to qualify a contact, the OPTIONS code checks to see
+	    if the AOR can still be retrieved. If not, then qualification is
+	    canceled on the contact.
+
+	  Alterations from this patch:
+	  * The registrar code no longer updates contact's qualify_frequence and
+	    qualify_timeout. There is no point to this since those values already
+	    get updated when the AOR changes.
+	  * Reloading res_pjsip.so no longer calls the OPTIONS initialization
+	    function. Reloading res_pjsip.so results in re-loading AORs, which
+	    results in re-scheduling qualifies.
+
+	  Change-Id: I2e7c3316da28f389c45954f24c4e9389abac1121
+
+2017-01-31 18:28 +0000 [43f0ff4b69]  Richard Mudgett <rmudgett@digium.com>
+
+	* channel.c: Fix unbalanced read queue deadlocking local channels.
+
+	  Using the timerfd timing module can cause channel freezing, lingering, or
+	  deadlock issues.  The problem is because this is the only timing module
+	  that uses an associated alert-pipe.  When the alert-pipe becomes
+	  unbalanced with respect to the number of frames in the read queue bad
+	  things can happen.  If the alert-pipe has fewer alerts queued than the
+	  read queue then nothing might wake up the thread to handle received frames
+	  from the channel driver.  For local channels this is the only way to wake
+	  up the thread to handle received frames.  Being unbalanced in the other
+	  direction is less of an issue as it will cause unnecessary reads into the
+	  channel driver.
+
+	  ASTERISK-26716 is an example of this deadlock which was indirectly fixed
+	  by the change that found the need for this patch.
+
+	  * In channel.c:__ast_queue_frame(): Adding frame lists to the read queue
+	  did not add the same number of alerts to the alert-pipe.  Correspondingly,
+	  when there is an exceptionally long queue event, any removed frames did
+	  not also remove the corresponding number of alerts from the alert-pipe.
+
+	  ASTERISK-26632 #close
+
+	  Change-Id: Ia98137c5bf6e9d6d202ce0eb36441851875863f6
+
+2017-01-31 16:38 +0000 [a199f94908]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_agi: Prevent an AGI from eating frames it should not. (Re-do)
+
+	  A dialplan intercept routine is equivalent to an interrupt routine.  As
+	  such, the routine must be done quickly and you do not have access to the
+	  media stream.  These restrictions are necessary because the media stream
+	  is the responsibility of some other code and interfering with or delaying
+	  that processing is bad.  A possible future dialplan processing
+	  architecture change may allow the interception routine to run in a
+	  different thread from the main thread handling the media and remove the
+	  execution time restriction.
+
+	  * Made res_agi.c:run_agi() running an AGI in an interception routine run
+	  in DeadAGI mode.  No touchy channel frames.
+
+	  ASTERISK-25951
+
+	  ASTERISK-26343
+
+	  ASTERISK-26716
+
+	  Change-Id: I638f147ca7a7f2590d7194a8ef4090eb191e4e43
+
+2017-01-31 16:32 +0000 [6bed318a66]  Richard Mudgett <rmudgett@digium.com>
+
+	* Frame deferral: Revert API refactoring.
+
+	  There are several issues with deferring frames that are caused by the
+	  refactoring.
+
+	  1) The code deferring frames mishandles adding a deferred frame to the
+	  deferred queue.  As a result the deferred queue can only be one frame
+	  long.
+
+	  2) Deferrable frames can come directly from the channel driver as well as
+	  the read queue.  These frames need to be added to the deferred queue.
+
+	  3) Whoever is deferring frames is really only doing the __ast_read() to
+	  collect deferred frames and doesn't care about the returned frames except
+	  to detect a hangup event.  When frame deferral is completed we must make
+	  the normal frame processing see the hangup as a frame anyway.  As such,
+	  there is no need to have varying hangup frame deferral methods.  We also
+	  need to be aware of the AST_SOFTHANGUP_ASYNCGOTO hangup that isn't real.
+	  That fake hangup is to cause the PBX thread to break out of loops to go
+	  execute a new dialplan location.
+
+	  4) To properly deal with deferrable frames from the channel driver as
+	  pointed out by (2) above, means that it is possible to process a dialplan
+	  interception routine while frames are deferred because of the
+	  AST_CONTROL_READ_ACTION control frame.  Deferring frames is not
+	  implemented as a re-entrant operation so you could have the unsupported
+	  case of two sections of code thinking they have control of the media
+	  stream.
+
+	  A worse problem is because of the bad implementation of the AMI PlayDTMF
+	  action.  It can cause two threads to be deferring frames on the same
+	  channel at the same time.  (ASTERISK_25940)
+
+	  * Rather than fix all these problems simply revert the API refactoring as
+	  there is going to be only autoservice and safe_sleep deferring frames
+	  anyway.
+
+	  ASTERISK-26343
+
+	  ASTERISK-26716 #close
+
+	  Change-Id: I45069c779aa3a35b6c863f65245a6df2c7865496
+
+2017-01-31 11:17 +0000 [e371e13b9e]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip: Handle invocation of callback on outgoing request when error occurs.
+
+	  There are some error cases in PJSIP when sending a request that will
+	  result in the callback for the request being invoked.  The code did not
+	  handle this case and assumed on every error case that the callback was not
+	  invoked.
+
+	  The code has been changed to check whether the callback has been invoked
+	  and if so to absorb the error and treat it as a success.
+
+	  ASTERISK-26679
+	  ASTERISK-26699
+
+	  Change-Id: I563982ba204da5aa1428989a11c06dd9087fea91
+
+2017-01-30 09:02 +0000 [339c30f2b6]  Sean Bright <sean.bright@gmail.com>
+
+	* res_rtp_asterisk:  Swap byte-order when sending signed linear
+
+	  Before Asterisk 13, signed linear was converted into network byte order by a
+	  smoother before being sent over the network. We restore this behavior by
+	  forcing the creation of a smoother when slinear is in use and setting the
+	  appropriate flags so that the byte order conversion is always done.
+
+	  ASTERISK-24858 #close
+	  Reported-by: Frankie Chin
+
+	  Change-Id: I868449617d1a7819578f218c8c6b2111ad84f5a9
+
+2017-01-31 12:46 +0000 [7fd28cefdb]  gtjoseph <gjoseph@digium.com>
+
+	* debug_utilities: Install ast_logescalator to /var/lib/asterisk/scripts
+
+	  Forgot to install it with the original patch
+
+	  Change-Id: I8bdb540a6694971ae5fe21f48d532332c6482e4c
+
+2017-01-25 06:50 +0000 [456bc3c704]  gtjoseph <gjoseph@digium.com>
+
+	* debug_utilities:  Add ast_logescalator
+
+	  The escalator works by creating a set of startup commands in cli.conf
+	  that set up logger channels and issue the debug commands for the
+	  subsystems specified.  If asterisk is running when it is executed,
+	  the same commands will be issued to the running instance.  The original
+	  cli.conf is saved before any changes are made and can be restored by
+	  executing '$prog --reset'.
+
+	  The log output will be stored in...
+	  $astlogdir/message.$uniqueid
+	  $astlogdir/debug.$uniqueid
+	  $astlogdir/dtmf.$uniqueid
+	  $astlogdir/fax.$uniqueid
+	  $astlogdir/security.$uniqueid
+	  $astlogdir/pjsip_history.$uniqueid
+	  $astlogdir/sip_history.$uniqueid
+
+	  Some minor tweaks were made to chan_sip, and res_pjsip_history
+	  so their history output could be send to a log channel as packets
+	  are captured.
+
+	  A minor tweak was also made to manager so events are output to verbose
+	  when "manager set debug on" is issued.
+
+	  Change-Id: I799f8e5013b86dc5282961b27383d134bf09e543
+
+2017-01-23 09:35 +0000 [54b027916a]  Torrey Searle <torrey@voxbone.com>
+
+	* libastssl/pj: libastssl/pj should have an so_version
+
+	  Issue introduced in b59956a87.  In the non-darwin case libastssl/pj
+	  should be versioned.  This causes the symbol file for this lib
+	  to not be generated.
+
+	  Change-Id: Ib07ae8c40252813c488e2c1ac6204fd42816dd4c
+
+2017-01-24 19:51 +0000 [3c8f84786e]  Kirill Katsnelson <kkm@smartaction.com>
+
+	* make_build_h: handle backslashes in external strings
+
+	  LikewiseOpen creates user names with a backslash in them. A gentle
+	  massage with sed(1) allows such strings to be inserted into build.h
+	  properly quoted. I am also adding the same for host name and other
+	  strings used in the script that are more or less user-controlled.
+
+	  ASTERISK-26754
+
+	  Change-Id: Iac5ef2b67a68ee58f35ddbf86bb818ba6eabecae
+
+2017-01-17 20:46 +0000 [555e8cd2ba]  Kirill Katsnelson <kkm@smartaction.com>
+
+	* ast_careful_fwrite to support EPIPE gracefully
+
+	  When a reading end of the network socket is closed by an AMI manager,
+	  the EPIPE is signaled when writing to our end, resulting in the
+	  spurious log error message
+
+	    ast_careful_fwrite: fwrite() returned error: Broken pipe
+
+	  Previously EPIPE was handled in ast_carefulwrite() a few lines above,
+	  but not in this function.
+
+	  ASTERISK-26753
+
+	  Change-Id: I6a67335cd6526608bb9b78f796c626b1677664b8
+
+2017-01-24 22:31 +0000 [be92f10a16]  Kirill Katsnelson <kkm@smartaction.com>
+
+	* app_queue: Fix queues randomly disappearing on reload
+
+	  With 500+ queues and a reload every minute, a random queue disappears
+	  upon reload. The cause is mususe of the 'dead' flag. Namely, all queues
+	  were marked dead up front, and then "resurrected" by dropping this flag
+	  for those found in the configuration. But a queue marked dead can be
+	  removed also when control leaves the app entry point on a PBX thread.
+
+	  With this change, the queue is marked only not found, and at the end of
+	  reload only the queues that are still not found are actually marked as
+	  dead, so the dead flag is never reset, and set only on positively dead
+	  queues.
+
+	  ASTERISK-26755
+
+	  Change-Id: I3a4537aec9eb8d8aeeaa0193407e3523feb004bf
+
+2017-01-26 07:57 +0000 [aae9df0643]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_endpoint_identifier_ip: Fix memory leak of hosts when resolving.
+
+	  This change adds a missing unreference of the hostname when resolving and
+	  also cleans up the iterator.
+
+	  ASTERISK-26735
+
+	  Change-Id: Ic012ebaf3d89e714eec340b7b0c5e63c66af857a
+
+2017-01-25 15:26 +0000 [9e3150b98d]  Mark Michelson <mmichelson@digium.com>
+
+	* Add reload options to CLI/AMI stale object commands.
+
+	  Marking an object as stale in a memory cache is supposed to prime the
+	  cache so that the next time the item is retrieved, the stale item is
+	  deleted from the cache and a background task is run to re-populate the
+	  cache with a fresh version of the object.
+
+	  The problem is, there are some object types out there for which there is
+	  no natural reason that they would be retrieved from the backend with any
+	  regularity. Outbound PJSIP registrations are a good example of this. At
+	  startup, they are read, and an object-specific state is created that
+	  refers to the initially-retrieved object for all time.
+
+	  Adding the "reload" option to the CLI/AMI commands gives the cache the
+	  opportunity to manually re-retrieve the object from the backend, both
+	  storing the new object in the cache and applying the new object's
+	  configuration to the module that uses that object.
+
+	  Change-Id: Ieb1fe7270ceed491f057ec5cbf0e097bde96c5c8
+
+2017-01-10 17:39 +0000 [c54f9d2bf0]  Richard Mudgett <rmudgett@digium.com>
+
+	* T.140: Fix format ref and memory leaks.
+
+	  * channel.c:ast_sendtext(): Fix T.140 SendText memory leak.
+
+	  * format_compatibility.c: T.140 RED and T.140 were swapped.
+
+	  * res_rtp_asterisk.c:rtp_red_init(): Fix ast_format_t140_red ref leak.
+
+	  * res_rtp_asterisk.c:rtp_red_init(): Fix data race after starting periodic
+	  scheduled red_write().
+
+	  * res_rtp_asterisk.c: Some other minor misc tweaks.
+
+	  Change-Id: Ifa27a2e0f8a966b1cf628607c86fc4374b0b88cb
+
+2017-01-24 15:39 +0000 [a2f0adccbd]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_endpoint_identifier_ip: Ensure error defaults to 0.
+
+	  When configuring a match using a netmask the error variable was
+	  not defaulting to 0. For some people this would cause the code
+	  to think an error occurred when adding the match when in reality
+	  it added perfectly fine.
+
+	  ASTERISK-26693
+
+	  Change-Id: I850c250813742bddde65c84e739093c9e01dfe56
+
+2017-01-10 17:37 +0000 [607b3ac736]  Richard Mudgett <rmudgett@digium.com>
+
+	* astobj2.c: Add excessive ref count trap.
+
+	  Change-Id: I32e6a589cf9009450e4ff7cb85c07c9d9ef7fe4a
+
+2017-01-10 13:11 +0000 [ab8cb5a7ce]  Richard Mudgett <rmudgett@digium.com>
+
+	* main/app.c: Memory corruption from early format destruction.
+
+	  * make_silence() created a malloced silence slin frame without adding a
+	  slin format ref.  When the frame is destroyed it will unref the slin
+	  format that never had a ref added.  Memory corruption is expected to
+	  follow.
+
+	  * Simplified and fixed counting the number of samples in a frame list for
+	  make_silence().
+
+	  * Eliminated an unnecessary RAII_VAR associated with the make_silence()
+	  frame.
+
+	  Change-Id: I47de3f9b92635b7f8b4d72309444d6c0aee6f747
+
+2017-01-11 14:59 +0000 [dcd8e4b1a0]  Richard Mudgett <rmudgett@digium.com>
+
+	* frame.c: Fix off-nominal format ref leaks.
+
+	  * ast_frisolate() could leak frame format refs on allocation
+	  failures.
+
+	  * Similified code in ast_frisolate() and code used by
+	  ast_frisolate().
+
+	  Change-Id: I79566d4d36b3d7801bf0c8294fcd3e9a86a2ed6d
+
+2017-01-13 19:08 +0000 [00a227e93d]  Richard Mudgett <rmudgett@digium.com>
+
+	* stasis_bridge.c: Fix off-nominal stasis control ref leak.
+
+	  Change-Id: Ib17218343a6596832060180e19386da9df150ac8
+
+2017-01-10 12:30 +0000 [38a2021c68]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_musiconhold.c: Fix format ref leak when parsing MOH config class.
+
+	  Change-Id: Ica8e8e2ce7604c2c61ec55bef07dc675361d2ea5
+
+2017-01-10 14:03 +0000 [ab7a9fc5b2]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_oss.c: Fix format ref leak in oss_read().
+
+	  Change-Id: I0a5d56c7dcf327d60f86a4c25a23571733709fd0
+
+2017-01-10 17:48 +0000 [1484a991e1]  Richard Mudgett <rmudgett@digium.com>
+
+	* Add notes about embedded ast_frame structs holding a format ref.
+
+	  mod_format.h: Note ast_filestream.fr holds a format ref.
+
+	  translate.h: Note ast_trans_pvt.f holds a format ref.
+
+	  Change-Id: I86bda354d725207b41e08920355d7c31b2d7f749
+
+2017-01-19 09:05 +0000 [17f4989d49]  gtjoseph <gjoseph@digium.com>
+
+	* ari: Implement 'debug all' and request/response logging
+
+	  The 'ari set debug' command has been enhanced to accept 'all' as an
+	  application name.  This allows dumping of all apps even if an app
+	  hasn't registered yet.  To accomplish this, a new global_debug global
+	  variable was added to res/stasis/app.c and new APIs were added to
+	  set and query the value.
+
+	  'ari set debug' now displays requests and responses as well as events.
+	  This required refactoring the existing debug code.
+
+	  * The implementation for 'ari set debug' was moved from stasis/cli.{c,h}
+	    to ari/cli.{c,h}, and stasis/cli.{c,h} were deleted.
+	  * In order to print the body of incoming requests even if a request
+	    failed, the consumption of the body was moved from the ari stubs
+	    to ast_ari_callback in res_ari.c and the moustache templates were
+	    then regenerated.  The body is now passed to ast_ari_invoke and then
+	    on to the handlers.  This results in code savings since that template
+	    was inserted multiple times into all the stubs.
+
+	  An additional change was made to the ao2_str_container implementation
+	  to add partial key searching and a sort function.  The existing cli
+	  code assumed it was already there when it wasn't so the tab completion
+	  was never working.
+
+	  Change-Id: Ief936f747ce47f1fb14035fbe61152cf766406bf
+
+2017-01-20 21:13 +0000 [30cb4eb57f]  Richard Mudgett <rmudgett@digium.com>
+
+	* PJPROJECT logging: Fix detection of max supported log level.
+
+	  The mechanism used for detecting the maximum log level compiled into the
+	  linked pjproject did not work.  The API call simply stores the requested
+	  level into an integer and does no range checking.  Asterisk was assuming
+	  that there was range checking and limited the new value to the allowable
+	  range.  To get the actual maximum log level compiled into the linked
+	  pjproject we need to get and save off the initial set log level from
+	  pjproject.  This is the maximum log level supported.
+
+	  * Get and save off the initial log level setting before altering it to the
+	  desired level on startup.  This has to be done by a macro rather than
+	  calling a core function to avoid incorrectly linking pjproject.
+
+	  * Split the initial log level warning messages to warn if the linked
+	  pjproject cannot support the requested startup level and if it is too low
+	  to get the pjproject buildopts for "pjproject show buildopts".
+
+	  * Adjust the CLI "pjproject set log level" to check the saved max log
+	  level and to generate normal output messages instead of a warning message.
+
+	  ASTERISK-26743 #close
+
+	  Change-Id: I40aa76653e2a1dece66c3f8734594b4f0471cfb4
+
+2017-01-21 14:43 +0000 [cd2677f966]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* tests: use datadir for sound files
+
+	  Some (voicemail-related) tests API symlinks beep.gsm and other files
+	  from ast_config_AST_VAR_DIR. It should use ast_config_AST_DATA_DIR.
+
+	  ASTERISK-26740 #close
+
+	  Change-Id: Id49c56fb9e16df64b1a2b829693ca7601252df89
+
+2017-01-20 23:41 +0000 [b62f84bfb1]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* test_voicemail_api: order of params to VERIFY macros
+
+	  Fix order of parameters in calls to VM_API_INT_VERIFY and
+	  VM_API_STRING_VERIFY
+
+	  ASTERISK-26739 #close
+
+	  Change-Id: I30dc6b36893aadad6012be3f16f93aa5720870d6
+	  Note: status: builds. Not tested any further.
+
+2017-01-05 13:21 +0000 [e3dcb9ddd9]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Implement "pjsip show subscriptions" commands.
+
+	  ASTERISK-23828 #close
+
+	  Change-Id: Ifb8a3b61f447aedc58a8e6b36a810f7566018567
+
+2017-01-23 16:18 +0000 [75497c33ea]  Mark Michelson <mmichelson@digium.com>
+
+	* Free endpoint ACLs when destroying PJSIP endpoints.
+
+	  If endpoint ACLs were specified, they were not being freed
+	  when endpoints were destroyed. On systems with realtime endpoints, this
+	  could add up quickly since each DB lookup would allocate the ACL without
+	  freeing it.
+
+	  ASTERISK-26731 #close
+	  Reported by Ustinov Artem
+
+	  Change-Id: Ie1f8bf5b7a0de628c975beba01e69c56893331ad
+
+2017-01-23 09:10 +0000 [177e81ee47]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled: Fix setting max log level
+
+	  An earlier attempt to prevent pjsua from spitting out an extra 6795
+	  lines of debug output every time the testsuite called it was also
+	  turning off the ability for asterisk to output debug info when it
+	  needed to.  This patch reverts the earlier fix and instead adds
+	  a pjproject patch that sets the startup log level to 1 for pjsua
+	  pjsystest and the pjsua python binding.  This is an asterisk-only
+	  patch that does not affect pjproject functionality and will not be
+	  submitted upstream.
+
+	  Change-Id: I347a8b58b2626f2906ccfc1d339e907627a0c9e8
+
+2017-01-23 10:08 +0000 [6d23b2e360]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_endpoint_identifier_ip: Read settings before resolving.
+
+	  An option has been added, srv_lookups, which controls whether
+	  SRV lookups are performed on the provided match hosts or not.
+	  It was possible for this option to be applied after resolution
+	  had already happened.
+
+	  This change makes it so hosts are stored away, settings are read
+	  and applied, and then resolution is done. This ensures that no
+	  matter the ordering the srv_lookups option is in effect.
+
+	  ASTERISK-26735
+
+	  Change-Id: I750378cb277be0140f8c5539450270afbfc43388
+
+2017-01-22 17:25 +0000 [a969bf3577]  Richard Mudgett <rmudgett@digium.com>
+
+	* LISTFILTER: Remove outdated ERROR message.
+
+	  Feeding LISTFILTER an empty variable results in an invalid ERROR message.
+	  Earlier changes made the message useless because we can no longer tell if
+	  the variable is empty or does not exist.  It is valid to try to remove a
+	  value from an empty list just as it is valid to try to remove a value that
+	  is not in a non-empty list.
+
+	  * Removed the outdated ERROR message.
+
+	  * Added more test cases to the LISTFILTER unit test.
+
+	  Change-Id: Ided9040e6359c44a335ef54e02ef5950a1863134
+
+2017-01-05 15:11 +0000 [3890337e7a]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Fix AMI event list counts.
+
+	  Fix the AMI PJSIPShowSubscriptionsInbound, PJSIPShowSubscriptionsOutbound,
+	  and PJSIPShowResourceLists actions event counts.  The reported counts may
+	  not necessarily be accurate depending on what happens.
+
+	  The subscriptions count would be wrong if Asterisk ever has outbound
+	  subscriptions.
+
+	  The resource list count could be wrong if a list were added or removed
+	  during the AMI action being processed.
+
+	  Change-Id: I4344301827523fa174960a42c413fd19abe4aed5
+
+2017-01-05 13:02 +0000 [fe4801c4f9]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Fix incorrect message string wrapping.
+
+	  Change-Id: Id771e6fe56d89ce365ddcbb423f820af97211120
+
+2017-01-05 13:01 +0000 [46484b8730]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Eliminate trivial SCOPED_LOCK usage.
+
+	  Change-Id: Ie0b69a830385452042fa19e7d267c6790ec6b6be
+
+2017-01-05 12:58 +0000 [8160474d7d]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: alloca can never fail.
+
+	  Change-Id: Ia2a6158e5fdf311bc2a1c0c43417978de504b1f1
+
+2017-01-13 11:03 +0000 [c628a7acac]  gtjoseph <gjoseph@digium.com>
+
+	* debug_utilities:  Create ast_loggrabber
+
+	  ast_loggrabber gathers log files from customizable search patterns,
+	  optionally converts POSIX timestamps to a readable format and
+	  tarballs the results.
+
+	  Also a few tweaks were made to ast_coredumper.
+
+	  Change-Id: I8bfe1468ada24c1344ce4abab7b002a59a659495
+	  (cherry picked from commit 5fa1c56d7e76999aa14f133a33f6b168e7c3b99c)
+
+2017-01-01 03:47 +0000 [e335b706ee]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_outbound_authenticator_digest.c: Fix spacing in warning messages.
+
+	  Change-Id: I573f0343c0c63a785cd4da60d57cc9f8b9ce7f49
+
+2017-01-12 15:58 +0000 [883e7fde31]  Kevin Harwell <kharwell@digium.com>
+
+	* abstract/fixed/adpative jitter buffer: disallow frame re-inserts
+
+	  It was possible for a frame to be re-inserted into a jitter buffer after it
+	  had been removed from it. A case when this happened was if a frame was read
+	  out of the jitterbuffer, passed to the translation core, and then multiple
+	  frames were returned from said translation core. Upon multiple frames being
+	  returned the first is passed on, but sebsequently "chained" frames are put
+	  back into the read queue. Thus it was possible for a frame to go back into
+	  the jitter buffer where this would cause problems.
+
+	  This patch adds a flag to frames that are inserted into the channel's read
+	  queue after translation. The abstract jitter buffer code then checks for this
+	  flag and ignores any frames marked as such.
+
+	  Change-Id: I276c44edc9dcff61e606242f71274265c7779587
+
+2017-01-13 21:23 +0000 [473330983b]  Richard Mudgett <rmudgett@digium.com>
+
+	* taskprocessor.c: Change when high water warning logged.
+
+	  The task processor queue reached X scheduled tasks message was originally
+	  intended to get logged only once per task processor to prevent spamming
+	  the log.  This is no longer necessary since high and low water thresholds
+	  can better control when the message is logged.
+
+	  It is beneficial to generate the warning each time a task processor
+	  reaches the high water level because PJSIP stops processing new requests
+	  while any high water alert is active.  Without this change you would have
+	  to enable at least debug level 3 logging to know about a repeated alert
+	  trigger.
+
+	  * Made generate the warning message whenever a task is pushed into the
+	  task processor that triggers the high water alert.
+
+	  * Appended 'again' to the warning for a repeated high water alert trigger.
+
+	  Change-Id: Iabf75a004f7edaf1e5e8c323099418e667cac999
+
+2017-01-10 05:54 +0000 [0047b1bc49]  Aaron An <anjb@ti-net.com.cn>
+
+	* res_rtp_asterisk:  Fix bug in function CHANNEL(rtcp, all_rtt)
+
+	  Function CHANNEL(rtcp,all_rtt) CHANNEL(rtcp,all_loss) CHANNEL(rtcp,all_jitter)
+	  always return 0.0 due to wrong define of macro "AST_RTP_SATA_SET" and
+	  "AST_RTP_STAT_STRCPY".
+	  It should compare "combined" with "stat" not "current_stat".
+
+	  ASTERISK-26710 #close
+	  Reported-by: Aaron An
+	  Tested-by: AaronAn
+
+	  Change-Id: Id4140fafbf92e2db689dac5b17d9caa009028a15
+
+2017-01-10 18:10 +0000 [47474cfd54]  gtjoseph <gjoseph@digium.com>
+
+	* debug_utilities:  Create the ast_coredumper utility
+
+	  This utility allows easy manipulation of asterisk coredumps.
+
+	  * Configurable search paths and patterns for existing coredumps
+	  * Can generate a consistent coredump from the running instance
+	  * Can dump the lock_infos table from a coredump
+	  * Dumps backtraces to separate files...
+	    - thread apply 1 bt full -> <coredump>.thread1.txt
+	    - thread apply all bt -> <coredump>.brief.txt
+	    - thread apply all bt full -> <coredump>.full.txt
+	    - lock_infos table -> <coredump>.locks.txt
+	  * Can tarball corefiles and optionally delete them after processing
+	  * Can tarball results files and optionally delete them after processing
+	  * Converts ':' in coredump and results file names '-' to facilitate
+	    uploading.  Jira for instance, won't accept file names with colons
+	    in them.
+
+	  Tested on Fedora24+, Ubuntu14+, Debian6+, CentOS6+ and FreeBSD9+[1].
+
+	  [1] For *BSDs, the "devel/gdb" package might have to be installed to
+	  get a recent gdb.  The utility will check all instances of gdb
+	  it finds in $PATH and if one isn't found that can run python, it
+	  prints a friendly error.
+
+	  Change-Id: I935d37ab9db85ef923f32b05579897f0893d33cd
+
+2017-01-08 10:29 +0000 [f8cd73ec3c]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Fix compilation with MALLOC_DEBUG
+
+	  When MALLOC_DEBUG was specified, make was failing.  Immediately
+	  remaking would work.  The issues was in the ordering of the make
+	  dependencies.
+
+	  Change-Id: If6030b54fc693f3179f32bfd20c6b5d5f1b3f7cd
+
+2017-01-05 06:11 +0000 [37aaaa2da2]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_endpoint_identifier_ip: Add support for SRV lookups.
+
+	  This change implements SRV support for the IP based endpoint
+	  identifier module. All possible addresses through SRV are looked
+	  up and added as matches. If no SRV records are available a
+	  fallback to normal host resolution is done. If an IP address
+	  is provided then no SRV lookup occurs.
+
+	  This is configured using the "srv_lookups" option on the
+	  identify section and defaults to "yes".
+
+	  ASTERISK-26693
+
+	  Change-Id: I6b641e275bf96629320efa8b479737062aed82ac
+
+2016-12-22 09:13 +0000 [569dac8e50]  Alexander Traud <pabstraud@compuserve.com>
+
+	* res_pjsip_session: Access SIPDOMAIN via Dialplan.
+
+	  This feature was available in the SIP channel driver chan_sip. For example,
+	  Asterisk is the outbound proxy and has to handle all SIP-URIs, even domains not
+	  local to Asterisk. In that case, SIPDOMAIN is used in the Dialplan, to detect
+	  and dial remote SIP-URIs. This change here sets the SIP destination domain of
+	  an inbound call (SIPDOMAIN) in the SIP channel driver res_pjsip as well.
+
+	  ASTERISK-26670 #close
+
+	  Change-Id: I27c880dc404a3c1c6792e1ba3545475339577243
+
+2017-01-04 05:50 +0000 [367128e70b]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Remember SDP negotiation on SIP_CODEC_INBOUND.
+
+	  After a SIP_CODEC_INBOUND in the dialplan, do not continue with cached formats
+	  but remember the joint format. Cached formats contain default parameters,
+	  often create an empty fmtp line. However, a joint format might have passed
+	  format_get_joint(.) in a res_format_attr_* module (like Opus Codec) and
+	  contain the resulting format parameters from a SDP negotiation.
+
+	  ASTERISK-26691 #close
+
+	  Change-Id: I35712d98a793d4c3efdd156cec57deab9014b1dc
+
+2017-01-03 15:14 +0000 [d7e5a747c3]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Compile pjsua with max log level = 2
+
+	  A while back, we changed config_site.h to set PJ_LOG_MAX_LEVEL = 6.
+	  This allowed us to control the log level better from inside Asterisk.
+	  An unfortunate side effect of this was that the pjsua binary and
+	  python bindings were also compiled with log level set to 6 so whenever
+	  a testsuite test that uses pjsua runs, it spits out 6795 lines of
+	  debug in an instant even before the test starts.  I believe this
+	  overruns the Jenkins capture buffer and prevents the test from
+	  properly terminating.  In turn, this results in the testsuite just
+	  hanging until the job is killed.  It's more frequent on the higher
+	  end agents because they can spit out the messages faster.
+
+	  Unfortunately, the messages are all spit out before we have control
+	  of the python pj.Lib instance where we can set logging levels so the
+	  only alternative was to actually compile pjsua and _pjsua.so with an
+	  overridden PJ_LOG_MAX_LEVEL.  Although defining a lower max level was
+	  done in the Makefile, the define in config_site.h had to be wrapped
+	  with "#ifndef" so the change would take effect.
+
+	  Change-Id: I2af9e7d48dde1927279c586c9c725d868fe6f3ff
+
+2016-12-22 16:00 +0000 [34e728cfb9]  Joshua Colp <jcolp@digium.com>
+
+	* chan_pjsip: Use session for retrieving CHANNEL() information.
+
+	  The CHANNEL() dialplan function implementation for PJSIP allows
+	  querying of PJSIP specific information. This used the channel
+	  passed in to get the PJSIP session and associated information.
+	  It is possible for this channel to be masqueraded and end
+	  up as a different channel type by the time the information
+	  request is actually acted upon.
+
+	  This change retrieves the PJSIP session safely and accesses
+	  data from it (including channel). This provides a guarantee
+	  that the session and channel will not be altered when the
+	  request is being acted upon.
+
+	  ASTERISK-26673
+
+	  Change-Id: I335e12b89e1820cafdd92b3e7526b8ba649eb7e6
+
+2016-12-31 19:56 +0000 [a398f98b08]  Joshua Elson <joshelson@gmail.com>
+
+	* res_pjsip: Fix known compact header issues
+
+	  ASTERISK-26684 #close
+
+	  Change-Id: Ifd7e401c45015119dd5e8421dbfe3afa6381744a
+
+2016-12-30 09:10 +0000 [0ab9d103f6]  JoshE (license 6075)
+
+	* res_pjsip_refer:  Handle compact Refer-To header.
+
+	  refer_incoming_refer_request needed to look for the "r" header as well
+	  as the "Refer-To" header.
+
+	  ASTERISK-26655 #close
+	  patches:
+	  	refer_compact_fix.diff	submitted by JoshE (license 6075)
+
+	  Change-Id: I610410a99b02427ea5db887aeb454d5f12c2259f
+
+2016-12-23 12:11 +0000 [21151408f7]  Richard Mudgett <rmudgett@digium.com>
+
+	* bridge_native_rtp.c: Minor code cleanups.
+
+	  In native_rtp_bridge_compatible_check()
+
+	  * Made one variable declaration per line.
+
+	  * Extracted if test assignment to make the test easier to see.
+
+	  * Made long if tests easier to see the combinatorial logic.
+
+	  * Added bridge id to a couple debug messages.
+
+	  Change-Id: I65bc5732aa7c9a2537f062f106fbea711cf2daad
+
+2016-12-23 12:10 +0000 [9dcf9e9cea]  Richard Mudgett <rmudgett@digium.com>
+
+	* bridge_native_rtp.c: Fix native rtp bridge data race.
+
+	  native_rtp_bridge_compatible() didn't lock the bridge channels before
+	  checking the channels for native bridging ability.  As a result, one of
+	  the channel's native format capabilities structure got replaced out from
+	  under the native bridge check.  Use of a stale pointer to freed memory
+	  causes bad things to happen.
+
+	  MALLOC_DEBUG, DO_CRASH, and the
+	  tests/channels/pjsip/transfers/blind_transfer/caller_direct_media
+	  testsuite test caught this.
+
+	  * Add missing channel locking in native_rtp_bridge_compatible().
+
+	  Change-Id: If25fdb3ac8e85563c4857fb8216b3d9dc3d0fa53
+
+2016-12-21 16:28 +0000 [a9e459f8ac]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_rtp_asterisk.c: Fix uninitialized memory crash.
+
+	  ast_rtp_remote_address_set() could pass an uninitialized 'us' parameter to
+	  ast_ouraddrfor().  If ast_ouraddrfor() returns an error then the 'us'
+	  parameter may not get initialized.  Thus when the code tries to save the
+	  'us' parameter to the local address we could try to copy a ridiculous
+	  sized memory buffer and segfault.
+
+	  * Made pass an initialized 'us' parameter to ast_ouraddrfor().
+
+	  * Optimized out the 'us' struct variable.
+
+	  ASTERISK-26672 #close
+
+	  Change-Id: I4acea5dcdf0813da2c7d3e11c2d6067d160d17dc
+
+2016-12-21 17:55 +0000 [bcdd282ada]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_rtp_asterisk.c: Initialize ourip passed to ast_find_ourip().
+
+	  We access uninitialized memory when the 'ourip' parameter does not
+	  have an initial guess to our IP address.
+
+	  ASTERISK-26672
+
+	  Change-Id: I35507ea1ad7455d2be188f6ccdd4add7bd150e15
+
+2016-12-21 16:25 +0000 [ac31233dbe]  Richard Mudgett <rmudgett@digium.com>
+
+	* acl.c: Improve ast_ouraddrfor() diagnostic messages.
+
+	  * Made not generate strings unless they will actually be used.
+
+	  ASTERISK-26672
+
+	  Change-Id: I155fbe7fdff5ce47dfe5326f3baf5446849702c3
+
+2016-12-21 17:54 +0000 [0aa5db4b38]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_rtp.c: Fix uninitialized memory crash.
+
+	  unicast_rtp_request() could pass an uninitialized 'us' parameter to
+	  ast_ouraddrfor().  If ast_ouraddrfor() returns an error then the 'us'
+	  parameter may not get initialized.  Thus when the code tries to save the
+	  'us' parameter to the local address we could try to copy a ridiculous
+	  sized memory buffer and segfault.
+
+	  * Made pass an initialized 'us' parameter to ast_ouraddrfor() and abort
+	  the UnicastRTP channel request if it fails.
+
+	  ASTERISK-26672
+
+	  Change-Id: I1ef7a7c09f4da4f15dcb6de660d2bcac5f2a95c0
+
+2016-12-07 15:23 +0000 [e2fa3c7eda]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_rtp_asterisk.c: Fix off nominal memory leak.
+
+	  Change-Id: I95b1088d11244a2edae6607c12fbf33b38658a75
+
+2016-12-09 12:23 +0000 [d13be4eff6]  Martin Tomec <tomec@ipex.cz>
+
+	* app_queue: Ensure member is removed from pending when hanging up.
+
+	  In some cases member is added to pending_members, and the channel
+	  is hung up before any extension state change. So the member would
+	  stay in pending_members forever. So when we call do_hang, we
+	  should also remove member from pending.
+
+	  ASTERISK-26621 #close
+
+	  Change-Id: Iae476b5c06481db18ebe0fa594b3e80fdc9a7d54
+
+2016-12-18 15:23 +0000 [815f755155]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Make build single threaded
+
+	  There were just too many issues in various environments with
+	  multi threaded building of pjproject.  It doesn't really speed
+	  things up anyway since asterisk is already being compiled in
+	  parallel.
+
+	  Change-Id: Ie5648fb91bb89b4224b6bf43a0daa1af793c4ce1
+
+2016-12-08 20:00 +0000 [493849dcd7]  Corey Farrell <git@cfware.com>
+
+	* chan_sip: Reorder unload_module to deal with stuck TCP threads.
+
+	  In some situations TCP threads may become frozen.  This creates the
+	  possibility that Asterisk could segfault if they become unfrozen after
+	  chan_sip has been dlclose'd.  This reorders the unload_module process to
+	  allow abort if threads do not exit within 5 seconds.
+
+	  High level order as follows:
+	  1) Unregister from the core to stop new requests.
+	  2) Signal threads to stop
+	  3) Clear config based tables (but do not free the table itself).
+	  4) Verify that threads have shutdown, cancel unload if not.
+	  5) Clean all remaining resources.
+
+	  ASTERISK-26586
+
+	  Change-Id: Ie23692041d838fbd35ece61868f4c640960ff882
+
+2016-12-16 01:32 +0000 [ab447f8a6a]  David M. Lee <dlee@respoke.io>
+
+	* configure: fix with-pjproject-bundled
+
+	  The AC_ARG_WITH macro's shell variable is withval; not enableval. Purely
+	  coincidentally, the option would work when --enable-dev-mode is given.
+
+	  Also fixed a portability problem with bootstrap.sh, since -printf is not
+	  a portable option for find.
+
+	  Change-Id: I0f0e5b1a934b5af5737713834361e9c95b96b376
+
+2016-12-15 13:25 +0000 [35736d419a]  Richard Mudgett <rmudgett@digium.com>
+
+	* autosupport: Add 'pjproject show buildopts'
+
+	  Change-Id: I8aa55a7c3fb175235ddc7f85e9457d5102d06fa7
+
+2016-12-14 14:21 +0000 [4b285d226d]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_dahdi.c: Fix bounds check regression.
+
+	  Caused by ASTERISK-25494
+
+	  Change-Id: I1fc408c1a083745ff59da5c4113041bbfce54bcb
+
+2016-12-13 14:34 +0000 [9114574188]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Add/update ERROR msg if invalid URI.
+
+	  ASTERISK-24499
+
+	  Change-Id: Ie305153e47e922233b2ff24715e0e326e5fa3a6c
+
+2016-12-12 18:38 +0000 [75a6afbec5]  Richard Mudgett <rmudgett@digium.com>
+
+	* MESSAGE: Flush Message/ast_msg_queue channel alert pipe.
+
+	  ASTERISK-25083
+
+	  Change-Id: Id54baa57a8dbca84e29f28bcd2ffc0a5ac12d8b2
+
+2016-12-13 14:06 +0000 [91485734a4]  gtjoseph <gjoseph@digium.com>
+
+	* res_sorcery_memory_cache:  Change an error to a debug message
+
+	  When a sorcery user calls ast_sorcery_delete on an object that
+	  may have already expired from the cache, res_sorcery_memory_cache
+	  spits out an ERROR.  Since this can happen frequently and validly when
+	  an inbound registration expires after the cache entry expired, the
+	  errors are unnecessary and misleading.  Changed to a debug/1.
+
+	  Change-Id: Idf3a67038c16e3da814cf612ff4d6d18ad29ecd7
+
+2016-12-09 08:14 +0000 [cd46e86491]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Retry download if previously saved tarball is bad
+
+	  If a tarball is corrupted during download, the makefile will attempt to
+	  download it again. If the tarball somehow gets corrupted after it's
+	  downloaded however, the makefile was just failing.  We now
+	  retry the download.
+
+	  ASTERISK-26653 #close
+
+	  Change-Id: I1b24d454852d80186f60c5a65dc4624ea8a1c359
+
+2016-12-08 12:54 +0000 [22820e10fe]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* chan_sip: Delete unneeded check
+
+	  P is always true. We check it before
+
+	  Change-Id: Iee61cda002a9f61aee26b9f66c5f9b59e3389efb
+
+2016-12-08 12:58 +0000 [6aa2c5e5f9]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* Small code cleanup in chan_sip
+
+	  The conditional expressions of the 'if' operators situated
+	  alongside each other are identical.
+
+	  Change-Id: I2cf7c317b106ec14440c7f1b5dcfbf03639f748a
+
+2016-12-08 12:43 +0000 [b596fac838]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* Fix typo in chan_sip
+
+	  The conditional expressions of the 'if' operators
+	  situated alongside each other are identical.
+
+	  Change-Id: I652b6dcddb3be007e669a6aa8107edb31a1ddafb
+
+2016-12-08 12:30 +0000 [483ed9f1aa]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* res_pjsip: Fix 'A = B != C' kind.
+
+	  Consider reviewing the expression of the 'A = B != C' kind.
+	  The expression is calculated as following: 'A = (B != C)'
+
+	  Change-Id: Ibaa637dfda47d51a20e26069d3103e05ce80003d
+
+2016-11-30 09:31 +0000 [41c6319c4e]  Walter Doekes <walter+asterisk@wjd.nu>
+
+	* chan_sip: Do not allow non-SP/HTAB between header key and colon.
+
+	  RFC says SIP headers look like:
+
+	      HCOLON  =  *( SP / HTAB ) ":" SWS
+	      SWS     =  [LWS]                    ; sep whitespace
+	      LWS     =  [*WSP CRLF] 1*WSP        ; linear whitespace
+	      WSP     =  SP / HTAB                ; from rfc2234
+
+	  chan_sip implemented this:
+
+	      HCOLON  =  *( LOWCTL / SP ) ":" SWS
+	      LOWCTL  = %x00-1F                   ; CTL without DEL
+
+	  This discrepancy meant that SIP proxies in front of Asterisk with
+	  chan_sip could pass on unknown headers with \x00-\x1F in them, which
+	  would be treated by Asterisk as a different (known) header.  For
+	  example, the "To\x01:" header would gladly be forwarded by some proxies
+	  as irrelevant, but chan_sip would treat it as the relevant "To:" header.
+
+	  Those relying on a SIP proxy to scrub certain headers could mistakenly
+	  get unexpected and unvalidated data fed to Asterisk.
+
+	  This change fixes so chan_sip only considers SP/HTAB as valid tokens
+	  before the colon, making it agree on the headers with other speakers of
+	  SIP.
+
+	  ASTERISK-26433 #close
+	  AST-2016-009
+
+	  Change-Id: I78086fbc524ac733b8f7f78cb423c91075fd489b
+
+2016-11-14 18:18 +0000 [888142e891]  Joshua Colp <jcolp@digium.com>
+
+	* res_format_attr_opus: Fix crash when fmtp contains spaces.
+
+	  When an opus offer or answer was received that contained an
+	  fmtp line with spaces between the attributes the module would
+	  fail to properly parse it and crash due to recursion.
+
+	  This change makes the module handle the space properly and
+	  also removes the recursion requirement.
+
+	  ASTERISK-26579
+
+	  Change-Id: I01f53e5d9fa9f1925a7365f8d25071b5b3ac2dc3
+
+2016-12-06 14:54 +0000 [ebc67d3053]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_registrar: AMI Add RegistrationInboundContactStatuses command
+
+	  The PJSIPShowRegistrationsInbound AMI command was just dumping out
+	  all AORs which was pretty useless and resource heavy since it had
+	  to get all endpoints, then all aors for each endpoint, then all
+	  contacts for each aor.
+
+	  PJSIPShowRegistrationInboundContactStatuses sends ContactStatusDetail
+	  events which meets the intended purpose of the other command and has
+	  significantly less overhead.  Also, some additional fields that were
+	  added to Contact since the original creation of the ContactStatusDetail
+	  event have been added to the end of the event.
+
+	  For compatibility purposes, PJSIPShowRegistrationsInbound is left
+	  intact.
+
+	  ASTERISK-26644 #close
+
+	  Change-Id: I326f12c9ecb52bf37ba03f0748749de4da01490a
+
+2016-12-06 16:45 +0000 [d506874477]  Richard Mudgett <rmudgett@digium.com>
+
+	* Bundled pjproject:  Fix finding SIP transactions.
+
+	  Occasionally SIP message transactions are not found when they should be.
+	  In the particular case an incoming INVITE transaction is CANCELed but the
+	  INVITE transaction cannot be found so a 481 response is returned for the
+	  CANCEL.  The problematic calls have a '_' character in the Via branch
+	  parameter.
+
+	  The problem is in the pjproject PJ_HASH_USE_OWN_TOLOWER feature's code.
+	  The problem with the "own tolower" code is that it does not calculate the
+	  same hash value as when the pj_tolower() function is used.  The "own
+	  tolower" code will erroneously modify the ASCII characters '@', '[', '\\',
+	  ']', '^', and '_'.  Calls to pj_hash_calc_tolower() can use the
+	  PJ_HASH_USE_OWN_TOLOWER substitute algorithm when enabled.  Calls to
+	  pj_hash_get_lower(), pj_hash_set_lower(), and pj_hash_set_np_lower() call
+	  find_entry() which never uses the PJ_HASH_USE_OWN_TOLOWER algorithm.  As a
+	  result you may not be able to find a hash tabled entry because the
+	  calculated hash values would differ.
+
+	  * Simply disable PJ_HASH_USE_OWN_TOLOWER.
+
+	  ASTERISK-26490 #close
+
+	  Change-Id: If89bfdb5f301b8b685881a9a2a6e0c3c5af32253
+
+2016-12-06 12:06 +0000 [4b233675d8]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Fix missing inclusion of symbols
+
+	  Added back in a -g3, and an -O3 when DONT_OPTIMIZE is not set, to
+	  the CFLAGS.  Not sure how they went missing.
+
+	  Also fixed an uninstall problem where we weren't removing the
+	  symlink from libasteriskpj.so.2 to libasteriskpj.so.  While I was
+	  there, I fixed it for libasteriskssl as well.
+
+	  Change-Id: I9e00873b1e9082d05b5549d974534b48a2142556
+
+2016-12-02 12:04 +0000 [580f83dac7]  Richard Mudgett <rmudgett@digium.com>
+
+	* Remove files that got merged in error somehow to the 13 branch.
+
+	  Change-Id: Id79e2226c31084f9252d5aede9050d3cf13322c8
+
+2016-11-30 18:25 +0000 [61ba2a014a]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_outbound_registration.c: Filter redundant statsd reporting.
+
+	  Increasing the testsuite shutdown timeout before forcibly killing
+	  Asterisk allowed more events to be sent out.  Some tests failed as
+	  a result.  The tests/channels/pjsip/statsd/registrations failed
+	  because we now get the statsd events that a comment in the test
+	  configuration stated couldn't be intercepted.  Unfortunately, we
+	  get a variable number of events because of internal status state
+	  transition races generating redundant statsd events.
+
+	  We were reporting redundant statsd PJSIP.registrations.state changes
+	  for internal state changes that equated to the same thing publicly.
+
+	  * Made update_client_state_status() filter out redundant statsd
+	  updates.
+
+	  ASTERISK-26527
+
+	  Change-Id: If851c7d514bb530d9226e4941ba97dcf52000646
+
+2016-11-22 11:20 +0000 [2ceb609edb]  Guido Falsi <mad@madpilot.net>
+
+	* res_rtp: Fix regression when IPv6 is not available.
+
+	  The latest Release candidate fails to create RTP streams when IPv6
+	  is not available. Due to the changes made in September the ast_sockaddr
+	  structure passed around to create these streams is always of AF_INET6
+	  type, causing failure when used for IPv4. This patch adds a utility
+	  function to check for availability of IPv6 and applies such check
+	  at startup to determine how to create the ast_sockaddr structures.
+
+	  ASTERISK-26617 #close
+
+	  Change-Id: I627a4e91795e821111e1cda523f083a40d0e0c3e
+
+2016-11-28 19:43 +0000 [53459cdaa9]  Eduardo S. Libardi <eslibardi@gmail.com>
+
+	* res_calendar_caldav: Add support reading gmail calendar
+
+	  The response from gmail calendar includes the string name
+	  "caldav:calendar-data". res_calendar_caldav implements
+	  the example included in RFC 4791: string "C:calendar-data".
+	  When reading the calendar, res_calendar_caldav compare the
+	  string and if does not match just discards the event.
+	  This commit compares the response to both strings,
+	  successfully loading gmail calendar events.
+	  Writing to gmail calendar is working prior to this fix.
+
+	  ASTERISK-26624
+	  Reported by: Eduardo S. Libardi
+
+	  Change-Id: Ia1eef10552ae616efb645d390f5ffe81260d7d4a
+
+2016-11-23 18:27 +0000 [44fe4a5769]  Richard Mudgett <rmudgett@digium.com>
+
+	* PJPROJECT logging: Made easier to get available logging levels.
+
+	  Use of the new logging is as simple as issuing the new CLI command or
+	  setting the new pjproject.conf option.
+
+	  Other options that can affect the logging are how you have the pjproject
+	  log levels mapped to Asterisk log types in pjproject.conf and if you have
+	  configured Asterisk to log the DEBUG type messages.  Altering the
+	  pjproject.conf level mapping shouldn't be necessary for most installations
+	  as the default mapping is sensible.  Configuring Asterisk to log the DEBUG
+	  message type is standard practice for collecting debug information.
+
+	  * Added CLI "pjproject set log level" command to dynamically adjust the
+	  maximum pjproject log message level.
+
+	  * Added CLI "pjproject show log level" command to see the currently set
+	  maximum pjproject log message level.
+
+	  * Added pjproject.conf startup section "log_level" option to set the
+	  initial maximum pjproject log message level so all messages could be
+	  captured from initialization.
+
+	  * Set PJ_LOG_MAX_LEVEL to 6 to compile in all defined logging levels into
+	  bundled pjproject.  Pjproject will use the currently set run time log
+	  level to determine if a log message is generated just like Asterisk
+	  verbose and debug logging levels.
+
+	  * In log_forwarder(), made always log enabled and mapped pjproject log
+	  messages.  DEBUG mapped log messages are no longer gated by the current
+	  Asterisk debug logging level.
+
+	  * Removed RAII_VAR() from res_pjproject.c:get_log_level().
+
+	  ASTERISK-26630 #close
+
+	  Change-Id: I6dca12979f482ffb0450aaf58db0fe0f6d2e5389
+
+2016-11-30 10:48 +0000 [17b0b91afa]  Mark Michelson <mmichelson@digium.com>
+
+	* Frame deferral: Re-queue deferred frames one-at-a-time.
+
+	  The recent change that made frame deferral into an API had a behavior
+	  change to it. When frame deferral was completed, we would take all of
+	  the deferred frames and queue them all onto the channel in one call to
+	  ast_queue_frame_head(). Before frame deferral was API-ized, places that
+	  performed manual frame deferral would actually take each deferred frame
+	  and queue them onto the channel.
+
+	  This change in behavior caused the confbridge_recording test to start
+	  failing consistently. Without going too crazily deep into the details,
+	  a channel was getting "stuck" in an ast_safe_sleep(). An AMI redirect
+	  was attempting to break it out of the sleep, but because there were more
+	  frames in the channel read queue than expected, the channel ended up
+	  being unable to break from its sleep loop.
+
+	  By restoring the behavior of individual frame queuing after deferral,
+	  the test starts passing again.
+
+	  Note, this points to a potential underlying issue pointing to an
+	  "unbalance" that can occur when queuing multiple frames at once,
+	  and so a follow-up issue is being created to investigate that
+	  possibility.
+
+	  Change-Id: Ied5dacacda06d343dea751ed5814a03364fe5a7d
+
+2016-06-28 16:26 +0000 [b0c9f07f04]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* OpenSSL 1.1.0 support
+
+	  OpenSSL 1.1.0 includes some major changes in the interface. See
+	  https://wiki.openssl.org/index.php/1.1_API_Changes .
+
+	  Status: Right now there are still a few deprecation notes with OpenSSL
+	  1.1.0. But it's a start.
+
+	  Changes:
+	  * CRYPTO_LOCK is no longer available. Replace it with its value for now.
+	    I don't completely understand what it is used for there.
+	  * Remove several functions from libasteriskssl that seem to no longer be
+	    needed.
+	  * Structures have become opaque and are accesses with accessors.
+	  * ERR_remove_thread_state() no longer needed.
+	  * SSLv2 code now could no longer be used in 1.1.
+
+	  ASTERISK-26109 #close
+
+	  Change-Id: I5e29d477d486ca29b6aae0dc2f5dff960c1cb82b
+
+2016-11-28 15:12 +0000 [a33ed3327a]  Matt Jordan <mjordan@digium.com>
+
+	* res/res_pjsip: Fix documentation whitespace issues
+
+	  Tabs > Spaces.
+
+	  Change-Id: If1e43a71822615a898e958e0f8b2e882606f0bd0
+
+2016-11-22 10:27 +0000 [09c36a6535]  Matt Jordan <mjordan@digium.com>
+
+	* res_pjsip/chan_sip: Advertise 'ws' in the SIP URI transport parameter
+
+	  Per RFC 7118 5.2, the SIP URI 'transport' parameter should advertise
+	  'ws' when WebSockets are to be used as the transport. This applies to
+	  both secure and insecure WebSockets.
+
+	  There were two bugs in Asterisk with respect to this:
+
+	  (1) The most egregious occurs in res_pjsip. There, we advertise 'ws' for
+	      insecure websockets and 'wss' for secure websockets. While this
+	      would seem to make sense - since 'WS' and 'WSS' are used for the Via
+	      Transport parameter - this is not the case for the SIP URI. This
+	      patch corrects that by registering the secure websockets with
+	      pjproject using the shorthand 'WS', and by returning 'ws' when asked
+	      for the transport parameter. Note that in pjproject, it is perfectly
+	      valid to have multiple transports use the same shorthand.
+
+	  (2) In chan_sip, we return an upper-case version of the transport 'WS'
+	      instead of 'ws'. Since we should be strict in what we send and
+	      liberal in what we accept (within reason), this patch lower-cases
+	      the transport before appending it to the parameter.
+
+	  ASTERISK-24330 #close
+	  Reported by: cervajs, Inaki Baz Castillo
+
+	  Change-Id: Iff77b645f8cc3b7cd35168a6676c26b147f22f42
+
+2016-11-28 11:03 +0000 [29e887e9e1]  gtjoseph <gjoseph@digium.com>
+
+	* build_tools:  Fix download_externals to handle certified branches
+
+	  download_externals wasn't handling the "certified/13.x" version
+	  correctly.
+
+	  Change-Id: I124d195bb117ca36fd7bf1150c630f3b474a9d9a
+
+2016-11-02 05:05 +0000 [bfb8c962c4]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* autoconf: more variants for OSARCH linux-gnu
+
+	  There are quite a few odd GNU/Linux platforms. Just call all of them
+	  linux-gnu.
+
+	  Specifically this fixes building the Debian platforms mips64el and x32.
+	  And maybe also others.
+
+	  ASTERISK-26546 #close
+
+	  Change-Id: I06ec4bd7f0ee1c84b6b24d81538223b07c4174b1
+
+2016-11-17 08:25 +0000 [a1fa909033]  Timo Teräs <timo.teras@iki.fi>
+
+	* codec_dahdi: Fix poll.h include.
+
+	  POSIX defines poll.h. sys/poll.h should not be used as it is c-library
+	  internal header which may or may not exist. Notably in musl including
+	  sys/poll.h generates warning of being incorrect.
+
+	  Change-Id: Ib318c1c7142a737bcf3caa4d8d72560bebe39252
+
+2016-11-26 10:57 +0000 [0cc8351484]  Michael Kuron <m.kuron@gmx.de>
+
+	* chan_sip: Fix segfault during module unload
+
+	  If a TCP/TLS connection was pending (not accepted and not timed out) during
+	  unload of chan_sip, Asterisk would segfault when trying to send a signal to
+	  a thread whose thread ID hadn't been recorded yet. This commit fixes that by
+	  recording the thread ID before calling the blocking connect() syscall.
+	  This was a regression introduced by 776a14386a55b5425c7e9617eff8af8b45427144.
+
+	  The above wasn't enough to fix the segfault, which was now delayed to the
+	  point where connect() timed out. Therefore, it was necessary to also remove
+	  the SA_RESTART flag from the SIGURG sigaction so that pthread_kill() could be
+	  used to interruput the connect() syscall.
+	  This was a regression introduced by 5d313f51b982a18f7321adcf7c7a4e822d8b2714.
+
+	  ASTERISK-26586 #close
+
+	  Change-Id: I76fd9d47d56e4264e2629bce8ec15fecba673e7b
+
+2016-11-11 08:16 +0000 [8756ce64b7]  gestoip2 <gestoip2@ull.edu.es>
+
+	* res_rtp_asterisk: RTT miscalculation in RTCP
+
+	  When retrieving RTCP stats for PJSIP channels, RTT values are unreliable.
+	  RTT calculation is correct, but the data representation isn't.  RTT is
+	  represented by a 32-bit fixed-point number with the integer part in the
+	  first 16 bits and the fractional part in the last 16 bits.  In order to
+	  get the RTT value, the fractional part is miscalculated, there is an
+	  unnecessary 16 bit shift that causes overflow.  Besides this there is
+	  another mistake, when transforming the integer value to the fixed point
+	  fractional part via bitwise operation, that loses precision.
+
+	  * RTT fractional part is no longer shifted, avoiding overflow.
+
+	  * RTT fractional part is transformed to its fixed-point value more
+	  precisely.
+
+	  * Fixed timeval2ntp() and ntp2timeval() second fraction conversions.
+
+	  * Fixed NTP timestamp report logging.  The usec was inexplicably
+	  multiplied by 4096.
+
+	  ASTERISK-26566 #close
+	  Reported by Hector Royo Concepcion
+
+	  Change-Id: Ie09bdabfee75afb3f1b8ddfd963e5219ada3b96f
+
+2016-11-15 13:44 +0000 [8e77d6f520]  Michael Kuron <m.kuron@gmx.de>
+
+	* tcptls: Use new certificate upon sip reload
+
+	  Previously, a TLS server socket would only be restarted upon sip reload if the
+	  bind address had changed. This commit adds checking for changes to TLS
+	  parameters like certificate, ciphers, etc. so they get picked up without
+	  requiring a reload of the entire chan_sip module. This does not affect open
+	  connections in any way, but new connections will use the new TLS parameters.
+	  The changes also apply to HTTP and Manager.
+
+	  ASTERISK-26604 #close
+
+	  Change-Id: I169e86cefc6dcd627c915134015a6a1ab1aadbe6
+2016-11-11 00:29 +0000 [86d824b7ff]  Timo Teräs <timo.teras@iki.fi>
+
+	* addons/chan_mobile: do not use strerror_r
+
+	  The two reasons why it might be used are that some systems do not
+	  implement strerror in thread safe manner, and that strerror_r returns
+	  the error code in the string in case there's no error message.
+
+	  However, all of asterisk elsewhere uses strerror() and assumes it
+	  to be thread safe. And in chan_mobile the errno is also explicitly
+	  printed so neither of the above reasons are valid.
+
+	  The reasoning to remove usage is that there are actually two versions
+	  of strerror_r: XSI and GNU. They are incompatible in their return
+	  value, and there's no easy way to figure out which one is being
+	  used. glibc gives you the GNU version if _GNU_SOURCE is defined,
+	  but the same feature test macro is needed for other symbols. On
+	  all other systems you assumedly get XSI symbol, and compilation warnings
+	  as well as non-working error printing.
+
+	  Thus the easiest solution is to just remove strerror_r and use
+	  strerror as rest of the code. Alternative is to introduce ast_strerror
+	  in separate translation unit so it can request the XSI symbol in
+	  glibc case, and replace all usage of strerror.
+
+	  Change-Id: I84d35225b5642d85d48bc35fdf399afbae28a91d
+
+2016-11-21 09:40 +0000 [425da14927]  gtjoseph <gjoseph@digium.com>
+
+	* build:  Backport addition of librt check to configure.ac
+
+	  A while back, a master-only change was made to check for librt which
+	  should probably have been cherry-picked to 13 at that time.  Sometime
+	  between then and now, part of that change did make it into 13 but it
+	  was incomplete and non-functional.  This patch backports the rest
+	  of the librt check and allows the link of libasteriskpj to use the
+	  results.
+
+	  Change-Id: I1424008fd8c90f389dda53162ec4a340b253a3c1
+
+2016-11-16 12:05 +0000 [2a40c3a867]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Improve reliability of pjproject download
+
+	  The download process now has a timeout which will cause wget to retry
+	  if it stops retrieving data for 5 seconds and fetch and curl to timeout
+	  if the whole retrieval take smore than 30 seconds.
+
+	  If the tarball retrieval works, the MD5SUM file is retrieved from
+	  the downloads site and the md5 checksum is verified.
+
+	  If either the tarball retrieval or MD5SUM retrieval fails, or the
+	  checksums don't match, the entire process is retried once.  If it
+	  fails again, any incomplete tarball is deleted.
+
+	  .DELETE_ON_ERROR: was also added to the Makefile.  Not only does
+	  this delete the tarball on failure, it till also delete corrupted
+	  library files from the pjproject source directory should they
+	  fail to build correctly.
+
+	  Tested all the way back to FreeBSD 9, CentOS 6, Debian 6 and
+	  Ubuntu 14.
+
+	  Change-Id: Iea7d33b96a31622ab1b6e54baebaf271959514e1
+
+2016-11-11 07:13 +0000 [12c4e664bc]  Mikheili Dautashvili <mishadaut@gmail.com>
+
+	* main/app.c: Transmit Silence on ControlPlayback pause
+
+	  ASTERISK-26562 #close
+
+	  Change-Id: Ie6cb0ffc2b8c775639ce7784fe96f4ea00cfa2f8
+
+2016-11-15 15:01 +0000 [cf6d13180e]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* chan_pjsip: fix switching sending codec when asymmetric_rtp_codec=no
+
+	  The sending codec is switched to the receiving codec and then
+	  is switched back to the best native codec on EVERY receiving RTP packets.
+	  This is because after call of ast_channel_set_rawwriteformat there is call
+	  of ast_set_write_format which calls set_format which sets rawwriteformat
+	  to the best native format.
+
+	  This patch adds a new function ast_set_write_format_path which set
+	  specific write path on channel and uses this function to switch
+	  the sending codec.
+
+	  ASTERISK-26603 #close
+
+	  Change-Id: I5b7d098f8b254ce8f45546e6c36e5d324737f71d
+
+2016-11-10 13:34 +0000 [ee73af1d88]  gtjoseph <gjoseph@digium.com>
+
+	* Update for 13.12.2
+
+2016-11-04 10:57 +0000 [a3614d75f6]  Kevin Harwell <kharwell@digium.com>
+
+	* Revert "chan_sip: Fix lastrtprx always updated"
+
+	  This reverts commit 93332cb1d0eea18021ea6538237297e627d6e2fc.
+
+	  Unfortunately, the aforementioned commit caused a regression (incoming calls
+	  would eventually disconnect). Thus it is being removed.
+
+	  ASTERISK-26523 #close
+	  ASTERISK-25270
+
+	  Change-Id: Ibf5586adc303073a8eac667a4cbfdb6be184a64d
+
+2016-10-27 13:48 +0000 [7d7b52c434]  Mark Michelson <mmichelson@digium.com>
+
+	* Update for 13.12.1
+
+2016-10-26 07:51 +0000 [9c761b8f45]  Joshua Colp <jcolp@digium.com>
+
+	* app_voicemail: Clear voice mailbox in MailboxExists and MAILBOX_EXISTS.
+
+	  When executing the MailboxExists dialplan application and
+	  MAILBOX_EXISTS dialplan function the passed in temporary voice
+	  mailbox was not cleared, causing it to try to free garbage.
+
+	  ASTERISK-26503 #close
+
+	  Change-Id: Ie21ccfa1b80b9c59318e596f6b8e17da2b5a7cb3
+
+2016-10-25 14:13 +0000 [226a7e36c5]  Mark Michelson <mmichelson@digium.com>
+
+	* Update for 13.12.0
+
+2016-10-17 14:08 +0000 [df75b647da]  Mark Michelson <mmichelson@digium.com>
+
+	* Update for 13.12.0-rc1
+
+2016-11-18 18:59 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.13.0-rc1 Released.
+
+2016-11-18 09:45 +0000 [cb624b10ae]  Mark Michelson <mmichelson@digium.com>
+
+	* Bump ARI version to 1.10.0
+
+	  The video-related bridge changes mean that the version needs to be
+	  bumped.
+
+	  Change-Id: I41c4495068562bef03aa76728f188b8ac4bd393d
+
+2016-11-17 10:50 +0000 [bde3d022a3]  Mark Michelson <mmichelson@digium.com>
+
+	* manager: update minor version
+
+	  Based on bridge video AMI event changes, bump the minor version of AMI.
+
+	  Change-Id: I02586bd6cafc0baa33ea98c2f75356c0f5e03435
+
+2016-11-16 20:24 +0000 [b213045fe4]  gtjoseph <gjoseph@digium.com>
+
+	* build:  Various OpenBSD issues
+
+	  OpenBSD's 'find' doesn't take the -delete argument so you have to pipe
+	  through 'xargs rm -rf'.
+
+	  'echo -e' doesn't like \t starting a line. It just prints 't' which
+	  causes the libasteriskpj.exports file to be garbage.  They were just
+	  cosmetic so they were removed.
+
+	  librt doesn't exist so the link of libasteriskpj.so fails. It's not
+	  actually needed for linux anyway so -lrt was removed from the link.
+
+	  res_rtp_asterisk was failing to load because of an undefined
+	  DTLS_method. '|| defined(LIBRESSL_VERSION_NUMBER)' was added to the #if
+	  so DTLSv1_method is used instead.
+
+	  ASTERISK-26608
+
+	  Change-Id: I926ec95b0b69633231e3ad1d6e803b977272c49c
+
+2016-11-14 18:45 +0000 [404596b790]  gtjoseph <gjoseph@digium.com>
+
+	* channel:  Fix issues in hangup scenarios caused by frame deferral
+
+	  ASTERISK-26343
+
+	  Change-Id: I06dbf7366e26028251964143454a77d017bb61c8
+
+2016-11-16 15:42 +0000 [2c031b67d3]  Mark Michelson <mmichelson@digium.com>
+
+	* res_format_attr_opus: Fix fmtp generation.
+
+	  res_format_attr_opus assumed that the string being passed into it was
+	  empty. It tried to determine if the only thing it had written was
+
+	  a=fmtp:<num>
+
+	  And if it had, it would reset the string. Its calculation was off when
+	  working with chan_sip, though. chan_sip passes the entire built SDP
+	  rather than an empty string. This resulted in always putting an empty
+	  fmtp line in the SDP.
+
+	  ASTERISK-26520 #close
+	  Reported by scgm11
+
+	  Change-Id: Ib2e8712d26a47067e5f36d5973577added01dbb5
+
+2016-11-15 16:23 +0000 [ed0f1afc8c]  Richard Mudgett <rmudgett@digium.com>
+
+	* codec_opus: Fix warning when Opus negotiated but codec_opus not loaded.
+
+	  When Opus is negotiated but not loaded, the log is spammed with messages
+	  because the system does not know how to calculate the number of samples in
+	  a frame.
+
+	  * Suppress the warning by supplying a function that assumes 20ms of
+	  samples in the frame.  For pass through support it doesn't really seem to
+	  matter what number of samples is returned anyway.
+
+	  ASTERISK-26605 #close
+
+	  Change-Id: Icf2273692f040dc2c45b01e72a790d11092f9e0f
+
+2016-11-14 14:36 +0000 [e632222bc4]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_outbound_authenticator_digest.c: Fix memory pool leak.
+
+	  Responding to authentication challenges leaks PJSIP memory pools.
+
+	  The leak was introduced with a pjproject 2.5.5 API change.
+	  https://trac.pjsip.org/repos/ticket/1929 changed the API usage of
+	  pjsip_auth_clt_init() to require the new API pjsip_auth_clt_deinit() to
+	  clean up cached authentication allocations that get allocated with
+	  pjsip_auth_clt_reinit_req().
+
+	  ASTERISK-26516 #close
+
+	  Change-Id: I4473141b8c3961d0dc91c382beb3876b3efb45c8
+
+2016-11-15 12:01 +0000 [c92dcc76da]  gtjoseph <gjoseph@digium.com>
+
+	* file.c/__ast_file_read_dirs:  Fix issues on filesystems without d_type
+
+	  One of the code paths in __ast_file_read_dirs will only get executed if
+	  the OS doesn't support dirent->d_type OR if the filesystem the
+	  particular file is on doesn't support it.  So, while standard Linux
+	  systems support the field, some filesystems like XFS do not.  In this
+	  case, we need to call stat() to determine whether the directory entry
+	  is a file or directory so we append the filename to the supplied
+	  directory path and call stat.  We forgot to truncate path back to just
+	  the directory afterwards though so we were passing a complete file name
+	  to the callback in the dir_name parameter instead of just the directory
+	  name.
+
+	  The logic has been re-written to only create a full_path if we need to
+	  call stat() or if we need to descend into another directory.
+
+	  Change-Id: I54e4228bd8355fad65200c6df3ec4c9c8a98dfba
+
+2015-05-14 17:12 +0000 [7b96e8cc3d]  Maciej Szmigiero <mail@maciej.szmigiero.name>
+
+	* Add X.509 subject alternative name support to TLS certificate
+	  verification.
+
+	  This way one X.509 certificate can be used for hosts that
+	  can be reached under multiple DNS names or for multiple hosts.
+
+	  Signed-off-by: Maciej Szmigiero <mail@maciej.szmigiero.name>
+
+	  ASTERISK-25063 #close
+
+	  Change-Id: I13302c80490a0b44c43f1b45376c9bd7b15a538f
+
+2016-11-14 15:57 +0000 [0790aa528a]  Matt Jordan <mjordan@digium.com>
+
+	* pjproject: Use a much higher limit for PJ_ICE_MAX_CHECKS
+
+	  The PJ_ICE_MAX_CHECKS constant is used by pjproject to determine how
+	  many pairs of local/remote candidates will be made. If for some reason
+	  we reach this upper bound, ICE will generally fail and no media will
+	  flow between the browser and Asterisk.
+
+	  This patch makes PJ_ICE_MAX_CHECKS set to the total possible number of
+	  pairs of candidates we'd theoretically allow, which is
+	  PJ_ICE_MAX_CAND^2. Prior to this patch, we simply multiplied
+	  PJ_ICE_MAX_CAND by two; on systems with multiple interfaces (I blame
+	  Docker), this is far too low to allow WebRTC calls to succeed.
+
+	  Setting this to be PJ_ICE_MAX_CAND^2 allowed WebRTC calls to succeed
+	  even when the system Asterisk was running on had quite a few virtual
+	  interfaces.
+
+	  Change-Id: Icd4f17de0ac9d3a83dddfc8bf1cb7616bc107d55
+
+2016-11-14 15:32 +0000 [993a6f96c7]  Matt Jordan <mjordan@digium.com>
+
+	* apps/app_echo: Only relay a single video source change frame
+
+	  In 9785e8d0, app_echo was updated to relay video source updates to the
+	  channel for the purposes of displaying video in WebRTC tests.
+	  Unfortunately, this can cause a Kafkaesque nightmare if two or more
+	  Local channels are in a bridge together where their ends are in
+	  app_echo. When this situation occurs, a video update sent into app_echo
+	  will cause the video update to be relayed to the other Local channels,
+	  causing another round of video updates, etc. In not much time at all,
+	  the channel length queues will be overwhelmed, channel alert pipes will
+	  fail, and all hell will break loose as Asterisk merrily continues to
+	  throw more video update requests onto the channels.
+
+	  This patch updates app_echo to *only* relay a single video update. Once
+	  a video update has been made, all further video updates are dropped.
+	  This meets the intended purpose of the original patch: if we get a video
+	  update and we're in app_echo, go ahead and ask the sender to update
+	  themselves. However, once we've got that video stream sync'd up, don't
+	  keep spamming the world.
+
+	  Change-Id: I9210780b08d4c17ddb38599d1c64453adfc34f74
+
+2016-11-08 10:11 +0000 [d23b4af477]  Matt Jordan <mjordan@digium.com>
+
+	* res/ari/resource_bridges: Add the ability to manipulate the video source
+
+	  In multi-party bridges, Asterisk currently supports two video modes:
+	   * Follow the talker, in which the speaker with the most energy is shown
+	     to all participants but the speaker, and the speaker sees the
+	     previous video source
+	   * Explicitly set video sources, in which all participants see a locked
+	     video source
+
+	  Prior to this patch, ARI had no ability to manipulate the video source.
+	  This isn't important for two-party bridges, in which Asterisk merely
+	  relays the video between the participants. However, in a multi-party
+	  bridge, it can be advantageous to allow an external application to
+	  manipulate the video source.
+
+	  This patch provides two new routes to accomplish this:
+	  (1) setVideoSource: POST /bridges/{bridgeId}/videoSource/{channelId}
+	      Sets a video source to an explicit channel
+	  (2) clearVideoSource: DELETE /bridges/{bridgeId}/videoSource
+	      Removes any explicit video source, and sets the video mode to talk
+	      detection
+
+	  ASTERISK-26595 #close
+
+	  Change-Id: I98e455d5bffc08ea5e8d6b84ccaf063c714e6621
+
+2016-11-14 14:22 +0000 [404a62eeee]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "Revert "channel: Use frame deferral API for safe sleep.""
+
+	  This reverts commit 58c88cfbaa80cb43419cde9186d643d1c5d24baf.
+
+	  Change-Id: I72692e2b2e83ef6da9390075ff20b138b2c374b6
+
+2016-11-14 14:22 +0000 [09d8febc91]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "Revert "autoservice: Use frame deferral API""
+
+	  This reverts commit 1df434e2b4bd7cc34b9b4addf405a3caa7ac16b8.
+
+	  Change-Id: Id2b8a8bccbb4bbdd82b792275d4cd6f32563e401
+
+2016-11-14 14:21 +0000 [ffad2b44df]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "Revert "AGI: Only defer frames when in an interception routine.""
+
+	  This reverts commit 6be5d8de0da7e804544507f70382425af9a07b3f.
+
+	  Change-Id: I4b548137f52ae0686d8f09e21496b778d1c6a797
+
+2016-11-14 14:21 +0000 [2fefb6187f]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "Revert "Add API for channel frame deferral.""
+
+	  This reverts commit 6b5a7ced136b7178ae0b2ba39221eba1cd2e37c9.
+
+	  Change-Id: I61d1dbb2e69e1977f684b7dfc8e98211024e1cd1
+
+2016-11-14 12:16 +0000 [5e0c224043]  gtjoseph <gjoseph@digium.com>
+
+	* cli:  Fix ast_el_read_char to work with libedit >= 3.1
+
+	  Libedit 3.1 is not build with unicode on as a default and so the
+	  prototype for the el_gets callback changed from expecting a char buffer
+	  to accepting a wchar buffer.  If ast_el_read_char isn't changed,
+	  the cli reads garbage from teh terminal.
+
+	  Added a configure test for (*el_rfunc_t)(EditLine *, wchar_t *) and
+	  updated ast_el_read_char to use the HAVE_ define to detemrine whether
+	  to use char or wchar.
+
+	  ASTERISK-26592 #close
+
+	  Change-Id: I9099b46f68e06d0202ff80e53022a2b68b08871a
+
+2016-11-11 02:41 +0000 [3faca1d4ff]  Igor Goncharovskiy <igor.goncharovsky@gmail.com>
+
+	* Fix closing rtp ports after call finished in chan_unistim.
+
+	  Fix ASTERISK-26565 by adding ast_rtp_instance_stop before
+	  rtp instance destroy for chan_unistim. Also several fixes
+	  for displayed text translation.
+
+	  Change-Id: If42a03eea09bd1633471406bdc829cf98bf6affc
+
+2016-09-23 17:54 +0000 [412d43fa21]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip.c: Rework endpt_send_request() req_wrapper code.
+
+	  * Don't hold the req_wrapper lock too long in endpt_send_request().  We
+	  could block the PJSIP monitor thread if the timeout timer expires.
+	  sip_get_tpselector_from_endpoint() does a sorcery access that could take
+	  awhile accessing a database.  pjsip_endpt_send_request() might take awhile
+	  if selecting a transport.
+
+	  * Shorten the time that the req_wrapper lock is held in the callback
+	  functions.
+
+	  * Simplify endpt_send_request() req_wrapper->timeout code.
+
+	  * Removed some redundant req_wrapper->timeout_timer->id assignments.
+
+	  Change-Id: I3195e3a8e0207bb8e7f49060ad2742cf21a6e4c9
+
+2016-09-21 15:10 +0000 [2e7fc56d3c]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Fix tdata leaks in off nominal paths.
+
+	  Change-Id: Ie83e06e88c2d60157775263b07e40b61718ac97b
+
+2016-10-24 12:41 +0000 [da68b185b3]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_registrar_expire.c: Remove extra linefeed in debug message.
+
+	  Change-Id: I1f9adb911f23376503396ec8867e8005b755eb94
+
+2016-11-10 10:57 +0000 [b70eb07c53]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_sdp_rtp: Reject offer of required SRTP without res_srtp.
+
+	  When optimistic SRTP was on it was possible for us to still
+	  set up a call without an audio stream if an offer was received
+	  with required SRTP.
+
+	  This change makes it so this scenario will now fail with a 488
+	  response.
+
+	  ASTERISK-26575
+
+	  Change-Id: I7d14187037681f48879bd20319ac79d0877318f3
+
+2016-11-10 08:33 +0000 [71dc333565]  Joshua Colp <jcolp@digium.com>
+
+	* app_queue: Add mention of 'ABANDON' variable to CHANGES.
+
+	  ASTERISK-26558
+
+	  Change-Id: I1127010181e79c8ac291f72f036cb8e430dc7f7e
+
+2016-11-10 07:41 +0000 [6b5a7ced13]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "Add API for channel frame deferral."
+
+	  This reverts commit 9231a56cf3d6f5eca1bf2d37d827453400690773.
+	  Multiple testsuite failures were detected after the fact.
+
+	  Change-Id: I3bac8d7c3ddb69a4ddf6c5d6de0ffa5ff7ff3af7
+
+2016-11-10 07:41 +0000 [6be5d8de0d]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "AGI: Only defer frames when in an interception routine."
+
+	  This reverts commit 5c10091f3d1430c6fc04015226f8c3e3aa9d8282.
+	  Multiple testsuite failures were detected after the fact.
+
+	  Change-Id: I397a841acc17ae230c512449cd6bed89d2ef3b73
+
+2016-11-10 07:41 +0000 [1df434e2b4]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "autoservice: Use frame deferral API"
+
+	  This reverts commit 2e3a3545754749de21873bfdc6d1a40ec7d8893f.
+	  Multiple testsuite failures were detected after the fact.
+
+	  Change-Id: Ia45fa4633fae74dca345b24bb6722737c63035de
+
+2016-11-10 07:40 +0000 [58c88cfbaa]  gtjoseph <gjoseph@digium.com>
+
+	* Revert "channel: Use frame deferral API for safe sleep."
+
+	  This reverts commit 44f7e252397fd87420b3374df26941d7436401b3.
+	  Multiple testsuite failures were detected after the fact.
+
+	  Change-Id: I56299087da22128a95f0c8f3955f740890d7ca65
+
+2016-11-09 18:18 +0000 [a562fbe618]  gtjoseph <gjoseph@digium.com>
+
+	* build:  Fix default values for some SANITIZER options
+
+	  2 of the sanitizers didn't have default values so in systems that
+	  don't support sanitizers menuselect would spit out warnings.  They
+	  were harmless but confusing.  They've now been set to "0".
+
+	  Change-Id: I08dc495e3b83f1feac3160b421f538c375fc5d58
+
+2016-11-06 06:04 +0000 [7fd5031c1c]  Sebastian Gutierrez <sgutierrez@integraccs.com>
+
+	* app_queue: new variable set when abandoned
+
+	  sets the variable ABANDONED to TRUE if the call was not answered.
+
+	  ASTERISK-26558
+
+	  Change-Id: I4729af9bff4eba436d8a776afd3374065d0036d3
+
+2016-11-08 10:48 +0000 [e043d1a55c]  Mark Michelson <mmichelson@digium.com>
+
+	* res_pjsip_session: Do not call session supplements when it's too late.
+
+	  res_pjsip_sesssion was hooking into transaction and invite state
+	  changes. One of the reasons for doing so was due to the
+	  PJSIP_EVENT_TX_MSG event. The idea was that we were hooking into the
+	  message sending process, and so we should call session supplements to
+	  alter the outgoing message.
+
+	  In reality, this event was meant to indicate that the message either
+	  a) had already been sent, or
+	  b) required a DNS lookup and would be sent when the DNS query
+	  completed.
+
+	  In case (a), this meant we were altering an already-sent
+	  request/response for no reason. In case (b), this potentially meant we
+	  could be trying to alter a request/response at the same time that the
+	  DNS resolution completed. In this case, it meant we might be stomping on
+	  memory being used by the thread actually sending the message. This
+	  caused potential crashes and memory corruption.
+
+	  This patch removes the calls to session supplements from the case where
+	  the PJSIP_EVENT_TX_MSG event occurs. In all of these cases, trying to
+	  alter the message at this point is too late, and it can cause nothing
+	  but harm to try to do it. Because there were no longer any calls to the
+	  handle_outgoing() function, it has been removed.
+
+	  Change-Id: Ibcc223fb1c3a237927f38754e0429e80ee301e92
+
+2016-11-03 16:46 +0000 [44f7e25239]  Mark Michelson <mmichelson@digium.com>
+
+	* channel: Use frame deferral API for safe sleep.
+
+	  This is another case where manual frame deferral can be replaced with
+	  centralized routines instead.
+
+	  Change-Id: I42cdf205f8f29a7977e599751a57efbaac07c30e
+
+2016-11-03 16:46 +0000 [2e3a354575]  Mark Michelson <mmichelson@digium.com>
+
+	* autoservice: Use frame deferral API
+
+	  Rather than use manual frame deferral, just let the channel API do it
+	  for us.
+
+	  ASTERISK-26343
+
+	  Change-Id: I688386f36e765dbc07be863943a43f26bd5eac49
+
+2016-11-03 16:42 +0000 [5c10091f3d]  Mark Michelson <mmichelson@digium.com>
+
+	* AGI: Only defer frames when in an interception routine.
+
+	  AGI recently was modified to defer important frames. This was because
+	  when AGI was used in a connected line interception routine, the
+	  resulting connected line frame would end up getting discarded by the
+	  AGI.
+
+	  However, this caused bad behavior in other cases. Specifically, during a
+	  transfer, if someone attempted to manually set the Caller ID on a
+	  channel in an AGI, the deferred connected line frame would end up
+	  overwriting what had been manually set in the AGI.
+
+	  Since the initial issue was specific to interception routines, this
+	  change removes the manual frame deferral from AGI and instead uses the
+	  new frame deferral API in interception routines.
+
+	  ASTERISK-26343 #close
+	  Reported by Morton Tryfoss
+
+	  Change-Id: Iab7d39436d0ee99bfe32ad55ef91e9bd88db4208
+
+2016-11-03 16:36 +0000 [9231a56cf3]  Mark Michelson <mmichelson@digium.com>
+
+	* Add API for channel frame deferral.
+
+	  There are several places in Asterisk that have duplicated logic
+	  for deferring important frames until later.
+
+	  This commit adds a couple of API calls to facilitate this automatically.
+
+	  ast_channel_start_defer_frames(): Future reads of deferrable frames on
+	  this channel will be deferred until later.
+
+	  ast_channel_stop_defer_frames(): Any frames that have been deferred get
+	  requeued onto the channel.
+
+	  ASTERISK-26343
+
+	  Change-Id: I3e1b87bc6796f222442fa6f7d1b6a4706fb33641
+
+2016-11-03 07:42 +0000 [a9ac1f5de4]  Alexander Anikin <may213@yandex.ru>
+
+	* chan_ooh323: Fixes to work right with Cisco devices
+
+	  Changed output packets queue processing algo to one read-one write
+	  instead of all read-all send
+
+	  Remove h.245 tunneling parameter from ReleaseComplete packet
+
+	  ASTERISK-24400 #close
+	  Reported by: Dmitry Melekhov
+	  Tested by: Dmitry Melekhov
+
+	  Change-Id: I0b31933b062a21011dbac9a82b8bcfe345f406f6
+
+2016-11-03 13:10 +0000 [0ee249075a]  Alexander Anikin <may213@yandex.ru>
+
+	* chan_ooh323: reset rrq count on gk registration
+
+	  reset registration attempts count on success registration on gatekeeper
+
+	  Change-Id: I5f47351852e0ca76c9ac78421659600e0f106336
+
+2016-11-06 03:46 +0000 [59c23e1768]  Michael Kuron <m.kuron@gmx.de>
+
+	* automon: restore mixing of the both channels after recording stops
+
+	  This is a regression over Asterisk 11, introduced by
+	  2dc8a060064f359a17f5ebcd515d85fe5203c019. Previously, recordings started via
+	  the automon DTMF code would automatically be mixed together using sox because
+	  app_monitor would be called with the m option. This commit restores this
+	  behavior.
+
+	  Change-Id: Ibaf58684285c3f1b6ca3714524e6d638ae3b3759
+
+2016-11-04 15:42 +0000 [e79acaeb75]  Matt Jordan <mjordan@digium.com>
+
+	* res_http_websocket: Increase the buffer size for non-LOW_MEMORY systems
+
+	  Not surprisingly, using Respoke (and possibly other systems) it is
+	  possible to blow past the 16k limit for a WebSocket packet size. This
+	  patch bumps it up to 32k, which, at least for Respoke, is sufficient.
+	  For now.
+
+	  Because 32k is laughable on a LOW_MEMORY system (as is 16k, for that
+	  matter), this patch adds a LOW_MEMORY directive that sets the buffer to
+	  8k for systems who have asked for their reduced memory availability to
+	  be considered.
+
+	  Change-Id: Id235902537091b58608196844dc4b045e383cd2e
+
+2016-11-04 15:40 +0000 [7a83196985]  Matt Jordan <mjordan@digium.com>
+
+	* res_stasis: Set a video source mode on Stasis created bridges
+
+	  When a bridge is created via ARI (through res_stasis), no video source
+	  mode is set by default. As a result, any endpoint sending video media
+	  won't ever see any video reflected back to it.
+
+	  This patch defaults a bridge to a 'follow the talker' video mode.
+	  Further work can be done to add routes that allow for the video mode to
+	  be controlled through the /bridges resource.
+
+	  Change-Id: I7e9d530a5d7a97a4524a9ee4e468e1a6b3443866
+
+2016-11-04 15:37 +0000 [e7dc536b7a]  Matt Jordan <mjordan@digium.com>
+
+	* main/bridge_channel: Fix channel reference leak on video source
+
+	  When a channel is made the video source, the bridge holds a reference to
+	  it. Whenever the video source changes, that reference is released.
+	  However, a ref leak does occur if the channel leaves the bridge (such as
+	  being hung up) while it is the video source, as the bridge never
+	  releases the ref in such a case.
+
+	  This patch adds a line to the bridge_channel_internal_join routine such
+	  that, when a channel finishes its time in the bridge, it notifies the
+	  bridge via ast_bridge_remove_video_src that if it is a video source its
+	  reference should be released.
+
+	  ASTERISK-26555 #close
+
+	  Change-Id: I3a2f5238a9d2fc49c591f0e65199d782ab0be76a
+
+2016-11-04 15:36 +0000 [7c824b955d]  Matt Jordan <mjordan@digium.com>
+
+	* main/bridge: Add some verbose logging for video source changes
+
+	  It's actually quite useful to see the source of a video stream change.
+	  This doesn't happen terribly often, even with talk detection - but when
+	  it does, it's nice to know which channel is now providing your video
+	  stream.
+
+	  As a verbose 5 level message, it shouldn't be terribly spammy or costly
+	  to have, and is 'lower level' then most other verbose messages that the
+	  bridge system emits.
+
+	  ASTERISK-26555
+
+	  Change-Id: Ia1c20ecafa9670171fd38bddcf3beccae47fb15c
+
+2016-11-04 15:33 +0000 [fd6af2dee8]  Matt Jordan <mjordan@digium.com>
+
+	* bridges/bridge_softmix: Remove SSRC changes on join/leave; update video source
+
+	  WebRTC clients really, really want to know the SSRC of the media they're
+	  getting. Changing the SSRC is generally not a good thing.
+
+	  bridge_softmix, starting in Asterisk 12, started changing the SSRC of
+	  parties as they joined or left the bridge. With most phones, this isn't
+	  a problem: phones just play back the stream they're getting. With WebRTC
+	  clients, however, the SSRC is tied to a media stream that may be
+	  negotiated. When a new SSRC just shows up, the media can be dropped.
+
+	  As it turns out, the SSRC change shouldn't even be necessary. From the
+	  perspective of the client, it's still talking to Asterisk with the same
+	  media stream: why indicate that the far party has suddenly changed to a
+	  different source of media?
+
+	  This patch opts to just remove the SSRC changes. With this patch, video
+	  clients that join/leave a softmix bridge actually get the video stream
+	  instead of freaking out.
+
+	  ASTERISK-26555
+
+	  Change-Id: I27fec098b32e7c8718b4b65f3fd5fa73527968bf
+
+2016-10-28 15:11 +0000 [bd4d7d8ad0]  Kevin Harwell <kharwell@digium.com>
+
+	* stasis_recording/stored: remove calls to deprecated readdir_r function.
+
+	  The readdir_r function has been deprecated and should no longer be used. This
+	  patch removes the readdir_r dependency (replaced it with readdir) and also moves
+	  the directory search code to a more centralized spot (file.c)
+
+	  Also removed a strict dependency on the dirent structure's d_type field as it
+	  is not portable. The code now checks to see if the value is available. If so,
+	  it tries to use it, but defaults back to using the stats function if necessary.
+
+	  Lastly, for most implementations of readdir it *should* be thread-safe to make
+	  concurrent calls to it as long as different directory streams are specified.
+	  glibc falls into this category. However, since it is possible that there exist
+	  some implementations that are not safe, locking has been added for those other
+	  than glibc.
+
+	  ASTERISK-26412
+	  ASTERISK-26509 #close
+
+	  Change-Id: Id8f54689b1e2873e82a09d0d0d2faf41964e80ba
+
+2016-11-04 10:57 +0000 [cb30963d22]  Kevin Harwell <kharwell@digium.com>
+
+	* Revert "chan_sip: Fix lastrtprx always updated"
+
+	  This reverts commit 93332cb1d0eea18021ea6538237297e627d6e2fc.
+
+	  Unfortunately, the aforementioned commit caused a regression (incoming calls
+	  would eventually disconnect). Thus it is being removed.
+
+	  ASTERISK-26523 #close
+	  ASTERISK-25270
+
+	  Change-Id: Ibf5586adc303073a8eac667a4cbfdb6be184a64d
+
+2016-11-02 10:52 +0000 [3a1f9c5dab]  Joshua Colp <jcolp@digium.com>
+
+	* res_stasis: Don't unsubscribe from a NULL bridge.
+
+	  A NULL bridge has special meaning in res_stasis for
+	  unsubscribing. It means that a subscription to ALL
+	  bridges should be removed. This should not be done
+	  as part of the normal subscription management in
+	  the res_stasis channel loop.
+
+	  ASTERISK-26468
+
+	  Change-Id: I6d5bea8246dd13a22ef86b736aefbf2a39c15af0
+
+2016-11-03 13:45 +0000 [eceab15f33]  Alexander Anikin <may213@yandex.ru>
+
+	* chan_ooh323: Fix infinite loop on read second part of H.225 packet
+
+	  Fix logic on read second part of H.225 packet. There was infinite loop on
+	  wrong connections due to read before poll.
+
+	  Change-Id: I42b4bf75c46e4a5c5df5c5ca1f0bd74b8944e7ff
+
+2016-11-03 11:55 +0000 [a9992da4aa]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Fix issue with libasteriskpj needing libresample
+
+	  libresample is only needed by pjproject if we're building pjsua, which
+	  we only do if TEST_FRAMEWORK is selected.  It's required by pjsua to
+	  process audio which is needed by some testsuite tests.  Unfortunately,
+	  pjproject relies on a newer version of libresample than the version
+	  that ships by most distros so we need to compile the version that's
+	  bundled with pjproject.  Since we only need it for pjsua, we DON'T want
+	  it's symbols exposed when we actually build asterisk.
+
+	  There was a problem however... TEST_FRAMEWORK is only known AFTER we've
+	  already run ./configure on both asterisk and pjproject but pjproject's
+	  ./configure needs to test it to know whether to set up to build
+	  libresample or not.  The previous way of figuring this out was to
+	  always tell ./configure "yes" but not actually build the library.  This
+	  caused an issue where building libasteriskpj was being told to include
+	  libresample but it wasn't actually there.
+
+	  The solution is to still do a default pjproject configure during an
+	  asterisk ./configure but if makeopts or menuselect.makeopts changes
+	  subsequently, we now reconfigure pjproject, taking into account the
+	  current state of TEST_FRAMEWORK.  Previously, if makeopts or
+	  menuselect.makeopts changed, only a recompile of pjproject was done.
+
+	  Change-Id: I9b5d84c61384a3ae07fe30e85c49698378cc4685
+
+2016-11-01 19:48 +0000 [714412f6c4]  Sebastian Gutierrez <sgutierrez@integraccs.com>
+
+	* chan_sip: add missing account code
+
+	  Added missing account to AMI event of sip show peers
+
+	  ASTERISK-26176 #close
+
+	  Change-Id: Ieb6c2c80a838a1b59c82103eba4c63ba238dc482
+
+2016-09-13 04:08 +0000 [0cf1778eed]  Alexander Traud <pabstraud@compuserve.com>
+
+	* rtp_engine: Allow more than 32 dynamic payload types.
+
+	  The dynamic range (96-127) allows 32 RTP Payload Types. RFC 3551 section 3
+	  allows to reassign other ranges. Consequently, when the dynamic range is
+	  exhausted, you can go for "rtp_pt_dynamic = 35" (or 0) in asterisk.conf. This
+	  enables the range 35-63 (or 0-63) giving room for another 29 (or 64) payload
+	  types.
+
+	  ASTERISK-26311 #close
+
+	  Change-Id: I7bc96ab764bc30098a178b841cbf7146f9d64964
+	  (cherry picked from commit 9ac53877f688c06acaa7c377f15da8770e4ee88b)
+
+2016-11-02 09:15 +0000 [d971647949]  Joshua Colp <jcolp@digium.com>
+
+	* app_dial: Fix incorrect device state when channel is picked up.
+
+	  Given the scenario where multiple channels are dialed using Dial()
+	  but the caller is picked up using PickupChan() all outgoing channels
+	  except the channel specified to PickupChan() would be marked
+	  as ringing until the call had been hung up.
+
+	  When using the PickupChan application the channel executing the
+	  application is swapped into place of another channel. As part
+	  of this process the channel is answered. The Dial application
+	  has explicit logic which checks if the channel is answered,
+	  cancels all other outgoing channels, and bridges. This logic is
+	  different than the normal logic that is executed when an outgoing
+	  channel is answered. This different logic failed to publish dial
+	  events stating that the other outgoing channels had been canceled.
+	  As a result references to the outgoing channels were held onto by
+	  the dial masquerade process until the call had been ended and
+	  the channels had gone away. This would result in the channels
+	  appearing in the "core show channels" list despite not being present
+	  anymore and would also result in incorrect device state.
+
+	  This change makes it so that this logic also publishes
+	  dial events stating that the other outgoing channels have been
+	  canceled.
+
+	  ASTERISK-26549
+
+	  Change-Id: Iea7168e6e82f7d4609ec0366153804e4f55ea64f
+
+2016-11-01 13:13 +0000 [afecb2cfc0]  Richard Mudgett <rmudgett@digium.com>
+
+	* bundled pjproject: Fix DNS write to freed memory.
+
+	  PJPROJECT 2.5.5 introduced a race condition with the -r5349 IPv6 DNS
+	  patch.
+
+	  The patch below fixes a write to freed memory under cartain DNS lookup
+	  conditions.
+
+	  0006-r5477-svn-backport-Fix-DNS-write-on-freed-memory.patch
+
+	  ASTERISK-26516
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: Ifdfae9ecf1e41b53080f33aab44ce1a220f349c5
+
+2016-11-01 06:56 +0000 [5f188bb7a8]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_sdp_rtp: Limit number of formats to defined maximum.
+
+	  The res_pjsip_sdp_rtp module did not restrict the number of
+	  formats added to a media stream in the SDP to the defined
+	  limit. If allow=all was used with additional loaded codecs this
+	  could result in the next media stream being overwritten some.
+
+	  This change restricts the module to limit it to the defined
+	  maximum and also increases the maximum in our bundled pjproject.
+
+	  ASTERISK-26541 #close
+
+	  Change-Id: I0dc5f59d3891246cafa2f3df5ec406f088559ee8
+
+2016-11-01 04:18 +0000 [94c9496ed5]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* netsock.c: fix includes for HURD
+
+	  ASTERISK-25070
+
+	  Change-Id: I43bf94d2d36d3d8a8d0df40cd6c027d65a462814
+
+2016-11-01 04:00 +0000 [c1c9487375]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* define PATH_MAX for HURD
+
+	  PATH_MAX is not guaranteed to be defined. In parctice, all but the HURD
+	  define it to a constant. It is indeed not safe to assume there won't be
+	  longer paths and Asterisk generally does err safely on such cases.
+
+	  So even for HURD we'll just pretend PATH_MAX is 4096.
+
+	  ASTERISK-25070 #close
+
+	  Change-Id: I53d10ba18c34c132bcb640a5fd8e0da1d9b22db3
+
+2016-10-31 17:35 +0000 [50fa868ab8]  Kevin Harwell <kharwell@digium.com>
+
+	* codecs.conf.sample: Add sample and option descriptions for codec_opus
+
+	  codecs.conf.sample was missing codec opus's configuration options, descriptions,
+	  and examples. This patch adds the configuration options and examples to
+	  codecs.conf.sample that can be used with codec_opus.
+
+	  ASTERISK-26538 #close
+
+	  Change-Id: I1d89bb5e01d3e3b5bd78951b8dd0ff077a83dc8b
+
+2016-11-01 08:32 +0000 [b3f10b7b94]  Grachev Sergey <grachev@mcn.ru>
+
+	* chan_sip: Incorrect display option Outbound reg. retry 403
+
+	  If in sip.conf (general section) set option register_retry_403=no,
+	  the command "sip show settings" return value:
+	  Outbound reg. retry 403:0
+	  If in sip.conf (general section) set option register_retry_403=yes,
+	  the command "sip show settings" return value:
+	  Outbound reg. retry 403:-1
+
+	  * In static char "sip show settings" for "Outbound.reg. retry 403"
+	  option use AST_CLI_YESNO
+
+	  ASTERISK-26476 #close
+
+	  Change-Id: I3c14272f05f1067bd2aeaa8b3ef9cf8fcb12dcf9
+
+2016-10-20 07:27 +0000 [29692d4aa4]  Matt Jordan <mjordan@digium.com>
+
+	* res/stasis: Add CLI commands for displaying/debugging ARI apps
+
+	  This patch adds three new CLI commands:
+	   - ari show apps: list the registered ARI applications
+	   - ari show app: show detailed information about an ARI application
+	   - ari set debug: dump events being sent to an ARI application
+
+	  Note that while these CLI commands live in the res_stasis module, we use
+	  the 'ari' family for these commands. This was done as most users of
+	  Asterisk aren't aware of the semantic differences between ARI and
+	  res_stasis, and some 'ari' CLI commands already exist.
+
+	  ASTERISK-26488 #close
+
+	  Change-Id: I51ad6ff0cabee0d69db06858c13f18b1c513c9f5
+
+2016-10-31 16:12 +0000 [a36a7d0cf4]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Fix compile of pjsua so it handles audio
+
+	  In order for pjsua and its python binding to actually negotiate
+	  audio for the testsuite tests, it needs g711 and resample.  The
+	  pj* libraries themselves do not.  Unfortunately, pjproject relies
+	  on a brand new libresample that most distros don't ship so we need
+	  to use the libresample already bundled with pjproject.  Only the pjsua
+	  executable and the _pjsua.so python library are linked with it so it
+	  shouldn't interfere with asterisk itself.
+
+	  Also it was pointed out that apply_patches couldn't handle multiple
+	  patches that depended on each other during the dry-run, so the
+	  dry-run was removed.
+
+	  Change-Id: I24f397462b486dcdde0dcafe40e6c55a6593f098
+
+2016-10-31 13:46 +0000 [42bd70b29f]  Etienne Lessard <elessard@proformatique.com>
+
+	* manager: Add documentation for NewConnectedLine event.
+
+	  The NewConnectedLine event has been added by commit fe7671f, but the
+	  documentation was missing.
+
+	  ASTERISK-26537 #close
+
+	  Change-Id: I7fc331f18caa28492da9303e576f70884ca8c9e6
+
+2016-10-30 13:33 +0000 [30b1bc77d2]  Corey Farrell <git@cfware.com>
+
+	* vector: Prevent NULL argument to memcpy.
+
+	  Headers declare that memcpy does not accept NULL argument for the first
+	  two parameters.  Add a conditional block to prevent memcpy and ast_free
+	  from running on vectors with NULL element array.
+
+	  ASTERISK-26526 #close
+
+	  Change-Id: I988a476bb5fcfcbd3f6d6c6b3e7769e4f9629b71
+
+2016-10-29 10:31 +0000 [b96f18560b]  Corey Farrell <git@cfware.com>
+
+	* astobj2: Declare private variable data_size for AO2_DEBUG only.
+
+	  Every ao2 object contains storage for a private variable data_size,
+	  though the value is never read if AO2_DEBUG is disabled.  This change
+	  makes the variable conditional, reducing memory usage.
+
+	  ASTERISK-26524 #close
+
+	  Change-Id: If859929e507676ebc58b0f84247a4231e11da07f
+
+2016-10-28 16:59 +0000 [6b1c55dc9b]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Fix issue where "/version.mak" wasn't found
+
+	  main/Makefile includes third-party/pjproject/build.mak but
+	  doesn't set PJDIR beforehand so "include $(PJDIR)/version.mak"
+	  evaluates to "/version.mak".  Fix is to set PJDIR in main/Makefile
+	  before the include.
+
+	  Change-Id: I0f7c67d60209049056fe9c4b041bf0463aa95604
+
+2016-10-28 14:55 +0000 [d7f457e4c1]  Richard Mudgett <rmudgett@digium.com>
+
+	* bundled pjproject: Crashes while resolving DNS names.
+
+	  PJPROJECT 2.5.5 introduced a race condition with the -r5349 IPv6 DNS
+	  patch.
+
+	  The patches below fix the DNS lookup race condition crash caused by
+	  attempting to send the same message twice for the single DNS lookup.
+
+	  0006-r5471-svn-backport-Various-fixes-for-DNS-IPv6.patch
+	  0006-r5473-svn-backport-Fix-pending-query.patch
+
+	  The patch below removes a cached DNS response from the hash table when
+	  another thread is referencing the old entry.  The table still contained
+	  the entry when it was destroyed which can result in inexplicable crashes.
+
+	  0006-r5475-svn-backport-Remove-DNS-cache-entry.patch
+
+	  ASTERISK-26344 #close
+	  Reported by: Ian Gilmour
+
+	  ASTERISK-26387 #close
+	  Reported by: Harley Peters
+
+	  Change-Id: I17fde80359e66f65a91341ceca58d914d0f61cc4
+
+2016-10-28 09:50 +0000 [87903a6848]  Rusty Newton <rnewton@digium.com>
+
+	* SAC documentation: don't specify transports for endpoints and registrations
+
+	  Removing explicit transport definition for endpoints and registrations. It
+	  isn't necessary and isn't generally advised.
+
+	  ASTERISK-26514 #close
+
+	  Change-Id: Ifdec5e631962438a4683600968dfa4bfd15909fb
+
+2016-10-27 21:49 +0000 [f373de3020]  Corey Farrell <git@cfware.com>
+
+	* Fix shutdown crash caused by modules being left open.
+
+	  It is only safe to run ast_register_cleanup callbacks when all modules
+	  have been unloaded.  Previously these callbacks were run during graceful
+	  shutdown, making it possible to crash during shutdown.
+
+	  ASTERISK-26513 #close
+
+	  Change-Id: Ibfa635bb688d1227ec54aa211d90d6bd45052e21
+
+2016-10-26 18:48 +0000 [61a5c3460e]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Remove usage of tar's --strip-components option
+
+	  Older versions of tar don't support the --strip-components option so
+	  instead of doing 'tar --strip-components=1 -C source', we now just
+	  untar to the tarball's root directory (pjproject-<version>) and
+	  rename that directory to 'source'.
+
+	  Also fixed an issue where the pjproject source directory is a hard
+	  coded absolute pathname.
+
+	  ASTERISK-26510 #close
+	  ASTERISK-22480 #close
+
+	  Change-Id: I9ec92952507a91ff4e4d01e0149e09fd8e8f32b0
+
+2016-10-27 08:07 +0000 [675c71ae8c]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_caller_id: Fix crash on session timers UPDATE on inbound calls.
+
+	  The res_pjsip_caller_id module wrongly assumed that a
+	  saved From header would always exist on sessions. This
+	  is true until an inbound call is received and a session
+	  timer causes an UPDATE to be sent. In this case there will
+	  be no saved From header and a crash will occur. This change
+	  makes it fall back to the From header of the outgoing request
+	  if no saved From header is present.
+
+	  ASTERISK-26307 #close
+
+	  Change-Id: Iccc3bc8d243b5ede9b81abf960292930c908d4fa
+
+2016-10-26 07:51 +0000 [14496ce1e5]  Joshua Colp <jcolp@digium.com>
+
+	* app_voicemail: Clear voice mailbox in MailboxExists and MAILBOX_EXISTS.
+
+	  When executing the MailboxExists dialplan application and
+	  MAILBOX_EXISTS dialplan function the passed in temporary voice
+	  mailbox was not cleared, causing it to try to free garbage.
+
+	  ASTERISK-26503 #close
+
+	  Change-Id: Ie21ccfa1b80b9c59318e596f6b8e17da2b5a7cb3
+
+2016-10-23 07:38 +0000 [e0bc17edff]  Joshua Colp <jcolp@digium.com>
+
+	* pjsip: Fix a few media bugs with reinvites and asymmetric payloads.
+
+	  When channel format changes occurred as a result of an RTP
+	  re-negotiation the bridge was not informed this had happened.
+	  As a result the bridge technology was not re-evaluated and the
+	  channel may have been in a bridge technology that was incompatible
+	  with its formats. The bridge is now unbridged and the technology
+	  re-evaluated when this occurs.
+
+	  The chan_pjsip module also allowed asymmetric codecs for sending
+	  and receiving. This did not work with all devices and caused one
+	  way audio problems. The default has been changed to NOT do this
+	  but to match the sending codec to the receiving codec. For users
+	  who want asymmetric codecs an option has been added, asymmetric_rtp_codec,
+	  which will return chan_pjsip to the previous behavior.
+
+	  The codecs returned by the chan_pjsip module when queried by
+	  the bridge_native_rtp module were also not reflective of the
+	  actual negotiated codecs. The nativeformats are now returned as
+	  they reflect the actual negotiated codecs.
+
+	  ASTERISK-26423 #close
+
+	  Change-Id: I6ec88c6e3912f52c334f1a26983ccb8f267020dc
+
+2016-10-26 06:32 +0000 [f534f67f52]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_sdp_rtp: Fix address family of explicit media_address.
+
+	  When an explicit media_address is provided the address family
+	  in the SDP needs to be set to reflect it.
+
+	  ASTERISK-26309
+
+	  Change-Id: Ib9350cc91c120eb2f96f0623d3907d12af67eb79
+
+2016-10-25 11:20 +0000 [3a2092b722]  gtjoseph <gjoseph@digium.com>
+
+	* test_astobj2_thrash:  Fix multithreaded issues
+
+	  The test uses 4 threads to grow, count, lookup and shrink 15K objects
+	  in a container.  If there's only 1 execution engine available, the test
+	  will complete in <50ms.  If each threads gets its own execution engine,
+	  the test may timeout after 60 seconds because the count thread does a
+	  locked ao2_callback on the whole container in a tight loop with only
+	  a sched_yield to give up time.  The lock contention makes the test
+	  execution times wildly variable and mostly timeout.  2 execution
+	  engines are OK, 3 results in about 33% failure rate and >=4 causes
+	  a 80% failure rate.
+
+	  To fix, the sched_yield was changed to a usleep(500).
+
+	  Also, the number of buckets specified for the container was an even
+	  number so that was changed to the next prime number greater than
+	  (MAX_HASH_ENTRIES / 100).  That's 151 currently.
+
+	  Change-Id: I50cd2344161ea61bfe4b96d2a29a6ccf88385c77
+
+2016-10-24 14:13 +0000 [640203802e]  Pascal Cadotte Michaud <pcadotte@proformatique.com>
+
+	* typo: s/paranthesis/parenthesis/ in a comment
+
+	  Change-Id: I7c1f4eb051177ee22cbe97e063d4a3effe29be30
+
+2016-10-24 10:55 +0000 [9b3557e054]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Fixed various build issues
+
+	  * CFLAGS is now properly set when using older gcc.
+	  * All third-party pjproject targets have been removed.  This fixes
+	    an issue with older libsrtp in some distros.
+	  * Manually removing the source directory now causes a rebuild.
+	  * EXTERNALS_CACHE_DIR is now properly checked.
+	  * Whitespace fixes.
+
+	  Change-Id: I98fec6847efc5602a9f41cb95096fd660a49fa60
+
+2016-09-19 06:13 +0000 [bb982480d8]  Joshua Colp <jcolp@digium.com>
+
+	* pjsip: Support dual stack automatically.
+
+	  This change adds support for dual stack automatically. No
+	  configuration is required and the IP address and version
+	  in the SIP messages and SDP will be automatically changed
+	  based on the transport over which the message is being
+	  sent. RTP usage has also been changed to listen on both
+	  IPv4 and IPv6 simultaneously to allow media to flow, and
+	  to allow ICE support on both simultaneously. This also
+	  allows failover between IPv6 and IPv4 to work as expected.
+
+	  ASTERISK-26309 #close
+
+	  Change-Id: I235a421d8f9a326606d861b449fa6fe3a030572d
+
+2016-10-17 14:18 +0000 [eff97808fb]  Mark Michelson <mmichelson@digium.com>
+
+	* ARI: Detect duplicate channel IDs
+
+	  ARI and AMI allow for an explicit channel ID to be specified
+	  when originating channels. Unfortunately, there is nothing in
+	  place to prevent someone from using the same ID for multiple
+	  channels. Further complicating things, adding ID validation to channel
+	  allocation makes it impossible for ARI to discern why channel allocation
+	  failed, resulting in a vague error code being returned.
+
+	  The fix for this is to institute a new method for channel errors to be
+	  discerned. The method mirrors errno, in that when an error occurs, the
+	  caller can consult the channel errno value to determine what the error
+	  was. This initial iteration of the feature only introduces "unknown" and
+	  "channel ID exists" errors. However, it's possible to add more errors as
+	  needed.
+
+	  ARI uses this feature to determine why channel allocation failed and can
+	  return a 409 error during origination to show that a channel with the
+	  given ID already exists.
+
+	  ASTERISK-26421
+
+	  Change-Id: Ibba7ae68842dab6df0c2e9c45559208bc89d3d06
+
+2016-10-19 17:53 +0000 [c2036c827c]  snuffy <snuffy22@gmail.com>
+
+	* Fix issue with CLI not returning to prompt after running "features show"
+
+	  ASTERISK-26444 #close
+
+	  Change-Id: I91d645b7e6e5dba35f8c410df2be77a8c0e3acb8
+
+2016-10-04 18:24 +0000 [3c62b60e56]  Michael Walton <mike@farsouthnet.com>
+
+	* res_rtp_asterisk: Add ice_blacklist option
+
+	  Introduces ice_blacklist configuration in rtp.conf. Subnets listed in the
+	  form ice_blacklist = <subnet spec>, e.g. ice_blacklist =
+	  192.168.1.0/255.255.255.0, are excluded from ICE host, srflx and relay
+	  discovery. This is useful for optimizing the ICE process where a system
+	  has multiple host address ranges and/or physical interfaces and certain
+	  of them are not expected to be used for RTP. Multiple ice_blacklist
+	  configuration lines may be used. If left unconfigured, all discovered
+	  host addresses are used, as per previous behavior.
+
+	  Documention in rtp.conf.sample.
+
+	  ASTERISK-26418 #close
+
+	  Change-Id: Ibee88f80d7693874fda1cceaef94a03bd86012c9
+
+2016-10-18 16:30 +0000 [012fda29d2]  Mark Michelson <mmichelson@digium.com>
+
+	* CDR: Alter destruction pattern for CDR chains.
+
+	  CDRs form chains. When the root of the chain is destroyed, it then
+	  unreferences the next CDR in the chain. That CDR is destroyed, and it
+	  then unreferences the next CDR in the chain. This repeats until the end
+	  of the chain is reached. While this typically does not cause any sort of
+	  problems, it is possible in strange scenarios for the CDR chain to grow
+	  way longer than expected. In such a scenario, the destruction pattern
+	  can result in a stack overflow.
+
+	  This patch fixes the problem by switching from a recursive pattern to an
+	  iterative pattern for destruction. When the root CDR is destroyed, it is
+	  responsible for iterating over the rest of the CDRs and unreferencing
+	  each one. Other CDRs in the chain, since they are not the root, will
+	  simply destroy themselves and be done. This causes the stack depth not
+	  to increase.
+
+	  ASTERISK-26421 #close
+	  Reported by Andrew Nagy
+
+	  Change-Id: I3ca90c2b8051f3b7ead2e0e43f60d2c18fb204b8
+
+2016-10-18 09:04 +0000 [6d462b9eaf]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* chan_pjsip: segfault on already disconnected session
+
+	  On heavy loaded system the TCP/TLS incoming calls could be
+	  disconnected by pjproject while these calls are being
+	  processed by asterisk.
+
+	  This patch uses functions pjsip_inv_add_ref/pjsip_inv_dec_ref
+	  to inform pjproject that an INVITE session is in use.
+
+	  ASTERISK-26482 #close
+
+	  Change-Id: Ia2e3e2f75358cdb530252a9ce158af3d5d9fdf33
+
+2016-10-18 03:01 +0000 [662b560c35]  Alexander Traud <pabstraud@compuserve.com>
+
+	* cli: Auto-complete File not Module for core set debug.
+
+	  Since Asterisk 1.8, the command "core set debug" on the command-line interface
+	  asks not for a file (.c) but a module name. This change shows modules (.so) on
+	  the auto-completion via a tabulator or the question mark. Now, when you
+	  partially type a module name, TAB or ?, you get the correct candidiates.
+
+	  ASTERISK-26480
+
+	  Change-Id: I1213f1dd409bd4ff8de08ad80cb0c73cafb1bae0
+
+2016-09-11 10:13 +0000 [6f5880913f]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* menuselect: invalid test for GTK2
+
+	  configuire.ac was only checking for the existence of pkg-config
+	  and not the gtk2 package itself.  Now it calls AST_PKG_CONFIG_CHECK
+	  for gtk+-2.0.
+
+	  ASTERISK-26356 #close
+
+	  Change-Id: I8079d515d6ea99f9ab320a7eaa71c2aaa101ccd5
+
+2016-10-13 02:06 +0000 [644fad7477]  Moises Silva <moises.silva@gmail.com>
+
+	* chan_rtp: Set a sane default rtp engine for unicast.
+
+	  ASTERISK-26439
+
+	  Change-Id: I7f5ee2eeba8906e9ecb3293dbe3a747770bb5011
+
+2016-10-15 20:05 +0000 [42cfdcd1b7]  Matt Jordan <mjordan@digium.com>
+
+	* res/ari: Add the Asterisk EID field to outgoing events
+
+	  This patch adds the Asterisk EID field to all outgoing ARI events.
+	  Because this field should be added to all events as they are
+	  transmitted, it is appended to the JSON message just prior to it being
+	  handed off to the application message handler. This makes it somewhat
+	  resilient to both new events being added to ARI, as well as other
+	  potential event transport mechanisms.
+
+	  ASTERISK-26470 #close
+
+	  Change-Id: Ieff0ecc24464e83f3f44e9c3e7bd9a5d70b87a1d
+
+2016-10-16 17:25 +0000 [74d9385273]  gtjoseph <gjoseph@digium.com>
+
+	* utils.c:  Fix ast_set_default_eid for multiple platforms
+
+	  ast_set_default_eid was searching for ethX, emX, enoX, ensX and even
+	  pciD#U interface names.  While this was a good attempt, it wasn't
+	  inclusive enough to capture interfaces like enp6s0 or ens6d1, etc.
+
+	  Rather than relying on interface names, we now simply find the first
+	  interface returned by the OS that has a hardware address and that
+	  address isn't all 0x00 or all 0xff.  The code IS different for BSD,
+	  Solaris and Linux based on what method is available for enumerating
+	  interfaces.
+
+	  Tested on:
+	  FreeBSD9
+	  CentOS6
+	  Ubuntu14
+	  Fedora24
+
+	  I was unable to test on Solaris at this time but the code for Solaris
+	  is used elsewhere at Digium.
+
+	  Change-Id: Iaa6db87ca78a9a375e47d70e043ae08c1448cb72
+
+2016-10-13 14:09 +0000 [0306869399]  Leandro Dardini <ldardini@gmail.com>
+
+	* app_queue: Added initialization for "context" parameter
+
+	  When using Asterisk Realtime Architecture, empty fields are skipped and the
+	  default values are used. If the "context" parameter in queue was set and then
+	  cleared from the database, the old value remains in memory and it continues
+	  to be used. This change initialize the "context" parameter with an empty value,
+	  allowing clearing the parameter.
+
+	  ASTERISK-26462 #close
+
+	  Change-Id: I64be73d5044ce38dd02408bd0e53de965ef65905
+
+2016-10-11 06:55 +0000 [a859bcb49c]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Support nat=auto_comedia or nat=force_rport,auto_comedia.
+
+	  In the SIP channel driver chan_sip, auto_comedia was expected to be used in
+	  tandem with auto_force_rport. Or stated differently: Only when auto_force_rport
+	  was chosen (the default), auto_comedia worked. This change allows auto_comedia
+	  to be set independently of the state of (auto_)force_rport. For example,
+	  nat=force_rport,auto_comedia is useful for IPv4/IPv6 Dual Stack deployments
+	  when IPv6 clients are behind a Firewall.
+
+	  ASTERISK-26457 #close
+
+	  Change-Id: Ib29d66c6dbb61648e371e01fc36c6978ddae5bc2
+
+2016-10-17 19:08 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.12.0-rc1 Released.
+
+2016-10-17 11:39 +0000 [546ec4b038]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Add patch to address SSL crash
+
+	  Addresses crashes when an attempt is made to operate on an SSL socket
+	  after the socket has been closed.
+
+	  ASTERISK-26477 #close
+
+	  Change-Id: I421305b357558b4f9e690210dc0f4831ef4b3002
+
+2016-10-15 04:58 +0000 [f1fd873df0]  Michael Kuron <m.kuron@gmx.de>
+
+	* chan_sip: Only send video on outgoing channel if incoming channel supports it
+
+	  Previously, the settings videosupport=always and videosupport=yes behaved
+	  identically and unconditionally caused a video offer to be sent in the SDP on
+	  an outgoing call. This was a regression introduced with commit
+	  5a1d90e1fbfc4b48927aad55311f3b38efbf1f54 in Asterisk 1.6.1.
+
+	  This commit restores correct behavior: videosupport=always causes a video offer
+	  to be sent unconditionally, while videosupport=yes will only offer video on an
+	  outbound channel if the incoming channel it is bridged to also supports video.
+	  That way, the device receiving the outgoing call can display the correct user
+	  interface elements for audio or video and will not unnecessarily show a blank
+	  video window on an audio-only call.
+
+	  ASTERISK-17470 #close
+
+	  Change-Id: I782f4409d436114dbc97061c3570c0cd24f7c3ae
+
+2016-10-14 00:18 +0000 [ce4cfd2eca]  Corey Farrell <git@cfware.com>
+
+	* Fix issues with bundled pjproject cached download.
+
+	  Previously when testing I had a preexisting makeopts in ASTTOPDIR.  The
+	  ordering of configure.ac causes --with-externals-cache to be processed
+	  after third-party configure.  In cases where the Asterisk clone is
+	  cleaned it would cause pjproject to be downloaded to /tmp.  This
+	  moves processing of the externals cache and sounds cache to happen
+	  before third-party configure.
+
+	  This also addresses a possible issue with the third-party Makefile.  If
+	  TMPDIR is set by the environment it would override the path given to
+	  --with-externals-cache.
+
+	  ASTERISK-26416
+
+	  Change-Id: Ifab7f35bfcd5a31a31a3a4353cc26a68c8c6592d
+
+2016-10-12 16:24 +0000 [3c54328c57]  Richard Mudgett <rmudgett@digium.com>
+
+	* Audit ast_json_pack() calls for needed UTF-8 checks.
+
+	  Added needed UTF-8 checks before constructing json objects in various
+	  files for strings obtained outside the system.  In this case string values
+	  from a channel driver's peer and not from the user setting channel
+	  variables.
+
+	  * aoc.c: Fixed type mismatch in s_to_json() for time and granularity json
+	  object construction.
+
+	  ASTERISK-26466
+	  Reported by: Richard Mudgett
+
+	  Change-Id: Iac2d867fa598daba5c5dbc619b5464625a7f2096
+
+2016-10-12 16:20 +0000 [7f8f125738]  Richard Mudgett <rmudgett@digium.com>
+
+	* json: Check party id name, number, subaddresses for UTF-8.
+
+	  * Updated unit test as ast_json_name_number() is now NULL tolerant.
+
+	  ASTERISK-26466 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I7d4e14194f8f81f24a1dc34d1b8602c0950265a6
+
+2016-10-11 18:14 +0000 [9621c9bcbc]  Richard Mudgett <rmudgett@digium.com>
+
+	* json: Add UTF-8 check call.
+
+	  Since the json library does not make the check function public we
+	  recreate/copy the function in our interface module.
+
+	  ASTERISK-26466
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I36d3d750b6f5f1a110bc69ea92b435ecdeeb2a99
+
+2016-10-12 17:42 +0000 [e4bb9f9a37]  Richard Mudgett <rmudgett@digium.com>
+
+	* aoc.c: Whitespace cleanup
+
+	  * In s_to_json() removed unnecessary ast_json_ref() to ast_json_null()
+	  when creating the type json object.  The ref is a noop.
+
+	  Change-Id: I2be8b836876fc2e34a27c161f8b1c53b58a3889a
+
+2016-10-12 17:27 +0000 [bcac905bd3]  Richard Mudgett <rmudgett@digium.com>
+
+	* app_queue.c: Fix clearing of pause reason string.
+
+	  The pause reason is not always cleared when it should be cleared.
+
+	  * Made set_queue_member_pause() always clear pause reason if not pausing
+	  with a reason string.
+
+	  Change-Id: I993dad19626ec017478a230e980989438b778c53
+
+2016-10-12 16:22 +0000 [ee4ae2b648]  Richard Mudgett <rmudgett@digium.com>
+
+	* app_minivm.c: Fix malformed ast_json_pack() call.
+
+	  Change-Id: I082b239022fac462666e52a14a44304748908dc0
+
+2016-10-12 16:30 +0000 [90ae4e4337]  gtjoseph <gjoseph@digium.com>
+
+	* res_config_mysql:  Fix several issues related to recent table changes
+
+	  Unlike any of the other database drivers, res_config_mysql checks that
+	  the table definition matches the requirements for every insert and
+	  update statement.  Since all requirements are forced to 'char', any
+	  column that isn't a char, like ps_contacts' expiration_time,
+	  qualify_timeout, etc., will throw a warning.  It's kinda harmless but
+	  very misleading.  Since no other driver does those checks on insert
+	  or update, they've been removed from res_config_mysql.  Also, all
+	  the logic that actually attempted to ALTER the table to fix the issue
+	  has been removed.  With the move to alembic, the auto-alter
+	  functionality is not only unnecessary, it's also dangerous.
+
+	  The other issue is that res_config_mysql calls the mysql_insert_id
+	  function inside store_mysql.  Presumably the intention was to return
+	  the number of rows inserted DESPITE A NOTE IN THE CODE THAT THE VALUE
+	  IS NON_PORTABLE AND MAY CHANGE.  That value is then returned to
+	  config realtime as the number of rows inserted.  Guess what?  The value
+	  changed.  It now only returns the number of rows inserted if there's an
+	  auto increment column on the table, which ps_contacts doesn't have.
+	  Otherwise it returns 0.  So now, the insert worked but we tell config
+	  realtime and sorcery that no rows were inserted.  That call to
+	  mysql_insert_id was removed and we now always return 1 if the insert
+	  succeeded.  We're only inserting 1 row at a time anyway.  If the insert
+	  fails, we still return -1.
+
+	  ASTERISK-26362 #close
+	  Reported-by: Carlos Chavez
+
+	  Change-Id: I83ce633efdb477b03c8399946994ee16fefceaf4
+
+2016-09-29 13:08 +0000 [86c15db6a1]  Torrey Searle <torrey@voxbone.com>
+
+	* res_fax: Fix a tight race condition causing fax to crash in audio fallback
+
+	  When T.38 gets rejected and G711 failback occurs there is a period of
+	  time where neither AST_FAX_TECH_T38 nor AST_FAX_TECH_AUDIO is set,
+	  leading to a crash.
+
+	  Change-Id: Icc3f457b2292d48a9d7843dac0028347420cc982
+
+2016-09-30 16:29 +0000 [29b7a5b00f]  Rodrigo Ramírez Norambuena <a@rodrigoramirez.com>
+
+	* Add text of cdr directory into README.md for ast-db-manage
+
+	  Change-Id: I68321c4bea50730c39fdb486e5f23aeadd1ad636
+
+2016-10-06 09:58 +0000 [f919edc4e2]  gtjoseph <gjoseph@digium.com>
+
+	* app_dial:  Add the "Q" option to set the cause on unanswered channels
+
+	  The "Q" option will set the cause on the unanswered channels when
+	  another channel answers.  It overrides the default of
+	  ANSWERED_ELSEWHERE.
+
+	  NOTE:  chan_sip does not support setting the cause on a CANCEL to
+	  anything other than ANSWERED_ELSEWHERE.
+
+	  ASTERISK-26446 #close
+
+	  Change-Id: I71742e0919aaa16784c30a2b2e73fbeed7672e47
+
+2016-10-10 16:59 +0000 [a884b26392]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* vector: After remove element recheck index
+
+	  Small fix. It is necessary to double-check
+	  the index that we just removed because there
+	  is a new element.
+
+	  ASTERISK-26453 #close
+
+	  Change-Id: Ib947fa94dc91dcd9341f357f1084782c64434eb7
+
+2016-09-29 12:52 +0000 [349c34f72a]  Torrey Searle <torrey@voxbone.com>
+
+	* res_rtp_asterisk: Fix infinite DTMF issue when switching to P2P bridge
+
+	  If a bridge switched to P2P when a DTMF was in progress it
+	  was possible for the DTMF to continue being sent indefinitely.
+
+	  Change-Id: I7e2a3efe0d59d4b214ed50cd0b5d0317e2d92e29
+
+2016-10-10 10:59 +0000 [9da3489d24]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* res_pjsip_config_wizard: Memory leak in module_unload
+
+	  Fixed a memory leak. It removes only the first element.
+	  Added a useful feature in vector.h to remove all items
+	  under the CMP through a callback function / macro.
+
+	  ASTERISK-26453 #close
+
+	  Change-Id: I84508353463456d2495678f125738e20052da950
+
+2016-10-09 21:53 +0000 [fa2885b3ff]  Badalyan Vyacheslav <v.badalyan@open-bs.ru>
+
+	* cel_odbc: Fix memory leak on module unload
+
+	  Change-Id: Ic7a1236eba2408090fdabb5f717b5fa455ead715
+
+2016-10-03 11:30 +0000 [e6b0053d75]  gtjoseph <gjoseph@digium.com>
+
+	* bundled_pjproject:  Add tests for programs used by the Makefile, et al.
+
+	  Added tests for bzip2, tar, patch, sed and nm to configure.ac.
+
+	  Set DOWNLOAD_TO_STDOUT to a working command line regardless of
+	  whether the download program is wget, curl or fetch.
+
+	  Added a 'configure.m4' file to the third-party directory which takes
+	  care of calling any third-party project setup.  Had to move some
+	  pjproject_bundled stuff up in configure.ac so it was called before
+	  the third-party configure macro.
+
+	  The pjproject tarball is now downloaded to the externals_cache_dir if
+	  it was specified on the ./configure command line
+
+	  Removed regeneration of the pjproject aconfigure file.  It was only
+	  needed for an old patch that no longer applies.
+
+	  Converted the tests for symbols to explicit tests since we know that
+	  they're now available in the bundled version.  Saves a little time
+	  during configure.
+
+	  ASTERISK-26416 #close
+	  Reported-by: Corey Farrell
+
+	  Change-Id: Id1d94251c0155f8dd41b7de7067f35cfbaafbb9b
+
+2016-10-05 14:53 +0000 [0dc0356e39]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Add MALLOC_DEBUG capability
+
+	  pjproject_bundled will now use the asterisk memory debugging APIs
+	  if MALLOC_DEBUG is turned on in menuselect.
+
+	  Because this required stubs for the executable programs and the python
+	  bindings, some Makefile reorganization was needed to properly handle
+	  the dependencies.  As a result, the makefile now individually makes
+	  each of the pjproject libraries separately instead of making them all
+	  in 1 shot.  The only visible change is that there are separate status
+	  lines printed for each library instead oif 1 for all libs.  Also, the
+	  making of the pjproject dependency files was eliminated.  They're not
+	  needed for building unless you're actively modifying pjproject source
+	  files and it makes the build process faster.  Finally, any issues with
+	  parallel builds should be resolved again making the build faster.
+
+	  Change-Id: Icc5e3d658fbfb00e0a46b44c66dcc2522d5171b0
+
+2016-10-07 17:32 +0000 [dd873bcada]  Corey Farrell <git@cfware.com>
+
+	* astobj2: Add backtrace to log_bad_ao2.
+
+	  * Compile __ast_assert_failed unconditionally.
+	  * Use __ast_assert_failed to log messages from log_bad_ao2
+	  * Remove calls to ast_assert(0) that happen after log_bad_ao2 was run.
+
+	  Change-Id: I48f1af44b2718ad74a421ff75cb6397b924a9751
+
+2016-10-04 16:59 +0000 [86550f9c17]  gtjoseph <gjoseph@digium.com>
+
+	* alembic:  Allow cdr, config and voicemail to exist in the same schema
+
+	  cdr, config and voicemail are all separate alembic trees.  Because
+	  alembic's default is to use a table named 'alembic_version' to store
+	  the current tree revision, the 3 trees can't exist in the same schema
+	  without stepping on each other.
+
+	  Now each tree uses 'alembic_version_<tree_name>' as the version table.
+	  Each tree's env.py script now first checks for 'alembic_version'.  If
+	  it finds it AND its revision is in the tree's history, the script
+	  renames it to 'alembic_version_<tree_name>'.  Regardless, the script
+	  then continues with the migration using 'alembic_version_<tree_name>'
+	  and creates that table if it's not found.  The result is that if an
+	  existing 'alembic_version' table was found but it didn't belong to this
+	  tree, it's left alone and 'alembic_version_<tree_name>' is used or
+	  created.
+
+	  WARNING:  If multiple trees are using the same schema, they MUST NOT
+	  CRU or D any objects with names that might exist in the other trees.
+	  An example would be 'yesno_values' type.  If two trees perform
+	  operations on it, one tree could pull it out from under the other.
+	  Thankfully we currently don't share any names among cdr, config and
+	  voicemail.
+
+	  NOTE:  Since the env.py scripts in each tree were identical, a common
+	  env.py has been placed in the ast-db-manage directory and a symlink
+	  to it has been placed in each tree directory.
+
+	  ASTERISK-24311 #close
+	  Reported-by: Dafi Ni
+
+	  Change-Id: I4d593f000350deb5d21a14fa1e9bc3896844d898
+
+2016-10-05 04:25 +0000 [f166681c12]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Honor support of Symmetric Response (rport) for SIP requests.
+
+	  In the SIP channel driver chan_sip, the default is "auto_force_rport". When no
+	  NAT was detected, for example in case of IPv6, Asterisk uses the IP address
+	  from the headers within the SIP-REGISTER for subsequent SIP signaling. When
+	  the remote party specifies support for Symmetric Response (RFC 3581) via the
+	  parameter "rport", Asterisk should not extract the port from the SIP headers
+	  but reuse the port of the transport. This did not happen because of a typo.
+
+	  ASTERISK-26438 #close
+
+	  Change-Id: If6e7891848aaf96666dee5305695f7c6667cd5a6
+
+2016-10-04 20:46 +0000 [430f6e5388]  Michael Walton <mike@farsouthnet.com>
+
+	* audiohooks: Remove redundant codec translations when using audiohooks
+
+	  The main frame read and write handlers in main/channel.c don't use the
+	  optimum placement in the processing flow for calling audiohooks
+	  callbacks, as far as codec translation is concerned. This change places
+	  the audiohooks callback code:
+	   * After the channel read translation if the frame is not linear before
+	  the translation, thereby increasing the chance that the frame is linear
+	  as required by audiohooks
+	   * Before the channel write translation if the frame is linear at this
+	  point
+	  This prevents the audiohooks code from instantiating additional
+	  translation paths to/from linear where a linear frame format is already
+	  available, saving valuable CPU cycles
+
+	  ASTERISK-26419
+
+	  Change-Id: I6edd5771f0740e758e7eb42558b953f046c01f8f
+
+2016-09-29 14:02 +0000 [2449d2877c]  Kevin Harwell <kharwell@digium.com>
+
+	* Remove "format_ogg_opus: New format"
+
+	  This reverts commit 40aa28131bc30b4516da2b20eb1a1e043920169c.
+
+	  ASTERISK-26426 #close
+
+	  Change-Id: I81e55c3c512f1dd6f49896f0c6b97a07d74fd8f5
+
+2016-09-27 16:10 +0000 [f0a2e628d6]  gtjoseph <gjoseph@digium.com>
+
+	* download_externals: Fix issue with re-install
+
+	  Needed to ignore an xmlstarlet return code for optional element.
+
+	  Change-Id: I6a96f709b4b38c9a3f3dda4e8b07903787e16873
+	  Reported-by: Dan Jenkins
+
+2016-09-22 09:49 +0000 [5258c067ae]  gtjoseph <gjoseph@digium.com>
+
+	* codec_opus: Add download ability to menuselect
+
+	  Updated codecs/codecs.xml to add codec_opus to the external
+	  download list.
+
+	  ASTERISK-26409
+
+	  Change-Id: Ia07b36539f30e852125fb2b94147dc9774df31a4
+
+2016-07-23 14:50 +0000 [a5af8709c8]  gtjoseph <gjoseph@digium.com>
+
+	* codec_opus: Replace res_format_attr_opus with the one from codec_opus
+
+	  Preparation
+
+	  ASTERISK-26409
+
+	  Change-Id: I9f20e7cce00c32464d9a180e81283d49d199d0a3
+	  (cherry picked from commit 59f7662a93bf9c07204fb50e1020a0f5bfbbd5c9)
+
+2016-07-23 15:56 +0000 [44c0c51cf1]  gtjoseph <gjoseph@digium.com>
+
+	* format_ogg_opus: New format
+
+	  Add Ogg/Opus playback support.
+
+	  This uses libopusfile in order to be able to read .opus files and play
+	  them back.
+
+	  Writing/recording support is not present at this time.
+
+	  ASTERISK-26409
+
+	  Change-Id: I8815d23345108d8ca7c0bd640f6a1ce6b4f56955
+
+2016-09-24 19:05 +0000 [0ab443007b]  gtjoseph <gjoseph@digium.com>
+
+	* build_tools:  Add ability to download variants to download_externals
+
+	  Some external packages have multiple variants that apply to different
+	  builds of asterisk.  The DPMA for instance has a "bundled" variant that
+	  needs to be downloaded if asterisk was configured with
+	  --with-pjproject-bundled.
+
+	  There are 2 ways to specify variants:
+
+	  If you need the user to make the decision about which variant to
+	  download, simply create multiple menuselect "member" entries like so...
+
+	  <member name="res_digium_phone" displayname="..snipped..">
+	    <support_level>external</support_level>
+	    <depend>xmlstarlet</depend>
+	    <depend>bash</depend>
+	    <defaultenabled>no</defaultenabled>
+	  </member>
+
+	  <member name="res_digium_phone-bundled" displayname="..snipped..">
+	    <support_level>external</support_level>
+	    <depend>xmlstarlet</depend>
+	    <depend>bash</depend>
+	    <defaultenabled>no</defaultenabled>
+	  </member>
+
+	  Note that the second entry has "-<variant>" appended to the name.
+	  You can then use the existing menuselect facilities to restrict which
+	  members to enable or disable.  Youy probably don't want the user to
+	  enable multiple at the same time.
+
+	  If you want to hide the details of the variants, the better way to
+	  do it is to create 1 member with "variant" elements.
+
+	  <member name="res_digium_phone" displayname="..snipped..">
+	    <support_level>external</support_level>
+	    <depend>xmlstarlet</depend>
+	    <depend>bash</depend>
+	    <defaultenabled>no</defaultenabled>
+	    <member_data>
+	      <downloader>
+	        <variants>
+	          <variant tag="bundled"
+	            condition='[[ "$PJPROJECT_BUNDLED" = "yes" ]]'/>
+	        </variants>
+	      </downloader>
+	    </member_data>
+	  </member>
+
+	  The condition must be a bash expression suitable for use with an "if"
+	  statement.  Any environment variable can be used plus those available
+	  in makeopts.
+
+	  In this case, if asterisk was configured with --with-pjproject-bundled
+	  the bundled variant will be automatically downloaded.  Otherwise the
+	  normal version will be downloaded.
+
+	  Change-Id: I4de23e06d4492b0a65e105c8369966547d0faa3e
+
+2016-09-22 01:40 +0000 [a0a17a8c6f]  Aaron An <anjb@ti-net.com.cn>
+
+	* channels/chan_pjsip: fix HANGUPCAUSE function bug.
+
+	  HANGUPCAUSE not return 'SIP 200 Ok' when dialed channel answered.
+	  This patch change the call order of ast_queue_control_data
+	  and ast_queue_control in chan_pjsip_incoming_response.
+
+	  ASTERISK-26396 #close
+	  Reported by: AaronAn
+	  Tested by: AaronAn
+
+	  Change-Id: Ide2d31723d8d425961e985de7de625694580be61
+
+2016-09-23 09:54 +0000 [0502675e5c]  Alessandro Crespi
+
+	* chan_sip: Resolve externhost not to IPv6; instead go for IPv4.
+
+	  For the channel driver chan_sip, you specify externhost=example.com in sip.conf
+	  when your Asterisk is behind a NAT and your IP address is assigned dynamically.
+	  Or stated differently: You do not have a static IP address to use "externaddr"
+	  directly. This NAT support is quite handy but just about IPv4. Previously,
+	  Asterisk resolved "externhost" to any IP version. When the first DNS answer
+	  resolved to an IPv6, Asterisk sent an IPv6 in SIP/SDP for origin (o=) and
+	  connection (c=). This happened in outgoing SIP-REGISTER and while answering
+	  SIP-INVITE. If the remote peer is IPv4-only, it might not handle o=/c= with an
+	  IPv6. This change makes sure, no IPv6 is resolved anymore for "externhost".
+
+	  ASTERISK-18232 #close
+	  Reported by: Jacek Kowalski
+	  Tested by: Alexander Traud
+	  patches:
+	   changes.patch submitted by Alessandro Crespi
+
+	  Change-Id: If68eedbeff65bd1c1d8a9ed921c02ba464b32dac
+
+2016-09-20 09:42 +0000 [0056bcaebd]  gtjoseph <gjoseph@digium.com>
+
+	* chan_sip:  Address runaway when realtime peers subscribe to mailboxes
+
+	  Users upgrading from asterisk 13.5 to a later version and who use
+	  realtime with peers that have mailboxes were experiencing runaway
+	  situations that manifested as a continuous stream of taskprocessor
+	  congestion errors, memory leaks and an unresponsive chan_sip.
+
+	  A related issue was that setting rtcachefriends=no NEVER worked in
+	  asterisk 13 (since the move to stasis).  In 13.5 and earlier, when a
+	  peer tried to register, all of the stasis threads would block and
+	  chan_sip would again become unresponsive.  After 13.5, the runaway
+	  would happen.
+
+	  There were a number of causes...
+	  * mwi_event_cb was (indirectly) calling build_peer even though calls to
+	    mwi_event_cb are often caused by build_peer.
+	  * In an effort to prevent chan_sip from being unloaded while messages
+	    were still in flight, destroy_mailboxes was calling
+	    stasis_unsubscribe_and_join but in some cases waited forever for the
+	    final message.
+	  * add_peer_mailboxes wasn't properly marking the existing mailboxes
+	    on a peer as "keep" so build_peer would always delete them all.
+	  * add_peer_mwi_subs was unsubscribing existing mailbox subscriptions
+	    then just creating them again.
+
+	  All of this was causing a flood of subscribes and unsubscribes on
+	  multiple threads all for the same peer and mailbox.
+
+	  Fixes...
+	  * add_peer_mailboxes now marks mailboxes correctly and build_peer only
+	    deletes the ones that really are no longer needed by the peer.
+	  * add_peer_mwi_subs now only adds subscriptions marked as "new" instead
+	    of unsubscribing and resubscribing everything.  It also adds the peer
+	    object's address to the mailbox instead of its name to the subscription
+	    userdata so mwi_event_cb doesn't have to call build_peer.
+
+	  With these changes, with rtcachefriends=yes (the most common setting),
+	  there are no leaks, locks, loops or crashes at shutdown.
+
+	  rtcachefriends=no still causes leaks but at least it doesn't lock, loop
+	  or crash.  Since making rtcachefriends=no work wasnt in scope for this
+	  issue, further work will have to be deferred to a separate patch.
+
+	  Side fixes...
+	   * The ast_lock_track structure had a member named "thread" which gdb
+	     doesn't like since it conflicts with it's "thread" command.  That
+	     member was renamed to "thread_id".
+
+	  ASTERISK-25468 #close
+
+	  Change-Id: I07519ef7f092629e1e844f855abd279d6475cdd0
+
+2016-09-21 15:03 +0000 [323aff3a09]  Joshua Colp <jcolp@digium.com>
+
+	* core: Ensure presencestate subtype and message are NULL.
+
+	  When retrieving presence state information there is no
+	  guarantee that the subtype and message passed in are
+	  set to NULL. This change ensures they are.
+
+	  ASTERISK-26397 #close
+
+	  Change-Id: I61f8187972d5d8bbd7d6b7f4daa4f4f7e8237b23
+
+2016-09-21 10:48 +0000 [10c180760c]  Joshua Colp <jcolp@digium.com>
+
+	* res_odbc: Make pooling option deprecation notice more useful.
+
+	  This changes the notice for the deprecation of the old
+	  pooling options to point to the new option for doing
+	  pooling. This gives a clearer direction as to what to
+	  look into.
+
+	  ASTERISK-26389 #close
+
+	  Change-Id: I2ca9cdfdcd75aec170a7db9d5ff69a4cd25b7c10
+
+2016-09-12 07:37 +0000 [42cc267016]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* cdr_mysql: fix UTC support
+
+	  * Make 'cdrzone=UTC' work properly.
+	  * Fix the documentation of cdr_mysql.conf: it's cdrzone and not timezone
+
+	  ASTERISK-26359 #close
+
+	  Change-Id: I2a6f67b71bbbe77cac31a34d0bbfb1d67c933778
+
+2016-09-21 08:46 +0000 [f16ab19292]  Joshua Colp <jcolp@digium.com>
+
+	* odbc: Remove options that are no longer applicable.
+
+	  The pooling, shared_connection, limit, and idlecheck options
+	  are no longer used in res_odbc.
+
+	  ASTERISK-26389
+
+	  Change-Id: I2fde7b467d01f9d1c82cc0a339bb4f7e1dd6bbe6
+
+2016-09-20 15:17 +0000 [c9ce299b64]  Corey Farrell <git@cfware.com>
+
+	* core: Fix LOW_MEMORY missing symbol ast_pbx_uuid_get.
+
+	  Move the function outside the conditional block that excludes
+	  LOW_MEMORY.
+
+	  ASTERISK-26273 #close
+
+	  Change-Id: Ic290fa128222c410c3531107e30efacabc8493b4
+
+2016-09-20 10:05 +0000 [610eb4c189]  Corey Farrell <git@cfware.com>
+
+	* logger: Fix default console settings.
+
+	  When logger.conf is missing or invalid we should be printing notices,
+	  warnings and errors to the console.  The logmask was incorrectly
+	  calculated.
+
+	  Change-Id: Ibaa9465a8682854bc1a5e9ba07079bea1bfb6bb3
+
+2016-06-27 14:26 +0000 [36092ee3a0]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* sd_notify (systemd status notifications) support
+
+	  sd_notify() is used to notify systemd of changes to the status of the
+	  process. This allows the systemd daemon to know when the process
+	  finished loading (and thus only start another program after Asterisk has
+	  finished loading).
+
+	  To use this, use a systemd unit with 'Type=notify' for Asterisk.
+
+	  This commit also adds the function ast_sd_notify(), a wrapper around
+	  sd_notify that does nothing if not built with systemd support.
+
+	  Also adds support for libsystemd detection in the configure script.
+
+	  Change-Id: Ied6a59dafd5ef331c5c7ae8f3ccd2dfc94be7811
+	  (cherry picked from commit 07b95f7c65b7c083724f1af2b26f93cc22cad58c)
+
+2016-09-19 14:21 +0000 [9372d32100]  Walter Doekes <walter+github@wjd.nu>
+
+	* asterisk.c: Non-root users also get the astcanary after core restart.
+
+	  Without this change, a 'core restart' would kill the astcanary forever
+	  if you're not running as root. Both with and without this patch, the
+	  scheduling priority was still SCHED_RR after restart.
+
+	  Additionally, the astcanary is now spawned if you start with high
+	  priority and Asterisk doesn't get a chance to lower it. For example
+	  through: `chrt -r 10 sudo -u asterisk asterisk -c`
+
+	  Also reap killed astcanary processes on core restart.
+
+	  ASTERISK-26352 #close
+
+	  Change-Id: Iacb49f26491a0717084ad46ed96b0bea5f627a55
+
+2016-09-19 09:40 +0000 [e96448e991]  Walter Doekes <walter+github@wjd.nu>
+
+	* asterisk.c: When astcanary dies on linux, reset priority on all threads.
+
+	  Previously only the canary checking thread itself had its priority set
+	  to SCHED_OTHER. Now all threads are traversed and adjusted.
+
+	  ASTERISK-19867 #close
+	  Reported by: Xavier Hienne
+
+	  Change-Id: Ie0dd02a3ec42f66a78303e9c1aac28f7ed9aae39
+
+2016-09-09 06:35 +0000 [01884a7af6]  Timo Teräs <timo.teras@iki.fi>
+
+	* Fix showing of swap details when sysinfo() is available
+
+	  If sysinfo() is available, but not sysctl() or swapctl() the
+	  printing code for swap buffer sizes is incorrectly omitted.
+	  The above condition happens with musl c-library.
+
+	  Fix #if rule to consider defined(HAVE_SYSINFO). And also
+	  remove the redundant || defined(HAVE_SYSCTL) which was
+	  incorrectly there to start with. Now swap information is
+	  displayed only if an actual libc function to get it is
+	  available.
+
+	  This also fixes warnings previously seen with musl libc:
+
+	     [CC] asterisk.c -> asterisk.o
+	  asterisk.c: In function 'handle_show_sysinfo':
+	  asterisk.c:773:6: warning: variable 'totalswap' set but not used
+	   [-Wunused-but-set-variable]
+	    int totalswap = 0;
+	        ^~~~~~~~~
+	  asterisk.c:770:11: warning: variable 'freeswap' set but not used
+	   [-Wunused-but-set-variable]
+	    uint64_t freeswap = 0;
+	             ^~~~~~~~
+
+	  Change-Id: I1fb21dad8f27e416c60f138c6f2bff03fb626eca
+
+2016-09-12 18:00 +0000 [cdbad152c7]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_config_odbc.c: Fix buffer size limitation creating invalid SQL.
+
+	  Creating ODBC SQL queries resulted in queries too large to fit into the
+	  supplied buffer.  The resulting truncated buffer contained an invalid SQL
+	  query.
+
+	  * Made SQL query generation code use a thread storage buffer that can
+	  increase in size as needed.
+
+	  * Fixed bad multi-line warning messages.
+
+	  ASTERISK-26263 #close
+	  Reported by: Jeppe Ryskov Larsen
+
+	  Change-Id: I23f3cdd43c2dac80bed3ded4dd77d18cb17f21ae
+
+2016-09-14 08:42 +0000 [449719be00]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_multihomed: Change Contact port to listening port.
+
+	  The res_pjsip_multihomed module determines what interface and transport
+	  a request is going out on and updates the SIP message accordingly with
+	  the address information. This currently incorrectly updates the Contact
+	  header for connectionful protocols to the ephemeral connection port,
+	  instead of the bound address for the listening socket which can actually
+	  accept the connection back. If the remote side attempts to connect back on
+	  the epehemeral port it will fail.
+
+	  This change makes it so the port is updated to the bound port on
+	  connectionful protocols and is maintained on UDP (as there can be
+	  multiple of those).
+
+	  ASTERISK-26374 #close
+
+	  Change-Id: I50f8dab65b9f75117d73ba5f6bbcf6c9871854ab
+
+2016-09-07 14:48 +0000 [4d64b176eb]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Prevent SERVFAIL from marking name server bad
+
+	  A name server that returns "Server Failure" is indicating only that
+	  the server couldn't process that particular request.  We should NOT
+	  assume that the name server is incapable of serving other requests.
+
+	  Here's the scenario we've been encountering...
+
+	  * 2 local name servers configured in resolv.conf.
+	  * An OPTIONS request causes a request for A and AAAA records to go out
+	    to both nameservers.
+	  * The A responses both come back successfully resolved.
+	  * Because of an issue at some upstream nameserver, the AAAA responses
+	    for that particular query come back as "SERVFAIL" from both local
+	    name servers.
+	  * Both local servers are marked as bad and no further queries can be
+	    sent until the 60 second ttl expires.  Only previously cached results
+	    can be used.
+	  * In this case, 60 seconds is just enough time for another OPTIONS
+	    request to go out to the same host so the cycle repeats.
+
+	  We could set the bad ttl really low but that also affects REFUSED and
+	  NOTAUTH which probably DO signal a real server issue.  Besides, even
+	  a really low bad ttl would be an issue on a pbx.
+
+	  Although we use our own resolver in 14 and master and don't have this
+	  issue there, Teluu has merged this patch upstream so it's appropriate
+	  to cherry-pick to 14 and master to keep pjproject consistent.
+
+
+	  Change-Id: Ie03ba902288e274aff23f9b9bb2786e1e8be09e0
+
+2016-09-14 07:59 +0000 [1cac856e17]  Joshua Colp <jcolp@digium.com>
+
+	* rtp: Preserve timestamps on video frames.
+
+	  Currently when receiving video over RTP we store only
+	  a calculated samples on the frame. When starting the video
+	  it can take some time for this calculation to actually yield
+	  a value as it requires constant changing timestamps. As well
+	  if a video frame passes over multiple RTP packets this calculation
+	  will fail as the timestamp is the same as the previous RTP
+	  packet and the number of samples calculated will be 0.
+
+	  This change preserves the timestamp on the frame and allows
+	  it to pass through the core. When sending the video this timestamp
+	  is used instead of a new one being calculated.
+
+	  ASTERISK-26367 #close
+
+	  Change-Id: Iba8179fb5c14c9443aee4baf670d2185da3ecfbd
+
+2016-09-14 09:51 +0000 [9df4056d70]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_transport_management: Convert time in log message to seconds.
+
+	  ASTERISK-26375 #close
+
+	  Change-Id: I46496af5cae41413e76d44d2068a7431279f09dc
+
+2016-09-13 05:34 +0000 [98e42cc662]  Steve Davies <steve@one47.co.uk>
+
+	* chan_sip: Fix session timeout on retransmit of non-UDP packets
+
+	  Change-Id I1cd33453c77c56c8e1394cd60a6f17bb61c1d957 Enable Session-Timers for
+	  SIP over TCP (and TLS) also disables SIP retransmits in chan_sip for non-UDP
+	  connections, allowing the TCP layer to handle the retransmits. Unfortunately,
+	  this caused sessions to be terminated with a retransmit timeout becasue it
+	  stopped at the point of the first retrans call.
+
+	  This patch waits for the 64*T1 timer to expire instead.
+
+	  ASTERISK-19968
+
+	  Change-Id: I844f26801aada10bc94e9bebe6e151f0a8443204
+
+2016-09-12 12:25 +0000 [0388882cdb]  Richard Mudgett <rmudgett@digium.com>
+
+	* app_queue: Fix CLI "queue show" and AMI Queues action output truncation.
+
+	  The output of CLI "queue show" and AMI Queues action is truncated and
+	  "failed to extend from 240 to 327" messages are generated if the queue
+	  member and interface names are lengthy.
+
+	  * Increase the string buffer size from 240 to 512 in order to accommodate
+	  for more information fields added to the output since v1.8.
+
+	  ASTERISK-26360 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: Id99c03cf5362453b80491a4b3b0434cb67aa966d
+
+2016-09-12 03:28 +0000 [da8ba990d1]  Walter Doekes <walter+github@wjd.nu>
+
+	* chan_sip: Allow target refresh (Contact update) on re-INVITE.
+
+	  Previously, the Contact was stored only on initial INVITE and on any
+	  18X and 200. That meant that after re-INVITEs from *us* the Contact
+	  could get updated, but after re-INVITEs from the *peer*, it did not.
+
+	  This changeset fixes this inconsistency, properly allowing target
+	  refreshes through re-INVITES (RFC3261, 12.2).
+
+	  If your strictrtp setting allows it, this change allows you to switch
+	  the source IP of a connected/calling device mid-call with a simple
+	  re-INVITE from the new IP.
+
+	  ASTERISK-26358 #close
+
+	  Change-Id: Ibb8512054ab27c8c3d2514022568fde943bf2435
+
+2016-08-31 15:22 +0000 [e9ddab4685]  Richard Mudgett <rmudgett@digium.com>
+
+	* sip_to_pjsip.py: Map legacy_useroption_parsing.
+
+	  Map the sip.conf general section legacy_useroption_parsing to the
+	  new pjsip.conf global ignore_uri_user_options.
+
+	  ASTERISK-26316
+	  Reported by: Kevin Harwell
+
+	  Change-Id: I78108a31995db19d41f4e1a07b3324692c5363fc
+
+2016-08-29 18:08 +0000 [30af92e78d]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Add ignore_uri_user_options option.
+
+	  This implements the chan_sip legacy_useroption_parsing option but with a
+	  better name.
+
+	  * Made the caller-id number and redirecting number strings obtained from
+	  incoming SIP URI user fields always truncated at the first semicolon.
+	  People don't care about anything after the semicolon showing up on their
+	  displays even though the RFC allows the semicolon.
+
+	  ASTERISK-26316 #close
+	  Reported by: Kevin Harwell
+
+	  Change-Id: Ib42b0e940dd34d84c7b14bc2e90d1ba392624f62
+
+2016-09-09 06:26 +0000 [7ed5dc2c58]  Walter Doekes <walter+github@wjd.nu>
+
+	* contrib: Let safe_asterisk script continue without /dev/tty9.
+
+	  If you use the safe_asterisk script, it uses hardcoded defaults before
+	  running configurable values from /etc/asterisk/startup.d. The hardcoded
+	  default has TTY=9. Some containerized environments don't have such a
+	  TTY, and safe_asterisk would stop.
+
+	  The custom configuration from /etc/asterisk/startup.d/* isn't read until
+	  after it stopped, so changing TTY in a custom config did not help.
+
+	  This changeset changes safe_asterisk to continue if the TTY setting was
+	  untouched and /dev/tty9 and /dev/vc/9 aren't found.
+
+	  Change-Id: I2c7cdba549b77f418a0af4cb1227e8e6fe4148fc
+
+2016-09-09 05:39 +0000 [7580a736bb]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip: Only invoke unidentified endpoint logic when unidentified.
+
+	  The code was incorrectly invoking the unidentified logic when
+	  an endpoint had actually been identified, causing log messages
+	  to be output.
+
+	  ASTERISK-26349 #close
+
+	  Change-Id: Id8104fc9e3d138d5e8b6f6977ecc08765fd17d4f
+
+2016-08-23 06:35 +0000 [efcfc4c1ee]  Corey Farrell <git@cfware.com> (license 5909)
+
+	* chan_sip: Don't allocate new RTP instances on top of old ones.
+
+	  In some scenarios dialog_initialize_rtp can be called multiple times on
+	  the same dialog.  This can cause RTP instances to be leaked along with
+	  multiple file descriptors for each instance.
+
+	  This change makes it so the existing RTP instances are destroyed and
+	  not overwritten, stopping the memory leak.
+
+	  ASTERISK-26272 #close
+	  patches:
+	    ASTERISK-26272-13.patch submitted by Corey Farrell (license 5909)
+
+	  Change-Id: Id529de1184c68f2f4d254ab41a1f458dafdb5f73
+
+2016-08-16 15:34 +0000 [f1ffc22933]  Mark Michelson <mmichelson@digium.com>
+
+	* res_pjsip: Do not crash on ACKs from unknown endpoints.
+
+	  The endpoint identification PJSIP module is intended to identify which
+	  endpoint an incoming request is from. If an endpoint is not identified,
+	  then an artificial endpoint is used in its place when proceeding.
+
+	  The problem is that the ACK request type is an exception to the rule.
+	  The artificial endpoint is not used when processing an ACK. This results
+	  in the possibility of having a NULL endpoint being used further on.
+
+	  The reason ACK is an exception is an attempt not to spam security logs
+	  with unidentified requests. Presumably, you've already logged the
+	  unidentified request on the preceeding INVITE.
+
+	  Up until Asterisk 13.10, retrieving a NULL endpoint in this fashion
+	  didn't cause an issue. A new change in 13.10 added endpoint ACL checking
+	  shortly after endpoint identification. Because we are accessing a NULL
+	  endpoint, this ACL check resulted in a crash.
+
+	  The fix here is to be sure to retrieve the artificial endpoint for all
+	  request types. ACKs still do not generate unidentified request security
+	  events.
+
+	  ASTERISK-26264 #close
+	  Reported by nappsoft
+
+	  AST-2016-006
+
+	  Change-Id: Ie0c795ae2d72273decb972dd74b6a1489fb6b703
+
+2016-09-06 11:46 +0000 [23d6ec7417]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_messaging.c: Misc cleanups and fixes.
+
+	  * Eliminated RAII_VAR in get_outbound_endpoint().
+
+	  * Simplify update_to() coding.  However, this function can only be a NoOp
+	  because the To string can only be a URI and not a name-address formatted
+	  string.
+
+	  * Simplify update_from() coding.  Also fixed a code path modifying the
+	  from string when the caller could still want to use the original string.
+
+	  * Fixed msg_data_create() incompletely removing the "pjsip:" to then add
+	  back the "sip:" string if needed.  The code didn't handle the "pjsip:sip:"
+	  case because it left the colon after pjsip in the string.
+
+	  Change-Id: I68a09a665f6d4daa9eaa59069045ab69122e28db
+
+2016-09-07 16:00 +0000 [5f19657710]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip: Allow global headers to be overridden.
+
+	  Currently when you add global headers from the dialplan both
+	  the header in the dialplan and the globally configured header
+	  are added to the resulting SIP INVITE. This change makes it
+	  so the headers in the dialplan take precedence and are the
+	  only ones added.
+
+	  Change-Id: I36f864298f38db3632ad503edc11267cb8ffb3ad
+
+2016-08-11 12:10 +0000 [206d4f57dc]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* followme: initialize all config items on reload
+
+	  Some configuration directives were not initialized on reload, and hence
+	  were not reset to default if they were removed from followme.conf.
+
+	  ASTERISK-26288 #close
+
+	  Change-Id: Ief829e16374ad1e0ecfd63e6ee4923b5a1d1c150
+
+2016-08-01 20:55 +0000 [117a7741c8]  gtjoseph <gjoseph@digium.com>
+
+	* build: Add download capability for external packages
+
+	  The DPMA and g729a, silk, siren7 and siren14 codecs hosted at
+	  http://downloads.digium.com/pub/telephony/ are now listed in the
+	  "External" sections of the "Resource Modules" and "Codec Translators"
+	  pages in menuselect.  Any that are selected will automatically be
+	  downloaded and installed when "make install" is run.  Their LICENSE and
+	  README (if avaialble) files will be installed to
+	  ASTVARLIBDIR/documentation/thirdparty/<product_name>.
+
+	  Example use with codecs:
+
+	  The codecs/codecs.xml file is a menuselect style xml file that lists
+	  the codecs to be included.  Their support levels are 'external', which
+	  triggers the download and install, and defaultenabled is no.  Also
+	  because codec_g729a is actually in a directory named codec_g729 on the
+	  download server, the newly added 'member_data' element is used to
+	  override the default of the directory name being the package name.  You
+	  can use the 'directory_name' attribute to keep default base URL
+	  (http://downloads.digium.com/pub/telephony/) but use the new directory,
+	  or you use the 'remote_url' attribute to specify a full URL to the
+	  download directory.  In this case, you must still follow the same
+	  subdirectory naming conventions as that used for the packages located
+	  at 'http://downloads.digium.com/pub/telephony'.
+
+	  A new configure option '--with-externals-cache' was added and like
+	  '--with-sounds-cache' it allows the installer to cache tarballs so
+	  they're not downloaded every time.
+
+	  To assist with the download and install process, each external package
+	  now has a manifest.xml file that, among other things, contains a package
+	  version and checksums for each file in the tarball.  The manifest is
+	  saved to both the cache directory and ASTMODDIR and together with the
+	  manifest.xml on the downloads site, tells the install scripts whether
+	  a download and/or update is needed.
+
+	  bash and xmlstarlet are required for downloader operation.  If they're
+	  not installed, the external items in menuselect will be unavailable.
+
+	  Change-Id: Id3dcf1289ffd3cb0bbd7dfab3cafbb87be60323a
+
+2016-09-06 02:41 +0000 [d04ae7d1d8]  Walter Doekes <walter+github@wjd.nu>
+
+	* chan_sip: Don't refuse calls with "optional crypto"; fall back to RTP.
+
+	  Certain SNOM phones send so-called "optional crypto" in their SDP body.
+	  Regular SRTP setup looks like this:
+
+	      m=audio 64620 RTP/SAVP 8 0 9 99 3 18 4 101
+	      a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:...
+
+	  SNOM-style "optional crypto" looks like this:
+
+	      m=audio 61438 RTP/AVP 8 0 9 99 3 18 4 101
+	      a=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:...
+
+	  A crypto line is supplied, but the m-line does not have SAVP.
+
+	  When res_srtp.so is *not* loaded, then chan_sip.so treats the optional
+	  crypto as regular RTP, but when res_srtp.so *is* loaded, it refuses the
+	  incoming call with the following message:
+
+	      WARNING: process_sdp: Failed to receive SDP offer/answer with
+	      required SRTP crypto attributes for audio
+
+	  For platforms that want to start providing SRTP this presents a
+	  compatibility problem.
+
+	  This changeset lets chan_sip handle the SDP as if no crypto-line was
+	  supplied: i.e. accept the call as regular RTP, just like it did before
+	  res_srtp was loaded.
+
+	  Now you'll get this informative warning instead:
+
+	      WARNING: Ignoring crypto attribute in SDP because RTP transport is
+	      insecure
+
+	  ASTERISK-23989 #close
+	  Reported by: Olle Johansson
+
+	  Change-Id: I91a15ae05a0296e398d6b65f53bb11afde1d80e2
+
+2016-09-03 16:04 +0000 [df3d0188e4]  Matt Jordan <mjordan@digium.com>
+
+	* apps/app_dial: Fix crash on non-connect call paths for Privacy/Screening option
+
+	  In any scenario in which the callee is not connected to the caller, the
+	  current code in app_dial will crash due to raising a Dial End Stasis
+	  Message after the callee channel has been hung up. This patch corrects
+	  the error by simply moving the explicit hangup of the callee (peer)
+	  channel until after the dial end message.
+
+	  ASTERISK-25691 #close
+
+	  Change-Id: I816a414014424d0d8c80e2a3cbef13ef8c63798d
+
+2016-09-03 16:02 +0000 [a64063cc97]  Matt Jordan <mjordan@digium.com>
+
+	* apps/app_dial: Set the DIALSTATUS to NOANSWER on privacy option 5
+
+	  If the callee selects option '5' using the Dial application's privacy
+	  (P) option, the DIALSTATUS is erroneously set to ANSWER. This option
+	  reflects the callee sending the caller to VoiceMail one time; the call
+	  is definitely *not* ANSWERed in such a scenario. With this patch, the
+	  DIALSTATUS is instead set to NOANSWER, which is the same DIALSTATUS that
+	  is set when the 'send to VoiceMail every time' option is set.
+
+	  ASTERISK-25691
+
+	  Change-Id: Iaf0c9f0fa00545e7366443875e2bb7d9a89a1358
+
+2016-08-30 16:40 +0000 [03fc438f6e]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_registrar.c: Reduce stack usage in find_aor_name().
+
+	  Change-Id: I8aebad1fdcf303bd115b59a4b57fbbd5b2267f09
+
+2016-08-29 18:06 +0000 [b5e753227d]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_configuration.c: Ignore repeated identify by methods.
+
+	  Change-Id: Ied0c06043d1dfef8fdc9c9a808cf89b118119838
+
+2016-08-30 17:26 +0000 [9b7501b6ad]  Richard Mudgett <rmudgett@digium.com>
+
+	* config_global.c: Comments and a default expression adjustment.
+
+	  Change-Id: Ia6a58f8c73a30da6874b3f94364dce162d6f1ad3
+
+2016-08-31 15:14 +0000 [3314e1cec2]  Richard Mudgett <rmudgett@digium.com>
+
+	* sip_to_pjsip.py: Map canreinvite as directmedia alias.
+
+	  Change-Id: I48b8e150f96a3d2a24d8fc25fbe4f5aff9f4a6b2
+
+2016-08-31 15:37 +0000 [6372f40ba0]  Richard Mudgett <rmudgett@digium.com>
+
+	* sip_to_pjsip.py: Fix typo converting outboundproxy registration.
+
+	  Change-Id: I6f30e5f9fcf8469ba0079fbf884047d54c2c0b15
+
+2016-08-31 15:13 +0000 [11eb1afd2d]  Richard Mudgett <rmudgett@digium.com>
+
+	* sip_to_pjsip.py: Fix comment typo and tabs.
+
+	  Change-Id: If35174614545727817d329c60ba4456c028941b5
+
+2016-08-31 15:56 +0000 [0f9b144c1a]  Richard Mudgett <rmudgett@digium.com>
+
+	* Sample configs: Eliminate false multiline comment block starts.
+
+	  Change-Id: Ie627def9604ae30abd80754f9e6f09874825aec6
+
+2016-09-02 11:36 +0000 [8d1c535bd6]  Richard Mudgett <rmudgett@digium.com>
+
+	* format_cap.c: Fix CLI "core show channeltype Surrogate" crash.
+
+	  * Make ast_format_cap_get_names() NULL tolerant.
+
+	  ASTERISK-26331 #close
+	  Reported by: CGI.NET
+
+	  Change-Id: Id67e93936dc8ec2a33a9d33655843d43b59285a3
+
+2016-08-18 14:45 +0000 [9bca895469]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_session: segfault on already disconnected session
+
+	  On heavy loaded system the TCP/TLS incoming calls could be
+	  disconnected by pjproject while these calls are being
+	  processed by asterisk which could use the session's memory pools.
+	  If the session in the disconnected state then the session memory
+	  pools were already freed, so we get segfault.
+
+	  This patch adds a lifetime control on an INVITE session to pjproject.
+	  The lifetime of the session is manipulated by calling
+	  pjsip_inv_add_ref/pjsip_inv_dec_ref.
+	  This patch uses these functions to inform pjproject that the
+	  session is in use.
+
+	  This patch adds check if the session state is not disconnected
+	  and also checks if the memory pool is not NULL.
+
+	  This patch also places tasks 'session_end' and 'session_end_completion'
+	  into session's serializer to avoid race condition.
+
+	  ASTERISK-26291 #close
+
+	  Change-Id: I4d28b1fb3b91f0492a911d110049d670fdc3c8d7
+
+2016-08-10 15:14 +0000 [63feffa126]  Mark Michelson <mmichelson@digium.com>
+
+	* ConfBridge: Make some announcements asynchronous.
+
+	  Confbridge announcements tend to block a channel while they are being
+	  played. In some circumstances, this is warranted since you want that
+	  particular channel not to hear the announcement (Example: "John Doe has
+	  entered the conference"). For others it makes less sense.
+
+	  This change first introduces methods for playing sounds asynchronously
+	  into the conference. This is very similar to how synchronous sounds are
+	  played, except the channel initiating the playback does not wait for the
+	  sound to complete before moving on.
+
+	  Asynchronous announcements are used for two circumstances:
+	  * Sounds played for a user after they have left the bridge
+	  * Sounds that play first to a single user and then the rest of the
+	    conference (if the channel and conference use the same language)
+
+	  ASTERISK-26289 #close
+	  Reported by Mark Michelson
+
+	  Change-Id: Ie486bb3de1646d50894489030326a423e594ab0a
+
+2016-08-31 12:23 +0000 [a002a4d2db]  Michael Kuron <m.kuron@gmx.de>
+
+	* app_mp3: Use correct buffer size and the same sample rate as the channel
+
+	  Previously, the buffer used for MP3 streamed from HTTP servers had a size of
+	  1 MB. For 8 kHz mono audio at 16 bit resolution, such a buffer covers about 1
+	  minute. Only when the buffer is full does audio start to play.
+	  For MP3 files streamed from a server, that is usually not a big deal as long as
+	  the connection to the server is fast enough to supply that much data within a
+	  second or two. For MP3 live streams however, it takes 1 minute to download 1
+	  minute of audio, so without this change, app_mp3 wasn't really usable for MP3
+	  live streams.
+	  This commit changes the buffer size so that it covers 6 seconds of an MP3 file
+	  streamed from a server and 0.5 seconds of an MP3 live stream. The latter is
+	  identified by the use of a .m3u file extension.
+
+	  app_mp3 so far only supported 8 kHz audio.
+	  Now it always runs at the sample rate of the channel.
+
+	  ASTERISK-26085 #close
+
+	  Change-Id: Id1ee274733cd804a0edecf7450329b72f1235af0
+
+2016-08-26 10:39 +0000 [308a65fe6c]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: qualify/unqualify added/deleted realtime endpoints
+
+	  If the PJSIP endpoint's AOR with the permanent contact
+	  was deleted from the realtime storage the res_pjsip module
+	  continues trying to qualify this contact.
+	  The error 'Unable to find an endpoint to qualify contact'
+	  appeares every 'qualify_frequency' seconds.
+	  This patch deletes this contact in this case.
+
+	  The PJSIP endpoint's AOR with the permanent contact
+	  is never qualified if it is added to realtime storage
+	  after asterisk started.
+	  This patch adds qualifying for the AOR's permanent contacts
+	  on the first handling of this AOR.
+
+	  ASTERISK-26319 #close
+
+	  Change-Id: Ib93dded9121edb113076903d1aa95402f799f8fe
+
+2016-08-17 02:51 +0000 [2fa168348e]  chris de rock <chris@derock.de>
+
+	* app_macro: Consider '~~s~~' as a macro start extension.
+
+	  As described in issue ASTERISK-26282 the AEL parser creates macros with
+	  extension '~~s~~'.  app_macro searches only for extension 's' so the
+	  created extension cannot be found.  with this patch app_macro searches for
+	  both extensions and performs the right extension.
+
+	  ASTERISK-26282 #close
+
+	  Change-Id: I939aa2a694148cc1054dd75ec0c47c47f47c90fb
+
+2016-08-29 07:10 +0000 [27951792c4]  Etienne Lessard <elessard@proformatique.com>
+
+	* pbx.c: Prevent infinite recursion in manager_show_dialplan_helper.
+
+	  Previously, if context A was including context B and context B was including
+	  context A, i.e. if there was a circular dependency between contexts, then
+	  calling manager_show_dialplan_helper could lead to an infinite recursion,
+	  resulting in a crash.
+
+	  This commit applies the same solution as the one implemented in the
+	  show_dialplan_helper function. The manager_show_dialplan_helper and
+	  show_dialplan_helper functions contain lots of code in common, but the former
+	  was missing the "infinite recursion avoidance" code.
+
+	  ASTERISK-26226 #close
+
+	  Change-Id: I1aea85133c21787226f4f8442253a93000aa0897
+
+2016-08-26 14:34 +0000 [fb82fdb013]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Disable srtp use by pjmedia
+
+	  The reason for the disable is that while Asterisk works fine with older
+	  libsrtp versions, newer versions of pjproject won't compile with them.
+	  Debian 6 for instance, has libsrtp 1.4.4 which is older than what
+	  pjproject is expecting.
+
+	  We don't use most of pjmedia but we DO use it for SDP negotiation.
+	  Luckily disabling srtp in pjmedia doesn't interfere with it's ability
+	  to negitiate a secure channel.  The proper crypto attributes are
+	  negotiated in both directions.
+
+	  ASTERISK-26279 #close
+
+	  Change-Id: Id25a92cdf3df97a26c53cffae65b6b82de33c8e2
+
+2016-08-26 08:41 +0000 [847bd47ff0]  Alexander Traud <pabstraud@compuserve.com>
+
+	* channel: No hung-up on failing security requirements.
+
+	  In your Diaplan, if you specify
+	   same => n,Set(CHANNEL(secure_bridge_media)=1)
+	   same => n,Set(CHANNEL(secure_bridge_signaling)=1)
+	  only the SIP channel driver chan_sip supports this. All other channels drivers
+	  like res_pjsip fail. In case of failure, the original sRTP source code released
+	  the whole channel, even if not hung-up, yet. This change does not release the
+	  channel but instead hangs-up the channel.
+
+	  ASTERISK-26306
+
+	  Change-Id: I0489f0cb660fab6673b0db8af027d116e70a66db
+
+2016-08-20 09:04 +0000 [b59d3b48d0]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Migrate IPv4/IPv6 (Dual Stack) configurations.
+
+	  When using the migration script sip_to_pjsip.py, and your sip.conf is
+	  configured with bindaddr=::, two transports are written to pjsip.conf, one for
+	  0.0.0.0 (IPv4) and one for [::] (IPv6). That way, PJProject listens on the IPv4
+	  and IPv6 wildcards; a IPv4/IPv6 Dual Stack configuration on a single interface
+	  like in chan_sip.
+
+	  Furthermore, the script internal functions "build_host" and "split_hostport"
+	  did not parse Literal IPv6 addresses as expected (like [::1]:5060). This change
+	  makes sure, even such addresses are parsed correctly.
+
+	  ASTERISK-26309
+
+	  Change-Id: Ia4799a0f80fc30c0550fc373efc207c3330aeb48
+
+2016-08-25 07:06 +0000 [f69f5cd3c4]  Joshua Colp <jcolp@digium.com>
+
+	* app_queue: Ensure member is removed from pending when hanging up.
+
+	  When dialing channels it is possible that they may not ever
+	  leave the not in use state (Local channels in particular) by
+	  the time we cancel them. If this occurs but we know they were
+	  dialed we explicitly remove them from the pending members
+	  container so that subsequent call attempts occur.
+
+	  ASTERISK-26299 #close
+
+	  Change-Id: I6ad0d17c36480c92cebf840626228ce3f7e4bd65
+
+2016-08-04 20:11 +0000 [5cd583d7a2]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Cache global config options.
+
+	  We may check a global config option hundreds of times a second or more.
+	  Asking sorcery for the global configuration from the config files backend
+	  involves several allocations and container traversals.  Using realtime
+	  without a memory cache is a lot worse because you have to lookup in the
+	  realtime database each time to reconstitute the sorcery object.  With a
+	  memory cache for realtime, there is about the same amount of overhead as
+	  for config files.  Either way, it is still fairly expensive to access the
+	  sorcery object that much.
+
+	  * Cache the global config options so we can access them faster.  You must
+	  now always perform a res_pjsip reload to change the global options.
+
+	  Change-Id: Ice16c7a4cbca4614da344aaea21a072b86263ef7
+
+2016-08-23 11:02 +0000 [8b4b2500ee]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_fax: Fix deadlock in ast_channel_get_t38_state().
+
+	  ast_channel_get_t38_state() calls ast_channel_queryoption() with
+	  AST_OPTION_T38_STATE.  If the passed in channel is a local channel then a
+	  deadlock can happen if a channel lock is held when called.
+
+	  * Made ast_channel_get_t38_state() callers not hold a channel lock before
+	  calling.
+
+	  * Update ast_channel_get_t38_state() doxygen to note that no channel locks
+	  can be held when calling the function.
+
+	  ASTERISK-26203 #close
+	  Reported by: Etienne Lessard
+
+	  ASTERISK-24822 #close
+	  Reported by: David Brillert
+
+	  ASTERISK-22732 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I49fd76fa9af628b4198009b5c0b82c8b03681214
+
+2016-08-23 10:39 +0000 [e8d4f40022]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_fax: Fix deadlock setting FAXMODE channel variable.
+
+	  ASTERISK-25980 added the FAXMODE channel variable to res_fax.c.
+	  Unfortunately, it also introduced a deadlock potential because
+	  set_channel_variables() which sets FAXMODE can be called during a
+	  masquerade.  The ast_channel_get_t38_state() which gets the value used to
+	  set FAXMODE cannot be called with the channel locked.  As a result, local
+	  channels can deadlock because of how they must acquire the locks necessary
+	  to operate.
+
+	  The intent of FAXMODE is for dialplan to know how a fax was transferred
+	  after the fax completes.  However, the previous patch sets FAXMODE to the
+	  channel's current T.38 state AFTER the fax has completed and where T.38
+	  may have already disconnected.
+
+	  * Set FAXMODE based upon T.38 negotiations exchanged either with the fax
+	  applications or the fax framehooks.
+
+	  ASTERISK-26203
+	  Reported by: Etienne Lessard
+
+	  ASTERISK-24822
+	  Reported by: David Brillert
+
+	  ASTERISK-22732
+	  Reported by: Richard Mudgett
+
+	  Change-Id: Id525747254b64c1efe8b1b5973d52ff9719c2ae1
+
+2016-08-22 12:31 +0000 [35cf6c7702]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_fax.c: Fix deadlock in fax_gateway_indicate_t38().
+
+	  fax_gateway_indicate_t38() calls ast_indicate_data() which cannot be
+	  called with any channel locks already held.  A deadlock can happen if the
+	  function is operating on a local channel.
+
+	  * Made fax_gateway_indicate_t38() unlock the channel before calling
+	  ast_indicate_data() since fax_gateway_indicate_t38() is always called with
+	  the channel locked.
+
+	  * Made fax_gateway_indicate_t38() return void since nothing cared about
+	  its return value.
+
+	  ASTERISK-26203
+	  Reported by: Etienne Lessard
+
+	  ASTERISK-24822
+	  Reported by: David Brillert
+
+	  ASTERISK-22732
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I701ff2d26c5fc23e0d5a48a3fd98759a9fd09407
+
+2016-08-23 11:16 +0000 [50b2aa506f]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_fax.c: Add chan locked precondition comments.
+
+	  Change-Id: Ic10ae434536bbf7fb7055d6ab36cc50b8748a4e7
+
+2016-08-23 10:42 +0000 [038cbc0215]  Richard Mudgett <rmudgett@digium.com>
+
+	* ast_framehook_detach() must be called with the channel locked.
+
+	  The framehook container could become corrupted if the channel lock is not
+	  held before calling.
+
+	  Change-Id: If0a1c7ba0484ed3a191106a7516526b905952584
+
+2016-08-22 15:01 +0000 [88e9d05ef7]  Richard Mudgett <rmudgett@digium.com>
+
+	* ast_framehook_attach() must be called with the channel locked.
+
+	  The framehook container could become corrupted if the channel lock is not
+	  held before calling.
+
+	  Change-Id: I1a6b957a1f7b899eb29a186915f8cccab886a438
+
+2016-08-24 14:42 +0000 [c9e83f6d0b]  gtjoseph <gjoseph@digium.com>
+
+	* res_rtp_multicast:  Fix SEGV in ast_multicast_rtp_create_options
+
+	  ast_multicast_rtp_create_options now checks for NULL or empty options
+
+	  Change-Id: Ib845eae46a67a9787e89a87ebd1027344e5e0362
+
+2016-08-19 18:19 +0000 [cb8fd610e2]  Corey Farrell <git@cfware.com>
+
+	* Fix checks for allocation debugging.
+
+	  MALLOC_DEBUG should not be used to check if debugging is actually
+	  enabled, __AST_DEBUG_MALLOC should be used instead.  MALLOC_DEBUG only
+	  indicates that debugging is requested, __AST_DEBUG_MALLOC indicates it
+	  is active.
+
+	  Change-Id: I3ce9cdb6ec91b74ee1302941328462231be1ea53
+
+2016-08-10 15:14 +0000 [b8b5d52b5e]  Mark Michelson <mmichelson@digium.com>
+
+	* ConfBridge: Rework announcer channel methodology
+
+	  NOTE: This patch was submitted earlier and reverted because of a failing
+	  test. The test has been patched so that it adjusts for the changes here,
+	  so this is being resubmitted for review.
+
+	  One feature that confbridge has is the ability to play sounds to all
+	  participants in the conference. Prior to this commit, the algorithm for
+	  this was as follows:
+
+	  * Grab the playback lock
+	  * Push the conference announcer channel into the bridge
+	  * Play back the sound
+	  * Pull the conference announcer channel from the bridge
+	  * Release the playback lock
+
+	  The issue here is that the act of adding the playback channel to the
+	  bridge and removing it for each announcement is expensive. Amongst the
+	  expenses:
+
+	  * The announcer channel is imparted into the bridge, meaning a new
+	    thread is spun up for each playback.
+	  * When the announcer is added or removed from the bridge, it results
+	    in the BRIDGEPEER channel variable being set on all channels in the
+	    bridge. This requires keeping the bridge locked and locking each
+	    individual channel in order to set it.
+	  * There's also just the general overhead of adding the channel and
+	    removing it from the bridge. The bridge potentially has to reconfigure
+	    every single time
+
+	  With this commit, the paradigm for playing back announcements has
+	  shifted.
+
+	  * The announcer channel is now added to the bridge when the conference
+	    is allocated, and it is hung up when the conference is destroyed.
+	  * A taskprocessor is used to queue playbacks onto the announcer channel.
+	    This keeps the behavior from before where playbacks do not overlap.
+	  * The announcer channel is no longer placed into the bridge as
+	    departable. Since we are not constantly removing the channel from
+	    the bridge, it is safe to add the channel using an independent thread
+	    and simply hang the channel up when it is time for the conference to
+	    be destroyed.
+
+	  The use of the taskprocessor for playbacks opens up the interesting
+	  possibility of having asynchronous announcements played. In this commit,
+	  however, the behavior is still exactly the same as it previously was.
+
+	  ASTERISK-26289
+	  Reported by Mark Michelson
+
+	  Change-Id: Ica9fa4907c2f3728cdd1cf0bc564ef4eb40754a0
+
+2016-08-23 05:54 +0000 [d5d7cbfcfb]  Joshua Colp <jcolp@digium.com>
+
+	* Revert "ConfBridge: Rework announcer channel methodology"
+
+	  This reverts commit 0cdeb2bfb0f4203384c08858951af3c77be8b9b3.
+
+	  Change-Id: I18ba73b6d4dc0b994f4ffb01ae0b6cfad36ac636
+
+2016-08-22 17:08 +0000 [c16ef02318]  Mark Michelson <mmichelson@digium.com>
+
+	* res_pjsip: Default endpoints to the "offline" status.
+
+	  A recent change attempted to optimize startup by not updating contact
+	  status. Instead, code responsible for qualifying contacts updates the
+	  status as it becomes known. The code even accounts for contacts/AORs
+	  that are not set to be qualified.
+
+	  The problem, though, is when there are no contacts associated with an
+	  endpoint. A common case is when an endpoint is set to register its
+	  contacts but has not done so yet. In this case, prior to registration,
+	  the endpoint's device state will appear to be "not in use" and hints
+	  associated with that device will appear to be "idle". In actuality, the
+	  device state and hint should both appear as "unavailable". The reason
+	  for the failure is that the optimization change made all persistent
+	  endpoint states set to "unknown".
+
+	  The fix here is to change the hard-coded "unknown" to be "offline"
+	  instead. The default state will be offline until the qualifying code
+	  determines that the contact is actually online. This way, if there are
+	  no contacts at all, then the state stays as offline, and device state
+	  and hints appear correctly.
+
+	  ASTERISK-26269 #close
+	  Reported by nappsoft
+
+	  Change-Id: Ie99b84169393983453076f5e9c0d35ff313a456a
+
+2016-08-20 14:51 +0000 [e54dcf4fd5]  David M. Lee <dlee@respoke.io>
+
+	* res_odbc_transaction: add dep on generic_odbc
+
+	  When res_odbc_transaction depended on res_odbc, it got the generic_odbc
+	  headers and libs implicitly. Now that it no longer depends on res_odbc,
+	  its dependency on generic_odbc must be explicit.
+
+	  Change-Id: I9db88f7af7388437f49903d3008ba8d4890d5911
+
+2016-08-20 11:18 +0000 [be38c95def]  Alexander Traud <pabstraud@compuserve.com>
+
+	* pjproject_bundled: Allow IPv4/IPv6 (Dual Stack) configurations.
+
+	  PJProject supports a lot of platforms even Windows, some with different defaults
+	  when it comes to IPv6. In many Linux platforms like Ubuntu 16.04 LTS,
+	  "/proc/sys/net/ipv6/bindv6only" is set to 0 (false). Different than in Windows.
+
+	  Because of this, if configured with just an IPv6 address/transport, PJProject
+	  listens to both IPv4 and IPv6. However, this is not supported by the PJProject
+	  team. As consequence, you end-up with IPv4-mapped IPv6 addresses in SDP,
+	  incompatible with IPv4-only clients. Technically, you end-up with an IPv6-only
+	  server which accepts incoming connections on IPv4.
+
+	  If you try to configure two transports, one with IPv4 and one with IPv6 on the
+	  same interface, as expected by the PJProject team, the IPv4 transport is not
+	  able to bind because the IPv6 transport listens to both already.
+
+	  One solution would be to change "/proc/sys/net/ipv6/bindv6only" system-wide.
+	  Then, you are able to configure two transports, one for each IP version on the
+	  same interface. That way, you get a server which works with IPv4 clients and
+	  IPv6 clients at the same time over the same interface.
+
+	  Here, this change sets this parameter directly within PJProject to match the
+	  expectations of the PJProject team in any case. This allows IPv4/IPv6 Dual Stack
+	  servers out of the box like in chan_sip. This change was accepted by the
+	  PJProject team as <http://trac.pjsip.org/repos/changeset/5403> and is expected
+	  to arrive in the next version, PJProject 2.6.0. Until then, this change is
+	  incorporated in the bundled PJProject of Asterisk.
+
+	  ASTERISK-26309
+
+	  Change-Id: I3335d8718f79f4b2feae91b5b005a3ce684a63ae
+
+2016-08-10 15:14 +0000 [0cdeb2bfb0]  Mark Michelson <mmichelson@digium.com>
+
+	* ConfBridge: Rework announcer channel methodology
+
+	  One feature that confbridge has is the ability to play sounds to all
+	  participants in the conference. Prior to this commit, the algorithm for
+	  this was as follows:
+
+	  * Grab the playback lock
+	  * Push the conference announcer channel into the bridge
+	  * Play back the sound
+	  * Pull the conference announcer channel from the bridge
+	  * Release the playback lock
+
+	  The issue here is that the act of adding the playback channel to the
+	  bridge and removing it for each announcement is expensive. Amongst the
+	  expenses:
+
+	  * The announcer channel is imparted into the bridge, meaning a new
+	    thread is spun up for each playback.
+	  * When the announcer is added or removed from the bridge, it results
+	    in the BRIDGEPEER channel variable being set on all channels in the
+	    bridge. This requires keeping the bridge locked and locking each
+	    individual channel in order to set it.
+	  * There's also just the general overhead of adding the channel and
+	    removing it from the bridge. The bridge potentially has to reconfigure
+	    every single time
+
+	  With this commit, the paradigm for playing back announcements has
+	  shifted.
+
+	  * The announcer channel is now added to the bridge when the conference
+	    is allocated, and it is hung up when the conference is destroyed.
+	  * A taskprocessor is used to queue playbacks onto the announcer channel.
+	    This keeps the behavior from before where playbacks do not overlap.
+	  * The announcer channel is no longer placed into the bridge as
+	    departable. Since we are not constantly removing the channel from
+	    the bridge, it is safe to add the channel using an independent thread
+	    and simply hang the channel up when it is time for the conference to
+	    be destroyed.
+
+	  The use of the taskprocessor for playbacks opens up the interesting
+	  possibility of having asynchronous announcements played. In this commit,
+	  however, the behavior is still exactly the same as it previously was.
+
+	  ASTERISK-26289
+	  Reported by Mark Michelson
+
+	  Change-Id: Ic5cd2c4b98a1eaa1715eb7a5b35d62f1a76d78a5
+
+2016-08-19 10:21 +0000 [b494b9f88c]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* compilation failed with -Werror=maybe-uninitialized
+
+	  The compilation failed for devmode
+	  --enable DONT_OPTIMIZE
+	  --enable BETTER_BACKTRACES
+	  --enable DO_CRASH
+	  --enable TEST_FRAMEWORK
+
+	  res_pjsip/pjsip_configuration.c: In function dtls_handler:
+	  res_pjsip/pjsip_configuration.c:974:20: error:
+	  back may be used uninitialized in this function [-Werror=maybe-uninitialized]
+	  int size = strlen(front);
+	             ^
+	  cc1: all warnings being treated as errors
+
+	  Change-Id: I7f082ead0312792a577ec7c73015ba64dabca580
+
+2016-08-19 03:59 +0000 [a628009eb9]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Add cert_file.
+
+	  When using the migration script sip_to_pjsip.py, cert_file was not migrated to
+	  pjsip.conf. A previous change regarding this contained a copy/paste error.
+
+	  ASTERISK-22374
+
+	  Change-Id: I0fa72e9412117d53b4284fc6b83fa5b2b95ba03b
+
+2016-08-18 09:21 +0000 [b1fe070d0b]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip.conf: tlsclientmethod is using sslv23 as default.
+
+	  When 'tlsclientmethod' is not specified in sip.conf, chan_sip uses the OpenSSL
+	  SSLv23_method. This was documented incorrectly in the file sip.conf.sample.
+
+	  SSLv23_method got its name in the 90s. Today, with OpenSSL 1.0.2, this method
+	  enables (just) the secure TLSv1.0 and TLSv1.2. Or stated differently, that
+	  function should have been called 'secure_method' or 'automatic_method' back in
+	  the 90s.
+
+	  Consequently please, specify 'tlsclientmethod=tlsv1' in your sip.conf only if
+	  you face a server which has problems like not falling back to TLSv1.0
+	  automatically.
+
+	  ASTERISK-24425
+
+	  Change-Id: I502ce6146b4504cadfd3973af8d6ec3994f54fa3
+
+2016-08-18 17:16 +0000 [ff2378c735]  Kevin Harwell <kharwell@digium.com>
+
+	* rest-api: Swagger scripts were not replacing format variable in file brief
+
+	  Given resource paths did not have 'json' substituted in for the '{format}'. For
+	  some auto generated documentation/comment strings it resulted in something like
+	  the following:
+
+	  "... REST handler for /api-docs/sounds.{format}"
+
+	  This patch makes sure the resource api's path is properly substituted.
+
+	  ASTERISK-25472 #close
+
+	  Change-Id: Ie3e950a35db4043e284019d6c9061f3b03922e23
+
+2016-08-16 15:57 +0000 [43f400ef95]  Jason Parker (license 4993)
+
+	* res_format_attr_g729: Add annexb=no format parameter to SDPs
+
+	  Historically, Asterisk has always specified annexb=no for the g729 format.
+	  However, when using res_pjsip no format attribute was specified. This patch
+	  makes it so the SDP now contains a format attribute line with annexb=no.
+
+	  Note, that this means only g729a is negotiated. Even for pass through support.
+	  According to rfc7261 the type of annex used (a or b) is dependent upon the
+	  answerer. However, Asterisk being a back to back user agent makes this tricky
+	  to support at this time, thus we only allow annex 'a' for now.
+
+	  ASTERISK-26228 #close
+	  patches:
+	    res_format_attr_g729.c submitted by Jason Parker (license 4993)
+
+	  Change-Id: I76bc20cc0a01af01536e9915afef319c269c22d0
+
+2016-08-18 15:15 +0000 [4c1ae07d51]  gtjoseph <gjoseph@digium.com>
+
+	* res_odbc:  Correct the dependency relationship with res_odbc_transaction
+
+	  The MODULEINFO dependencies between these 2 modules was reversed.
+	  res_odbc should depend on res_odbc_transaction, not the other way
+	  around.
+
+	  ASTERISK-25984 #close
+
+	  Change-Id: Ifcfbb49c0b51cf6640a5446d47cd6c48caf1331f
+
+2016-08-18 12:04 +0000 [cab6975b02]  Kevin Harwell <kharwell@digium.com>
+
+	* sip_to_pjsip: Set correct tls transport method
+
+	  A recent update had a copy/paste error where the unused variable 'val' was
+	  being passed to the set_value function instead of the 'method' value itself.
+
+	  This patch passes in the right variable.
+
+	  ASTERISK-22374
+
+	  Change-Id: I895b7b3779ce4442bc58b8ec40d59dd29bb43f06
+
+2016-08-18 08:19 +0000 [2381ddde63]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Map the TLS method correctly.
+
+	  When using the migration script sip_to_pjsip.py and tlsclientmethod is not set
+	  in sip.conf, the default value of chan_sip (sslv23) is copied to pjsip.conf, to
+	  overwrite the default of the PJProject (tlsv1). This makes sure, res_pjsip is
+	  offering/using not just TLSv1.0 but TLSv1.2 as well.
+
+	  ASTERISK-22374
+
+	  Change-Id: Ie530a3dae9926ae14f3920a21be1e2edb15bda4f
+
+2016-08-18 08:17 +0000 [6500f5e138]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Add compactheaders, timerb, timert1, and useragent.
+
+	  When using the migration script sip_to_pjsip.py, no section of type=system or
+	  type=general were created. Therefore the keys compactheaders, timerb, timert1,
+	  and useragent were not migrated to pjsip.conf.
+
+	  ASTERISK-22374
+
+	  Change-Id: I318a453843227ea36bf130d392d4abd7bd26b5a1
+
+2016-08-18 08:16 +0000 [21e9c69e56]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Map (session-)timers correctly.
+
+	  When using the migration script sip_to_pjsip.py, session-timers=accept and
+	  session-timers=refuse were mapped to wrong values.
+
+	  ASTERISK-22374
+
+	  Change-Id: Ie4e90d5f6a29aff07837b7fe5bc8aea5fb6fc092
+
+2016-08-18 08:15 +0000 [c9a97398f7]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Write username even without authname.
+
+	  When using the migration script sip_to_pjsip.py, now the (mandatory) username is
+	  written to pjsip.conf, even if there was no (optional) authname in the register
+	  string in sip.conf.
+
+	  ASTERISK-22374
+
+	  Change-Id: Ie53e1997104cd2674821688b8a8247249f5e156f
+
+2016-08-18 08:14 +0000 [60275359bc]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Parse register even with transport.
+
+	  When using the migration script sip_to_pjsip.py and the register string
+	  started with a transport in sip.conf - like tls://... - register was not parsed
+	  correctly and therefore not migrated correctly to pjsip.conf.
+
+	  ASTERISK-22374
+
+	  Change-Id: I44c12104eea2bd8558ada6d25d77edfecd92edd2
+
+2016-08-18 08:13 +0000 [0d479232eb]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Write local_net, contact_acl, contact_deny, and contact_permit.
+
+	  When using the migration script sip_to_pjsip.py, those keys got missing. These
+	  keys might appear several times and the function "merge_value" tried to collect
+	  those. However, because these keys have different names in sip.conf and
+	  pjsip.conf, "merge_value" was not able to find the new key name in sip.conf.
+	  This change lets "merge_value" search with the old key name in sip.conf and
+	  write with the new key name in pjsip.conf.
+
+	  ASTERISK-22374
+
+	  Change-Id: Ie53c5278ae6f1cb8fa7e96c5289877d46981d9d2
+
+2016-08-18 08:11 +0000 [cbc1b2d020]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Map externhost/ip to Transports.
+
+	  When using the migration script sip_to_pjsip.py, the externhost or externip of
+	  sip.conf were erroneously written to Endpoints instead to Transports.
+
+	  ASTERISK-22374
+
+	  Change-Id: I2c5873386cfc388899fa9cf2368639dd12f1b8e4
+
+2016-08-18 08:04 +0000 [5f33e99534]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Add defaultexpiry, maxexpiry, and minexpiry.
+
+	  When using the migration script sip_to_pjsip.py, defaultexpiry, maxexpiry, and
+	  minexpiry were not migrated to pjsip.conf.
+
+	  ASTERISK-22374
+
+	  Change-Id: I007fbf543dcadc96fc3ed71c54da502bcb209b7b
+
+2016-08-18 08:03 +0000 [231ea0350d]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Write media_encryption.
+
+	  When using the migration script sip_to_pjsip.py, encryption=yes got missing and
+	  media_encryption=sdes was not written to pjsip.conf, because of a typo.
+
+	  ASTERISK-22374
+
+	  Change-Id: I0fc3e55dc512a57603ae0fef41baacccf2a35c05
+
+2016-08-18 08:02 +0000 [23eb065121]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Write cos and tos.
+
+	  When using the migration script sip_to_pjsip.py, both tos_sip and cos_sip got
+	  missed, because of a typo. Therefore, cos and tos were not written to
+	  pjsip.conf. Furthermore, that revealed a misuse of an internal function, caused
+	  by a copy-and-paste error.
+
+	  ASTERISK-22374
+
+	  Change-Id: Id245ebadf70ab9776eb280c026288540af3af5c2
+
+2016-08-18 07:55 +0000 [0b675a208b]  Alexander Traud <pabstraud@compuserve.com>
+
+	* sip_to_pjsip: Add cert_file and ca_list_path.
+
+	  When using the migration script sip_to_pjsip.py, cert_file and ca_list_path were
+	  not migrated to pjsip.conf.
+
+	  ASTERISK-22374
+
+	  Change-Id: I4612877d190b7f86a48698cefbf5c4db6c265825
+
+2016-08-17 14:13 +0000 [1cd12d73a6]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Fix unbound srv failover tests.
+
+	  Commit 1b666549f33d69dc080b212bf92126f3bc3a18b2 broke the srv failover
+	  functionality if a TCP connection gets disconnected.  Under these
+	  conditions, session_inv_on_state_changed() gets a
+	  PJSIP_EVENT_TRANSPORT_ERROR and restarts the INVITE transaction on a new
+	  transport.  Unfortunately, session_inv_on_tsx_state_changed() also gets
+	  the same PJSIP_EVENT_TRANSPORT_ERROR event and unconditionally terminates
+	  the session.
+
+	  * Made session_inv_on_tsx_state_changed() complete terminating the session
+	  on PJSIP_EVENT_TRANSPORT_ERROR only if the session state is still
+	  PJSIP_INV_STATE_DISCONNECTED.
+
+	  ASTERISK-26305 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: If736e766b5c55b970fa38ca6c8a885caf27b897d
+
+2016-08-16 15:36 +0000 [329507fe20]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip:  Add contact_user to endpoint
+
+	  contact_user, when specified on an endpoint, will override the user
+	  portion of the Contact header on outgoing requests.
+
+	  Change-Id: Icd4ebfda2f2e44d3ac749d0b4066630e988407d4
+
+2016-08-17 08:10 +0000 [6f448f32fe]  Torrey Searle <torrey@voxbone.com>
+
+	* res_ari: Add http prefix to generated docs
+
+	  updated the uri handler to include the url prefix of the http server
+	  this enables res_ari to add it to the uris when generating docs
+
+	  Change-Id: I279335a2625261a8492206c37219698f42591c2e
+
+2016-08-17 06:12 +0000 [56e0aed177]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Detect ca_list_path capabilities in external PJProject.
+
+	  Since Asterisk 13.8, pj_ssl_cert_load_from_files2 got detected only in the
+	  bundled PJProject but not in an external PJProject. Therefore, ca_list_path
+	  could not be used in pjsip.conf. With this change, pj_ssl_cert_load_from_files2
+	  is detected again to enable ca_list_path again.
+
+	  ASTERISK-26303 #close
+
+	  Change-Id: I4a4a0cdc5cdff33730911fb4cfc0498c069043d0
+
+2016-08-16 12:24 +0000 [2edcfcf1eb]  gtjoseph <gjoseph@digium.com>
+
+	* ari:  Add documentation that path parameters are case-sensitive
+
+	  Added to api.wiki.mustache so that the generated object pages
+	  have the notation in the table header as well as under each method
+	  that has path parameters.
+
+	  ASTERISK-25492 #close
+
+	  Change-Id: I36c46c6dc0c9ac350470394a999a1b19ef3fcdaf
+
+2016-08-15 15:29 +0000 [f4e28b3a09]  Corey Farrell <git@cfware.com>
+
+	* Refactor usage pattern of xmldoc info tag.
+
+	  This updates func_channel.c and main/message.c to use a generic xpointer
+	  include instead of including info from each channel driver.  Now the
+	  name attribute of info is CHANNEL or CHANNEL_EXAMPLES to be included in
+	  documentation for func_channel.  Setting the name attribute of info to
+	  MessageToInfo or MessageFromInfo causes it to be included in the
+	  MessageSend application and AMI action.
+
+	  Change-Id: I89fd8276a3250824241a618009714267d3a8d1ea
+
+2016-08-04 20:00 +0000 [a8d9a53bae]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_sorcery_config.c: Cleanup ao2 container usage idioms.
+
+	  Change-Id: Iad24b335fb121a2bc7f1d048ab7420569edcba5a
+
+2016-08-04 15:57 +0000 [74a91b9ee5]  Richard Mudgett <rmudgett@digium.com>
+
+	* sorcery.c: Minor optimizations.
+
+	  * Remove some unused parameters from internal functions:
+	  sorcery_wizard_create()
+	  sorcery_wizard_update()
+	  sorcery_wizard_delete()
+
+	  * Created the struct sorcery_observer_invocation ao2 object without a lock
+	  since it is not needed in sorcery_observer_invocation_alloc().
+
+	  * Cleanup generic ao2 container sorcery object id hash, sort, and cmp
+	  functions.
+
+	  Change-Id: Iff71d75f52bc1b8cee955456838c149faaa4f92e
+
+2016-08-01 11:04 +0000 [29beb2890c]  Richard Mudgett <rmudgett@digium.com>
+
+	* sorcery.c: Tweak some container declaration formatting.
+
+	  * Tweak sorcery_object_type_alloc() formatting.
+	  * Tweak ast_sorcery_init() formatting.
+
+	  Change-Id: Ib02430023f15268cd7a2ea53f2c331213e4d3944
+
+2016-08-11 23:30 +0000 [9b822293bd]  Corey Farrell <git@cfware.com>
+
+	* pbx.c: Additional fixes to ast_context_remove_extension_callerid2.
+
+	  Do not check registrar of the first extension head.  We should only check
+	  the registrar when we match the priority.
+
+	  Additionally fix a couple calls to strcmp which used the input callerid
+	  instead of the clean version ex.cidmatch.
+
+	  ASTERISK-26233
+
+	  Change-Id: I17ea6881a18f40840ae9c1f5394aab1fbb3769f1
+
+2016-08-10 14:41 +0000 [403c794684]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* core: Entity ID is not set or invalid
+
+	  The Exchanging Device and Mailbox States could not working
+	  if the Entity ID (EID) is not set manually and can't be obtained
+	  from ethernet interface.
+
+	  This patch replaces debug message to warning
+	  and addes missing description about option 'entityid' to
+	  asterisk.conf.sample.
+
+	  With this patch the asterisk also:
+	  (1) decline loading the modules which won't work without EID:
+	      res_corosync and res_pjsip_publish_asterisk.
+	  (2) warn if EID is empty on loading next modules:
+	      pbx_dundi, res_xmpp
+
+	  Starting with v197 systemd/udev will automatically assign "predictable"
+	  names for all local Ethernet interfaces.
+	  This patch also addes some new ethernet prefixes "eno" and "ens".
+
+	  ASTERISK-26164 #close
+
+	  Change-Id: I72d712f1ad5b6f64571bb179c5cb12461e7c58c6
+
+2016-06-15 17:10 +0000 [93332cb1d0]  Evgeniy Tsybra <cjack@yandex.ru>
+
+	* chan_sip: Fix lastrtprx always updated
+
+	  Packets are read regulary, when there is no data in buffer fr->frametype
+	  is AST_FRAME_NULL. There was no check of frametype and lastrtprx always 
+	  updated and, therefore, rtptimeout did not work at all.
+
+	  ASTERISK-25270 #close
+
+	  Change-Id: If3b5ca0dbb822582a86eb7d01dcae4e83448c41d
+
+2016-08-15 07:17 +0000 [2735ec899a]  Joshua Colp <jcolp@digium.com>
+
+	* manager: Clarify that dialplan manipulation actions are under system class.
+
+	  ASTERISK-26246 #close
+
+	  Change-Id: Id673b9786389f9d2a87f638ce1a25161f5f31657
+
+2016-08-13 22:02 +0000 [f59bd47ed3]  Matt Jordan <mjordan@digium.com>
+
+	* app_dial: Improve documentation
+
+	  * Add some helpful <literal> and other embedded paragraph tags
+
+	  * Document some of the lesser known channel variables set by Dial
+
+	  * Add examples for some common Dial uses, along with some more
+	    challenging but useful options
+
+	  Change-Id: Ib2fb9301e8e044d14fbb2815ec64161f19bbfbc1
+
+2016-08-13 20:16 +0000 [4facaac408]  Matt Jordan <mjordan@digium.com>
+
+	* manager: Add <see-also> tags to relate interrelated events/actions together
+
+	  Change-Id: Idbac539205aa732bf786c4f765577d8e9ff28ba4
+
+2016-08-13 20:15 +0000 [232d4fe24f]  Matt Jordan <mjordan@digium.com>
+
+	* manager: Add <see-also> tags to relate Bridge related events,actions, and apps
+
+	  Change-Id: I67e6b79fa3102e494b5fe6cc7510472249080e85
+
+2016-08-13 20:14 +0000 [63c0b2f7c9]  Matt Jordan <mjordan@digium.com>
+
+	* manager: Add <see-also> tags to relate AoC events and actions
+
+	  Change-Id: Iea89a36222712148c1775c05ed0ad1049d67a70e
+
+2016-08-13 20:13 +0000 [0422667d6c]  Matt Jordan <mjordan@digium.com>
+
+	* manager: Add <see-also> tags to relate UserEvent actions/apps/events
+
+	  Change-Id: I80f8a981f62f50e74609c69c49edcaca6c95efa4
+
+2016-08-12 15:53 +0000 [f9e734974b]  Matt Jordan <mjordan@digium.com>
+
+	* res_agi: Improve documentation
+
+	  * Groups of AGI commands that have similar functionality now reference
+	    each other, and all reference the AGI application for ease of wiki
+	    reference.
+
+	  * The documentation for the AGI application has been improved, in
+	    particular noting the various AGI types and how they are invoked.
+
+	  * A warning message has been added to DeadAGI, noting that it is
+	    deprecated.
+
+	  Change-Id: I479ccdee8a7393f01b18692c3d4ab7e6bdd1875d
+
+2016-08-12 13:53 +0000 [781bb410d0]  Matt Jordan <mjordan@digium.com>
+
+	* manager: Add <see-also> links between related events
+
+	  This patch adds some see-also references between related AMI events. It
+	  focuses primarily on those events that are guaranteed to come in pairs,
+	  such as DTMFBegin/DTMFEnd, as well as those that occur during the life
+	  cycle of an Asterisk channel, such as Newchannel/Hangup.
+
+	  Change-Id: Iaab600477052018d0f8c03d0c624c0856e9ff1f3
+
+2016-08-12 11:15 +0000 [cfd6852d39]  Matt Jordan <mjordan@digium.com>
+
+	* func_channel: Reorganize documentation
+
+	  * Following the example of the PJSIP channel driver, the channel
+	    technology specific documentation has been moved to the respective
+	    channel drivers that provide that functionality. This has the benefit
+	    of locating the documentation of items with those modules that provide
+	    it.
+
+	  * Examples of using the CHANNEL function for both standard items as well
+	    as for PJSIP have been added.
+
+	  * The 'max_forwards' standard item has been documented.
+
+	  Change-Id: Ifaa79a232c8ac99cf8da6ef6cc7815d398b1b79b
+
+2016-08-11 22:11 +0000 [cb043249b6]  Corey Farrell <git@cfware.com>
+
+	* Run mandatory cleanup when startup fails.
+
+	  Errors during startup result in an exit.  These error branches should be
+	  calling ast_run_atexit(0) to ensure mandatory cleanup is run.
+
+	  ASTERISK-26267 #close
+
+	  Change-Id: If226f2326ae2df7add20040696132214cf2bb680
+
+2016-08-11 11:24 +0000 [4d5e96ab53]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_caller_id:  Copy header name to short header name
+
+	  When compact_headers was set, we were sending a zero-length header name
+	  for PAI and RPID because we always forced the short header name length
+	  to 0.  We did this because we cloned the header from "From" and wanted
+	  to clear "f" from the sname.  By cloning however, we bypass pjproject's
+	  automatic logic that sets sname to name if there's no compact form of
+	  the header, which there isn't for PAI and RPID.  So now we force sname
+	  to be the same as name right after we set name.
+
+	  res_pjsip_diversion needed the same treatment for the Diversion header.
+
+	  ASTERISK-26241 #close
+
+	  Change-Id: I633ec139630cd83809aae00336cee4a10077e467
+
+2016-08-11 12:18 +0000 [143df33110]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip:  Fail global load if debug or default_from_user are empty
+
+	  If debug was specified in the global configuration but left blank,
+	  the logger would treat it as a wildcard and log all hosts.  If
+	  default_from_user was empty, a crash would result.
+
+	  The global apply handler now checks for empty strings.
+
+	  ASTERISK-26239 #close
+	  ASTERISK-26238 #close
+
+	  Change-Id: Ie75727f5cd5808845d92cc81f5713842fb203336
+
+2016-08-01 15:07 +0000 [1fc5c90014]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip res_pjsip_mwi: Misc fixes and cleanups.
+
+	  * Eliminated RAII_VAR() usage in
+	  ast_sip_persistent_endpoint_update_state().
+
+	  * Added a missing allocation failure check to
+	  persistent_endpoint_find_or_create().
+
+	  * Made persistent_endpoint_find_or_create() create the new object without
+	  a lock as it isn't needed.
+
+	  * Cleaned up some ao2 container allocation idioms.
+
+	  * Reordered res_pjsip_mwi.c load_module() and unload_module()
+
+	  Change-Id: If8ce88fbd82a0c72a37a2388f74f77237a6a36a8
+
+2016-08-04 18:03 +0000 [73052e5732]  Richard Mudgett <rmudgett@digium.com>
+
+	* location.c: Misc fixes and cleanups.
+
+	  * Eliminated most RAII_VAR() usage.
+
+	  * Added several missing allocation failure checks.
+
+	  * Made ast_sip_for_each_contact() allocate the wrapper ao2 object without
+	  a lock as it is not needed.
+
+	  Change-Id: Ie20913365156c95dd79e5d471cfd25e99ae880bc
+
+2016-08-02 13:53 +0000 [9d4bd3d763]  Richard Mudgett <rmudgett@digium.com>
+
+	* taskprocessor.c: Tweak high water checks.
+
+	  * The high water check in ast_taskprocessor_alert_set_levels() would
+	  trigger immediately if the new high water level is zero and the queue was
+	  empty.
+
+	  * The high water check in taskprocessor_push() was off by one.
+
+	  Change-Id: I687729fb4efa6a0ba38ec9c1c133c4d407bc3d5d
+
+2016-08-03 16:24 +0000 [e1248c3075]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Make aor named lock a mutex.
+
+	  The named aor lock was always being locked for writes so a rwlock adds no
+	  benefit and may be slower because rwlocks are biased toward read locking.
+
+	  Change-Id: I8c5c2c780eb30ce5441832257beeb3506fd12b28
+
+2016-07-29 17:41 +0000 [6e40334d89]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Add missing allocation failure check.
+
+	  Change-Id: I932ab2cea845e534d9ff318035b6de39972d3b28
+
+2016-08-11 11:13 +0000 [a3c5488ff4]  Matt Jordan <mjordan@digium.com>
+
+	* app_queue: Prevent crash when a call is forwarded to an invalid location
+
+	  When a call forward attempt is made from a Queue member, the current
+	  code will hang up the forwarding channel in an off-nominal condition
+	  prior to raising the Stasis events informing the rest of Asterisk that
+	  the call was forwarded. This will result in a slew of dreaded FRACKs,
+	  most likely leading to a crash.
+
+	  This patch modifies the code such that we don't hang up the forwarding
+	  channel even in an off-nominal condition until we've safely raised the
+	  Stasis messages.
+
+	  ASTERISK-25797 #close
+
+	  Change-Id: Ife5abed351691fd79105321636eaa8ea8dcdba38
+
+2016-08-11 10:50 +0000 [5913929d31]  Kevin Harwell <kharwell@digium.com>
+
+	* alembic: add auth_username to endpoint's identify_by enum
+
+	  A new identify_by option was added recently, auth_username. However, this
+	  setting was not added as an allowable choice in the database enumeration
+	  value.
+
+	  This patch updates the current enumeration, adding in the new setting.
+
+	  ASTERISK-26268 #close
+
+	  Change-Id: Ib4788e8485e4cd40172ec0abbf5810a147ab8bf8
+
+2016-08-06 10:57 +0000 [1589452fdc]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* pjsip: Fix deadlock with suspend taskprocessor on masquerade
+
+	  If both channels which should be masqueraded
+	  are in the same serializer:
+	  1st channel will be locked waiting condition 'complete'
+	  2nd channel will be locked waiting condition 'suspended'
+
+	  On heavy load system a chance that both channels will be in
+	  the same serializer 'pjsip/distibutor' is very high.
+
+	  To reproduce compile res_pjsip/pjsip_distributor.c with
+	  DISTRIBUTOR_POOL_SIZE=1
+
+	  Steps to reproduce:
+	  1. Party A calls Party B (bridged call 'AB')
+	  2. Party B places Party A on hold
+	  3. Party B calls Voicemail app (non-bridged call 'BV')
+	  4. Party B attended transfers Party A to voicemail using REFER.
+	  5. When asterisk masquerades calls 'AB' and 'BV',
+	     a deadlock is happened.
+
+	  This patch adds a suspension indicator to the taskprocessor.
+	  When a session suspends/unsuspends the serializer
+	  it sets the indicator to the appropriate state.
+	  The session checks the suspension indicator before
+	  suspend the serializer.
+
+	  ASTERISK-26145 #close
+
+	  Change-Id: Iaaebee60013a58c942ba47b1b4930a63e686663b
+
+2016-08-09 12:07 +0000 [f6ec94cca6]  Kevin Harwell <kharwell@digium.com>
+
+	* alembic/sqlalchemy: auto increment only allowed on a single column
+
+	  The extensions table defined two columns (id and priority) as primary key
+	  autoincrement columns. However only one is allowed when defining the primary
+	  key.
+
+	  This patch removes the autoincrement attribute from the priority column since
+	  it does not need to be as such and really should not have been on there in the
+	  first place.
+
+	  This patch also removes 'context', 'exten', and 'priority' from the primary key
+	  index and creates a new combined unique contraint index on them.
+
+	  ASTERISK-26183 #close
+
+	  Change-Id: Ib9c712c612a4d7ec1edb0dcb77f1bae0905a470b
+
+2016-08-07 09:58 +0000 [5f815f9dba]  Matt Jordan <mjordan@digium.com>
+
+	* channels/chan_pjsip: Add PJSIP_SEND_SESSION_REFRESH
+
+	  This patch adds a new PJSIP specific dialplan function,
+	  PJSIP_SEND_SESSION_REFRESH. When invoked on a PJSIP channel, the media
+	  session will be refreshed via either an UPDATE or re-INVITE request.
+	  When used in conjunction with the PJSIP_MEDIA_OFFER dialplan function,
+	  the formats in use on a PJSIP channel can be re-negotiated and changed
+	  dynamically after call setup.
+
+	  ASTERISK-26277 #close
+
+	  Change-Id: Ib98fe09ba889aafe26d58d32f0fd1323f8fd9b1b
+
+2016-08-09 16:19 +0000 [a119bab6a6]  Mark Michelson <mmichelson@digium.com>
+
+	* res_rtp_asterisk: Cache local RTCP address.
+
+	  When an RTCP packet is sent or received, res_rtp_asterisk generates a
+	  Stasis event that contains the RTCP report as well as the local and
+	  remote addresses that the report pertains to.
+
+	  The addresses are determined using ast_find_ourip(). For the local
+	  address, this will typically result in a lookup of the hostname of the
+	  server, and then a DNS lookup of that hostname. If you do not have the
+	  host in /etc/hosts, then this results in a full DNS lookup, which can
+	  potentially block for some time.
+
+	  This is especially problematic when performing RTCP reads, since those
+	  are done on the same thread responsible for reading and writing media.
+
+	  This patch addresses the issue by performing a lookup of the local
+	  address when RTCP is allocated. We then use this cached local address
+	  for the Stasis events when necessary.
+
+	  ASTERISK-26280 #close
+	  Reported by Mark Michelson
+
+	  Change-Id: I3dd61882c2e57036f09f0c390cf38f7c87e9b556
+
+2016-08-08 12:53 +0000 [a06a1af0eb]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_mwi: fix unsolicited mwi blocks PJSIP stack
+
+	  The PJSIP taskprocessors could be overflowed on startup
+	  if there are many (thousands) realtime endpoints
+	  configured with unsolicited mwi.
+	  The PJSIP stack could be totally unresponsive for a few minutes
+	  after boot completed.
+
+	  This patch creates a separate PJSIP serializers pool for mwi
+	  and makes unsolicited mwi use serializers from this pool.
+	  This patch also adds 2 new global options to tune taskprocessor
+	  alert levels: 'mwi_tps_queue_high' and 'mwi_tps_queue_low'.
+
+	  This patch also adds new global option 'mwi_disable_initial_unsolicited'
+	  to disable sending unsolicited mwi to all endpoints on startup.
+	  If disabled then unsolicited mwi will start processing
+	  on next endpoint's contact update.
+
+	  ASTERISK-26230 #close
+
+	  Change-Id: I4c8ecb82c249eb887930980a800c9f87f28f861a
+
+2016-08-04 10:16 +0000 [485fd27f7c]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_outbound_publish: Use a serializer shutdown group for unload.
+
+	  This change replaces the custom unload process for the outbound
+	  publish module with the common serializer shutdown group.
+
+	  ASTERISK-25217 #close
+
+	  Change-Id: I280a0384d860c486202d87d2d674394cca77ffb6
+
+2016-08-03 15:39 +0000 [805f105f88]  Corey Farrell <git@cfware.com>
+
+	* Add missing checks during startup.
+
+	  This ensures startup is canceled due to allocation failures from the
+	  following initializations.
+	  * channel.c: ast_channels_init
+	  * config_options.c: aco_init
+
+	  ASTERISK-26265 #close
+
+	  Change-Id: I911ed08fa2a3be35de55903e0225957bcdbe9611
+
+2016-07-22 16:37 +0000 [ea71bd6e3e]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* app_voicemail: Add taskprocessor alert level options.
+
+	  On heavy loaded system with IMAP or DB storage,
+	  'app_voicemail' taskprocessor queue could reach 500 scheduled tasks.
+	  It could happen when the IMAP or DB server dies or is unreachable.
+	  It could happen on startup when there are many (thousands)
+	  realtime endpoints configured with unsolicited mwi.
+	  If the taskprocessor queue reaches the high water level
+	  then the alert is triggered and pjsip stops processing new requests
+	  until the queue reaches the low water level to clear the alert.
+
+	  This patch adds 2 new 'general' configuration options
+	  to tune taskprocessor alert levels:
+	  'tps_queue_high' - Taskprocessor high water alert trigger level.
+	  'tps_queue_low' - Taskprocessor low water clear alert level
+
+	  ASTERISK-26229 #close
+
+	  Change-Id: I766294fbffedf64053c0d9ac0bedd3109f043ee8
+
+2016-08-03 09:47 +0000 [9dc8cfabd5]  Joshua Colp <jcolp@digium.com>
+
+	* astconfigparser: Really handle case where line is simply a comment.
+
+	  The regular expression would match causing the code that handled
+	  the line if it was merely a comment to never get executed.
+
+	  Change-Id: I3e4022481037ebcba9905587fe8c764b4ce21819
+
+2016-07-23 08:51 +0000 [ad3e65433c]  gtjoseph <gjoseph@digium.com>
+
+	* asterisk.c:  Add auto generation and persistence of UUID
+
+	  Upcoming features will require the generation and persistence
+	  of a UUID.
+
+	  Change-Id: I3ec0062427e133217db6ef496a4216f427c3b92d
+
+2016-08-02 12:55 +0000 [efc4034d72]  Kevin Harwell <kharwell@digium.com>
+
+	* rest-api: Code out of sync with the model
+
+	  Change-Id: Idccaa26fd4a423d47d013ee592b8fa6a0349c006
+
+2016-07-29 13:13 +0000 [f6821fbaec]  Mark Michelson <mmichelson@digium.com>
+
+	* Remove SILK payload mappings from Asterisk core.
+
+	  SILK is a bit of a hog when it comes to using up our limited number of
+	  dynamic payload types in the RTP engine. By freeing up four slots, it
+	  allows for other codecs to potentially take the place.
+
+	  Now, codec_silk.so will dynamically use the payload slots in the RTP
+	  engine when it loads.
+
+	  A better fix would be make RTP dynamic payload types actually
+	  dynamic. However, at this stage of Asterisk 14 development, this is a
+	  risky move that would be imprudent.
+
+	  Change-Id: I5774e09408f9a203db189529eabdc0d3f4c1e612
+	  (cherry picked from commit d50895c7b04036aeaad58990089399e46db4c817)
+
+2016-08-01 11:08 +0000 [102d28c11a]  Joshua Colp <jcolp@digium.com>
+
+	* sorcery: Use more compatible regex for local expressions.
+
+	  This changes the use of an empty regex for both res_sorcery_config
+	  and res_sorcery_memory to "." instead. This is a more compatible
+	  regular expression which also works on FreeBSD.
+
+	  ASTERISK-26206 #close
+
+	  Change-Id: Ia9166dd176f1597555ba22b6931180d0626c1388
+
+2016-08-02 03:08 +0000 [b78d10a2df]  Alexander Traud <pabstraud@compuserve.com>
+
+	* res_pjsip: SIP/SDP origin (o=) contained square brackets on IP6 transports.
+
+	  ASTERISK-26256 #close
+
+	  Change-Id: I3fd68df561f81fdb8c6c497d465b50c12422f058
+
+2016-08-01 16:13 +0000 [1f95c011c7]  gtjoseph <gjoseph@digium.com>
+
+	* menuselect:  Add an opaque "member_data" string to the acceptable xml
+
+	  Change-Id: Id5ac43b95c8d7395f3be37f983632169db3d1afe
+
+2016-07-27 09:56 +0000 [df42f64d62]  David M. Lee <dlee@respoke.io>
+
+	* Replace strdupa with more portable ast_strdupa
+
+	  The strdupa function is a GNU extension, and not widely portable. We
+	  have an ast_strdupa function used within Asterisk which is preferred.
+	  I pulled the definition up from menuselect.c into the menuselect.h
+	  header file so it can be shared across menuselect.
+
+	  Change-Id: I9593c97f78386b47dc1e83201e80cb2f62b36c2e
+
+2016-07-24 18:27 +0000 [56a07fbab9]  gtjoseph <gjoseph@digium.com>
+
+	* menuselect:  Various menuselect enhancements
+
+	  * Add 'external' as a support level.
+	  * Add ability for module directories to add entries to the menu
+	    by adding members to the <module_prefix>/<module_prefix>.xml file.
+	  * Expand the description field to 3 lines in the ncurses implementation.
+	  * Allow the description field to wrap in the newt implementation.
+	  * Add description field to the gtk implementation.
+
+	  Change-Id: I7f9600a1984a42ce0696db574c1051bc9ad7c808
+	  (cherry picked from commit 90f445729d5d86050d9d379485ff0a99f4a006c1)
+
+2016-07-29 04:48 +0000 [7f9369c1b6]  Joshua Colp <jcolp@digium.com>
+
+	* astconfigparser: Handle case where line is simply a comment.
+
+	  Change-Id: I2dea5815363f4d787d709228a04f33baee383ef5
+
+2016-07-28 14:10 +0000 [57e9c66819]  Corey Farrell <git@cfware.com>
+
+	* pbx.c: Fix handling of '-' in extension name and callerid
+
+	  This adds a two strings to ast_exten.  name to go with exten and
+	  cidmatch_display to go with cidmatch.  The new fields contain input used
+	  to add the extension in the first place.  The existing fields now
+	  contain stripped input that excludes insignificant spaces and dashes.
+	  These stripped fields should always be used for comparisons.  The
+	  unstripped fields should normally be used for display, but displaying
+	  stripped values will not cause runtime errors.
+
+	  Note the actual string is only stored twice if it contains dashes.  If
+	  no dashes are found then both 'char *' fields point to the same memory.
+	  So this change has a minimum effect on memory usage.
+
+	  The existing functions ast_get_extension_name and
+	  ast_get_extension_cidmatch return unstripped values as they did before
+	  this change.  Other similar bugs likely still exist where unstripped
+	  extensions are saved outside pbx.c then passed back in.
+
+	  ASTERISK-26233 #close
+
+	  Change-Id: I6cd61ce57acc1570ca6cc14960c4c3b0a9eb837f
+
+2016-07-27 17:17 +0000 [873fc0fda5]  Richard Mudgett <rmudgett@digium.com>
+
+	* pbx.c: Allow dangerous functions when adding a hint to dialplan.
+
+	  We can allow dangerous functions when adding a hint since altering
+	  dialplan is itself a privileged activity.  Otherwise, we could never
+	  execute dangerous functions.
+
+	  ASTERISK-25996 #close
+	  Reported by: Andrew Nagy
+
+	  Change-Id: I4929ff100ad1200a0198262d069a34f2296e77ba
+
+2016-07-21 10:36 +0000 [f00525a6f6]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* pjproject: fixed a few bugs
+
+	  This patch fixes the issue in pjsip_tx_data_dec_ref()
+	  when tx_data_destroy can be called more than once,
+	  and checks if invalid value (e.g. NULL) is passed to.
+
+	  This patch updates array limit checks and docs
+	  in pjsip_evsub_register_pkg() and pjsip_endpt_add_capability().
+
+	  Change-Id: I4c7a132b9664afaecbd6bf5ea4c951e43e273e40
+
+2016-07-17 18:28 +0000 [972cee2e4c]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Update for pjproject 2.5.5
+
+	  Add more --disable-* switches to Makefile.rules including
+	  --disable-opus which was causing bundled pjproject to fail with
+	  "undefined reference" errors in libasteriskpj.
+
+	  Changed PJ_ENABLE_EXTRA_CHECK to 1.
+
+	  Removed 2 obsolete patches and added a new one.
+	  The new one was merged by Teluu on 6/27/2016.
+
+	  ASTERISK-26148 #close
+
+	  Change-Id: Ib8af6c6a9d31f7238ce65b336134c2efdc855063
+
+2016-07-27 10:33 +0000 [8902a51d59]  David M. Lee <dlee@respoke.io>
+
+	* Portably sscanf tv_usec
+
+	  In a timeval, tv_usec is defined as a suseconds_t, which could be
+	  different underlying types on different platforms. Instead of trying to
+	  scanf directly into the timeval, scanf into a long int, then copy that
+	  into the timeval.
+
+	  Change-Id: I29f22d049d3f7746b6c0cc23fbf4293bdaa5eb95
+
+2016-07-27 12:36 +0000 [852e763571]  Kevin Harwell <kharwell@digium.com>
+
+	* rtp_engine: Failed assertion and wrong name given for codec
+
+	  Fixed an assert check that would trigger when the passed in value was negative.
+	  The negative value was being cast to an unsigned value. This resulted in the
+	  check failing.
+
+	  Also fixed another problem when loading formats in the engine. When setting the
+	  mime type the format's name was being passed in instead of the codec's name.
+
+	  Change-Id: I1a201cd419ba4d8e9a40d337e36b6fbe1737192c
+
+2016-07-21 22:44 +0000 [e8c34680ca]  Richard Mudgett <rmudgett@digium.com>
+
+	* dsp.c: Add fax and DTMF detection unit tests.
+
+	  * Add fax amplitude and frequency sweep tests.
+	  * Add DTMF amplitude and twist unit tests.
+
+	  Change-Id: I8d77c9a1eec89e440d715f998c928687e870c3f7
+
+2016-07-21 11:56 +0000 [c1f240b818]  Richard Mudgett <rmudgett@digium.com>
+
+	* dsp.c: Added descriptive comments to Goertzel calculations.
+
+	  * Added doxygen to describe some struct members and what is going on in
+	  the code.
+
+	  Change-Id: I2ec706a33b52aee42b16dcc356c2bd916a45190d
+
+2016-07-13 13:48 +0000 [003a52fd62]  Richard Mudgett <rmudgett@digium.com>
+
+	* dsp.c: Fix incorrect format reference typo.
+
+	  Change-Id: Ia131da3ec29acf385cb43a586a29ecc975eb3896
+
+2016-07-25 21:18 +0000 [4c0a0cbe02]  Richard Mudgett <rmudgett@digium.com>
+
+	* dsp.c: Correct DTMF twist dsp.conf documentation.
+
+	  Change-Id: Idf97e3a72f1edc5fca58f2fa7b20785922be0cae
+
+2016-07-22 04:43 +0000 [87433c2566]  Joshua Colp <jcolp@digium.com>
+
+	* astconfigparser.py: Update with realtime fixes.
+
+	  When configuring SIP URIs in the pjsip.conf file it is
+	  necessary to escape the semicolon so the parser does not
+	  treat it as a comment. This change allows this to work in
+	  the astconfigparser implementation.
+
+	  A secondary bug where some data was lost if a configuration
+	  option included a "=" in its value was also fixed.
+
+	  A bug where sections would be considered equal despite
+	  being different has also been fixed.
+
+	  Change-Id: If229f656ef22050b50e7b34e90c4bffe796431f8
+
+2016-07-28 14:32 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.11.0-rc1 Released.
+
+2016-07-28 09:29 +0000 [3bfaf6b172]  Mark Michelson <mmichelson@digium.com>
+
+	* Release summaries: Add summaries for 13.11.0-rc1
+
+2016-07-28 09:27 +0000 [ca145e1807]  Mark Michelson <mmichelson@digium.com>
+
+	* .version: Update for 13.11.0-rc1
+
+2016-07-28 09:27 +0000 [918ebf79ff]  Mark Michelson <mmichelson@digium.com>
+
+	* .lastclean: Update for 13.11.0-rc1
+
+2016-07-28 09:27 +0000 [d7afc1cf9d]  Mark Michelson <mmichelson@digium.com>
+
+	* realtime: Add database scripts for 13.11.0-rc1
+
+2016-07-21 22:28 +0000 [159e437e5a]  Richard Mudgett <rmudgett@digium.com>
+
+	* dsp.c: Fix erroneous fax tone detection.
+
+	  The Goertzel calculations get less accurate the lower the signal level
+	  being worked with becomes because there is less resolution remaining.
+	  If it is too low we can erroneously detect a tone where none really
+	  exists.  The searched for fax frequencies not only need to be so much
+	  stronger than the background noise they must also be a minimum strength.
+
+	  * Add needed minimum threshold test to tone_detect().
+
+	  * Set TONE_THRESHOLD to allow low volume frequency spread detection.
+
+	  ASTERISK-26237 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I84dbba7f7628fa13720add6a88eae3b129e066fc
+
+2016-07-22 14:44 +0000 [eda95236d1]  Mark Michelson <mmichelson@digium.com>
+
+	* Fix sqlalchemy error regarding identifier length.
+
+	  sqlalchemy was complaining:
+
+	  sqlalchemy.exc.IdentifierError: Identifier
+	  'ps_contacts_qualifyfreq_exptime' exceeds maximum length of 30
+	  characters
+
+	  This fixes the problem by changing the index name to be
+	  "ps_contacts_qualifyfreq_exp" instead.
+
+	  ASTERISK-26227 #close
+	  Reported by Mark Michelson
+
+	  Change-Id: I0ed784f87504be2a59ee8d3242ef6f625d5ed1a9
+
+2016-07-22 05:46 +0000 [66c9dfb272]  Alexander Traud <pabstraud@compuserve.com>
+
+	* chan_sip: Enable Session-Timers for SIP over TCP (and TLS).
+
+	  Asterisk defaults to timers=accept/refresher=uas. In that scenario, only in that
+	  scenario, Sessions-Timers (RFC 4028) had no effect via TCP. This change enables
+	  Session-Timers for SIP over TCP (and for SIP over TLS).
+
+	  However with longer international calls via TCP, the SIP channel might break,
+	  because all hops on the Internet route must stay online (have not a single power
+	  outage, for example). Therefore with Session-Timers enabled (which are enabled
+	  at default), you might see dropped calls. Consequently even with this change,
+	  you might be better-off going for session-timers=refuse in your sip.conf.
+
+	  ASTERISK-19968 #close
+
+	  Change-Id: I1cd33453c77c56c8e1394cd60a6f17bb61c1d957
+
+2016-07-15 16:16 +0000 [33716106e0]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Whitespace and comment cleanup.
+
+	  Change-Id: I11139a4a95df34e223ba622aa6227e33ab8f6c38
+
+2016-07-21 09:05 +0000 [52ab0bf258]  gtjoseph <gjoseph@digium.com>
+
+	* chan_sip: Prevent deadlock when issuing "sip show channels"
+
+	  sip_show_channels locks the dialogs container first then locks each
+	  sip_pvt so it can spit out the details.  The rest of sip dialog
+	  processing locks the sip_pvt first then locks the dialogs container
+	  if it needs to.  Both lock in the order they need but deadlocks can
+	  result.  To fix, sip_show_channels and sip_show_channelstats have
+	  been converted to use an iterator rather than ao2_callback.  This way
+	  the container is locked only while getting the next entry and is
+	  unlocked when the callback is called.
+
+	  ASTERISK-23013 #close
+
+	  Change-Id: Id9980419909e811f89484950ed46ef117b9eb990
+
+2016-07-19 15:22 +0000 [5997ec7c9e]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_pubsub: fixed a bug when pjsip_tx_data_dec_ref is called twice.
+
+	  This patch removed call of pjsip_tx_data_dec_ref in send_notify
+	  if send_request failed.
+	  The pjsip_dlg_send_request deletes the message on error by itself.
+
+	  It seems this patch fixes next issues:
+	  ASTERISK-26199
+	  ASTERISK-26166
+	  ASTERISK-26174
+
+	  Change-Id: I8b05917c93d993f95d604c042ace5f1a5500f59a
+
+2016-07-18 22:46 +0000 [7fdf7c3d4c]  Corey Farrell <git@cfware.com>
+
+	* Add conditional support for noreturn functions.
+
+	  This adds support for tagging functions with the noreturn attribute.
+	  If DO_CRASH is enabled then ast_do_crash never returns.  If AST_DEVMODE
+	  and DO_CRASH are enabled then failed assertions never return.  This can
+	  resolve a large number of false positives with static analyzers.
+
+	  ASTERISK-26220 #close
+
+	  Change-Id: Icfb61e5fe54574eced4c3e88b317244f467ec753
+
+2016-07-19 13:18 +0000 [dcb8aa8c1c]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_dahdi.c: Fix deadlock potential in fax redirection.
+
+	  The dahdi_handle_dtmf() and my_handle_dtmf() have the potential to
+	  deadlock if an incoming fax happens during the Playback or similar
+	  application.
+
+	  * Fixed the potential deadlock by not calling ast_async_goto() with the
+	  channel lock held.
+
+	  ASTERISK-26216 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I9144b84ade5f96690996624ec8a2d40c56af40aa
+
+2016-07-13 18:49 +0000 [fa91cf3eec]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_sip.c: Fix deadlock potential in fax redirection.
+
+	  The sip_read() has the potential to deadlock if an incoming fax happens
+	  during the Playback or similar application.
+
+	  * Fixed the potential deadlock by not calling ast_async_goto() with the
+	  channel lock held.
+
+	  * Made always eat the fax detection frame whether there is a fax extension
+	  or not.
+
+	  ASTERISK-26216
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I6d3f5cccd4b77c3aa6ffc1a54c0f6bde61c9278e
+
+2016-07-13 18:48 +0000 [2e1bdc3775]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_pjsip.c: Fix deadlock potential in fax redirection.
+
+	  The chan_pjsip_cng_tone_detected() has the potential to deadlock if an
+	  incoming fax happens during the Playback or similar application.
+
+	  * Fixed the potential deadlock by not calling ast_async_goto() with the
+	  channel lock held.
+
+	  * Made always eat the fax detection frame whether there is a fax extension
+	  or not.
+
+	  ASTERISK-26216
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I32aecbb4818af646dc5a619f0dc040e9b1f222e5
+
+2016-07-12 17:33 +0000 [628e8c91d5]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_fax.c: Fix deadlock potential in FAXOPT(faxdetect) framehook.
+
+	  The fax_detect_framehook() has the potential to deadlock if an incoming
+	  fax happens during the Playback or similar application.
+
+	  * Fixed the potential deadlock by not calling ast_async_goto() with the
+	  channel lock held.
+
+	  * Made always eat the fax detection frame whether there is a fax extension
+	  or not.
+
+	  * Made only detach the framehook if we detected a fax and not on other
+	  possible frames.
+
+	  ASTERISK-26216
+	  Reported by: Richard Mudgett
+
+	  Change-Id: I99da35c26d1cd802626ffb4c1b4eb5b015581b6d
+
+2016-07-12 17:24 +0000 [676aeede36]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_fax: Fix FAXOPT(faxdetect) timeout option.
+
+	  The fax detection timeout option did not work because basically the wrong
+	  variable was checked in fax_detect_framehook().  As a result, the timer
+	  would timeout immediately and disable fax detection.
+
+	  * Fixed ignoring negative timeout values.  We'd complain and then go right
+	  on using the negative value.
+
+	  * Fixed destroy_faxdetect() in the off-nominal case of an incomplete
+	  object creation.
+
+	  * Added more range checking to FAXOPT(gateway) timeout parameter.
+
+	  ASTERISK-26214 #close
+	  Reported by: Richard Mudgett
+
+	  Change-Id: Idc5e698dfe33572de9840bc68cd9fc043cbad976
+
+2016-07-18 16:16 +0000 [652130feb2]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_dahdi: Add faxdetect_timeout option.
+
+	  The new option allows the channel driver's faxdetect option to timeout on
+	  a call after the specified number of seconds into a call.  The new feature
+	  is disabled if the timeout is set to zero.  The option is disabled by
+	  default.
+
+	  * Don't clear dsp_features after passing them to the dsp code in
+	  my_pri_ss7_open_media().  We should still remember them especially for the
+	  new faxdetect_timeout option.
+
+	  ASTERISK-26214
+	  Reported by: Richard Mudgett
+
+	  Change-Id: Ieffd3fe788788d56282844774365546dce8ac810
+
+2016-07-15 20:44 +0000 [851b1c3a17]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Add fax_detect_timeout endpoint option.
+
+	  The new endpoint option allows the PJSIP channel driver's fax_detect
+	  endpoint option to timeout on a call after the specified number of
+	  seconds into a call.  The new feature is disabled if the timeout is set
+	  to zero.  The option is disabled by default.
+
+	  ASTERISK-26214
+	  Reported by: Richard Mudgett
+
+	  Change-Id: Id5a87375fb2c4f9dc1d4b44c78ec8735ba65453d
+
+2016-07-19 04:48 +0000 [021d4892cd]  Alexander Traud <pabstraud@compuserve.com>
+
+	* Makefile: Retain XML Declaration and DTD in docs.
+
+	  Since Asterisk 12, the documentation got an XML Stylesheet. Because of a typo,
+	  the XML Declaration and DTD were overwritten by this.
+
+	  ASTERISK-26212 #close
+
+	  Change-Id: If5ee4625068042e98ab3fcb22a25e2f15d0c68bd
+
+2016-07-18 18:39 +0000 [c8e41d14a1]  Corey Farrell <git@cfware.com>
+
+	* Unit tests: Use AST_TEST_DEFINE in conditional code only.
+
+	  If AST_TEST_DEFINE is not conditional to TEST_FRAMEWORK it produces dead
+	  code.  This places all existing unit tests into a conditional block if
+	  they weren't already.
+
+	  ASTERISK-26211 #close
+
+	  Change-Id: I8ef83ee11cbc991b07b7a37ecb41433e8c734686
+
+2016-07-18 05:13 +0000 [e404f51b42]  Alexander Traud <pabstraud@compuserve.com>
+
+	* res_rtp_asterisk: Count a roll-over of the sequence number even on lost packets.
+
+	  With this change, the initial RTP sequence number is randomly chosen not between
+	  0 and 65535 (0xffff) but 0 and 32767 (0x7fff). This assures, the roll-over
+	  counter (ROC) synchronization is not lost for sRTP, when the very first RTP
+	  packets get lost; see http://srtp.sourceforge.net/faq.html#Q6
+
+	  ASTERISK-26207 #close
+
+	  Change-Id: I9a527e3aa3ce8f3becc5131d7ba32b57b5845464
+
+2016-07-18 04:14 +0000 [5f24874ebb]  Alexander Traud <pabstraud@compuserve.com>
+
+	* Makefile: Suppress echoing of target 'config' again.
+
+	  ASTERISK-26038 #close
+
+	  Change-Id: I5746cf639f3fdc6332e8a97cf01f979e30bf403f
+
+2016-07-14 03:25 +0000 [76d4983c15]  Corey Farrell <git@cfware.com>
+
+	* features.c: Remove unneeded adsi.h include.
+
+	  adsi.h is no longer used by features.c since parking was moved to a
+	  module.
+
+	  Change-Id: I2248b8a455225a17cb6ddaafd6c20c511a1eaf59
+
+2016-07-14 18:06 +0000 [cb58f853e1]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip_mwi: remove unneeded check on endpoint's contacts.
+
+	  The function create_mwi_subscriptions_for_endpoint checks
+	  if there is active contacts by retrieving aors and contacts.
+
+	  This function is used to create all unsolicited mwi subscriptions
+	  on startup and is used when contact added.
+
+	  In both cases it's not necessary to check if there are contacts.
+	  The contacts are needed when asterisk sends mwi.
+
+	  ASTERISK-26200 #close
+
+	  Change-Id: I98e43bdc97f3c0829951cd9bf5f3c6348c6ac1fa
+
+2016-06-30 15:58 +0000 [28501051b4]  Mark Michelson <mmichelson@digium.com>
+
+	* Update support for SILK format.
+
+	  This commit adds scaffolding in order to support the SILK audio format
+	  on calls. Roughly, this is what is added:
+
+	  * Cached silk formats. One for each possible sample rate.
+	  * ast_codec structures for each possible sample rate.
+	  * RTP payload mappings for "SILK".
+
+	  In addition, this change overhauls the res_format_attr_silk file in the
+	  following ways:
+
+	  * The "samplerate" attribute is scrapped. That's native to the format.
+	  * There are far more checks to ensure that attributes have been
+	    allocated before attempting to reference them.
+	  * We do not SDP fmtp lines for attributes set to 0.
+
+	  These changes make way to be able to install a codec_silk module and
+	  have it actually work. It also should allow for passthrough silk calls
+	  in Asterisk.
+
+	  Change-Id: Ieeb39c95a9fecc9246bcfd3c45a6c9b51c59380e
+
+2016-07-14 07:45 +0000 [43b5f8d57b]  Richard Miller (license 5685)
+
+	* app_queue: Only remove queue member from pending when state changes.
+
+	  It is possible for a not in use state change to occur multiple
+	  times causing a queue member to be removed from the pending call
+	  container prematurely.
+
+	  The first not in use state change will remove the queue member
+	  from the container. At this moment the member may be called and
+	  placed in the pending container. After this another not in use
+	  state change can be received which will remove it from the
+	  container. Despite being called at this point the code will
+	  incorrectly see that there are no pending calls to it.
+
+	  This change only removes it from the pending container if the
+	  state has actually changed.
+
+	  ASTERISK-26133 #close
+	  patches:
+	    app_queue.diff submitted by Richard Miller (license 5685)
+
+	  Change-Id: Ie5a7f17a44f98e9159e9b85009ce3f8393aa78c0
+
+2016-07-14 02:40 +0000 [a17b071e36]  Corey Farrell <git@cfware.com>
+
+	* pbx: Fix leak of timezone for time based includes.
+
+	  Create include_free to run ast_destroy_timing and ast_free, use that in
+	  all places that freed an ast_include structure.  This fixes a couple of
+	  paths that previously did not run ast_destroy_timing.
+
+	  ASTERISK-26196 #close
+
+	  Change-Id: I1671bd111bef0dc113e8bf8f77f89fcfc395d838
+
+2016-07-13 17:45 +0000 [8cef8f35e7]  Kevin Harwell <kharwell@digium.com>
+
+	* translate: explicit format destination not properly set
+
+	  If the destination format's name differed from the codec name then the
+	  translator's explict_dst field would be improperly set. In some circumstances
+	  it would end up setting it to a newly created format that has the same name
+	  as the codec when it actually needed to be the given destination codec.
+
+	  This could cause the translation path to use the wrong format. For instance,
+	  if an endpoint had specified 'myulaw' as a format the translator could end up
+	  using a 'ulaw' format (with whatever/default settings) instead. If the format
+	  attribute settings differed between the two then there may unexpected results
+	  during processing.
+
+	  This patch removes the name check when building the translation path. This
+	  should make it always set the translator's explicit_dst to the given destination
+	  format as long as the sample rate and types match.
+
+	  Change-Id: Iaf8a03831d68e657d89569d54b505074efbefab5
+
+2016-07-08 11:46 +0000 [afbd10b0c5]  Richard Mudgett <rmudgett@digium.com>
+
+	* stasis_endpoint.c: Fix contactstatus_to_json().
+
+	  The roundtrip_usec json member is optional.  If it isn't present then
+	  don't put it into the converted json structure where ast_json_pack()
+	  will choke on it.
+
+	  Change-Id: I39bb2f86154ef54591270c58bfda8635070f9ea0
+
+2016-07-13 13:45 +0000 [2be13d62fd]  Corey Farrell <git@cfware.com>
+
+	* chan_sip: Fix reference leak in mwi_event_cb
+
+	  Cleanup the peer reference when stasis_subscription_final_message is
+	  true.  Also free peer_name even if peer exists, after reload a new
+	  peer_name will be allocated.
+
+	  ASTERISK-26193 #close
+
+	  Change-Id: If7ecd52facdc5c227f701c760841e3f6ca53cc69
+
+2016-06-22 07:13 +0000 [332beb27d8]  Eugene Voityuk <eugene@thirdlane.com>,Alexander Traud <pabstraud@compuserve.com>
+
+	* res_rtp_asterisk: Enable Forward Secrecy (PFS) for DTLS.
+
+	  Since July 2014, TLS based protocols (SIP over TLS, Secure WebSockets, HTTPS)
+	  support PFS thanks to ASTERISK-23905. In July 2015, the same feature was added
+	  for DTLS. The source code from main/tcptls.c should have been re-used to ease
+	  security audits. Therefore, this change rolls back the change from July 2015 and
+	  re-uses the code from July 2014. This has the additional benefits to work under
+	  CentOS 7 and enabling not just ECDHE but DHE based cipher suites as well.
+
+	  ASTERISK-25659 #close
+	  Reported by: StefanEng86, urbaniak, pay123
+	  Tested by: sarumjanuch, traud
+	  patches:
+	  res_rtp_asterisk.patch submitted by sarumjanuch
+	  dtls_centos_step_1.patch submitted by traud
+	  dtls_centos_step_2.patch submitted by traud
+
+	  Change-Id: I537cadf4421f092a613146b230f2c0ee1be28d5c
+
+2016-07-13 11:30 +0000 [672a64bda3]  Corey Farrell <git@cfware.com>
+
+	* threadpool: Fix leak in ast_threadpool_serializer_group error path.
+
+	  ast_threadpool_serializer_group leaks a reference to ser when listener
+	  is allocated but tps is not.  Although listener takes the reference to
+	  ser cleanup functions are not run without tps.
+
+	  ASTERISK-26191 #close
+
+	  Change-Id: Ie3ccf69a3f1e676c2ef62a77067c0cb57dc9a585
+
+2016-07-11 10:22 +0000 [fea201f7e6]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_options.c: Fix container operation.
+
+	  aor_observer_deleted() needs to operate on all contacts found for the
+	  deleted AOR instead of only the first one found.  This is really only a
+	  problem if there is more than one contact for the AOR.
+
+	  Change-Id: Id24ac0d5e8c931330231fb45dd2a331a84339dc1
+
+2016-07-11 10:21 +0000 [02877b4b4f]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_configuration.c: Misc cleanups.
+
+	  * Fix some whitespace in various routines.
+
+	  * Rename i to iter in persistent_endpoint_update_state().
+
+	  * Fix off-nominal copy/paste message wording in
+	  persistent_endpoint_contact_deleted_observer()
+
+	  Change-Id: Id8e34f5d09e7eebac3af22501c44c1110a3e29d8
+
+2016-07-13 08:57 +0000 [148cd1b319]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Avoid obsolete warning with pthread.m4 on autoconf.
+
+	  Updated the macro-set autoconf/ax_pthread.m4 to its latest upstream version.
+
+	  ASTERISK-26046 #close
+
+	  Change-Id: I11abc11d17acd2b6a8a5a5be8ae8e0949dab9cc7
+
+2016-07-11 10:25 +0000 [97b4c7a5b4]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Fix statsd regression.
+
+	  The ASTERISK-25904 change-id I8fad8aae9305481469c38d2146e1ba3a56d3108f
+	  patch introduced several regressions when the newly created "Updated"
+	  state goes out for each endpoint registration refresh.
+
+	  1) It restarted any OPTIONS RTT ping cycle.
+
+	  2) It would interfere with a currently active ping and throw off that
+	  ping's resulting RTT calculation.
+
+	  3) It cleared the RTT time each time the endpoint was refreshed.
+
+	  4) The cleared RTT time was sent out as a statsd update each time.
+
+	  5) It created two AMI events for each update.
+
+	  * Revert the original patch and reimplement it.  Now the current contact
+	  status state is re-sent instead of the state being momentarily toggled
+	  every time the endpoint refreshes its registration.  The statsd events are
+	  not created for the re-sent refresh because they are sent after every
+	  OPTIONS ping.
+
+	  ASTERISK-26160 #close
+	  Reported by: Matt Jordan
+
+	  Change-Id: Ie072be790fbb2a8f5c1c874266e4143fa31f66d1
+
+2016-07-12 03:50 +0000 [3be6fa1e4b]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Allow own CFLAGS on ./configure.
+
+	  Before this change, make failed with the error
+	  Unknown value '' found in build_tools/menuselect-deps for NATIVE_ARCH
+	  when CFLAGS were supplied to the configure script. This was introduced with
+	  <https://reviewboard.asterisk.org/r/1852/> which disabled BUILD_NATIVE when
+	  CFLAGS were supplied. Those who need different -march= values, please, go for
+	  ./configure
+	  make menuselect.makeopts or make menuselect
+	  ./menuselect/menuselect --disable BUILD_NATIVE
+
+	  ASTERISK-25289 #close
+
+	  Change-Id: Ic6365d5a97bb9b3556858f06432a8d1cfa83eebc
+
+2016-07-11 13:42 +0000 [5ee205d8bb]  Richard Mudgett <rmudgett@digium.com>
+
+	* ast_expr2: Fix off-nominal memory leak.
+
+	  Thanks to ibercom for pointing out a memory leak that was missed
+	  in the earlier patch for the issue.
+
+	  ASTERISK-26119
+	  Reported by: Alexei Gradinari
+
+	  Change-Id: I9a151f5c4725d97fb82a9e938bc73dc659532b71
+
+2016-07-11 10:17 +0000 [f5e9872016]  Alexander Traud <pabstraud@compuserve.com>
+
+	* install_prereq: Checkout of libSRTP 1.5.x.
+
+	  Since 5th November 2014, the master branch of libSRTP changed the prefix of
+	  several member names and is not compatible with the source code in Asterisk
+	  anymore. Therefore instead, this change checks out the latest version of the
+	  libSRTP 1.5.x branch. Furthermore now, libSRTP is compiled with OpenSSL as
+	  backend. This makes AES-GCM and AES-IN possible.
+
+	  ASTERISK-22131 #close
+
+	  Change-Id: I2e396cdc01da0ff610686e398ed210ca7408f7d6
+
+2016-07-10 19:08 +0000 [17efed6cf7]  Joshua Colp <jcolp@digium.com>
+
+	* func_odbc: Fix connection deadlock.
+
+	  The func_odbc module was modified to ensure that the
+	  previous behavior of using a single database connection
+	  was maintained. This was done by getting a single database
+	  connection and holding on to it. With the new multiple
+	  connection support in res_odbc this will actually starve
+	  every other thread from getting access to the database as
+	  it also maintains the previous behavior of having only
+	  a single database connection.
+
+	  This change disables the func_odbc specific behavior if
+	  the res_odbc module is running with only a single database
+	  connection active. The connection is only kept for the
+	  duration of the request.
+
+	  ASTERISK-26177 #close
+
+	  Change-Id: I9bdbd8a300fb3233877735ad3fd07bce38115b7f
+
+2016-07-09 13:32 +0000 [06ba533bc7]  Corey Farrell <git@cfware.com>
+
+	* chan_sip: Fix reference leaks in error paths.
+
+	  * get_sip_pvt_from_replaces leaks sip_pvt_ptr on any error.
+	  * build_peer leaks peer on failure to allocate the endpoint.
+
+	  This patch fixes get_sip_pvt by using an RAII_VAR, build_peer is fixed
+	  with an unref in the appropriate place.
+
+	  ASTERISK-26184 #close
+
+	  Change-Id: I728b424648ad041409f7d90880f4c28b3ce2ca12
+
+2016-07-07 12:41 +0000 [9d4e664f62]  Corey Farrell <git@cfware.com>
+
+	* REF_DEBUG: Prevent logging of container node objects.
+
+	  Using AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE can result in an unref being
+	  recorded to the refs log for the node being replaced.  This prevents
+	  logging of those unrefs since they would produce errors in
+	  refcounter.py.
+
+	  ASTERISK-26181 #close
+
+	  Change-Id: Ie4fded84e8a1a58b3a59ce59dfd7eb0da3ddc5d4
+
+2016-07-07 10:55 +0000 [e26bd15e7a]  Scott Griepentrog <scott@griepentrog.com>
+
+	* PJSIP: provide valid tcp nodelay option for reuse
+
+	  When using TCP transport with chan_pjsip, the TCP_NODELAY
+	  option value was allocated on the stack, then passed as a
+	  pointer to the tcp transport configuration structure, and
+	  later re-used on subsequently created sockets when it was
+	  no longer valid.  This patch changes the allocation to be
+	  a static.
+
+	  ASTERISK-26180 #close
+	  Reported by: Scott Griepentrog
+
+	  Change-Id: I3251164c7f710dbdab031282f00e30a9770626a0
+
+2016-07-07 10:38 +0000 [77b0145a25]  Joshua Colp <jcolp@digium.com>
+
+	* chan_sip/res_pjsip_t38: Handle a request to negotiate T.38 after it is enabled.
+
+	  Some T.38 implementations may send another re-invite after the initial
+	  one which adds additional negotiation details (such as the max bitrate).
+	  Currently this will fail when passthrough is being done in chan_sip as we
+	  do nothing if T.38 is already active.
+
+	  Other handlers of T.38 inside of Asterisk (such as res_fax) handle this
+	  scenario so this change adds support for it to chan_sip and res_pjsip_t38.
+	  If a request to negotiate is received while T.38 is already enabled a
+	  new re-INVITE is sent and negotiation is done again.
+
+	  ASTERISK-26179 #close
+
+	  Change-Id: I0298494d3da6df3219bbfa4be9aa04015043145c
+
+2016-07-04 16:38 +0000 [b4a9fa2c9e]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_sorcery_realtime: fix bug when successful UPDATE is treated as failed
+
+	  If the SQL UPDATE statement changes nothing then SQLRowCount returns 0.
+	  This value should be treated as success.
+	  But the function sorcery_realtime_update treats it as failed.
+
+	  This bug was found using stress tests on PJSIP.
+	  If there are 2 consecutive SIP REGISTER requests with the same contact data
+	  during 1 second then res_pjsip_registrar adds contact location on 1st request
+	  and tries to update contact location on 2nd.
+	  The update fails and res_pjsip_registrar even removes correct contact location.
+
+	  The test "object_update_uncreated" was removed from test_sorcery_realtime.c
+	  because it's now a valid situation.
+
+	  This patch also adds missing debug of extra SQL parameter.
+
+	  ASTERISK-26172 #close
+
+	  Change-Id: I05a7f3051455336c9dda29efc229decf86071303
+
+2016-06-24 19:55 +0000 [1dfd3fc995]  Matt Jordan <mjordan@digium.com>
+
+	* res/res_pjsip_session: Check for presence of an active negotiator
+
+	  It is possible in a hypothetical situation for a session refresh to be
+	  invoked on a PJSIP when the negotiatior on the INVITE session has not
+	  yet been established. While this shouldn't occur with existing uses of
+	  ast_sip_session_refresh, the crashes that occur due to improperly
+	  calling PJSIP functions that expect a non-NULL negotiatior are
+	  avoidable. PJSIP will create the negotiator in pjsip_inv_reinvite; this
+	  means that simply checking for the presence of the negotiator before
+	  passing it to other PJSIP functions that use it is allowable. As such,
+	  this patch adds checks for the presence of the negotiator before calling
+	  PJSIP functions that assume it is non-NULL.
+
+	  Change-Id: I1028323e7e01b0a531865e5412a71b6f6ec4276d
+
+2015-10-19 18:55 +0000 [9dd0aeeb44]  Matt Jordan <mjordan@digium.com>
+
+	* res/res_pjsip_pubsub: Add additional debug statements
+
+	  When something very sad and wrong occurs, it's challenging sometimes to
+	  figure out why. This patch adds some additional debug statements on
+	  off-nominal paths to try and make debugging easier.
+
+	  Change-Id: I7bffb73cc733b6f80193a23340881db4a102b640
+
+2015-10-19 18:55 +0000 [1ec4f8dd00]  Matt Jordan <mjordan@digium.com>
+
+	* res/res_corosync: Raise a Stasis message on node join/leave events
+
+	  When res_corosync detects that a node leaves or joins, it currently is
+	  informed of this via Corosync callbacks. However, there are a few
+	  limitations with the information presented:
+	  (1) While we have information that Corosync is aware of - such as the
+	      Corosync nodeid - that information is really only useful inside of
+	      Corosync or res_corosync. There's no way to translate a Corosync
+	      nodeid to some other internally useful unique identifier for the
+	      Asterisk instance that just joined or left the cluster.
+	  (2) While res_corosync is notified of the instance joining or leaving
+	      the cluster, it has no mechanism to inform the Asterisk core or
+	      other modules of this event. This limits the usefulness of res_corosync
+	      as a heartbeat mechanism for other modules.
+
+	  This patch addresses both issues.
+
+	  First, it adds the notion of a cluster discovery message both within the
+	  Stasis message bus, as well as the binary event messages that
+	  res_corosync uses to transmit data back and forth within the cluster.
+	  When Asterisk joins the cluster, it sends a discovery message to the other
+	  nodes in the cluster, which correlates the Corosync nodeid along with
+	  the Asterisk EID. res_corosync now maintains a hash of Corosync nodeids
+	  to Asterisk EIDs, such that it can map changes in cluster state with the
+	  Asterisk instance that has that nodeid. Likewise, when an Asterisk
+	  instance receives a discovery message from a node in the cluster, it now
+	  sends its own discovery message back to the originating node with the
+	  local Asterisk EID. This lets Asterisk instances within the cluster
+	  build a complete picture of the other Asterisk instances within the
+	  cluster.
+
+	  Second, it publishes the discovery messages onto the Stasis message bus.
+	  Said messages are published whenever a node joins or leaves the cluster.
+	  Interested modules can subscribe for the ast_cluster_discovery_type()
+	  message under the ast_system_topic() and be notified when changes in
+	  cluster state occur.
+
+	  Change-Id: I9015f418d6ae7f47e4994e04e18948df4d49b465
+
+2016-07-04 13:54 +0000 [2c16a81dd5]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: Added "subscribe_context" to endpoint
+
+	  If specified, incoming SUBSCRIBE requests will be searched for the matching
+	  extension in the indicated context. If no "subscribe_context" is specified,
+	  then the "context" setting is used.
+
+	  ASTERISK-25471 #close
+
+	  Change-Id: I3fb7a15f5bc154079bd348c08b7ad1cdd2d5e514
+
+2016-07-04 05:58 +0000 [a1bd57884d]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Avoid obsolete warning with libcurl.m4 on autoconf.
+
+	  Updated the macro-set autoconf/libcurl.m4 to its latest upstream version. This
+	  avoids a warning about an obsolete macro on AC_HELP_STRING, because Asterisk is
+	  using AS_HELP_STRING everywhere else already.
+
+	  ASTERISK-26046
+
+	  Change-Id: I8299faf504ceaeee3e39930c59293809e116c631
+
+2016-06-30 15:17 +0000 [640fbbbe28]  Richard Mudgett <rmudgett@digium.com>
+
+	* features: Fix channel datastore access.
+
+	  Found as a result of the testsuite tests/callparking test crashing.
+
+	  Several calls to ast_get_chan_featuremap_config() and
+	  ast_get_chan_features_xfer_config() did not lock the channel before
+	  calling so the channel's datastore list was accessed without the lock's
+	  protection.  Apparently another thread deleted a datastore on the
+	  channel's list while the crashing thread was walking the list.  Crash at
+	  0xdeaddead due to MALLOC_DEBUG's memory filler value as a result.
+
+	  * Add missing channel locks to calls that were not already protected
+	  as the doxygen for those calls indicates.
+
+	  Change-Id: Id273b3d305cc616406c353cbc841b2b7655efaa1
+
+2016-06-22 17:26 +0000 [359134c8d3]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Don't send extra BYE if SDP invalid.
+
+	  When an answer SDP is invalid we were disconnecting the outgoing call and
+	  sending two BYE requests.  The first BYE was sent by PJPROJECT because of
+	  the invalid SDP answer.  The second BYE was sent by Asterisk because it
+	  thought the canceled call was the result of the RFC5407 section 3.1.2 race
+	  condition.
+
+	  * Made not send the BYE on a canceled session if the SDP negotiation is
+	  incomplete because PJPROJECT has already sent a BYE for the failed
+	  negotiation.
+
+	  ASTERISK-25772 #close
+	  Reported by:  Dmitriy Serov
+
+	  Change-Id: I44ad0bd0605e8eeb7035c890d6f97a1331f1a836
+
+2016-06-27 17:19 +0000 [5fabcf2ca1]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: End call on initial invalid SDP negotiation.
+
+	  When an incoming call defers SDP negotiation and then sends us an invalid
+	  SDP in the ACK, we need to send a BYE to disconnect the call.  In this
+	  case SDP negotiation has failed and we don't have valid media streams
+	  negotiated.
+
+	  ASTERISK-25772
+
+	  Change-Id: Ia358516b0fc1e6c4c139b78246f10b9da7a2dfb8
+
+2016-06-23 15:13 +0000 [38a4e983dc]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip.c: Register PJMEDIA error code decoder.
+
+	  Registering the PJMEDIA error codes allows errors found when parsing an
+	  incoming SDP to be easier to figure out.
+
+	  "Missing SDP rtpmap for dynamic payload type (PJMEDIA_SDP_EMISSINGRTPMAP)"
+	  is much easier to understand than "Unknown error 220030".
+
+	  ASTERISK-25772
+
+	  Change-Id: I44b2dcea656fedd7593171be9e845880a2c70ca0
+
+2016-06-27 16:56 +0000 [1952434df5]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Remove unused parameter from handle_incoming().
+
+	  Change-Id: Iedd182d189ec947c42edc2c66c4bda3c22060daa
+
+2016-06-22 18:02 +0000 [28928ba5c4]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip: Add missing NULL checks when using pjsip_inv_end_session().
+
+	  pjsip_inv_end_session() is documented as being able to return the
+	  passed in tdata parameter set to NULL on success.
+
+	  Change-Id: I09d53725c49b7183c41bfa1be3ff225f3a8d3047
+
+2016-06-30 08:25 +0000 [43a78100c0]  gtjoseph <gjoseph@digium.com>
+
+	* configure:  Fix HAVE_PJSIP_EVSUB_GRP_LOCK not set with external pjproject
+
+	  There was a typo in configure.ac preventing HAVE_PJSIP_EVSUB_GRP_LOCK
+	  from getting set when using an external pjproject.
+
+	  ASTERISK-26099 #close
+	  Reported-by: Ross Beer
+
+	  Change-Id: I709af70428e125fb5ccd44b171d25dd29141f0ae
+
+2016-06-29 15:31 +0000 [99eff80e76]  Matt Jordan <mjordan@digium.com>
+
+	* hep.conf.sample: Default 'enabled' to 'no'
+
+	  Following the principle of least surprise, we should not be sending
+	  massive numbers of PJSIP and RTCP HEP packets out into the ether to some
+	  only-slightly-random IP address. Having 'enabled' set to 'no' in the
+	  sample configuration file should prevent this from happening for those
+	  who run 'make samples'.
+
+	  ASTERISK-26159 #close
+
+	  Change-Id: I1753a64ca83a3442a6ebdc31061f8185c062d9b1
+
+2016-06-29 15:09 +0000 [78960975f2]  Matt Jordan <mjordan@digium.com>
+
+	* pjproject/patches/config_site: Increase the max number of ICE candidates
+
+	  When negotiating ICE candidates with WebRTC capable endpoints, many
+	  networks will result in a browser offering ICE candidates that exceeds
+	  the default number of max candidates, 16. This patch bumps the max
+	  candidates to 32, with the max checks at twice the number of candidates.
+	  In practice, this has shown to be sufficient for browser/WebRTC
+	  negotiation.
+
+	  Change-Id: Ifd8da8b315f5ae14814d4ce20e10d2e6355020e5
+
+2016-06-28 09:00 +0000 [d07c8a0504]  gtjoseph <gjoseph@digium.com>
+
+	* codecs:  Fix ABI incompatibility created by adding format_name to ast_codec
+
+	  Adding format_name even to the end of ast_codec caused issued with
+	  binary codec modules because the pointer would be garbage in asterisk
+	  when they registered.  So, the ast_codec structure was reverted and an
+	  internal_ast_codec structure was created just for use in codec.c.  A new
+	  internal-only API was also added (__ast_codec_register_with_format) so
+	  that codec_builtin could register codecs with the format_name in a
+	  separate parameter rather than in the ast_codec structure.
+
+	  ASTERISK-26144 #close
+	  Reported-by: Alexei Gradinari
+
+	  Change-Id: I6df1b08f6a6ae089db23adfe1ebc8636330265ba
+
+2016-06-28 08:22 +0000 [f3d236ca7f]  gtjoseph <gjoseph@digium.com>
+
+	* BuildSystem:  Fix a few issues hightlighted by gcc 6.x
+
+	  gcc 6.1.1 caught a few more issues.
+	  Made sure the unit tests still pass for the func_env and stdtime
+	  issues.
+
+	  ASTERISK-26157 #close
+
+	  Change-Id: I6664d8f34a45bc1481d2a854481c7878b0c1cf8e
+
+2016-06-28 10:33 +0000 [9d5b0934d9]  Matt Jordan <mjordan@digium.com>
+
+	* configs/basic-pbx/modules.conf: Remove 'bad' modules
+
+	  This patch removes the following modules:
+	   - pbx_functions: It never existed.
+	   - res_pjsip_log_forwarder: It no longer exists.
+	   - res_hep_pjsip: The base HEP module wasn't loaded, and most basic PBXs
+	                    aren't going to be installing HOMER
+	   - res_pjsip_phoneprov_provider: The basic res_phoneprov module isn't
+	                    loaded, and we aren't configured to make use of the
+	                    module
+
+	  Change-Id: Id91f68cae7c9c8c3d370029fe1268cb51e4ff5a5
+
+2016-06-22 11:19 +0000 [1dfc286418]  Joshua Colp <jcolp@digium.com>
+
+	* siren: Add format attribute modules for Siren7 and Siren14.
+
+	  This change removes hardcoded SDP parsing and generation for
+	  Siren7 and Siren14 from chan_sip and moves it to format attribute
+	  modules so it can also be used by chan_pjsip.
+
+	  With this the fmtp lines for both are added with the bitrate
+	  information.
+
+	  ASTERISK-26021
+
+	  Change-Id: Ibb004eda37a14c0a35ef0613f6237977fc800037
+
+2016-06-23 04:33 +0000 [5f0a098243]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Avoid obsolete warning with AC_TYPE_SIGNAL on autoconf.
+
+	  Removed the obsolete macro AC_TYPE_SIGNAL because Asterisk does not use K&R C
+	  but requires ANSI C anyway.
+
+	  ASTERISK-26046
+
+	  Change-Id: I914c014385e1862102d90fe7650621def78db02e
+
+2016-06-02 17:26 +0000 [b3c787d1dd]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: improve realtime performance #2
+
+	  The patch removes updating all Endpoints' status on startup.
+	  Instead, only non-qualified aors with static contact
+	  and non-qualified non-expired contacts are retrieved from the realtime to
+	  update the endpoint status to ONLINE.
+	  The endpoint name was added to the contact object to simply find the endpoint
+	  that created this contact.
+
+	  The status of endpoints with qualified aors will be updated by 'qualify'
+	  functions.
+
+	  ASTERISK-26061 #close
+
+	  Change-Id: Id324c1776fa55d3741e0c5457ecac0304cb1a0df
+
+2016-06-23 13:47 +0000  Asterisk Development Team <asteriskteam@digium.com>
+
+	* asterisk 13.10.0-rc1 Released.
+
+2016-06-23 08:42 +0000 [62349ac1b4]  Mark Michelson <mmichelson@digium.com>
+
+	* Release summaries: Add summaries for 13.10.0-rc1
+
+2016-06-23 08:38 +0000 [8da6ba4328]  Mark Michelson <mmichelson@digium.com>
+
+	* .version: Update for 13.10.0-rc1
+
+2016-06-23 08:38 +0000 [170b85e3ae]  Mark Michelson <mmichelson@digium.com>
+
+	* .lastclean: Update for 13.10.0-rc1
+
+2016-06-23 08:38 +0000 [4af7049b8f]  Mark Michelson <mmichelson@digium.com>
+
+	* realtime: Add database scripts for 13.10.0-rc1
+
+2016-06-22 15:04 +0000 [3d904659ec]  Corey Farrell <git@cfware.com>
+
+	* res_fax: Fix reference leak in fax_v21_session_new.
+
+	  fax_v21_session_new created a session details object but only released
+	  the allocation reference during error conditions.  fax_session_new adds
+	  it's own reference to details if needed so the caller is always
+	  responsible for cleaning it's own reference.
+
+	  ASTERISK-26141 #close
+
+	  Change-Id: Ie7fc52a83b6596ce9ce2d5a2bd9f3e204f48fc88
+
+2016-06-22 13:41 +0000 [48db4c2159]  gtjoseph <gjoseph@digium.com>
+
+	* res_rtp_asterisk:  Fix a self-comparison identified by gcc 6
+
+	  gcc 6 caught a previously unidentified self-comparison in
+	  ice_candidate_cmp.  Fixed it and re-ordered the predicates for better
+	  short-circuiting.
+
+	  ASTERISK-26140 #close
+
+	  Change-Id: I3da713c568e24064430257b3502fbdafd35af7a7
+
+2016-06-22 10:37 +0000 [bc69b03316]  gtjoseph <gjoseph@digium.com>
+
+	* chan_unistim:  Fix memcpy in get_to_address
+
+	  A code block only enabled when HAVE_PKTINFO is not defined (FreeBSD)
+	  was using a pointer to a pointer as the destination of a memcpy and a
+	  '&' instead of '*' in the sizeof.
+
+	  ASTERISK-26138 #close
+
+	  Change-Id: Id4927ff256c0e470bdf7bcfc025146a2f656e708
+
+2016-06-20 13:18 +0000 [1b79e2deff]  Mark Michelson <mmichelson@digium.com>
+
+	* Fix Alembic upgrades.
+
+	  A non-existent constraint was being referenced in the upgrade script.
+	  This patch corrects the problem by removing the reference.
+
+	  This patch fixes another realtime problem as well. Our Alembic scripts
+	  store booleans as yes or no values. However, Sorcery tries to insert
+	  "true" or "false" instead. This patch updates Sorcery to use "yes" and
+	  "no"
+
+	  ASTERISK-26128 #close
+
+	  Change-Id: I366dbbf91418a9cb160b3ca74b0e59b5ac284bec
+
+2016-06-22 10:55 +0000 [e30602587c]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Avoid obsolete warning with AC_FUNC_SETVBUF_REVERSED on autoconf.
+
+	  Removed the obsolete macro AC_FUNC_SETVBUF_REVERSED because Asterisk does not
+	  support the platform SVR2 from the year 1987 anymore.
+
+	  ASTERISK-26046
+
+	  Change-Id: I28161b037feb2d29ab46ed20e785928460226c22
+
+2016-06-22 10:51 +0000 [77da168e58]  gtjoseph <gjoseph@digium.com>
+
+	* test_res_pjsip_scheduler: Add 'depends' on pjproject in MODULEINFO
+
+	  Since the file was missing the depends on pjproject, it wasn't
+	  picking up the pjproject related include path.  If there was no
+	  system installed pjproject and pjproject-bundled was used, a compile
+	  would fail because pjsip.h wasn't found.
+
+	  ASTERISK-26139 #close
+
+	  Change-Id: I2ee64a999051452bc198c4e2c168c70769cd3757
+
+2016-06-21 06:52 +0000 [dfcd466bf0]  Torrey Searle <torrey@voxbone.com>
+
+	* res_rtp_asterisk: fix memory leak in dtls
+
+	  ensure that cert bios get freed after creating the fingerprint
+
+	  ASTERISK-26129 #close
+
+	  Change-Id: I44d23aea07dce80176ca1ff877c5ace9452ef451
+
+2016-06-21 17:42 +0000 [c982da0641]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjproject.c: Replace inlined DEBUG_ATLEAST() with macro.
+
+	  Change-Id: I8799fb0a347ad76e747dafd0eacf1ea1086b9a8c
+
+2016-06-12 11:19 +0000 [6a568bcc66]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_pubsub: Address SEGV when attempting to terminate a subscription
+
+	  Occasionally under load we'll attempt to send a final NOTIFY on a
+	  subscription that's already been terminated and a SEGV will occur
+	  down in pjproject's evsub_destroy function.  This is a result of a
+	  race condition between all the paths that can generate a notify
+	  and/or destroy the underlying pjproject evsub object:
+
+	   * The client can send a SUBSCRIBE with Expires: 0.
+	   * The client can send a SUBSCRIBE/refresh.
+	   * The subscription timer can expire.
+	   * An extension state can change.
+	   * An MWI event can be generated.
+	   * The pjproject transaction timer (timer_b) can expire.
+
+	  Normally when our pubsub_on_evsub_state is called with a terminate,
+	  we push a task to the serializer and return at which point the dialog
+	  is unlocked.  This is usually not a problem because the task runs
+	  immediately and locks the dialog again.  When the system is heavily
+	  loaded though, there may be a delay between the unlock and relock
+	  during which another event may occur such as the subscription timer
+	  or timer_b expiring, an extension state change, etc.  These may also
+	  cause a terminate to be processed and if so, we could cause pjproject
+	  to try to destroy the evsub structure twice.  There's no way for us to
+	  tell that the evsub was already destroyed and the evsub's group lock
+	  can't tolerate this and SEGVs.
+
+	  The remedy is twofold.
+
+	   * A patch has been submitted to Teluu and added to the bundled
+	     pjproject which adds add/decrement operations on evsub's group lock.
+
+	   * In res_pjsip_pubsub:
+	     * configure.ac and pjproject-bundled's configure.m4 were updated
+	       to check for the new evsub group lock APIs.
+	     * We now add a reference to the evsub group lock when we create
+	       the subscription and remove the reference when we clean up the
+	       subscription.  This prevents evsub from being destroyed before
+	       we're done with it.
+	     * A state has been added to the subscription tree structure so
+	       termination progress can be tracked through the asyncronous tasks.
+	     * The pubsub_on_evsub_state callback has been split so it's not doing
+	       double duty.  It now only handles the final cleanup of the
+	       subscription tree.  pubsub_on_rx_refresh now handles both client
+	       refreshes and client terminates.  It was always being called for
+	       both anyway.
+	     * The serialized_on_server_timeout task was removed since
+	       serialized_pubsub_on_rx_refresh was almost identical.
+	     * Missing state checks and ao2_cleanups were added.
+	     * Some debug levels were adjusted to make seeing only off-nominal
+	       things at level 1 and nominal or progress things at level 2+.
+
+	  ASTERISK-26099 #close
+	  Reported-by: Ross Beer.
+
+	  Change-Id: I779d11802cf672a51392e62a74a1216596075ba1
+
+2016-06-21 07:05 +0000 [ef97911a1c]  Alexander Traud <pabstraud@compuserve.com>
+
+	* res_rtp_asterisk: Use latest DTLS version available by underlying platform.
+
+	  Do not use DTLSv1_method() but DTLS_method() when available in OpenSSL of the
+	  underlying platform. This change enables DTLS 1.2 since OpenSSL 1.0.2, for
+	  WebRTC (DTLS-SRTP via SIP-over-WebSockets). This change enables AEAD-based
+	  cipher-suites.
+
+	  ASTERISK-26130 #close
+
+	  Change-Id: I41f24448d6d2953e8bdb97c9f4a6bc8a8f055fd0
+
+2016-06-21 10:53 +0000 [69d58a1e37]  Scott Griepentrog <scott@griepentrog.com>
+
+	* PJSIP: provide transport type with received messages
+
+	  The receipt of a SIP MESSAGE may occur over any transport including TCP
+	  and TLS. When the message is received, the original URI is added to the
+	  message in the field PJSIP_RECVADDR, but this is insufficient to ensure
+	  a reply message can reach the originating endpoint. This patch adds the
+	  PJSIP_TRANSPORT field populated with the transport type.
+
+	  ASTERISK-26132 #close
+
+	  Change-Id: I28c4b1e40d573a056c81deb213ecf53e968f725e
+
+2016-06-21 08:01 +0000 [cbfa9f771e]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Avoid obsolete warning with HELP_STRING on autoconf.
+
+	  Some configure scripts used both AC_HELP_STRING and its replacement
+	  AS_HELP_STRING. For consistency and to avoid obsolete warnings, those were
+	  changed to AS_HELP_STRING.
+
+	  ASTERISK-26046
+
+	  Change-Id: I8aad4fd2bdee40aa2a31ce3339a1eb33ff4f5b0f
+
+2016-06-20 10:29 +0000 [ba0d9e7f7a]  Joshua Colp <jcolp@digium.com>
+
+	* res_pjsip_session: Handle race condition at shutdown with timer.
+
+	  When shutting down res_pjsip_session will get unloaded before res_pjsip.
+	  The act of unloading unregisters all the PJSIP services and sets
+	  their module IDs to -1. In some cases it is possible for a timer to
+	  occur after this happens which calls into res_pjsip_session. The
+	  res_pjsip_session module can then try to get the session from the
+	  INVITE session using the module ID. Since the module ID is now -1
+	  this fails.
+
+	  This change stores a copy of the module ID and uses it for the timer
+	  callback scenario. If the module ID is -1 the callback immediately
+	  returns but if the module ID is valid then it continues as normal.
+
+	  This works as the original ID of the module is guaranteed to still
+	  be valid when used with the INVITE session.
+
+	  ASTERISK-26127 #close
+
+	  Change-Id: I88df72525c4e9ef9f19c13aedddd3ac4a335c573
+
+2016-06-20 12:13 +0000 [c1512f4108]  Richard Mudgett <rmudgett@digium.com>
+
+	* app_voicemail.c: Fix IMAP compile error.
+
+	  Fix compile error introduced by the patch for
+	  ASTERISK-26045
+
+	  Change-Id: I5b02876266f2824f4cec2b54d6ff4db5de5778d3
+
+2016-06-16 15:56 +0000 [5134a8043a]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* fix: memory leaks, resource leaks, out of bounds and bugs
+
+	  ASTERISK-26119 #close
+
+	  Change-Id: Iecbf7d0f360a021147344c4e83ab242fd1e7512c
+
+2016-06-13 17:40 +0000 [cfebe3b94a]  Mark Michelson <mmichelson@digium.com>
+
+	* ARI: Ensure announcer channels are destroyed.
+
+	  Announcer channels were not being destroyed because the
+	  stasis_app_control structure that referenced them was not being
+	  destroyed. The control structure was not being destroyed because it was
+	  not being unlinked from its container. It was not being unlinked from
+	  its container because the after bridge callback for the announcer
+	  channel was not being run. The after bridge callback was not being run
+	  because the after bridge datastore was not being removed from the
+	  channel on destruction. The channel was not being destroyed because the
+	  hangup that used to destroy the channel was now only reducing the
+	  reference count to one. The reference count of the channel was only
+	  being reduced to one because the stasis_app_control structure was
+	  holding the final reference...
+
+	  The control structure used to not keep a reference to the channel, so
+	  that loop described above did not happen.
+
+	  The solution is to manually remove the control structure from its
+	  container when the playback on a bridge is complete.
+
+	  ASTERISK-26083 #close
+	  Reported by Joshua Colp
+
+	  Change-Id: I0ddc0f64484ea0016245800b409b567dfe85cfb4
+
+2016-06-20 08:05 +0000 [76516bd79d]  Alexander Traud <pabstraud@compuserve.com>
+
+	* http: leverage 'bindaddr' for TLS in http.conf
+
+	  The internal HTTP/WebSocket server supports both TCP and TLS, which can be
+	  activated separately via the file http.conf. The source code intends to re-use
+	  the TCP parameter 'bindaddr' for TLS, even if 'tlsbindaddr' is not specified
+	  explicitly. This did not work because of a typo. This change resolves this typo.
+
+	  ASTERISK-26126 #close
+
+	  Change-Id: I5efb0409ae12044dfb3495b6b97b6d40a8c9c51f
+
+2016-05-31 09:10 +0000 [89cc86fc38]  Vasil Kolev <vasil.kolev@securax.org>
+
+	* chan_sip: bigger buffers for headers, better failure mode
+
+	  Currently chan_sip can give weird messages if the contacts don't
+	  fit in the From: or To: headers. This fix changes the from,to and
+	  invite variables to use ast_str, allocates and deallocates them and
+	  resizes them if needed.
+
+	  ASTERISK-26069 #close
+
+	  Change-Id: I1b68fcbddca6f6cc7d7a92fe1cb0d5430282b2b3
+
+2016-05-18 17:37 +0000 [d53a36ff33]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_transport_management.c: Misc cleanups to survive shutdown.
+
+	  * In unload_module(), reordered destroying things to minimize the window
+	  that the global transports container could be used by other threads on
+	  shutdown.  When shutting down you need to stop things in the opposite
+	  order of creation.
+
+	  * Put the global transports container into an AO2_GLOBAL_OBJ_STATIC to
+	  eliminate the crash potential by other threads using the container on
+	  shutdown.
+
+	  * Made struct monitored_transport.sip_received not use
+	  ast_atomic_fetchadd_int() since it is used as a boolean value that is only
+	  set TRUE.  It was previously incremented for every received SIP message
+	  and could theoretically overflow.
+
+	  * In monitored_transport_state_callback(), allocated the monitored
+	  transport object without a lock since the lock was unused.
+
+	  * In keepalive_global_loaded(), removed releasing the transports container
+	  if the keepalive_thread could not be started.  I set it up to be tried
+	  again if the user reloads the configuration.
+
+	  Change-Id: I8d12d16ef564290fa6d25a32334bb5ce8fdf87ff
+
+2016-01-05 19:08 +0000 [03953d8034]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip.c: Add check that timer actually got scheduled.
+
+	  Change-Id: Iabaa2e5dccf0762c258101ea0eb1487cf6959ad1
+
+2016-06-13 13:33 +0000 [32ab98116e]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_rtp_multicast.c: Fix warning message typo.
+
+	  Change-Id: Ic9928208b9957e09866abe3d9649030942ec52b3
+
+2016-02-11 18:15 +0000 [0429c53368]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session.c: Reorganize ast_sip_session_terminate().
+
+	  Change-Id: I68a2128bcba4830985d2d441e70dfd1ac5bd712b
+
+2016-06-10 12:35 +0000 [5823f279f3]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_rtp: Backport changes from master.
+
+	  * Deprecate chan_multicast_rtp.
+
+	  Change-Id: Ib5a45e58c75ee8abd0b4f9575379b5321feb853e
+
+2016-06-10 16:13 +0000 [dde58df318]  Richard Mudgett <rmudgett@digium.com>
+
+	* chan_rtp.c: Copy file from chan_multicast_rtp.c
+
+	  Change-Id: I1119b53f2152ab1cbec74b5be7ea44844dbda8ef
+
+2016-06-08 06:15 +0000 [ca38a3cbb4]  Alexander Traud <pabstraud@compuserve.com>
+
+	* core: Not the configured but granted number of possible file descriptors.
+
+	  With CLI "core show settings", simply the parameter maxfiles of the file
+	  asterisk.conf was shown. If that parameter was not set, nothing was displayed
+	  although the environment might have set a default number itself. Or if maxfiles
+	  were not granted (completely), still maxfiles was shown. Now, the maximum number
+	  of possible file descriptors in the environment is shown.
+
+	  ASTERISK-26097
+
+	  Change-Id: I2df5c58863b5007b34b77adbe28b885dfcdf7e0b
+
+2016-06-07 18:45 +0000 [caf6cccc5c]  Joshua Colp <jcolp@digium.com>
+
+	* cel: Ensure only one dial status per channel exists.
+
+	  CEL wrongly assumed that a channel would only have a single dial
+	  event on it. This is incorrect. Particularly in a queue each
+	  call attempt to a member will result in a dial event, adding
+	  a new dial status in CEL without removing the old one. This
+	  would cause the container to grow with only one dial status
+	  being removed when the channel went away. The other dial status
+	  entries would remain leaking memory.
+
+	  This change fixes the memory leak by ensuring that only one dial
+	  status will only ever exist for each channel.
+
+	  The behavior during the scenario where multiple events are received
+	  has also been improved. For failure cases the first failure will
+	  be the dial status. If an answer dial status is received, though,
+	  it will take priority and the dial status for the channel will be
+	  answer.
+
+	  Memory usage has also been decreased by storing the minimal
+	  amount of information and the code has been cleaned up slightly.
+
+	  ASTERISK-25262 #close
+
+	  Change-Id: I5944eb923db17b6a0faa7317ff6abc9307c009fe
+
+2016-06-09 10:37 +0000 [715ef071a1]  Mark Michelson <mmichelson@digium.com>
+
+	* chan_pjsip: Lock channel when checking for RTP changes.
+
+	  bridge_native_rtp can call into an RTP-capable channel driver in order
+	  for the driver to update information about who the channel is
+	  communicating with. For SIP channel drivers, this means deactivating
+	  RTCP and sending a reinvite so that the endpoints can communicate
+	  directly.
+
+	  bridge_native_rtp does the right thing and has the channel locked when
+	  calling into the channel driver. chan_pjsip can't alter session
+	  properties in this thread, though. chan_pjsip queues a task on the
+	  session serializer in order to update properties there.
+
+	  The problem is that this queued task was not locking the channel. This
+	  meant that the queued task could attempt to deactivate RTCP at the same
+	  time that the channel thread was attempting to process an incoming RTCP
+	  packet. This could lead to a crash.
+
+	  This patch fixes the issue by locking the channel in the queued task
+	  when altering RTP properties.
+
+	  ASTERISK-26092 #close
+	  Reported by Niklas Larsson
+
+	  Change-Id: I3464e226a3c41f6b915f97891e07fa1599e2a159
+
+2016-06-09 09:20 +0000 [a99ddc6a0d]  gtjoseph <gjoseph@digium.com>
+
+	* build:  Fix ast_sockaddr initialization to be more portable
+
+	  A change to glibc 2.22 changed the order of the sockadddr_storage
+	  members which caused the places where we do an initialization of
+	  ast_sockaddr with '{ { 0, 0, } }' to fail compilation.  Those
+	  initializers (which we shouldn't have been using anyway) have been
+	  replaced with memsets.
+
+	  Change-Id: Idd1b3b320903d8771bfe221f0b015685de628fa4
+
+2016-06-08 12:26 +0000 [eabb398d71]  Matt Jordan <mjordan@digium.com>
+
+	* res_hep_{pjsip|rtcp}: Decline module loads if res_hep had not loaded
+
+	  A crash can occur in res_hep_pjsip or res_hep_rtcp if res_hep has not
+	  loaded and does not have a configuration file. Previously when this
+	  occurred, checks were put in to see if the configuration was loaded
+	  successfully. While this is a good idea - and has been added to the
+	  offending function in res_hep - the reality is res_hep_pjsip and
+	  res_hep_rtcp have no business running if res_hep isn't also running.
+
+	  As such, this patch also adds a function to res_hep that returns whether
+	  or not it successfully loaded. Oddly enough, ast_module_check returns
+	  "everything is peachy" even if a module declined its load - so it cannot
+	  be solely relied on. res_hep_pjsip and res_hep_rtcp now also check this
+	  function to see if they should continue to load; if it fails, they
+	  decline their load as well.
+
+	  ASTERISK-26096 #close
+
+	  Change-Id: I007e535fcc2e51c2ca48534f48c5fc2ac38935ea
+
+2016-06-08 05:58 +0000 [0d84421f93]  Alexander Traud <pabstraud@compuserve.com>
+
+	* astfd: Not maximum size of a single file but maximum file descriptors.
+
+	  With menuselect "DEBUG_FD_LEAKS" and CLI "core show fd", the maximum size of a
+	  single file was shown. Now, the maximum number of possible file descriptors is
+	  shown.
+
+	  ASTERISK-26097
+
+	  Change-Id: Icf98d145774b38cac144ca76d19eaef42ce659a3
+
+2016-06-02 14:53 +0000 [9c5a0b814b]  Timo Teräs <timo.teras@iki.fi>
+
+	* Fix #include poll.h and sys/cdefs.h
+
+	  POSIX defines poll.h, sys/poll.h should not be used at is c-library
+	  internal header which may or may not exist. Notable in musl it
+	  generates warning of being incorrect. And add explict include of
+	  sys/cdefs.h where needed.
+
+	  Change-Id: I142930df53fe7585a06b854b6faddc5301e024be
+
+2016-06-03 22:44 +0000 [9c35f34301]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_registrar.c: Eliminate rx REGISTER request race condition.
+
+	  This patch fixes a race condition processing received REGISTER requests
+	  and their retransmissions caused by REGISTER requests being processed by
+	  two threads.  The "sip_transaction Unable to register REGISTER transaction
+	  (key exists)" message is a notable symptom of this issue.
+
+	  This issue was more likely to happen before the pjsip/distributor
+	  serializers were created.  Instead of steps one and two below placing the
+	  REGISTER messages into the same pjsip/distributor they were placed in
+	  random pjsip/default serializers.
+
+	  1) REGISTER requests come in and get placed on the pjsip/distributor
+	  serializer.
+
+	  2) Before the first request is processed a retransmission comes in and is
+	  placed on the same pjsip/distributor serializer.
+
+	  3) The first request goes up the pjsip stack and is then shunted off to
+	  the pjsip/aor/<aor> serializer.
+
+	  4) Before the first request is completed processing in the pjsip/aor/<aor>
+	  serializer, the second request goes up the pjsip stack and is also shunted
+	  off to the pjsip/aor/<aor> serializer.
+
+	  5) The first request completes processing and sends out its response.
+
+	  6) The second request completes processing and tries to send out its
+	  response but pjlib complains that the REGISTER transaction key already
+	  exists.
+
+	  7) Sadness ensues.
+
+	  * The race is eliminated by removing the pjsip/aor/<aor> serializer and
+	  continuing the processing in the pjsip/distributor serializer.  Now any
+	  retransmissions queued in the pjsip/distributor serializer will be
+	  processed after the first message is completely processed.
+
+	  ASTERISK-26088 #close
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I842d714346088bf717ea27437f1dd85bff0bab5a
+
+2016-06-03 11:35 +0000 [557333ea4c]  Richard Mudgett <rmudgett@digium.com>
+
+	* stasis: Add setting subscription congestion levels.
+
+	  Stasis subscriptions and message routers create taskprocessors to process
+	  the event messages.  API calls are needed to be able to set the congestion
+	  levels of these taskprocessors for selected subscriptions and message
+	  routers.
+
+	  * Updated CDR, CEL, and manager's stasis subscription congestion levels
+	  based upon stress testing.  Increased the congestion levels to reduce the
+	  potential for bursty call setup/teardown activity from triggering the
+	  taskprocessor overload alert.  CDRs in particular need an extra high
+	  congestion level because they can take awhile to process the stasis
+	  messages.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: Id0a716394b4eee746dd158acc63d703902450244
+
+2016-06-02 18:19 +0000 [110d772467]  Richard Mudgett <rmudgett@digium.com>
+
+	* sorcery: Add setting object type congestion levels.
+
+	  Sorcery creates taskprocessors for object types to process object observer
+	  callbacks.  An API call is needed to be able to set the congestion levels
+	  of these taskprocessors for selected object types.
+
+	  * Updated PJSIP's contact and contact_status sorcery object type observer
+	  default congestion levels based upon stress testing.  Increased the
+	  congestion levels to reduce the potential for bursty register/unregister
+	  and subscribe/unsubscribe activity from triggering the taskprocessor
+	  overload alert.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I4542e83b556f0714009bfeff89505c801f1218c6
+
+2016-06-02 16:08 +0000 [610eee2a36]  Richard Mudgett <rmudgett@digium.com>
+
+	* taskprocessors: Implement high/low water mark alerts.
+
+	  When taskprocessors get backed up, there is a good chance that we are
+	  being overloaded and need to defer adding new work to the system.
+
+	  * Implemented a high/low water alert mechanism for modules to check if the
+	  system is being overloaded and take appropriate action.  When a
+	  taskprocessor is created it has default congestion levels set.  A
+	  taskprocessor can later have those congestion levels altered for specific
+	  needs if stress testing shows that the taskprocessor is a symptom of
+	  overloading or needs to handle bursty activity without triggering an
+	  overload alert.
+
+	  * Add CLI "core show taskprocessor" low/high water columns.
+
+	  * Fixed __allocate_taskprocessor() to not use RAII_VAR().  RAII_VAR() was
+	  never a good thing to use when creating a taskprocessor because of the
+	  nature of how its references needed to be cleaned up on a partial
+	  creation.
+
+	  * Made res_pjsip's distributor check if the taskprocessor overload alert
+	  is active before placing a message representing brand new work onto a
+	  distributor serializer.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I182f1be603529cd665958661c4c05ff9901825fa
+
+2016-05-27 17:31 +0000 [26e3492246]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_session: Use distributor serializer for incoming calls.
+
+	  We must continue using the serializer that the original INVITE came in on
+	  for the dialog.  There may be retransmissions already enqueued in the
+	  original serializer that can result in reentrancy and message sequencing
+	  problems.
+
+	  Outgoing call legs create the pjsip/outsess/<endpoint> serializers for
+	  their dialogs.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I24d7948749c582b8045d5389ba3f6588508adbbc
+
+2016-05-27 16:28 +0000 [ceb1007ed7]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Recreate subscriptions using distributor serializer.
+
+	  * Resolves potential reentrancy problems if system restarted in the middle
+	  of subscription message transactions.
+
+	  * Fixes memory leak recreating persistent subscriptions when the
+	  subscription resource tree could not be created.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I71e34d7ae8ed35a694f1030e820e2548c48697be
+
+2016-05-27 12:50 +0000 [27bafc3a8b]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Use distributor serializer for incoming subscriptions.
+
+	  We must continue using the serializer that the original SUBSCRIBE came in
+	  on for the dialog.  There may be retransmissions already enqueued in the
+	  original serializer that can result in reentrancy and message sequencing
+	  problems.  The "sip_transaction Unable to register SUBSCRIBE transaction
+	  (key exists)" message is a notable symptom of this issue.
+
+	  Outgoing subscriptions still create the pjsip/pubsub/<endpoint>
+	  serializers for their dialogs.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I18b00bb74a56747b2c8c29543a82440b110bf0b0
+
+2016-05-26 17:35 +0000 [16b08444da]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Consistently pick a serializer for messages.
+
+	  Incoming messages that are not part of a dialog or a recognized response
+	  to one of our requests need to be sent to a consistent serializer.  Under
+	  load we may be queueing retransmissions before we can process the original
+	  message.  We don't need to throw these messages onto random serializers
+	  and cause reentrancy and message sequencing problems.
+
+	  * Created a pool of pjsip/distributor serializers that get picked by
+	  hashing the call-id and remote tag strings of the received messages.
+
+	  * Made ast_sip_destroy_distributor() destroy items in the reverse order of
+	  creation.
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I2ce769389fc060d9f379977f559026fbcb632407
+
+2016-06-02 12:51 +0000 [993b769524]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Ignore messages until fully booted.
+
+	  We should not be processing any incoming messages until we are fully
+	  booted.  We may not have dialplan or other needed configuration loaded
+	  yet.
+
+	  ASTERISK-26089 #close
+	  Reported by: Scott Griepentrog
+
+	  ASTERISK-26088
+	  Reported by:  Richard Mudgett
+
+	  Change-Id: I584aefb4f34b885a8927e1f13a2c64babd606264
+
+2016-06-02 12:04 +0000 [321a9b128f]  Joshua Colp <jcolp@digium.com>
+
+	* res_odbc: Implement a connection pool.
+
+	  Testing has shown that our usage of UnixODBC is problematic
+	  due to bugs within UnixODBC itself as well as the heavy weight
+	  cost of connecting and disconnecting database connections, even
+	  when pooling is enabled.
+
+	  For users of UnixODBC 2.3.1 and earlier crashes would occur due
+	  to insufficient protection of the disconnect operation. This was
+	  fixed in UnixODBC 2.3.2 and above.
+
+	  For users of UnixODBC 2.3.3 and higher a slow-down would occur
+	  under heavy database use due to repeated connection establishment.
+	  A regression is present where on each connection the database
+	  configuration is cached again, with the cache growing out of
+	  control.
+
+	  The connection pool implementation present in this change helps
+	  to mitigate these issues by reducing how much we connect and
+	  disconnect database connections. We also solve the issue of
+	  crashes under UnixODBC 2.3.1 by defaulting the maximum number of
+	  connections to 1, returning us to the previous working behavior.
+	  For users who may have a fixed version the maximum concurrent
+	  connection limit can be increased helping with performance.
+
+	  The connection pool works by keeping a list of active connections.
+	  If the connection limit has not been reached a new connection is
+	  established. If the connection limit has been reached then the
+	  request waits until a connection becomes available before
+	  continuing.
+
+	  ASTERISK-26074 #close
+	  ASTERISK-26054 #close
+
+	  Change-Id: I6774bf4bac49a0b30242c76a09c403d2e856ecff
+
+2016-06-07 05:45 +0000 [c6ee4a0f44]  Alexander Traud <pabstraud@compuserve.com>
+
+	* res_srtp: Instead of libSRTP use OpenSSL as random source.
+
+	  Since libSRTP 1.5, its Random Number Generator (RNG) is not maintained anymore.
+	  Therefore, the symbol RAND_bytes is used instead of crypto_get_random.
+
+	  ASTERISK-24436 #close
+
+	  Change-Id: Iea0bae4d4e3c9aa0926ea442b6484b5159789d96
+
+2016-06-07 02:16 +0000 [d38b8e6399]  Alexander Traud <pabstraud@compuserve.com>
+
+	* BuildSystem: Avoid 'ar cru' and use 'ar cr' instead.
+
+	  In several internal library projects, the files are archived with the help of
+	  'ar cr'. Only the projects editline and the Objective Open H.323 stack
+	  implementation in C (ooh323c) use 'ar cru' instead. Recently, some platforms
+	  changed the default parameters of AR which creates "/usr/bin/ar: `u' modifier
+	  ignored since `D' is the default (see `U')". For consistency and to avoid this
+	  message all projects use 'ar cr' now.
+
+	  ASTERISK-26091 #close
+
+	  Change-Id: I710a9b1c01c1b5a1931a646098c044c8161ead40
+
+2016-05-27 14:49 +0000 [c27c232057]  gtjoseph <gjoseph@digium.com>
+
+	* ari/resource_channels:  Add 'formats' to channel create/originate
+
+	  If you create a local channel and don't specify an originator channel
+	  to take capabilities from, we automatically add all audio formats to
+	  the new channel's capabilities. When we try to make the channel
+	  compatible with another, the "best format" functions pick the best
+	  format available, which in this case will be slin192.  While this is
+	  great for preserving quality, it's the worst for performance and
+	  overkill for the vast majority of applications.
+
+	  In the absense of any other information, adding all formats is the
+	  correct thing to do and it's not always possible to supply an
+	  originator so a new parameter 'formats' has been added to the channel
+	  create/originate functions. It's just a comma separated list of formats
+	  to make availalble for the channel. Example: "ulaw,slin,slin16".
+	  'formats' and 'originator' are mutually exclusive.
+
+	  To facilitate determination of format names, the format name has been
+	  added to "core show codecs".
+
+	  ASTERISK-26070 #close
+
+	  Change-Id: I091b23ecd41c1b4128d85028209772ee139f604b
+
+2016-06-02 04:59 +0000 [cda3385409]  Joshua Colp <jcolp@digium.com>
+
+	* alembic: Fix migration.
+
+	  The 81b01a191a46_pjsip_add_contact_reg_server.py script was attempting
+	  to use UniqueConstraint and failing. It was not imported and after
+	  importing it also continued to fail.
+
+	  I've changed the script to use the explicit name of the constraint
+	  instead.
+
+	  Change-Id: I2438b0be90b7ce583b47dd27983c0c1a02cea5b9
+
+2016-06-01 13:57 +0000 [e2132dd358]  Richard Mudgett <rmudgett@digium.com>
+
+	* logging,cdr,cel: Fix stringfield memory leak.
+
+	  The stringfields refactor to allow adding stringfields to the end of a
+	  structure (f6f4cf459f43f072604927209b39646f84aaa2e2) exposed some
+	  incomplete cleanup code by some stringfield users.
+
+	  The most noticeable leaker is the logging system where there is a leak for
+	  every log message generated.
+
+	  ASTERISK-26078 #close
+	  Reported by:  Etienne Lessard
+	  Patches:
+	        jira_asterisk_26078_v13.patch (license #5621) patch uploaded
+	        by Richard Mudgett
+
+	  Change-Id: If6a08b31336b492c3de6f9dfd07c447f8d5a8782
+
+2016-05-25 10:34 +0000 [2de58c6d01]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* core/dial: New channel variable FORWARDERNAME
+
+	  Added a new channel variable FORWARDERNAME which indicates which
+	  channel was responsible for a forwarding requests received on dial attempt.
+
+	  Fixed a bug in the app_queue: FORWARD_CONTEXT is not used.
+
+	  ASTERISK-26059 #close
+
+	  Change-Id: I34e93e8c1b5e17776a77b319703c48c8ca48e7b2
+
+2016-05-31 13:02 +0000 [b2ce0e354b]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Use correct rdata info access method (Part 2).
+
+	  The pjproject doxygen for rdata->msg_info.info says to call
+	  pjsip_rx_data_get_info() instead of accessing the struct member directly.
+	  You need to call the function mostly because the function will generate
+	  the struct member value if it is not already setup.
+
+	  Change-Id: I4d519385a577f3e9d9193a88125e493cf17fa799
+
+2016-05-30 19:27 +0000 [fe305ccf01]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_mwi_body_generator:  Re-order the body items
+
+	  Re-ordered the body items so Message-Account is second.
+
+	  Messages-Waiting: no
+	  Message-Account: sip:1571@<IP Removed>:5060
+	  Voice-Message: 0/0 (0/0)
+
+	  ASTERISK-26065 #close
+	  Reported-by: Ross Beer
+
+	  Change-Id: If5d35a64656eac98c2dd5e490cc0b2807bed80c3
+
+2016-05-30 10:58 +0000 [e8abfdcdc5]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Move to pjproject 2.5
+
+	  Although all the patches we had against 2.4.5 were applied by Teluu,
+	  a new bug was introduced preventing re-use of tcp and tls transports
+	  This patch removes all the previous patches against 2.4.5, updates
+	  the version to 2.5, and adds a new patch to correct the transport
+	  re-use problem.
+
+	  Change-Id: I0dc6c438c3910f7887418a5832ca186aea23d068
+
+2016-05-27 12:25 +0000 [37d039fdf3]  Rusty Newton <rnewton@digium.com>
+
+	* res_pjsip: Add clarifying documentation to PJSIP_HEADER help text
+
+	  Added notes about when you can read or write headers. Specifically
+	  about being able to read on the inbound channel and write on an
+	  outbound channel.
+
+	  ASTERISK-26063 #close
+	  Reported by: Private Name
+	  Tested by: Rusty Newton
+
+	  Change-Id: Ibeb64af17d1f6451028b3c29855a3f151a01d8c5
+
+2016-05-25 18:30 +0000 [03d5b3ce5c]  Richard Mudgett <rmudgett@digium.com>
+
+	* pjsip_distributor.c: Use correct rdata info access method.
+
+	  The pjproject doxygen for rdata->msg_info.info says to call
+	  pjsip_rx_data_get_info() instead of accessing the struct member directly.
+	  You need to call the function mostly because the function will generate
+	  the struct member value if it is not already setup.
+
+	  Change-Id: Iafe8b01242b7deb0ebfdc36685e21374a43936d2
+
+2016-05-20 13:56 +0000 [859bbec09b]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* app_voicemail: fix bugs, imap mm_status log change to debug
+
+	  Fixed some bugs:
+	  - create dirpath when save downloading message from IMAP storage.
+	  - create IMAP folder if not exists when saving to IMAP storage
+	  - check if file successfully opened before write to it
+	  - some IMAP checks
+	  - remove non-standard flag 'Unseen'
+	  etc
+
+	  Change to debug IMAP mm_status log instead of verbose.
+
+	  Remove unused X-Asterisk-VM-Caller-channel message header
+	  for security reason. The clients should not know name of peer/endpoint.
+
+	  ASTERISK-26045 #close
+
+	  Change-Id: I7f83d88b69b36934e2539c114b9fb612deed971b
+
+2016-05-19 14:56 +0000 [230686f4ec]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: add "via_addr", "via_port", "call_id" to contact
+
+	  As res_pjsip_nat rewrites contact's address, only the last Via header
+	  can contain the source address of registered endpoint.
+	  Also Call-Id header may contain the source address of registered
+	  endpoint.
+
+	  Added "via_addr", "via_port", "call_id" to contact.
+	  Added new fields ViaAddress, CallID to AMI event ContactStatus.
+
+	  ASTERISK-26011
+
+	  Change-Id: I36bcc0bf422b3e0623680152d80486aeafe4c576
+
+2016-05-24 16:56 +0000 [04c12561a7]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: chatty verbose messages
+
+	  There are a lot of verbose messages about Endpoint and Contact status
+	  changes if there are many dynamic endpoints.
+	  The patch sets verbose level 2 for Endpoint status changes
+	  and verbose level 3 for Contact status changes.
+
+	  ASTERISK-26055 #close
+
+	  Change-Id: Ie64e261ddbbc41bfff0f0190241152cc123fe6d7
+
+2016-02-12 09:59 +0000 [a42bea3314]  Corey Farrell <git@cfware.com>
+
+	* threadpool: Fix potential data race.
+
+	  worker_start checked for ZOMBIE status without holding a lock.  All
+	  other read/write of worker status are performed with a lock, so this
+	  check should do the same.
+
+	  ASTERISK-25777 #close
+
+	  Change-Id: I5e33685a5c26fdb300851989a3b82be8c4e03781
+
+2016-05-18 10:58 +0000 [a32616d60c]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* Makefile: remove OSARCH check for init install
+
+	  There are more specific checks for the platform.
+
+	  Specifically this allows installing OS/X init scripts.
+
+	  ASTERISK-26038 #close
+
+	  Change-Id: If08933621145b10362a0cfe73c079301d9c13f50
+	  Signed-off-by: Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+2016-05-21 05:42 +0000 [9ddaab789e]  Jesper (License 5518)
+
+	* func_curl: Don't trim response text on non-ASCII characters
+
+	  The characters 0x80-0xFF were trimmed as well as 0x00-0x20 because of
+	  a signed comparison.
+
+	  ASTERISK-25669 #close
+	  Reported by: Jesper
+	  patches:
+	    strings.curl.trim.patch submitted by Jesper (License 5518)
+
+	  Change-Id: Ia51e169f24e3252a7ebbaab3728630138ec6f60a
+
+2016-05-20 16:59 +0000 [9453d1187a]  Richard Mudgett <rmudgett@digium.com>
+
+	* parking.h: Update ast_parking_park_call() doxygen to reality.
+
+	  ASTERISK-26029
+
+	  Change-Id: I2db14d102a48d3224010e6d1c69e856373cc1260
+
+2016-05-10 14:30 +0000 [cd89501d48]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* func_odbc: single database connection should be optional
+
+	  func_odbc was changed in Asterisk 13.9.0
+	  to make func_odbc use a single database connection per DSN
+	  because of reported bug ASTERISK-25938
+	  with MySQL/MariaDB LAST_INSERT_ID().
+
+	  This is drawback in performance when func_odbc is used
+	  very often in dialplan.
+
+	  Single database connection should be optional.
+
+	  ASTERISK-26010
+
+	  Change-Id: I57d990616c957dabf7597dea5d5c3148f459dfb6
+
+2016-05-20 09:39 +0000 [c0b190dd9a]  Mark Michelson <mmichelson@digium.com>
+
+	* res_pjsip: Match dialogs on responses better.
+
+	  When receiving an incoming response to a dialog-starting INVITE, we were
+	  not matching the response to the INVITE dialog. Since we had not
+	  recorded the to-tag to the dialog structure, the PJSIP-provided method
+	  to find the dialog did not match.
+
+	  Most of the time, this was not a problem, because there is a fall-back
+	  that makes the response get routed to the same serializer that the
+	  request was sent on. However, in cases where an asynchronous DNS lookup
+	  occurs in the PJSIP core, the thread that sends the INVITE is not
+	  actually a threadpool serializer thread. This means we are unable to
+	  record a serializer to handle the incoming response.
+
+	  Now, imagine what happens when an INVITE is sent on a non-serialized
+	  thread, and an error response (such as a 486) arrives. The 486 ends up
+	  getting put on some random threadpool thread. Eventually, a hangup task
+	  gets queued on the INVITE dialog serializer. Since the 486 is being
+	  handled on a different thread, the hangup task can execute at the same
+	  time that the 486 is being handled. The hangup task assumes that it is
+	  the sole owner of the INVITE session and channel, so it ends up
+	  potentially freeing the channel and NULLing the session's channel
+	  pointer. The thread handling the 486 can crash as a result.
+
+	  This change has the incoming response match the INVITE transaction, and
+	  then get the dialog from that transaction. It's the same method we had
+	  been using for matching incoming CANCEL requests. By doing this, we get
+	  the INVITE dialog and can ensure that the 486 response ends up being
+	  handled by the same thread as the hangup, ensuring that the hangup runs
+	  after the 486 has been completely handled.
+
+	  ASTERISK-25941 #close
+	  Reported by Javier Riveros
+
+	  Change-Id: I0d4cc5d07e2a8d03e9db704d34bdef2ba60794a0
+
+2016-05-19 11:41 +0000 [ddcf983e39]  Joshua Colp <jcolp@digium.com>
+
+	* res_sorcery_astdb: Filter fields to only the registered ones.
+
+	  This change introduces the same filtering that is done in res_sorcery_realtime
+	  to the res_sorcery_astdb module. This allows persisted sorcery objects
+	  that may contain unknown fields to still be read in from the AstDB
+	  and used. This is particularly useful when switching between different
+	  versions of Asterisk that may have introduced additional fields.
+
+	  ASTERISK-26014 #close
+
+	  Change-Id: Ib655130485a3ccfd635b7ed5546010ca14690fb2
+
+2016-05-09 21:40 +0000 [39fedfa423]  snuffy <snuffy22@gmail.com>
+
+	* res_pjsip_empty_info: Respond to empty SIP INFO packets
+
+	  Some SBCs require responses to empty SIP INFO packets
+	  after establishing call via INVITE, if not responded to
+	  they may drop your call after unspecified timeout of X minutes.
+
+	  They are identified by having no Content-Type, check for this
+	  and respond with 200 - OK message.
+
+	  ASTERISK-24986 #close
+	  Reported-by: Ilya Trikoz, Federico Santulli
+
+	  Change-Id: Ib27e4f07151e5aef28fa587e4ead36c5b87c43e0
+
+2016-05-18 07:54 +0000 [935e0496c4]  gtjoseph <gjoseph@digium.com>
+
+	* udptl:  Don't eat sequence numbers until OK is received
+
+	  Scenario:
+	  Local fax -> Asterisk w/ firewall -> Provider -> Remote fax
+
+	  * Local fax starts rtp call to remote fax
+	  * Remote fax starts t38 call back to local fax.
+	  * Local fax sends t38 no-signal to Asterisk before sending an OK.
+	  * udptl processes the frame and increments the expected sequence number.
+	  * chan_sip drops the frame because the call isn't up so nothing goes out
+	    the external interface to open the port for incoming packets.
+	  * Local fax sends OK and Asterisk sends OK to the remote fax.
+	  * Remote fax sends t38 packets which are dropped by the firewall.
+	  * Local fax re-sends t38 no-signal with the same sequence number.
+	  * udptl drops the frame because it thinks it's a dup.
+	  * Still no outgoing packets to open the firewall.
+	  * t38 negotiation fails.
+
+	  The patch drops frames t38 received before udptl sequence processing
+	  when the call hasn't been answered yet.  The second no-signal frame
+	  is then seen as new and is relayed out the external interface which
+	  opens the port and allows negotiation to continue.
+
+	  ASTERISK-26034 #close
+
+	  Change-Id: I11744b39748bd2ecbbe8ea84cdb4f3c5943c5af9
+
+2016-05-17 11:14 +0000 [77e8ec162b]  gtjoseph <gjoseph@digium.com>
+
+	* chan_sip:  Prevent extra Session-Expires headers from being added
+
+	  When chan_sip does a re-INVITE to refresh a session and authentication
+	  is required, the INVITE with the Authorization header containes a
+	  second Session-Expires header without the ";refersher=" parameter.
+	  This is causing some proxies to return a 400.  Also, when Asterisk is
+	  the uas and the refresher, it is including the Session-Expires and
+	  Min-SE headers in OPTIONS messages which is not allowed per RFC4028.
+
+	  This patch (based on the reporter's) Checks to see if a Session-Expires
+	  header is already in the message before adding another one.  It also
+	  checks that the method is INVITE or UPDATE.
+
+	  ASTERISK-26030 #close
+
+	  Change-Id: I58a7b07bab5a3177748d8a7034fb8ad8e11ce1d9
+
+2016-05-16 15:29 +0000 [3f6ef63099]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip_outbound_registration:  Clean up state when registration is deleted
+
+	  Nothing was cleaning up the registration state object when ast_sorcery_delete
+	  was called on a registration.  So, the registration was deleted from sorcery
+	  but the state object went right on refreshing the registration (or failing
+	  to refresh the registration) with the peer.
+
+	  * Added a 'deleted' observer on registration that removes the state object.
+
+	  ASTERISK-25964 #close
+	  Reported-by Matt Jordan
+
+	  Change-Id: I2db792145cdb1f72ebbf57dd9099596dbbf12c23
+
+2016-05-15 19:05 +0000 [b6f9392a12]  gtjoseph <gjoseph@digium.com>
+
+	* res_pjsip:  Set TCP_NODELAY on TCP transports
+
+	  Although it's perfectly legal to place multiple SIP messages in the same packet,
+	  it can cause problems because the Linux default is to enable Path MTU Discovery
+	  which sets the Don't Fragment bit on the packets. If adding a second message to
+	  the packet causes the MTU to be exceeded, and the destination isn't equipped to
+	  send a FRAGMENTATION NEEDED response to a large packet, the packet will just be
+	  dropped.
+
+	  We can't specifically tell the stack to send only 1 message per packet, but we
+	  can turn on TCP_NODELAY when we create the transport. This will at least tell
+	  the stack to send packets as soon as possible.
+
+	  ASTERISK-26005 #close
+	  Reported-by: Ross Beer
+
+	  Change-Id: I820f23227183f2416ca5e393bec510e8fe1c8fbd
+
+2016-05-14 21:48 +0000 [361a16f316]  Matt Jordan <mjordan@digium.com>
+
+	* configs/samples/pjsip.conf.sample: Fix typo
+
+	  A ':' is not a valid token for starting a comment.
+
+	  Change-Id: I123592d93a83d1bdde3e352822881eb9da85e5ad
+
+2016-05-12 07:08 +0000 [f91a7dc993]  Matt Jordan <mjordan@digium.com>
+
+	* res/res_hep_pjsip: Fix reported local IP address when bound to 'any'
+
+	  When bound to an 'any' address, e.g., 0.0.0.0, PJSIP reports as its
+	  local address the 'any' address, as opposed to the IP address we
+	  actually received the packet on. This can cause some confusion in Homer,
+	  as it will dutifully report what we send it.
+
+	  This patch uses the PJSIP inspection routines to determine which IP
+	  address we probably received the packet on based on the remote party's
+	  IP address. In the event that this fails, it falls back to the IP
+	  address natively reported by the transport.
+
+	  Change-Id: I076f835d2aef489e1ee1d01595b211eb2ce62da3
+
+2016-05-14 12:29 +0000 [9de5cd209e]  Sean Bright <sean.bright@gmail.com>
+
+	* res_ari: Correct Location headers returned by some ARI resources
+
+	  The Location headers returned by:
+
+	   * /bridges/{bridgeId}/play
+	   * /bridges/{bridgeId}/record
+	   * /channels/{channelId}/play
+	   * /channels/{channelId}/record
+
+	  Did not have the '/ari' prefix, and in the case of the 'play' resources, were
+	  using 'playback' instead of 'playbacks.'
+
+	  Change-Id: I957c58a3a1471bf477dae7c67faa1b74fcd9241c
+
+2016-05-13 11:38 +0000 [524a302974]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: Endpoint IP Access Controls
+
+	  With the old SIP module we can use IP access controls per peer.
+	  PJSIP module missing this feature.
+
+	  This patch added next configuration Endpoint options:
+	      "acl" - list of IP ACL section names in acl.conf
+	      "deny" - List of IP addresses to deny access from
+	      "permit" - List of IP addresses to permit access from
+	      "contact_acl" - List of Contact ACL section names in acl.conf
+	      "contact_deny" - List of Contact header addresses to deny
+	      "contact_permit" - List of Contact header addresses to permit
+
+	  This patch also better logging failed request:
+	      add custom message instead of "No matching endpoint found"
+	      add SIP method to logging
+
+	  ASTERISK-25900
+
+	  Change-Id: I456dea3909d929d413864fb347d28578415ebf02
+
+2016-05-11 20:17 +0000 [89ae4466ea]  Matt Jordan <mjordan@digium.com>
+
+	* res_hep: Provide an option to pick the UUID type
+
+	  At one point in time, it seemed like a good idea to use the Asterisk
+	  channel name as the HEP correlation UUID. In particular, it felt like
+	  this would be a useful identifier to tie PJSIP messages and RTCP
+	  messages together, along with whatever other data we may eventually send
+	  to Homer. This also had the benefit of keeping the correlation UUID
+	  channel technology agnostic.
+
+	  In practice, it isn't as useful as hoped, for two reasons:
+	  1) The first INVITE request received doesn't have a channel. As a
+	     result, there is always an 'odd message out', leading it to be
+	     potentially uncorrelated in Homer.
+	  2) Other systems sending capture packets (Kamailio) use the SIP Call-ID.
+	     This causes RTCP information to be uncorrelated to the SIP message
+	     traffic seen by those capture nodes.
+
+	  In order to support both (in case someone is trying to use res_hep_rtcp
+	  with a non-PJSIP channel), this patch adds a new option, uuid_type, with
+	  two valid values - 'call-id' and 'channel'. The uuid_type option is used
+	  by a module to determine the preferred UUID type. When available, that
+	  source of a correlation UUID is used; when not, the more readily available
+	  source is used.
+
+	  For res_hep_pjsip:
+	   - uuid_type = call-id: the module uses the SIP Call-ID header value
+	   - uuid_type = channel: the module uses the channel name if available,
+	                          falling back to SIP Call-ID if not
+	  For res_hep_rtcp:
+	   - uuid_type = call-id: the module uses the SIP Call-ID header if the
+	                          channel type is PJSIP and we have a channel,
+	                          falling back to the Stasis event provided
+	                          channel name if not
+	   - uuid_type = channel: the module uses the channel name
+
+	  ASTERISK-25352 #close
+
+	  Change-Id: Ide67e59a52d9c806e3cc0a797ea1a4b88a00122c
+
+2016-05-10 02:56 +0000 [a73d79c22f]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* basic-cfg: asterisk.conf: remove [directories]
+
+	  A minimal configuration does not need to explicitly spell out the
+	  directories. The built-in defaults will do just fine. In many cases
+	  they are wrong.
+
+	  Change-Id: Id1a671e5c5e9923765a4156b57f9f7e263fdd26c
+	  Signed-off-by: Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+2016-05-10 03:06 +0000 [1c56de9453]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* basic-cfg: asterisk.conf: defaults of options
+
+	  Note the default of remmed-out options. To clarify that those values are
+	  not the defaults.
+
+	  Change-Id: I849c29b7a710f0abc37355fcb5bfee335ae30738
+	  Signed-off-by: Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+2016-05-10 03:08 +0000 [d7af591c59]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* basic-cfg: asterisk.conf: debug level 5 spams
+
+	  Don't suggest users to use debug level 5, which spews (usually
+	  non-useful) debug information. Reduce the suggestion to (an
+	  arbitrarily-selected) level 2.
+
+	  Change-Id: Ib53195f78945970956ff59ef13fa89b90e0fcd60
+	  Signed-off-by: Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+2016-05-10 03:10 +0000 [9b7db18fc1]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* basic-cfg: asterisk.conf: don't set languages
+
+	  * No need to set language in a miniml configuration. 'en' will do just
+	    fine.
+	  * It would be useful to have an example of setting it to a different
+	    language.
+	  * Setting the documentation language explicitly is likewise not
+	    required. Setting it to a different value is not common. At least
+	    until there is a set of translated documentation.
+
+	  Change-Id: I94d91ea34e129925f25af81ef8dc0906fb568cb7
+	  Signed-off-by: Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+2016-05-10 08:17 +0000 [eec539a46e]  Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+	* followme: delete the right recorded name file
+
+	  FollowMe with the option a records the name of the caller and plays it
+	  to the callee. However it has failed to clean up that recorded file
+	  as it tried to delete the file name without the '.sln' extension.
+
+	  ASTERISK-26008 #close
+
+	  Change-Id: I79d7b1be7d5cde57bf076d9389e2a8a4422776ec
+	  Signed-off-by: Tzafrir Cohen <tzafrir.cohen@xorcom.com>
+
+2016-05-12 14:36 +0000 [02d30e171e]  Mark Michelson <mmichelson@digium.com>
 
 	* Use doubles instead of floats for conversions when comparing strings.
 
@@ -51,93 +12251,421 @@
 
 	  Change-Id: I83ca7944aae8b7cd994b254c78ec02411d321070
 
-2016-05-12 15:18 +0000 [d27ee3b1bf]  Mark Michelson <mmichelson@digium.com>
+2016-05-12 09:13 +0000 [e2df15bae9]  gtjoseph <gjoseph@digium.com>
 
-	* res_sorcery_astdb: Fix creation of retrieved objects.
+	* pjsip_distributor:  Add missing newline to NOTICE
 
-	  The contents of this commit come from a portion of commit
-	  a01ce2b88912cd802bb045e40fe264906e55bc45 of the 13 branch.
+	  There was a newline missing from the end of the "no matching endpoint" notice.
 
-	  The commit referenced above's main point was to introduce some
-	  performance enhancements for realtime. However, mixed in with that was a
-	  bug fix for sorcery's astdb backend. The astdb was using an empty
-	  objectset to create an object.
+	  Change-Id: Idc11fe5bc0354072291663dbffe648c471e39181
 
-	  This, combined with the floating point conversion bug, was what was
-	  contributing to contacts being deleted early.
+2016-05-10 10:19 +0000 [a94a12bbf7]  Sebastian Damm <damm@sipgate.de>
 
-	  ASTERISK-26007 #close
-	  Reported by Greg Siemon
+	* res_pjsip_outbound_registration: generate correct Contact URI for TLS
 
-	  Change-Id: I84594079356a6fb2d2f61d56bf644e5409925ee2
+	  There are two types of SIP URIs indicating a secure transport:
+	  * sips:user@example.org
+	  * sip:user@example.org;transport=tls
 
-2016-05-09 13:04 +0000  Asterisk Development Team <asteriskteam@digium.com>
+	  When using a sips URI, Asterisk checks incoming INVITEs and answers from
+	  the other side for sips URIs, and rejects the packet if there are only
+	  sip URIs. So Asterisk should only generate a sips Contact URI if the
+	  other side supports it.
 
-	* asterisk 13.9.0 Released.
+	  This patch makes Asterisk generate either a sip or sips Contact URI
+	  depending on the format of the server URI.
 
-2016-05-09 08:04 +0000 [3bb17c43b0]  Joshua Colp <jcolp@digium.com>
+	  If you want a sip URI, use:
+	  server_uri=sip:example.org\;transport=tls
 
-	* Release summaries: Add summaries for 13.9.0
+	  If you want a sips URI, use:
+	  server_uri=sips:example.org
 
-2016-05-09 08:01 +0000 [549465b89a]  Joshua Colp <jcolp@digium.com>
+	  ASTERISK-25990 #close
+	  Reported-by: Sebastian Damm
 
-	* Release summaries: Remove previous versions
+	  Change-Id: I5ae57d6531ce940b5fc64d5cd2673e60db0f9ba2
 
-2016-05-09 08:01 +0000 [d805a1c1ab]  Joshua Colp <jcolp@digium.com>
+2016-05-05 16:41 +0000 [36d66a23e0]  Alexei Gradinari <alex2grad@gmail.com>
 
-	* .version: Update for 13.9.0
+	* logger: Add PID to syslog messages.
 
-2016-05-09 08:01 +0000 [7c2ff2c29f]  Joshua Colp <jcolp@digium.com>
+	  During refactoring of this support the addition of
+	  the PID to messages was removed. This change adds it
+	  back in.
 
-	* .lastclean: Update for 13.9.0
+	  ASTERISK-25538 #close
 
-2016-05-09 08:01 +0000 [addd49f1a4]  Joshua Colp <jcolp@digium.com>
+	  Change-Id: Ie2d43b0652e59b7ac319a7dba94501540d70ba36
 
-	* realtime: Add database scripts for 13.9.0
+2016-05-11 14:07 +0000 [37214b0bdf]  Matt Jordan <mjordan@digium.com>
 
-2016-05-03 12:22 +0000  Asterisk Development Team <asteriskteam@digium.com>
+	* configure: Fix errors with AST_UNDEFINED_SANITIZER/AST_LEAK_SANITIZER
 
-	* asterisk 13.9.0-rc2 Released.
+	  When running on a system that does not support or use AST_UNDEFINED_SANITIZER
+	  or AST_LEAK_SANITIZER, the configure script would incorrectly set those
+	  constants to a blank value, e.g., 'AST_UNDEFINED_SANITIZER='. This would
+	  cause menuselect to error out, complaining that a blank value is not a
+	  valid option. This patch corrects the issue by setting the value to 0 if
+	  the options that those constants enable/disable is not found.
 
-2016-05-03 07:21 +0000 [45b84418ac]  Joshua Colp <jcolp@digium.com>
+	  Change-Id: Ib39814aaf940f308d500c1e026edb3d70de47fba
 
-	* Release summaries: Add summaries for 13.9.0-rc2
+2016-05-03 15:43 +0000 [49b25a0956]  Kevin Harwell <kharwell@digium.com>
 
-2016-05-03 07:21 +0000 [0581fa02e5]  Joshua Colp <jcolp@digium.com>
+	* res_pjsip_outbound_publish: state potential dropped on reloads/realtime fetches
 
-	* Release summaries: Remove previous versions
+	  When reloading, or fetching realtime data, if the "apply" failed for any
+	  numerous reasons the current state object would not be maintained. This
+	  potentially resulted in publishes being stopped for some states/clients when
+	  they should not have been.
 
-2016-05-03 07:21 +0000 [31b9b476fc]  Joshua Colp <jcolp@digium.com>
+	  This patch makes it so the current state object is kept upon any type of reload/
+	  fetch failures.
 
-	* .version: Update for 13.9.0-rc2
+	  Change-Id: Iab6020c116d628ed2ae81183e987e2eaa3c90b30
 
-2016-05-03 07:21 +0000 [b64d540059]  Joshua Colp <jcolp@digium.com>
+2016-05-03 15:31 +0000 [1b5c91b7be]  Kevin Harwell <kharwell@digium.com>
 
-	* .lastclean: Update for 13.9.0-rc2
+	* res_pjsip_outbound_publish: Potential crash due to off nominal path
 
-2016-05-03 07:21 +0000 [a9467ce7d7]  Joshua Colp <jcolp@digium.com>
+	  It was possible for the explicit publish destroy function to be called without
+	  the pjsip client ever being initialized. This fix checks to make sure there is
+	  a client to destroy before attempting.
 
-	* realtime: Add database scripts for 13.9.0-rc2
+	  Change-Id: I8eea1bfa3bd472149bfc255310be2a6248688f5c
 
-2016-04-27 13:23 +0000 [b470aabb7b]  Mark Michelson <mmichelson@digium.com>
+2016-05-03 15:35 +0000 [10de553c9d]  Kevin Harwell <kharwell@digium.com>
 
-	* func_odbc: Check connection status before executing queries.
+	* res_pjsip_outbound_publishing: After unloading the library won't load again
 
-	  A recent change to func_odbc made it so that a single connection was
-	  maintained per DSN. The problem was that the code was optimistic about
-	  the health of the connection after initially opening it and did nothing
-	  to re-connect in case the connection had died.
+	  The same thing was happening in res_pjsip_publish_asterisk. When the library
+	  was unloaded it did not unregister the object type from sorcery. Subsequent
+	  loads resulted in a failed load due to the sorcery type already existing.
 
-	  This change adds a check before executing a query to ensure that the
-	  connection to the database is still up and running.
+	  Change-Id: Ifdc25e94e4cd40bc5a19eb4d0a00b86c2e9fedc9
 
-	  ASTERISK-25963 #close
-	  Reported by Ross Beer
+2016-05-03 14:59 +0000 [1a833b9739]  Kevin Harwell <kharwell@digium.com>
 
-	  Change-Id: Id33c86eb04ff48ca088bb2e3086c27b3b683491d
-	  (cherry picked from commit 677d5b515151b51ed8be5e760ce0c7b99dae2761)
+	* res_pjsip_outbound_publish: Ref leak in off nominal callback paths
+
+	  There were a few spots where the client object's reference was being leaked in
+	  sip_outbound_publish_callback. This patch cleans up those leaks.
+
+	  Change-Id: I485d0bc9335090f373026f77c548042e258461df
+
+2016-05-03 15:39 +0000 [4752ef02e0]  Kevin Harwell <kharwell@digium.com>
+
+	* res_pjsip_outbound_publish: Won't unload if condition wait times out
+
+	  When res_pjsip_outbound_publish unloads it has to wait for all current
+	  publishing objects to get done. However if the wait condition times out
+	  then it does not fail the unload. This sometimes results in an infinite
+	  loop check while unloading. This patch now fails the unload operation if
+	  the condition times out.
+
+	  Change-Id: Id57b8cbed9d61222690fcba1e4f18e259df4c7ec
+
+2016-05-05 11:37 +0000 [4d063814ba]  Kevin Harwell <kharwell@digium.com>
+
+	* res_pjsip_authenticator_digest: Don't use source port in nonce verification
+
+	  From the issue reporter:
+	  "res_pjsip_outbound_authenticator_digest builds a nonce that is a hash of
+	  the timestamp, the source address, the source port, a server UUID that is
+	  calculated at startup, and the authentication realm.
+
+	  Rather than caching nonces that we create, we instead attempt to re-calculate
+	  the nonce when receiving an incoming request with authentication. We then
+	  compare the re-calculated nonce to the incoming nonce, and if they don't match,
+	  then authentication has failed early.
+
+	  The problem is that it is possible, especially when using TCP, to receive two
+	  requests from the same endpoint but have differing source ports for those
+	  requests. Asterisk itself commonly will use different source ports for
+	  outbound TCP requests."
+
+	  This patch removes the source port dependency when building the nonce.
+
+	  ASTERISK-25978 #close
+
+	  Change-Id: I871b5f4adce102df1c4988066283095ec509dffe
+
+2016-05-07 14:39 +0000 [fb6227a372]  gtjoseph <gjoseph@digium.com>
+
+	* config_transport:  Tell pjproject to allow all SSL/TLS protocols
+
+	  The default tls settings for pjproject only allow TLS 1, TLS 1.1 and TLS 1.2.
+	  SSL is not allowed.   So, even if you specify "sslv3" for a transport method,
+	  it's silently ignored and one of the TLS protocols is used.  This was a new
+	  behavior of pjsip_tls_setting_default() in 2.4 (when tls.proto was added) that
+	  we never caught.
+
+	  Now we need to set tls.proto = 0 after we call pjsip_tls_setting_default().
+	  This tells pjproject to set the socket protocol to match the method.
+
+	  ASTERISK-26004 #close
+
+	  Change-Id: Icfb55c1ebe921298dedb4b1a1d3bdc3ca41dd078
+
+2016-05-04 02:40 +0000 [2db17a793c]  Jaco Kroon <jaco@uls.co.za>
+
+	* app_confbridge: Add a regcontext option for confbridge bridge profiles.
+
+	  This patch allows for having app_confbridge register the name of the
+	  conference as an extension into a specific context, similar to
+	  regcontext for chan_sip.  This variant is not quite as involved as the
+	  one in chan_sip and doesn't allow for multiple contexts or custom
+	  extensions, you can only specify the context and the conference name
+	  will always be used as the extension to register.
+
+	  ASTERISK-25989 #close
+
+	  Change-Id: Icacf94d9f2b5dfd31ef36f6cb702392619a7902f
+
+2016-05-08 20:19 +0000 [2a7130b8b0]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Check for python-dev and TEST_FRAMEWORK
+
+	  The pjsua and pjsystest apps are now built only if TEST_FRAMEWORK is set.
+	  The python bindings are now built only if TEST_FRAMEWORK is set and a
+	  python development package is installed.
+
+	  libresample was also disabled.
+
+	  ASTERISK-25993 #close
+	  Reported-by: Joshua Colp
+
+	  Change-Id: If4e91c503a02f113d5b71bc8b972081fa3ff6f03
+
+2016-05-04 15:16 +0000 [72eb7c8301]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: module load priority
+
+	  The res_pjsip_authenticator_digest, res_pjsip_endpoint_identifier_*
+	  and res_pjsip_registrar modules should load ASAP
+	  to avoid "No matching endpoint found" for legitimate endpoint.
+
+	  ASTERISK-25994
+
+	  Change-Id: Iac95d95ad031e0be104189d29e923a2ad7c24a1b
+
+2016-05-04 03:17 +0000 [dd00c71aae]  Chris Trobridge <christ.trobridge@ultra-aep.com>
+
+	* config_options.c: Expand #ifdef to contain whole if statement.
+
+	  ASTERISK-25956 #close
+
+	  Change-Id: If6961ec54be276d5ab4f012ee7e7b420cb45de38
+
+2016-05-05 15:16 +0000 [e6eb17efd9]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* stasis_endpoints: Add new Status and Headers to ContactStatus
+
+	  ASTERISK-25903 added a new headers to AMI Event ContactStatusDetail.
+	  ASTERISK-25904 added a new Status to AMI Event ContactStatusDetail.
+	  These additions should be also in stasis_endpoints
+	  to include in command "manager show event ContactStatus"
+
+	  Change-Id: I7610ad02a998e1f26c20caa27aa50279d0164f6a
+
+2016-05-05 05:07 +0000 [fa11f4c920]  Joshua Colp <jcolp@digium.com>
+
+	* file: Ensure nativeformats remains valid for lifetime of use.
+
+	  It is possible for the nativeformats of a channel to change
+	  throughout its lifetime. As a result a user of it needs to either
+	  ensure the channel is locked when accessing the formats or keep
+	  a reference to the nativeformats themselves.
+
+	  This change fixes the file playback support so it keeps a
+	  reference to the nativeformats when accessing things.
+
+	  ASTERISK-25998 #close
+
+	  Change-Id: Ie45b65475e1481ddf05b874ee48f63e39fff8915
+
+2016-04-15 09:32 +0000 [9c2032240e]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: improve realtime performance
+
+	  This patch modified pjsip_options to retrieve only
+	  permament contacts for aor if the qualify_frequency is > 0
+	  and persisted contacts if the qualify_frequency is > 0.
+
+	  This patch also fixed a bug in res_sorcery_astdb.
+	  res_sorcery_astdb doesn't save object data retrived from astdb.
+
+	  ASTERISK-25826
+
+	  Change-Id: I1831fa46c4578eae5a3e574ee3362fddf08a1f05
+
+2016-05-04 16:11 +0000 [fe38d21c2a]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* pjsip: Added "reg_server" to contacts (fixed alembic)
+
+	  ASTERISK-25931
+
+	  Change-Id: Icc4321a88f5c93ff809da3f372eebbf69c6a8549
+
+2016-04-07 16:33 +0000 [7a14e669f0]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip/AMI: add contact.updated event
+
+	  With the old SIP module AMI sends PeerStatus event on every
+	  successfully REGISTER requests, ie, on start registration,
+	  update registration and stop registration.
+
+	  With PJSIP AMI sends ContactStatus only when status is changed.
+	  Regarding registration:
+	  on start registration - Created
+	  on stop registration - Removed
+	  but on update registration nothing
+
+	  This patch added contact.updated event.
+
+	  ASTERISK-25904
+
+	  Change-Id: I8fad8aae9305481469c38d2146e1ba3a56d3108f
+
+2016-05-02 16:08 +0000 [06d4ac0355]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_fax: add FAXMODE variable
+
+	  The app_fax set FAXMODE variable, but res_fax missing this feature.
+	  This patch add FAXMODE variable which is set to either "audio" or "T38".
+
+	  ASTERISK-25980
+
+	  Change-Id: Ie3dcbfb72cc681e9e267a60202f7fb8723a51b6b
+
+2016-05-02 16:52 +0000 [2d17fe06c5]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_fax/t38_gateway: Peer V.21 session is created on wrong channel
+
+	  The channel and peer V.21 sessions are created on the same channel now.
+	  The peer V.21 session should be created only on peer channel
+	  when one of channel can handle T.38.
+
+	  Also this patch enable debug for T.38 gateway session
+	  if global fax debug enabled.
+
+	  ASTERISK-25982
+
+	  Change-Id: I78387156ea521a77eb0faf170179ddd37a50430e
+
+2016-05-01 02:21 +0000 [a2f19d82a8]  Diederik de Groot <dkgroot@talon.nl>
+
+	* configs/basic-pbx/asterisk.conf: contains incorrect path separator
+
+	  Note: When packagers use these files (as an example) the paths are never
+	  really used when they are split using '='.
+
+	  Note: Thirdparty applications will also have trouble parsing the file when
+	  expecting '=>'.
+
+	  Change-Id: I0ada647f588e81f023fb1333ca15a1a333fd6004
+
+2016-04-30 17:52 +0000 [f39089f17c]  gtjoseph <gjoseph@digium.com>
+
+	* pjproject_bundled:  Various fixes discovered during testing of OSes
+
+	  For all OSes:
+	  * Disabled third-party codecs in pjproject and added
+	    '--disable-speex-codec --disable-speex-aec --disable-gsm-codec' to the
+	    configure options since we don't use the pjsip codec capability.
+
+	  FreeBSD:
+	  * Added FreeBSD support to install_prereq.
+	  * Changed pjproject/configure.m4 to use $GNU_MAKE instead of hardcoding "make".
+	  * Added __progname and environ to asterisk.exports.in.
+	  * Reverted the use of ldconfig to create shared library symlinks to ln.
+	  * Only enable epoll in pjproject if `uname -s` is Linux.
+	  * Added a patch to pjproject to take the name of the 'make' command from
+	    an environment variable if supplied.  This is needed for the python bindings.
+	    (merged by Teluu into pjproject trunk 5/3/2016)
+	  FreeBSD support isn't complete.  Still some general issues regarding
+	  make/gmake having nothing to do with pjproject.  With some handholding it DOES
+	  build successfully.
+
+	  CentOS:
+	  Added 'patch' and 'bzip2' to install_prereq PACKAGES_RH.
+	  CentOS 6/7 32/64 build and run the pjsip testsuite successfully.
+
+	  Ubuntu:
+	  No changes required.
+	  Ubuntu 15/16 32/64 build and run the pjsip testsuite successfully.
+
+	  Debian:
+	  No changes required.
+	  Debian 6/7/8 32/64 build and run the pjsip testsuite successfully.
+
+	  There will utimately be a follow-up patch to create an install_prereq for
+	  the testsuite as I've discovered a few missing requirements.
+
+	  ASTERISK-25968 #close
+
+	  Change-Id: I5756a07facfc63798115a5e73a8709382fe9259c
+
+2016-03-17 14:29 +0000 [8028fc7585]  Andrew Nagy <andrew.nagy@the159.com>
+
+	* app_voicemail: always copy dynamic struct to avoid race condition
+
+	  Voicemail email addresses can be corrupt or voicemail
+	  emails can end up being sent to the wrong email address if asterisk is
+	  reading voicemail.conf during a reload and processing an email at the
+	  same time. This patch always copies the struct that would otherwise only
+	  be copied once.
+
+	  ASTERISK-24463 #close
+	  Reported by: John Campbell
+	  Tested by: Etienne Lessard
+	  Tested by: Andrew Nagy
+	  Change-Id: I3a0643813116da84e2617291903d0d489b7425fb
+
+2016-04-15 14:26 +0000 [3cb8934de0]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* pjsip: Added "reg_server" to contacts.
+
+	  If the Asterisk system name is set in asterisk.conf, it will be stored
+	  into the "reg_server" field in the ps_contacts table to facilitate
+	  multi-server setups.
+
+	  ASTERISK-25931
+
+	  Change-Id: Ia8f6bd2267809c78753b52bcf21835b9b59f4cb8
+
+2016-04-28 11:35 +0000 [7992923c70]  Richard Mudgett <rmudgett@digium.com>
 
-2016-04-28 16:54 +0000 [e702b9fc40]  gtjoseph <gjoseph@digium.com>
+	* res_pjsip: Start body generator users after suppliers.
+
+	  Change-Id: I8f0b57841feaab56c8a4e821b5ccb4e05e5fbadb
+
+2016-04-28 16:06 +0000 [5dc0e082b2]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Add useful information to some messages.
+
+	  Change-Id: Ia0b2e15773894c599e5c5748bbc70e99f434192a
+
+2016-04-26 15:58 +0000 [f9e416f053]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.c: Fix body generator registration race.
+
+	  Change-Id: Id8752073ef06472a2fd96080f4009fac42843e67
+
+2016-04-26 15:13 +0000 [b1b2019046]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_pubsub.h: Fix doxygen association.
+
+	  Change-Id: I110d3e3572598289fcd4215d966cf0c858f98632
+
+2016-04-25 16:00 +0000 [b7f07fdff5]  Richard Mudgett <rmudgett@digium.com>
+
+	* res_pjsip_outbound_publish.c: Remove redundant flag check.
+
+	  Change-Id: I0da80a3c3e0eae0c52ff27e7412ba027d6f52353
+
+2016-04-28 16:54 +0000 [719ece5659]  gtjoseph <gjoseph@digium.com>
 
 	* pjproject_bundled:  Disable PJSIP_UNESCAPE_IN_PLACE
 
@@ -153,6 +12681,338 @@
 
 	  Change-Id: I28dc0e599b5108f7959b9c46dc8278371b372f88
 
+2016-03-07 18:34 +0000 [38bed4515d]  gtjoseph <george.joseph@fairview5.com>
+
+	* res_pjsip:  Add ability to identify by Authorization username
+
+	  A feature of chan_sip that service providers relied upon was the ability to
+	  identify by the Authorization username.  This is most often used when customers
+	  have a PBX that needs to register rather than identify by IP address.  From my
+	  own experiance, this is pretty common with small businesses who otherwise
+	  don't need a static IP.
+
+	  In this scenario, a register from the customer's PBX may succeed because From
+	  will usually contain the PBXs account id but an INVITE will contain the caller
+	  id.  With nothing recognizable in From, the service provider's Asterisk can
+	  never match to an endpoint and the INVITE just stays unauthorized.
+
+	  The fixes:
+
+	  A new value "auth_username" has been added to endpoint/identify_by that
+	  will use the username and digest fields in the Authorization header
+	  instead of username and domain in the the From header to match an endpoint,
+	  or the To header to match an aor.  This code as added to
+	  res_pjsip_endpoint_identifier_user rather than creating a new module.
+
+	  Although identify_by was always a comma-separated list, there was only
+	  1 choice so order wasn't preserved.  So to keep the order, a vector was added
+	  to the end of ast_sip_endpoint.  This is only used by res_pjsip_registrar
+	  to find the aor.  The res_pjsip_endpoint_identifier_* modules are called in
+	  globals/endpoint_identifier_order.
+
+	  Along the way, the logic in res_pjsip_registrar was corrected to match
+	  most-specific to least-specific as res_pjsip_endpoint_identifier_user does.
+
+	  The order is:
+
+	  username@domain
+	  username@domain_alias
+	  username
+
+	  Auth by username does present 1 problem however, the first INVITE won't have
+	  an Authorization header so the distributor, not finding a match on anything,
+	  sends a securty_alert.  It still sends a 401 with a challenge so the next
+	  INVITE will have the Authorization header and presumably succeed.  As a result
+	  though, that first security alert is actually a false alarm.
+
+	  To address this, a new feature has been added to pjsip_distributor that keeps
+	  track of unidentified requests and only sends the security alert if a
+	  configurable number of unidentified requests come from the same IP in a
+	  configurable amout of time.  Those configuration options have been added to
+	  the global config object.  This feature is only used when auth_username
+	  is enabled.
+
+	  Finally, default_realm was added to the globals object to replace the hard
+	  coded "asterisk" used when an endpoint is not yet identified.
+
+	  The testsuite tests all pass but new tests are forthcoming for this new
+	  feature.
+
+	  ASTERISK-25835 #close
+	  Reported-by: Ross Beer
+
+	  Change-Id: I30ba62d208e6f63439600916fcd1c08a365ed69d
+
+2016-04-27 13:23 +0000 [677d5b5151]  Mark Michelson <mmichelson@digium.com>
+
+	* func_odbc: Check connection status before executing queries.
+
+	  A recent change to func_odbc made it so that a single connection was
+	  maintained per DSN. The problem was that the code was optimistic about
+	  the health of the connection after initially opening it and did nothing
+	  to re-connect in case the connection had died.
+
+	  This change adds a check before executing a query to ensure that the
+	  connection to the database is still up and running.
+
+	  ASTERISK-25963 #close
+	  Reported by Ross Beer
+
+	  Change-Id: Id33c86eb04ff48ca088bb2e3086c27b3b683491d
+
+2016-04-15 11:59 +0000 [df3639700a]  Alexei Gradinari <alex2grad@gmail.com>
+
+	* res_pjsip: disable multi domain to improve realtime performace
+
+	  This patch added new global pjsip option 'disable_multi_domain'.
+	  Disabling Multi Domain can improve Realtime performance by reducing
+	  number of database requests.
+
+	  ASTERISK-25930 #close
+
+	  Change-Id: I2e7160f3aae68475d52742107949a799aa2c7dc7
+
+2016-04-26 11:13 +0000 [949bf6b282]  Joshua Colp <jcolp@digium.com>
+
+	* chan_sip: Give more time for TCP/TLS threads to stop.
+
+	  The unload process currently tells each TCP/TLS to terminate but
+	  does not wait for them to do so. This introduces a race condition
+	  where the container holding the threads may be destroyed before
+	  the threads are able to remove themselves from it. When they
+	  finally do the container is invalid and can't be used causing a
+	  crash.
+
+	  A previous change existed which waited a bit to wait for any
+	  stranglers to finish. This change extends this and waits longer.
+
+	  ASTERISK-25961 #close
+
+	  Change-Id: Idc6262b670ca49ede32061159e323b7b63c6f3c6
+
+2016-04-26 05:48 +0000 [6959f5484b]  Joshua Colp <jcolp@digium.com>
+
+	* app_queue: Fix crash when unloading module.
+
+	  When unloading the app_queue module the members in each queue are
+	  destroyed and as part of this they are removed from the pending
+	  members container. Unfortunately a crash would occur as the container
+	  was destroyed before the members were removed.
+
+	  This change tweaks ordering so the container destruction occurs
+	  after the members are destroyed.
+
+	  ASTERISK-16115
+
+	  Change-Id: I48c728668c55aee3d05b751a5d450fb57e87f44b
+
+2016-04-24 22:51 +0000 [b38f1146e5]  gtjoseph <gjoseph@digium.com>
+
+	* config:  Fix ast_config_text_file_save2 writability check for missing files
+
+	  A patch I did back in 2014 modified ast_config_text_file_save2 to check the
+	  writability of the main file and include files before truncating and re-writing
+	  them.  An unintended side-effect of this was that if a file doesn't exist,
+	  the check fails and the write is aborted.
+
+	  This patch causes ast_config_text_file_save2 to check the writability of the
+	  parent directory of missing files instead of checking the file itself.  This
+	  allows missing files to be created again.  A unit test was also added to
+	  test_config to test saving of config files.
+
+	  The regression was discovered when app_voicemail's passwordlocation=spooldir
+	  feature stopped working.
+
+	  ASTERISK-25917 #close
+	  Reported-by: Jonathan Rose
+
+	  Change-Id: Ic4dbe58c277a47b674679e49daed5fc6de349f80
+
+2016-04-21 23:53 +0000 [29bab0d1a4]  Kirill Katsnelson <kkm@smartaction.com>
+
+	* chan_sip: Make autocreated peers send PeerStatus events
+
+	  Since Stasis has been introduced, an attempt to send AMI messages by an
+	  autocreated peer caused a crash, and all events from autocreated peers were
+	  semi-inadvertently disabled altogether in 0b83761. This change restores the
+	  disabled functionality.
+
+	  ASTERISK-25950
+
+	  Change-Id: Iecc350f23db603fadb2f302064643ebe9664e974
+
+2016-04-21 14:23 +0000 [c345e530f4]  Kevin Harwell <kharwell@digium.com>
+
+	* app_queue: queue members can receive multiple calls
+
+	  It was possible for a queue member that is a member of at least 2 or more
+	  queues to receive mulitiple calls at the same time. This happened because
+	  of a race between when a member was being rung and when the device state
+	  notified the other queue(s) member object of the state change.
+
+	  This patch makes it so when a queue member is being rung it gets added to
+	  a global pool of queue members. If that same member is tried again, e.g.
+	  from another queue, and it is found to already exist in the pending member
+	  container then it will not ring that member.
+
+	  ASTERISK-16115 #close
+
+	  Change-Id: I546dd474776d158c2b6be44205353dee5bac7e48
+
+2016-04-25 08:11 +0000 [c0688a6398]  Javier Acosta <javier.acosta@beeonline.es>
+
+	* Fix case sensitive actions in AMI QueueSummary and QueueStatus
+
+	  ASTERISK-25954 #close
+	  Reported by: Javier Acosta
+
+	  Change-Id: I00be83d45cc7e8385de2523012bd196aafeeb256
+
+2016-04-22 15:25 +0000 [ebf0724a83]  Richard Mudgett <rmudgett@digium.com>
+
+	* test_message.c: Wait longer in case dialplan also processes the test message.
+
+	  Bumped the wait from 1 second to 5 seconds.  The test message was hitting my
+	  default call handler and failing the test because it took longer.
+
+	  Change-Id: I3a03737f25e92983de00548fcc7bbc50dd7544ba
+
+2016-04-12 15:29 +0000 [ba63aa7c9e]  Richard Mudgett <rmudgett@digium.com>
+
+	* Manager: Short circuit AMI message processing.
+
+	  Improve AMI message processing performance if there are no consumers
+	  listening for the messages.  We now skip creating the AMI event message
+	  text strings.
+
+	  Change-Id: I7b22fc5ec4e500d00635c1a467aa8ea68a1bb2b3
+
+2016-04-13 17:54 +0000 [d5ee6acf28]  Richard Mudgett <rmudgett@digium.com>
+
+	* manager.c: Eliminate most RAII_VAR usage.
+
+	  * Made ast_manager_event_blob_create() not allocate the ao2 event object
+	  with a lock as it is not needed.
+
+	  Change-Id: I8e11bfedd22c21316012e0b9dd79f5918f644b7c
+
+2016-04-13 17:09 +0000 [7303e3dc96]  Richard Mudgett <rmudgett@digium.com>
+
+	* manager_channels.c: Fix allocation failure crash.
+
+	  An earlier allocation failure failed to create a channel snapshot for the
+	  AMI HangupRequest/SoftHangupRequest event which resulted in a crash in
+	  channel_hangup_request_cb().  Where the stasis message gets generated
+	  cannot tell if the NULL snapshot returned was because of an allocation
+	  failure or the channel was a dummy channel.
+
+	  * Made channel_hangup_request_cb() check if the channel blob has a
+	  snapshot and exit if it doesn't.
+
+	  * Eliminated the RAII_VAR usage in channel_hangup_request_cb().
+
+	  Change-Id: I0b6a1c4e95cbb7d80b2a7054c6eadecc169dfd24
+
+2016-04-13 13:50 +0000 [1e93f3d723]  Richard Mudgett <rmudgett@digium.com>
+
+	* Bridge system: Fix memory leaks and double frees on impart failure.
+
+	  You cannot reference the passed in features struct after calling
+	  ast_bridge_impart().  Even if the call fails.
+
+	  Change-Id: I902b88ba0d5d39520e670fb635078a367268ea21
+
+2016-04-13 13:20 +0000 [5e388d4188]  Richard Mudgett <rmudgett@digium.com>
+
+	* bridge_softmix.c: Fix crash if channel fails to join mixing tech.
+
+	  softmix_bridge_join() failed because of an allocation failure.  To address
+	  this, the softmix bridge technology now checks if the channel failed to
+	  join softmix successfully.  In addition, the bridge now begins the process
+	  of kicking the channel out of the bridge so we don't have channels
+	  partially in the bridge for very long.
+
+	  * Fix the test_channel_feature_hooks.c unit tests.  The test channel must
+	  have a valid codec to join the simple_bridge technology.  This patch makes
+	  joining a bridge more strict by not allowing partially joined channels to
+	  remain in the bridge.
+
+	  Change-Id: I97e2ade6a2bcd1214f24fb839fda948825b61a2b
+
+2016-03-17 12:28 +0000 [9740277713]  gtjoseph <george.joseph@fairview5.com>
+
+	* res_pjsip:  Add serialized scheduler (res_pjsip/pjsip_scheduler.c)
+
+	  There are several places that do scheduled tasks or periodic housecleaning,
+	  each with its own implementation:
+
+	  * res_pjsip_keepalive has a thread that sends keepalives.
+	  * pjsip_distributor has a thread that cleans up expired unidentified requests.
+	  * res_pjsip_registrar_expire has a thread that cleans up expired contacts.
+	  * res_pjsip_pubsub uses ast_sched directly and then calls ast_sip_push_task.
+	  * res_pjsip_sdp_rtp also uses ast_sched to send keepalives.
+
+	  There are also places where we should be doing scheduled work but aren't.
+	  A good example are the places we have sorcery observers to start registration
+	  or qualify.  These don't work when changes are made to a backend database
+	  without a pjsip reload.  We need to check periodically.
+
+	  As a first step to solving these issues, a new ast_sip_sched facility has
+	  been created.
+
+	  ast_sip_sched wraps ast_sched but only uses ast_sched as a scheduled queue.
+	  When a task is ready to run, ast_sip_task_pusk is called for it. This ensures
+	  that the task is executed in a PJLIB registered thread and doesn't hold up the
+	  ast_sched thread so it can immediately continue processing the queue.  The
+	  serializer used by ast_sip_sched is one of your choosing or a random one from
+	  the res_pjsip pool if you don't choose one.
+
+	  Another feature is the ability to automatically clean up the task_data when the
+	  task expires (if ever).  If it's an ao2 object, it will be dereferenced, if
+	  it's a malloc'd object it will be freed.  This is selectable when the task is
+	  scheduled.  Even if you choose to not auto dereference an ao2 task data object,
+	  the scheduler itself maintains a reference to it while the task is under it's
+	  control.  This prevents the data from disappearing out from under the task.
+
+	  There are two scheduling models.
+
+	  AST_SIP_SCHED_TASK_PERIODIC specifies that the invocations of the task occur at
+	  the specific interval.  That is, every "interval" milliseconds, regardless of
+	  how long the task takes.  If the task takes longer than the interval, it will
+	  be scheduled at the next available multiple of interval.  For exmaple: If the
+	  task has an interval of 60 secs and the task takes 70 secs (it better not),
+	  the next invocation will happen at 120 seconds.
+
+	  AST_SIP_SCHED_TASK_DELAY specifies that the next invocation of the task should
+	  start "interval" milliseconds after the current invocation has finished.
+
+	  Also, the same ast_sched facility for fixed or variable intervals exists.  The
+	  task's return code in conjunction with the AST_SIP_SCHED_TASK_FIXED or
+	  AST_SIP_SCHED_TASK_VARIABLE flags controls the next invocation start time.
+
+	  One res_pjsip.h housekeeping change was made.  The pjsip header files were
+	  added to the top.  There have been a few cases lately where I've needed
+	  res_pjsip.h just for ast_sip calls and had compiles fail spectacularly because
+	  I didn't add the pjsip header files to my source even though I never referenced
+	  any pjsip calls.
+
+	  Finally, a few new convenience APIs were added to astobj2 to make things a
+	  little easier in the scheduler.  ao2_ref_and_lock() calls ao2_ref() and
+	  ao2_lock() in one go.  ao2_unlock_and_unref() does the reverse. A few macros
+	  were also copied from res_phoneprov because I got tired of having to duplicate
+	  the same hash, sort and compare functions over and over again. The
+	  AO2_STRING_FIELD_(HASH|SORT|CMP)_FN macros will insert functions suitable for
+	  aor_container_alloc into your source.
+
+	  This facility can be used immediately for the situations where we already have
+	  a thread that wakes up periodically or do some scheduled work.  For the
+	  registration and qualify issues, additional sorcery and schema changes would
+	  need to be made so that we can easily detect changed objects on a periodic
+	  basis without having to pull the entire database back to check.  I'm thinking
+	  of a last-updated timestamp on the rows but more on this later.
+
+	  Change-Id: I7af6ad2b2d896ea68e478aa1ae201d6dd016ba1c
+
 2016-04-25 21:43 +0000  Asterisk Development Team <asteriskteam@digium.com>
 
 	* asterisk 13.9.0-rc1 Released.
diff -urpN asterisk-13.9.1/Makefile asterisk-13.17.0/Makefile
--- asterisk-13.9.1/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -99,6 +99,10 @@ export WGET_EXTRA_ARGS
 export LDCONFIG
 export LDCONFIG_FLAGS
 export PYTHON
+export TAR
+export PATCH
+export SED
+export NM
 
 # makeopts is required unless the goal is clean or distclean
 ifeq ($(findstring clean,$(MAKECMDGOALS)),)
@@ -120,6 +124,9 @@ _ASTLDFLAGS+=$(LDOPTS)
 # libxml2 cflags
 _ASTCFLAGS+=$(LIBXML2_INCLUDE)
 
+# BIND_8_COMPAT
+_ASTCFLAGS+=$(BIND8_CFLAGS)
+
 #Uncomment this to see all build commands instead of 'quiet' output
 #NOISY_BUILD=yes
 
@@ -179,11 +186,6 @@ OTHER_SUBDIR_CFLAGS="-I$(ASTTOPDIR)/incl
 # Create OPTIONS variable, but probably we can assign directly to ASTCFLAGS
 OPTIONS=
 
-ifeq ($(OSARCH),linux-gnu)
-  # flag to tell 'ldconfig' to only process specified directories
-  LDCONFIG_FLAGS=-n
-endif
-
 ifeq ($(findstring -save-temps,$(_ASTCFLAGS) $(ASTCFLAGS)),)
   ifeq ($(findstring -pipe,$(_ASTCFLAGS) $(ASTCFLAGS)),)
     _ASTCFLAGS+=-pipe
@@ -219,8 +221,6 @@ ifeq ($(OSARCH),FreeBSD)
   # -V is understood by BSD Make, not by GNU make.
   BSDVERSION=$(shell make -V OSVERSION -f /usr/share/mk/bsd.port.subdir.mk)
   _ASTCFLAGS+=$(shell if test $(BSDVERSION) -lt 500016 ; then echo "-D_THREAD_SAFE"; fi)
-  # flag to tell 'ldconfig' to only process specified directories
-  LDCONFIG_FLAGS=-m
 endif
 
 ifeq ($(OSARCH),NetBSD)
@@ -257,9 +257,6 @@ SUBDIRS_INSTALL:=$(SUBDIRS:%=%-install)
 SUBDIRS_CLEAN:=$(SUBDIRS:%=%-clean)
 SUBDIRS_DIST_CLEAN:=$(SUBDIRS:%=%-dist-clean)
 SUBDIRS_UNINSTALL:=$(SUBDIRS:%=%-uninstall)
-MOD_SUBDIRS_EMBED_LDSCRIPT:=$(MOD_SUBDIRS:%=%-embed-ldscript)
-MOD_SUBDIRS_EMBED_LDFLAGS:=$(MOD_SUBDIRS:%=%-embed-ldflags)
-MOD_SUBDIRS_EMBED_LIBS:=$(MOD_SUBDIRS:%=%-embed-libs)
 MOD_SUBDIRS_MENUSELECT_TREE:=$(MOD_SUBDIRS:%=%-menuselect-tree)
 
 ifneq ($(findstring darwin,$(OSARCH)),)
@@ -348,41 +345,14 @@ ifeq ($(filter %menuselect,$(MAKECMDGOAL
 	menuselect/menuselect --check-deps $@
 endif
 
-$(MOD_SUBDIRS_EMBED_LDSCRIPT):
-	+@echo "EMBED_LDSCRIPTS+="`$(SILENTMAKE) -C $(@:-embed-ldscript=) SUBDIR=$(@:-embed-ldscript=) __embed_ldscript` >> makeopts.embed_rules
-
-$(MOD_SUBDIRS_EMBED_LDFLAGS):
-	+@echo "EMBED_LDFLAGS+="`$(SILENTMAKE) -C $(@:-embed-ldflags=) SUBDIR=$(@:-embed-ldflags=) __embed_ldflags` >> makeopts.embed_rules
-
-$(MOD_SUBDIRS_EMBED_LIBS):
-	+@echo "EMBED_LIBS+="`$(SILENTMAKE) -C $(@:-embed-libs=) SUBDIR=$(@:-embed-libs=) __embed_libs` >> makeopts.embed_rules
-
 $(MOD_SUBDIRS_MENUSELECT_TREE):
 	+@$(SUBMAKE) -C $(@:-menuselect-tree=) SUBDIR=$(@:-menuselect-tree=) moduleinfo
 	+@$(SUBMAKE) -C $(@:-menuselect-tree=) SUBDIR=$(@:-menuselect-tree=) makeopts
 
-makeopts.embed_rules: menuselect.makeopts
-	@echo "Generating embedded module rules ..."
-	@rm -f $@
-	+@$(SUBMAKE) $(MOD_SUBDIRS_EMBED_LDSCRIPT)
-	+@$(SUBMAKE) $(MOD_SUBDIRS_EMBED_LDFLAGS)
-	+@$(SUBMAKE) $(MOD_SUBDIRS_EMBED_LIBS)
-
-$(SUBDIRS): makeopts .lastclean main/version.c include/asterisk/build.h include/asterisk/buildopts.h defaults.h makeopts.embed_rules
+$(SUBDIRS): makeopts .lastclean main/version.c include/asterisk/build.h include/asterisk/buildopts.h defaults.h
 
 ifeq ($(findstring $(OSARCH), mingw32 cygwin ),)
-  ifeq ($(shell grep ^MENUSELECT_EMBED=$$ menuselect.makeopts 2>/dev/null),)
-    # Non-windows:
-    # ensure that all module subdirectories are processed before 'main' during
-    # a parallel build, since if there are modules selected to be embedded the
-    # directories containing them must be completed before the main Asterisk
-    # binary can be built.
-    # If MENUSELECT_EMBED is empty, we don't need this and allow 'main' to be
-    # be built with only third_party first.
-main: $(filter-out main,$(MOD_SUBDIRS))
-  else
 main: third-party
-  endif
 else
     # Windows: we need to build main (i.e. the asterisk dll) first,
     # followed by res, followed by the other directories, because
@@ -447,7 +417,6 @@ distclean: $(SUBDIRS_DIST_CLEAN) _clean
 	@$(MAKE) -C menuselect dist-clean
 	@$(MAKE) -C sounds dist-clean
 	rm -f menuselect.makeopts makeopts menuselect-tree menuselect.makedeps
-	rm -f makeopts.embed_rules
 	rm -f config.log config.status config.cache
 	rm -rf autom4te.cache
 	rm -f include/asterisk/autoconfig.h
@@ -492,7 +461,7 @@ doc/core-en_US.xml: makeopts .lastclean
 	@printf "Building Documentation For: "
 	@echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" > $@
 	@echo "<!DOCTYPE docs SYSTEM \"appdocsxml.dtd\">" >> $@
-	@echo "<?xml-stylesheet type=\"text/xsl\" href=\"appdocsxml.xslt\"?>" > $@
+	@echo "<?xml-stylesheet type=\"text/xsl\" href=\"appdocsxml.xslt\"?>" >> $@
 	@echo "<docs xmlns:xi=\"http://www.w3.org/2001/XInclude\">" >> $@
 	@for x in $(MOD_SUBDIRS); do \
 		printf "$$x " ; \
@@ -516,7 +485,7 @@ else
 	@printf "Building Documentation For: "
 	@echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" > $@
 	@echo "<!DOCTYPE docs SYSTEM \"appdocsxml.dtd\">" >> $@
-	@echo "<?xml-stylesheet type=\"text/xsl\" href=\"appdocsxml.xslt\"?>" > $@
+	@echo "<?xml-stylesheet type=\"text/xsl\" href=\"appdocsxml.xslt\"?>" >> $@
 	@echo "<docs xmlns:xi=\"http://www.w3.org/2001/XInclude\">" >> $@
 	@for x in $(MOD_SUBDIRS); do \
 		printf "$$x " ; \
@@ -619,9 +588,10 @@ $(SUBDIRS_INSTALL):
 
 NEWMODS:=$(foreach d,$(MOD_SUBDIRS),$(notdir $(wildcard $(d)/*.so)))
 OLDMODS=$(filter-out $(NEWMODS) $(notdir $(DESTDIR)$(ASTMODDIR)),$(notdir $(wildcard $(DESTDIR)$(ASTMODDIR)/*.so)))
+BADMODS=$(strip $(filter-out $(shell ./build_tools/list_valid_installed_externals),$(OLDMODS)))
 
 oldmodcheck:
-	@if [ -n "$(OLDMODS)" ]; then \
+	@if [ -n "$(BADMODS)" ]; then \
 		echo " WARNING WARNING WARNING" ;\
 		echo "" ;\
 		echo " Your Asterisk modules directory, located at" ;\
@@ -631,13 +601,87 @@ oldmodcheck:
 		echo " modules are compatible with this version before" ;\
 		echo " attempting to run Asterisk." ;\
 		echo "" ;\
-		for f in $(OLDMODS); do \
+		for f in $(BADMODS); do \
 			echo "    $$f" ;\
 		done ;\
 		echo "" ;\
 		echo " WARNING WARNING WARNING" ;\
 	fi
 
+ld-cache-update:
+ifneq ($(LDCONFIG),)
+ifeq ($(DESTDIR),)  # DESTDIR means binary archive creation; ldconfig should be run on postinst
+	@if [ $${EUID} -eq 0 ] ; then \
+		$(LDCONFIG) "$(ASTLIBDIR)/" ; \
+	else \
+		echo " WARNING WARNING WARNING" ;\
+		echo "" ;\
+		echo " You cannot rebuild the system linker cache unless you are root. " ;\
+		echo " You MUST do one of the following..." ;\
+		echo "  * Re-run 'make install' as root. " ;\
+		echo "  * Run 'ldconfig $(ASTLIBDIR)' as root. " ;\
+		echo "  * Run asterisk with 'LD_LIBRARY_PATH=$(ASTLIBDIR) asterisk' " ;\
+		echo "" ;\
+		echo " WARNING WARNING WARNING" ;\
+	fi
+endif
+endif
+
+export _oldlibdir =
+export _oldmoddir =
+ifeq ($(findstring 64,$(HOST_CPU)),64)
+    # Strip any trailing '/' so the dir and notdir functions work correctly
+    _current_libdir = $(patsubst %/,%,$(DESTDIR)$(ASTLIBDIR))
+
+    # Only process if the paths end in lib64 or lib.
+    # If we're installing to lib64, check lib for orphans.
+    # If we're installing to lib, check lib64 for orphans.
+    # Otherwise, leave _oldlibdir empty.
+    ifeq ($(notdir $(_current_libdir)),lib64)
+        _oldlibdir = $(dir $(_current_libdir))lib
+    else ifeq ($(notdir $(_current_libdir)),lib)
+        _oldlibdir = $(dir $(_current_libdir))lib64
+    endif
+
+    # Strip any trailing '/' so the dir and notdir functions work correctly
+    _current_moddir = $(patsubst %/,%,$(DESTDIR)$(ASTMODDIR))
+
+    # Only process if the paths contain /lib64/ or /lib/.
+    # If we're installing to lib64, check lib for orphans.
+    # If we're installing to lib, check lib64 for orphans.
+    # Otherwise, leave _oldmoddir empty.
+    ifeq ($(findstring /lib64/,$(_current_moddir)),/lib64/)
+        _oldmoddir = $(subst /lib64/,/lib/,$(_current_moddir))
+    else ifeq ($(findstring /lib/,$(_current_moddir)),/lib/)
+        _oldmoddir = $(subst /lib/,/lib64/,$(_current_moddir))
+    endif
+endif
+
+check-old-libdir:
+	@test -n "$(_oldlibdir)" -a -d "$(_oldlibdir)" || exit 0 ;\
+	oldfiles=`find "$(_oldlibdir)" -name libasterisk* -print -quit -o \( -path *asterisk/modules/* -a -name *.so \) -print -quit 2>/dev/null` ;\
+	if [ "x$$oldfiles" != "x" ] ; then \
+		echo " WARNING WARNING WARNING" ;\
+		echo "" ;\
+		echo " Installation is to: " ;\
+		echo "   $(DESTDIR)$(ASTLIBDIR)" ;\
+		echo " but there are asterisk shared libraries in: " ;\
+		echo "   $(_oldlibdir)" ;\
+		echo " or" ;\
+		echo "   $(_oldlibdir)/asterisk/modules" ;\
+		echo "" ;\
+		echo " It is unlikely that asterisk will start." ;\
+		echo "" ;\
+		echo " You should do one of the following..." ;\
+		echo "  * Run 'make uninstall' to remove the incorrect libraries" ;\
+		echo "    then run 'make install' again." ;\
+		echo "  * Manually remove the libraries from" ;\
+		echo "   $(_oldlibdir)" ;\
+		echo "   and run 'ldconfig' to rebuild the linker cache." ;\
+		echo "" ;\
+		echo " WARNING WARNING WARNING" ;\
+	fi
+
 badshell:
 ifneq ($(filter ~%,$(DESTDIR)),)
 	@echo "Your shell doesn't do ~ expansion when expected (specifically, when doing \"make install DESTDIR=~/path\")."
@@ -676,6 +720,8 @@ install: badshell bininstall datafiles
 	@echo " + doxygen installed on your local system    +"
 	@echo " +-------------------------------------------+"
 	@$(MAKE) -s oldmodcheck
+	@$(MAKE) -s ld-cache-update
+	@$(MAKE) -s check-old-libdir
 
 isntall: install
 
@@ -825,60 +871,56 @@ install-logrotate:
 	rm -f contrib/scripts/asterisk.logrotate.tmp
 
 config:
-	@if [ "${OSARCH}" = "linux-gnu" -o "${OSARCH}" = "kfreebsd-gnu" ]; then \
-		if [ -f /etc/redhat-release -o -f /etc/fedora-release ]; then \
-			./build_tools/install_subst contrib/init.d/rc.redhat.asterisk  "$(DESTDIR)/etc/rc.d/init.d/asterisk"; \
-			if [ ! -f "$(DESTDIR)/etc/sysconfig/asterisk" ] ; then \
-				$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/sysconfig/asterisk" ; \
-			fi ; \
-			if [ -z "$(DESTDIR)" ] ; then \
-				/sbin/chkconfig --add asterisk ; \
-			fi ; \
-		elif [ -f /etc/debian_version ] ; then \
-			./build_tools/install_subst contrib/init.d/rc.debian.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
-			if [ ! -f "$(DESTDIR)/etc/default/asterisk" ] ; then \
-				$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/default/asterisk" ; \
-			fi ; \
-			if [ -z "$(DESTDIR)" ] ; then \
-				/usr/sbin/update-rc.d asterisk defaults 50 91 ; \
-			fi ; \
-		elif [ -f /etc/gentoo-release ] ; then \
-			./build_tools/install_subst contrib/init.d/rc.gentoo.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
-			if [ -z "$(DESTDIR)" ] ; then \
-				/sbin/rc-update add asterisk default ; \
-			fi ; \
-		elif [ -f /etc/mandrake-release -o -f /etc/mandriva-release ] ; then \
-			./build_tools/install_subst contrib/init.d/rc.mandriva.asterisk  "$(DESTDIR)/etc/rc.d/init.d/asterisk"; \
-			if [ ! -f /etc/sysconfig/asterisk ] ; then \
-				$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/sysconfig/asterisk" ; \
-			fi ; \
-			if [ -z "$(DESTDIR)" ] ; then \
-				/sbin/chkconfig --add asterisk ; \
-			fi ; \
-		elif [ -f /etc/SuSE-release -o -f /etc/novell-release ] ; then \
-			./build_tools/install_subst contrib/init.d/rc.suse.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
-			if [ ! -f /etc/sysconfig/asterisk ] ; then \
-				$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/sysconfig/asterisk" ; \
-			fi ; \
-			if [ -z "$(DESTDIR)" ] ; then \
-				/sbin/chkconfig --add asterisk ; \
-			fi ; \
-		elif [ -f /etc/arch-release -o -f /etc/arch-release ] ; then \
-			./build_tools/install_subst contrib/init.d/rc.archlinux.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
-		elif [ -d "$(DESTDIR)/Library/LaunchDaemons" ]; then \
-			if [ ! -f "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.asterisk.plist" ]; then \
-				./build_tools/install_subst contrib/init.d/org.asterisk.asterisk.plist "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.asterisk.plist"; \
-			fi; \
-			if [ ! -f "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.muted.plist" ]; then \
-				./build_tools/install_subst contrib/init.d/org.asterisk.muted.plist "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.muted.plist"; \
-			fi; \
-		elif [ -f /etc/slackware-version ]; then \
-			echo "Slackware is not currently supported, although an init script does exist for it."; \
-		else \
-			echo "We could not install init scripts for your distribution." ; \
-		fi \
+	@if [ -f /etc/redhat-release -o -f /etc/fedora-release ]; then \
+		./build_tools/install_subst contrib/init.d/rc.redhat.asterisk  "$(DESTDIR)/etc/rc.d/init.d/asterisk"; \
+		if [ ! -f "$(DESTDIR)/etc/sysconfig/asterisk" ] ; then \
+			$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/sysconfig/asterisk" ; \
+		fi ; \
+		if [ -z "$(DESTDIR)" ] ; then \
+			/sbin/chkconfig --add asterisk ; \
+		fi ; \
+	elif [ -f /etc/debian_version ] ; then \
+		./build_tools/install_subst contrib/init.d/rc.debian.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
+		if [ ! -f "$(DESTDIR)/etc/default/asterisk" ] ; then \
+			$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/default/asterisk" ; \
+		fi ; \
+		if [ -z "$(DESTDIR)" ] ; then \
+			/usr/sbin/update-rc.d asterisk defaults 50 91 ; \
+		fi ; \
+	elif [ -f /etc/gentoo-release ] ; then \
+		./build_tools/install_subst contrib/init.d/rc.gentoo.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
+		if [ -z "$(DESTDIR)" ] ; then \
+			/sbin/rc-update add asterisk default ; \
+		fi ; \
+	elif [ -f /etc/mandrake-release -o -f /etc/mandriva-release ] ; then \
+		./build_tools/install_subst contrib/init.d/rc.mandriva.asterisk  "$(DESTDIR)/etc/rc.d/init.d/asterisk"; \
+		if [ ! -f /etc/sysconfig/asterisk ] ; then \
+			$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/sysconfig/asterisk" ; \
+		fi ; \
+		if [ -z "$(DESTDIR)" ] ; then \
+			/sbin/chkconfig --add asterisk ; \
+		fi ; \
+	elif [ -f /etc/SuSE-release -o -f /etc/novell-release ] ; then \
+		./build_tools/install_subst contrib/init.d/rc.suse.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
+		if [ ! -f /etc/sysconfig/asterisk ] ; then \
+			$(INSTALL) -m 644 contrib/init.d/etc_default_asterisk "$(DESTDIR)/etc/sysconfig/asterisk" ; \
+		fi ; \
+		if [ -z "$(DESTDIR)" ] ; then \
+			/sbin/chkconfig --add asterisk ; \
+		fi ; \
+	elif [ -f /etc/arch-release -o -f /etc/arch-release ] ; then \
+		./build_tools/install_subst contrib/init.d/rc.archlinux.asterisk  "$(DESTDIR)/etc/init.d/asterisk"; \
+	elif [ -d "$(DESTDIR)/Library/LaunchDaemons" ]; then \
+		if [ ! -f "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.asterisk.plist" ]; then \
+			./build_tools/install_subst contrib/init.d/org.asterisk.asterisk.plist "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.asterisk.plist"; \
+		fi; \
+		if [ ! -f "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.muted.plist" ]; then \
+			./build_tools/install_subst contrib/init.d/org.asterisk.muted.plist "$(DESTDIR)/Library/LaunchDaemons/org.asterisk.muted.plist"; \
+		fi; \
+	elif [ -f /etc/slackware-version ]; then \
+		echo "Slackware is not currently supported, although an init script does exist for it."; \
 	else \
-		echo "We could not install init scripts for your operating system." ; \
+		echo "We could not install init scripts for your distribution." ; \
 	fi
 
 sounds:
@@ -900,6 +942,7 @@ main-binuninstall:
 
 _uninstall: $(SUBDIRS_UNINSTALL) main-binuninstall
 	rm -f "$(DESTDIR)$(ASTMODDIR)/"*
+	test -n "$(_oldmoddir)" -a -d "$(_oldmoddir)" && rm -f "$(_oldmoddir)/"* || :
 	rm -f "$(DESTDIR)$(ASTSBINDIR)/astgenkey"
 	rm -f "$(DESTDIR)$(ASTSBINDIR)/autosupport"
 	rm -rf "$(DESTDIR)$(ASTHEADERDIR)"
@@ -912,6 +955,9 @@ ifeq ($(HAVE_DAHDI),1)
 	rm -f $(DESTDIR)$(DAHDI_UDEV_HOOK_DIR)/40-asterisk
 endif
 	$(MAKE) -C sounds uninstall
+ifneq ($(LDCONFIG),)
+	$(LDCONFIG) || :
+endif
 
 uninstall: _uninstall
 	@echo " +--------- Asterisk Uninstall Complete -----+"
@@ -929,6 +975,7 @@ uninstall: _uninstall
 
 uninstall-all: _uninstall
 	rm -rf "$(DESTDIR)$(ASTMODDIR)"
+	test -n "$(_oldmoddir)" -a -d "$(_oldmoddir)" && rm -rf "$(_oldmoddir)" || :
 	rm -rf "$(DESTDIR)$(ASTVARLIBDIR)"
 	rm -rf "$(DESTDIR)$(ASTDATADIR)"
 	rm -rf "$(DESTDIR)$(ASTSPOOLDIR)"
@@ -985,7 +1032,7 @@ menuselect/nmenuselect: menuselect/makeo
 menuselect/makeopts: makeopts .lastclean
 	+$(MAKE_MENUSELECT) makeopts
 
-menuselect-tree: $(foreach dir,$(filter-out main,$(MOD_SUBDIRS)),$(wildcard $(dir)/*.c) $(wildcard $(dir)/*.cc)) build_tools/cflags.xml build_tools/cflags-devmode.xml sounds/sounds.xml build_tools/embed_modules.xml utils/utils.xml agi/agi.xml configure makeopts
+menuselect-tree: $(foreach dir,$(filter-out main,$(MOD_SUBDIRS)),$(wildcard $(dir)/*.c) $(wildcard $(dir)/*.cc) $(wildcard $(dir)/*.xml)) build_tools/cflags.xml build_tools/cflags-devmode.xml sounds/sounds.xml utils/utils.xml agi/agi.xml configure makeopts
 	@echo "Generating input for menuselect ..."
 	@echo "<?xml version=\"1.0\"?>" > $@
 	@echo >> $@
@@ -998,7 +1045,6 @@ menuselect-tree: $(foreach dir,$(filter-
 	fi
 	@cat utils/utils.xml >> $@
 	@cat agi/agi.xml >> $@
-	@cat build_tools/embed_modules.xml >> $@
 	@cat sounds/sounds.xml >> $@
 	@echo "</menu>" >> $@
 
@@ -1042,14 +1088,13 @@ check-alembic: makeopts
 .PHONY: ari-stubs
 .PHONY: basic-pbx
 .PHONY: check-alembic
+.PHONY: ld-cache-update
+.PHONY: check-old-libdir
 .PHONY: $(SUBDIRS_INSTALL)
 .PHONY: $(SUBDIRS_DIST_CLEAN)
 .PHONY: $(SUBDIRS_CLEAN)
 .PHONY: $(SUBDIRS_UNINSTALL)
 .PHONY: $(SUBDIRS)
-.PHONY: $(MOD_SUBDIRS_EMBED_LDSCRIPT)
-.PHONY: $(MOD_SUBDIRS_EMBED_LDFLAGS)
-.PHONY: $(MOD_SUBDIRS_EMBED_LIBS)
 
 FORCE:
 
diff -urpN asterisk-13.9.1/Makefile.moddir_rules asterisk-13.17.0/Makefile.moddir_rules
--- asterisk-13.9.1/Makefile.moddir_rules	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/Makefile.moddir_rules	2017-07-12 13:12:08.000000000 +0200
@@ -18,10 +18,6 @@
 # Also note that we can only set one variable per rule, so we have to
 # repeat the left hand side to set multiple variables.
 
-ifeq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
-  _ASTCFLAGS+=${GC_CFLAGS}
-endif
-
 ifneq ($(findstring STATIC_BUILD,$(MENUSELECT_CFLAGS)),)
   STATIC_BUILD=-static
 endif
@@ -29,7 +25,7 @@ endif
 include $(ASTTOPDIR)/Makefile.rules
 
 # If MODULE_PREFIX is defined, use it to run the standard functions to set
-# C_MODS, CC_MODS, LOADABLE_MODS and EMBEDDED_MODS.
+# C_MODS, CC_MODS and LOADABLE_MODS
 # Each word of MODULE_PREFIX is a prefix for filenames that we consider
 # valid C or CC modules (eg. app, func ...). Note that the underscore
 # is added here, and does not need to be in MODULE_PREFIX
@@ -46,11 +42,7 @@ endif
 C_MODS:=$(filter-out $(MENUSELECT_$(MENUSELECT_CATEGORY)),$(ALL_C_MODS))
 CC_MODS:=$(filter-out $(MENUSELECT_$(MENUSELECT_CATEGORY)),$(ALL_CC_MODS))
 
-ifneq ($(findstring EMBED_$(MENUSELECT_CATEGORY),$(MENUSELECT_EMBED)),)
-    EMBEDDED_MODS:=$(C_MODS) $(CC_MODS)
-else
-    LOADABLE_MODS:=$(C_MODS) $(CC_MODS)
-endif
+LOADABLE_MODS:=$(C_MODS) $(CC_MODS)
 
 # Both C++ and C++ sources need their module name in AST_MODULE
 # We also pass whatever _INCLUDE list is generated by menuselect
@@ -74,16 +66,11 @@ endif
 $(LOADABLE_MODS:%=%.so): LIBS+=$(foreach dep,$(MENUSELECT_DEPENDS_$*),$(value $(dep)_LIB))
 $(LOADABLE_MODS:%=%.so): _ASTLDFLAGS+=$(foreach dep,$(MENUSELECT_DEPENDS_$*),$(value $(dep)_LDFLAGS))
 
-$(EMBEDDED_MODS:%=%.o): _ASTCFLAGS+=-DEMBEDDED_MODULE=$*
-
 $(addsuffix .so,$(filter $(LOADABLE_MODS),$(C_MODS))): %.so: %.o
 $(addsuffix .so,$(filter $(LOADABLE_MODS),$(CC_MODS))): %.so: %.oo
 
-modules.link: $(addsuffix .eo,$(filter $(EMBEDDED_MODS),$(C_MODS)))
-
 .PHONY: clean uninstall _all moduleinfo makeopts
 
-ifneq ($(LOADABLE_MODS),)
 _all: $(LOADABLE_MODS:%=%.so)
 ifneq ($(findstring $(OSARCH), mingw32 cygwin ),)
   # linker options and extra libraries for cygwin
@@ -91,28 +78,6 @@ ifneq ($(findstring $(OSARCH), mingw32 c
   LIBS+=-L$(ASTTOPDIR)/main -lasterisk -L$(ASTTOPDIR)/res $($@_LIBS)
   # additional libraries in res/
 endif
-endif
-
-ifneq ($(EMBEDDED_MODS),)
-_all: modules.link
-__embed_ldscript:
-	@echo "../$(SUBDIR)/modules.link"
-__embed_ldflags:
-	@echo "$(foreach mod,$(filter $(EMBEDDED_MODS),$(C_MODS)),$(foreach dep,$(MENUSELECT_DEPENDS_$(mod)),$(dep)_LDFLAGS))"
-	@echo "$(foreach mod,$(filter $(EMBEDDED_MODS),$(CC_MODS)),$(foreach dep,$(MENUSELECT_DEPENDS_$(mod)),$(dep)_LDFLAGS))"
-__embed_libs:
-	@echo "$(foreach mod,$(filter $(EMBEDDED_MODS),$(C_MODS)),$(foreach dep,$(MENUSELECT_DEPENDS_$(mod)),$(dep)_LIB))"
-	@echo "$(foreach mod,$(filter $(EMBEDDED_MODS),$(CC_MODS)),$(foreach dep,$(MENUSELECT_DEPENDS_$(mod)),$(dep)_LIB))"
-else
-__embed_ldscript:
-__embed_ldflags:
-__embed_libs:
-endif
-
-modules.link:
-	@rm -f $@
-	@for file in $(patsubst %,$(SUBDIR)/%,$(filter %.eo,$^)); do echo "INPUT (../$${file})" >> $@; done
-	@for file in $(patsubst %,$(SUBDIR)/%,$(filter-out %.eo,$^)); do echo "INPUT (../$${file})" >> $@; done
 
 clean::
 	rm -f *.so *.o *.oo *.eo *.i *.ii
@@ -124,6 +89,18 @@ clean::
 install:: all
 	@echo "Installing modules from `basename $(CURDIR)`..."
 	@for x in $(LOADABLE_MODS:%=%.so); do $(INSTALL) -m 755 $$x "$(DESTDIR)$(ASTMODDIR)" ; done
+ifneq ($(findstring :,$(XMLSTARLET)$(BASH)),:)
+	@if [ -f .moduleinfo ] ; then \
+		declare -A DISABLED_MODS ;\
+		for x in $(MENUSELECT_$(MENUSELECT_CATEGORY)) ; do DISABLED_MODS[$${x}]=1 ; done ;\
+		EXTERNAL_MODS=$$(xmlstarlet sel -t -m "/category/member[support_level = 'external']" -v "@name" -n .moduleinfo) ;\
+		for x in $${EXTERNAL_MODS} ; do \
+			if [ -z "$${DISABLED_MODS[$${x}]}" ] ; then \
+				$(ASTTOPDIR)/build_tools/download_externals $${x} ;\
+			fi ;\
+		done ;\
+	fi
+endif
 
 uninstall::
 
@@ -142,8 +119,8 @@ dist-clean::
 	$(AWK) -f $(ASTTOPDIR)/build_tools/get_moduleinfo $^ >> $@
 	echo "</member>" >> $@
 
-.moduleinfo:: $(addsuffix .moduleinfo,$(addprefix .,$(sort $(ALL_C_MODS) $(ALL_CC_MODS))))
-	@echo "<category name=\"MENUSELECT_$(MENUSELECT_CATEGORY)\" displayname=\"$(MENUSELECT_DESCRIPTION)\" remove_on_change=\"$(SUBDIR)/modules.link\">" > $@
+.moduleinfo:: $(addsuffix .moduleinfo,$(addprefix .,$(sort $(ALL_C_MODS) $(ALL_CC_MODS)))) $(wildcard $(call tolower,$(MENUSELECT_CATEGORY)).xml)
+	@echo "<category name=\"MENUSELECT_$(MENUSELECT_CATEGORY)\" displayname=\"$(MENUSELECT_DESCRIPTION)\">" > $@
 	@cat $^ >> $@
 	@echo "</category>" >> $@
 
diff -urpN asterisk-13.9.1/Makefile.rules asterisk-13.17.0/Makefile.rules
--- asterisk-13.9.1/Makefile.rules	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/Makefile.rules	2017-07-12 13:12:08.000000000 +0200
@@ -17,6 +17,10 @@
 
 -include $(ASTTOPDIR)/makeopts
 
+# Helpful functions
+# call with $(call function,...)
+tolower = $(shell echo $(1) | tr '[:upper:]' '[:lower:]')
+
 .PHONY: dist-clean
 
 # If 'make' decides to create intermediate files to satisfy a build requirement
@@ -181,18 +185,6 @@ endif
 	$(ECHO_PREFIX) echo "   [LDXX] $^ -> $@"
 	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(CXX_LDFLAGS_SO) $^ $(CXX_LIBS)
 
-%.eo: %.o
-	$(ECHO_PREFIX) echo "   [EMBED] $< -> $@"
-	$(CMD_PREFIX) $(ASTTOPDIR)/build_tools/make_linker_eo_script $* > .$@.ld
-	$(CMD_PREFIX) $(LD) -r -T .$@.ld -o $@ $<
-	$(CMD_PREFIX) rm -f .$@.ld
-
-%.eo: %.oo
-	$(ECHO_PREFIX) echo "   [EMBED] $< -> $@"
-	$(CMD_PREFIX) $(ASTTOPDIR)/build_tools/make_linker_eo_script $* > .$@.ld
-	$(CMD_PREFIX) $(LD) -r -T .$@.ld -o $@ $<
-	$(CMD_PREFIX) rm -f .$@.ld
-
 %: %.o
 	$(ECHO_PREFIX) echo "   [LD] $^ -> $@"
 	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(PTHREAD_CFLAGS) $(_ASTLDFLAGS) $^ $(CXX_LIBS) $(ASTLDFLAGS)
diff -urpN asterisk-13.9.1/UPGRADE.txt asterisk-13.17.0/UPGRADE.txt
--- asterisk-13.9.1/UPGRADE.txt	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/UPGRADE.txt	2017-07-12 13:12:08.000000000 +0200
@@ -21,6 +21,22 @@
 === UPGRADE-12.txt  -- Upgrade info for 11 to 12
 ===========================================================
 
+From 13.15.0 to 13.16.0:
+
+Core:
+ - Support for embedded modules has been removed.  This has not worked in
+   many years.  LOADABLE_MODULES menuselect option is also removed as
+   loadable module support is now always enabled.
+
+From 13.14.0 to 13.15.0:
+
+res_rtp_asterisk:
+ - The RTP layer of Asterisk now has support for RFC 5761: "Multiplexing RTP
+   Data and Control Packets on a Single Port." For the PJSIP channel driver,
+   chan_pjsip, you can set "rtcp_mux = yes" on a PJSIP endpoint in pjsip.conf
+   to enable the feature. For chan_sip you can set "rtcp_mux = yes" either
+   globally or on a per-peer basis in sip.conf.
+
 From 13.8.0 to 13.9.0:
 
 res_parking:
diff -urpN asterisk-13.9.1/addons/Makefile asterisk-13.17.0/addons/Makefile
--- asterisk-13.9.1/addons/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -41,10 +41,10 @@ ifeq ($(filter format_mp3,$(MENUSELECT_A
 		echo ; \
 		echo "**************************************************************" ; \
 		echo "***                                                        ***" ; \
-		echo "***   --->  READ THIS OR YOUR BUILD WILL FAIL  <---        ***" ; \
+		echo "***    ---> IMPORTANT INFORMATION ABOUT format_mp3 <---    ***" ; \
 		echo "***                                                        ***" ; \
 		echo "*** format_mp3 has been selected to be installed, but the  ***" ; \
-		echo "*** mp3 decoder library has not yet been downloaded into   ***" ; \
+		echo "*** MP3 decoder library has not yet been downloaded into   ***" ; \
 		echo "*** the source tree.  To do so, please run the following   ***" ; \
 		echo "*** command:                                               ***" ; \
 		echo "***                                                        ***" ; \
@@ -61,12 +61,17 @@ clean::
 	if [ -f mp3/Makefile ] ; then $(MAKE) -C mp3 clean ; fi
 	rm -f $(addprefix ooh323c/src/,$(H323OBJS))
 
-$(if $(filter format_mp3,$(EMBEDDED_MODS)),modules.link,format_mp3.so): mp3/common.o mp3/dct64_i386.o mp3/decode_ntom.o mp3/layer3.o mp3/tabinit.o mp3/interface.o
+ifneq ($(wildcard mp3/Makefile),)
+format_mp3.so: mp3/common.o mp3/dct64_i386.o mp3/decode_ntom.o mp3/layer3.o mp3/tabinit.o mp3/interface.o
+endif
 
 chan_ooh323.o: _ASTCFLAGS+=$(H323CFLAGS)
-
-$(if $(filter chan_ooh323,$(EMBEDDED_MODS)),modules.link,chan_ooh323.so): _ASTCFLAGS+=$(H323CFLAGS)
-$(if $(filter chan_ooh323,$(EMBEDDED_MODS)),modules.link,chan_ooh323.so): $(addprefix ooh323c/src/,$(H323OBJS)) chan_ooh323.o ooh323cDriver.o
+chan_ooh323.so: _ASTCFLAGS+=$(H323CFLAGS)
+chan_ooh323.so: $(addprefix ooh323c/src/,$(H323OBJS)) chan_ooh323.o ooh323cDriver.o
 $(addprefix ooh323c/src/,$(H323OBJS)) chan_ooh323.o ooh323cDriver.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_ooh323)
 
 .PHONY: check_mp3
+
+ifeq ($(wildcard mp3/Makefile),)
+.PHONY: format_mp3.o format_mp3.so
+endif
diff -urpN asterisk-13.9.1/addons/cdr_mysql.c asterisk-13.17.0/addons/cdr_mysql.c
--- asterisk-13.9.1/addons/cdr_mysql.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/cdr_mysql.c	2017-07-12 13:12:08.000000000 +0200
@@ -250,7 +250,7 @@ db_reconnect:
 					struct ast_tm tm;
 					char timestr[128];
 					ast_localtime(&tv, &tm, ast_str_strlen(cdrzone) ? ast_str_buffer(cdrzone) : NULL);
-					ast_strftime(timestr, sizeof(timestr), "%Y-%m-%d %T", &tm);
+					ast_strftime(timestr, sizeof(timestr), DATE_FORMAT, &tm);
 					value = ast_strdupa(timestr);
 					cdrname = "calldate";
 				} else {
@@ -265,8 +265,7 @@ db_reconnect:
 			/* Need the type and value to determine if we want the raw value or not */
 			if (entry->staticvalue) {
 				value = ast_strdupa(entry->staticvalue);
-			} else if ((!strcmp(cdrname, "start") ||
-				 !strcmp(cdrname, "answer") ||
+			} else if ((!strcmp(cdrname, "answer") ||
 				 !strcmp(cdrname, "end") ||
 				 !strcmp(cdrname, "disposition") ||
 				 !strcmp(cdrname, "amaflags")) &&
@@ -278,6 +277,12 @@ db_reconnect:
 				 strstr(entry->type, "numeric") ||
 				 strstr(entry->type, "fixed"))) {
 				ast_cdr_format_var(cdr, cdrname, &value, workspace, sizeof(workspace), 1);
+			} else if (!strcmp(cdrname, "start")) {
+				struct ast_tm tm;
+				char timestr[128];
+				ast_localtime(&cdr->start, &tm, ast_str_strlen(cdrzone) ? ast_str_buffer(cdrzone) : NULL);
+				ast_strftime(timestr, sizeof(timestr), DATE_FORMAT, &tm);
+				value = ast_strdupa(timestr);
 			} else if (!strcmp(cdrname, "calldate")) {
 				/* Skip calldate - the value has already been dup'd */
 			} else {
@@ -353,9 +358,20 @@ db_reconnect:
 	return 0;
 }
 
+static void free_strings(void)
+{
+	struct unload_string *us;
+
+	AST_LIST_LOCK(&unload_strings);
+	while ((us = AST_LIST_REMOVE_HEAD(&unload_strings, entry))) {
+		ast_free(us->str);
+		ast_free(us);
+	}
+	AST_LIST_UNLOCK(&unload_strings);
+}
+
 static int my_unload_module(int reload)
 { 
-	struct unload_string *us;
 	struct column *entry;
 
 	ast_cli_unregister_multiple(cdr_mysql_status_cli, sizeof(cdr_mysql_status_cli) / sizeof(struct ast_cli_entry));
@@ -366,12 +382,7 @@ static int my_unload_module(int reload)
 		records = 0;
 	}
 
-	AST_LIST_LOCK(&unload_strings);
-	while ((us = AST_LIST_REMOVE_HEAD(&unload_strings, entry))) {
-		ast_free(us->str);
-		ast_free(us);
-	}
-	AST_LIST_UNLOCK(&unload_strings);
+	free_strings();
 
 	if (!reload) {
 		AST_RWLIST_WRLOCK(&columns);
@@ -507,13 +518,16 @@ static int my_load_module(int reload)
 	} else {
 		calldate_compat = 0;
 	}
+	ast_free(compat);
 
 	if (res < 0) {
 		if (reload) {
 			AST_RWLIST_UNLOCK(&columns);
 		}
 		ast_config_destroy(cfg);
-		return AST_MODULE_LOAD_FAILURE;
+		free_strings();
+
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Check for any aliases */
@@ -584,7 +598,9 @@ static int my_load_module(int reload)
 			connected = 0;
 			AST_RWLIST_UNLOCK(&columns);
 			ast_config_destroy(cfg);
-			return AST_MODULE_LOAD_FAILURE;
+			free_strings();
+
+			return AST_MODULE_LOAD_DECLINE;
 		}
 
 		if (!(result = mysql_store_result(&mysql))) {
@@ -593,7 +609,9 @@ static int my_load_module(int reload)
 			connected = 0;
 			AST_RWLIST_UNLOCK(&columns);
 			ast_config_destroy(cfg);
-			return AST_MODULE_LOAD_FAILURE;
+			free_strings();
+
+			return AST_MODULE_LOAD_DECLINE;
 		}
 
 		while ((row = mysql_fetch_row(result))) {
@@ -659,7 +677,8 @@ static int my_load_module(int reload)
 	AST_RWLIST_UNLOCK(&columns);
 	ast_config_destroy(cfg);
 	if (res < 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		my_unload_module(0);
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!reload) {
@@ -673,7 +692,12 @@ static int my_load_module(int reload)
 		res = ast_cli_register_multiple(cdr_mysql_status_cli, sizeof(cdr_mysql_status_cli) / sizeof(struct ast_cli_entry));
 	}
 
-	return res;
+	if (res) {
+		my_unload_module(0);
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 static int load_module(void)
diff -urpN asterisk-13.9.1/addons/chan_mobile.c asterisk-13.17.0/addons/chan_mobile.c
--- asterisk-13.9.1/addons/chan_mobile.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/chan_mobile.c	2017-07-12 13:12:08.000000000 +0200
@@ -3855,10 +3855,7 @@ static void *do_monitor_phone(void *data
 		}
 
 		if ((at_msg = at_read_full(hfp->rsock, buf, sizeof(buf))) < 0) {
-			/* XXX gnu specific strerror_r is assummed here, this
-			 * is not really safe.  See the strerror(3) man page
-			 * for more info. */
-			ast_debug(1, "[%s] error reading from device: %s (%d)\n", pvt->id, strerror_r(errno, buf, sizeof(buf)), errno);
+			ast_debug(1, "[%s] error reading from device: %s (%d)\n", pvt->id, strerror(errno), errno);
 			break;
 		}
 
@@ -3995,7 +3992,7 @@ static void *do_monitor_phone(void *data
 			ast_debug(1, "[%s] error parsing message\n", pvt->id);
 			goto e_cleanup;
 		case AT_READ_ERROR:
-			ast_debug(1, "[%s] error reading from device: %s (%d)\n", pvt->id, strerror_r(errno, buf, sizeof(buf)), errno);
+			ast_debug(1, "[%s] error reading from device: %s (%d)\n", pvt->id, strerror(errno), errno);
 			goto e_cleanup;
 		default:
 			break;
@@ -4073,11 +4070,7 @@ static void *do_monitor_headset(void *da
 			continue;
 
 		if ((at_msg = at_read_full(pvt->rfcomm_socket, buf, sizeof(buf))) < 0) {
-			if (strerror_r(errno, buf, sizeof(buf)))
-				ast_debug(1, "[%s] error reading from device\n", pvt->id);
-			else
-				ast_debug(1, "[%s] error reading from device: %s (%d)\n", pvt->id, buf, errno);
-
+			ast_debug(1, "[%s] error reading from device: %s (%d)\n", pvt->id, strerror(errno), errno);
 			goto e_cleanup;
 		}
 		ast_debug(1, "[%s] %s\n", pvt->id, buf);
@@ -4713,9 +4706,13 @@ static int load_module(void)
 	ast_format_cap_append(mbl_tech.capabilities, DEVICE_FRAME_FORMAT, 0);
 	/* Check if we have Bluetooth, no point loading otherwise... */
 	dev_id = hci_get_route(NULL);
+
 	s = hci_open_dev(dev_id);
 	if (dev_id < 0 || s < 0) {
 		ast_log(LOG_ERROR, "No Bluetooth devices found. Not loading module.\n");
+		ao2_ref(mbl_tech.capabilities, -1);
+		mbl_tech.capabilities = NULL;
+		hci_close_dev(s);
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -4723,6 +4720,8 @@ static int load_module(void)
 
 	if (mbl_load_config()) {
 		ast_log(LOG_ERROR, "Errors reading config file %s. Not loading module.\n", MBL_CONFIG);
+		ao2_ref(mbl_tech.capabilities, -1);
+		mbl_tech.capabilities = NULL;
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -4747,10 +4746,9 @@ static int load_module(void)
 	return AST_MODULE_LOAD_SUCCESS;
 
 e_cleanup:
-	if (sdp_session)
-		sdp_close(sdp_session);
+	unload_module();
 
-	return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_DECLINE;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Bluetooth Mobile Device Channel Driver",
diff -urpN asterisk-13.9.1/addons/chan_ooh323.c asterisk-13.17.0/addons/chan_ooh323.c
--- asterisk-13.9.1/addons/chan_ooh323.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/chan_ooh323.c	2017-07-12 13:12:08.000000000 +0200
@@ -22,6 +22,54 @@
 	<support_level>extended</support_level>
  ***/
 
+/*** DOCUMENTATION
+<info name="CHANNEL" language="en_US" tech="OOH323">
+	<enumlist>
+		<enum name="faxdetect">
+			<para>R/W Fax Detect</para>
+			<para>Returns 0 or 1</para>
+			<para>Write yes or no</para>
+		</enum>
+		<enum name="t38support">
+			<para>R/W t38support</para>
+			<para>Returns 0 or 1</para>
+			<para>Write yes or no</para>
+		</enum>
+		<enum name="h323id_url">
+			<para>R/0 Returns caller URL</para>
+			</enum>
+		<enum name="caller_h323id">
+			<para>R/0 Returns caller h323id</para>
+		</enum>
+		<enum name="caller_dialeddigits">
+			<para>R/0 Returns caller dialed digits</para>
+		</enum>
+		<enum name="caller_email">
+			<para>R/0 Returns caller email</para>
+		</enum>
+		<enum name="callee_email">
+			<para>R/0 Returns callee email</para>
+		</enum>
+		<enum name="callee_dialeddigits">
+			<para>R/0 Returns callee dialed digits</para>
+		</enum>
+		<enum name="caller_url">
+			<para>R/0 Returns caller URL</para>
+		</enum>
+		<enum name="max_forwards">
+			<para>R/W Get or set the maximum number of call forwards for this channel.
+
+			This number describes the number of times a call may be forwarded by this channel
+			before the call fails. "Forwards" in this case refers to redirects by phones as well
+			as calls to local channels.
+
+			Note that this has no relation to the SIP Max-Forwards header.
+			</para>
+		</enum>
+	</enumlist>
+</info>
+ ***/
+
 #include "chan_ooh323.h"
 #include <math.h>
 
diff -urpN asterisk-13.9.1/addons/format_mp3.c asterisk-13.17.0/addons/format_mp3.c
--- asterisk-13.9.1/addons/format_mp3.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/format_mp3.c	2017-07-12 13:12:08.000000000 +0200
@@ -120,9 +120,11 @@ static int mp3_squeue(struct ast_filestr
 
 	res = ftell(s->f);
 	p->sbuflen = fread(p->sbuf, 1, MP3_SCACHE, s->f);
-	if(p->sbuflen < 0) {
-		ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", p->sbuflen, strerror(errno));
-		return -1;
+	if (p->sbuflen < MP3_SCACHE) {
+		if (ferror(s->f)) {
+			ast_log(LOG_WARNING, "Error while reading MP3 file: %s\n", strerror(errno));
+			return -1;
+		}
 	}
 	res = decodeMP3(&p->mp,p->sbuf,p->sbuflen,p->dbuf,MP3_DCACHE,&p->dbuflen);
 	if(res != MP3_OK)
diff -urpN asterisk-13.9.1/addons/ooh323c/src/Makefile.in asterisk-13.17.0/addons/ooh323c/src/Makefile.in
--- asterisk-13.9.1/addons/ooh323c/src/Makefile.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/ooh323c/src/Makefile.in	2017-07-12 13:12:08.000000000 +0200
@@ -104,7 +104,7 @@ CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 
-libooh323c_a_AR = $(AR) cru
+libooh323c_a_AR = $(AR) cr
 libooh323c_a_LIBADD =
 am_libooh323c_a_OBJECTS = ooLogChan.$(OBJEXT) ooUtils.$(OBJEXT) \
 	ooGkClient.$(OBJEXT) context.$(OBJEXT) ooDateTime.$(OBJEXT) \
diff -urpN asterisk-13.9.1/addons/ooh323c/src/ooCalls.c asterisk-13.17.0/addons/ooh323c/src/ooCalls.c
--- asterisk-13.9.1/addons/ooh323c/src/ooCalls.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/ooh323c/src/ooCalls.c	2017-07-12 13:12:08.000000000 +0200
@@ -223,7 +223,8 @@ int ooEndCall(OOH323CallData *call)
       call->callState = OO_CALL_CLEARED;
    }
 
-   if(call->callState == OO_CALL_CLEARED || call->callState == OO_CALL_CLEAR_RELEASESENT)
+   if(call->callState == OO_CALL_CLEARED || ((strcmp(call->callType, "incoming")) &&
+     call->callState == OO_CALL_CLEAR_RELEASESENT))
    {
       ooCleanCall(call); 
       call->callState = OO_CALL_REMOVED;
diff -urpN asterisk-13.9.1/addons/ooh323c/src/ooGkClient.c asterisk-13.17.0/addons/ooh323c/src/ooGkClient.c
--- asterisk-13.9.1/addons/ooh323c/src/ooGkClient.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/ooh323c/src/ooGkClient.c	2017-07-12 13:12:08.000000000 +0200
@@ -1272,6 +1272,7 @@ int ooGkClientHandleRegistrationConfirm
       }
    }
    pGkClient->state = GkClientRegistered;
+   pGkClient->rrqRetries = 0;
    if(pGkClient->callbacks.onReceivedRegistrationConfirm)
       pGkClient->callbacks.onReceivedRegistrationConfirm(pRegistrationConfirm,
                                                               gH323ep.aliases);
diff -urpN asterisk-13.9.1/addons/ooh323c/src/oochannels.c asterisk-13.17.0/addons/ooh323c/src/oochannels.c
--- asterisk-13.9.1/addons/ooh323c/src/oochannels.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/ooh323c/src/oochannels.c	2017-07-12 13:12:08.000000000 +0200
@@ -679,9 +679,9 @@ int ooProcessCallFDSETsAndTimers
     if (0 != call->pH245Channel && 0 != call->pH245Channel->sock)
     {
      if(ooPDWrite(pfds, nfds, call->pH245Channel->sock)) {
-      while (call->pH245Channel->outQueue.count>0) {
+      if (call->pH245Channel->outQueue.count>0) {
        if (ooSendMsg(call, OOH245MSG) != OO_OK)
-	break;
+	OOTRACEERR1("Error in sending h245 message\n");
       }
      }
     }
@@ -699,26 +699,24 @@ int ooProcessCallFDSETsAndTimers
     {
      if(ooPDWrite(pfds, nfds, call->pH225Channel->sock))
      {
-      while (call->pH225Channel->outQueue.count>0)
+      if (call->pH225Channel->outQueue.count>0)
       {
        OOTRACEDBGC3("Sending H225 message (%s, %s)\n", 
                         call->callType, call->callToken);
        if (ooSendMsg(call, OOQ931MSG) != OO_OK)
-	break;
+	OOTRACEERR1("Error in sending h225 message\n");
       }
       if(call->pH245Channel && 
          call->pH245Channel->outQueue.count>0 && 
         OO_TESTFLAG (call->flags, OO_M_TUNNELING)) {
-       while (call->pH245Channel->outQueue.count>0) {
         OOTRACEDBGC3("H245 message needs to be tunneled. "
                           "(%s, %s)\n", call->callType, 
                                call->callToken);
         if (ooSendMsg(call, OOH245MSG) != OO_OK)
-	 break;
+	  OOTRACEERR1("Error in sending h245 message\n");
        }
-      }
-     }                                
-    }
+      }                                
+     }
 
      if(ooTimerNextTimeout(&call->timerList, &toNext))
      {
@@ -1061,11 +1059,6 @@ int ooH2250Receive(OOH323CallData *call)
    while(total < len)
    {
       struct pollfd pfds;
-      recvLen = ooSocketRecv (call->pH225Channel->sock, message1, len-total);
-      memcpy(message+total, message1, recvLen);
-      total = total + recvLen;
-
-      if(total == len) break; /* Complete message is received */
       
       pfds.fd = call->pH225Channel->sock;
       pfds.events = POLLIN;
@@ -1085,8 +1078,9 @@ int ooH2250Receive(OOH323CallData *call)
          }
          return OO_FAILED;
       }
-      /* If remaining part of the message is not received in 3 seconds 
-         exit */
+
+      /* exit If remaining part of the message is not received in 3 seconds */
+
       if(!ooPDRead(&pfds, 1, call->pH225Channel->sock))
       {
          OOTRACEERR3("Error: Incomplete H.2250 message received - clearing "
@@ -1099,6 +1093,23 @@ int ooH2250Receive(OOH323CallData *call)
          }
          return OO_FAILED;
       }
+
+      recvLen = ooSocketRecv (call->pH225Channel->sock, message1, len-total);
+      if (recvLen == 0) {
+         OOTRACEERR3("Error in read while receiving H.2250 message - "
+                     "clearing call (%s, %s)\n", call->callType, 
+                     call->callToken);
+         ooFreeQ931Message(pctxt, pmsg);
+         if(call->callState < OO_CALL_CLEAR)
+         {
+            call->callEndReason = OO_REASON_TRANSPORTFAILURE;
+            call->callState = OO_CALL_CLEAR;
+         }
+         return OO_FAILED;
+      }
+      memcpy(message+total, message1, recvLen);
+      total = total + recvLen;
+
    }
 
    OOTRACEDBGC3("Received Q.931 message: (%s, %s)\n", 
diff -urpN asterisk-13.9.1/addons/ooh323c/src/ooq931.c asterisk-13.17.0/addons/ooh323c/src/ooq931.c
--- asterisk-13.9.1/addons/ooh323c/src/ooq931.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/ooh323c/src/ooq931.c	2017-07-12 13:12:08.000000000 +0200
@@ -2124,9 +2124,6 @@ int ooSendReleaseComplete(OOH323CallData
       return OO_FAILED;
    }
    memset(releaseComplete, 0, sizeof(H225ReleaseComplete_UUIE));
-   q931msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent=1; 
-   q931msg->userInfo->h323_uu_pdu.h245Tunneling = OO_TESTFLAG(call->flags, 
-                                                              OO_M_TUNNELING); 
    q931msg->userInfo->h323_uu_pdu.h323_message_body.t = 
          T_H225H323_UU_PDU_h323_message_body_releaseComplete;
    
@@ -2143,8 +2140,6 @@ int ooSendReleaseComplete(OOH323CallData
    releaseComplete->reason.t = h225ReasonCode;
 
    /* Add user-user ie */
-   q931msg->userInfo->h323_uu_pdu.m.h245TunnelingPresent=TRUE; 
-   q931msg->userInfo->h323_uu_pdu.h245Tunneling = OO_TESTFLAG (call->flags, OO_M_TUNNELING);
    q931msg->userInfo->h323_uu_pdu.h323_message_body.t = 
            T_H225H323_UU_PDU_h323_message_body_releaseComplete;
    
diff -urpN asterisk-13.9.1/addons/res_config_mysql.c asterisk-13.17.0/addons/res_config_mysql.c
--- asterisk-13.9.1/addons/res_config_mysql.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/addons/res_config_mysql.c	2017-07-12 13:12:08.000000000 +0200
@@ -126,7 +126,6 @@ static char *handle_cli_realtime_mysql_s
 static char *handle_cli_realtime_mysql_cache(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
 static int load_mysql_config(struct ast_config *config, const char *category, struct mysql_conn *conn);
 static int require_mysql(const char *database, const char *tablename, va_list ap);
-static int internal_require(const char *database, const char *table, ...) attribute_sentinel;
 
 static struct ast_cli_entry cli_realtime_mysql_status[] = {
 	AST_CLI_DEFINE(handle_cli_realtime_mysql_status, "Shows connection information for the MySQL RealTime driver"),
@@ -165,16 +164,6 @@ static struct mysql_conn *find_database(
 
 #define release_database(a)	ast_mutex_unlock(&(a)->lock)
 
-static int internal_require(const char *database, const char *table, ...)
-{
-	va_list ap;
-	int res;
-	va_start(ap, table);
-	res = require_mysql(database, table, ap);
-	va_end(ap);
-	return res;
-}
-
 static void destroy_table(struct tables *table)
 {
 	struct columns *column;
@@ -316,6 +305,11 @@ static char *decode_chunk(char *chunk)
 	return orig;
 }
 
+#define IS_SQL_LIKE_CLAUSE(x) ((x) && ast_ends_with(x, " LIKE"))
+
+/* MySQL requires us to escape the escape... yo dawg */
+static char *ESCAPE_CLAUSE = " ESCAPE '\\\\'";
+
 static struct ast_variable *realtime_mysql(const char *database, const char *table, const struct ast_variable *rt_fields)
 {
 	struct mysql_conn *dbh;
@@ -328,6 +322,7 @@ static struct ast_variable *realtime_mys
 	char *stringp;
 	char *chunk;
 	char *op;
+	char *escape = "";
 	const struct ast_variable *field = rt_fields;
 	struct ast_variable *var=NULL, *prev=NULL;
 
@@ -358,20 +353,29 @@ static struct ast_variable *realtime_mys
 	/* Create the first part of the query using the first parameter/value pairs we just extracted
 	   If there is only 1 set, then we have our query. Otherwise, loop thru the list and concat */
 
-	if (!strchr(field->name, ' ')) 
-		op = " ="; 
-	else 
+	if (!strchr(field->name, ' ')) {
+		op = " =";
+	} else {
 		op = "";
+		if (IS_SQL_LIKE_CLAUSE(field->name)) {
+			escape = ESCAPE_CLAUSE;
+		}
+	}
 
 	ESCAPE_STRING(buf, field->value);
-	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'", table, field->name, op, ast_str_buffer(buf));
+	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'%s", table, field->name, op, ast_str_buffer(buf), escape);
 	while ((field = field->next)) {
-		if (!strchr(field->name, ' ')) 
-			op = " ="; 
-		else
+		escape = "";
+		if (!strchr(field->name, ' ')) {
+			op = " =";
+		} else {
 			op = "";
+			if (IS_SQL_LIKE_CLAUSE(field->name)) {
+				escape = ESCAPE_CLAUSE;
+			}
+		}
 		ESCAPE_STRING(buf, field->value);
-		ast_str_append(&sql, 0, " AND %s%s '%s'", field->name, op, ast_str_buffer(buf));
+		ast_str_append(&sql, 0, " AND %s%s '%s'%s", field->name, op, ast_str_buffer(buf), escape);
 	}
 
 	ast_debug(1, "MySQL RealTime: Retrieve SQL: %s\n", ast_str_buffer(sql));
@@ -429,6 +433,7 @@ static struct ast_config *realtime_multi
 	char *stringp;
 	char *chunk;
 	char *op;
+	char *escape = "";
 	const struct ast_variable *field = rt_fields;
 	struct ast_variable *var = NULL;
 	struct ast_config *cfg = NULL;
@@ -475,17 +480,29 @@ static struct ast_config *realtime_multi
 	/* Create the first part of the query using the first parameter/value pairs we just extracted
 	   If there is only 1 set, then we have our query. Otherwise, loop thru the list and concat */
 
-	if (!strchr(field->name, ' '))
+	if (!strchr(field->name, ' ')) {
 		op = " =";
-	else
+	} else {
 		op = "";
+		if (IS_SQL_LIKE_CLAUSE(field->name)) {
+			escape = ESCAPE_CLAUSE;
+		}
+	}
 
 	ESCAPE_STRING(buf, field->value);
-	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'", table, field->name, op, ast_str_buffer(buf));
+	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'%s", table, field->name, op, ast_str_buffer(buf), escape);
 	while ((field = field->next)) {
-		if (!strchr(field->name, ' ')) op = " ="; else op = "";
+		escape = "";
+		if (!strchr(field->name, ' ')) {
+			op = " =";
+		} else {
+			op = "";
+			if (IS_SQL_LIKE_CLAUSE(field->name)) {
+				escape = ESCAPE_CLAUSE;
+			}
+		}
 		ESCAPE_STRING(buf, field->value);
-		ast_str_append(&sql, 0, " AND %s%s '%s'", field->name, op, ast_str_buffer(buf));
+		ast_str_append(&sql, 0, " AND %s%s '%s'%s", field->name, op, ast_str_buffer(buf), escape);
 	}
 
 	if (initfield) {
@@ -508,9 +525,8 @@ static struct ast_config *realtime_multi
 
 		while ((row = mysql_fetch_row(result))) {
 			var = NULL;
-			cat = ast_category_new("", "", -1);
+			cat = ast_category_new_anonymous();
 			if (!cat) {
-				ast_log(LOG_WARNING, "Out of memory!\n");
 				continue;
 			}
 			for (i = 0; i < numFields; i++) {
@@ -600,11 +616,6 @@ static int update_mysql(const char *data
 	ESCAPE_STRING(buf, field->value);
 	ast_str_set(&sql, 0, "UPDATE %s SET `%s` = '%s'", tablename, field->name, ast_str_buffer(buf));
 
-	/* If the column length isn't long enough, give a chance to lengthen it. */
-	if (strncmp(column->type, "char", 4) == 0 || strncmp(column->type, "varchar", 7) == 0) {
-		internal_require(database, tablename, field->name, RQ_CHAR, ast_str_strlen(buf), SENTINEL);
-	}
-
 	while ((field = field->next)) {
 		/* If the column is not within the table, then skip it */
 		if (!(column = find_column(table, field->name))) {
@@ -614,11 +625,6 @@ static int update_mysql(const char *data
 
 		ESCAPE_STRING(buf, field->value);
 		ast_str_append(&sql, 0, ", `%s` = '%s'", field->name, ast_str_buffer(buf));
-
-		/* If the column length isn't long enough, give a chance to lengthen it. */
-		if (strncmp(column->type, "char", 4) == 0 || strncmp(column->type, "varchar", 7) == 0) {
-			internal_require(database, tablename, field->name, RQ_CHAR, ast_str_strlen(buf), SENTINEL);
-		}
 	}
 
 	ESCAPE_STRING(buf, lookup);
@@ -703,11 +709,6 @@ static int update2_mysql(const char *dat
 		ESCAPE_STRING(buf, field->value);
 		ast_str_append(&where, 0, "%s `%s` = '%s'", first ? "" : " AND", field->name, ast_str_buffer(buf));
 		first = 0;
-
-		/* If the column length isn't long enough, give a chance to lengthen it. */
-		if (strncmp(column->type, "char", 4) == 0 || strncmp(column->type, "varchar", 7) == 0) {
-			internal_require(database, tablename, field->name, RQ_CHAR, ast_str_strlen(buf), SENTINEL);
-		}
 	}
 
 	first = 1;
@@ -721,11 +722,6 @@ static int update2_mysql(const char *dat
 		ESCAPE_STRING(buf, field->value);
 		ast_str_append(&sql, 0, "%s `%s` = '%s'", first ? "" : ",", field->name, ast_str_buffer(buf));
 		first = 0;
-
-		/* If the column length isn't long enough, give a chance to lengthen it. */
-		if (strncmp(column->type, "char", 4) == 0 || strncmp(column->type, "varchar", 7) == 0) {
-			internal_require(database, tablename, field->name, RQ_CHAR, ast_str_strlen(buf), SENTINEL);
-		}
 	}
 
 	release_table(table);
@@ -759,7 +755,6 @@ static int update2_mysql(const char *dat
 static int store_mysql(const char *database, const char *table, const struct ast_variable *rt_fields)
 {
 	struct mysql_conn *dbh;
-	my_ulonglong insertid;
 	struct ast_str *sql = ast_str_thread_get(&sql_buf, 16);
 	struct ast_str *sql2 = ast_str_thread_get(&sql2_buf, 16);
 	struct ast_str *buf = ast_str_thread_get(&scratch_buf, 16);
@@ -792,15 +787,11 @@ static int store_mysql(const char *datab
 	ast_str_set(&sql, 0, "INSERT INTO %s (`%s`", table, field->name);
 	ast_str_set(&sql2, 0, ") VALUES ('%s'", ast_str_buffer(buf));
 
-	internal_require(database, table, field->name, RQ_CHAR, ast_str_strlen(buf), SENTINEL);
-
 	while ((field = field->next)) {
 		ESCAPE_STRING(buf, field->value);
 
-		if (internal_require(database, table, field->name, RQ_CHAR, ast_str_strlen(buf), SENTINEL) == 0) {
-			ast_str_append(&sql, 0, ", `%s`", field->name);
-			ast_str_append(&sql2, 0, ", '%s'", ast_str_buffer(buf));
-		}
+		ast_str_append(&sql, 0, ", `%s`", field->name);
+		ast_str_append(&sql2, 0, ", '%s'", ast_str_buffer(buf));
 	}
 	ast_str_append(&sql, 0, "%s)", ast_str_buffer(sql2));
 	ast_debug(1,"MySQL RealTime: Insert SQL: %s\n", ast_str_buffer(sql));
@@ -812,18 +803,11 @@ static int store_mysql(const char *datab
 		return -1;
 	}
 
-	/*!\note The return value is non-portable and may change in future versions. */
-	insertid = mysql_insert_id(&dbh->handle);
 	release_database(dbh);
 
-	ast_debug(1, "MySQL RealTime: row inserted on table: %s, id: %llu\n", table, insertid);
+	ast_debug(1, "MySQL RealTime: row inserted on table: %s\n", table);
 
-	/* From http://dev.mysql.com/doc/mysql/en/mysql-affected-rows.html
-	 * An integer greater than zero indicates the number of rows affected
-	 * Zero indicates that no records were updated
-	 * -1 indicates that the query returned an error (although, if the query failed, it should have been caught above.)
-	*/
-	return (int)insertid;
+	return 1;
 }
 
 static int destroy_mysql(const char *database, const char *table, const char *keyfield, const char *lookup, const struct ast_variable *rt_fields)
@@ -951,8 +935,8 @@ static struct ast_config *config_mysql(c
 			}
 
 			if (strcmp(last, row[0]) || last_cat_metric != atoi(row[3])) {
-				if (!(cur_cat = ast_category_new(row[0], "", -1))) {
-					ast_log(LOG_WARNING, "Out of memory!\n");
+				cur_cat = ast_category_new_dynamic(row[0]);
+				if (!cur_cat) {
 					break;
 				}
 				strcpy(last, row[0]);
@@ -989,105 +973,14 @@ static int unload_mysql(const char *data
 	return cur ? 0 : -1;
 }
 
-static int modify_mysql(const char *database, const char *tablename, struct columns *column, require_type type, int len)
-{
-	/*!\note Cannot use ANY of the same scratch space as is used in other functions, as this one is interspersed. */
-	struct ast_str *sql = ast_str_thread_get(&modify_buf, 100), *escbuf = ast_str_thread_get(&modify2_buf, 100);
-	struct ast_str *typestr = ast_str_thread_get(&modify3_buf, 30);
-	int waschar = strncasecmp(column->type, "char", 4) == 0 ? 1 : 0;
-	int wasvarchar = strncasecmp(column->type, "varchar", 7) == 0 ? 1 : 0;
-	int res = 0;
-	struct mysql_conn *dbh;
-
-	if (!(dbh = find_database(database, 1))) {
-		return -1;
-	}
-
-	do {
-		if (type == RQ_CHAR || waschar || wasvarchar) {
-			if (wasvarchar) {
-				ast_str_set(&typestr, 0, "VARCHAR(%d)", len);
-			} else {
-				ast_str_set(&typestr, 0, "CHAR(%d)", len);
-			}
-		} else if (type == RQ_UINTEGER1) {
-			ast_str_set(&typestr, 0, "tinyint(3) unsigned");
-		} else if (type == RQ_INTEGER1) {
-			ast_str_set(&typestr, 0, "tinyint(4)");
-		} else if (type == RQ_UINTEGER2) {
-			ast_str_set(&typestr, 0, "smallint(5) unsigned");
-		} else if (type == RQ_INTEGER2) {
-			ast_str_set(&typestr, 0, "smallint(6)");
-		} else if (type == RQ_UINTEGER3) {
-			ast_str_set(&typestr, 0, "mediumint(8) unsigned");
-		} else if (type == RQ_INTEGER3) {
-			ast_str_set(&typestr, 0, "mediumint(8)");
-		} else if (type == RQ_UINTEGER4) {
-			ast_str_set(&typestr, 0, "int(10) unsigned");
-		} else if (type == RQ_INTEGER4) {
-			ast_str_set(&typestr, 0, "int(11)");
-		} else if (type == RQ_UINTEGER8) {
-			ast_str_set(&typestr, 0, "bigint(19) unsigned");
-		} else if (type == RQ_INTEGER8) {
-			ast_str_set(&typestr, 0, "bigint(20)");
-		} else if (type == RQ_DATETIME) {
-			ast_str_set(&typestr, 0, "datetime");
-		} else if (type == RQ_DATE) {
-			ast_str_set(&typestr, 0, "date");
-		} else if (type == RQ_FLOAT) {
-			ast_str_set(&typestr, 0, "FLOAT(%d,2)", len);
-		} else {
-			ast_log(LOG_ERROR, "Unknown type (should NEVER happen)\n");
-			res = -1;
-			break;
-		}
-		ast_str_set(&sql, 0, "ALTER TABLE %s MODIFY `%s` %s", tablename, column->name, ast_str_buffer(typestr));
-		if (!column->null) {
-			ast_str_append(&sql, 0, " NOT NULL");
-		}
-		if (!ast_strlen_zero(column->dflt)) {
-			ESCAPE_STRING(escbuf, column->dflt);
-			ast_str_append(&sql, 0, " DEFAULT '%s'", ast_str_buffer(escbuf));
-		}
-
-		if (!mysql_reconnect(dbh)) {
-			ast_log(LOG_ERROR, "Unable to add column: %s\n", ast_str_buffer(sql));
-			res = -1;
-			break;
-		}
-
-		/* Execution. */
-		if (mysql_real_query(&dbh->handle, ast_str_buffer(sql), ast_str_strlen(sql))) {
-			ast_log(LOG_WARNING, "MySQL RealTime: Failed to modify database: %s\n", mysql_error(&dbh->handle));
-			ast_debug(1, "MySQL RealTime: Query: %s\n", ast_str_buffer(sql));
-			res = -1;
-		}
-	} while (0);
-
-	release_database(dbh);
-	return res;
-}
-
-#define PICK_WHICH_ALTER_ACTION(stringtype) \
-	if (table->database->requirements == RQ_WARN) {                                                                       \
-		ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
-			"the required data length: %d (detected stringtype)\n",                                      \
-			tablename, database, column->name, size);                                                    \
-		res = -1;                                                                                        \
-	} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {     \
-		table_altered = 1;                                                                               \
-	} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {   \
-		table_altered = 1;                                                                               \
-	} else {                                                                                             \
-		res = -1;                                                                                        \
-	}
-
 static int require_mysql(const char *database, const char *tablename, va_list ap)
 {
 	struct columns *column;
 	struct tables *table = find_table(database, tablename);
 	char *elm;
-	int type, size, res = 0, table_altered = 0;
+	int type;
+	int size;
+	int res = 0;
 
 	if (!table) {
 		ast_log(LOG_WARNING, "Table %s not found in database.  This table should exist if you're using realtime.\n", tablename);
@@ -1097,55 +990,54 @@ static int require_mysql(const char *dat
 	while ((elm = va_arg(ap, char *))) {
 		type = va_arg(ap, require_type);
 		size = va_arg(ap, int);
+
 		AST_LIST_TRAVERSE(&table->columns, column, list) {
 			if (strcmp(column->name, elm) == 0) {
 				/* Char can hold anything, as long as it is large enough */
 				if (strncmp(column->type, "char", 4) == 0 || strncmp(column->type, "varchar", 7) == 0) {
 					if ((size > column->len) && column->len != -1) {
-						if (table->database->requirements == RQ_WARN) {
-							ast_log(LOG_WARNING, "Realtime table %s@%s: Column '%s' should be at least %d long, but is only %d long.\n", database, tablename, column->name, size, column->len);
-							res = -1;
-						} else if (modify_mysql(database, tablename, column, type, size) == 0) {
-							table_altered = 1;
-						} else {
-							res = -1;
-						}
+						ast_log(LOG_WARNING, "Realtime table %s@%s: Column '%s' should be at least %d long, but is only %d long.\n", database, tablename, column->name, size, column->len);
+						res = -1;
 					}
 				} else if (strcasestr(column->type, "unsigned")) {
 					if (!ast_rq_is_int(type)) {
-						if (table->database->requirements == RQ_WARN) {
-							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' cannot be type '%s' (need %s)\n",
-								database, tablename, column->name, column->type,
-								type == RQ_CHAR ? "char" : type == RQ_FLOAT ? "float" :
-								type == RQ_DATETIME ? "datetime" : type == RQ_DATE ? "date" : "a rather stiff drink");
-							res = -1;
-						} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {
-							table_altered = 1;
-						} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {
-							table_altered = 1;
-						} else {
-							res = -1;
-						}
+						ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' cannot be type '%s' (need %s)\n",
+							database, tablename, column->name, column->type,
+							type == RQ_CHAR ? "char" : type == RQ_FLOAT ? "float" :
+							type == RQ_DATETIME ? "datetime" : type == RQ_DATE ? "date" : "a rather stiff drink");
+						res = -1;
 					} else if (strncasecmp(column->type, "tinyint", 1) == 0) {
 						if (type != RQ_UINTEGER1) {
-							PICK_WHICH_ALTER_ACTION(unsigned tinyint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "smallint", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 && type != RQ_UINTEGER2) {
-							PICK_WHICH_ALTER_ACTION(unsigned smallint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "mediumint", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 &&
 							type != RQ_UINTEGER2 && type != RQ_INTEGER2 &&
 							type != RQ_UINTEGER3) {
-							PICK_WHICH_ALTER_ACTION(unsigned mediumint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "int", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 &&
 							type != RQ_UINTEGER2 && type != RQ_INTEGER2 &&
 							type != RQ_UINTEGER3 && type != RQ_INTEGER3 &&
 							type != RQ_UINTEGER4) {
-							PICK_WHICH_ALTER_ACTION(unsigned int)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "bigint", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 &&
@@ -1153,45 +1045,52 @@ static int require_mysql(const char *dat
 							type != RQ_UINTEGER3 && type != RQ_INTEGER3 &&
 							type != RQ_UINTEGER4 && type != RQ_INTEGER4 &&
 							type != RQ_UINTEGER8) {
-							PICK_WHICH_ALTER_ACTION(unsigned bigint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					}
 				} else if (strcasestr(column->type, "int")) {
 					if (!ast_rq_is_int(type)) {
-						if (table->database->requirements == RQ_WARN) {
-							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' cannot be type '%s' (need %s)\n",
-								database, tablename, column->name, column->type,
-								type == RQ_CHAR ? "char" : type == RQ_FLOAT ? "float" :
-								type == RQ_DATETIME ? "datetime" : type == RQ_DATE ? "date" :
-								"to get a life, rather than writing silly error messages");
-							res = -1;
-						} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {
-							table_altered = 1;
-						} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {
-							table_altered = 1;
-						} else {
-							res = -1;
-						}
+						ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' cannot be type '%s' (need %s)\n",
+							database, tablename, column->name, column->type,
+							type == RQ_CHAR ? "char" : type == RQ_FLOAT ? "float" :
+							type == RQ_DATETIME ? "datetime" : type == RQ_DATE ? "date" :
+							"to get a life, rather than writing silly error messages");
+						res = -1;
 					} else if (strncasecmp(column->type, "tinyint", 1) == 0) {
 						if (type != RQ_INTEGER1) {
-							PICK_WHICH_ALTER_ACTION(tinyint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "smallint", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 && type != RQ_INTEGER2) {
-							PICK_WHICH_ALTER_ACTION(smallint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "mediumint", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 &&
 							type != RQ_UINTEGER2 && type != RQ_INTEGER2 &&
 							type != RQ_INTEGER3) {
-							PICK_WHICH_ALTER_ACTION(mediumint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "int", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 &&
 							type != RQ_UINTEGER2 && type != RQ_INTEGER2 &&
 							type != RQ_UINTEGER3 && type != RQ_INTEGER3 &&
 							type != RQ_INTEGER4) {
-							PICK_WHICH_ALTER_ACTION(int)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					} else if (strncasecmp(column->type, "bigint", 1) == 0) {
 						if (type != RQ_UINTEGER1 && type != RQ_INTEGER1 &&
@@ -1199,137 +1098,41 @@ static int require_mysql(const char *dat
 							type != RQ_UINTEGER3 && type != RQ_INTEGER3 &&
 							type != RQ_UINTEGER4 && type != RQ_INTEGER4 &&
 							type != RQ_INTEGER8) {
-							PICK_WHICH_ALTER_ACTION(bigint)
+							ast_log(LOG_WARNING, "Realtime table %s@%s: column '%s' may not be large enough for "            \
+								"the required data length: %d (detected stringtype)\n",                                      \
+								tablename, database, column->name, size);                                                    \
+							res = -1;                                                                                        \
 						}
 					}
 				} else if (strncmp(column->type, "float", 5) == 0) {
 					if (!ast_rq_is_int(type) && type != RQ_FLOAT) {
-						if (table->database->requirements == RQ_WARN) {
-							ast_log(LOG_WARNING, "Realtime table %s@%s: Column %s cannot be a %s\n", tablename, database, column->name, column->type);
-							res = -1;
-						} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {
-							table_altered = 1;
-						} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {
-							table_altered = 1;
-						} else {
-							res = -1;
-						}
+						ast_log(LOG_WARNING, "Realtime table %s@%s: Column %s cannot be a %s\n", tablename, database, column->name, column->type);
+						res = -1;
 					}
 				} else if (strncmp(column->type, "datetime", 8) == 0 || strncmp(column->type, "timestamp", 9) == 0) {
 					if (type != RQ_DATETIME) {
-						if (table->database->requirements == RQ_WARN) {
-							ast_log(LOG_WARNING, "Realtime table %s@%s: Column %s cannot be a %s\n", tablename, database, column->name, column->type);
-							res = -1;
-						} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {
-							table_altered = 1;
-						} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {
-							table_altered = 1;
-						} else {
-							res = -1;
-						}
+						ast_log(LOG_WARNING, "Realtime table %s@%s: Column %s cannot be a %s\n", tablename, database, column->name, column->type);
+						res = -1;
 					}
 				} else if (strncmp(column->type, "date", 4) == 0) {
 					if (type != RQ_DATE) {
-						if (table->database->requirements == RQ_WARN) {
-							ast_log(LOG_WARNING, "Realtime table %s@%s: Column %s cannot be a %s\n", tablename, database, column->name, column->type);
-							res = -1;
-						} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {
-							table_altered = 1;
-						} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {
-							table_altered = 1;
-						} else {
-							res = -1;
-						}
-					}
-				} else { /* Other, possibly unsupported types? */
-					if (table->database->requirements == RQ_WARN) {
-						ast_log(LOG_WARNING, "Possibly unsupported column type '%s' on column '%s'\n", column->type, column->name);
+						ast_log(LOG_WARNING, "Realtime table %s@%s: Column %s cannot be a %s\n", tablename, database, column->name, column->type);
 						res = -1;
-					} else if (table->database->requirements == RQ_CREATECLOSE && modify_mysql(database, tablename, column, type, size) == 0) {
-						table_altered = 1;
-					} else if (table->database->requirements == RQ_CREATECHAR && modify_mysql(database, tablename, column, RQ_CHAR, size) == 0) {
-						table_altered = 1;
-					} else {
 					}
+				} else { /* Other, possibly unsupported types? */
+					ast_log(LOG_WARNING, "Possibly unsupported column type '%s' on column '%s'\n", column->type, column->name);
+					res = -1;
 				}
 				break;
 			}
 		}
 
 		if (!column) {
-			if (table->database->requirements == RQ_WARN) {
-				ast_log(LOG_WARNING, "Table %s requires a column '%s' of size '%d', but no such column exists.\n", tablename, elm, size);
-			} else {
-				struct ast_str *sql = ast_str_thread_get(&modify_buf, 100), *fieldtype = ast_str_thread_get(&modify3_buf, 16);
-
-				if (table->database->requirements == RQ_CREATECHAR || type == RQ_CHAR) {
-					ast_str_set(&fieldtype, 0, "CHAR(%d)", size);
-				} else if (type == RQ_UINTEGER1 || type == RQ_UINTEGER2 || type == RQ_UINTEGER3 || type == RQ_UINTEGER4 || type == RQ_UINTEGER8) {
-					if (type == RQ_UINTEGER1) {
-						ast_str_set(&fieldtype, 0, "TINYINT(3) UNSIGNED");
-					} else if (type == RQ_UINTEGER2) {
-						ast_str_set(&fieldtype, 0, "SMALLINT(5) UNSIGNED");
-					} else if (type == RQ_UINTEGER3) {
-						ast_str_set(&fieldtype, 0, "MEDIUMINT(8) UNSIGNED");
-					} else if (type == RQ_UINTEGER4) {
-						ast_str_set(&fieldtype, 0, "INT(10) UNSIGNED");
-					} else if (type == RQ_UINTEGER8) {
-						ast_str_set(&fieldtype, 0, "BIGINT(20) UNSIGNED");
-					} else {
-						ast_log(LOG_WARNING, "Somebody should check this code for a rather large bug... it's about to squash Tokyo.\n");
-						continue;
-					}
-				} else if (ast_rq_is_int(type)) {
-					if (type == RQ_INTEGER1) {
-						ast_str_set(&fieldtype, 0, "TINYINT(3)");
-					} else if (type == RQ_INTEGER2) {
-						ast_str_set(&fieldtype, 0, "SMALLINT(5)");
-					} else if (type == RQ_INTEGER3) {
-						ast_str_set(&fieldtype, 0, "MEDIUMINT(8)");
-					} else if (type == RQ_INTEGER4) {
-						ast_str_set(&fieldtype, 0, "INT(10)");
-					} else if (type == RQ_INTEGER8) {
-						ast_str_set(&fieldtype, 0, "BIGINT(20)");
-					} else {
-						ast_log(LOG_WARNING, "Somebody should check this code for a rather large bug... it's about to eat Cincinnati.\n");
-						continue;
-					}
-				} else if (type == RQ_FLOAT) {
-					ast_str_set(&fieldtype, 0, "FLOAT");
-				} else if (type == RQ_DATE) {
-					ast_str_set(&fieldtype, 0, "DATE");
-				} else if (type == RQ_DATETIME) {
-					ast_str_set(&fieldtype, 0, "DATETIME");
-				} else {
-					continue;
-				}
-				ast_str_set(&sql, 0, "ALTER TABLE %s ADD COLUMN %s %s", tablename, elm, ast_str_buffer(fieldtype));
-
-				ast_mutex_lock(&table->database->lock);
-				if (!mysql_reconnect(table->database)) {
-					ast_mutex_unlock(&table->database->lock);
-					ast_log(LOG_ERROR, "Unable to add column: %s\n", ast_str_buffer(sql));
-					continue;
-				}
-
-				/* Execution. */
-				if (mysql_real_query(&table->database->handle, ast_str_buffer(sql), ast_str_strlen(sql))) {
-					ast_log(LOG_WARNING, "MySQL RealTime: Failed to query database. Check debug for more info.\n");
-					ast_debug(1, "MySQL RealTime: Query: %s\n", ast_str_buffer(sql));
-					ast_debug(1, "MySQL RealTime: Query Failed because: %s\n", mysql_error(&table->database->handle));
-				} else {
-					table_altered = 1;
-				}
-			}
+			ast_log(LOG_WARNING, "Table %s requires a column '%s' of size '%d', but no such column exists.\n", tablename, elm, size);
 		}
 	}
 	release_table(table);
 
-	/* If we altered the table, we must refresh the cache */
-	if (table_altered) {
-		unload_mysql(database, tablename);
-		release_table(find_table(database, tablename));
-	}
 	return res;
 }
 
diff -urpN asterisk-13.9.1/apps/Makefile asterisk-13.17.0/apps/Makefile
--- asterisk-13.9.1/apps/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -30,7 +30,7 @@ include $(ASTTOPDIR)/Makefile.moddir_rul
 clean::
 	rm -f confbridge/*.o confbridge/*.i confbridge/*.gcda confbridge/*.gcno
 
-$(if $(filter app_confbridge,$(EMBEDDED_MODS)),modules.link,app_confbridge.so): $(subst .c,.o,$(wildcard confbridge/*.c))
+app_confbridge.so: $(subst .c,.o,$(wildcard confbridge/*.c))
 $(subst .c,.o,$(wildcard confbridge/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,app_confbridge)
 
 ifneq ($(findstring $(OSARCH), mingw32 cygwin ),)
diff -urpN asterisk-13.9.1/apps/app_adsiprog.c asterisk-13.17.0/apps/app_adsiprog.c
--- asterisk-13.9.1/apps/app_adsiprog.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_adsiprog.c	2017-07-12 13:12:08.000000000 +0200
@@ -1607,7 +1607,7 @@ static int unload_module(void)
 static int load_module(void)
 {
 	if (ast_register_application_xml(app, adsi_exec))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/apps/app_agent_pool.c asterisk-13.17.0/apps/app_agent_pool.c
--- asterisk-13.9.1/apps/app_agent_pool.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_agent_pool.c	2017-07-12 13:12:08.000000000 +0200
@@ -2655,7 +2655,7 @@ static int load_module(void)
 	agents = ao2_container_alloc_rbtree(AO2_ALLOC_OPT_LOCK_MUTEX,
 		AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE, agent_pvt_sort_cmp, agent_pvt_cmp);
 	if (!agents) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Init agent holding bridge v_table. */
@@ -2679,8 +2679,9 @@ static int load_module(void)
 	res |= ast_register_application_xml(app_agent_request, agent_request_exec);
 
 	if (res) {
+		ast_log(LOG_ERROR, "Unable to register application. Not loading module.\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (load_config()) {
diff -urpN asterisk-13.9.1/apps/app_alarmreceiver.c asterisk-13.17.0/apps/app_alarmreceiver.c
--- asterisk-13.9.1/apps/app_alarmreceiver.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_alarmreceiver.c	2017-07-12 13:12:08.000000000 +0200
@@ -977,7 +977,7 @@ static int load_module(void)
 {
 	if (load_config(0)) {
 		if (ast_register_application_xml(app, alarmreceiver_exec)) {
-			return AST_MODULE_LOAD_FAILURE;
+			return AST_MODULE_LOAD_DECLINE;
 		}
 		return AST_MODULE_LOAD_SUCCESS;
 	}
diff -urpN asterisk-13.9.1/apps/app_authenticate.c asterisk-13.17.0/apps/app_authenticate.c
--- asterisk-13.9.1/apps/app_authenticate.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_authenticate.c	2017-07-12 13:12:08.000000000 +0200
@@ -272,7 +272,7 @@ static int unload_module(void)
 static int load_module(void)
 {
 	if (ast_register_application_xml(app, auth_exec))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/apps/app_cdr.c asterisk-13.17.0/apps/app_cdr.c
--- asterisk-13.9.1/apps/app_cdr.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_cdr.c	2017-07-12 13:12:08.000000000 +0200
@@ -251,7 +251,7 @@ static int load_module(void)
 	int res = 0;
 
 	if (!router) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	res |= STASIS_MESSAGE_TYPE_INIT(appcdr_message_type);
@@ -261,7 +261,8 @@ static int load_module(void)
 	                                 appcdr_callback, NULL);
 
 	if (res) {
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/apps/app_chanspy.c asterisk-13.17.0/apps/app_chanspy.c
--- asterisk-13.9.1/apps/app_chanspy.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_chanspy.c	2017-07-12 13:12:08.000000000 +0200
@@ -498,10 +498,15 @@ static struct ast_generator spygen = {
 
 static int start_spying(struct ast_autochan *autochan, const char *spychan_name, struct ast_audiohook *audiohook)
 {
+	int res;
+
+	ast_autochan_channel_lock(autochan);
 	ast_log(LOG_NOTICE, "Attaching %s to %s\n", spychan_name, ast_channel_name(autochan->chan));
 
 	ast_set_flag(audiohook, AST_AUDIOHOOK_TRIGGER_SYNC | AST_AUDIOHOOK_SMALL_QUEUE);
-	return ast_audiohook_attach(autochan->chan, audiohook);
+	res = ast_audiohook_attach(autochan->chan, audiohook);
+	ast_autochan_channel_unlock(autochan);
+	return res;
 }
 
 static void change_spy_mode(const char digit, struct ast_flags *flags)
@@ -585,8 +590,14 @@ static int attach_barge(struct ast_autoc
 {
 	int retval = 0;
 	struct ast_autochan *internal_bridge_autochan;
-	RAII_VAR(struct ast_channel *, bridged, ast_channel_bridge_peer(spyee_autochan->chan), ast_channel_cleanup);
+	struct ast_channel *spyee_chan;
+	RAII_VAR(struct ast_channel *, bridged, NULL, ast_channel_cleanup);
 
+	ast_autochan_channel_lock(spyee_autochan);
+	spyee_chan = ast_channel_ref(spyee_autochan->chan);
+	ast_autochan_channel_unlock(spyee_autochan);
+	bridged = ast_channel_bridge_peer(spyee_chan);
+	ast_channel_unref(spyee_chan);
 	if (!bridged) {
 		return -1;
 	}
@@ -598,12 +609,10 @@ static int attach_barge(struct ast_autoc
 		return -1;
 	}
 
-	ast_autochan_channel_lock(internal_bridge_autochan);
 	if (start_spying(internal_bridge_autochan, spyer_name, bridge_whisper_audiohook)) {
 		ast_log(LOG_WARNING, "Unable to attach barge audiohook on spyee '%s'. Barge mode disabled.\n", name);
 		retval = -1;
 	}
-	ast_autochan_channel_unlock(internal_bridge_autochan);
 
 	*spyee_bridge_autochan = internal_bridge_autochan;
 
@@ -623,21 +632,25 @@ static int channel_spy(struct ast_channe
 	struct ast_autochan *spyee_bridge_autochan = NULL;
 	const char *spyer_name;
 
-	if (ast_check_hangup(chan) || ast_check_hangup(spyee_autochan->chan) ||
-			ast_test_flag(ast_channel_flags(spyee_autochan->chan), AST_FLAG_ZOMBIE)) {
+	ast_channel_lock(chan);
+	if (ast_check_hangup(chan)) {
+		ast_channel_unlock(chan);
 		return 0;
 	}
-
-	ast_channel_lock(chan);
 	spyer_name = ast_strdupa(ast_channel_name(chan));
 	ast_channel_unlock(chan);
 
 	ast_autochan_channel_lock(spyee_autochan);
+	if (ast_check_hangup(spyee_autochan->chan)
+		|| ast_test_flag(ast_channel_flags(spyee_autochan->chan), AST_FLAG_ZOMBIE)) {
+		ast_autochan_channel_unlock(spyee_autochan);
+		return 0;
+	}
 	name = ast_strdupa(ast_channel_name(spyee_autochan->chan));
-	ast_autochan_channel_unlock(spyee_autochan);
 
 	ast_verb(2, "Spying on channel %s\n", name);
 	publish_chanspy_message(chan, spyee_autochan->chan, 1);
+	ast_autochan_channel_unlock(spyee_autochan);
 
 	memset(&csth, 0, sizeof(csth));
 	ast_copy_flags(&csth.flags, flags, AST_FLAGS_ALL);
@@ -663,9 +676,7 @@ static int channel_spy(struct ast_channe
 		}
 	}
 
-	ast_channel_lock(chan);
-	ast_set_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
-	ast_channel_unlock(chan);
+	ast_channel_set_flag(chan, AST_FLAG_END_DTMF_ONLY);
 
 	csth.volfactor = *volfactor;
 
@@ -795,9 +806,7 @@ static int channel_spy(struct ast_channe
 	else
 		ast_deactivate_generator(chan);
 
-	ast_channel_lock(chan);
-	ast_clear_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
-	ast_channel_unlock(chan);
+	ast_channel_clear_flag(chan, AST_FLAG_END_DTMF_ONLY);
 
 	if (ast_test_flag(flags, OPTION_WHISPER | OPTION_BARGE | OPTION_DTMF_SWITCH_MODES)) {
 		ast_audiohook_lock(&csth.whisper_audiohook);
@@ -829,7 +838,7 @@ static int channel_spy(struct ast_channe
 }
 
 static struct ast_autochan *next_channel(struct ast_channel_iterator *iter,
-		struct ast_autochan *autochan, struct ast_channel *chan)
+	struct ast_channel *chan)
 {
 	struct ast_channel *next;
 	struct ast_autochan *autochan_store;
@@ -891,7 +900,7 @@ static int common_exec(struct ast_channe
 	if (ast_channel_state(chan) != AST_STATE_UP)
 		ast_answer(chan);
 
-	ast_set_flag(ast_channel_flags(chan), AST_FLAG_SPYING); /* so nobody can spy on us while we are spying */
+	ast_channel_set_flag(chan, AST_FLAG_SPYING);
 
 	waitms = 100;
 
@@ -904,7 +913,7 @@ static int common_exec(struct ast_channe
 			if (!res)
 				res = ast_waitstream(chan, "");
 			else if (res < 0) {
-				ast_clear_flag(ast_channel_flags(chan), AST_FLAG_SPYING);
+				ast_channel_clear_flag(chan, AST_FLAG_SPYING);
 				break;
 			}
 			if (!ast_strlen_zero(exitcontext)) {
@@ -947,7 +956,7 @@ static int common_exec(struct ast_channe
 		res = ast_waitfordigit(chan, waitms);
 		if (res < 0) {
 			iter = ast_channel_iterator_destroy(iter);
-			ast_clear_flag(ast_channel_flags(chan), AST_FLAG_SPYING);
+			ast_channel_clear_flag(chan, AST_FLAG_SPYING);
 			break;
 		}
 		if (!ast_strlen_zero(exitcontext)) {
@@ -966,11 +975,12 @@ static int common_exec(struct ast_channe
 		waitms = 100;
 		num_spyed_upon = 0;
 
-		for (autochan = next_channel(iter, autochan, chan);
-		     autochan;
-			 prev = autochan->chan, ast_autochan_destroy(autochan),
-		     autochan = next_autochan ? next_autochan : 
-				next_channel(iter, autochan, chan), next_autochan = NULL) {
+		for (autochan = next_channel(iter, chan);
+			autochan;
+			prev = autochan->chan,
+				ast_autochan_destroy(autochan),
+				autochan = next_autochan ?: next_channel(iter, chan),
+				next_autochan = NULL) {
 			int igrp = !mygroup;
 			int ienf = !myenforced;
 
@@ -984,13 +994,19 @@ static int common_exec(struct ast_channe
 				break;
 			}
 
-			if (ast_test_flag(flags, OPTION_BRIDGED) && !ast_channel_is_bridged(autochan->chan)) {
+			ast_autochan_channel_lock(autochan);
+			if (ast_test_flag(flags, OPTION_BRIDGED)
+				&& !ast_channel_is_bridged(autochan->chan)) {
+				ast_autochan_channel_unlock(autochan);
 				continue;
 			}
 
-			if (ast_check_hangup(autochan->chan) || ast_test_flag(ast_channel_flags(autochan->chan), AST_FLAG_SPYING)) {
+			if (ast_check_hangup(autochan->chan)
+				|| ast_test_flag(ast_channel_flags(autochan->chan), AST_FLAG_SPYING)) {
+				ast_autochan_channel_unlock(autochan);
 				continue;
 			}
+			ast_autochan_channel_unlock(autochan);
 
 			if (mygroup) {
 				int num_groups = 0;
@@ -1008,11 +1024,13 @@ static int common_exec(struct ast_channe
 
 				/* Before dahdi scan was part of chanspy, it would use the "GROUP" variable 
 				 * rather than "SPYGROUP", this check is done to preserve expected behavior */
+				ast_autochan_channel_lock(autochan);
 				if (ast_test_flag(flags, OPTION_DAHDI_SCAN)) {
 					group = pbx_builtin_getvar_helper(autochan->chan, "GROUP");
 				} else {
 					group = pbx_builtin_getvar_helper(autochan->chan, "SPYGROUP");
 				}
+				ast_autochan_channel_unlock(autochan);
 
 				if (!ast_strlen_zero(group)) {
 					ast_copy_string(dup_group, group, sizeof(dup_group));
@@ -1040,7 +1058,9 @@ static int common_exec(struct ast_channe
 
 				snprintf(buffer, sizeof(buffer) - 1, ":%s:", myenforced);
 
+				ast_autochan_channel_lock(autochan);
 				ast_copy_string(ext + 1, ast_channel_name(autochan->chan), sizeof(ext) - 1);
+				ast_autochan_channel_unlock(autochan);
 				if ((end = strchr(ext, '-'))) {
 					*end++ = ':';
 					*end = '\0';
@@ -1062,7 +1082,9 @@ static int common_exec(struct ast_channe
 				char *ptr, *s;
 
 				strcpy(peer_name, "spy-");
+				ast_autochan_channel_lock(autochan);
 				strncat(peer_name, ast_channel_name(autochan->chan), AST_NAME_STRLEN - 4 - 1);
+				ast_autochan_channel_unlock(autochan);
 				if ((ptr = strchr(peer_name, '/'))) {
 					*ptr++ = '\0';
 					for (s = peer_name; s < ptr; s++) {
@@ -1127,12 +1149,14 @@ static int common_exec(struct ast_channe
 					next = ast_channel_unref(next);
 				} else {
 					/* stay on this channel, if it is still valid */
+					ast_autochan_channel_lock(autochan);
 					if (!ast_check_hangup(autochan->chan)) {
 						next_autochan = ast_autochan_setup(autochan->chan);
 					} else {
 						/* the channel is gone */
 						next_autochan = NULL;
 					}
+					ast_autochan_channel_unlock(autochan);
 				}
 			} else if (res == 0 && ast_test_flag(flags, OPTION_EXITONHANGUP)) {
 				ast_autochan_destroy(autochan);
@@ -1151,7 +1175,7 @@ static int common_exec(struct ast_channe
 	}
 exit:
 
-	ast_clear_flag(ast_channel_flags(chan), AST_FLAG_SPYING);
+	ast_channel_clear_flag(chan, AST_FLAG_SPYING);
 
 	ast_channel_setoption(chan, AST_OPTION_TXGAIN, &zero_volume, sizeof(zero_volume), 0);
 
diff -urpN asterisk-13.9.1/apps/app_confbridge.c asterisk-13.17.0/apps/app_confbridge.c
--- asterisk-13.9.1/apps/app_confbridge.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_confbridge.c	2017-07-12 13:12:08.000000000 +0200
@@ -71,6 +71,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/stasis_bridges.h"
 #include "asterisk/json.h"
 #include "asterisk/format_cache.h"
+#include "asterisk/taskprocessor.h"
 
 /*** DOCUMENTATION
 	<application name="ConfBridge" language="en_US">
@@ -959,6 +960,59 @@ static void handle_video_on_exit(struct
 	ao2_unlock(conference);
 }
 
+struct hangup_data
+{
+	struct confbridge_conference *conference;
+	ast_mutex_t lock;
+	ast_cond_t cond;
+	int hungup;
+};
+
+/*!
+ * \brief Hang up the announcer channel
+ *
+ * This hangs up the announcer channel in the conference. This
+ * runs in the playback queue taskprocessor since we do not want
+ * to hang up the channel while it's trying to play an announcement.
+ *
+ * This task is performed synchronously, so there is no need to
+ * perform any cleanup on the passed-in data.
+ *
+ * \param data A hangup_data structure
+ * \return 0
+ */
+static int hangup_playback(void *data)
+{
+	struct hangup_data *hangup = data;
+
+	ast_autoservice_stop(hangup->conference->playback_chan);
+
+	ast_hangup(hangup->conference->playback_chan);
+	hangup->conference->playback_chan = NULL;
+
+	ast_mutex_lock(&hangup->lock);
+	hangup->hungup = 1;
+	ast_cond_signal(&hangup->cond);
+	ast_mutex_unlock(&hangup->lock);
+
+	return 0;
+}
+
+static void hangup_data_init(struct hangup_data *hangup, struct confbridge_conference *conference)
+{
+	ast_mutex_init(&hangup->lock);
+	ast_cond_init(&hangup->cond, NULL);
+
+	hangup->conference = conference;
+	hangup->hungup = 0;
+}
+
+static void hangup_data_destroy(struct hangup_data *hangup)
+{
+	ast_mutex_destroy(&hangup->lock);
+	ast_cond_destroy(&hangup->cond);
+}
+
 /*!
  * \brief Destroy a conference bridge
  *
@@ -973,9 +1027,22 @@ static void destroy_conference_bridge(vo
 	ast_debug(1, "Destroying conference bridge '%s'\n", conference->name);
 
 	if (conference->playback_chan) {
-		conf_announce_channel_depart(conference->playback_chan);
-		ast_hangup(conference->playback_chan);
-		conference->playback_chan = NULL;
+		if (conference->playback_queue) {
+			struct hangup_data hangup;
+			hangup_data_init(&hangup, conference);
+			ast_taskprocessor_push(conference->playback_queue, hangup_playback, &hangup);
+
+			ast_mutex_lock(&hangup.lock);
+			while (!hangup.hungup) {
+				ast_cond_wait(&hangup.cond, &hangup.lock);
+			}
+			ast_mutex_unlock(&hangup.lock);
+			hangup_data_destroy(&hangup);
+		} else {
+			/* Playback queue is not yet allocated. Just hang up the channel straight */
+			ast_hangup(conference->playback_chan);
+			conference->playback_chan = NULL;
+		}
 	}
 
 	/* Destroying a conference bridge is simple, all we have to do is destroy the bridging object */
@@ -989,7 +1056,7 @@ static void destroy_conference_bridge(vo
 	ast_free(conference->record_filename);
 
 	conf_bridge_profile_destroy(&conference->b_profile);
-	ast_mutex_destroy(&conference->playback_lock);
+	ast_taskprocessor_unreference(conference->playback_queue);
 }
 
 /*! \brief Call the proper join event handler for the user for the conference bridge's current state
@@ -1253,15 +1320,89 @@ void conf_handle_second_active(struct co
 
 void conf_ended(struct confbridge_conference *conference)
 {
+	struct pbx_find_info q = { .stacklen = 0 };
+
 	/* Called with a reference to conference */
 	ao2_unlink(conference_bridges, conference);
 	send_conf_end_event(conference);
+	if (!ast_strlen_zero(conference->b_profile.regcontext) &&
+			pbx_find_extension(NULL, NULL, &q, conference->b_profile.regcontext,
+				conference->name, 1, NULL, "", E_MATCH)) {
+		ast_context_remove_extension(conference->b_profile.regcontext,
+				conference->name, 1, NULL);
+	}
 	ao2_lock(conference);
 	conf_stop_record(conference);
 	ao2_unlock(conference);
 }
 
 /*!
+ * \internal
+ * \brief Allocate playback channel for a conference.
+ * \pre expects conference to be locked before calling this function
+ */
+static int alloc_playback_chan(struct confbridge_conference *conference)
+{
+	struct ast_format_cap *cap;
+	char taskprocessor_name[AST_TASKPROCESSOR_MAX_NAME + 1];
+
+	cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!cap) {
+		return -1;
+	}
+	ast_format_cap_append(cap, ast_format_slin, 0);
+	conference->playback_chan = ast_request("CBAnn", cap, NULL, NULL,
+		conference->name, NULL);
+	ao2_ref(cap, -1);
+	if (!conference->playback_chan) {
+		return -1;
+	}
+
+	/* To make sure playback_chan has the same language as the bridge */
+	ast_channel_lock(conference->playback_chan);
+	ast_channel_language_set(conference->playback_chan, conference->b_profile.language);
+	ast_channel_unlock(conference->playback_chan);
+
+	ast_debug(1, "Created announcer channel '%s' to conference bridge '%s'\n",
+		ast_channel_name(conference->playback_chan), conference->name);
+
+	ast_taskprocessor_build_name(taskprocessor_name, sizeof(taskprocessor_name),
+		"Confbridge/%s", conference->name);
+	conference->playback_queue = ast_taskprocessor_get(taskprocessor_name, TPS_REF_DEFAULT);
+	if (!conference->playback_queue) {
+		ast_hangup(conference->playback_chan);
+		conference->playback_chan = NULL;
+		return -1;
+	}
+	return 0;
+}
+
+/*!
+ * \brief Push the announcer channel into the bridge
+ *
+ * This runs in the playback queue taskprocessor.
+ *
+ * \param data A confbridge_conference
+ * \retval 0 Success
+ * \retval -1 Failed to push the channel to the bridge
+ */
+static int push_announcer(void *data)
+{
+	struct confbridge_conference *conference = data;
+
+	if (conf_announce_channel_push(conference->playback_chan)) {
+		ast_hangup(conference->playback_chan);
+		conference->playback_chan = NULL;
+		ao2_cleanup(conference);
+		return -1;
+	}
+
+	ast_autoservice_start(conference->playback_chan);
+	ao2_cleanup(conference);
+	return 0;
+}
+
+/*!
  * \brief Join a conference bridge
  *
  * \param conference_name The conference name
@@ -1306,9 +1447,6 @@ static struct confbridge_conference *joi
 			return NULL;
 		}
 
-		/* Setup lock for playback channel */
-		ast_mutex_init(&conference->playback_lock);
-
 		/* Setup for the record channel */
 		conference->record_filename = ast_str_create(RECORD_FILENAME_INITIAL_SPACE);
 		if (!conference->record_filename) {
@@ -1353,6 +1491,22 @@ static struct confbridge_conference *joi
 		/* Set the initial state to EMPTY */
 		conference->state = CONF_STATE_EMPTY;
 
+		if (alloc_playback_chan(conference)) {
+			ao2_unlink(conference_bridges, conference);
+			ao2_ref(conference, -1);
+			ao2_unlock(conference_bridges);
+			ast_log(LOG_ERROR, "Could not allocate announcer channel for conference '%s'\n", conference_name);
+			return NULL;
+		}
+
+		if (ast_taskprocessor_push(conference->playback_queue, push_announcer, ao2_bump(conference))) {
+			ao2_unlink(conference_bridges, conference);
+			ao2_ref(conference, -1);
+			ao2_unlock(conference_bridges);
+			ast_log(LOG_ERROR, "Could not add announcer channel for conference '%s' bridge\n", conference_name);
+			return NULL;
+		}
+
 		if (ast_test_flag(&conference->b_profile, BRIDGE_OPT_RECORD_CONFERENCE)) {
 			ao2_lock(conference);
 			conf_start_record(conference);
@@ -1360,6 +1514,13 @@ static struct confbridge_conference *joi
 		}
 
 		send_conf_start_event(conference);
+
+		if (!ast_strlen_zero(conference->b_profile.regcontext)) {
+			if (!ast_exists_extension(NULL, conference->b_profile.regcontext, conference->name, 1, NULL)) {
+				ast_add_extension(conference->b_profile.regcontext, 1, conference->name, 1, NULL, NULL, "Noop", NULL, NULL, "ConfBridge");
+			}
+		}
+
 		ast_debug(1, "Created conference '%s' and linked to container.\n", conference_name);
 	}
 
@@ -1466,74 +1627,389 @@ static void leave_conference(struct conf
 	user->conference = NULL;
 }
 
+static void playback_common(struct confbridge_conference *conference, const char *filename, int say_number)
+{
+	/* Don't try to play if the playback channel has been hung up */
+	if (!conference->playback_chan) {
+		return;
+	}
+
+	ast_autoservice_stop(conference->playback_chan);
+
+	/* The channel is all under our control, in goes the prompt */
+	if (!ast_strlen_zero(filename)) {
+		ast_stream_and_wait(conference->playback_chan, filename, "");
+	} else if (say_number >= 0) {
+		ast_say_number(conference->playback_chan, say_number, "",
+			ast_channel_language(conference->playback_chan), NULL);
+	}
+
+	ast_autoservice_start(conference->playback_chan);
+}
+
+struct playback_task_data {
+	struct confbridge_conference *conference;
+	const char *filename;
+	int say_number;
+	int playback_finished;
+	ast_mutex_t lock;
+	ast_cond_t cond;
+};
+
 /*!
- * \internal
- * \brief Allocate playback channel for a conference.
- * \pre expects conference to be locked before calling this function
+ * \brief Play an announcement into a confbridge
+ *
+ * This runs in the playback queue taskprocessor. This ensures that
+ * all playbacks are handled in sequence and do not play over top one
+ * another.
+ *
+ * This task runs synchronously so there is no need for performing any
+ * sort of cleanup on the input parameter.
+ *
+ * \param data A playback_task_data
+ * \return 0
  */
-static int alloc_playback_chan(struct confbridge_conference *conference)
+static int playback_task(void *data)
 {
-	struct ast_format_cap *cap;
+	struct playback_task_data *ptd = data;
 
-	cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
-	if (!cap) {
-		return -1;
+	playback_common(ptd->conference, ptd->filename, ptd->say_number);
+
+	ast_mutex_lock(&ptd->lock);
+	ptd->playback_finished = 1;
+	ast_cond_signal(&ptd->cond);
+	ast_mutex_unlock(&ptd->lock);
+
+	return 0;
+}
+
+static void playback_task_data_init(struct playback_task_data *ptd, struct confbridge_conference *conference,
+		const char *filename, int say_number)
+{
+	ast_mutex_init(&ptd->lock);
+	ast_cond_init(&ptd->cond, NULL);
+
+	ptd->filename = filename;
+	ptd->say_number = say_number;
+	ptd->conference = conference;
+	ptd->playback_finished = 0;
+}
+
+static void playback_task_data_destroy(struct playback_task_data *ptd)
+{
+	ast_mutex_destroy(&ptd->lock);
+	ast_cond_destroy(&ptd->cond);
+}
+
+static int play_sound_helper(struct confbridge_conference *conference, const char *filename, int say_number)
+{
+	struct playback_task_data ptd;
+
+	/* Do not waste resources trying to play files that do not exist */
+	if (ast_strlen_zero(filename)) {
+		if (say_number < 0) {
+			return 0;
+		}
+	} else if (!sound_file_exists(filename)) {
+		return 0;
 	}
-	ast_format_cap_append(cap, ast_format_slin, 0);
-	conference->playback_chan = ast_request("CBAnn", cap, NULL, NULL,
-		conference->name, NULL);
-	ao2_ref(cap, -1);
-	if (!conference->playback_chan) {
+
+	playback_task_data_init(&ptd, conference, filename, say_number);
+	if (ast_taskprocessor_push(conference->playback_queue, playback_task, &ptd)) {
+		if (!ast_strlen_zero(filename)) {
+			ast_log(LOG_WARNING, "Unable to play file '%s' to conference %s\n",
+				filename, conference->name);
+		} else {
+			ast_log(LOG_WARNING, "Unable to say number '%d' to conference %s\n",
+				say_number, conference->name);
+		}
+		playback_task_data_destroy(&ptd);
 		return -1;
 	}
 
-	/* To make sure playback_chan has the same language of that profile */
-	ast_channel_lock(conference->playback_chan);
-	ast_channel_language_set(conference->playback_chan, conference->b_profile.language);
-	ast_channel_unlock(conference->playback_chan);
+	/* Wait for the playback to complete */
+	ast_mutex_lock(&ptd.lock);
+	while (!ptd.playback_finished) {
+		ast_cond_wait(&ptd.cond, &ptd.lock);
+	}
+	ast_mutex_unlock(&ptd.lock);
+
+	playback_task_data_destroy(&ptd);
 
-	ast_debug(1, "Created announcer channel '%s' to conference bridge '%s'\n",
-		ast_channel_name(conference->playback_chan), conference->name);
 	return 0;
 }
 
-static int play_sound_helper(struct confbridge_conference *conference, const char *filename, int say_number)
+int play_sound_file(struct confbridge_conference *conference, const char *filename)
 {
-	/* Do not waste resources trying to play files that do not exist */
-	if (!ast_strlen_zero(filename) && !sound_file_exists(filename)) {
+	return play_sound_helper(conference, filename, -1);
+}
+
+struct async_playback_task_data {
+	struct confbridge_conference *conference;
+	int say_number;
+	struct ast_channel *initiator;
+	char filename[0];
+};
+
+struct async_datastore_data {
+	ast_mutex_t lock;
+	ast_cond_t cond;
+	int wait;
+};
+
+static void async_datastore_data_destroy(void *data)
+{
+	struct async_datastore_data *add = data;
+
+	ast_mutex_destroy(&add->lock);
+	ast_cond_destroy(&add->cond);
+
+	ast_free(add);
+}
+
+/*!
+ * \brief Datastore used for timing of async announcement playback
+ *
+ * Announcements that are played to the entire conference can be played
+ * asynchronously (i.e. The channel that queues the playback does not wait
+ * for the playback to complete before continuing)
+ *
+ * The thing about async announcements is that the channel that queues the
+ * announcement is either not in the bridge or is in some other way "occupied"
+ * at the time the announcement is queued. Because of that, the initiator of
+ * the announcement may enter after the announcement has already started,
+ * resulting in the sound being "clipped".
+ *
+ * This datastore makes it so that the channel that queues the async announcement
+ * can say "I'm ready now". This way the announcement does not start until the
+ * initiator of the announcement is ready to hear the sound.
+ */
+static struct ast_datastore_info async_datastore_info = {
+	.type = "Confbridge async playback",
+	.destroy = async_datastore_data_destroy,
+};
+
+static struct async_datastore_data *async_datastore_data_alloc(void)
+{
+	struct async_datastore_data *add;
+
+	add = ast_malloc(sizeof(*add));
+	if (!add) {
+		return NULL;
+	}
+
+	ast_mutex_init(&add->lock);
+	ast_cond_init(&add->cond, NULL);
+	add->wait = 1;
+
+	return add;
+}
+
+/*!
+ * \brief Prepare the async playback datastore
+ *
+ * This is done prior to queuing an async announcement. If the
+ * datastore has not yet been created, it is allocated and initialized.
+ * If it already exists, we set it to be in "waiting" mode.
+ *
+ * \param initiator The channel that is queuing the async playback
+ * \retval 0 Success
+ * \retval -1 Failure :(
+ */
+static int setup_async_playback_datastore(struct ast_channel *initiator)
+{
+	struct ast_datastore *async_datastore;
+
+	async_datastore = ast_channel_datastore_find(initiator, &async_datastore_info, NULL);
+	if (async_datastore) {
+		struct async_datastore_data *add;
+
+		add = async_datastore->data;
+		add->wait = 1;
+
 		return 0;
 	}
 
-	ast_mutex_lock(&conference->playback_lock);
-	if (!conference->playback_chan && alloc_playback_chan(conference)) {
-		ast_mutex_unlock(&conference->playback_lock);
+	async_datastore = ast_datastore_alloc(&async_datastore_info, NULL);
+	if (!async_datastore) {
 		return -1;
 	}
-	if (conf_announce_channel_push(conference->playback_chan)) {
-		ast_mutex_unlock(&conference->playback_lock);
+
+	async_datastore->data = async_datastore_data_alloc();
+	if (!async_datastore->data) {
+		ast_datastore_free(async_datastore);
 		return -1;
 	}
 
-	/* The channel is all under our control, in goes the prompt */
-	if (!ast_strlen_zero(filename)) {
-		ast_stream_and_wait(conference->playback_chan, filename, "");
-	} else if (say_number >= 0) {
-		ast_say_number(conference->playback_chan, say_number, "",
-			ast_channel_language(conference->playback_chan), NULL);
+	ast_channel_datastore_add(initiator, async_datastore);
+	return 0;
+}
+
+static struct async_playback_task_data *async_playback_task_data_alloc(
+	struct confbridge_conference *conference, const char *filename, int say_number,
+	struct ast_channel *initiator)
+{
+	struct async_playback_task_data *aptd;
+
+	aptd = ast_malloc(sizeof(*aptd) + strlen(filename) + 1);
+	if (!aptd) {
+		return NULL;
 	}
 
-	ast_debug(1, "Departing announcer channel '%s' from conference bridge '%s'\n",
-		ast_channel_name(conference->playback_chan), conference->name);
-	conf_announce_channel_depart(conference->playback_chan);
+	/* Safe */
+	strcpy(aptd->filename, filename);
+	aptd->say_number = say_number;
+
+	/* You may think that we need to bump the conference refcount since we are pushing
+	 * this task to the taskprocessor.
+	 *
+	 * In this case, that actually causes a problem. The destructor for the conference
+	 * pushes a hangup task into the taskprocessor and waits for it to complete before
+	 * continuing. If the destructor gets called from a taskprocessor task, we're
+	 * deadlocked.
+	 *
+	 * So is there a risk of the conference being freed out from under us? No. Since
+	 * the destructor pushes a task into the taskprocessor and waits for it to complete,
+	 * the destructor cannot free the conference out from under us. No further tasks
+	 * can be queued onto the taskprocessor after the hangup since no channels are referencing
+	 * the conference at that point any more.
+	 */
+	aptd->conference = conference;
 
-	ast_mutex_unlock(&conference->playback_lock);
+	aptd->initiator = initiator;
+	if (initiator) {
+		ast_channel_ref(initiator);
+		ast_channel_lock(aptd->initiator);
+		/* We don't really care if this fails. If the datastore fails to get set up
+		 * we'll still play the announcement. It's possible that the sound will be
+		 * clipped for the initiator, but that's not the end of the world.
+		 */
+		setup_async_playback_datastore(aptd->initiator);
+		ast_channel_unlock(aptd->initiator);
+	}
+
+	return aptd;
+}
+
+static void async_playback_task_data_destroy(struct async_playback_task_data *aptd)
+{
+	ast_channel_cleanup(aptd->initiator);
+	ast_free(aptd);
+}
+
+/*!
+ * \brief Wait for the initiator of an async playback to be ready
+ *
+ * See the description on the async_datastore_info structure for more
+ * information about what this is about.
+ *
+ * \param initiator The channel that queued the async announcement
+ */
+static void wait_for_initiator(struct ast_channel *initiator)
+{
+	struct ast_datastore *async_datastore;
+	struct async_datastore_data *add;
+
+	ast_channel_lock(initiator);
+	async_datastore = ast_channel_datastore_find(initiator, &async_datastore_info, NULL);
+	ast_channel_unlock(initiator);
+
+	if (!async_datastore) {
+		return;
+	}
+
+	add = async_datastore->data;
+
+	ast_mutex_lock(&add->lock);
+	while (add->wait) {
+		ast_cond_wait(&add->cond, &add->lock);
+	}
+	ast_mutex_unlock(&add->lock);
+}
 
+/*!
+ * \brief Play an announcement into a confbridge asynchronously
+ *
+ * This runs in the playback queue taskprocessor. This ensures that
+ * all playbacks are handled in sequence and do not play over top one
+ * another.
+ *
+ * \param data An async_playback_task_data
+ * \return 0
+ */
+static int async_playback_task(void *data)
+{
+	struct async_playback_task_data *aptd = data;
+
+	/* Wait for the initiator to get back in the bridge or be hung up */
+	if (aptd->initiator) {
+		wait_for_initiator(aptd->initiator);
+	}
+
+	playback_common(aptd->conference, aptd->filename, aptd->say_number);
+
+	async_playback_task_data_destroy(aptd);
 	return 0;
 }
 
-int play_sound_file(struct confbridge_conference *conference, const char *filename)
+static int async_play_sound_helper(struct confbridge_conference *conference,
+	const char *filename, int say_number, struct ast_channel *initiator)
 {
-	return play_sound_helper(conference, filename, -1);
+	struct async_playback_task_data *aptd;
+
+	/* Do not waste resources trying to play files that do not exist */
+	if (ast_strlen_zero(filename)) {
+		if (say_number < 0) {
+			return 0;
+		}
+	} else if (!sound_file_exists(filename)) {
+		return 0;
+	}
+
+	aptd = async_playback_task_data_alloc(conference, filename, say_number, initiator);
+	if (!aptd) {
+		return -1;
+	}
+
+	if (ast_taskprocessor_push(conference->playback_queue, async_playback_task, aptd)) {
+		if (!ast_strlen_zero(filename)) {
+			ast_log(LOG_WARNING, "Unable to play file '%s' to conference '%s'\n",
+				filename, conference->name);
+		} else {
+			ast_log(LOG_WARNING, "Unable to say number '%d' to conference '%s'\n",
+				say_number, conference->name);
+		}
+		async_playback_task_data_destroy(aptd);
+		return -1;
+	}
+
+	return 0;
+}
+
+int async_play_sound_file(struct confbridge_conference *conference,
+	const char *filename, struct ast_channel *initiator)
+{
+	return async_play_sound_helper(conference, filename, -1, initiator);
+}
+
+void async_play_sound_ready(struct ast_channel *chan)
+{
+	struct ast_datastore *async_datastore;
+	struct async_datastore_data *add;
+
+	ast_channel_lock(chan);
+	async_datastore = ast_channel_datastore_find(chan, &async_datastore_info, NULL);
+	ast_channel_unlock(chan);
+	if (!async_datastore) {
+		return;
+	}
+
+	add = async_datastore->data;
+
+	ast_mutex_lock(&add->lock);
+	add->wait = 0;
+	ast_cond_signal(&add->cond);
+	ast_mutex_unlock(&add->lock);
 }
 
 /*!
@@ -1667,6 +2143,86 @@ static int conf_rec_name(struct confbrid
 	return 0;
 }
 
+struct async_delete_name_rec_task_data {
+	struct confbridge_conference *conference;
+	char filename[0];
+};
+
+static struct async_delete_name_rec_task_data *async_delete_name_rec_task_data_alloc(
+	struct confbridge_conference *conference, const char *filename)
+{
+	struct async_delete_name_rec_task_data *atd;
+
+	atd = ast_malloc(sizeof(*atd) + strlen(filename) + 1);
+	if (!atd) {
+		return NULL;
+	}
+
+	/* Safe */
+	strcpy(atd->filename, filename);
+	atd->conference = conference;
+
+	return atd;
+}
+
+static void async_delete_name_rec_task_data_destroy(struct async_delete_name_rec_task_data *atd)
+{
+	ast_free(atd);
+}
+
+/*!
+ * \brief Delete user's name file asynchronously
+ *
+ * This runs in the playback queue taskprocessor. This ensures that
+ * sound file is removed after playback is finished and not before.
+ *
+ * \param data An async_delete_name_rec_task_data
+ * \return 0
+ */
+static int async_delete_name_rec_task(void *data)
+{
+	struct async_delete_name_rec_task_data *atd = data;
+
+	ast_filedelete(atd->filename, NULL);
+	ast_log(LOG_DEBUG, "Conference '%s' removed user name file '%s'\n",
+		atd->conference->name, atd->filename);
+
+	async_delete_name_rec_task_data_destroy(atd);
+	return 0;
+}
+
+static int async_delete_name_rec(struct confbridge_conference *conference,
+	const char *filename)
+{
+	struct async_delete_name_rec_task_data *atd;
+
+	if (ast_strlen_zero(filename)) {
+		return 0;
+	} else if (!sound_file_exists(filename)) {
+		return 0;
+	}
+
+	atd = async_delete_name_rec_task_data_alloc(conference, filename);
+	if (!atd) {
+		return -1;
+	}
+
+	if (ast_taskprocessor_push(conference->playback_queue, async_delete_name_rec_task, atd)) {
+		ast_log(LOG_WARNING, "Conference '%s' was unable to remove user name file '%s'\n",
+			conference->name, filename);
+		async_delete_name_rec_task_data_destroy(atd);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int join_callback(struct ast_bridge_channel *bridge_channel, void *ignore)
+{
+	async_play_sound_ready(bridge_channel->chan);
+	return 0;
+}
+
 /*! \brief The ConfBridge application */
 static int confbridge_exec(struct ast_channel *chan, const char *data)
 {
@@ -1845,10 +2401,14 @@ static int confbridge_exec(struct ast_ch
 	if (!quiet) {
 		const char *join_sound = conf_get_sound(CONF_SOUND_JOIN, conference->b_profile.sounds);
 
-		ast_stream_and_wait(chan, join_sound, "");
-		ast_autoservice_start(chan);
-		play_sound_file(conference, join_sound);
-		ast_autoservice_stop(chan);
+		if (strcmp(conference->b_profile.language, ast_channel_language(chan))) {
+			ast_stream_and_wait(chan, join_sound, "");
+			ast_autoservice_start(chan);
+			play_sound_file(conference, join_sound);
+			ast_autoservice_stop(chan);
+		} else {
+			async_play_sound_file(conference, join_sound, chan);
+		}
 	}
 
 	if (user.u_profile.timeout) {
@@ -1868,6 +2428,11 @@ static int confbridge_exec(struct ast_ch
 
 	/* Join our conference bridge for real */
 	send_join_event(&user, conference);
+
+	if (ast_bridge_join_hook(&user.features, join_callback, NULL, NULL, 0)) {
+		async_play_sound_ready(user.chan);
+	}
+
 	ast_bridge_join(conference->bridge,
 		chan,
 		NULL,
@@ -1875,6 +2440,11 @@ static int confbridge_exec(struct ast_ch
 		&user.tech_args,
 		0);
 
+	/* This is a catch-all in case joining the bridge failed or for some reason
+	 * an async announcement got queued up and hasn't been told to play yet
+	 */
+	async_play_sound_ready(chan);
+
 	if (!user.kicked && ast_check_hangup(chan)) {
 		pbx_builtin_setvar_helper(chan, "CONFBRIDGE_RESULT", "HANGUP");
 	}
@@ -1899,19 +2469,16 @@ static int confbridge_exec(struct ast_ch
 
 	/* if this user has a intro, play it when leaving */
 	if (!quiet && !ast_strlen_zero(user.name_rec_location)) {
-		ast_autoservice_start(chan);
-		play_sound_file(conference, user.name_rec_location);
-		play_sound_file(conference,
-			conf_get_sound(CONF_SOUND_HAS_LEFT, conference->b_profile.sounds));
-		ast_autoservice_stop(chan);
+		async_play_sound_file(conference, user.name_rec_location, NULL);
+		async_play_sound_file(conference,
+			conf_get_sound(CONF_SOUND_HAS_LEFT, conference->b_profile.sounds), NULL);
+		async_delete_name_rec(conference, user.name_rec_location);
 	}
 
 	/* play the leave sound */
 	if (!quiet) {
 		const char *leave_sound = conf_get_sound(CONF_SOUND_LEAVE, conference->b_profile.sounds);
-		ast_autoservice_start(chan);
-		play_sound_file(conference, leave_sound);
-		ast_autoservice_stop(chan);
+		async_play_sound_file(conference, leave_sound, NULL);
 	}
 
 	/* If the user was kicked from the conference play back the audio prompt for it */
@@ -1933,10 +2500,6 @@ static int confbridge_exec(struct ast_ch
 		ast_audiohook_volume_set(chan, AST_AUDIOHOOK_DIRECTION_WRITE, volume_adjustments[1]);
 	}
 
-	if (!ast_strlen_zero(user.name_rec_location)) {
-		ast_filedelete(user.name_rec_location, NULL);
-	}
-
 confbridge_cleanup:
 	ast_bridge_features_cleanup(&user.features);
 	conf_bridge_profile_destroy(&user.b_profile);
@@ -1984,13 +2547,18 @@ static int action_toggle_mute_participan
 		mute ? CONF_SOUND_PARTICIPANTS_MUTED : CONF_SOUND_PARTICIPANTS_UNMUTED,
 		conference->b_profile.sounds);
 
-	/* The host needs to hear it seperately, as they don't get the audio from play_sound_helper */
-	ast_stream_and_wait(user->chan, sound_to_play, "");
+	if (strcmp(conference->b_profile.language, ast_channel_language(user->chan))) {
+		/* The host needs to hear it seperately, as they don't get the audio from play_sound_helper */
+		ast_stream_and_wait(user->chan, sound_to_play, "");
 
-	/* Announce to the group that all participants are muted */
-	ast_autoservice_start(user->chan);
-	play_sound_helper(conference, sound_to_play, 0);
-	ast_autoservice_stop(user->chan);
+		/* Announce to the group that all participants are muted */
+		ast_autoservice_start(user->chan);
+		play_sound_file(conference, sound_to_play);
+		ast_autoservice_stop(user->chan);
+	} else {
+		/* Playing the sound asynchronously lets the sound be heard by everyone at once */
+		async_play_sound_file(conference, sound_to_play, user->chan);
+	}
 
 	return 0;
 }
@@ -2275,6 +2843,8 @@ int conf_handle_dtmf(struct ast_bridge_c
 	/* See if music on hold needs to be started back up again */
 	conf_moh_unsuspend(user);
 
+	async_play_sound_ready(bridge_channel->chan);
+
 	return 0;
 }
 
@@ -3433,7 +4003,7 @@ static int load_module(void)
 	if (register_channel_tech(conf_record_get_tech())
 		|| register_channel_tech(conf_announce_get_tech())) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Create a container to hold the conference bridges */
@@ -3441,7 +4011,7 @@ static int load_module(void)
 		conference_bridge_hash_cb, conference_bridge_cmp_cb);
 	if (!conference_bridges) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Setup manager stasis subscriptions */
@@ -3466,7 +4036,7 @@ static int load_module(void)
 	res |= ast_manager_register_xml("ConfbridgeSetSingleVideoSrc", EVENT_FLAG_CALL, action_confbridgesetsinglevideosrc);
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/apps/app_dahdiras.c asterisk-13.17.0/apps/app_dahdiras.c
--- asterisk-13.9.1/apps/app_dahdiras.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_dahdiras.c	2017-07-12 13:12:08.000000000 +0200
@@ -230,7 +230,7 @@ static int unload_module(void)
 
 static int load_module(void)
 {
-	return ((ast_register_application_xml(app, dahdiras_exec)) ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS);
+	return ((ast_register_application_xml(app, dahdiras_exec)) ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS);
 }
 
 AST_MODULE_INFO_STANDARD_EXTENDED(ASTERISK_GPL_KEY, "DAHDI ISDN Remote Access Server");
diff -urpN asterisk-13.9.1/apps/app_dial.c asterisk-13.17.0/apps/app_dial.c
--- asterisk-13.9.1/apps/app_dial.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_dial.c	2017-07-12 13:12:08.000000000 +0200
@@ -103,15 +103,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<option name="a">
 					<para>Immediately answer the calling channel when the called channel answers in
 					all cases. Normally, the calling channel is answered when the called channel
-					answers, but when options such as A() and M() are used, the calling channel is
+					answers, but when options such as <literal>A()</literal> and
+					<literal>M()</literal> are used, the calling channel is
 					not answered until all actions on the called channel (such as playing an
 					announcement) are completed.  This option can be used to answer the calling
 					channel before doing anything on the called channel. You will rarely need to use
 					this option, the default behavior is adequate in most cases.</para>
 				</option>
 				<option name="b" argsep="^">
-					<para>Before initiating an outgoing call, Gosub to the specified
-					location using the newly created channel.  The Gosub will be
+					<para>Before initiating an outgoing call, <literal>Gosub</literal> to the specified
+					location using the newly created channel.  The <literal>Gosub</literal> will be
 					executed for each destination channel.</para>
 					<argument name="context" required="false" />
 					<argument name="exten" required="false" />
@@ -121,8 +122,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					</argument>
 				</option>
 				<option name="B" argsep="^">
-					<para>Before initiating the outgoing call(s), Gosub to the specified
-					location using the current channel.</para>
+					<para>Before initiating the outgoing call(s), <literal>Gosub</literal> to the
+					specified location using the current channel.</para>
 					<argument name="context" required="false" />
 					<argument name="exten" required="false" />
 					<argument name="priority" required="true" hasparams="optional" argsep="^">
@@ -134,7 +135,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>Reset the call detail record (CDR) for this call.</para>
 				</option>
 				<option name="c">
-					<para>If the Dial() application cancels this call, always set HANGUPCAUSE to 'answered elsewhere'</para>
+					<para>If the Dial() application cancels this call, always set
+					<variable>HANGUPCAUSE</variable> to 'answered elsewhere'</para>
 				</option>
 				<option name="d">
 					<para>Allow the calling user to dial a 1 digit extension while waiting for
@@ -156,8 +158,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<replaceable>called</replaceable> DTMF string is sent to the called party, and the
 					<replaceable>calling</replaceable> DTMF string is sent to the calling party.  Both arguments
 					can be used alone.  If <replaceable>progress</replaceable> is specified, its DTMF is sent
-					to the called party immediately after receiving a PROGRESS message.</para>
-					<para>See SendDTMF for valid digits.</para>
+					to the called party immediately after receiving a <literal>PROGRESS</literal> message.</para>
+					<para>See <literal>SendDTMF</literal> for valid digits.</para>
 				</option>
 				<option name="e">
 					<para>Execute the <literal>h</literal> extension for peer after the call ends</para>
@@ -165,7 +167,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<option name="f">
 					<argument name="x" required="false" />
 					<para>If <replaceable>x</replaceable> is not provided, force the CallerID sent on a call-forward or
-					deflection to the dialplan extension of this Dial() using a dialplan <literal>hint</literal>.
+					deflection to the dialplan extension of this <literal>Dial()</literal> using a dialplan <literal>hint</literal>.
 					For example, some PSTNs do not allow CallerID to be set to anything
 					other than the numbers assigned to you.
 					If <replaceable>x</replaceable> is provided, force the CallerID sent to <replaceable>x</replaceable>.</para>
@@ -318,11 +320,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<note>
 						<para>You cannot use any additional action post answer options in conjunction
 						with this option. Also, pbx services are run on the peer (called) channel,
-						so you will not be able to set timeouts via the TIMEOUT() function in this macro.</para>
+						so you will not be able to set timeouts via the <literal>TIMEOUT()</literal> function in this macro.</para>
 					</note>
 					<warning><para>Be aware of the limitations that macros have, specifically with regards to use of
 					the <literal>WaitExten</literal> application. For more information, see the documentation for
-					Macro()</para></warning>
+					<literal>Macro()</literal>.</para></warning>
 				</option>
 				<option name="n">
 					<argument name="delete">
@@ -339,7 +341,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</option>
 				<option name="N">
 					<para>This option is a modifier for the call screening/privacy mode. It specifies
-					that if Caller*ID is present, do not screen the call.</para>
+					that if CallerID is present, do not screen the call.</para>
 				</option>
 				<option name="o">
 					<argument name="x" required="false" />
@@ -347,7 +349,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<emphasis>calling</emphasis> channel be stored as the CallerID on the <emphasis>called</emphasis> channel.
 					This was the behavior of Asterisk 1.0 and earlier.
 					If <replaceable>x</replaceable> is provided, specify the CallerID stored on the <emphasis>called</emphasis> channel.
-					Note that o(${CALLERID(all)}) is similar to option o without the parameter.</para>
+					Note that <literal>o(${CALLERID(all)})</literal> is similar to option <literal>o</literal> without the parameter.</para>
 				</option>
 				<option name="O">
 					<argument name="mode">
@@ -373,17 +375,36 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>Enable privacy mode. Use <replaceable>x</replaceable> as the family/key in the AstDB database if
 					it is provided. The current extension is used if a database family/key is not specified.</para>
 				</option>
+				<option name="Q">
+					<argument name="cause" required="true"/>
+					<para>Specify the Q.850/Q.931 <replaceable>cause</replaceable> to send on
+					unanswered channels when another channel answers the call.
+					As with <literal>Hangup()</literal>, <replaceable>cause</replaceable>
+					can be a numeric cause code or a name such as
+						<literal>NO_ANSWER</literal>,
+						<literal>USER_BUSY</literal>,
+						<literal>CALL_REJECTED</literal> or
+						<literal>ANSWERED_ELSEWHERE</literal> (the default if Q isn't specified).
+						You can also specify <literal>0</literal> or <literal>NONE</literal>
+						to send no cause.  See the <filename>causes.h</filename> file for the
+						full list of valid causes and names.
+						</para>
+					<note>
+						<para>chan_sip does not support setting the cause on a CANCEL to anything
+						other than ANSWERED_ELSEWHERE.</para>
+					</note>
+				</option>
 				<option name="r">
 					<para>Default: Indicate ringing to the calling party, even if the called party isn't actually ringing. Pass no audio to the calling
 					party until the called channel has answered.</para>
 					<argument name="tone" required="false">
-						<para>Indicate progress to calling party. Send audio 'tone' from the indications.conf tonezone currently in use.</para>
+						<para>Indicate progress to calling party. Send audio 'tone' from the <filename>indications.conf</filename> tonezone currently in use.</para>
 					</argument>
 				</option>
-                                <option name="R">
-                                        <para>Default: Indicate ringing to the calling party, even if the called party isn't actually ringing. 
+				<option name="R">
+					<para>Default: Indicate ringing to the calling party, even if the called party isn't actually ringing. 
 					Allow interruption of the ringback if early media is received on the channel.</para>
-                                </option>
+				</option>
 				<option name="S">
 					<argument name="x" required="true" />
 					<para>Hang up the call <replaceable>x</replaceable> seconds <emphasis>after</emphasis> the called party has
@@ -391,8 +412,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</option>
 				<option name="s">
 					<argument name="x" required="true" />
-					<para>Force the outgoing callerid tag parameter to be set to the string <replaceable>x</replaceable>.</para>
-					<para>Works with the f option.</para>
+					<para>Force the outgoing CallerID tag parameter to be set to the string <replaceable>x</replaceable>.</para>
+					<para>Works with the <literal>f</literal> option.</para>
 				</option>
 				<option name="t">
 					<para>Allow the called party to transfer the calling party by sending the
@@ -406,15 +427,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</option>
 				<option name="U" argsep="^">
 					<argument name="x" required="true">
-						<para>Name of the subroutine to execute via Gosub</para>
+						<para>Name of the subroutine to execute via <literal>Gosub</literal></para>
 					</argument>
 					<argument name="arg" multiple="true" required="false">
-						<para>Arguments for the Gosub routine</para>
+						<para>Arguments for the <literal>Gosub</literal> routine</para>
 					</argument>
-					<para>Execute via Gosub the routine <replaceable>x</replaceable> for the <emphasis>called</emphasis> channel before connecting
-					to the calling channel. Arguments can be specified to the Gosub
-					using <literal>^</literal> as a delimiter. The Gosub routine can set the variable
-					<variable>GOSUB_RESULT</variable> to specify the following actions after the Gosub returns.</para>
+					<para>Execute via <literal>Gosub</literal> the routine <replaceable>x</replaceable> for the <emphasis>called</emphasis> channel before connecting
+					to the calling channel. Arguments can be specified to the <literal>Gosub</literal>
+					using <literal>^</literal> as a delimiter. The <literal>Gosub</literal> routine can set the variable
+					<variable>GOSUB_RESULT</variable> to specify the following actions after the <literal>Gosub</literal> returns.</para>
 					<variablelist>
 						<variable name="GOSUB_RESULT">
 							<value name="ABORT">
@@ -438,7 +459,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<note>
 						<para>You cannot use any additional action post answer options in conjunction
 						with this option. Also, pbx services are run on the peer (called) channel,
-						so you will not be able to set timeouts via the TIMEOUT() function in this routine.</para>
+						so you will not be able to set timeouts via the <literal>TIMEOUT()</literal> function in this routine.</para>
 					</note>
 				</option>
 				<option name="u">
@@ -455,7 +476,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 						<literal>prohib</literal>
 						<literal>unavailable</literal></para>
 					</argument>
-					<para>Works with the f option.</para>
+					<para>Works with the <literal>f</literal> option.</para>
 				</option>
 				<option name="w">
 					<para>Allow the called party to enable recording of the call by sending
@@ -497,11 +518,62 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			hangs up, or if the call is bridged and either of the parties in the bridge
 			ends the call.</para>
 			<para>If the <variable>OUTBOUND_GROUP</variable> variable is set, all peer channels created by this
-			application will be put into that group (as in Set(GROUP()=...).
+			application will be put into that group (as in <literal>Set(GROUP()=...</literal>).
 			If the <variable>OUTBOUND_GROUP_ONCE</variable> variable is set, all peer channels created by this
-			application will be put into that group (as in Set(GROUP()=...). Unlike <variable>OUTBOUND_GROUP</variable>,
+			application will be put into that group (as in <literal>Set(GROUP()=...</literal>). Unlike <variable>OUTBOUND_GROUP</variable>,
 			however, the variable will be unset after use.</para>
 
+			<example title="Dial with 30 second timeout">
+			 same => n,Dial(PJSIP/alice,30)
+			</example>
+			<example title="Parallel dial with 45 second timeout">
+			 same => n,Dial(PJSIP/alice&amp;PJIP/bob,45)
+			</example>
+			<example title="Dial with 'g' continuation option">
+			 same => n,Dial(PJSIP/alice,,g)
+			 same => n,Log(NOTICE, Alice call result: ${DIALSTATUS})
+			</example>
+			<example title="Dial with transfer/recording features for calling party">
+			 same => n,Dial(PJSIP/alice,,TX)
+			</example>
+			<example title="Dial with call length limit">
+			 same => n,Dial(PJSIP/alice,,L(60000:30000:10000))
+			</example>
+			<example title="Dial alice and bob and send NO_ANSWER to bob instead of ANSWERED_ELSEWHERE when alice answers">
+			 same => n,Dial(PJSIP/alice&amp;PJSIP/bob,,Q(NO_ANSWER))
+			</example>
+			<example title="Dial with pre-dial subroutines">
+			[default]
+
+			exten => callee_channel,1,NoOp()
+			 same => n,Log(NOTICE, I'm called on channel ${CHANNEL} prior to it starting the dial attempt)
+			 same => n,Return()
+
+			exten => called_channel,1,NoOp()
+			 same => n,Log(NOTICE, I'm called on outbound channel ${CHANNEL} prior to it being used to dial someone)
+			 same => n,Return()
+
+			exten => _X.,1,NoOp()
+			 same => n,Dial(PJSIP/alice,,b(default^called_channel^1)B(default^callee_channel^1))
+			 same => n,Hangup()
+			</example>
+			<example title="Dial with post-answer subroutine executed on outbound channel">
+			[default]
+
+			exten => called_channel,1,NoOp()
+			 same => n,Playback(hello)
+			 same => n,Return()
+
+			exten => _X.,1,NoOp()
+			 same => n,Dial(PJSIP/alice,,U(default^called_channel^1))
+			 same => n,Hangup()
+			</example>
+			<example title="Dial into ConfBridge using 'G' option">
+			 same => n,Dial(PJSIP/alice,,G(jump_to_here))
+			 same => n(jump_to_here),Goto(confbridge)
+			 same => n,Goto(confbridge)
+			 same => n(confbridge),ConfBridge(${EXTEN})
+			</example>
 			<para>This application sets the following channel variables:</para>
 			<variablelist>
 				<variable name="DIALEDTIME">
@@ -510,6 +582,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<variable name="ANSWEREDTIME">
 					<para>This is the amount of time for actual call.</para>
 				</variable>
+				<variable name="DIALEDPEERNAME">
+					<para>The name of the outbound channel that answered the call.</para>
+				</variable>
+				<variable name="DIALEDPEERNUMBER">
+					<para>The number that was dialed for the answered outbound channel.</para>
+				</variable>
+				<variable name="FORWARDERNAME">
+					<para>If a call forward occurred, the name of the forwarded channel.</para>
+				</variable>
 				<variable name="DIALSTATUS">
 					<para>This is the status of the call</para>
 					<value name="CHANUNAVAIL" />
@@ -530,6 +611,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</variable>
 			</variablelist>
 		</description>
+		<see-also>
+			<ref type="application">RetryDial</ref>
+			<ref type="application">SendDTMF</ref>
+			<ref type="application">Gosub</ref>
+			<ref type="application">Macro</ref>
+		</see-also>
 	</application>
 	<application name="RetryDial" language="en_US">
 		<synopsis>
@@ -562,6 +649,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			The <replaceable>dialargs</replaceable> are specified in the same format that arguments are provided
 			to the Dial application.</para>
 		</description>
+		<see-also>
+			<ref type="application">Dial</ref>
+		</see-also>
 	</application>
  ***/
 
@@ -616,6 +706,7 @@ enum {
 #define OPT_PREDIAL_CALLEE   (1LLU << 41)
 #define OPT_PREDIAL_CALLER   (1LLU << 42)
 #define OPT_RING_WITH_EARLY_MEDIA (1LLU << 43)
+#define OPT_HANGUPCAUSE      (1LLU << 44)
 
 enum {
 	OPT_ARG_ANNOUNCE = 0,
@@ -637,6 +728,7 @@ enum {
 	OPT_ARG_FORCE_CID_PRES,
 	OPT_ARG_PREDIAL_CALLEE,
 	OPT_ARG_PREDIAL_CALLER,
+	OPT_ARG_HANGUPCAUSE,
 	/* note: this entry _MUST_ be the last one in the enum */
 	OPT_ARG_ARRAY_SIZE
 };
@@ -670,6 +762,7 @@ AST_APP_OPTIONS(dial_exec_options, BEGIN
 	AST_APP_OPTION_ARG('O', OPT_OPERMODE, OPT_ARG_OPERMODE),
 	AST_APP_OPTION('p', OPT_SCREENING),
 	AST_APP_OPTION_ARG('P', OPT_PRIVACY, OPT_ARG_PRIVACY),
+	AST_APP_OPTION_ARG('Q', OPT_HANGUPCAUSE, OPT_ARG_HANGUPCAUSE),
 	AST_APP_OPTION_ARG('r', OPT_RINGBACK, OPT_ARG_RINGBACK),
 	AST_APP_OPTION('R', OPT_RING_WITH_EARLY_MEDIA),
 	AST_APP_OPTION_ARG('S', OPT_DURATION_STOP, OPT_ARG_DURATION_STOP),
@@ -728,7 +821,7 @@ static void chanlist_free(struct chanlis
 	ast_free(outgoing);
 }
 
-static void hanguptree(struct dial_head *out_chans, struct ast_channel *exception, int answered_elsewhere)
+static void hanguptree(struct dial_head *out_chans, struct ast_channel *exception, int hangupcause)
 {
 	/* Hang up a tree of stuff */
 	struct chanlist *outgoing;
@@ -736,9 +829,9 @@ static void hanguptree(struct dial_head
 	while ((outgoing = AST_LIST_REMOVE_HEAD(out_chans, node))) {
 		/* Hangup any existing lines we have open */
 		if (outgoing->chan && (outgoing->chan != exception)) {
-			if (answered_elsewhere) {
+			if (hangupcause >= 0) {
 				/* This is for the channel drivers */
-				ast_channel_hangupcause_set(outgoing->chan, AST_CAUSE_ANSWERED_ELSEWHERE);
+				ast_channel_hangupcause_set(outgoing->chan, hangupcause);
 			}
 			ast_hangup(outgoing->chan);
 		}
@@ -834,6 +927,7 @@ static void do_forward(struct chanlist *
 	struct ast_party_id *forced_clid, struct ast_party_id *stored_clid)
 {
 	char tmpchan[256];
+	char forwarder[AST_CHANNEL_NAME];
 	struct ast_channel *original = o->chan;
 	struct ast_channel *c = o->chan; /* the winner */
 	struct ast_channel *in = num->chan; /* the input channel */
@@ -842,6 +936,7 @@ static void do_forward(struct chanlist *
 	int cause;
 	struct ast_party_caller caller;
 
+	ast_copy_string(forwarder, ast_channel_name(c), sizeof(forwarder));
 	ast_copy_string(tmpchan, ast_channel_call_forward(c), sizeof(tmpchan));
 	if ((stuff = strchr(tmpchan, '/'))) {
 		*stuff++ = '\0';
@@ -893,6 +988,7 @@ static void do_forward(struct chanlist *
 			ast_channel_lock_both(in, o->chan);
 			ast_channel_inherit_variables(in, o->chan);
 			ast_channel_datastore_inherit(in, o->chan);
+			pbx_builtin_setvar_helper(o->chan, "FORWARDERNAME", forwarder);
 			ast_max_forwards_decrement(o->chan);
 			ast_channel_unlock(in);
 			ast_channel_unlock(o->chan);
@@ -1205,6 +1301,7 @@ static struct ast_channel *wait_for_answ
 						}
 					}
 					peer = c;
+					publish_dial_end_event(in, out_chans, peer, "CANCEL");
 					ast_copy_flags64(peerflags, o,
 						OPT_CALLEE_TRANSFER | OPT_CALLER_TRANSFER |
 						OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
@@ -1843,9 +1940,10 @@ static int do_privacy(struct ast_channel
 		ast_copy_string(pa->status, "DONTCALL", sizeof(pa->status));
 		break;
 	case '5':
-		/* XXX should we set status to DENY ? */
-		if (ast_test_flag64(opts, OPT_PRIVACY))
+		if (ast_test_flag64(opts, OPT_PRIVACY)) {
+			ast_copy_string(pa->status, "NOANSWER", sizeof(pa->status));
 			break;
+		}
 		/* if not privacy, then 5 is the same as "default" case */
 	default: /* bad input or -1 if failure to start autoservice */
 		/* well, if the user messes up, ... he had his chance... What Is The Best Thing To Do?  */
@@ -1870,8 +1968,6 @@ static int do_privacy(struct ast_channel
 		}
 		return 0; /* the good exit path */
 	} else {
-		/* hang up on the callee -- he didn't want to talk anyway! */
-		ast_autoservice_chan_hangup_peer(chan, peer);
 		return -1;
 	}
 }
@@ -2442,16 +2538,14 @@ static int dial_exec_full(struct ast_cha
 			continue;
 		}
 
-		ast_channel_lock(tc);
-		ast_channel_stage_snapshot(tc);
-		ast_channel_unlock(tc);
-
 		ast_channel_get_device_name(tc, device_name, sizeof(device_name));
 		if (!ignore_cc) {
 			ast_cc_extension_monitor_add_dialstring(chan, tmp->interface, device_name);
 		}
 
 		ast_channel_lock_both(tc, chan);
+		ast_channel_stage_snapshot(tc);
+
 		pbx_builtin_setvar_helper(tc, "DIALEDPEERNUMBER", tmp->number);
 
 		/* Setup outgoing SDP to match incoming one */
@@ -2467,7 +2561,6 @@ static int dial_exec_full(struct ast_cha
 
 		ast_channel_appl_set(tc, "AppDial");
 		ast_channel_data_set(tc, "(Outgoing Line)");
-		ast_channel_publish_snapshot(tc);
 
 		memset(ast_channel_whentohangup(tc), 0, sizeof(*ast_channel_whentohangup(tc)));
 
@@ -2692,23 +2785,39 @@ static int dial_exec_full(struct ast_cha
 		}
 	} else {
 		const char *number;
+		const char *name;
 		int dial_end_raised = 0;
+		int cause = -1;
 
-		if (ast_test_flag64(&opts, OPT_CALLER_ANSWER))
+		if (ast_test_flag64(&opts, OPT_CALLER_ANSWER)) {
 			ast_answer(chan);
+		}
 
-		strcpy(pa.status, "ANSWER");
-		ast_channel_stage_snapshot(chan);
-		pbx_builtin_setvar_helper(chan, "DIALSTATUS", pa.status);
 		/* Ah ha!  Someone answered within the desired timeframe.  Of course after this
 		   we will always return with -1 so that it is hung up properly after the
 		   conversation.  */
-		hanguptree(&out_chans, peer, 1);
+
+		if (ast_test_flag64(&opts, OPT_HANGUPCAUSE)
+			&& !ast_strlen_zero(opt_args[OPT_ARG_HANGUPCAUSE])) {
+			cause = ast_str2cause(opt_args[OPT_ARG_HANGUPCAUSE]);
+			if (cause <= 0) {
+				if (!strcasecmp(opt_args[OPT_ARG_HANGUPCAUSE], "NONE")) {
+					cause = 0;
+				} else if (sscanf(opt_args[OPT_ARG_HANGUPCAUSE], "%30d", &cause) != 1
+					|| cause < 0) {
+					ast_log(LOG_WARNING, "Invalid cause given to Dial(...Q(<cause>)): \"%s\"\n",
+						opt_args[OPT_ARG_HANGUPCAUSE]);
+					cause = -1;
+				}
+			}
+		}
+		hanguptree(&out_chans, peer, cause >= 0 ? cause : AST_CAUSE_ANSWERED_ELSEWHERE);
+
 		/* If appropriate, log that we have a destination channel and set the answer time */
-		if (ast_channel_name(peer))
-			pbx_builtin_setvar_helper(chan, "DIALEDPEERNAME", ast_channel_name(peer));
 
 		ast_channel_lock(peer);
+		name = ast_strdupa(ast_channel_name(peer));
+
 		number = pbx_builtin_getvar_helper(peer, "DIALEDPEERNUMBER");
 		if (ast_strlen_zero(number)) {
 			number = NULL;
@@ -2716,8 +2825,16 @@ static int dial_exec_full(struct ast_cha
 			number = ast_strdupa(number);
 		}
 		ast_channel_unlock(peer);
+
 		ast_channel_lock(chan);
+		ast_channel_stage_snapshot(chan);
+
+		strcpy(pa.status, "ANSWER");
+		pbx_builtin_setvar_helper(chan, "DIALSTATUS", pa.status);
+
+		pbx_builtin_setvar_helper(chan, "DIALEDPEERNAME", name);
 		pbx_builtin_setvar_helper(chan, "DIALEDPEERNUMBER", number);
+
 		ast_channel_stage_snapshot_done(chan);
 		ast_channel_unlock(chan);
 
@@ -2728,6 +2845,8 @@ static int dial_exec_full(struct ast_cha
 		if ( (ast_test_flag64(&opts, OPT_PRIVACY) || ast_test_flag64(&opts, OPT_SCREENING)) && pa.privdb_val == AST_PRIVACY_UNKNOWN) {
 			if (do_privacy(chan, peer, &opts, opt_args, &pa)) {
 				ast_channel_publish_dial(chan, peer, NULL, pa.status);
+				/* hang up on the callee -- he didn't want to talk anyway! */
+				ast_autoservice_chan_hangup_peer(chan, peer);
 				res = 0;
 				goto out;
 			}
@@ -2751,7 +2870,7 @@ static int dial_exec_full(struct ast_cha
 				ast_log(LOG_ERROR, "error streaming file '%s' to callee\n", opt_args[OPT_ARG_ANNOUNCE]);
 			}
 
-			ast_set_flag(ast_channel_flags(peer), AST_FLAG_END_DTMF_ONLY);
+			ast_channel_set_flag(peer, AST_FLAG_END_DTMF_ONLY);
 			while (ast_channel_stream(peer)) {
 				int ms;
 
@@ -2815,13 +2934,13 @@ static int dial_exec_full(struct ast_cha
 				}
 				ast_sched_runq(ast_channel_sched(peer));
 			}
-			ast_clear_flag(ast_channel_flags(peer), AST_FLAG_END_DTMF_ONLY);
+			ast_channel_clear_flag(peer, AST_FLAG_END_DTMF_ONLY);
 		}
 
 		if (chan && peer && ast_test_flag64(&opts, OPT_GOTO) && !ast_strlen_zero(opt_args[OPT_ARG_GOTO])) {
 			/* chan and peer are going into the PBX; as such neither are considered
 			 * outgoing channels any longer */
-			ast_clear_flag(ast_channel_flags(chan), AST_FLAG_OUTGOING);
+			ast_channel_clear_flag(chan, AST_FLAG_OUTGOING);
 
 			ast_replace_subargument_delimiter(opt_args[OPT_ARG_GOTO]);
 			ast_parseable_goto(chan, opt_args[OPT_ARG_GOTO]);
@@ -3105,7 +3224,11 @@ out:
 	}
 
 	ast_channel_early_bridge(chan, NULL);
-	hanguptree(&out_chans, NULL, ast_channel_hangupcause(chan)==AST_CAUSE_ANSWERED_ELSEWHERE || ast_test_flag64(&opts, OPT_CANCEL_ELSEWHERE) ? 1 : 0 ); /* forward 'answered elsewhere' if we received it */
+	 /* forward 'answered elsewhere' if we received it */
+	hanguptree(&out_chans, NULL,
+		ast_channel_hangupcause(chan) == AST_CAUSE_ANSWERED_ELSEWHERE
+		|| ast_test_flag64(&opts, OPT_CANCEL_ELSEWHERE)
+		? AST_CAUSE_ANSWERED_ELSEWHERE : -1);
 	pbx_builtin_setvar_helper(chan, "DIALSTATUS", pa.status);
 	ast_debug(1, "Exiting with DIALSTATUS=%s.\n", pa.status);
 
diff -urpN asterisk-13.9.1/apps/app_directory.c asterisk-13.17.0/apps/app_directory.c
--- asterisk-13.9.1/apps/app_directory.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_directory.c	2017-07-12 13:12:08.000000000 +0200
@@ -466,7 +466,7 @@ static struct ast_config *realtime_direc
 	struct ast_config *rtdata = NULL;
 	struct ast_category *cat;
 	struct ast_variable *var;
-	char *mailbox;
+	char *category = NULL;
 	const char *fullname;
 	const char *hidefromdir, *searchcontexts = NULL;
 	struct ast_flags config_flags = { 0 };
@@ -507,13 +507,12 @@ static struct ast_config *realtime_direc
 		return cfg;
 	}
 
-	mailbox = NULL;
-	while ( (mailbox = ast_category_browse(rtdata, mailbox)) ) {
-		struct ast_variable *alias;
-		const char *ctx = ast_variable_retrieve(rtdata, mailbox, "context");
+	while ((category = ast_category_browse(rtdata, category))) {
+		const char *mailbox = ast_variable_retrieve(rtdata, category, "mailbox");
+		const char *ctx = ast_variable_retrieve(rtdata, category, "context");
 
-		fullname = ast_variable_retrieve(rtdata, mailbox, "fullname");
-		hidefromdir = ast_variable_retrieve(rtdata, mailbox, "hidefromdir");
+		fullname = ast_variable_retrieve(rtdata, category, "fullname");
+		hidefromdir = ast_variable_retrieve(rtdata, category, "hidefromdir");
 		if (ast_true(hidefromdir)) {
 			/* Skip hidden */
 			continue;
@@ -521,8 +520,9 @@ static struct ast_config *realtime_direc
 
 		/* password,Full Name,email,pager,options */
 		ast_str_set(&tmp, 0, "no-password,%s,,,", S_OR(fullname, ""));
-		if (ast_variable_retrieve(rtdata, mailbox, "alias")) {
-			for (alias = ast_variable_browse(rtdata, mailbox); alias; alias = alias->next) {
+		if (ast_variable_retrieve(rtdata, category, "alias")) {
+			struct ast_variable *alias;
+			for (alias = ast_variable_browse(rtdata, category); alias; alias = alias->next) {
 				if (!strcasecmp(alias->name, "alias")) {
 					ast_str_append(&tmp, 0, "|alias=%s", alias->value);
 				}
diff -urpN asterisk-13.9.1/apps/app_disa.c asterisk-13.17.0/apps/app_disa.c
--- asterisk-13.9.1/apps/app_disa.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_disa.c	2017-07-12 13:12:08.000000000 +0200
@@ -210,7 +210,7 @@ static int disa_exec(struct ast_channel
 
 	play_dialtone(chan, args.mailbox);
 
-	ast_set_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
+	ast_channel_set_flag(chan, AST_FLAG_END_DTMF_ONLY);
 
 	for (;;) {
 		  /* if outa time, give em reorder */
@@ -226,7 +226,7 @@ static int disa_exec(struct ast_channel
 		}
 
 		if (!(f = ast_read(chan))) {
-			ast_clear_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
+			ast_channel_clear_flag(chan, AST_FLAG_END_DTMF_ONLY);
 			return -1;
 		}
 
@@ -234,7 +234,7 @@ static int disa_exec(struct ast_channel
 			if (f->data.uint32)
 				ast_channel_hangupcause_set(chan, f->data.uint32);
 			ast_frfree(f);
-			ast_clear_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
+			ast_channel_clear_flag(chan, AST_FLAG_END_DTMF_ONLY);
 			return -1;
 		}
 
@@ -263,7 +263,7 @@ static int disa_exec(struct ast_channel
 						fp = fopen(args.passcode,"r");
 						if (!fp) {
 							ast_log(LOG_WARNING,"DISA password file %s not found on chan %s\n",args.passcode,ast_channel_name(chan));
-							ast_clear_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
+							ast_channel_clear_flag(chan, AST_FLAG_END_DTMF_ONLY);
 							return -1;
 						}
 						pwline[0] = 0;
@@ -359,7 +359,7 @@ static int disa_exec(struct ast_channel
 		}
 	}
 
-	ast_clear_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
+	ast_channel_clear_flag(chan, AST_FLAG_END_DTMF_ONLY);
 
 	if (k == 3) {
 		int recheck = 0;
diff -urpN asterisk-13.9.1/apps/app_dumpchan.c asterisk-13.17.0/apps/app_dumpchan.c
--- asterisk-13.9.1/apps/app_dumpchan.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_dumpchan.c	2017-07-12 13:12:08.000000000 +0200
@@ -90,8 +90,6 @@ static int serialize_showchan(struct ast
 
 	ast_channel_lock(c);
 	bridge = ast_channel_get_bridge(c);
-	ast_channel_unlock(c);
-
 	snprintf(buf,size,
 		"Name=               %s\n"
 		"Type=               %s\n"
@@ -168,7 +166,7 @@ static int serialize_showchan(struct ast
 		ast_channel_appl(c) ? ast_channel_appl(c) : "(N/A)",
 		ast_channel_data(c) ? S_OR(ast_channel_data(c), "(Empty)") : "(None)",
 		(ast_test_flag(ast_channel_flags(c), AST_FLAG_BLOCKING) ? ast_channel_blockproc(c) : "(Not Blocking)"));
-
+	ast_channel_unlock(c);
 	ao2_cleanup(bridge);
 	return 0;
 }
diff -urpN asterisk-13.9.1/apps/app_echo.c asterisk-13.17.0/apps/app_echo.c
--- asterisk-13.9.1/apps/app_echo.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_echo.c	2017-07-12 13:12:08.000000000 +0200
@@ -68,7 +68,8 @@ static int echo_exec(struct ast_channel
 		f->delivery.tv_sec = 0;
 		f->delivery.tv_usec = 0;
 		if (f->frametype == AST_FRAME_CONTROL
-			&& f->subclass.integer == AST_CONTROL_VIDUPDATE) {
+			&& f->subclass.integer == AST_CONTROL_VIDUPDATE
+			&& !fir_sent) {
 			if (ast_write(chan, f) < 0) {
 				ast_frfree(f);
 				goto end;
diff -urpN asterisk-13.9.1/apps/app_externalivr.c asterisk-13.17.0/apps/app_externalivr.c
--- asterisk-13.9.1/apps/app_externalivr.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_externalivr.c	2017-07-12 13:12:08.000000000 +0200
@@ -645,9 +645,9 @@ static int eivr_comm(struct ast_channel
 		setvbuf(eivr_errors, NULL, _IONBF, 0);
 	}
 
- 	while (1) {
- 		if (ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE)) {
- 			ast_chan_log(LOG_ERROR, chan, "Is a zombie\n");
+	while (1) {
+		if (ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE)) {
+			ast_chan_log(LOG_ERROR, chan, "Is a zombie\n");
  			break;
  		}
  		if (!hangup_info_sent && !(ast_test_flag(&flags, run_dead)) && ast_check_hangup(chan)) {
diff -urpN asterisk-13.9.1/apps/app_fax.c asterisk-13.17.0/apps/app_fax.c
--- asterisk-13.9.1/apps/app_fax.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_fax.c	2017-07-12 13:12:08.000000000 +0200
@@ -262,13 +262,13 @@ static void phase_e_handler(t30_state_t
 	}
 	ast_json_ref(json_filenames);
 	json_object = ast_json_pack("{s: s, s: s, s: s, s: i, s: i, s: i, s: o}",
-			"type", s->direction ? "send" : "receive",
-			"remote_station_id", far_ident,
-			"local_station_id", local_ident,
-			"fax_pages", pages_transferred,
-			"fax_resolution", stat.y_resolution,
-			"fax_bitrate", stat.bit_rate,
-			"filenames", json_filenames);
+		"type", s->direction ? "send" : "receive",
+		"remote_station_id", AST_JSON_UTF8_VALIDATE(far_ident),
+		"local_station_id", AST_JSON_UTF8_VALIDATE(local_ident),
+		"fax_pages", pages_transferred,
+		"fax_resolution", stat.y_resolution,
+		"fax_bitrate", stat.bit_rate,
+		"filenames", json_filenames);
 	message = ast_channel_blob_create_from_cache(ast_channel_uniqueid(s->chan), ast_channel_fax_type(), json_object);
 	if (!message) {
 		return;
diff -urpN asterisk-13.9.1/apps/app_followme.c asterisk-13.17.0/apps/app_followme.c
--- asterisk-13.9.1/apps/app_followme.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_followme.c	2017-07-12 13:12:08.000000000 +0200
@@ -66,6 +66,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/stasis_channels.h"
 #include "asterisk/max_forwards.h"
 
+#define REC_FORMAT "sln"
+
 /*** DOCUMENTATION
 	<application name="FollowMe" language="en_US">
 		<synopsis>
@@ -309,8 +311,16 @@ static struct call_followme *alloc_profi
 
 	ast_mutex_init(&f->lock);
 	ast_copy_string(f->name, fmname, sizeof(f->name));
-	f->moh[0] = '\0';
+	AST_LIST_HEAD_INIT_NOLOCK(&f->numbers);
+	AST_LIST_HEAD_INIT_NOLOCK(&f->blnumbers);
+	AST_LIST_HEAD_INIT_NOLOCK(&f->wlnumbers);
+	return f;
+}
+
+static void init_profile(struct call_followme *f, int activate)
+{
 	f->context[0] = '\0';
+	ast_copy_string(f->moh, defaultmoh, sizeof(f->moh));
 	ast_copy_string(f->takecall, takecall, sizeof(f->takecall));
 	ast_copy_string(f->nextindp, nextindp, sizeof(f->nextindp));
 	ast_copy_string(f->callfromprompt, callfromprompt, sizeof(f->callfromprompt));
@@ -319,16 +329,9 @@ static struct call_followme *alloc_profi
 	ast_copy_string(f->plsholdprompt, plsholdprompt, sizeof(f->plsholdprompt));
 	ast_copy_string(f->statusprompt, statusprompt, sizeof(f->statusprompt));
 	ast_copy_string(f->sorryprompt, sorryprompt, sizeof(f->sorryprompt));
-	AST_LIST_HEAD_INIT_NOLOCK(&f->numbers);
-	AST_LIST_HEAD_INIT_NOLOCK(&f->blnumbers);
-	AST_LIST_HEAD_INIT_NOLOCK(&f->wlnumbers);
-	return f;
-}
-
-static void init_profile(struct call_followme *f)
-{
-	f->active = 1;
-	ast_copy_string(f->moh, defaultmoh, sizeof(f->moh));
+	if (activate) {
+		f->active = 1;
+	}
 }
 
    
@@ -501,7 +504,7 @@ static int reload_followme(int reload)
 		if (!new)
 			ast_mutex_lock(&f->lock);
 		/* Re-initialize the profile */
-		init_profile(f);
+		init_profile(f, 1);
 		free_numbers(f);
 		var = ast_variable_browse(cfg, cat);
 		while (var) {
@@ -1214,6 +1217,7 @@ static struct call_followme *find_realti
 		ast_free(str);
 		return NULL;
 	}
+	init_profile(new_follower, 0);
 
 	for (v = var; v; v = v->next) {
 		if (!strcasecmp(v->name, "active")) {
@@ -1421,7 +1425,7 @@ static int app_exec(struct ast_channel *
 
 			snprintf(targs->namerecloc, sizeof(targs->namerecloc), "%s/followme.%s",
 				ast_config_AST_SPOOL_DIR, ast_channel_uniqueid(chan));
-			if (ast_play_and_record(chan, "vm-rec-name", targs->namerecloc, 5, "sln", &duration,
+			if (ast_play_and_record(chan, "vm-rec-name", targs->namerecloc, 5, REC_FORMAT, &duration,
 				NULL, ast_dsp_get_threshold_from_settings(THRESHOLD_SILENCE), 0, NULL) < 0) {
 				goto outrun;
 			}
@@ -1522,7 +1526,18 @@ outrun:
 		ast_free(nm);
 	}
 	if (!ast_strlen_zero(targs->namerecloc)) {
-		unlink(targs->namerecloc);
+		int ret;
+		char fn[PATH_MAX];
+
+		snprintf(fn, sizeof(fn), "%s.%s", targs->namerecloc,
+			     REC_FORMAT);
+		ret = unlink(fn);
+		if (ret != 0) {
+			ast_log(LOG_NOTICE, "Failed to delete recorded name file %s: %d (%s)\n",
+					fn, errno, strerror(errno));
+		} else {
+			ast_debug(2, "deleted recorded prompt %s.\n", fn);
+		}
 	}
 	ast_free((char *) targs->predial_callee);
 	ast_party_connected_line_free(&targs->connected_in);
diff -urpN asterisk-13.9.1/apps/app_forkcdr.c asterisk-13.17.0/apps/app_forkcdr.c
--- asterisk-13.9.1/apps/app_forkcdr.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_forkcdr.c	2017-07-12 13:12:08.000000000 +0200
@@ -201,7 +201,7 @@ static int load_module(void)
 	int res = 0;
 
 	if (!router) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	res |= STASIS_MESSAGE_TYPE_INIT(forkcdr_message_type);
@@ -210,7 +210,9 @@ static int load_module(void)
 	                                 forkcdr_callback, NULL);
 
 	if (res) {
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/apps/app_macro.c asterisk-13.17.0/apps/app_macro.c
--- asterisk-13.9.1/apps/app_macro.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_macro.c	2017-07-12 13:12:08.000000000 +0200
@@ -243,7 +243,7 @@ static int _macro_exec(struct ast_channe
 	int setmacrocontext=0;
 	int autoloopflag, inhangup = 0;
 	struct ast_str *tmp_subst = NULL;
-  
+	const char *my_macro_exten = NULL;
 	char *save_macro_exten;
 	char *save_macro_context;
 	char *save_macro_priority;
@@ -304,12 +304,32 @@ static int _macro_exec(struct ast_channe
 	}
 
 	snprintf(fullmacro, sizeof(fullmacro), "macro-%s", macro);
-	if (!ast_exists_extension(chan, fullmacro, "s", 1,
-		S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL))) {
-		if (!ast_context_find(fullmacro)) 
-			ast_log(LOG_WARNING, "No such context '%s' for macro '%s'. Was called by %s@%s\n", fullmacro, macro, ast_channel_exten(chan), ast_channel_context(chan));
-		else
-			ast_log(LOG_WARNING, "Context '%s' for macro '%s' lacks 's' extension, priority 1\n", fullmacro, macro);
+
+	/* first search for the macro */
+	if (!ast_context_find(fullmacro)) {
+		ast_log(LOG_WARNING, "No such context '%s' for macro '%s'. Was called by %s@%s\n",
+			fullmacro, macro, ast_channel_exten(chan), ast_channel_context(chan));
+		return 0;
+	}
+
+	/* now search for the right extension */
+	if (ast_exists_extension(chan, fullmacro, "s", 1,
+		S_COR(ast_channel_caller(chan)->id.number.valid,
+			ast_channel_caller(chan)->id.number.str, NULL))) {
+		/* We have a normal macro */
+		my_macro_exten = "s";
+	} else if (ast_exists_extension(chan, fullmacro, "~~s~~", 1,
+		S_COR(ast_channel_caller(chan)->id.number.valid,
+			ast_channel_caller(chan)->id.number.str, NULL))) {
+		/* We have an AEL generated macro */
+		my_macro_exten = "~~s~~";
+	}
+
+	/* do we have a valid exten? */
+	if (!my_macro_exten) {
+		ast_log(LOG_WARNING,
+			"Context '%s' for macro '%s' lacks 's' extension, priority 1\n",
+			fullmacro, macro);
 		return 0;
 	}
 
@@ -361,7 +381,7 @@ static int _macro_exec(struct ast_channe
 	ast_set_flag(ast_channel_flags(chan), AST_FLAG_SUBROUTINE_EXEC);
 
 	/* Setup environment for new run */
-	ast_channel_exten_set(chan, "s");
+	ast_channel_exten_set(chan, my_macro_exten);
 	ast_channel_context_set(chan, fullmacro);
 	ast_channel_priority_set(chan, 1);
 
diff -urpN asterisk-13.9.1/apps/app_meetme.c asterisk-13.17.0/apps/app_meetme.c
--- asterisk-13.9.1/apps/app_meetme.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_meetme.c	2017-07-12 13:12:08.000000000 +0200
@@ -4663,7 +4663,7 @@ static struct ast_conference *find_conf_
 	if (cnf) {
 		if (confflags->flags && !cnf->chan &&
 		    !ast_test_flag64(confflags, CONFFLAG_QUIET) &&
-		    ast_test_flag64(confflags, CONFFLAG_INTROUSER | CONFFLAG_INTROUSERNOREVIEW) | CONFFLAG_INTROUSER_VMREC) {
+		    ast_test_flag64(confflags, CONFFLAG_INTROUSER | CONFFLAG_INTROUSERNOREVIEW | CONFFLAG_INTROUSER_VMREC)) {
 			ast_log(LOG_WARNING, "No DAHDI channel available for conference, user introduction disabled (is chan_dahdi loaded?)\n");
 			ast_clear_flag64(confflags, CONFFLAG_INTROUSER | CONFFLAG_INTROUSERNOREVIEW | CONFFLAG_INTROUSER_VMREC);
 		}
diff -urpN asterisk-13.9.1/apps/app_minivm.c asterisk-13.17.0/apps/app_minivm.c
--- asterisk-13.9.1/apps/app_minivm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_minivm.c	2017-07-12 13:12:08.000000000 +0200
@@ -856,16 +856,16 @@ static int b64_inbuf(struct b64_baseio *
 	if (bio->ateof)
 		return 0;
 
-	if ((l = fread(bio->iobuf, 1, B64_BASEMAXINLINE,fi)) <= 0) {
-		if (ferror(fi))
-			return -1;
-
+	if ((l = fread(bio->iobuf, 1, B64_BASEMAXINLINE, fi)) != B64_BASEMAXINLINE) {
 		bio->ateof = 1;
-		return 0;
+		if (l == 0) {
+			/* Assume EOF */
+			return 0;
+		}
 	}
 
-	bio->iolen= l;
-	bio->iocp= 0;
+	bio->iolen = l;
+	bio->iocp = 0;
 
 	return 1;
 }
@@ -1853,10 +1853,10 @@ static int notify_new_message(struct ast
 	}
 	mwi_state->snapshot = ast_channel_snapshot_get_latest(ast_channel_uniqueid(chan));
 
-	json_object = ast_json_pack("{s: s, s: s}",
-			"Event", "MiniVoiceMail"
-			"Action", "SentNotification",
-			"Counter", counter);
+	json_object = ast_json_pack("{s: s, s: s, s: s}",
+		"Event", "MiniVoiceMail",
+		"Action", "SentNotification",
+		"Counter", counter ?: "");
 	if (!json_object) {
 		goto notify_cleanup;
 	}
@@ -3016,11 +3016,9 @@ static char *complete_minivm_show_users(
 	struct minivm_account *vmu;
 	const char *domain = "";
 
-	/* 0 - voicemail; 1 - list; 2 - accounts; 3 - for; 4 - <domain> */
+	/* 0 - minivm; 1 - list; 2 - accounts; 3 - for; 4 - <domain> */
 	if (pos > 4)
 		return NULL;
-	if (pos == 3)
-		return (state == 0) ? ast_strdup("for") : NULL;
 	wordlen = strlen(word);
 	AST_LIST_TRAVERSE(&minivm_accounts, vmu, list) {
 		if (!strncasecmp(word, vmu->domain, wordlen)) {
@@ -3042,9 +3040,9 @@ static char *handle_minivm_show_users(st
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "minivm list accounts";
+		e->command = "minivm list accounts [for]";
 		e->usage =
-			"Usage: minivm list accounts\n"
+			"Usage: minivm list accounts [for <domain>]\n"
 			"       Lists all mailboxes currently set up\n";
 		return NULL;
 	case CLI_GENERATE:
diff -urpN asterisk-13.9.1/apps/app_mixmonitor.c asterisk-13.17.0/apps/app_mixmonitor.c
--- asterisk-13.9.1/apps/app_mixmonitor.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_mixmonitor.c	2017-07-12 13:12:08.000000000 +0200
@@ -622,6 +622,16 @@ static void mixmonitor_save_prep(struct
 	}
 }
 
+static int mixmonitor_autochan_is_bridged(struct ast_autochan *autochan)
+{
+	int is_bridged;
+
+	ast_autochan_channel_lock(autochan);
+	is_bridged = ast_channel_is_bridged(autochan->chan);
+	ast_autochan_channel_unlock(autochan);
+	return is_bridged;
+}
+
 static void *mixmonitor_thread(void *obj)
 {
 	struct mixmonitor *mixmonitor = obj;
@@ -679,8 +689,7 @@ static void *mixmonitor_thread(void *obj
 		ast_audiohook_unlock(&mixmonitor->audiohook);
 
 		if (!ast_test_flag(mixmonitor, MUXFLAG_BRIDGED)
-			|| (mixmonitor->autochan->chan
-				&& ast_channel_is_bridged(mixmonitor->autochan->chan))) {
+			|| mixmonitor_autochan_is_bridged(mixmonitor->autochan)) {
 			ast_mutex_lock(&mixmonitor->mixmonitor_ds->lock);
 
 			/* Write out the frame(s) */
@@ -729,11 +738,11 @@ static void *mixmonitor_thread(void *obj
 
 	ast_audiohook_unlock(&mixmonitor->audiohook);
 
-	ast_autochan_channel_lock(mixmonitor->autochan);
 	if (ast_test_flag(mixmonitor, MUXFLAG_BEEP_STOP)) {
+		ast_autochan_channel_lock(mixmonitor->autochan);
 		ast_stream_and_wait(mixmonitor->autochan->chan, "beep", "");
+		ast_autochan_channel_unlock(mixmonitor->autochan);
 	}
-	ast_autochan_channel_unlock(mixmonitor->autochan);
 
 	ast_autochan_destroy(mixmonitor->autochan);
 
@@ -805,11 +814,11 @@ static int setup_mixmonitor_ds(struct mi
 		return -1;
 	}
 
-	ast_autochan_channel_lock(mixmonitor->autochan);
 	if (ast_test_flag(mixmonitor, MUXFLAG_BEEP_START)) {
+		ast_autochan_channel_lock(mixmonitor->autochan);
 		ast_stream_and_wait(mixmonitor->autochan->chan, "beep", "");
+		ast_autochan_channel_unlock(mixmonitor->autochan);
 	}
-	ast_autochan_channel_unlock(mixmonitor->autochan);
 
 	mixmonitor_ds->samp_rate = 8000;
 	mixmonitor_ds->audiohook = &mixmonitor->audiohook;
diff -urpN asterisk-13.9.1/apps/app_mp3.c asterisk-13.17.0/apps/app_mp3.c
--- asterisk-13.9.1/apps/app_mp3.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_mp3.c	2017-07-12 13:12:08.000000000 +0200
@@ -77,9 +77,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
  ***/
 static char *app = "MP3Player";
 
-static int mp3play(const char *filename, int fd)
+static int mp3play(const char *filename, unsigned int sampling_rate, int fd)
 {
 	int res;
+	char sampling_rate_str[8];
 
 	res = ast_safe_fork(0);
 	if (res < 0) 
@@ -93,30 +94,44 @@ static int mp3play(const char *filename,
 	dup2(fd, STDOUT_FILENO);
 	ast_close_fds_above_n(STDERR_FILENO);
 
+	snprintf(sampling_rate_str, 8, "%u", sampling_rate);
+
 	/* Execute mpg123, but buffer if it's a net connection */
-	if (!strncasecmp(filename, "http://", 7)) {
+	if (!strncasecmp(filename, "http://", 7) && strstr(filename, ".m3u")) {
+	    char buffer_size_str[8];
+	    snprintf(buffer_size_str, 8, "%u", (int) 0.5*2*sampling_rate/1000); // 0.5 seconds for a live stream
+		/* Most commonly installed in /usr/local/bin */
+	    execl(LOCAL_MPG_123, "mpg123", "-q", "-s", "-b", buffer_size_str, "-f", "8192", "--mono", "-r", sampling_rate_str, "-@", filename, (char *)NULL);
+		/* But many places has it in /usr/bin */
+	    execl(MPG_123, "mpg123", "-q", "-s", "-b", buffer_size_str, "-f", "8192", "--mono", "-r", sampling_rate_str, "-@", filename, (char *)NULL);
+		/* As a last-ditch effort, try to use PATH */
+	    execlp("mpg123", "mpg123", "-q", "-s", "-b", buffer_size_str, "-f", "8192", "--mono", "-r", sampling_rate_str, "-@", filename, (char *)NULL);
+	}
+	else if (!strncasecmp(filename, "http://", 7)) {
+	    char buffer_size_str[8];
+	    snprintf(buffer_size_str, 8, "%u", 6*2*sampling_rate/1000); // 6 seconds for a remote MP3 file
 		/* Most commonly installed in /usr/local/bin */
-	    execl(LOCAL_MPG_123, "mpg123", "-q", "-s", "-b", "1024", "-f", "8192", "--mono", "-r", "8000", filename, (char *)NULL);
+	    execl(LOCAL_MPG_123, "mpg123", "-q", "-s", "-b", buffer_size_str, "-f", "8192", "--mono", "-r", sampling_rate_str, filename, (char *)NULL);
 		/* But many places has it in /usr/bin */
-	    execl(MPG_123, "mpg123", "-q", "-s", "-b", "1024","-f", "8192", "--mono", "-r", "8000", filename, (char *)NULL);
+	    execl(MPG_123, "mpg123", "-q", "-s", "-b", buffer_size_str, "-f", "8192", "--mono", "-r", sampling_rate_str, filename, (char *)NULL);
 		/* As a last-ditch effort, try to use PATH */
-	    execlp("mpg123", "mpg123", "-q", "-s", "-b", "1024",  "-f", "8192", "--mono", "-r", "8000", filename, (char *)NULL);
+	    execlp("mpg123", "mpg123", "-q", "-s", "-b", buffer_size_str, "-f", "8192", "--mono", "-r", sampling_rate_str, filename, (char *)NULL);
 	}
 	else if (strstr(filename, ".m3u")) {
 		/* Most commonly installed in /usr/local/bin */
-	    execl(LOCAL_MPG_123, "mpg123", "-q", "-z", "-s", "-b", "1024", "-f", "8192", "--mono", "-r", "8000", "-@", filename, (char *)NULL);
+	    execl(LOCAL_MPG_123, "mpg123", "-q", "-z", "-s", "-f", "8192", "--mono", "-r", sampling_rate_str, "-@", filename, (char *)NULL);
 		/* But many places has it in /usr/bin */
-	    execl(MPG_123, "mpg123", "-q", "-z", "-s", "-b", "1024","-f", "8192", "--mono", "-r", "8000", "-@", filename, (char *)NULL);
+	    execl(MPG_123, "mpg123", "-q", "-z", "-s", "-f", "8192", "--mono", "-r", sampling_rate_str, "-@", filename, (char *)NULL);
 		/* As a last-ditch effort, try to use PATH */
-	    execlp("mpg123", "mpg123", "-q", "-z", "-s", "-b", "1024",  "-f", "8192", "--mono", "-r", "8000", "-@", filename, (char *)NULL);
+	    execlp("mpg123", "mpg123", "-q", "-z", "-s",  "-f", "8192", "--mono", "-r", sampling_rate_str, "-@", filename, (char *)NULL);
 	}
 	else {
 		/* Most commonly installed in /usr/local/bin */
-	    execl(MPG_123, "mpg123", "-q", "-s", "-f", "8192", "--mono", "-r", "8000", filename, (char *)NULL);
+	    execl(MPG_123, "mpg123", "-q", "-s", "-f", "8192", "--mono", "-r", sampling_rate_str, filename, (char *)NULL);
 		/* But many places has it in /usr/bin */
-	    execl(LOCAL_MPG_123, "mpg123", "-q", "-s", "-f", "8192", "--mono", "-r", "8000", filename, (char *)NULL);
+	    execl(LOCAL_MPG_123, "mpg123", "-q", "-s", "-f", "8192", "--mono", "-r", sampling_rate_str, filename, (char *)NULL);
 		/* As a last-ditch effort, try to use PATH */
-	    execlp("mpg123", "mpg123", "-q", "-s", "-f", "8192", "--mono", "-r", "8000", filename, (char *)NULL);
+	    execlp("mpg123", "mpg123", "-q", "-s", "-f", "8192", "--mono", "-r", sampling_rate_str, filename, (char *)NULL);
 	}
 	/* Can't use ast_log since FD's are closed */
 	fprintf(stderr, "Execute of mpg123 failed\n");
@@ -155,6 +170,9 @@ static int mp3_exec(struct ast_channel *
 	} myf = {
 		.f = { 0, },
 	};
+	struct ast_format * native_format;
+	unsigned int sampling_rate;
+	struct ast_format * write_format;
 
 	if (ast_strlen_zero(data)) {
 		ast_log(LOG_WARNING, "MP3 Playback requires an argument (filename)\n");
@@ -168,15 +186,19 @@ static int mp3_exec(struct ast_channel *
 	
 	ast_stopstream(chan);
 
+	native_format = ast_format_cap_get_format(ast_channel_nativeformats(chan), 0);
+	sampling_rate = ast_format_get_sample_rate(native_format);
+	write_format = ast_format_cache_get_slin_by_rate(sampling_rate);
+
 	owriteformat = ao2_bump(ast_channel_writeformat(chan));
-	res = ast_set_write_format(chan, ast_format_slin);
+	res = ast_set_write_format(chan, write_format);
 	if (res < 0) {
 		ast_log(LOG_WARNING, "Unable to set write format to signed linear\n");
 		return -1;
 	}
 
 	myf.f.frametype = AST_FRAME_VOICE;
-	myf.f.subclass.format = ast_format_slin;
+	myf.f.subclass.format = write_format;
 	myf.f.mallocd = 0;
 	myf.f.offset = AST_FRIENDLY_OFFSET;
 	myf.f.src = __PRETTY_FUNCTION__;
@@ -184,7 +206,7 @@ static int mp3_exec(struct ast_channel *
 	myf.f.delivery.tv_usec = 0;
 	myf.f.data.ptr = myf.frdata;
 	
-	res = mp3play(data, fds[1]);
+	res = mp3play(data, sampling_rate, fds[1]);
 	if (!strncasecmp(data, "http://", 7)) {
 		timeout = 10000;
 	}
@@ -211,7 +233,7 @@ static int mp3_exec(struct ast_channel *
 					res = 0;
 					break;
 				}
-				next = ast_tvadd(next, ast_samp2tv(myf.f.samples, 8000));
+				next = ast_tvadd(next, ast_samp2tv(myf.f.samples, sampling_rate));
 			} else {
 				ms = ast_waitfor(chan, ms);
 				if (ms < 0) {
diff -urpN asterisk-13.9.1/apps/app_originate.c asterisk-13.17.0/apps/app_originate.c
--- asterisk-13.9.1/apps/app_originate.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_originate.c	2017-07-12 13:12:08.000000000 +0200
@@ -178,15 +178,15 @@ static int originate_exec(struct ast_cha
 				chantech, chandata, args.arg1, exten, priority);
 
 		ast_pbx_outgoing_exten(chantech, cap_slin, chandata,
-				timeout * 1000, args.arg1, exten, priority, &outgoing_status, 1, NULL,
-				NULL, NULL, NULL, NULL, 0, NULL);
+				timeout * 1000, args.arg1, exten, priority, &outgoing_status,
+				AST_OUTGOING_WAIT, NULL, NULL, NULL, NULL, NULL, 0, NULL);
 	} else if (!strcasecmp(args.type, "app")) {
 		ast_debug(1, "Originating call to '%s/%s' and connecting them to %s(%s)\n",
 				chantech, chandata, args.arg1, S_OR(args.arg2, ""));
 
 		ast_pbx_outgoing_app(chantech, cap_slin, chandata,
-				timeout * 1000, args.arg1, args.arg2, &outgoing_status, 1, NULL,
-				NULL, NULL, NULL, NULL, NULL);
+				timeout * 1000, args.arg1, args.arg2, &outgoing_status,
+				AST_OUTGOING_WAIT, NULL, NULL, NULL, NULL, NULL, NULL);
 	} else {
 		ast_log(LOG_ERROR, "Incorrect type, it should be 'exten' or 'app': %s\n",
 				args.type);
diff -urpN asterisk-13.9.1/apps/app_queue.c asterisk-13.17.0/apps/app_queue.c
--- asterisk-13.9.1/apps/app_queue.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_queue.c	2017-07-12 13:12:08.000000000 +0200
@@ -259,7 +259,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			any of the join options cause the caller to not enter the queue.</para>
 			<para>This application does not automatically answer and should be preceeded
 			by an application such as Answer(), Progress(), or Ringing().</para>
-			<para>This application sets the following channel variable upon completion:</para>
+			<para>This application sets the following channel variables upon completion:</para>
 			<variablelist>
 				<variable name="QUEUESTATUS">
 					<para>The status of the call as a text string.</para>
@@ -271,6 +271,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<value name="LEAVEUNAVAIL" />
 					<value name="CONTINUE" />
 				</variable>
+				<variable name="ABANDONED">
+					<para>If the call was not answered by an agent this variable will be TRUE.</para>
+					<value name="TRUE" />
+				</variable>
 			</variablelist>
 		</description>
 		<see-also>
@@ -1505,12 +1509,12 @@ struct member {
 	int paused;                          /*!< Are we paused (not accepting calls)? */
 	char reason_paused[80];              /*!< Reason of paused if member is paused */
 	int queuepos;                        /*!< In what order (pertains to certain strategies) should this member be called? */
+	int callcompletedinsl;               /*!< Whether the current call was completed within service level */
+	time_t starttime;                    /*!< The time at which the member answered the current caller. */
 	time_t lastcall;                     /*!< When last successful call was hungup */
-	unsigned int in_call:1;              /*!< True if member is still in call. (so lastcall is not actual) */
 	struct call_queue *lastqueue;	     /*!< Last queue we received a call */
 	unsigned int dead:1;                 /*!< Used to detect members deleted in realtime */
 	unsigned int delme:1;                /*!< Flag to delete entry on reload */
-	unsigned int call_pending:1;         /*!< TRUE if the Q is attempting to place a call to the member. */
 	char rt_uniqueid[80];                /*!< Unique id of realtime member entry */
 	unsigned int ringinuse:1;            /*!< Flag to ring queue members even if their status is 'inuse' */
 };
@@ -1663,6 +1667,7 @@ static struct ao2_container *queues;
 static void update_realtime_members(struct call_queue *q);
 static struct member *interface_exists(struct call_queue *q, const char *interface);
 static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused);
+static int update_queue(struct call_queue *q, struct member *member, int callcompletedinsl, time_t starttime);
 
 static struct member *find_member_by_queuename_and_interface(const char *queuename, const char *interface);
 /*! \brief sets the QUEUESTATUS channel variable */
@@ -2176,7 +2181,7 @@ static struct ast_json *queue_member_blo
 		"Penalty", mem->penalty,
 		"CallsTaken", mem->calls,
 		"LastCall", (int)mem->lastcall,
-		"InCall", mem->in_call,
+		"InCall", mem->starttime ? 1 : 0,
 		"Status", mem->status,
 		"Paused", mem->paused,
 		"PausedReason", mem->reason_paused,
@@ -2240,10 +2245,6 @@ static int get_member_status(struct call
 			if (member->paused && (conditions & QUEUE_EMPTY_PAUSED)) {
 				ast_debug(4, "%s is unavailable because he is paused'\n", member->membername);
 				break;
-			} else if ((conditions & QUEUE_EMPTY_WRAPUP) && member->in_call && q->wrapuptime) {
-				ast_debug(4, "%s is unavailable because still in call, so we can`t check "
-					"wrapuptime (%d)\n", member->membername, q->wrapuptime);
-				break;
 			} else if ((conditions & QUEUE_EMPTY_WRAPUP) && member->lastcall && q->wrapuptime && (time(NULL) - q->wrapuptime < member->lastcall)) {
 				ast_debug(4, "%s is unavailable because it has only been %d seconds since his last call (wrapup time is %d)\n", member->membername, (int) (time(NULL) - member->lastcall), q->wrapuptime);
 				break;
@@ -2267,6 +2268,71 @@ static int get_member_status(struct call
 	return -1;
 }
 
+/*
+ * A "pool" of member objects that calls are currently pending on. If an
+ * agent is a member of multiple queues it's possible for that agent to be
+ * called by each of the queues at the same time. This happens because device
+ * state is slow to notify the queue app of one of it's member's being rung.
+ * This "pool" allows us to track which members are currently being rung while
+ * we wait on the device state change.
+ */
+static struct ao2_container *pending_members;
+#define MAX_CALL_ATTEMPT_BUCKETS 353
+
+static int pending_members_hash(const void *obj, const int flags)
+{
+	const struct member *object;
+	const char *key;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_KEY:
+		key = obj;
+		break;
+	case OBJ_SEARCH_OBJECT:
+		object = obj;
+		key = object->interface;
+		break;
+	default:
+		ast_assert(0);
+		return 0;
+	}
+	return ast_str_case_hash(key);
+}
+
+static int pending_members_cmp(void *obj, void *arg, int flags)
+{
+	const struct member *object_left = obj;
+	const struct member *object_right = arg;
+	const char *right_key = arg;
+	int cmp;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_OBJECT:
+		right_key = object_right->interface;
+		/* Fall through */
+	case OBJ_SEARCH_KEY:
+		cmp = strcasecmp(object_left->interface, right_key);
+		break;
+	case OBJ_SEARCH_PARTIAL_KEY:
+		/* Not supported by container. */
+		ast_assert(0);
+		return 0;
+	default:
+		cmp = 0;
+		break;
+	}
+	if (cmp) {
+		return 0;
+	}
+	return CMP_MATCH;
+}
+
+static void pending_members_remove(struct member *mem)
+{
+	ast_debug(3, "Removed %s from pending_members\n", mem->membername);
+	ao2_find(pending_members, mem, OBJ_POINTER | OBJ_NODATA | OBJ_UNLINK);
+}
+
 /*! \brief set a member's status based on device state of that member's state_interface.
  *
  * Lock interface list find sc, iterate through each queues queue_member list for member to
@@ -2274,7 +2340,25 @@ static int get_member_status(struct call
 */
 static void update_status(struct call_queue *q, struct member *m, const int status)
 {
-	m->status = status;
+	if (m->status != status) {
+		/* If this member has transitioned to being available then update their queue
+		 * information. If they are currently in a call then the leg to the agent will be
+		 * considered done and the call finished.
+		 */
+		if (status == AST_DEVICE_NOT_INUSE) {
+			update_queue(q, m, m->callcompletedinsl, m->starttime);
+		}
+
+		m->status = status;
+
+		/* Remove the member from the pending members pool only when the status changes.
+		 * This is not done unconditionally because we can occasionally see multiple
+		 * device state notifications of not in use after a previous call has ended,
+		 * including after we have initiated a new call. This is more likely to
+		 * happen when there is latency in the connection to the member.
+		 */
+		pending_members_remove(m);
+	}
 
 	queue_publish_member_blob(queue_member_status_type(), queue_member_blob_create(q, m));
 }
@@ -2311,9 +2395,6 @@ static int is_member_available(struct ca
 	}
 
 	/* Let wrapuptimes override device state availability */
-	if (q->wrapuptime && mem->in_call) {
-		available = 0; /* member is still in call, cant check wrapuptime to lastcall time */
-	}
 	if (mem->lastcall && q->wrapuptime && (time(NULL) - q->wrapuptime < mem->lastcall)) {
 		available = 0;
 	}
@@ -2573,6 +2654,9 @@ static void init_queue(struct call_queue
 	q->retry = DEFAULT_RETRY;
 	q->timeout = DEFAULT_TIMEOUT;
 	q->maxlen = 0;
+
+	ast_string_field_set(q, context, "");
+
 	q->announcefrequency = 0;
 	q->minannouncefrequency = DEFAULT_MIN_ANNOUNCE_FREQUENCY;
 	q->announceholdtime = 1;
@@ -2665,8 +2749,9 @@ static void clear_queue(struct call_queu
 		struct ao2_iterator mem_iter = ao2_iterator_init(q->members, 0);
 		while ((mem = ao2_iterator_next(&mem_iter))) {
 			mem->calls = 0;
+			mem->callcompletedinsl = 0;
 			mem->lastcall = 0;
-			mem->in_call = 0;
+			mem->starttime = 0;
 			ao2_ref(mem, -1);
 		}
 		ao2_iterator_destroy(&mem_iter);
@@ -2788,13 +2873,19 @@ static int load_realtime_rules(void)
 		ast_log(LOG_WARNING, "Failed to load queue rules from realtime\n");
 		return 0;
 	}
-	while ((rulecat = ast_category_browse(cfg, rulecat)) && !ast_strlen_zero(rulecat)) {
-		const char *timestr, *maxstr, *minstr;
+	while ((rulecat = ast_category_browse(cfg, rulecat))) {
+		const char *timestr, *maxstr, *minstr, *rule_name;
 		int penaltychangetime, rule_exists = 0, inserted = 0;
 		int max_penalty = 0, min_penalty = 0, min_relative = 0, max_relative = 0;
 		struct penalty_rule *new_penalty_rule = NULL;
+
+		rule_name = ast_variable_retrieve(cfg, rulecat, "rule_name");
+		if (ast_strlen_zero(rule_name)) {
+			continue;
+		}
+
 		AST_LIST_TRAVERSE(&rule_lists, rl_iter, list) {
-			if (!(strcasecmp(rl_iter->name, rulecat))) {
+			if (!(strcasecmp(rl_iter->name, rule_name))) {
 				rule_exists = 1;
 				new_rl = rl_iter;
 				break;
@@ -2805,13 +2896,13 @@ static int load_realtime_rules(void)
 				ast_config_destroy(cfg);
 				return -1;
 			}
-			ast_copy_string(new_rl->name, rulecat, sizeof(new_rl->name));
+			ast_copy_string(new_rl->name, rule_name, sizeof(new_rl->name));
 			AST_LIST_INSERT_TAIL(&rule_lists, new_rl, list);
 		}
 		timestr = ast_variable_retrieve(cfg, rulecat, "time");
 		if (!(timestr) || sscanf(timestr, "%30d", &penaltychangetime) != 1) {
 			ast_log(LOG_NOTICE, "Failed to parse time (%s) for one of the %s rules,	skipping it\n",
-				(ast_strlen_zero(timestr) ? "invalid value" : timestr), rulecat);
+				(ast_strlen_zero(timestr) ? "invalid value" : timestr), rule_name);
 			continue;
 		}
 		if (!(new_penalty_rule = ast_calloc(1, sizeof(*new_penalty_rule)))) {
@@ -3132,6 +3223,7 @@ static void member_add_to_queue(struct c
  */
 static void member_remove_from_queue(struct call_queue *queue, struct member *mem)
 {
+	pending_members_remove(mem);
 	ao2_lock(queue->members);
 	ast_devstate_changed(QUEUE_UNKNOWN_PAUSED_DEVSTATE, AST_DEVSTATE_CACHABLE, "Queue:%s_pause_%s", queue->name, mem->interface);
 	queue_member_follower_removal(queue, mem);
@@ -3145,7 +3237,7 @@ static void member_remove_from_queue(str
  * Search for member in queue, if found update penalty/paused state,
  * if no member exists create one flag it as a RT member and add to queue member list.
 */
-static void rt_handle_member_record(struct call_queue *q, char *interface, struct ast_config *member_config)
+static void rt_handle_member_record(struct call_queue *q, char *category, struct ast_config *member_config)
 {
 	struct member *m;
 	struct ao2_iterator mem_iter;
@@ -3155,11 +3247,12 @@ static void rt_handle_member_record(stru
 	int ringinuse = q->ringinuse;
 
 	const char *config_val;
-	const char *rt_uniqueid = ast_variable_retrieve(member_config, interface, "uniqueid");
-	const char *membername = S_OR(ast_variable_retrieve(member_config, interface, "membername"), interface);
-	const char *state_interface = S_OR(ast_variable_retrieve(member_config, interface, "state_interface"), interface);
-	const char *penalty_str = ast_variable_retrieve(member_config, interface, "penalty");
-	const char *paused_str = ast_variable_retrieve(member_config, interface, "paused");
+	const char *interface = ast_variable_retrieve(member_config, category, "interface");
+	const char *rt_uniqueid = ast_variable_retrieve(member_config, category, "uniqueid");
+	const char *membername = S_OR(ast_variable_retrieve(member_config, category, "membername"), interface);
+	const char *state_interface = S_OR(ast_variable_retrieve(member_config, category, "state_interface"), interface);
+	const char *penalty_str = ast_variable_retrieve(member_config, category, "penalty");
+	const char *paused_str = ast_variable_retrieve(member_config, category, "paused");
 
 	if (ast_strlen_zero(rt_uniqueid)) {
 		ast_log(LOG_WARNING, "Realtime field uniqueid is empty for member %s\n", S_OR(membername, "NULL"));
@@ -3182,7 +3275,7 @@ static void rt_handle_member_record(stru
 		}
 	}
 
-	if ((config_val = ast_variable_retrieve(member_config, interface, realtime_ringinuse_field))) {
+	if ((config_val = ast_variable_retrieve(member_config, category, realtime_ringinuse_field))) {
 		if (ast_true(config_val)) {
 			ringinuse = 1;
 		} else if (ast_false(config_val)) {
@@ -3298,7 +3391,7 @@ static struct call_queue *find_queue_by_
 	};
 	struct member *m;
 	struct ao2_iterator mem_iter;
-	char *interface = NULL;
+	char *category = NULL;
 	const char *tmp_name;
 	char *tmp;
 	char tmpbuf[64];	/* Must be longer than the longest queue param name. */
@@ -3399,8 +3492,8 @@ static struct call_queue *find_queue_by_
 	}
 	ao2_iterator_destroy(&mem_iter);
 
-	while ((interface = ast_category_browse(member_config, interface))) {
-		rt_handle_member_record(q, interface, member_config);
+	while ((category = ast_category_browse(member_config, category))) {
+		rt_handle_member_record(q, category, member_config);
 	}
 
 	/* Delete all realtime members that have been deleted in DB. */
@@ -3509,7 +3602,7 @@ static void update_realtime_members(stru
 {
 	struct ast_config *member_config = NULL;
 	struct member *m;
-	char *interface = NULL;
+	char *category = NULL;
 	struct ao2_iterator mem_iter;
 
 	if (!(member_config = ast_load_realtime_multientry("queue_members", "interface LIKE", "%", "queue_name", q->name , SENTINEL))) {
@@ -3542,8 +3635,8 @@ static void update_realtime_members(stru
 	}
 	ao2_iterator_destroy(&mem_iter);
 
-	while ((interface = ast_category_browse(member_config, interface))) {
-		rt_handle_member_record(q, interface, member_config);
+	while ((category = ast_category_browse(member_config, category))) {
+		rt_handle_member_record(q, category, member_config);
 	}
 
 	/* Delete all realtime members that have been deleted in DB. */
@@ -4003,6 +4096,17 @@ static void hangupcalls(struct queue_ent
 				ast_channel_hangupcause_set(outgoing->chan, AST_CAUSE_ANSWERED_ELSEWHERE);
 			}
 			ast_channel_publish_dial(qe->chan, outgoing->chan, outgoing->interface, "CANCEL");
+
+			/* When dialing channels it is possible that they may not ever
+			 * leave the not in use state (Local channels in particular) by
+			 * the time we cancel them. If this occurs but we know they were
+			 * dialed we explicitly remove them from the pending members
+			 * container so that subsequent call attempts occur.
+			 */
+			if (outgoing->member->status == AST_DEVICE_NOT_INUSE) {
+				pending_members_remove(outgoing->member);
+			}
+
 			ast_hangup(outgoing->chan);
 		}
 		oo = outgoing;
@@ -4092,6 +4196,7 @@ static void do_hang(struct callattempt *
 {
 	o->stillgoing = 0;
 	ast_hangup(o->chan);
+	pending_members_remove(o->member);
 	o->chan = NULL;
 }
 
@@ -4110,41 +4215,6 @@ static int member_status_available(int s
 
 /*!
  * \internal
- * \brief Clear the member call pending flag.
- *
- * \param mem Queue member.
- *
- * \return Nothing
- */
-static void member_call_pending_clear(struct member *mem)
-{
-	ao2_lock(mem);
-	mem->call_pending = 0;
-	ao2_unlock(mem);
-}
-
-/*!
- * \internal
- * \brief Set the member call pending flag.
- *
- * \param mem Queue member.
- *
- * \retval non-zero if call pending flag was already set.
- */
-static int member_call_pending_set(struct member *mem)
-{
-	int old_pending;
-
-	ao2_lock(mem);
-	old_pending = mem->call_pending;
-	mem->call_pending = 1;
-	ao2_unlock(mem);
-
-	return old_pending;
-}
-
-/*!
- * \internal
  * \brief Determine if can ring a queue entry.
  *
  * \param qe Queue entry to check.
@@ -4164,12 +4234,6 @@ static int can_ring_entry(struct queue_e
 		return 0;
 	}
 
-	if (call->member->in_call && call->lastqueue && call->lastqueue->wrapuptime) {
-		ast_debug(1, "%s is in call, so not available (wrapuptime %d)\n",
-			call->interface, call->lastqueue->wrapuptime);
-		return 0;
-	}
-
 	if ((call->lastqueue && call->lastqueue->wrapuptime && (time(NULL) - call->lastcall < call->lastqueue->wrapuptime))
 		|| (!call->lastqueue && qe->parent->wrapuptime && (time(NULL) - call->lastcall < qe->parent->wrapuptime))) {
 		ast_debug(1, "Wrapuptime not yet expired on queue %s for %s\n",
@@ -4185,13 +4249,33 @@ static int can_ring_entry(struct queue_e
 	}
 
 	if (!call->member->ringinuse) {
-		if (member_call_pending_set(call->member)) {
-			ast_debug(1, "%s has another call pending, can't receive call\n",
-				call->interface);
+		struct member *mem;
+
+		ao2_lock(pending_members);
+
+		mem = ao2_find(pending_members, call->member,
+				  OBJ_SEARCH_OBJECT | OBJ_NOLOCK);
+		if (mem) {
+			/*
+			 * If found that means this member is currently being attempted
+			 * from another calling thread, so stop trying from this thread
+			 */
+			ast_debug(1, "%s has another call trying, can't receive call\n",
+				  call->interface);
+			ao2_ref(mem, -1);
+			ao2_unlock(pending_members);
 			return 0;
 		}
 
 		/*
+		 * If not found add it to the container so another queue
+		 * won't attempt to call this member at the same time.
+		 */
+		ast_debug(3, "Add %s to pending_members\n", call->member->membername);
+		ao2_link(pending_members, call->member);
+		ao2_unlock(pending_members);
+
+		/*
 		 * The queue member is available.  Get current status to be sure
 		 * because the device state and extension state callbacks may
 		 * not have updated the status yet.
@@ -4199,7 +4283,7 @@ static int can_ring_entry(struct queue_e
 		if (!member_status_available(get_queue_member_status(call->member))) {
 			ast_debug(1, "%s actually not available, can't receive call\n",
 				call->interface);
-			member_call_pending_clear(call->member);
+			pending_members_remove(call->member);
 			return 0;
 		}
 	}
@@ -4236,7 +4320,6 @@ static int ring_entry(struct queue_ent *
 		++*busies;
 		return 0;
 	}
-	ast_assert(tmp->member->ringinuse || tmp->member->call_pending);
 
 	ast_copy_string(tech, tmp->interface, sizeof(tech));
 	if ((location = strchr(tech, '/'))) {
@@ -4253,7 +4336,7 @@ static int ring_entry(struct queue_ent *
 		qe->linpos++;
 		ao2_unlock(qe->parent);
 
-		member_call_pending_clear(tmp->member);
+		pending_members_remove(tmp->member);
 
 		publish_dial_end_event(qe->chan, tmp, NULL, "BUSY");
 		tmp->stillgoing = 0;
@@ -4324,7 +4407,6 @@ static int ring_entry(struct queue_ent *
 		/* Again, keep going even if there's an error */
 		ast_verb(3, "Couldn't call %s\n", tmp->interface);
 		do_hang(tmp);
-		member_call_pending_clear(tmp->member);
 		++*busies;
 		return 0;
 	}
@@ -4344,7 +4426,6 @@ static int ring_entry(struct queue_ent *
 
 	ast_verb(3, "Called %s\n", tmp->interface);
 
-	member_call_pending_clear(tmp->member);
 	return 1;
 }
 
@@ -4524,6 +4605,8 @@ static void record_abandoned(struct queu
 {
 	RAII_VAR(struct ast_json *, blob, NULL, ast_json_unref);
 
+	pbx_builtin_setvar_helper(qe->chan, "ABANDONED", "TRUE");
+
 	set_queue_variables(qe->parent, qe->chan);
 	ao2_lock(qe->parent);
 	blob = ast_json_pack("{s: s, s: i, s: i, s: i}",
@@ -4778,16 +4861,23 @@ static struct callattempt *wait_for_answ
 					continue;
 				} else if (!ast_strlen_zero(ast_channel_call_forward(o->chan))) {
 					struct ast_channel *original = o->chan;
+					char forwarder[AST_CHANNEL_NAME];
 					char tmpchan[256];
 					char *stuff;
 					char *tech;
+					int failed = 0;
 
 					ast_copy_string(tmpchan, ast_channel_call_forward(o->chan), sizeof(tmpchan));
+					ast_copy_string(forwarder, ast_channel_name(o->chan), sizeof(forwarder));
 					if ((stuff = strchr(tmpchan, '/'))) {
 						*stuff++ = '\0';
 						tech = tmpchan;
 					} else {
-						snprintf(tmpchan, sizeof(tmpchan), "%s@%s", ast_channel_call_forward(o->chan), ast_channel_context(o->chan));
+						const char *forward_context;
+						ast_channel_lock(o->chan);
+						forward_context = pbx_builtin_getvar_helper(o->chan, "FORWARD_CONTEXT");
+						snprintf(tmpchan, sizeof(tmpchan), "%s@%s", ast_channel_call_forward(o->chan), forward_context ? forward_context : ast_channel_context(o->chan));
+						ast_channel_unlock(o->chan);
 						stuff = tmpchan;
 						tech = "Local";
 					}
@@ -4819,6 +4909,7 @@ static struct callattempt *wait_for_answ
 						ast_channel_lock_both(o->chan, in);
 						ast_channel_inherit_variables(in, o->chan);
 						ast_channel_datastore_inherit(in, o->chan);
+						pbx_builtin_setvar_helper(o->chan, "FORWARDERNAME", forwarder);
 						ast_max_forwards_decrement(o->chan);
 
 						if (o->pending_connected_update) {
@@ -4887,14 +4978,20 @@ static struct callattempt *wait_for_answ
 						if (ast_call(o->chan, stuff, 0)) {
 							ast_log(LOG_NOTICE, "Forwarding failed to dial '%s/%s'\n",
 								tech, stuff);
-							do_hang(o);
-							numnochan++;
+							failed = 1;
 						}
 					}
 
-					ast_channel_publish_dial(qe->chan, o->chan, stuff, NULL);
 					ast_channel_publish_dial_forward(qe->chan, original, o->chan, NULL,
 						"CANCEL", ast_channel_call_forward(original));
+					if (o->chan) {
+						ast_channel_publish_dial(qe->chan, o->chan, stuff, NULL);
+					}
+
+					if (failed) {
+						do_hang(o);
+						numnochan++;
+					}
 
 					/* Hangup the original channel now, in case we needed it */
 					ast_hangup(winner);
@@ -5320,7 +5417,8 @@ static int wait_our_turn(struct queue_en
 			if ((status = get_member_status(qe->parent, qe->max_penalty, qe->min_penalty, qe->parent->leavewhenempty, 0))) {
 				*reason = QUEUE_LEAVEEMPTY;
 				ast_queue_log(qe->parent->name, ast_channel_uniqueid(qe->chan), "NONE", "EXITEMPTY", "%d|%d|%ld", qe->pos, qe->opos, (long) (time(NULL) - qe->start));
-				leave_queue(qe);
+				res = -1;
+				qe->handled = -1;
 				break;
 			}
 		}
@@ -5376,14 +5474,22 @@ static int wait_our_turn(struct queue_en
  * \brief update the queue status
  * \retval Always 0
 */
-static int update_queue(struct call_queue *q, struct member *member, int callcompletedinsl, int newtalktime)
+static int update_queue(struct call_queue *q, struct member *member, int callcompletedinsl, time_t starttime)
 {
 	int oldtalktime;
-
+	int newtalktime = time(NULL) - starttime;
 	struct member *mem;
 	struct call_queue *qtmp;
 	struct ao2_iterator queue_iter;
 
+	/* It is possible for us to be called when a call has already been considered terminated
+	 * and data updated, so to ensure we only act on the call that the agent is currently in
+	 * we check when the call was bridged.
+	 */
+	if (!starttime || (member->starttime != starttime)) {
+		return 0;
+	}
+
 	if (shared_lastcall) {
 		queue_iter = ao2_iterator_init(queues, 0);
 		while ((qtmp = ao2_t_iterator_next(&queue_iter, "Iterate through queues"))) {
@@ -5391,10 +5497,9 @@ static int update_queue(struct call_queu
 			if ((mem = ao2_find(qtmp->members, member, OBJ_POINTER))) {
 				time(&mem->lastcall);
 				mem->calls++;
+				mem->callcompletedinsl = 0;
+				mem->starttime = 0;
 				mem->lastqueue = q;
-				mem->in_call = 0;
-				ast_debug(4, "Marked member %s as NOT in_call. Lastcall time: %ld \n",
-					mem->membername, (long)mem->lastcall);
 				ao2_ref(mem, -1);
 			}
 			ao2_unlock(qtmp);
@@ -5404,13 +5509,19 @@ static int update_queue(struct call_queu
 	} else {
 		ao2_lock(q);
 		time(&member->lastcall);
+		member->callcompletedinsl = 0;
 		member->calls++;
+		member->starttime = 0;
 		member->lastqueue = q;
-		member->in_call = 0;
-		ast_debug(4, "Marked member %s as NOT in_call. Lastcall time: %ld \n",
-			member->membername, (long)member->lastcall);
 		ao2_unlock(q);
 	}
+	/* Member might never experience any direct status change (local
+	 * channel with forwarding in particular). If that's the case,
+	 * this is the last chance to remove it from pending or subsequent
+	 * calls will not occur.
+	 */
+	pending_members_remove(member);
+
 	ao2_lock(q);
 	q->callscompleted++;
 	if (callcompletedinsl) {
@@ -5535,12 +5646,12 @@ static void send_agent_complete(const ch
 	}
 
 	blob = ast_json_pack("{s: s, s: s, s: s, s: i, s: i, s: s}",
-			     "Queue", queuename,
-			     "Interface", member->interface,
-			     "MemberName", member->membername,
-			     "HoldTime", (long)(callstart - holdstart),
-			     "TalkTime", (long)(time(NULL) - callstart),
-			     "Reason", reason);
+		"Queue", queuename,
+		"Interface", member->interface,
+		"MemberName", member->membername,
+		"HoldTime", (long)(callstart - holdstart),
+		"TalkTime", (long)(time(NULL) - callstart),
+		"Reason", reason ?: "");
 
 	queue_publish_multi_channel_snapshot_blob(ast_queue_topic(queuename), caller, peer,
 			queue_agent_complete_type(), blob);
@@ -5785,6 +5896,7 @@ static void handle_bridge_enter(void *us
 {
 	struct queue_stasis_data *queue_data = userdata;
 	struct ast_bridge_blob *enter_blob = stasis_message_data(msg);
+	SCOPED_AO2LOCK(lock, queue_data);
 
 	if (queue_data->dying) {
 		return;
@@ -5823,16 +5935,17 @@ static void handle_blind_transfer(void *
 	RAII_VAR(struct ast_channel_snapshot *, caller_snapshot, NULL, ao2_cleanup);
 	RAII_VAR(struct ast_channel_snapshot *, member_snapshot, NULL, ao2_cleanup);
 
-	if (queue_data->dying) {
-		return;
-	}
-
 	if (transfer_msg->result != AST_BRIDGE_TRANSFER_SUCCESS) {
 		return;
 	}
 
 	ao2_lock(queue_data);
 
+	if (queue_data->dying) {
+		ao2_unlock(queue_data);
+		return;
+	}
+
 	if (ast_strlen_zero(queue_data->bridge_uniqueid) ||
 			strcmp(queue_data->bridge_uniqueid, transfer_msg->bridge->uniqueid)) {
 		ao2_unlock(queue_data);
@@ -5857,7 +5970,7 @@ static void handle_blind_transfer(void *
 	send_agent_complete(queue_data->queue->name, caller_snapshot, member_snapshot, queue_data->member,
 			queue_data->holdstart, queue_data->starttime, TRANSFER);
 	update_queue(queue_data->queue, queue_data->member, queue_data->callcompletedinsl,
-			time(NULL) - queue_data->starttime);
+			queue_data->starttime);
 	remove_stasis_subscriptions(queue_data);
 }
 
@@ -5880,10 +5993,6 @@ static void handle_attended_transfer(voi
 	RAII_VAR(struct ast_channel_snapshot *, caller_snapshot, NULL, ao2_cleanup);
 	RAII_VAR(struct ast_channel_snapshot *, member_snapshot, NULL, ao2_cleanup);
 
-	if (queue_data->dying) {
-		return;
-	}
-
 	if (atxfer_msg->result != AST_BRIDGE_TRANSFER_SUCCESS ||
 			atxfer_msg->dest_type == AST_ATTENDED_TRANSFER_DEST_THREEWAY) {
 		return;
@@ -5891,6 +6000,11 @@ static void handle_attended_transfer(voi
 
 	ao2_lock(queue_data);
 
+	if (queue_data->dying) {
+		ao2_unlock(queue_data);
+		return;
+	}
+
 	if (ast_strlen_zero(queue_data->bridge_uniqueid)) {
 		ao2_unlock(queue_data);
 		return;
@@ -5916,7 +6030,7 @@ static void handle_attended_transfer(voi
 	send_agent_complete(queue_data->queue->name, caller_snapshot, member_snapshot, queue_data->member,
 			queue_data->holdstart, queue_data->starttime, TRANSFER);
 	update_queue(queue_data->queue, queue_data->member, queue_data->callcompletedinsl,
-			time(NULL) - queue_data->starttime);
+			queue_data->starttime);
 	remove_stasis_subscriptions(queue_data);
 }
 
@@ -6074,12 +6188,13 @@ static void handle_hangup(void *userdata
 	RAII_VAR(struct ast_channel *, chan, NULL, ao2_cleanup);
 	enum agent_complete_reason reason;
 
+	ao2_lock(queue_data);
+
 	if (queue_data->dying) {
+		ao2_unlock(queue_data);
 		return;
 	}
 
-	ao2_lock(queue_data);
-
 	if (!strcmp(channel_blob->snapshot->uniqueid, queue_data->caller_uniqueid)) {
 		reason = CALLER;
 	} else if (!strcmp(channel_blob->snapshot->uniqueid, queue_data->member_uniqueid)) {
@@ -6108,7 +6223,7 @@ static void handle_hangup(void *userdata
 	ast_debug(3, "Detected hangup of queue %s channel %s\n", reason == CALLER ? "caller" : "member",
 			channel_blob->snapshot->name);
 
-	ast_queue_log(queue_data->queue->name, queue_data->caller_uniqueid, queue_data->member->membername,
+	ast_queue_log(queue_data->queue->name, caller_snapshot->uniqueid, queue_data->member->membername,
 			reason == CALLER ? "COMPLETECALLER" : "COMPLETEAGENT", "%ld|%ld|%d",
 		(long) (queue_data->starttime - queue_data->holdstart),
 		(long) (time(NULL) - queue_data->starttime), queue_data->caller_pos);
@@ -6116,7 +6231,7 @@ static void handle_hangup(void *userdata
 	send_agent_complete(queue_data->queue->name, caller_snapshot, member_snapshot, queue_data->member,
 			queue_data->holdstart, queue_data->starttime, reason);
 	update_queue(queue_data->queue, queue_data->member, queue_data->callcompletedinsl,
-			time(NULL) - queue_data->starttime);
+			queue_data->starttime);
 	remove_stasis_subscriptions(queue_data);
 }
 
@@ -6377,7 +6492,6 @@ static int try_calling(struct queue_ent
 	int x=0;
 	char *announce = NULL;
 	char digit = 0;
-	time_t callstart;
 	time_t now = time(NULL);
 	struct ast_bridge_config bridge_config;
 	char nondataquality = 1;
@@ -6388,12 +6502,10 @@ static int try_calling(struct queue_ent
 	char tmpid[256];
 	int forwardsallowed = 1;
 	int block_connected_line = 0;
-	int callcompletedinsl;
 	struct ao2_iterator memi;
 	struct queue_end_bridge *queue_end_bridge = NULL;
-	struct ao2_iterator queue_iter; /* to iterate through all queues (for shared_lastcall)*/
-	struct member *mem;
-	struct call_queue *queuetmp;
+	int callcompletedinsl;
+	time_t starttime;
 
 	memset(&bridge_config, 0, sizeof(bridge_config));
 	tmpid[0] = 0;
@@ -6582,10 +6694,10 @@ static int try_calling(struct queue_ent
 		/* Update parameters for the queue */
 		time(&now);
 		recalc_holdtime(qe, (now - qe->start));
+		member = lpeer->member;
 		ao2_lock(qe->parent);
-		callcompletedinsl = ((now - qe->start) <= qe->parent->servicelevel);
+		callcompletedinsl = member->callcompletedinsl = ((now - qe->start) <= qe->parent->servicelevel);
 		ao2_unlock(qe->parent);
-		member = lpeer->member;
 		/* Increment the refcount for this member, since we're going to be using it for awhile in here. */
 		ao2_ref(member, 1);
 		hangupcalls(qe, outgoing, peer, qe->cancel_answered_elsewhere);
@@ -6647,6 +6759,7 @@ static int try_calling(struct queue_ent
 				ast_log(LOG_NOTICE, "Caller was about to talk to agent on %s but the caller hungup.\n", ast_channel_name(peer));
 				ast_queue_log(queuename, ast_channel_uniqueid(qe->chan), member->membername, "ABANDON", "%d|%d|%ld", qe->pos, qe->opos, (long) (time(NULL) - qe->start));
 				record_abandoned(qe);
+				qe->handled = -1;
 				ast_channel_publish_dial(qe->chan, peer, member->interface, ast_hangup_cause_to_dial_status(ast_channel_hangupcause(peer)));
 				ast_autoservice_chan_hangup_peer(qe->chan, peer);
 				ao2_ref(member, -1);
@@ -6820,27 +6933,6 @@ static int try_calling(struct queue_ent
 		}
 		qe->handled++;
 
-		/** mark member as "in_call" in all queues */
-		if (shared_lastcall) {
-			queue_iter = ao2_iterator_init(queues, 0);
-			while ((queuetmp = ao2_t_iterator_next(&queue_iter, "Iterate through queues"))) {
-				ao2_lock(queuetmp);
-				if ((mem = ao2_find(queuetmp->members, member, OBJ_POINTER))) {
-					mem->in_call = 1;
-					ast_debug(4, "Marked member %s as in_call \n", mem->membername);
-					ao2_ref(mem, -1);
-				}
-				ao2_unlock(queuetmp);
-				queue_t_unref(queuetmp, "Done with iterator");
-			}
-			ao2_iterator_destroy(&queue_iter);
-		} else {
-			ao2_lock(qe->parent);
-			member->in_call = 1;
-			ast_debug(4, "Marked member %s as in_call \n", member->membername);
-			ao2_unlock(qe->parent);
-		}
-
 		ast_queue_log(queuename, ast_channel_uniqueid(qe->chan), member->membername, "CONNECT", "%ld|%s|%ld", (long) (time(NULL) - qe->start), ast_channel_uniqueid(peer),
 													(long)(orig - to > 0 ? (orig - to) / 1000 : 0));
 
@@ -6868,8 +6960,16 @@ static int try_calling(struct queue_ent
 			queue_t_ref(qe->parent, "For bridge_config reference");
 		}
 
-		time(&callstart);
-		setup_stasis_subs(qe, peer, member, qe->start, callstart, callcompletedinsl);
+		ao2_lock(qe->parent);
+		time(&member->starttime);
+		starttime = member->starttime;
+		ao2_unlock(qe->parent);
+		/* As a queue member may end up in multiple calls at once if a transfer occurs with
+		 * a Local channel in the mix we pass the current call information (starttime) to the
+		 * Stasis subscriptions so when they update the queue member data it becomes a noop
+		 * if this call is no longer between the caller and the queue member.
+		 */
+		setup_stasis_subs(qe, peer, member, qe->start, starttime, callcompletedinsl);
 		bridge = ast_bridge_call_with_flags(qe->chan, peer, &bridge_config,
 				AST_BRIDGE_FLAG_MERGE_INHIBIT_FROM | AST_BRIDGE_FLAG_MERGE_INHIBIT_TO | AST_BRIDGE_FLAG_SWAP_INHIBIT_FROM);
 
@@ -7118,12 +7218,10 @@ static void set_queue_member_pause(struc
 	}
 
 	mem->paused = paused;
-	if (paused) {
-		if (!ast_strlen_zero(reason)) {
-			ast_copy_string(mem->reason_paused, reason, sizeof(mem->reason_paused));
-		}
+	if (paused && !ast_strlen_zero(reason)) {
+		ast_copy_string(mem->reason_paused, reason, sizeof(mem->reason_paused));
 	} else {
-		ast_copy_string(mem->reason_paused, "", sizeof(mem->reason_paused));
+		mem->reason_paused[0] = '\0';
 	}
 
 	ast_devstate_changed(mem->paused ? QUEUE_PAUSED_DEVSTATE : QUEUE_UNPAUSED_DEVSTATE,
@@ -7311,12 +7409,11 @@ static int set_member_value(const char *
 
 	if (ast_strlen_zero(queuename)) { /* This means we need to iterate through all the queues. */
 		if (ast_check_realtime("queues")) {
-			char *name;
 			queue_config = ast_load_realtime_multientry("queues", "name LIKE", "%", SENTINEL);
 			if (queue_config) {
-				for (name = ast_category_browse(queue_config, NULL);
-					 !ast_strlen_zero(name);
-					 name = ast_category_browse(queue_config, name)) {
+				char *category = NULL;
+				while ((category = ast_category_browse(queue_config, category))) {
+					const char *name = ast_variable_retrieve(queue_config, category, "name");
 					if ((q = find_load_queue_rt_friendly(name))) {
 						foundqueue++;
 						foundinterface += set_member_value_help_members(q, interface, property, value);
@@ -7843,6 +7940,8 @@ static int queue_exec(struct ast_channel
 	/* Setup our queue entry */
 	qe.start = time(NULL);
 
+	pbx_builtin_setvar_helper(chan, "ABANDONED", NULL);
+
 	/* set the expire time based on the supplied timeout; */
 	if (!ast_strlen_zero(args.queuetimeoutstr)) {
 		qe.expire = qe.start + atoi(args.queuetimeoutstr);
@@ -8067,6 +8166,9 @@ stop:
 			} else if (qcontinue) {
 				reason = QUEUE_CONTINUE;
 				res = 0;
+			} else if (reason == QUEUE_LEAVEEMPTY) {
+				/* Return back to dialplan, don't hang up */
+				res = 0;
 			}
 		} else if (qe.valid_digits) {
 			ast_queue_log(args.queuename, ast_channel_uniqueid(chan), "NONE", "EXITWITHKEY",
@@ -8644,7 +8746,7 @@ static int reload_queue_rules(int reload
 		if (!(new_rl = ast_calloc(1, sizeof(*new_rl)))) {
 			AST_LIST_UNLOCK(&rule_lists);
 			ast_config_destroy(cfg);
-			return AST_MODULE_LOAD_FAILURE;
+			return AST_MODULE_LOAD_DECLINE;
 		} else {
 			ast_copy_string(new_rl->name, rulecat, sizeof(new_rl->name));
 			AST_LIST_INSERT_TAIL(&rule_lists, new_rl, list);
@@ -8941,33 +9043,22 @@ static void reload_single_queue(struct a
 	queue_t_unref(q, "Expiring creation reference");
 }
 
-static int remove_members_and_mark_unfound(void *obj, void *arg, int flags)
+static int mark_unfound(void *obj, void *arg, int flags)
 {
 	struct call_queue *q = obj;
 	char *queuename = arg;
 	if (!q->realtime && (ast_strlen_zero(queuename) || !strcasecmp(queuename, q->name))) {
 		q->found = 0;
-
 	}
 	return 0;
 }
 
-static int mark_dead_and_unfound(void *obj, void *arg, int flags)
+static int kill_if_unfound(void *obj, void *arg, int flags)
 {
 	struct call_queue *q = obj;
 	char *queuename = arg;
-	if (!q->realtime && (ast_strlen_zero(queuename) || !strcasecmp(queuename, q->name))) {
+	if (!q->realtime && !q->found && (ast_strlen_zero(queuename) || !strcasecmp(queuename, q->name))) {
 		q->dead = 1;
-		q->found = 0;
-	}
-	return 0;
-}
-
-static int kill_dead_queues(void *obj, void *arg, int flags)
-{
-	struct call_queue *q = obj;
-	char *queuename = arg;
-	if ((ast_strlen_zero(queuename) || !strcasecmp(queuename, q->name)) && q->dead) {
 		return CMP_MATCH;
 	} else {
 		return 0;
@@ -8992,7 +9083,6 @@ static int reload_queues(int reload, str
 	char *cat;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
 	const int queue_reload = ast_test_flag(mask, QUEUE_RELOAD_PARAMETERS);
-	const int member_reload = ast_test_flag(mask, QUEUE_RELOAD_MEMBER);
 
 	if (!(cfg = ast_config_load("queues.conf", config_flags))) {
 		ast_log(LOG_NOTICE, "No call queueing config file (queues.conf), so no call queues\n");
@@ -9007,18 +9097,10 @@ static int reload_queues(int reload, str
 	/* We've made it here, so it looks like we're doing operations on all queues. */
 	ao2_lock(queues);
 
-	/* Mark all queues as dead for the moment if we're reloading queues.
-	 * For clarity, we could just be reloading members, in which case we don't want to mess
-	 * with the other queue parameters at all*/
-	if (queue_reload) {
-		ao2_callback(queues, OBJ_NODATA | OBJ_NOLOCK, mark_dead_and_unfound, (char *) queuename);
-	}
-
-	if (member_reload) {
-		ao2_callback(queues, OBJ_NODATA, remove_members_and_mark_unfound, (char *) queuename);
-	}
+	/* Mark non-realtime queues not found at the beginning. */
+	ao2_callback(queues, OBJ_NODATA, mark_unfound, (char *) queuename);
 
-	/* Chug through config file */
+	/* Chug through config file. */
 	cat = NULL;
 	while ((cat = ast_category_browse(cfg, cat)) ) {
 		if (!strcasecmp(cat, "general") && queue_reload) {
@@ -9030,9 +9112,9 @@ static int reload_queues(int reload, str
 	}
 
 	ast_config_destroy(cfg);
-	/* Unref all the dead queues if we were reloading queues */
 	if (queue_reload) {
-		ao2_callback(queues, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK | OBJ_NOLOCK, kill_dead_queues, (char *) queuename);
+		/* Unlink and mark dead all non-realtime queues that were not found in the configuration file. */
+		ao2_callback(queues, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK | OBJ_NOLOCK, kill_if_unfound, (char *) queuename);
 	}
 	ao2_unlock(queues);
 	return 0;
@@ -9116,7 +9198,7 @@ static void do_print(struct mansession *
 static char *__queues_show(struct mansession *s, int fd, int argc, const char * const *argv)
 {
 	struct call_queue *q;
-	struct ast_str *out = ast_str_alloca(240);
+	struct ast_str *out = ast_str_alloca(512);
 	int found = 0;
 	time_t now = time(NULL);
 	struct ao2_iterator queue_iter;
@@ -9135,9 +9217,10 @@ static char *__queues_show(struct manses
 		 * which have not yet been added to the in-core container
 		 */
 		struct ast_config *cfg = ast_load_realtime_multientry("queues", "name LIKE", "%", SENTINEL);
-		char *queuename;
 		if (cfg) {
-			for (queuename = ast_category_browse(cfg, NULL); !ast_strlen_zero(queuename); queuename = ast_category_browse(cfg, queuename)) {
+			char *category = NULL;
+			while ((category = ast_category_browse(cfg, category))) {
+				const char *queuename = ast_variable_retrieve(cfg, category, "name");
 				if ((q = find_load_queue_rt_friendly(queuename))) {
 					queue_t_unref(q, "Done with temporary pointer");
 				}
@@ -9200,7 +9283,8 @@ static char *__queues_show(struct manses
 				ast_str_set(&out, 0, "      %s", mem->membername);
 				if (strcasecmp(mem->membername, mem->interface)) {
 					ast_str_append(&out, 0, " (%s", mem->interface);
-					if (!ast_strlen_zero(mem->state_interface)) {
+					if (!ast_strlen_zero(mem->state_interface)
+						&& strcmp(mem->state_interface, mem->interface)) {
 						ast_str_append(&out, 0, " from %s", mem->state_interface);
 					}
 					ast_str_append(&out, 0, ")");
@@ -9215,7 +9299,7 @@ static char *__queues_show(struct manses
 					mem->dynamic ? ast_term_color(COLOR_CYAN, COLOR_BLACK) : "", mem->dynamic ? " (dynamic)" : "", ast_term_reset(),
 					mem->realtime ? ast_term_color(COLOR_MAGENTA, COLOR_BLACK) : "", mem->realtime ? " (realtime)" : "", ast_term_reset(),
 					mem->paused ? ast_term_color(COLOR_BROWN, COLOR_BLACK) : "", mem->paused ? " (paused)" : "", ast_term_reset(),
-					mem->in_call ? ast_term_color(COLOR_BROWN, COLOR_BLACK) : "", mem->in_call ? " (in call)" : "", ast_term_reset(),
+					mem->starttime ? ast_term_color(COLOR_BROWN, COLOR_BLACK) : "", mem->starttime ? " (in call)" : "", ast_term_reset(),
 					ast_term_color(
 						mem->status == AST_DEVICE_UNAVAILABLE || mem->status == AST_DEVICE_UNKNOWN ?
 							COLOR_RED : COLOR_GREEN, COLOR_BLACK),
@@ -9472,7 +9556,7 @@ static int manager_queues_summary(struct
 		ao2_lock(q);
 
 		/* List queue properties */
-		if (ast_strlen_zero(queuefilter) || !strcmp(q->name, queuefilter)) {
+		if (ast_strlen_zero(queuefilter) || !strcasecmp(q->name, queuefilter)) {
 			/* Reset the necessary local variables if no queuefilter is set*/
 			qmemcount = 0;
 			qmemavail = 0;
@@ -9550,7 +9634,7 @@ static int manager_queues_status(struct
 		ao2_lock(q);
 
 		/* List queue properties */
-		if (ast_strlen_zero(queuefilter) || !strcmp(q->name, queuefilter)) {
+		if (ast_strlen_zero(queuefilter) || !strcasecmp(q->name, queuefilter)) {
 			sl = ((q->callscompleted > 0) ? 100 * ((float)q->callscompletedinsl / (float)q->callscompleted) : 0);
 			astman_append(s, "Event: QueueParams\r\n"
 				"Queue: %s\r\n"
@@ -9590,7 +9674,7 @@ static int manager_queues_status(struct
 						"%s"
 						"\r\n",
 						q->name, mem->membername, mem->interface, mem->state_interface, mem->dynamic ? "dynamic" : "static",
-						mem->penalty, mem->calls, (int)mem->lastcall, mem->in_call, mem->status,
+						mem->penalty, mem->calls, (int)mem->lastcall, mem->starttime ? 1 : 0, mem->status,
 						mem->paused, mem->reason_paused, idText);
 					++q_items;
 				}
@@ -10697,14 +10781,13 @@ static int queues_data_provider_get(cons
 	struct ao2_iterator i;
 	struct call_queue *queue, *queue_realtime = NULL;
 	struct ast_config *cfg;
-	char *queuename;
 
 	/* load realtime queues. */
 	cfg = ast_load_realtime_multientry("queues", "name LIKE", "%", SENTINEL);
 	if (cfg) {
-		for (queuename = ast_category_browse(cfg, NULL);
-				!ast_strlen_zero(queuename);
-				queuename = ast_category_browse(cfg, queuename)) {
+		char *category = NULL;
+		while ((category = ast_category_browse(cfg, category))) {
+			const char *queuename = ast_variable_retrieve(cfg, category, "name");
 			if ((queue = find_load_queue_rt_friendly(queuename))) {
 				queue_unref(queue);
 			}
@@ -10806,6 +10889,8 @@ static int unload_module(void)
 
 	ast_unload_realtime("queue_members");
 	ao2_cleanup(queues);
+	ao2_cleanup(pending_members);
+
 	queues = NULL;
 	return 0;
 }
@@ -10833,6 +10918,13 @@ static int load_module(void)
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
+	pending_members = ao2_container_alloc(
+		MAX_CALL_ATTEMPT_BUCKETS, pending_members_hash, pending_members_cmp);
+	if (!pending_members) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
 	use_weight = 0;
 
 	if (reload_handler(0, &mask, NULL)) {
diff -urpN asterisk-13.9.1/apps/app_record.c asterisk-13.17.0/apps/app_record.c
--- asterisk-13.9.1/apps/app_record.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_record.c	2017-07-12 13:12:08.000000000 +0200
@@ -81,6 +81,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<option name="t">
 						<para>use alternate '*' terminator key (DTMF) instead of default '#'</para>
 					</option>
+					<option name="u">
+						<para>Don't truncate recorded silence.</para>
+					</option>
 					<option name="x">
 						<para>Ignore all terminator keys (DTMF) and keep recording until hangup.</para>
 					</option>
@@ -133,6 +136,7 @@ enum {
 	FLAG_HAS_PERCENT = (1 << 7),
 	OPTION_ANY_TERMINATE = (1 << 8),
 	OPTION_OPERATOR_EXIT = (1 << 9),
+	OPTION_NO_TRUNCATE = (1 << 10),
 };
 
 AST_APP_OPTIONS(app_opts,{
@@ -143,6 +147,7 @@ AST_APP_OPTIONS(app_opts,{
 	AST_APP_OPTION('q', OPTION_QUIET),
 	AST_APP_OPTION('s', OPTION_SKIP),
 	AST_APP_OPTION('t', OPTION_STAR_TERMINATE),
+	AST_APP_OPTION('u', OPTION_NO_TRUNCATE),
 	AST_APP_OPTION('y', OPTION_ANY_TERMINATE),
 	AST_APP_OPTION('x', OPTION_IGNORE_TERMINATE),
 });
@@ -194,6 +199,7 @@ static int record_exec(struct ast_channe
 	int dspsilence = 0;
 	int silence = 0;		/* amount of silence to allow */
 	int gotsilence = 0;		/* did we timeout for silence? */
+	int truncate_silence = 1;	/* truncate on complete silence recording */
 	int maxduration = 0;		/* max duration of recording in milliseconds */
 	int gottimeout = 0;		/* did we timeout for maxduration exceeded? */
 	int terminator = '#';
@@ -245,7 +251,10 @@ static int record_exec(struct ast_channe
 			ast_log(LOG_WARNING, "'%s' is not a valid silence duration\n", args.silence);
 		}
 	}
-	
+
+	if (ast_test_flag(&flags, OPTION_NO_TRUNCATE))
+		truncate_silence = 0;
+
 	if (args.maxduration) {
 		if ((sscanf(args.maxduration, "%30d", &i) == 1) && (i > -1))
 			/* Convert duration to milliseconds */
@@ -445,7 +454,7 @@ static int record_exec(struct ast_channe
 		}
 	}
 
-	if (gotsilence) {
+	if (gotsilence && truncate_silence) {
 		ast_stream_rewind(s, silence - 1000);
 		ast_truncstream(s);
 	} else if (!gottimeout && f) {
diff -urpN asterisk-13.9.1/apps/app_userevent.c asterisk-13.17.0/apps/app_userevent.c
--- asterisk-13.9.1/apps/app_userevent.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_userevent.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,6 +62,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<replaceable>eventname</replaceable> under the
 			<literal>eventname</literal> key.</para>
 		</description>
+		<see-also>
+			<ref type="manager">UserEvent</ref>
+			<ref type="managerEvent">UserEvent</ref>
+		</see-also>
 	</application>
  ***/
 
diff -urpN asterisk-13.9.1/apps/app_voicemail.c asterisk-13.17.0/apps/app_voicemail.c
--- asterisk-13.9.1/apps/app_voicemail.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_voicemail.c	2017-07-12 13:12:08.000000000 +0200
@@ -507,6 +507,7 @@ static int imapversion = 1;
 
 static int expungeonhangup = 1;
 static int imapgreetings = 0;
+static int imap_poll_logout = 0;
 static char delimiter = '\0';
 
 /* mail_open cannot be protected on a stream basis */
@@ -544,6 +545,8 @@ static int imap_retrieve_file (const cha
 static int imap_delete_old_greeting (char *dir, struct vm_state *vms);
 static void check_quota(struct vm_state *vms, char *mailbox);
 static int open_mailbox(struct vm_state *vms, struct ast_vm_user *vmu, int box);
+static void imap_logout(const char *mailbox_id);
+
 struct vmstate {
 	struct vm_state *vms;
 	AST_LIST_ENTRY(vmstate) list;
@@ -805,6 +808,7 @@ struct ast_vm_user {
 	char *emailbody;                 /*!< E-mail body */
 	char pager[80];                  /*!< E-mail address to pager (no attachment) */
 	char serveremail[80];            /*!< From: Mail address */
+	char fromstring[100];            /*!< From: Username */
 	char language[MAX_LANGUAGE];     /*!< Config: Language setting */
 	char zonetag[80];                /*!< Time zone */
 	char locale[20];                 /*!< The locale (for presentation of date/time) */
@@ -813,7 +817,7 @@ struct ast_vm_user {
 	char uniqueid[80];               /*!< Unique integer identifier */
 	char exit[80];
 	char attachfmt[20];              /*!< Attachment format */
-	unsigned int flags;              /*!< VM_ flags */	
+	unsigned int flags;              /*!< VM_ flags */
 	int saydurationm;
 	int minsecs;                     /*!< Minimum number of seconds per message for this mailbox */
 	int maxmsg;                      /*!< Maximum number of msgs per folder for this mailbox */
@@ -1036,6 +1040,8 @@ static char listen_control_restart_key[1
 static char listen_control_stop_key[12];
 
 /* custom password sounds */
+static char vm_login[80] = "vm-login";
+static char vm_newuser[80] = "vm-newuser";
 static char vm_password[80] = "vm-password";
 static char vm_newpassword[80] = "vm-newpassword";
 static char vm_passchanged[80] = "vm-passchanged";
@@ -1088,7 +1094,7 @@ static int advanced_options(struct ast_c
 static int dialout(struct ast_channel *chan, struct ast_vm_user *vmu, char *num, char *outgoing_context);
 static int play_record_review(struct ast_channel *chan, char *playfile, char *recordfile, int maxtime,
 			char *fmt, int outsidecaller, struct ast_vm_user *vmu, int *duration, int *sound_duration, const char *unlockdir,
-			signed char record_gain, struct vm_state *vms, char *flag, const char *msg_id);
+			signed char record_gain, struct vm_state *vms, char *flag, const char *msg_id, int forwardintro);
 static int vm_tempgreeting(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms, char *fmtc, signed char record_gain);
 static int vm_play_folder_name(struct ast_channel *chan, char *mbox);
 static int notify_new_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms, int msgnum, long duration, char *fmt, char *cidnum, char *cidname, const char *flag);
@@ -1308,6 +1314,8 @@ static void apply_option(struct ast_vm_u
 		ast_copy_string(vmu->attachfmt, value, sizeof(vmu->attachfmt));
 	} else if (!strcasecmp(var, "serveremail")) {
 		ast_copy_string(vmu->serveremail, value, sizeof(vmu->serveremail));
+	} else if (!strcasecmp(var, "fromstring")) {
+		ast_copy_string(vmu->fromstring, value, sizeof(vmu->fromstring));
 	} else if (!strcasecmp(var, "emailbody")) {
 		ast_free(vmu->emailbody);
 		vmu->emailbody = ast_strdup(substitute_escapes(value));
@@ -1725,13 +1733,14 @@ static struct ast_vm_user *find_user(str
 	}
 	if (cur) {
 		/* Make a copy, so that on a reload, we have no race */
-		if ((vmu = (ivm ? ivm : ast_malloc(sizeof(*vmu))))) {
+		if ((vmu = (ivm ? ivm : ast_calloc(1, sizeof(*vmu))))) {
+			ast_free(vmu->email);
+			ast_free(vmu->emailbody);
+			ast_free(vmu->emailsubject);
 			*vmu = *cur;
-			if (!ivm) {
-				vmu->email = ast_strdup(cur->email);
-				vmu->emailbody = ast_strdup(cur->emailbody);
-				vmu->emailsubject = ast_strdup(cur->emailsubject);
-			}
+			vmu->email = ast_strdup(cur->email);
+			vmu->emailbody = ast_strdup(cur->emailbody);
+			vmu->emailsubject = ast_strdup(cur->emailsubject);
 			ast_set2_flag(vmu, !ivm, VM_ALLOCED);
 			AST_LIST_NEXT(vmu, list) = NULL;
 		}
@@ -2009,17 +2018,18 @@ static int get_folder_by_name(const char
 
 static void free_user(struct ast_vm_user *vmu)
 {
-	if (ast_test_flag(vmu, VM_ALLOCED)) {
-
-		ast_free(vmu->email);
-		vmu->email = NULL;
-
-		ast_free(vmu->emailbody);
-		vmu->emailbody = NULL;
+	if (!vmu) {
+		return;
+	}
 
-		ast_free(vmu->emailsubject);
-		vmu->emailsubject = NULL;
+	ast_free(vmu->email);
+	vmu->email = NULL;
+	ast_free(vmu->emailbody);
+	vmu->emailbody = NULL;
+	ast_free(vmu->emailsubject);
+	vmu->emailsubject = NULL;
 
+	if (ast_test_flag(vmu, VM_ALLOCED)) {
 		ast_free(vmu);
 	}
 }
@@ -2172,6 +2182,7 @@ static int imap_retrieve_greeting(const
 {
 	struct vm_state *vms_p;
 	char *file, *filename;
+	char dest[PATH_MAX];
 	char *attachment;
 	int i;
 	BODY *body;
@@ -2235,6 +2246,7 @@ static int imap_retrieve_greeting(const
 		if (!strcmp(filename, file)) {
 			ast_copy_string(vms_p->fn, dir, sizeof(vms_p->fn));
 			vms_p->msgArray[vms_p->curmsg] = i + 1;
+			create_dirpath(dest, sizeof(dest), vmu->context, vms_p->username, "");
 			save_body(body, vms_p, "2", attachment, 0);
 			ret = 0;
 			break;
@@ -2367,7 +2379,8 @@ static int imap_retrieve_file(const char
 	snprintf(text_file, sizeof(text_file), "%s.%s", vms->fn, "txt");
 
 	if (!(text_file_ptr = fopen(text_file, "w"))) {
-		ast_log(LOG_WARNING, "Unable to open/create file %s: %s\n", text_file, strerror(errno));
+		ast_log(LOG_ERROR, "Unable to open/create file %s: %s\n", text_file, strerror(errno));
+		goto exit;
 	}
 
 	fprintf(text_file_ptr, "%s\n", "[message]");
@@ -2457,14 +2470,17 @@ static int __messagecount(const char *co
 		return 0;
 
 	/* We have to get the user before we can open the stream! */
+	memset(&vmus, 0, sizeof(vmus));
 	vmu = find_user(&vmus, context, mailbox);
 	if (!vmu) {
 		ast_log(AST_LOG_WARNING, "Couldn't find mailbox %s in context %s\n", mailbox, context);
+		free_user(vmu);
 		return -1;
 	} else {
 		/* No IMAP account available */
 		if (vmu->imapuser[0] == '\0') {
 			ast_log(AST_LOG_WARNING, "IMAP user not set for mailbox %s\n", vmu->mailbox);
+			free_user(vmu);
 			return -1;
 		}
 	}
@@ -2484,9 +2500,11 @@ static int __messagecount(const char *co
 	if (vms_p) {
 		ast_debug(3, "Returning before search - user is logged in\n");
 		if (fold == 0) { /* INBOX */
+			free_user(vmu);
 			return urgent ? vms_p->urgentmessages : vms_p->newmessages;
 		}
 		if (fold == 1) { /* Old messages */
+			free_user(vmu);
 			return vms_p->oldmessages;
 		}
 	}
@@ -2503,6 +2521,7 @@ static int __messagecount(const char *co
 	ret = init_mailstream(vms_p, fold);
 	if (!vms_p->mailstream) {
 		ast_log(AST_LOG_ERROR, "Houston we have a problem - IMAP mailstream is NULL\n");
+		free_user(vmu);
 		return -1;
 	}
 	if (ret == 0) {
@@ -2546,6 +2565,7 @@ static int __messagecount(const char *co
 		/*Freeing the searchpgm also frees the searchhdr*/
 		mail_free_searchpgm(&pgm);
 		ast_mutex_unlock(&vms_p->lock);
+		free_user(vmu);
 		vms_p->updated = 0;
 		return vms_p->vmArrayIndex;
 	} else {
@@ -2553,6 +2573,7 @@ static int __messagecount(const char *co
 		mail_ping(vms_p->mailstream);
 		ast_mutex_unlock(&vms_p->lock);
 	}
+	free_user(vmu);
 	return 0;
 }
 
@@ -2699,8 +2720,8 @@ static int imap_store_file(const char *d
 	}
 
 	make_email_file(p, myserveremail, vmu, msgnum, vmu->context, vmu->mailbox, "INBOX",
-		S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL),
-		S_COR(ast_channel_caller(chan)->id.name.valid, ast_channel_caller(chan)->id.name.str, NULL),
+		chan ? S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL) : NULL,
+		chan ? S_COR(ast_channel_caller(chan)->id.name.valid, ast_channel_caller(chan)->id.name.str, NULL) : NULL,
 		fn, introfn, fmt, duration, 1, chan, NULL, 1, flag, msg_id);
 	/* read mail file to memory */
 	len = ftell(p);
@@ -2712,9 +2733,9 @@ static int imap_store_file(const char *d
 			*(vmu->email) = '\0';
 		return -1;
 	}
-	if (fread(buf, len, 1, p) < len) {
+	if (fread(buf, 1, len, p) != len) {
 		if (ferror(p)) {
-			ast_log(LOG_ERROR, "Short read while reading in mail file.\n");
+			ast_log(LOG_ERROR, "Error while reading mail file: %s\n", tmp);
 			return -1;
 		}
 	}
@@ -3008,6 +3029,10 @@ static int init_mailstream(struct vm_sta
 	ast_mutex_lock(&vms->lock);
 	ast_mutex_lock(&mail_open_lock);
 	vms->mailstream = mail_open (stream, tmp, debug ? OP_DEBUG : NIL);
+	/* Create the folder if it dosn't exist */
+	if (vms->mailstream && !mail_status(vms->mailstream, tmp, SA_UIDNEXT)) {
+		mail_create(vms->mailstream, tmp);
+	}
 	ast_mutex_unlock(&mail_open_lock);
 	ast_mutex_unlock(&vms->lock);
 	if (vms->mailstream == NIL) {
@@ -3102,7 +3127,15 @@ static void write_file(char *filename, c
 {
 	FILE *output;
 
-	output = fopen (filename, "w");
+	if (!filename || !buffer) {
+		return;
+	}
+
+	if (!(output = fopen(filename, "w"))) {
+		ast_log(LOG_ERROR, "Unable to open/create file %s: %s\n", filename, strerror(errno));
+		return;
+	}
+
 	if (fwrite(buffer, len, 1, output) != 1) {
 		if (ferror(output)) {
 			ast_log(LOG_ERROR, "Short write while writing e-mail body: %s.\n", strerror(errno));
@@ -3237,18 +3270,31 @@ void mm_lsub(MAILSTREAM * stream, int de
 
 void mm_status(MAILSTREAM * stream, char *mailbox, MAILSTATUS * status)
 {
-	ast_log(AST_LOG_NOTICE, " Mailbox %s", mailbox);
-	if (status->flags & SA_MESSAGES)
-		ast_log(AST_LOG_NOTICE, ", %lu messages", status->messages);
-	if (status->flags & SA_RECENT)
-		ast_log(AST_LOG_NOTICE, ", %lu recent", status->recent);
-	if (status->flags & SA_UNSEEN)
-		ast_log(AST_LOG_NOTICE, ", %lu unseen", status->unseen);
-	if (status->flags & SA_UIDVALIDITY)
-		ast_log(AST_LOG_NOTICE, ", %lu UID validity", status->uidvalidity);
-	if (status->flags & SA_UIDNEXT)
-		ast_log(AST_LOG_NOTICE, ", %lu next UID", status->uidnext);
-	ast_log(AST_LOG_NOTICE, "\n");
+	struct ast_str *str;
+
+	if (!DEBUG_ATLEAST(5) || !(str = ast_str_create(256))) {
+	    return;
+	}
+
+	ast_str_append(&str, 0, " Mailbox %s", mailbox);
+	if (status->flags & SA_MESSAGES) {
+		ast_str_append(&str, 0, ", %lu messages", status->messages);
+	}
+	if (status->flags & SA_RECENT) {
+		ast_str_append(&str, 0, ", %lu recent", status->recent);
+	}
+	if (status->flags & SA_UNSEEN) {
+		ast_str_append(&str, 0, ", %lu unseen", status->unseen);
+	}
+	if (status->flags & SA_UIDVALIDITY) {
+		ast_str_append(&str, 0, ", %lu UID validity", status->uidvalidity);
+	}
+	if (status->flags & SA_UIDNEXT) {
+		ast_str_append(&str, 0, ", %lu next UID", status->uidnext);
+	}
+	ast_log(LOG_DEBUG, "%s\n", ast_str_buffer(str));
+
+	ast_free(str);
 }
 
 
@@ -3436,8 +3482,9 @@ static struct vm_state *get_vm_state_by_
 	if (interactive) {
 		struct vm_state *vms;
 		pthread_once(&ts_vmstate.once, ts_vmstate.key_init);
-		vms = pthread_getspecific(ts_vmstate.key);
-		return vms;
+		if ((vms = pthread_getspecific(ts_vmstate.key)) && vms->imapuser && !strcmp(vms->imapuser, user)) {
+			return vms;
+		}
 	}
 
 	AST_LIST_LOCK(&vmstates);
@@ -3475,8 +3522,10 @@ static struct vm_state *get_vm_state_by_
 	if (interactive) {
 		struct vm_state *vms;
 		pthread_once(&ts_vmstate.once, ts_vmstate.key_init);
-		vms = pthread_getspecific(ts_vmstate.key);
-		return vms;
+		if ((vms = pthread_getspecific(ts_vmstate.key)) && vms->username && vms->context &&
+		    !strcmp(vms->username,mailbox) && !strcmp(vms->context, local_context)) {
+			return vms;
+		}
 	}
 
 	AST_LIST_LOCK(&vmstates);
@@ -4699,12 +4748,12 @@ static int inbuf(struct baseio *bio, FIL
 	if (bio->ateof)
 		return 0;
 
-	if ((l = fread(bio->iobuf, 1, BASEMAXINLINE, fi)) <= 0) {
-		if (ferror(fi))
-			return -1;
-
+	if ((l = fread(bio->iobuf, 1, BASEMAXINLINE, fi)) != BASEMAXINLINE) {
 		bio->ateof = 1;
-		return 0;
+		if (l == 0) {
+			/* Assume EOF */
+			return 0;
+		}
 	}
 
 	bio->iolen = l;
@@ -5073,12 +5122,13 @@ static void make_email_file(FILE *p,
 	/* Set date format for voicemail mail */
 	ast_strftime_locale(date, sizeof(date), emaildateformat, &tm, S_OR(vmu->locale, NULL));
 
-	if (!ast_strlen_zero(fromstring)) {
+	if (!ast_strlen_zero(fromstring) || !ast_strlen_zero(vmu->fromstring)) {
 		struct ast_channel *ast;
+		char *e_fromstring = !ast_strlen_zero(vmu->fromstring) ? vmu->fromstring : fromstring;
 		if ((ast = ast_dummy_channel_alloc())) {
 			char *ptr;
 			prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, fromfolder, enc_cidnum, enc_cidname, dur, date, category, flag);
-			ast_str_substitute_variables(&str1, 0, ast, fromstring);
+			ast_str_substitute_variables(&str1, 0, ast, e_fromstring);
 
 			if (check_mime(ast_str_buffer(str1))) {
 				first_line = 1;
@@ -5123,7 +5173,9 @@ static void make_email_file(FILE *p,
 		first_line = 0;
 	}
 
-	if (!ast_strlen_zero(emailsubject) || !ast_strlen_zero(vmu->emailsubject)) {
+	if (msgnum <= -1) {
+		fprintf(p, "Subject: New greeting '%s' on %s." ENDL, greeting_attachment, date);
+	} else if (!ast_strlen_zero(emailsubject) || !ast_strlen_zero(vmu->emailsubject)) {
 		char *e_subj = !ast_strlen_zero(vmu->emailsubject) ? vmu->emailsubject : emailsubject;
 		struct ast_channel *ast;
 		if ((ast = ast_dummy_channel_alloc())) {
@@ -5176,9 +5228,8 @@ static void make_email_file(FILE *p,
 		fprintf(p, "X-Asterisk-VM-Extension: %s" ENDL, mailbox);
 #endif
 		/* flag added for Urgent */
-		fprintf(p, "X-Asterisk-VM-Flag: %s" ENDL, flag);
+		fprintf(p, "X-Asterisk-VM-Flag: %s" ENDL, S_OR(flag, ""));
 		fprintf(p, "X-Asterisk-VM-Priority: %d" ENDL, chan ? ast_channel_priority(chan) : 0);
-		fprintf(p, "X-Asterisk-VM-Caller-channel: %s" ENDL, chan ? ast_channel_name(chan) : "");
 		fprintf(p, "X-Asterisk-VM-Caller-ID-Num: %s" ENDL, enc_cidnum);
 		fprintf(p, "X-Asterisk-VM-Caller-ID-Name: %s" ENDL, enc_cidname);
 		fprintf(p, "X-Asterisk-VM-Duration: %d" ENDL, duration);
@@ -5209,7 +5260,11 @@ static void make_email_file(FILE *p,
 		fprintf(p, "--%s" ENDL, bound);
 	}
 	fprintf(p, "Content-Type: text/plain; charset=%s" ENDL "Content-Transfer-Encoding: 8bit" ENDL ENDL, charset);
-	if (emailbody || vmu->emailbody) {
+	if (msgnum <= -1) {
+		fprintf(p, "This message is to let you know that your greeting '%s' was changed on %s." ENDL
+				"Please do not delete this message, lest your greeting vanish with it." ENDL ENDL,
+				greeting_attachment, date);
+	} else if (emailbody || vmu->emailbody) {
 		char* e_body = vmu->emailbody ? vmu->emailbody : emailbody;
 		struct ast_channel *ast;
 		if ((ast = ast_dummy_channel_alloc())) {
@@ -5235,7 +5290,7 @@ static void make_email_file(FILE *p,
 		} else {
 			ast_log(AST_LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
 		}
-	} else if (msgnum > -1) {
+	} else {
 		if (strcmp(vmu->mailbox, mailbox)) {
 			/* Forwarded type */
 			struct ast_config *msg_cfg;
@@ -5280,9 +5335,6 @@ plain_message:
 				ENDL ENDL, vmu->fullname, dur, msgnum + 1, mailbox,
 				(cidname ? cidname : (cidnum ? cidnum : "an unknown caller")), date);
 		}
-	} else {
-		fprintf(p, "This message is to let you know that your greeting was changed on %s." ENDL
-				"Please do not delete this message, lest your greeting vanish with it." ENDL ENDL, date);
 	}
 
 	if (imap || attach_user_voicemail) {
@@ -6185,6 +6237,7 @@ static int msg_create_from_file(struct a
 		return -1;
 	}
 
+	memset(&svm, 0, sizeof(svm));
 	if (!(recipient = find_user(&svm, recdata->context, recdata->mailbox))) {
 		ast_log(LOG_ERROR, "No entry in voicemail config file for '%s@%s'\n", recdata->mailbox, recdata->context);
 		return -1;
@@ -6500,6 +6553,7 @@ static int leave_voicemail(struct ast_ch
 	}
 
 	ast_debug(3, "Before find_user\n");
+	memset(&svm, 0, sizeof(svm));
 	if (!(vmu = find_user(&svm, context, ext))) {
 		ast_log(AST_LOG_WARNING, "No entry in voicemail config file for '%s'\n", ext);
 		pbx_builtin_setvar_helper(chan, "VMSTATUS", "FAILED");
@@ -6529,6 +6583,7 @@ static int leave_voicemail(struct ast_ch
 	snprintf(tempfile, sizeof(tempfile), "%s%s/%s/temp", VM_SPOOL_DIR, vmu->context, ext);
 	if ((res = create_dirpath(tmpdir, sizeof(tmpdir), vmu->context, ext, "tmp"))) {
 		ast_log(AST_LOG_WARNING, "Failed to make directory (%s)\n", tempfile);
+		free_user(vmu);
 		ast_free(tmp);
 		return -1;
 	}
@@ -6672,9 +6727,9 @@ static int leave_voicemail(struct ast_ch
 			}
 			ast_play_and_wait(chan, "transfer");
 			ast_channel_priority_set(chan, 0);
-			free_user(vmu);
 			pbx_builtin_setvar_helper(chan, "VMSTATUS", "USEREXIT");
 		}
+		free_user(vmu);
 		ast_free(tmp);
 		return OPERATOR_EXIT;
 	}
@@ -6708,6 +6763,7 @@ static int leave_voicemail(struct ast_ch
 		res = inboxcount(ext_context, &newmsgs, &oldmsgs);
 		if (res < 0) {
 			ast_log(AST_LOG_NOTICE, "Can not leave voicemail, unable to count messages\n");
+			free_user(vmu);
 			ast_free(tmp);
 			return -1;
 		}
@@ -6718,6 +6774,7 @@ static int leave_voicemail(struct ast_ch
 		 */
 			if (!(vms = create_vm_state_from_user(vmu))) {
 				ast_log(AST_LOG_ERROR, "Couldn't allocate necessary space\n");
+				free_user(vmu);
 				ast_free(tmp);
 				return -1;
 			}
@@ -6836,7 +6893,7 @@ static int leave_voicemail(struct ast_ch
 			res = ast_streamfile(chan, "vm-mailboxfull", ast_channel_language(chan));
 			goto leave_vm_out;
 		}
-		res = play_record_review(chan, NULL, tmptxtfile, vmu->maxsecs, fmt, 1, vmu, &duration, &sound_duration, NULL, options->record_gain, vms, flag, msg_id);
+		res = play_record_review(chan, NULL, tmptxtfile, vmu->maxsecs, fmt, 1, vmu, &duration, &sound_duration, NULL, options->record_gain, vms, flag, msg_id, 0);
 
 		if (txt) {
 			fprintf(txt, "flag=%s\n", flag);
@@ -6912,6 +6969,7 @@ static int leave_voicemail(struct ast_ch
 							*cntx = '\0';
 							cntx++;
 						}
+						memset(&recipu, 0, sizeof(recipu));
 						if ((recip = find_user(&recipu, cntx, exten))) {
 							copy_message(chan, vmu, 0, msgnum, duration, recip, fmt, dir, flag, NULL);
 							free_user(recip);
@@ -7039,6 +7097,7 @@ static int save_to_folder(struct ast_vm_
 	char sequence[10];
 	char mailbox[256];
 	int res;
+	int curr_mbox;
 
 	/* get the real IMAP message number for this message */
 	snprintf(sequence, sizeof(sequence), "%ld", vms->msgArray[msg]);
@@ -7048,26 +7107,35 @@ static int save_to_folder(struct ast_vm_
 	/* if save to Old folder, put in INBOX as read */
 	if (box == OLD_FOLDER) {
 		mail_setflag(vms->mailstream, sequence, "\\Seen");
-		mail_clearflag(vms->mailstream, sequence, "\\Unseen");
 	} else if (box == NEW_FOLDER) {
-		mail_setflag(vms->mailstream, sequence, "\\Unseen");
 		mail_clearflag(vms->mailstream, sequence, "\\Seen");
 	}
 	if (!strcasecmp(mbox(vmu, NEW_FOLDER), vms->curbox) && (box == NEW_FOLDER || box == OLD_FOLDER)) {
 		ast_mutex_unlock(&vms->lock);
 		return 0;
 	}
-	/* Create the folder if it don't exist */
+
+	/* get the current mailbox so that we can point the mailstream back to it later */
+	curr_mbox = get_folder_by_name(vms->curbox);
+
+	/* Create the folder if it dosn't exist */
 	imap_mailbox_name(mailbox, sizeof(mailbox), vms, box, 1); /* Get the full mailbox name */
-	ast_debug(5, "Checking if folder exists: %s\n", mailbox);
-	if (mail_create(vms->mailstream, mailbox) == NIL)
-		ast_debug(5, "Folder exists.\n");
-	else
-		ast_log(AST_LOG_NOTICE, "Folder %s created!\n", mbox(vmu, box));
-	if (move) {
-		res = !mail_move(vms->mailstream, sequence, (char *) mbox(vmu, box));
+	if (vms->mailstream && !mail_status(vms->mailstream, mailbox, SA_UIDNEXT)) {
+    		if (mail_create(vms->mailstream, mailbox) != NIL) {
+			ast_log(AST_LOG_NOTICE, "Folder %s created!\n", mbox(vmu, box));
+		}
+	}
+
+	/* restore previous mbox stream */
+	if (init_mailstream(vms, curr_mbox) || !vms->mailstream) {
+		ast_log(AST_LOG_ERROR, "IMAP mailstream is NULL or can't init_mailstream\n");
+		res = -1;
 	} else {
-		res = !mail_copy(vms->mailstream, sequence, (char *) mbox(vmu, box));
+		if (move) {
+			res = !mail_move(vms->mailstream, sequence, (char *) mbox(vmu, box));
+		} else {
+			res = !mail_copy(vms->mailstream, sequence, (char *) mbox(vmu, box));
+		}
 	}
 	ast_mutex_unlock(&vms->lock);
 	return res;
@@ -7798,9 +7866,9 @@ static int vm_forwardoptions(struct ast_
 			}
 			make_file(vms->introfn, sizeof(vms->introfn), curdir, curmsg);
 			strncat(vms->introfn, "intro", sizeof(vms->introfn));
-			ast_play_and_wait(chan, INTRO);
+			ast_play_and_wait(chan, "vm-record-prepend");
 			ast_play_and_wait(chan, "beep");
-			cmd = play_record_review(chan, NULL, vms->introfn, vmu->maxsecs, vm_fmts, 1, vmu, (int *) duration, NULL, NULL, record_gain, vms, flag, msg_id);
+			cmd = play_record_review(chan, NULL, vms->introfn, vmu->maxsecs, vm_fmts, 1, vmu, (int *) duration, NULL, NULL, record_gain, vms, flag, msg_id, 1);
 			if (cmd == -1) {
 				break;
 			}
@@ -8069,6 +8137,7 @@ static int forward_message(struct ast_ch
 	AST_LIST_HEAD_NOLOCK_STATIC(extensions, ast_vm_user);
 	char *stringp;
 	const char *s;
+	const char mailbox_context[256];
 	int saved_messages = 0;
 	int valid_extensions = 0;
 	char *dir;
@@ -8177,20 +8246,44 @@ static int forward_message(struct ast_ch
 		/* start optimistic */
 		valid_extensions = 1;
 		while (s) {
+			snprintf((char*)mailbox_context, sizeof(mailbox_context), "%s@%s", s, context ? context : "default");
 			if ((is_new_message == 1 || strcmp(s, sender->mailbox)) && (receiver = find_user(NULL, context, s))) {
 				int oldmsgs;
 				int newmsgs;
 				int capacity;
-				if (inboxcount(s, &newmsgs, &oldmsgs)) {
-					ast_log(LOG_ERROR, "Problem in calculating number of voicemail messages available for extension %s\n", s);
+
+				if (inboxcount(mailbox_context, &newmsgs, &oldmsgs)) {
+					ast_log(LOG_ERROR, "Problem in calculating number of voicemail messages available for extension %s\n", mailbox_context);
 					/* Shouldn't happen, but allow trying another extension if it does */
 					res = ast_play_and_wait(chan, "pbx-invalid");
 					valid_extensions = 0;
 					break;
 				}
+#ifdef IMAP_STORAGE
+				if (!(dstvms = get_vm_state_by_mailbox(s, context, 0))) {
+					if (!(dstvms = create_vm_state_from_user(receiver))) {
+						ast_log(AST_LOG_ERROR, "Couldn't allocate necessary space\n");
+						/* Shouldn't happen, but allow trying another extension if it does */
+						res = ast_play_and_wait(chan, "pbx-invalid");
+						valid_extensions = 0;
+						break;
+					}
+				}
+				check_quota(dstvms, imapfolder);
+				if (dstvms->quota_limit && dstvms->quota_usage >= dstvms->quota_limit) {
+					ast_log(LOG_NOTICE, "Mailbox '%s' is exceeded quota %u >= %u\n", mailbox_context, dstvms->quota_usage, dstvms->quota_limit);
+					res = ast_play_and_wait(chan, "vm-mailboxfull");
+					valid_extensions = 0;
+					while ((vmtmp = AST_LIST_REMOVE_HEAD(&extensions, list))) {
+						inprocess_count(vmtmp->mailbox, vmtmp->context, -1);
+						free_user(vmtmp);
+					}
+					break;
+				}
+#endif
 				capacity = receiver->maxmsg - inprocess_count(receiver->mailbox, receiver->context, +1);
 				if ((newmsgs + oldmsgs) >= capacity) {
-					ast_log(LOG_NOTICE, "Mailbox '%s' is full with capacity of %d, prompting for another extension.\n", s, capacity);
+					ast_log(LOG_NOTICE, "Mailbox '%s' is full with capacity of %d, prompting for another extension.\n", mailbox_context, capacity);
 					res = ast_play_and_wait(chan, "vm-mailboxfull");
 					valid_extensions = 0;
 					while ((vmtmp = AST_LIST_REMOVE_HEAD(&extensions, list))) {
@@ -8210,7 +8303,7 @@ static int forward_message(struct ast_ch
 				while ((receiver = AST_LIST_REMOVE_HEAD(&extensions, list))) {
 					free_user(receiver);
 				}
-				ast_log(LOG_NOTICE, "'%s' is not a valid mailbox\n", s);
+				ast_log(LOG_NOTICE, "'%s' is not a valid mailbox\n", mailbox_context);
 				/* "I am sorry, that's not a valid extension.  Please try again." */
 				res = ast_play_and_wait(chan, "pbx-invalid");
 				valid_extensions = 0;
@@ -8290,7 +8383,7 @@ static int forward_message(struct ast_ch
 					if (!dstvms->mailstream) {
 						ast_log(AST_LOG_ERROR, "IMAP mailstream for %s is NULL\n", vmtmp->mailbox);
 					} else {
-						copy_msg_result = STORE(vmstmp.curdir, vmtmp->mailbox, vmtmp->context, dstvms->curmsg, chan, vmtmp, fmt, duration, dstvms, urgent_str, msg_id);
+						copy_msg_result = STORE(vmstmp.curdir, vmtmp->mailbox, vmtmp->context, curmsg, chan, vmtmp, fmt, duration, dstvms, urgent_str, msg_id);
 						run_externnotify(vmtmp->context, vmtmp->mailbox, urgent_str); 
 					}
 				} else {
@@ -8326,10 +8419,6 @@ static int forward_message(struct ast_ch
 					res = ast_play_and_wait(chan, "vm-messages");
 				if (!res)
 					res = ast_play_and_wait(chan, "vm-saved"); */
-#ifdef IMAP_STORAGE
-				/* If forwarded with intro, DON'T PLAY THIS MESSAGE AGAIN! */
-				if (ast_strlen_zero(vmstmp.introfn))
-#endif
 				res = ast_play_and_wait(chan, "vm-msgforwarded");
 			}
 #ifndef IMAP_STORAGE
@@ -8798,6 +8887,7 @@ static int imap_delete_old_greeting (cha
 	char arg[10];
 	int i;
 	BODY* body;
+	int curr_mbox;
 
 	file = strrchr(ast_strdupa(dir), '/');
 	if (file) {
@@ -8808,6 +8898,16 @@ static int imap_delete_old_greeting (cha
 	}
 
 	ast_mutex_lock(&vms->lock);
+
+	/* get the current mailbox so that we can point the mailstream back to it later */
+	curr_mbox = get_folder_by_name(vms->curbox);
+
+	if (init_mailstream(vms, GREETINGS_FOLDER) || !vms->mailstream) {
+		ast_log(AST_LOG_ERROR, "IMAP mailstream is NULL or can't init_mailstream\n");
+		ast_mutex_unlock(&vms->lock);
+		return -1;
+	}
+
 	for (i = 0; i < vms->mailstream->nmsgs; i++) {
 		mail_fetchstructure(vms->mailstream, i + 1, &body);
 		/* We have the body, now we extract the file name of the first attachment. */
@@ -8825,6 +8925,14 @@ static int imap_delete_old_greeting (cha
 		}
 	}
 	mail_expunge(vms->mailstream);
+
+	if (curr_mbox != -1) {
+		/* restore previous mbox stream */
+		if (init_mailstream(vms, curr_mbox) || !vms->mailstream) {
+			ast_log(AST_LOG_ERROR, "IMAP mailstream is NULL or can't init_mailstream\n");
+		}
+	}
+
 	ast_mutex_unlock(&vms->lock);
 	return 0;
 }
@@ -10307,7 +10415,7 @@ static int vm_instructions(struct ast_ch
 }
 
 
-static int vm_newuser(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms, char *fmtc, signed char record_gain)
+static int vm_newuser_setup(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms, char *fmtc, signed char record_gain)
 {
 	int cmd = 0;
 	int duration = 0;
@@ -10332,7 +10440,7 @@ static int vm_newuser(struct ast_channel
 	if (ast_test_flag(vmu, VM_FORCENAME)) {
 		snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vms->username);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
-			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
 				return cmd;
 		}
@@ -10342,14 +10450,14 @@ static int vm_newuser(struct ast_channel
 	if (ast_test_flag(vmu, VM_FORCEGREET)) {
 		snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vms->username);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
-			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
 				return cmd;
 		}
 
 		snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vms->username);
 		if (ast_fileexists(prefile, NULL, NULL) < 1) {
-			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd < 0 || cmd == 't' || cmd == '#')
 				return cmd;
 		}
@@ -10431,15 +10539,15 @@ static int vm_options(struct ast_channel
 		switch (cmd) {
 		case '1': /* Record your unavailable message */
 			snprintf(prefile, sizeof(prefile), "%s%s/%s/unavail", VM_SPOOL_DIR, vmu->context, vms->username);
-			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-unv", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '2':  /* Record your busy message */
 			snprintf(prefile, sizeof(prefile), "%s%s/%s/busy", VM_SPOOL_DIR, vmu->context, vms->username);
-			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-busy", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '3': /* Record greeting */
 			snprintf(prefile, sizeof(prefile), "%s%s/%s/greet", VM_SPOOL_DIR, vmu->context, vms->username);
-			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-name", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			break;
 		case '4':  /* manage the temporary greeting */
 			cmd = vm_tempgreeting(chan, vmu, vms, fmtc, record_gain);
@@ -10573,7 +10681,7 @@ static int vm_tempgreeting(struct ast_ch
 			retries = 0;
 		RETRIEVE(prefile, -1, vmu->mailbox, vmu->context);
 		if (ast_fileexists(prefile, NULL, NULL) <= 0) {
-			cmd = play_record_review(chan, "vm-rec-temp", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+			cmd = play_record_review(chan, "vm-rec-temp", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 			if (cmd == -1) {
 				break;
 			}
@@ -10581,7 +10689,7 @@ static int vm_tempgreeting(struct ast_ch
 		} else {
 			switch (cmd) {
 			case '1':
-				cmd = play_record_review(chan, "vm-rec-temp", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL);
+				cmd = play_record_review(chan, "vm-rec-temp", prefile, maxgreet, fmtc, 0, vmu, &duration, NULL, NULL, record_gain, vms, NULL, NULL, 0);
 				break;
 			case '2':
 				DELETE(prefile, -1, prefile, vmu);
@@ -10897,7 +11005,7 @@ static int vm_authenticate(struct ast_ch
 	adsi_begin(chan, &useadsi);
 	if (!skipuser && useadsi)
 		adsi_login(chan);
-	if (!silent && !skipuser && ast_streamfile(chan, "vm-login", ast_channel_language(chan))) {
+	if (!silent && !skipuser && ast_streamfile(chan, vm_login, ast_channel_language(chan))) {
 		ast_log(AST_LOG_WARNING, "Couldn't stream login file\n");
 		return -1;
 	}
@@ -10939,6 +11047,7 @@ static int vm_authenticate(struct ast_ch
 		}
 
 		ast_debug(1, "Before find user for mailbox %s\n", mailbox);
+		memset(&vmus, 0, sizeof(vmus));
 		vmu = find_user(&vmus, context, mailbox);
 		if (vmu && (vmu->password[0] == '\0' || (vmu->password[0] == '-' && vmu->password[1] == '\0'))) {
 			/* saved password is blank, so don't bother asking */
@@ -10946,10 +11055,12 @@ static int vm_authenticate(struct ast_ch
 		} else {
 			if (ast_streamfile(chan, vm_password, ast_channel_language(chan))) {
 				ast_log(AST_LOG_WARNING, "Unable to stream password file\n");
+				free_user(vmu);
 				return -1;
 			}
 			if (ast_readstring(chan, password, sizeof(password) - 1, 2000, 10000, "#") < 0) {
 				ast_log(AST_LOG_WARNING, "Unable to read password\n");
+				free_user(vmu);
 				return -1;
 			} else if (password[0] == '*') {
 				/* user entered '*' */
@@ -10957,11 +11068,13 @@ static int vm_authenticate(struct ast_ch
 				if (ast_exists_extension(chan, ast_channel_context(chan), "a", 1,
 					S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL))) {
 					mailbox[0] = '*';
+					free_user(vmu);
 					return -1;
 				}
 				ast_verb(4, "Jump to extension 'a' failed; setting mailbox and user to NULL\n");
 				mailbox[0] = '\0';
 				/* if the password entered was '*', do not let a user mailbox be created if the extension 'a' is not defined */
+				free_user(vmu);
 				vmu = NULL;
 			}
 		}
@@ -10982,6 +11095,7 @@ static int vm_authenticate(struct ast_ch
 			if (skipuser || logretries >= max_logins) {
 				if (ast_streamfile(chan, "vm-incorrect", ast_channel_language(chan))) {
 					ast_log(AST_LOG_WARNING, "Unable to stream incorrect message\n");
+					free_user(vmu);
 					return -1;
 				}
 			} else {
@@ -10989,20 +11103,24 @@ static int vm_authenticate(struct ast_ch
 					adsi_login(chan);
 				if (ast_streamfile(chan, "vm-incorrect-mailbox", ast_channel_language(chan))) {
 					ast_log(AST_LOG_WARNING, "Unable to stream incorrect mailbox message\n");
+					free_user(vmu);
 					return -1;
 				}
 			}
-			if (ast_waitstream(chan, ""))	/* Channel is hung up */
+			if (ast_waitstream(chan, "")) {	/* Channel is hung up */
+				free_user(vmu);
 				return -1;
+			}
 		}
 	}
 	if (!valid && (logretries >= max_logins)) {
 		ast_stopstream(chan);
 		ast_play_and_wait(chan, "vm-goodbye");
+		free_user(vmu);
 		return -1;
 	}
 	if (vmu && !skipuser) {
-		memcpy(res_vmu, vmu, sizeof(struct ast_vm_user));
+		*res_vmu = *vmu;
 	}
 	return 0;
 }
@@ -11018,7 +11136,6 @@ static int play_message_by_id_helper(str
 	/* Found the msg, so play it back */
 
 	make_file(vms->fn, sizeof(vms->fn), vms->curdir, vms->curmsg);
-	make_file(vms->fn, sizeof(vms->fn), vms->curdir, vms->curmsg);
 
 #ifdef IMAP_STORAGE
 	/*IMAP storage stores any prepended message from a forward
@@ -11028,6 +11145,8 @@ static int play_message_by_id_helper(str
 		wait_file(chan, vms, vms->introfn);
 	}
 #endif
+	RETRIEVE(vms->curdir,vms->curmsg,vmu->mailbox, vmu->context);
+
 	if ((wait_file(chan, vms, vms->fn)) < 0) {
 		ast_log(AST_LOG_WARNING, "Playback of message %s failed\n", vms->fn);
 	} else {
@@ -11039,7 +11158,7 @@ static int play_message_by_id_helper(str
 		ast_mutex_unlock(&vms->lock);
 #endif
 	}
-
+	DISPOSE(vms->curdir, vms->curmsg);
 	return 0;
 }
 
@@ -11106,6 +11225,8 @@ play_msg_cleanup:
 	}
 #endif
 
+	free_user(vmu);
+
 	return res;
 }
 
@@ -11161,8 +11282,8 @@ static int vm_execmain(struct ast_channe
 	int box;
 	int useadsi = 0;
 	int skipuser = 0;
-	struct vm_state vms;
-	struct ast_vm_user *vmu = NULL, vmus;
+	struct vm_state vms = {{0}};
+	struct ast_vm_user *vmu = NULL, vmus = {{0}};
 	char *context = NULL;
 	int silentexit = 0;
 	struct ast_flags flags = { 0 };
@@ -11175,12 +11296,8 @@ static int vm_execmain(struct ast_channe
 #endif
 
 	/* Add the vm_state to the active list and keep it active */
-	memset(&vms, 0, sizeof(vms));
-
 	vms.lastmsg = -1;
 
-	memset(&vmus, 0, sizeof(vmus));
-
 	ast_test_suite_event_notify("START", "Message: vm_execmain started");
 	if (ast_channel_state(chan) != AST_STATE_UP) {
 		ast_debug(1, "Before ast_answer\n");
@@ -11382,9 +11499,9 @@ static int vm_execmain(struct ast_channe
 	/* Check to see if this is a new user */
 	if (!strcasecmp(vmu->mailbox, vmu->password) && 
 		(ast_test_flag(vmu, VM_FORCENAME | VM_FORCEGREET))) {
-		if (ast_play_and_wait(chan, "vm-newuser") == -1)
+		if (ast_play_and_wait(chan, vm_newuser) == -1)
 			ast_log(AST_LOG_WARNING, "Couldn't stream new user file\n");
-		cmd = vm_newuser(chan, vmu, &vms, vmfmts, record_gain);
+		cmd = vm_newuser_setup(chan, vmu, &vms, vmfmts, record_gain);
 		if ((cmd == 't') || (cmd == '#')) {
 			/* Timeout */
 			ast_test_suite_event_notify("TIMEOUT", "Message: response from user timed out");
@@ -11848,7 +11965,13 @@ static int vm_execmain(struct ast_channe
 			cmd = vm_options(chan, vmu, &vms, vmfmts, record_gain);
 			if (useadsi)
 				adsi_status(chan, &vms);
-			break;
+			/* Reopen play_folder */
+			res = open_mailbox(&vms, vmu, play_folder);
+			if (res < 0) {
+				goto out;
+			}
+			vms.starting = 1;
+ 			break;
 		default:	/* Nothing */
 			ast_test_suite_event_notify("PLAYBACK", "Message: instructions");
 			cmd = vm_instructions(chan, vmu, &vms, 0, in_urgent);
@@ -12106,18 +12229,22 @@ static int append_mailbox(const char *co
 	strcat(mailbox_full, context);
 
 	inboxcount2(mailbox_full, &urgent, &new, &old);
+#ifdef IMAP_STORAGE
+	imap_logout(mailbox_full);
+#endif
 	queue_mwi_event(NULL, mailbox_full, urgent, new, old);
 
 	return 0;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(test_voicemail_vmuser)
 {
 	int res = 0;
 	struct ast_vm_user *vmu;
 	/* language parameter seems to only be used for display in manager action */
 	static const char options_string[] = "attach=yes|attachfmt=wav49|"
-		"serveremail=someguy@digium.com|tz=central|delete=yes|saycid=yes|"
+		"serveremail=someguy@digium.com|fromstring=Voicemail System|tz=central|delete=yes|saycid=yes|"
 		"sendvoicemail=yes|review=yes|tempgreetwarn=yes|messagewrap=yes|operator=yes|"
 		"envelope=yes|moveheard=yes|sayduration=yes|saydurationm=5|forcename=yes|"
 		"forcegreetings=yes|callback=somecontext|dialout=somecontext2|"
@@ -12158,6 +12285,10 @@ AST_TEST_DEFINE(test_voicemail_vmuser)
 		ast_test_status_update(test, "Parse failure for attachftm option\n");
 		res = 1;
 	}
+	if (strcasecmp(vmu->fromstring, "Voicemail System")) {
+		ast_test_status_update(test, "Parse failure for fromstring option\n");
+		res = 1;
+	}
 	if (strcasecmp(vmu->serveremail, "someguy@digium.com")) {
 		ast_test_status_update(test, "Parse failure for serveremail option\n");
 		res = 1;
@@ -12298,10 +12429,11 @@ AST_TEST_DEFINE(test_voicemail_vmuser)
 	free_user(vmu);
 	return res ? AST_TEST_FAIL : AST_TEST_PASS;
 }
+#endif
 
 static int vm_box_exists(struct ast_channel *chan, const char *data) 
 {
-	struct ast_vm_user svm;
+	struct ast_vm_user svm, *vmu;
 	char *context, *box;
 	AST_DECLARE_APP_ARGS(args,
 		AST_APP_ARG(mbox);
@@ -12331,8 +12463,11 @@ static int vm_box_exists(struct ast_chan
 		context++;
 	}
 
-	if (find_user(&svm, context, args.mbox)) {
+	memset(&svm, 0, sizeof(svm));
+	vmu = find_user(&svm, context, args.mbox);
+	if (vmu) {
 		pbx_builtin_setvar_helper(chan, "VMBOXEXISTSSTATUS", "SUCCESS");
+		free_user(vmu);
 	} else
 		pbx_builtin_setvar_helper(chan, "VMBOXEXISTSSTATUS", "FAILED");
 
@@ -12341,7 +12476,7 @@ static int vm_box_exists(struct ast_chan
 
 static int acf_mailbox_exists(struct ast_channel *chan, const char *cmd, char *args, char *buf, size_t len)
 {
-	struct ast_vm_user svm;
+	struct ast_vm_user svm, *vmu;
 	AST_DECLARE_APP_ARGS(arg,
 		AST_APP_ARG(mbox);
 		AST_APP_ARG(context);
@@ -12360,7 +12495,11 @@ static int acf_mailbox_exists(struct ast
 		ast_log(AST_LOG_WARNING, "MAILBOX_EXISTS is deprecated.  Please use ${VM_INFO(%s,exists)} instead.\n", args);
 	}
 
-	ast_copy_string(buf, find_user(&svm, ast_strlen_zero(arg.context) ? "default" : arg.context, arg.mbox) ? "1" : "0", len);
+	memset(&svm, 0, sizeof(svm));
+	vmu = find_user(&svm, ast_strlen_zero(arg.context) ? "default" : arg.context, arg.mbox);
+	ast_copy_string(buf, vmu ? "1" : "0", len);
+	free_user(vmu);
+
 	return 0;
 }
 
@@ -12396,10 +12535,12 @@ static int acf_vm_info(struct ast_channe
 		return -1;
 	}
 
+	memset(&svm, 0, sizeof(svm));
 	vmu = find_user(&svm, context, mailbox);
 
 	if (!strncasecmp(arg.attribute, "exists", 5)) {
 		ast_copy_string(buf, vmu ? "1" : "0", len);
+		free_user(vmu);
 		return 0;
 	}
 
@@ -12428,13 +12569,16 @@ static int acf_vm_info(struct ast_channe
 			res = messagecount(mailbox_id, arg.folder);
 			if (res < 0) {
 				ast_log(LOG_ERROR, "Unable to retrieve message count for mailbox %s\n", arg.mailbox_context);
+				free_user(vmu);
 				return -1;
 			}
 			snprintf(buf, len, "%d", res);
 		} else {
 			ast_log(LOG_ERROR, "Unknown attribute '%s' for VM_INFO\n", arg.attribute);
+			free_user(vmu);
 			return -1;
 		}
+		free_user(vmu);
 	}
 
 	return 0;
@@ -12453,7 +12597,7 @@ static struct ast_custom_function vm_inf
 static int vmauthenticate(struct ast_channel *chan, const char *data)
 {
 	char *s, *user = NULL, *context = NULL, mailbox[AST_MAX_EXTENSION] = "";
-	struct ast_vm_user vmus;
+	struct ast_vm_user vmus = {{0}};
 	char *options = NULL;
 	int silent = 0, skipuser = 0;
 	int res = -1;
@@ -12537,11 +12681,9 @@ static char *complete_voicemail_show_use
 	struct ast_vm_user *vmu;
 	const char *context = "";
 
-	/* 0 - show; 1 - voicemail; 2 - users; 3 - for; 4 - <context> */
+	/* 0 - voicemail; 1 - show; 2 - users; 3 - for; 4 - <context> */
 	if (pos > 4)
 		return NULL;
-	if (pos == 3)
-		return (state == 0) ? ast_strdup("for") : NULL;
 	wordlen = strlen(word);
 	AST_LIST_TRAVERSE(&users, vmu, list) {
 		if (!strncasecmp(word, vmu->context, wordlen)) {
@@ -12564,7 +12706,7 @@ static char *handle_voicemail_show_users
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "voicemail show users";
+		e->command = "voicemail show users [for]";
 		e->usage =
 			"Usage: voicemail show users [for <context>]\n"
 			"       Lists all mailboxes currently set up\n";
@@ -12706,6 +12848,7 @@ static struct ast_cli_entry cli_voicemai
 		USER(ast_vm_user, emailbody, AST_DATA_STRING)			\
 		USER(ast_vm_user, pager, AST_DATA_STRING)			\
 		USER(ast_vm_user, serveremail, AST_DATA_STRING)			\
+		USER(ast_vm_user, fromstring, AST_DATA_STRING)			\
 		USER(ast_vm_user, language, AST_DATA_STRING)			\
 		USER(ast_vm_user, zonetag, AST_DATA_STRING)			\
 		USER(ast_vm_user, callback, AST_DATA_STRING)			\
@@ -12733,6 +12876,7 @@ static struct ast_cli_entry cli_voicemai
 		USER(ast_vm_user, emailbody, AST_DATA_STRING)			\
 		USER(ast_vm_user, pager, AST_DATA_STRING)			\
 		USER(ast_vm_user, serveremail, AST_DATA_STRING)			\
+		USER(ast_vm_user, fromstring, AST_DATA_STRING)			\
 		USER(ast_vm_user, language, AST_DATA_STRING)			\
 		USER(ast_vm_user, zonetag, AST_DATA_STRING)			\
 		USER(ast_vm_user, callback, AST_DATA_STRING)			\
@@ -12840,6 +12984,12 @@ static void poll_subscribed_mailbox(stru
 
 	inboxcount2(mwi_sub->mailbox, &urgent, &new, &old);
 
+#ifdef IMAP_STORAGE
+	if (imap_poll_logout) {
+		imap_logout(mwi_sub->mailbox);
+	}
+#endif
+
 	if (urgent != mwi_sub->old_urgent || new != mwi_sub->old_new || old != mwi_sub->old_old) {
 		mwi_sub->old_urgent = urgent;
 		mwi_sub->old_new = new;
@@ -12891,6 +13041,55 @@ static void mwi_sub_destroy(struct mwi_s
 	ast_free(mwi_sub);
 }
 
+#ifdef IMAP_STORAGE
+static void imap_logout(const char *mailbox_id)
+{
+	char *context;
+	char *mailbox;
+	struct ast_vm_user vmus;
+	RAII_VAR(struct ast_vm_user *, vmu, NULL, free_user);
+	struct vm_state *vms = NULL;
+
+	if (ast_strlen_zero(mailbox_id)
+		|| separate_mailbox(ast_strdupa(mailbox_id), &mailbox, &context)) {
+		return;
+	}
+
+	memset(&vmus, 0, sizeof(vmus));
+
+	if (!(vmu = find_user(&vmus, context, mailbox)) || vmu->imapuser[0] == '\0') {
+		return;
+	}
+
+	vms = get_vm_state_by_imapuser(vmu->imapuser, 0);
+	if (!vms) {
+		vms = get_vm_state_by_mailbox(mailbox, context, 0);
+	}
+	if (!vms) {
+		return;
+	}
+
+	ast_mutex_lock(&vms->lock);
+	vms->mailstream = mail_close(vms->mailstream);
+	ast_mutex_unlock(&vms->lock);
+
+	vmstate_delete(vms);
+}
+
+static void imap_close_subscribed_mailboxes(void)
+{
+	struct mwi_sub *mwi_sub;
+
+	AST_RWLIST_RDLOCK(&mwi_subs);
+	AST_RWLIST_TRAVERSE(&mwi_subs, mwi_sub, entry) {
+		if (!ast_strlen_zero(mwi_sub->mailbox)) {
+			imap_logout(mwi_sub->mailbox);
+		}
+	}
+	AST_RWLIST_UNLOCK(&mwi_subs);
+}
+#endif
+
 static int handle_unsubscribe(void *datap)
 {
 	struct mwi_sub *mwi_sub;
@@ -12902,6 +13101,9 @@ static int handle_unsubscribe(void *data
 			AST_LIST_REMOVE_CURRENT(entry);
 			/* Don't break here since a duplicate uniqueid
 			 * may have been added as a result of a cache dump. */
+#ifdef IMAP_STORAGE
+			imap_logout(mwi_sub->mailbox);
+#endif
 			mwi_sub_destroy(mwi_sub);
 		}
 	}
@@ -13122,6 +13324,7 @@ static int manager_list_voicemail_users(
 			"Email: %s\r\n"
 			"Pager: %s\r\n"
 			"ServerEmail: %s\r\n"
+			"FromString: %s\r\n"
 			"MailCommand: %s\r\n"
 			"Language: %s\r\n"
 			"TimeZone: %s\r\n"
@@ -13156,6 +13359,7 @@ static int manager_list_voicemail_users(
 			vmu->email,
 			vmu->pager,
 			ast_strlen_zero(vmu->serveremail) ? serveremail : vmu->serveremail,
+			ast_strlen_zero(vmu->fromstring) ? fromstring : vmu->fromstring,
 			mailcmd,
 			vmu->language,
 			vmu->zonetag,
@@ -13324,6 +13528,8 @@ static int actual_load_config(int reload
 	int x;
 	unsigned int tmpadsi[4];
 	char secretfn[PATH_MAX] = "";
+	long tps_queue_low;
+	long tps_queue_high;
 
 #ifdef IMAP_STORAGE
 	ast_copy_string(imapparentfolder, "\0", sizeof(imapparentfolder));
@@ -13335,7 +13541,11 @@ static int actual_load_config(int reload
 	strcpy(listen_control_restart_key, DEFAULT_LISTEN_CONTROL_RESTART_KEY);
 	strcpy(listen_control_stop_key, DEFAULT_LISTEN_CONTROL_STOP_KEY);
 
-	/* Free all the users structure */	
+#ifdef IMAP_STORAGE
+	imap_close_subscribed_mailboxes();
+#endif
+
+	/* Free all the users structure */
 	free_vm_users();
 
 	/* Free all the zones structure */
@@ -13500,6 +13710,11 @@ static int actual_load_config(int reload
 		} else {
 			ast_copy_string(greetingfolder, imapfolder, sizeof(greetingfolder));
 		}
+		if ((val = ast_variable_retrieve(cfg, "general", "imap_poll_logout"))) {
+			imap_poll_logout = ast_true(val);
+		} else {
+			imap_poll_logout = 0;
+		}
 
 		/* There is some very unorthodox casting done here. This is due
 		 * to the way c-client handles the argument passed in. It expects a 
@@ -13781,6 +13996,10 @@ static int actual_load_config(int reload
 		}
 
 		/* load password sounds configuration */
+		if ((val = ast_variable_retrieve(cfg, "general", "vm-login")))
+			ast_copy_string(vm_login, val, sizeof(vm_login));
+		if ((val = ast_variable_retrieve(cfg, "general", "vm-newuser")))
+			ast_copy_string(vm_newuser, val, sizeof(vm_newuser));
 		if ((val = ast_variable_retrieve(cfg, "general", "vm-password")))
 			ast_copy_string(vm_password, val, sizeof(vm_password));
 		if ((val = ast_variable_retrieve(cfg, "general", "vm-newpassword")))
@@ -13899,6 +14118,25 @@ static int actual_load_config(int reload
 			pagerbody = ast_strdup(substitute_escapes(val));
 		}
 
+		tps_queue_high = AST_TASKPROCESSOR_HIGH_WATER_LEVEL;
+		if ((val = ast_variable_retrieve(cfg, "general", "tps_queue_high"))) {
+			if (sscanf(val, "%30ld", &tps_queue_high) != 1 || tps_queue_high <= 0) {
+				ast_log(AST_LOG_WARNING, "Invalid the taskprocessor high water alert trigger level '%s'\n", val);
+				tps_queue_high = AST_TASKPROCESSOR_HIGH_WATER_LEVEL;
+			}
+		}
+		tps_queue_low = -1;
+		if ((val = ast_variable_retrieve(cfg, "general", "tps_queue_low"))) {
+			if (sscanf(val, "%30ld", &tps_queue_low) != 1 ||
+				tps_queue_low < -1 || tps_queue_high < tps_queue_low) {
+				ast_log(AST_LOG_WARNING, "Invalid the taskprocessor low water clear alert level '%s'\n", val);
+				tps_queue_low = -1;
+			}
+		}
+		if (ast_taskprocessor_alert_set_levels(mwi_subscription_tps, tps_queue_low, tps_queue_high)) {
+			ast_log(AST_LOG_WARNING, "Failed to set alert levels for voicemail taskprocessor.\n");
+		}
+
 		/* load mailboxes from users.conf */
 		if (ucfg) {	
 			for (cat = ast_category_browse(ucfg, NULL); cat ; cat = ast_category_browse(ucfg, cat)) {
@@ -14164,7 +14402,7 @@ AST_TEST_DEFINE(test_voicemail_vmsayname
 				ast_log(AST_LOG_WARNING, "Failed to make test directory\n");
 				goto exit_vmsayname_test;
 			}
-			snprintf(dir, sizeof(dir), "%s/sounds/beep.gsm", ast_config_AST_VAR_DIR);
+			snprintf(dir, sizeof(dir), "%s/sounds/beep.gsm", ast_config_AST_DATA_DIR);
 			snprintf(dir2, sizeof(dir2), "%s%s/%s/greet.gsm", VM_SPOOL_DIR, TEST_CONTEXT, TEST_EXTENSION);
 			/* we're not going to hear the sound anyway, just use a valid gsm audio file */
 			if ((res = symlink(dir, dir2))) {
@@ -14248,6 +14486,7 @@ AST_TEST_DEFINE(test_voicemail_msgcount)
 	}
 #endif
 
+	memset(&svm, 0, sizeof(svm));
 	if (!(vmu = find_user(&svm, testcontext, testmailbox)) &&
 		!(vmu = find_or_create(testcontext, testmailbox))) {
 		ast_test_status_update(test, "Cannot create vmu structure\n");
@@ -14277,6 +14516,7 @@ AST_TEST_DEFINE(test_voicemail_msgcount)
 #ifdef IMAP_STORAGE
 				chan = ast_channel_unref(chan);
 #endif
+				free_user(vmu);
 				return AST_TEST_FAIL;
 			}
 		}
@@ -14360,6 +14600,7 @@ AST_TEST_DEFINE(test_voicemail_msgcount)
 			syserr > 0 ? strerror(syserr) : "unable to fork()");
 	}
 
+	free_user(vmu);
 	return res;
 }
 
@@ -14407,8 +14648,8 @@ AST_TEST_DEFINE(test_voicemail_notify_en
 		break;
 	}
 
-	snprintf(attach, sizeof(attach), "%s/sounds/en/tt-weasels", ast_config_AST_VAR_DIR);
-	snprintf(attach2, sizeof(attach2), "%s/sounds/en/tt-somethingwrong", ast_config_AST_VAR_DIR);
+	snprintf(attach, sizeof(attach), "%s/sounds/en/tt-weasels", ast_config_AST_DATA_DIR);
+	snprintf(attach2, sizeof(attach2), "%s/sounds/en/tt-somethingwrong", ast_config_AST_DATA_DIR);
 
 	if (!(vmu = find_user(&vmus, testcontext, testmailbox)) &&
 		!(vmu = find_or_create(testcontext, testmailbox))) {
@@ -14469,6 +14710,7 @@ AST_TEST_DEFINE(test_voicemail_notify_en
 		}
 	}
 	fclose(file);
+	free_user(vmu);
 	return res;
 }
 
@@ -14629,6 +14871,7 @@ AST_TEST_DEFINE(test_voicemail_vm_info)
 	}
 
 	chan = ast_channel_unref(chan);
+	free_user(vmu);
 	return res;
 }
 #endif /* defined(TEST_FRAMEWORK) */
@@ -14701,6 +14944,9 @@ static int unload_module(void)
 	ast_unload_realtime("voicemail");
 	ast_unload_realtime("voicemail_data");
 
+#ifdef IMAP_STORAGE
+	imap_close_subscribed_mailboxes();
+#endif
 	free_vm_users();
 	free_vm_zones();
 	return res;
@@ -14727,7 +14973,7 @@ static int load_module(void)
 	umask(my_umask);
 
 	if (!(inprocess_container = ao2_container_alloc(573, inprocess_hash_fn, inprocess_cmp_fn))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* compute the location of the voicemail spool directory */
@@ -15020,8 +15266,10 @@ static int advanced_options(struct ast_c
 			ast_config_destroy(msg_cfg);
 			return res;
 		} else {
-			struct ast_vm_user vmu2;
-			if (find_user(&vmu2, vmu->context, num)) {
+			struct ast_vm_user vmu2, *vmu3;
+			memset(&vmu2, 0, sizeof(vmu2));
+			vmu3 = find_user(&vmu2, vmu->context, num);
+			if (vmu3) {
 				struct leave_vm_options leave_options;
 				char mailbox[AST_MAX_EXTENSION * 2 + 2];
 				snprintf(mailbox, sizeof(mailbox), "%s@%s", num, vmu->context);
@@ -15034,6 +15282,7 @@ static int advanced_options(struct ast_c
 				if (!res)
 					res = 't';
 				ast_config_destroy(msg_cfg);
+				free_user(vmu3);
 				return res;
 			} else {
 				/* Sender has no mailbox, can't reply */
@@ -15063,7 +15312,7 @@ static int advanced_options(struct ast_c
 
 static int play_record_review(struct ast_channel *chan, char *playfile, char *recordfile, int maxtime, char *fmt,
 			int outsidecaller, struct ast_vm_user *vmu, int *duration, int *sound_duration, const char *unlockdir,
-			signed char record_gain, struct vm_state *vms, char *flag, const char *msg_id)
+			signed char record_gain, struct vm_state *vms, char *flag, const char *msg_id, int forwardintro)
 {
 	/* Record message & let caller review or re-record it, or set options if applicable */
 	int res = 0;
@@ -15105,7 +15354,9 @@ static int play_record_review(struct ast
 				ast_verb(3, "Saving message as is\n");
 				if (!outsidecaller) 
 					ast_filerename(tempfile, recordfile, NULL);
-				ast_stream_and_wait(chan, "vm-msgsaved", "");
+				if (!forwardintro) {
+					ast_stream_and_wait(chan, "vm-msgsaved", "");
+				}
 				if (!outsidecaller) {
 					/* Saves to IMAP server only if imapgreeting=yes */
 					STORE(recordfile, vmu->mailbox, vmu->context, -1, chan, vmu, fmt, *duration, vms, flag, msg_id);
@@ -15128,7 +15379,11 @@ static int play_record_review(struct ast
 				ast_verb(3, "Recording the message\n");
 			
 			if (recorded && outsidecaller) {
-				cmd = ast_play_and_wait(chan, INTRO);
+				if (forwardintro) {
+					cmd = ast_play_and_wait(chan, "vm-record-prepend");
+				} else {
+					cmd = ast_play_and_wait(chan, INTRO);
+				}
 				cmd = ast_play_and_wait(chan, "beep");
 			}
 			recorded = 1;
@@ -15249,10 +15504,10 @@ static int play_record_review(struct ast
 			}
 			return cmd;
 		default:
-			/* If the caller is an ouside caller, and the review option is enabled,
+			/* If the caller is an ouside caller and the review option is enabled or it's forward intro
 			   allow them to review the message, but let the owner of the box review
 			   their OGM's */
-			if (outsidecaller && !ast_test_flag(vmu, VM_REVIEW))
+			if (outsidecaller && !ast_test_flag(vmu, VM_REVIEW) && !forwardintro)
 				return cmd;
 			if (msg_exists) {
 				cmd = ast_play_and_wait(chan, "vm-review");
@@ -15528,11 +15783,13 @@ static struct ast_vm_mailbox_snapshot *v
 
 	if (!(mailbox_snapshot = ast_calloc(1, sizeof(*mailbox_snapshot)))) {
 		ast_log(AST_LOG_ERROR, "Failed to allocate memory for mailbox snapshot\n");
+		free_user(vmu);
 		return NULL;
 	}
 
 	if (!(mailbox_snapshot->snapshots = ast_calloc(ARRAY_LEN(mailbox_folders), sizeof(*mailbox_snapshot->snapshots)))) {
 		ast_free(mailbox_snapshot);
+		free_user(vmu);
 		return NULL;
 	}
 
@@ -15593,6 +15850,7 @@ snapshot_cleanup:
 	}
 #endif
 
+	free_user(vmu);
 	return mailbox_snapshot;
 }
 
@@ -15747,6 +16005,7 @@ static int vm_msg_forward(const char *fr
 
 	if (!(to_vmu = find_user(&to_vmus, to_context, to_mailbox))) {
 		ast_log(LOG_WARNING, "Can't find voicemail user to forward to (%s@%s)\n", to_mailbox, to_context);
+		free_user(vmu);
 		return -1;
 	}
 
@@ -15827,6 +16086,8 @@ vm_forward_cleanup:
 		notify_new_state(to_vmu);
 	}
 
+	free_user(vmu);
+	free_user(to_vmu);
 	return res;
 }
 
@@ -15930,6 +16191,7 @@ vm_move_cleanup:
 		notify_new_state(vmu);
 	}
 
+	free_user(vmu);
 	return res;
 }
 
@@ -16027,6 +16289,7 @@ vm_remove_cleanup:
 		notify_new_state(vmu);
 	}
 
+	free_user(vmu);
 	return res;
 }
 
@@ -16140,6 +16403,7 @@ play2_msg_cleanup:
 		notify_new_state(vmu);
 	}
 
+	free_user(vmu);
 	return res;
 }
 
diff -urpN asterisk-13.9.1/apps/app_zapateller.c asterisk-13.17.0/apps/app_zapateller.c
--- asterisk-13.9.1/apps/app_zapateller.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/app_zapateller.c	2017-07-12 13:12:08.000000000 +0200
@@ -134,7 +134,7 @@ static int unload_module(void)
 
 static int load_module(void)
 {
-	return ((ast_register_application_xml(app, zapateller_exec)) ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS);
+	return ((ast_register_application_xml(app, zapateller_exec)) ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS);
 }
 
 AST_MODULE_INFO_STANDARD_EXTENDED(ASTERISK_GPL_KEY, "Block Telemarketers with Special Information Tone");
diff -urpN asterisk-13.9.1/apps/confbridge/conf_chan_announce.c asterisk-13.17.0/apps/confbridge/conf_chan_announce.c
--- asterisk-13.9.1/apps/confbridge/conf_chan_announce.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/confbridge/conf_chan_announce.c	2017-07-12 13:12:08.000000000 +0200
@@ -143,31 +143,6 @@ struct ast_channel_tech *conf_announce_g
 	return &announce_tech;
 }
 
-void conf_announce_channel_depart(struct ast_channel *chan)
-{
-	struct announce_pvt *p = ast_channel_tech_pvt(chan);
-
-	if (!p) {
-		return;
-	}
-
-	ao2_ref(p, +1);
-	ao2_lock(p);
-	if (!ast_test_flag(&p->base, AST_UNREAL_CARETAKER_THREAD)) {
-		ao2_unlock(p);
-		ao2_ref(p, -1);
-		return;
-	}
-	ast_clear_flag(&p->base, AST_UNREAL_CARETAKER_THREAD);
-	chan = p->base.chan;
-	ao2_unlock(p);
-	ao2_ref(p, -1);
-	if (chan) {
-		ast_bridge_depart(chan);
-		ast_channel_unref(chan);
-	}
-}
-
 int conf_announce_channel_push(struct ast_channel *ast)
 {
 	struct ast_bridge_features *features;
@@ -186,21 +161,17 @@ int conf_announce_channel_push(struct as
 		if (!chan) {
 			return -1;
 		}
-		ast_channel_ref(chan);
 	}
 
 	features = ast_bridge_features_new();
 	if (!features) {
-		ast_channel_unref(chan);
 		return -1;
 	}
 	ast_set_flag(&features->feature_flags, AST_BRIDGE_CHANNEL_FLAG_IMMOVABLE);
 
 	/* Impart the output channel into the bridge */
 	if (ast_bridge_impart(p->bridge, chan, NULL, features,
-		AST_BRIDGE_IMPART_CHAN_DEPARTABLE)) {
-		ast_bridge_features_destroy(features);
-		ast_channel_unref(chan);
+		AST_BRIDGE_IMPART_CHAN_INDEPENDENT)) {
 		return -1;
 	}
 	ao2_lock(p);
diff -urpN asterisk-13.9.1/apps/confbridge/conf_config_parser.c asterisk-13.17.0/apps/confbridge/conf_config_parser.c
--- asterisk-13.9.1/apps/confbridge/conf_config_parser.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/confbridge/conf_config_parser.c	2017-07-12 13:12:08.000000000 +0200
@@ -317,6 +317,22 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 						on a conference.
 					</para></description>
 				</configOption>
+				<configOption name="regcontext">
+					<synopsis>The name of the context into which to register the name of the conference bridge as NoOP() at priority 1</synopsis>
+					<description><para>
+						When set this will cause the name of the created conference to be registered
+						into the named context at priority 1 with an operation of NoOP().  This can
+						then be used in other parts of the dialplan to test for the existence of a
+						specific conference bridge.
+						You should be aware that there are potential races between testing for the
+						existence of a bridge, and taking action upon that information, consider
+						for example two callers executing the check simultaniously, and then taking
+						special action as "first caller" into the bridge.  The same for exiting,
+						directly after the check the bridge can be destroyed before the new caller
+						enters (creating a new bridge), for example, and the "first member" actions
+						could thus be missed.
+					</para></description>
+				</configOption>
 				<configOption name="video_mode">
 					<synopsis>Sets how confbridge handles video distribution to the conference participants</synopsis>
 					<description><para>
@@ -1327,7 +1343,7 @@ static char *handle_cli_confbridge_show_
 	case CLI_INIT:
 		e->command = "confbridge show profile users";
 		e->usage =
-			"Usage confbridge show profile users\n";
+			"Usage: confbridge show profile users\n";
 		return NULL;
 	case CLI_GENERATE:
 		return NULL;
@@ -1357,7 +1373,7 @@ static char *handle_cli_confbridge_show_
 	case CLI_INIT:
 		e->command = "confbridge show profile user";
 		e->usage =
-			"Usage confbridge show profile user [<profile name>]\n";
+			"Usage: confbridge show profile user [<profile name>]\n";
 		return NULL;
 	case CLI_GENERATE:
 		if (a->pos == 4) {
@@ -1478,7 +1494,7 @@ static char *handle_cli_confbridge_show_
 	case CLI_INIT:
 		e->command = "confbridge show profile bridges";
 		e->usage =
-			"Usage confbridge show profile bridges\n";
+			"Usage: confbridge show profile bridges\n";
 		return NULL;
 	case CLI_GENERATE:
 		return NULL;
@@ -1510,7 +1526,7 @@ static char *handle_cli_confbridge_show_
 	case CLI_INIT:
 		e->command = "confbridge show profile bridge";
 		e->usage =
-			"Usage confbridge show profile bridge <profile name>\n";
+			"Usage: confbridge show profile bridge <profile name>\n";
 		return NULL;
 	case CLI_GENERATE:
 		if (a->pos == 4) {
@@ -1563,6 +1579,8 @@ static char *handle_cli_confbridge_show_
 		ast_cli(a->fd,"Max Members:          No Limit\n");
 	}
 
+	ast_cli(a->fd,"Registration context: %s\n", b_profile.regcontext);
+
 	switch (b_profile.flags
 		& (BRIDGE_OPT_VIDEO_SRC_LAST_MARKED | BRIDGE_OPT_VIDEO_SRC_FIRST_MARKED
 			| BRIDGE_OPT_VIDEO_SRC_FOLLOW_TALKER)) {
@@ -1650,7 +1668,7 @@ static char *handle_cli_confbridge_show_
 	case CLI_INIT:
 		e->command = "confbridge show menus";
 		e->usage =
-			"Usage confbridge show profile menus\n";
+			"Usage: confbridge show profile menus\n";
 		return NULL;
 	case CLI_GENERATE:
 		return NULL;
@@ -1684,7 +1702,7 @@ static char *handle_cli_confbridge_show_
 	case CLI_INIT:
 		e->command = "confbridge show menu";
 		e->usage =
-			"Usage confbridge show menu [<menu name>]\n";
+			"Usage: confbridge show menu [<menu name>]\n";
 		return NULL;
 	case CLI_GENERATE:
 		if (a->pos == 3) {
@@ -2004,7 +2022,7 @@ static int conf_menu_profile_copy(struct
 static int menu_template_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
 {
 	struct conf_menu *dst_menu = obj;
-	struct confbridge_cfg *cfg = aco_pending_config(&cfg_info);
+	RAII_VAR(struct confbridge_cfg *, cfg, ao2_global_obj_ref(cfg_handle), ao2_cleanup);
 	RAII_VAR(struct conf_menu *, src_menu, NULL, ao2_cleanup);
 
 	if (!cfg) {
@@ -2039,6 +2057,7 @@ static int verify_default_profiles(void)
 	RAII_VAR(struct user_profile *, user_profile, NULL, ao2_cleanup);
 	RAII_VAR(struct bridge_profile *, bridge_profile, NULL, ao2_cleanup);
 	RAII_VAR(struct conf_menu *, menu_profile, NULL, ao2_cleanup);
+	/* We can only be called as a result of an aco_process_config so this is safe */
 	struct confbridge_cfg *cfg = aco_pending_config(&cfg_info);
 
 	if (!cfg) {
@@ -2128,6 +2147,7 @@ int conf_load_config(void)
 	aco_option_register(&cfg_info, "record_file_append", ACO_EXACT, bridge_types, "yes", OPT_BOOLFLAG_T, 1, FLDSET(struct bridge_profile, flags), BRIDGE_OPT_RECORD_FILE_APPEND);
 	aco_option_register(&cfg_info, "max_members", ACO_EXACT, bridge_types, "0", OPT_UINT_T, 0, FLDSET(struct bridge_profile, max_members));
 	aco_option_register(&cfg_info, "record_file", ACO_EXACT, bridge_types, NULL, OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, rec_file));
+	aco_option_register(&cfg_info, "regcontext", ACO_EXACT, bridge_types, NULL, OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, regcontext));
 	aco_option_register(&cfg_info, "language", ACO_EXACT, bridge_types, "en", OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, language));
 	aco_option_register_custom(&cfg_info, "^sound_", ACO_REGEX, bridge_types, NULL, sound_option_handler, 0);
 	/* This option should only be used with the CONFBRIDGE dialplan function */
@@ -2135,6 +2155,7 @@ int conf_load_config(void)
 
 	/* Menu options */
 	aco_option_register(&cfg_info, "type", ACO_EXACT, menu_types, NULL, OPT_NOOP_T, 0, 0);
+	/* This option should only be used with the CONFBRIDGE dialplan function */
 	aco_option_register_custom(&cfg_info, "template", ACO_EXACT, menu_types, NULL, menu_template_handler, 0);
 	aco_option_register_custom(&cfg_info, "^[0-9A-D*#]+$", ACO_REGEX, menu_types, NULL, menu_option_handler, 0);
 
diff -urpN asterisk-13.9.1/apps/confbridge/conf_state_multi_marked.c asterisk-13.17.0/apps/confbridge/conf_state_multi_marked.c
--- asterisk-13.9.1/apps/confbridge/conf_state_multi_marked.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/confbridge/conf_state_multi_marked.c	2017-07-12 13:12:08.000000000 +0200
@@ -160,12 +160,9 @@ static void leave_marked(struct confbrid
 	if (need_prompt) {
 		/* Play back the audio prompt saying the leader has left the conference */
 		if (!ast_test_flag(&user->u_profile, USER_OPT_QUIET)) {
-			ao2_unlock(user->conference);
-			ast_autoservice_start(user->chan);
-			play_sound_file(user->conference,
-				conf_get_sound(CONF_SOUND_LEADER_HAS_LEFT, user->conference->b_profile.sounds));
-			ast_autoservice_stop(user->chan);
-			ao2_lock(user->conference);
+			async_play_sound_file(user->conference,
+				conf_get_sound(CONF_SOUND_LEADER_HAS_LEFT, user->conference->b_profile.sounds),
+				NULL);
 		}
 
 		AST_LIST_TRAVERSE(&user->conference->waiting_list, user_iter, list) {
diff -urpN asterisk-13.9.1/apps/confbridge/confbridge_manager.c asterisk-13.17.0/apps/confbridge/confbridge_manager.c
--- asterisk-13.9.1/apps/confbridge/confbridge_manager.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/confbridge/confbridge_manager.c	2017-07-12 13:12:08.000000000 +0200
@@ -191,7 +191,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 	</managerEvent>
 	<managerEvent language="en_US" name="ConfbridgeTalking">
 		<managerEventInstance class="EVENT_FLAG_CALL">
-			<synopsis>Raised when a confbridge participant unmutes.</synopsis>
+			<synopsis>Raised when a confbridge participant begins or ends talking.</synopsis>
 			<syntax>
 				<parameter name="Conference">
 					<para>The name of the Confbridge conference.</para>
diff -urpN asterisk-13.9.1/apps/confbridge/include/confbridge.h asterisk-13.17.0/apps/confbridge/include/confbridge.h
--- asterisk-13.9.1/apps/confbridge/include/confbridge.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/apps/confbridge/include/confbridge.h	2017-07-12 13:12:08.000000000 +0200
@@ -207,6 +207,7 @@ struct bridge_profile {
 	unsigned int internal_sample_rate; /*!< The internal sample rate of the bridge. 0 when set to auto adjust mode. */
 	unsigned int mix_interval;  /*!< The internal mixing interval used by the bridge. When set to 0 the bridgewill use a default interval. */
 	struct bridge_profile_sounds *sounds;
+	char regcontext[AST_MAX_CONTEXT];
 };
 
 /*! \brief The structure that represents a conference bridge */
@@ -224,9 +225,9 @@ struct confbridge_conference {
 	struct ast_channel *record_chan;                                  /*!< Channel used for recording the conference */
 	struct ast_str *record_filename;                                  /*!< Recording filename. */
 	struct ast_str *orig_rec_file;                                    /*!< Previous b_profile.rec_file. */
-	ast_mutex_t playback_lock;                                        /*!< Lock used for playback channel */
 	AST_LIST_HEAD_NOLOCK(, confbridge_user) active_list;              /*!< List of users participating in the conference bridge */
 	AST_LIST_HEAD_NOLOCK(, confbridge_user) waiting_list;             /*!< List of users waiting to join the conference bridge */
+	struct ast_taskprocessor *playback_queue;                         /*!< Queue for playing back bridge announcements and managing the announcer channel */
 };
 
 extern struct ao2_container *conference_bridges;
@@ -385,6 +386,37 @@ int func_confbridge_helper(struct ast_ch
  */
 int play_sound_file(struct confbridge_conference *conference, const char *filename);
 
+/*!
+ * \brief Play sound file into conference bridge asynchronously
+ *
+ * If the initiator parameter is non-NULL, then the playback will wait for
+ * that initiator channel to get back in the bridge before playing the sound
+ * file. This way, the initiator has no danger of hearing a "clipped" file.
+ *
+ * \param conference The conference bridge to play sound file into
+ * \param filename Sound file to play
+ * \param initiator Channel that initiated playback.
+ *
+ * \retval 0 success
+ * \retval -1 failure
+ */
+int async_play_sound_file(struct confbridge_conference *conference, const char *filename,
+	struct ast_channel *initiator);
+
+/*!
+ * \brief Indicate the initiator of an async sound file is ready for it to play.
+ *
+ * When playing an async sound file, the initiator is typically either out of the bridge
+ * or not in a position to hear the queued announcement. This function lets the announcement
+ * thread know that the initiator is now ready for the sound to play.
+ *
+ * If an async announcement was queued and no initiator channel was provided, then this is
+ * a no-op
+ *
+ * \param chan The channel that initiated the async announcement
+ */
+void async_play_sound_ready(struct ast_channel *chan);
+
 /*! \brief Callback to be called when the conference has become empty
  * \param conference The conference bridge
  */
@@ -606,16 +638,6 @@ struct ast_channel_tech *conf_record_get
 struct ast_channel_tech *conf_announce_get_tech(void);
 
 /*!
- * \brief Remove the announcer channel from the conference.
- * \since 12.0.0
- *
- * \param chan Either channel in the announcer channel pair.
- *
- * \return Nothing
- */
-void conf_announce_channel_depart(struct ast_channel *chan);
-
-/*!
  * \brief Push the announcer channel into the conference.
  * \since 12.0.0
  *
diff -urpN asterisk-13.9.1/asterisk-13.17.0-summary.html asterisk-13.17.0/asterisk-13.17.0-summary.html
--- asterisk-13.9.1/asterisk-13.17.0-summary.html	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/asterisk-13.17.0-summary.html	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,306 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><title>Release Summary - asterisk-13.17.0</title><h1 align="center"><a name="top">Release Summary</a></h1><h3 align="center">asterisk-13.17.0</h3><h3 align="center">Date: 2017-07-12</h3><h3 align="center">&lt;asteriskteam@digium.com&gt;</h3><hr><h2 align="center">Table of Contents</h2><ol>
+<li><a href="#summary">Summary</a></li>
+<li><a href="#contributors">Contributors</a></li>
+<li><a href="#closed_issues">Closed Issues</a></li>
+<li><a href="#open_issues">Open Issues</a></li>
+<li><a href="#commits">Other Changes</a></li>
+<li><a href="#diffstat">Diffstat</a></li>
+</ol><hr><a name="summary"><h2 align="center">Summary</h2></a><center><a href="#top">[Back to Top]</a></center><p>This release is a point release of an existing major version. The changes included were made to address problems that have been identified in this release series, or are minor, backwards compatible new features or improvements. Users should be able to safely upgrade to this version if this release series is already in use. Users considering upgrading from a previous version are strongly encouraged to review the UPGRADE.txt document as well as the CHANGES document for information about upgrading to this release series.</p><p>The data in this summary reflects changes that have been made since the previous release, asterisk-13.16.0.</p><hr><a name="contributors"><h2 align="center">Contributors</h2></a><center><a href="#top">[Back to Top]</a></center><p>This table lists the people who have submitted code, those that have tested patches, as well as those that reported issues on the issue tracker that were resolved in this release. For coders, the number is how many of their patches (of any size) were committed into this release. For testers, the number is the number of times their name was listed as assisting with testing a patch. Finally, for reporters, the number is the number of issues that they reported that were affected by commits that went into this release.</p><table width="100%" border="0">
+<tr><th width="33%">Coders</th><th width="33%">Testers</th><th width="33%">Reporters</th></tr>
+<tr valign="top"><td width="33%">17 Sean Bright <sean.bright@gmail.com><br/>12 George Joseph <gjoseph@digium.com><br/>10 Joshua Colp <jcolp@digium.com><br/>9 Alexei Gradinari <alex2grad@gmail.com><br/>5 Richard Mudgett <rmudgett@digium.com><br/>5 Kevin Harwell <kharwell@digium.com><br/>2 Torrey Searle <tsearle@gmail.com><br/>2 Guido Falsi <madpilot@freebsd.org><br/>2 Alexander Traud <pabstraud@compuserve.com><br/>1 Jan Friesse <jfriesse@redhat.com><br/>1 Florian Floimair <f.floimair@commend.com><br/>1 Ivan Poddubny <ivan.poddubny@gmail.com><br/>1 Matthew Fredrickson <creslin@digium.com><br/>1 Yasin CANER <yasin.caner@netgsm.com.tr><br/>1 David M. Lee <dlee@digium.com><br/>1 Robert Mordec <r.mordec@slican.pl><br/>1 Jørgen H <asterisk.org@hovland.cx><br/>1 Rodrigo Ramirez Norambuena <a@rodrigoramirez.com><br/>1 Frederic LE FOLL <frederic.lefoll@c-s.fr><br/>1 Corey Farrell <git@cfware.com><br/></td><td width="33%"><td width="33%">4 Alexei Gradinari <alex2grad@gmail.com><br/>4 Joshua Colp <jcolp@digium.com><br/>3 Kevin Harwell <kharwell@digium.com><br/>3 Louis Jocelyn Paquet <ljpaquet@quebecinternet.net><br/>3 Tzafrir Cohen <tzafrir.cohen@xorcom.com><br/>3 George Joseph <gjoseph@digium.com><br/>2 Guido Falsi <madpilot@freebsd.org><br/>2 Alexander Traud <pabstraud@compuserve.com><br/>2 Michael Walton <mike@farsouthnet.com><br/>2 Torrey Searle <tsearle@gmail.com><br/>1 Rusty Newton <rnewton@digium.com><br/>1 Matthew Fredrickson <creslin@digium.com><br/>1 Jacek Konieczny <jkonieczny@eggsoft.pl><br/>1 Tim Morgan <morganuci@gmail.com><br/>1 Etienne Allovon <eallovon@avencall.com><br/>1 alex <asterisk@maximum.guru><br/>1 Kinsey Moore <kmoore@digium.com><br/>1 John Harris <john.harris@certus-tech.com><br/>1 Javier Riveros  <goseeped@gmail.com><br/>1 Sean Bright <sean.bright@gmail.com><br/>1 Robert Mordec <r.mordec@slican.pl><br/>1 Ross Beer <ross.beer@voicehost.co.uk><br/>1 Chris Howard <choward@digium.com><br/>1 mdu113 <mulitskiy@acedsl.com><br/>1 Andrew Nowrot <andrew.nowrot@gmail.com><br/>1 'alex'<br/>1 Lorne Gaetz <lgaetz@gmail.com><br/>1 Ben Langfeld <ben@langfeld.me><br/>1 John Fawcett <john@voipsupport.it><br/>1 Corey Farrell <git@cfware.com><br/>1 Frankie Chin <fchin@biamp.com><br/>1 Zach R <zrothy@monmouth.com><br/>1 Matthias Binder <it@mitterhuemer.at><br/>1 Christopher van de Sande <cvandesande@opendmz.com><br/>1 Stefan Engström <stefanen@kth.se><br/>1 Antoine Pitrou <pitrou@free.fr><br/>1 Alex <metsys@gmx.com><br/>1 Etienne Lessard <elessard97@gmail.com><br/>1 Ryan Smith <ryan.smith@tekara.co.uk><br/>1 Michael Maier <m1278468@mailbox.org><br/>1 OpenBSD ports<br/>1 Marek Cervenka <marek.cervenka@gmail.com><br/>1 Ronald Raikes <reraikes@avweb.com><br/>1 Ove Aursand <oveaurs@gmail.com><br/>1 Richard Mudgett <rmudgett@digium.com><br/>1 Frederic LE FOLL <frederic.lefoll@c-s.fr><br/>1 wushumasters <wushumasters@gmail.com><br/>1 Tony Mountifield <tony@softins.co.uk><br/>1 Jørgen H <asterisk.org@hovland.cx><br/>1 Michel R. Vaillancourt <michel@jkl5group.com><br/>1 David Brillert <david_brillert@scopserv.com><br/>1 Yasin CANER <yasin.caner@netgsm.com.tr><br/></td></tr>
+</table><hr><a name="closed_issues"><h2 align="center">Closed Issues</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a list of all issues from the issue tracker that were closed by changes that went into this release.</p><h3>Bug</h3><h4>Category: Addons/format_mp3</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-23951">ASTERISK-23951</a>:  Asterisk attempts and fails to build format_mp3 even if mp3lib was not downloaded<br/>Reported by: Tzafrir Cohen<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=97b003f5e2d4a350508fc20173e180a23f8ef525">[97b003f5e2]</a> Sean Bright -- format_mp3: Re-work menuselect/build issues</li>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=72213c98e3d4d5287ed321f1b4fb67087a7a129c">[72213c98e3]</a> Sean Bright -- format_mp3: Don't try to build format_mp3 if we don't have sources</li>
+</ul><br><h4>Category: Applications/app_confbridge</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27012">ASTERISK-27012</a>: app_confbridge: ConfBridge sometimes does not play user name recording while leaving<br/>Reported by: Robert Mordec<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=f1b32de2c5fb8854183f0c7d8c9df7470ab9c140">[f1b32de2c5]</a> Robert Mordec -- app_confbridge: Race between removing and playing name recording while leaving</li>
+</ul><br><h4>Category: Applications/app_meetme</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27025">ASTERISK-27025</a>: channel / meetme: Fix missing parentheses<br/>Reported by: Joshua Colp<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=dc05183f4b7d728534ec6fa5f3fc21802396aabf">[dc05183f4b]</a> Joshua Colp -- channel / app_meetme: Fix parentheses.</li>
+</ul><br><h4>Category: Applications/app_queue</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25665">ASTERISK-25665</a>: Duplicate logging in queue log for EXITEMPTY events<br/>Reported by: Ove Aursand<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=2c43ca0ac50764ab17d691844a84158bbf590b0e">[2c43ca0ac5]</a> Ivan Poddubny -- app_queue: Fix returning to dialplan when a queue is empty</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27065">ASTERISK-27065</a>: call hangup after leaving app_queue<br/>Reported by: Marek Cervenka<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=2c43ca0ac50764ab17d691844a84158bbf590b0e">[2c43ca0ac5]</a> Ivan Poddubny -- app_queue: Fix returning to dialplan when a queue is empty</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26399">ASTERISK-26399</a>: app_queue: Agent not called when caller is parked<br/>Reported by: wushumasters<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6bfcb1acc7ae53d50e1b784b4d46c588744aae8b">[6bfcb1acc7]</a> Joshua Colp -- app_queue: Fix members showing as being in call when not.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26400">ASTERISK-26400</a>: app_queue: Queue member stops being called after AMI "Redirect" action for queues with wrapuptime<br/>Reported by: Etienne Lessard<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6bfcb1acc7ae53d50e1b784b4d46c588744aae8b">[6bfcb1acc7]</a> Joshua Colp -- app_queue: Fix members showing as being in call when not.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26715">ASTERISK-26715</a>: app_queue: Member will not receive any new calls after doing a transfer if wrapuptime = greater than 0 and using Local channel<br/>Reported by: David Brillert<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6bfcb1acc7ae53d50e1b784b4d46c588744aae8b">[6bfcb1acc7]</a> Joshua Colp -- app_queue: Fix members showing as being in call when not.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26975">ASTERISK-26975</a>: app_queue: Non-zero wrapup time can cause agents not to receive queue calls after transfer queue call<br/>Reported by: Lorne Gaetz<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6bfcb1acc7ae53d50e1b784b4d46c588744aae8b">[6bfcb1acc7]</a> Joshua Colp -- app_queue: Fix members showing as being in call when not.</li>
+</ul><br><h4>Category: Applications/app_voicemail/IMAP</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-24052">ASTERISK-24052</a>: app_voicemail reloads result in leaked IMAP sockets.<br/>Reported by: Louis Jocelyn Paquet<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=8f356192d196ae146b0c2390f8d62024694e691f">[8f356192d1]</a> Alexei Gradinari -- app_voicemail: IMAP connection control</li>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=3b6c327c515944d74aa798f385e01768a4bb04c2">[3b6c327c51]</a> Alexei Gradinari -- app_voicemail: IMAP logout on reload/unload</li>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=08be5e01e8ab72a7e9e80525e20967467a6df99b">[08be5e01e8]</a> Alexei Gradinari -- app_voicemail: IMAP logout on MWI unsubscribe</li>
+</ul><br><h4>Category: Bridges/bridge_simple</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26973">ASTERISK-26973</a>: bridge: Crash when freeing frame and snooping<br/>Reported by: Michel R. Vaillancourt<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=adfb28882bfd2055d8b54705805db573d8ce6c94">[adfb28882b]</a> Kevin Harwell -- channel: ast_write frame wrongly freed after call to audiohooks</li>
+</ul><br><h4>Category: Channels/chan_pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27039">ASTERISK-27039</a>: chan_pjsip: Device state is idle when channel from endpoint is in early media<br/>Reported by: Joshua Colp<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=1f10c6b3b044f9979c523f65f449670047dcb57f">[1f10c6b3b0]</a> Joshua Colp -- chan_pjsip: Update device state when in early media.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26996">ASTERISK-26996</a>: chan_pjsip: Flipping between codecs<br/>Reported by: Michael Maier<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=996a4791ff123e80d71d44cb0fd13bb201d197b1">[996a4791ff]</a> Joshua Colp -- pjsip: Extend 'asymmetric_rtp_codec' option to include us changing.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26281">ASTERISK-26281</a>: chan_pjsip would send INVITE to 'Unreachable' endpoints<br/>Reported by: Jacek Konieczny<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=746c2c574578608a6b48d4794ba33cda5a6dd484">[746c2c5745]</a> Joshua Colp -- res_pjsip: Add support for returning only reachable contacts and use it.</li>
+</ul><br><h4>Category: Channels/chan_sip/General</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27106">ASTERISK-27106</a>: [patch] autodomain (SIP Domain Support): Add only really different domain with TLS.<br/>Reported by: Alexander Traud<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=39d2ebbf56635355432eb96ff850c0c9bf2a5d63">[39d2ebbf56]</a> Alexander Traud -- chan_sip: Only when different, add TCP|TLS in autodomain (SIP Domain Support).</li>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=9f4b3b966e911fae157a484d8f4a1440130eede6">[9f4b3b966e]</a> Alexander Traud -- chan_sip: Fix a typo for tlsbindaddr in autodomain (SIP Domain Support).</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26982">ASTERISK-26982</a>: chan_sip: rtcp_mux setting may cause ice completion failure/delay if client offers rtcp-mux as negotiable<br/>Reported by: Stefan Engström<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=4479038073e57a67c19c1ec5dc8896fcc8c3a0fb">[4479038073]</a> Sean Bright -- chan_sip: Better ICE handling for RTCP-MUX</li>
+</ul><br><h4>Category: Channels/chan_sip/SRTP</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25101">ASTERISK-25101</a>: DTLS configuration can not be specified in the general section - documentation<br/>Reported by: Ben Langfeld<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=971a401ce95ed0f566b2e90a52d69d0274c63ff8">[971a401ce9]</a> Sean Bright -- sip.conf.sample: Clarify where DTLS settings are permitted</li>
+</ul><br><h4>Category: Codecs/General</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-24858">ASTERISK-24858</a>: [patch]Asterisk 13 PJSIP sends RTP packets in wrong byte order on Intel platform when using slin codec<br/>Reported by: Frankie Chin<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=70e5887906db8d585892409cde89e5e28111549a">[70e5887906]</a> Sean Bright -- format: Reintroduce smoother flags</li>
+</ul><br><h4>Category: Core/Bridging</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27075">ASTERISK-27075</a>: bridge: stuck channel(s) after failed attended transfer<br/>Reported by: Kevin Harwell<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=67664fbf95a00ced30f8791fd1089b4595e29479">[67664fbf95]</a> Kevin Harwell -- bridge: stuck channel(s) after failed attended transfer</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26923">ASTERISK-26923</a>: bridging: T.38 request is lost when channels are added to bridge<br/>Reported by: Torrey Searle<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=e414833f6e77345f4969116972e9cf1ad9b595fd">[e414833f6e]</a> Joshua Colp -- bridge: Add a deferred queue.</li>
+</ul><br><h4>Category: Core/Channels</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27100">ASTERISK-27100</a>: channel: ast_waitfordigit_full fails to clear flag in an error branch.<br/>Reported by: Corey Farrell<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=73520e9f58857049a086fb88106e342cdc25d3a1">[73520e9f58]</a> Corey Farrell -- channel: Clear channel flag in error branch.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27074">ASTERISK-27074</a>: core_local: local channel data not being properly unref'ed and unlocked<br/>Reported by: Kevin Harwell<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=1f9913f2723cbcbf6d78f4da7ee4dd4decc13c05">[1f9913f272]</a> Kevin Harwell -- core_local: local channel data not being properly unref'ed and unlocked</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26923">ASTERISK-26923</a>: bridging: T.38 request is lost when channels are added to bridge<br/>Reported by: Torrey Searle<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=e414833f6e77345f4969116972e9cf1ad9b595fd">[e414833f6e]</a> Joshua Colp -- bridge: Add a deferred queue.</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27025">ASTERISK-27025</a>: channel / meetme: Fix missing parentheses<br/>Reported by: Joshua Colp<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=dc05183f4b7d728534ec6fa5f3fc21802396aabf">[dc05183f4b]</a> Joshua Colp -- channel / app_meetme: Fix parentheses.</li>
+</ul><br><h4>Category: Core/General</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26789">ASTERISK-26789</a>: Audit manipulation of channel flags without locks<br/>Reported by: Joshua Colp<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=161820396495a549c9a378d32136cbb5f28ef2af">[1618203964]</a> Joshua Colp -- asterisk: Audit locking of channel when manipulating flags.</li>
+</ul><br><h4>Category: Core/PBX</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27041">ASTERISK-27041</a>: Core/PBX: [patch] Deadlock between dialplan execution and application unregistration<br/>Reported by: Frederic LE FOLL<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=dc307af7f2ed653914aeadb0b7e613cb4e239b06">[dc307af7f2]</a> Frederic LE FOLL -- Core/PBX: Deadlock between dialplan execution and application unregistration.</li>
+</ul><br><h4>Category: Core/RTP</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26978">ASTERISK-26978</a>: rtp: Crash in ast_rtp_codecs_payload_code()<br/>Reported by: Ross Beer<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=eb48e99bd4f4556424a6799e2e5f7aebf8911e8d">[eb48e99bd4]</a> George Joseph -- bridge_native_rtp: Keep rtp instance refs on bridge_channel</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-24858">ASTERISK-24858</a>: [patch]Asterisk 13 PJSIP sends RTP packets in wrong byte order on Intel platform when using slin codec<br/>Reported by: Frankie Chin<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=70e5887906db8d585892409cde89e5e28111549a">[70e5887906]</a> Sean Bright -- format: Reintroduce smoother flags</li>
+</ul><br><h4>Category: Core/Sorcery</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27057">ASTERISK-27057</a>: Seg Fault in ast_sorcery_object_get_id at sorcery.c<br/>Reported by: Ryan Smith<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=c2eea791e4178e5f2e4446a5f70d81ac27cf2a0e">[c2eea791e4]</a> George Joseph -- res_pjsip_pubsub:  Fix reference to released endpoint</li>
+</ul><br><h4>Category: Documentation</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-23839">ASTERISK-23839</a>: AGI - RECORD FILE - documentation doesn't describe BEEP argument<br/>Reported by: Rusty Newton<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=3eb7fbba72482b3019a7493c68e533e67d9d8235">[3eb7fbba72]</a> Sean Bright -- res_agi: Clarify 'RECORD FILE' documentation</li>
+</ul><br><h4>Category: General</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27108">ASTERISK-27108</a>: Crash using 'data get' CLI command<br/>Reported by: Sean Bright<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6258de458b2e6ba02e91ed67bbd2801f0984526a">[6258de458b]</a> Sean Bright -- core: Fix segfault when invoking 'data get' CLI command</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27060">ASTERISK-27060</a>: Comment typo format_g729.c<br/>Reported by: Matthew Fredrickson<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=0a40073750b46ae28ddf1041d5ed3ab57151298e">[0a40073750]</a> Matthew Fredrickson -- formats/format_g729: Fix typo in comment</li>
+</ul><br><h4>Category: PBX/pbx_realtime</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-19291">ASTERISK-19291</a>: Background in realtime<br/>Reported by: Andrew Nowrot<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=283cc59af746896a2b2bc23899fc86118895f7c0">[283cc59af7]</a> Sean Bright -- pbx_builtin: Properly handle hangup during Background</li>
+</ul><br><h4>Category: Resources/res_agi</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-23839">ASTERISK-23839</a>: AGI - RECORD FILE - documentation doesn't describe BEEP argument<br/>Reported by: Rusty Newton<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=3eb7fbba72482b3019a7493c68e533e67d9d8235">[3eb7fbba72]</a> Sean Bright -- res_agi: Clarify 'RECORD FILE' documentation</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-22432">ASTERISK-22432</a>: Async AGI crashes Asterisk when issuing "set variable" command without args<br/>Reported by: Antoine Pitrou<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=f306e451f6f905a2bb74c15cb844735c244a7610">[f306e451f6]</a> Sean Bright -- res_agi: Prevent crash when SET VARIABLE called without arguments</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25662">ASTERISK-25662</a>: Malformed AGI 520 Usage response<br/>Reported by: Tony Mountifield<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=a007e438c36960d4179e2f188767e7ae14a204d1">[a007e438c3]</a> Sean Bright -- res_agi: Fix malformed AGI usage response</li>
+</ul><br><h4>Category: Resources/res_ari</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27026">ASTERISK-27026</a>: res_ari: Crash when no ari.conf configuration file exists<br/>Reported by: Ronald Raikes<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=7901b9853e8f60e1d2dce44ce81dec6f7f866ccc">[7901b9853e]</a> George Joseph -- res_ari:  Add "module loaded" check to ari stubs</li>
+</ul><br><h4>Category: Resources/res_ari_recordings</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27021">ASTERISK-27021</a>: GET /recordings/stored returns 500 Internal Server Error<br/>Reported by: Tim Morgan<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=cf6cf59646f52dc3de12dac16c3c3824ce9ae927">[cf6cf59646]</a> Sean Bright -- stasis_recording: Correct ast_asprintf error checking</li>
+</ul><br><h4>Category: Resources/res_format_attr_h264</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27008">ASTERISK-27008</a>: res_format_attr_h264: SDP parse fails if fmtp optional parameters have a space<br/>Reported by: John Harris<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=700ef6861ab966008ca16e5f23c64eb68b047c08">[700ef6861a]</a> Sean Bright -- res_format_attr_h26x: Trim blanks in fmtp attributes</li>
+</ul><br><h4>Category: Resources/res_parking</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26399">ASTERISK-26399</a>: app_queue: Agent not called when caller is parked<br/>Reported by: wushumasters<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6bfcb1acc7ae53d50e1b784b4d46c588744aae8b">[6bfcb1acc7]</a> Joshua Colp -- app_queue: Fix members showing as being in call when not.</li>
+</ul><br><h4>Category: Resources/res_pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27090">ASTERISK-27090</a>: PJSIP: Deadlock using TCP transport<br/>Reported by: Richard Mudgett<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=0d64cbde5756eaa1c7ee62116e112b7ebd198bbe">[0d64cbde57]</a> Richard Mudgett -- pjsip_distributor.c: Fix deadlock with TCP type transports.</li>
+</ul><br><h4>Category: Resources/res_pjsip/Bundling</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27052">ASTERISK-27052</a>: Asterisk build process fails with flag --with-pjproject-bundled with curl download command and slow network<br/>Reported by: alex<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=0bde568669ac26735c1058115ae96223a7e69a6b">[0bde568669]</a> George Joseph -- pjproject_bundled:  Use the asterisk github mirror for download</li>
+</ul><br><h4>Category: Resources/res_pjsip_refer</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27053">ASTERISK-27053</a>: res_pjsip_refer/session: Calls dropped during transfer<br/>Reported by: Kevin Harwell<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6cdf3191d3538b2e9a1aec31580db1e01d73d5ef">[6cdf3191d3]</a> Kevin Harwell -- res_pjsip_refer/session: Calls dropped during transfer</li>
+</ul><br><h4>Category: Resources/res_pjsip_session</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27024">ASTERISK-27024</a>: nat/external_media settings ignored in 14.4.1<br/>Reported by: Christopher van de Sande<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=2dee95cc7a280d0ab84c778bf44a76aa62ac758b">[2dee95cc7a]</a> Florian Floimair -- res_pjsip_session:  Correct inverted test in session_outgoing_nat_hook</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27053">ASTERISK-27053</a>: res_pjsip_refer/session: Calls dropped during transfer<br/>Reported by: Kevin Harwell<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6cdf3191d3538b2e9a1aec31580db1e01d73d5ef">[6cdf3191d3]</a> Kevin Harwell -- res_pjsip_refer/session: Calls dropped during transfer</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26964">ASTERISK-26964</a>: res_pjsip_session: Wrong From on reinvite when request and To URI differ<br/>Reported by: Yasin CANER<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=36628cc9c474b52b134a415803b14f87e420dce6">[36628cc9c4]</a> Yasin CANER -- res_pjsip_session : fixed wrong From Header number On Re-invite</li>
+</ul><br><h4>Category: Resources/res_pjsip_transport_websocket</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27046">ASTERISK-27046</a>: res_pjsip_transport_websocket: segfault in get_write_timeout<br/>Reported by: Jørgen H<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=e16a669c70c5a93bb9a38c218a5348cd62bd780a">[e16a669c70]</a> Jørgen H -- res_pjsip_transport_websocket: Add NULL check in get_write_timeout</li>
+</ul><br><h4>Category: Resources/res_rtp_asterisk</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27022">ASTERISK-27022</a>: res_rtp_asterisk: Incorrect SSRC change for RTCP component<br/>Reported by: Michael Walton<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=7dafe82751fd512d58bb3843601daff013958dd2">[7dafe82751]</a> George Joseph -- res_rtp_asterisk:  Fix ssrc change for rtcp srtp</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-24858">ASTERISK-24858</a>: [patch]Asterisk 13 PJSIP sends RTP packets in wrong byte order on Intel platform when using slin codec<br/>Reported by: Frankie Chin<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=70e5887906db8d585892409cde89e5e28111549a">[70e5887906]</a> Sean Bright -- format: Reintroduce smoother flags</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25101">ASTERISK-25101</a>: DTLS configuration can not be specified in the general section - documentation<br/>Reported by: Ben Langfeld<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=971a401ce95ed0f566b2e90a52d69d0274c63ff8">[971a401ce9]</a> Sean Bright -- sip.conf.sample: Clarify where DTLS settings are permitted</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26979">ASTERISK-26979</a>: res_rtp_asterisk: SRTP unprotect failed with authentication failure 10 or 110<br/>Reported by: Javier Riveros <ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=e91efef2bb35cd0b03f45ad1b1ba43203948368d">[e91efef2bb]</a> Kevin Harwell -- res_rtp_asterisk: rtcp mux using the wrong srtp unprotecting algorithm</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26982">ASTERISK-26982</a>: chan_sip: rtcp_mux setting may cause ice completion failure/delay if client offers rtcp-mux as negotiable<br/>Reported by: Stefan Engström<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=4479038073e57a67c19c1ec5dc8896fcc8c3a0fb">[4479038073]</a> Sean Bright -- chan_sip: Better ICE handling for RTCP-MUX</li>
+</ul><br><h4>Category: Resources/res_srtp</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25294">ASTERISK-25294</a>: srtp's crypto_get_random deprecated<br/>Reported by: Tzafrir Cohen<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=5e9cd1f20d86de1c25b7a9accffb7d3e2601878b">[5e9cd1f20d]</a> Sean Bright -- res_srtp: Add support for libsrtp2</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25101">ASTERISK-25101</a>: DTLS configuration can not be specified in the general section - documentation<br/>Reported by: Ben Langfeld<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=971a401ce95ed0f566b2e90a52d69d0274c63ff8">[971a401ce9]</a> Sean Bright -- sip.conf.sample: Clarify where DTLS settings are permitted</li>
+</ul><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26979">ASTERISK-26979</a>: res_rtp_asterisk: SRTP unprotect failed with authentication failure 10 or 110<br/>Reported by: Javier Riveros <ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=e91efef2bb35cd0b03f45ad1b1ba43203948368d">[e91efef2bb]</a> Kevin Harwell -- res_rtp_asterisk: rtcp mux using the wrong srtp unprotecting algorithm</li>
+</ul><br><h4>Category: Resources/res_stasis_snoop</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26973">ASTERISK-26973</a>: bridge: Crash when freeing frame and snooping<br/>Reported by: Michel R. Vaillancourt<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=adfb28882bfd2055d8b54705805db573d8ce6c94">[adfb28882b]</a> Kevin Harwell -- channel: ast_write frame wrongly freed after call to audiohooks</li>
+</ul><br><h4>Category: pjproject/pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26333">ASTERISK-26333</a>: Problems with Blind Transfer, PJSIP (Aastra 6869i)<br/>Reported by: Matthias Binder<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6af2dd34afc2c20bdabd07bc3836821690db4c86">[6af2dd34af]</a> Alexei Gradinari -- res_pjsip: New endpoint option "refer_blind_progress"</li>
+</ul><br><h3>Improvement</h3><h4>Category: Core/BuildSystem</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27043">ASTERISK-27043</a>: Core/BuildSystem: Add defines to fix build with LibreSSL<br/>Reported by: Guido Falsi<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6a64f65fe6fee96702668bdd3344233f19232850">[6a64f65fe6]</a> Guido Falsi -- BuildSystem: Add patches to allow building with recent LibreSSL</li>
+</ul><br><h4>Category: Core/Channels</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26419">ASTERISK-26419</a>: audiohooks: Remove redundant codec translations when using audiohooks<br/>Reported by: Michael Walton<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=adfb28882bfd2055d8b54705805db573d8ce6c94">[adfb28882b]</a> Kevin Harwell -- channel: ast_write frame wrongly freed after call to audiohooks</li>
+</ul><br><h4>Category: Core/General</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26419">ASTERISK-26419</a>: audiohooks: Remove redundant codec translations when using audiohooks<br/>Reported by: Michael Walton<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=adfb28882bfd2055d8b54705805db573d8ce6c94">[adfb28882b]</a> Kevin Harwell -- channel: ast_write frame wrongly freed after call to audiohooks</li>
+</ul><br><h4>Category: Core/Portability</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27042">ASTERISK-27042</a>: Unpatched asterisk sources fail to build on FreeBSD due to missing crypt.h file<br/>Reported by: Guido Falsi<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=44cee2f4a15db911d2c9bdd6f845d17a1e6c6c17">[44cee2f4a1]</a> Guido Falsi -- BuildSystem: Fix build on FreeBSD due to missing crypt.h</li>
+</ul><br><h4>Category: Resources/res_agi</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26124">ASTERISK-26124</a>: res_agi: Set audio format for EAGI audio stream<br/>Reported by: John Fawcett<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=90237dca11d0adf129198cef4a6a0716a52618b5">[90237dca11]</a> Sean Bright -- res_agi: Allow configuration of audio format of EAGI pipe</li>
+</ul><br><h4>Category: Resources/res_pjsip_mwi</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26230">ASTERISK-26230</a>: [patch] res_pjsip_mwi: unsolicited mwi could block PJSIP taskprocessor on startup<br/>Reported by: Alexei Gradinari<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=0f6a9617eb44a8d59b5828cd860d3852cc824ce9">[0f6a9617eb]</a> Alexei Gradinari -- res_pjsip_mwi: update unsolicited MWI subscriptions on updating contact</li>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=59c9bbe6961a5677ddb13eed2a130d16b6ffc0ee">[59c9bbe696]</a> Alexei Gradinari -- res_pjsip_mwi: don't create mwi subscriptions if initial unsolicited disabled</li>
+</ul><br><h4>Category: Resources/res_rtp_asterisk</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26976">ASTERISK-26976</a>: libsrtp-2.x.x support<br/>Reported by: Alex<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=5e9cd1f20d86de1c25b7a9accffb7d3e2601878b">[5e9cd1f20d]</a> Sean Bright -- res_srtp: Add support for libsrtp2</li>
+</ul><br><hr><a name="open_issues"><h2 align="center">Open Issues</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a list of all open issues from the issue tracker that were referenced by changes that went into this release.</p><h3>Bug</h3><h4>Category: Bridges/bridge_simple</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26469">ASTERISK-26469</a>: Infinite loop after a dual Redirect<br/>Reported by: Etienne Allovon<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=b07b2162359ccc9a3f84324fabce18b6ad63eee3">[b07b216235]</a> Joshua Colp -- manager: Clear the flag on the other channel.</li>
+</ul><br><h4>Category: Channels/chan_pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27095">ASTERISK-27095</a>: chan_pjsip: When connected_line_method is set to invite, we're not trying UPDATE<br/>Reported by: George Joseph<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=6bd7c0f37cb7b513d1333717ece0118bd8875546">[6bd7c0f37c]</a> George Joseph -- chan_pjsip:  Fix ability to send UPDATE on COLP</li>
+</ul><br><h4>Category: Core/Bridging</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27016">ASTERISK-27016</a>: Crash occurs when a channel in a 'mixing,dtmf_events' bridge is muted multiple times.<br/>Reported by: Chris Howard<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=4910a3bf402baddf8ed72badfaed7ae64da48686">[4910a3bf40]</a> Joshua Colp -- channel: Fix reference counting in ast_channel_suppress.</li>
+</ul><br><h4>Category: General</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27088">ASTERISK-27088</a>: res_rtp_asterisk: Better handle ICE renegotiation and unidirectional negotiation<br/>Reported by: Joshua Colp<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=0426b1d88ab97c4fc1b2b27f8da93b28096f2dfc">[0426b1d88a]</a> Joshua Colp -- res_rtp_asterisk: Fix issues with ICE renegotiation.</li>
+</ul><br><h4>Category: Resources/res_corosync</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-25370">ASTERISK-25370</a>: res_corosync segfaults at startup with corosync version > 2.x<br/>Reported by: mdu113<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=005a4afa6b0e710e11b47b11cfc152b028c596fc">[005a4afa6b]</a> Jan Friesse -- res_corosync: Change thread stack size</li>
+</ul><br><h4>Category: Resources/res_pjsip_dialog_info_body_generator</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26919">ASTERISK-26919</a>: res_pjsip_dialog_info_body_generator: Ringing&&InUse behavior difference between chan_sip and res_pjsip<br/>Reported by: Zach R<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=a6e4899612ca71bc3c9180dadea0c0117e8ae462">[a6e4899612]</a> Alexei Gradinari -- res_pjsip: New endpoint option "notify_early_inuse_ringing"</li>
+</ul><br><h4>Category: Resources/res_pjsip_mwi</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27051">ASTERISK-27051</a>: res_pjsip_mwi: unsolicited MWI has to be unsubscribed on deleting the endpoint's last contact<br/>Reported by: Alexei Gradinari<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=8e749c8f51c20fb13bfe93e969cf02d7e74cdb27">[8e749c8f51]</a> Alexei Gradinari -- res_pjsip_mwi: unsubscribe unsolicited MWI on deleting endpoint last contact</li>
+</ul><br><h4>Category: Resources/res_stasis</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27059">ASTERISK-27059</a>: res_stasis: Stolen channel references are leaking<br/>Reported by: George Joseph<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=edfdb4dff5d8438bdb1dfb526c57618944ea6bf3">[edfdb4dff5]</a> George Joseph -- res_stasis:  Plug reference leak on stolen channels</li>
+</ul><br><h4>Category: Third-Party/pjproject</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27097">ASTERISK-27097</a>: pjproject_bundled:  We don't pass options needed for cross-compile to pjproject configure<br/>Reported by: George Joseph<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=bbe68f139db525b2d922f63d8452d9732fb5f1b9">[bbe68f139d]</a> George Joseph -- pjproject_bundled:  Allow passing configure options to bundled</li>
+</ul><br><h3>Improvement</h3><h4>Category: Applications/app_voicemail/IMAP</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27068">ASTERISK-27068</a>: app_voicemail: Add global option "imap_poll_logout" to specify post-polling disconnect<br/>Reported by: Alexei Gradinari<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=8f356192d196ae146b0c2390f8d62024694e691f">[8f356192d1]</a> Alexei Gradinari -- app_voicemail: IMAP connection control</li>
+</ul><br><h4>Category: Channels/chan_pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27066">ASTERISK-27066</a>: res_pjsip: Add DTMF INFO Failback mode<br/>Reported by: Torrey Searle<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=9fbc34d2bd5393d93d8b3b3a8c6daa895c2e9633">[9fbc34d2bd]</a> Torrey Searle -- res_pjsip:  Add DTMF INFO Failback mode</li>
+</ul><br><h4>Category: Resources/res_pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-27066">ASTERISK-27066</a>: res_pjsip: Add DTMF INFO Failback mode<br/>Reported by: Torrey Searle<ul>
+<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=9fbc34d2bd5393d93d8b3b3a8c6daa895c2e9633">[9fbc34d2bd]</a> Torrey Searle -- res_pjsip:  Add DTMF INFO Failback mode</li>
+</ul><br><hr><a name="commits"><h2 align="center">Commits Not Associated with an Issue</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a list of all changes that went into this release that did not reference a JIRA issue.</p><table width="100%" border="1">
+<tr><th>Revision</th><th>Author</th><th>Summary</th></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=0c00ee754b436ca926b92b469ce259e8fdc8732e">0c00ee754b</a></td><td>George Joseph</td><td>Update for 13.17.0-rc1</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=379fe658312e11699ff8c8e8a463e31b3c277237">379fe65831</a></td><td>George Joseph</td><td>Fix alembic branches</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=905d18e8bf52ea7657acaaf2ec0cbe58531fb625">905d18e8bf</a></td><td>Richard Mudgett</td><td>pjsip_distributor.c: Fix unidentified_requests hash functions.</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=1f59d08924bc676970cabc6f3e291c7d1d2f2707">1f59d08924</a></td><td>Torrey Searle</td><td>res/res_pjsip_t38: fix incorrect increment of media_count</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=764d04fa8705d9e5c2e7aee8a6f1c774d7d28595">764d04fa87</a></td><td>Richard Mudgett</td><td>res_pjsip_mwi.c: Eliminate RAII_VAR in contact delete observer</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=cecf6540dc4779598289f711340bb966bbfcc6aa">cecf6540dc</a></td><td>Rodrigo Ramírez Norambuena</td><td>cdr: fix mistake spelling of a word for Unanswered.</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=b9a4ab8c8c00c8d53584d6f7e31729b5027c8dd6">b9a4ab8c8c</a></td><td>Richard Mudgett</td><td>chan_pjsip: Fix PJSIP_MEDIA_OFFER dialplan function read.</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=f1a209d5ac8f8b7fe96e54d6aba55dbf0dbb1403">f1a209d5ac</a></td><td>Richard Mudgett</td><td>app_voicemail.c: Fix compile error when IMAP enabled.</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=68de35a6a01e2a1fe732e156b73f800bb672a421">68de35a6a0</a></td><td>David M. Lee</td><td>CFLAGS for BIND8 support</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=da3312457e6cf1c0d7bc8cb2a4aba57877fb5afc">da3312457e</a></td><td>Sean Bright</td><td>codecs.conf.sample: Fix max_bandwidth speling error</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=590ffcaf0b03bbe3d25730ad750a2075a46c7208">590ffcaf0b</a></td><td>Sean Bright</td><td>eventfd: Disable during cross compilation</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=5520b6c201875133a73db5a2c88b5fc5b78864bb">5520b6c201</a></td><td>Alexei Gradinari</td><td>CHANGES: correct version for a new option 'refer_blind_progress'</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=c093bf8072ff65bf29d290c1330291c460cd7fdf">c093bf8072</a></td><td>Sean Bright</td><td>res_rtp_multicast: Use consistent timestamps when possible</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=c10341646d353922b4ee92c77fc4e5560d263c73">c10341646d</a></td><td>George Joseph</td><td>test_json:  Fix test names with reserved words</td></tr>
+<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=65898c3af82e2d780a48d9d50d3b1c952c208a89">65898c3af8</a></td><td>George Joseph</td><td>unittests:  Add a unit test that causes a SEGV and...</td></tr>
+</table><hr><a name="diffstat"><h2 align="center">Diffstat Results</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a summary of the changes to the source code that went into this release that was generated using the diffstat utility.</p><pre>asterisk-13.16.0-summary.html                                                                   |  405 ---
+asterisk-13.16.0-summary.txt                                                                    |  952 ---------
+b/.version                                                                                      |    2
+b/CHANGES                                                                                       |   54
+b/ChangeLog                                                                                     | 1045 +++++++++-
+b/Makefile                                                                                      |    3
+b/addons/Makefile                                                                               |   10
+b/apps/app_chanspy.c                                                                            |   16
+b/apps/app_confbridge.c                                                                         |   79
+b/apps/app_dial.c                                                                               |    6
+b/apps/app_disa.c                                                                               |   10
+b/apps/app_dumpchan.c                                                                           |    4
+b/apps/app_externalivr.c                                                                        |    6
+b/apps/app_meetme.c                                                                             |    2
+b/apps/app_queue.c                                                                              |  109 -
+b/apps/app_voicemail.c                                                                          |   80
+b/asterisk-13.17.0-rc1-summary.html                                                             |  311 ++
+b/asterisk-13.17.0-rc1-summary.txt                                                              |  832 +++++++
+b/autoconf/ast_ext_lib.m4                                                                       |   36
+b/bridges/bridge_native_rtp.c                                                                   |  677 +++++-
+b/bridges/bridge_simple.c                                                                       |   32
+b/channels/chan_pjsip.c                                                                         |   68
+b/channels/chan_sip.c                                                                           |    8
+b/channels/pjsip/dialplan_functions.c                                                           |   37
+b/configs/samples/cdr.conf.sample                                                               |    2
+b/configs/samples/codecs.conf.sample                                                            |    6
+b/configs/samples/pjsip.conf.sample                                                             |   20
+b/configs/samples/sip.conf.sample                                                               |    3
+b/configs/samples/voicemail.conf.sample                                                         |    3
+b/configure                                                                                     |  434 +++-
+b/configure.ac                                                                                  |  100
+b/contrib/ast-db-manage/config/versions/164abbd708c_add_auto_info_to_endpoint_dtmf_mode.py      |   58
+b/contrib/ast-db-manage/config/versions/86bb1efa278d_add_ps_endpoints_refer_blind_progress.py   |   30
+b/contrib/ast-db-manage/config/versions/d7983954dd96_add_ps_endpoints_notify_early_inuse_.py    |   30
+b/contrib/realtime/mssql/mssql_config.sql                                                       |   46
+b/contrib/realtime/mysql/mysql_config.sql                                                       |   18
+b/contrib/realtime/oracle/oracle_config.sql                                                     |   46
+b/contrib/realtime/postgresql/postgresql_config.sql                                             |   22
+b/formats/format_g729.c                                                                         |    2
+b/include/asterisk/ari.h                                                                        |   10
+b/include/asterisk/autoconfig.h.in                                                              |    3
+b/include/asterisk/bridge_channel.h                                                             |    2
+b/include/asterisk/bridge_channel_internal.h                                                    |   11
+b/include/asterisk/bridge_technology.h                                                          |    3
+b/include/asterisk/channel.h                                                                    |   25
+b/include/asterisk/codec.h                                                                      |    3
+b/include/asterisk/core_local.h                                                                 |   37
+b/include/asterisk/format.h                                                                     |   11
+b/include/asterisk/res_pjsip.h                                                                  |   74
+b/include/asterisk/res_pjsip_presence_xml.h                                                     |    3
+b/include/asterisk/res_pjsip_session.h                                                          |   11
+b/include/asterisk/rtp_engine.h                                                                 |    9
+b/include/asterisk/smoother.h                                                                   |    1
+b/include/asterisk/test.h                                                                       |    8
+b/main/autoservice.c                                                                            |    2
+b/main/bridge.c                                                                                 |   10
+b/main/bridge_after.c                                                                           |    2
+b/main/bridge_channel.c                                                                         |   38
+b/main/channel.c                                                                                |   90
+b/main/codec_builtin.c                                                                          |   19
+b/main/core_local.c                                                                             |   54
+b/main/crypt.c                                                                                  |    2
+b/main/data.c                                                                                   |    4
+b/main/file.c                                                                                   |   20
+b/main/format.c                                                                                 |    8
+b/main/libasteriskssl.c                                                                         |    4
+b/main/manager.c                                                                                |    8
+b/main/pbx.c                                                                                    |    4
+b/main/pbx_app.c                                                                                |    7
+b/main/pbx_builtins.c                                                                           |    8
+b/main/tcptls.c                                                                                 |    4
+b/main/test.c                                                                                   |    4
+b/makeopts.in                                                                                   |    2
+b/res/res_agi.c                                                                                 |   73
+b/res/res_ari_applications.c                                                                    |    4
+b/res/res_ari_asterisk.c                                                                        |    4
+b/res/res_ari_bridges.c                                                                         |    4
+b/res/res_ari_channels.c                                                                        |    4
+b/res/res_ari_device_states.c                                                                   |    4
+b/res/res_ari_endpoints.c                                                                       |    4
+b/res/res_ari_events.c                                                                          |   33
+b/res/res_ari_mailboxes.c                                                                       |    4
+b/res/res_ari_playbacks.c                                                                       |    4
+b/res/res_ari_recordings.c                                                                      |    4
+b/res/res_ari_sounds.c                                                                          |    4
+b/res/res_corosync.c                                                                            |   29
+b/res/res_format_attr_h263.c                                                                    |    2
+b/res/res_format_attr_h264.c                                                                    |    2
+b/res/res_musiconhold.c                                                                         |    4
+b/res/res_pjsip.c                                                                               |   31
+b/res/res_pjsip/location.c                                                                      |   53
+b/res/res_pjsip/pjsip_configuration.c                                                           |    9
+b/res/res_pjsip/pjsip_distributor.c                                                             |  242 +-
+b/res/res_pjsip/presence_xml.c                                                                  |    9
+b/res/res_pjsip_dialog_info_body_generator.c                                                    |   10
+b/res/res_pjsip_mwi.c                                                                           |   87
+b/res/res_pjsip_pidf_body_generator.c                                                           |    2
+b/res/res_pjsip_pidf_eyebeam_body_supplement.c                                                  |    2
+b/res/res_pjsip_pubsub.c                                                                        |    8
+b/res/res_pjsip_refer.c                                                                         |   28
+b/res/res_pjsip_sdp_rtp.c                                                                       |   38
+b/res/res_pjsip_session.c                                                                       |   37
+b/res/res_pjsip_session.exports.in                                                              |    1
+b/res/res_pjsip_t38.c                                                                           |    2
+b/res/res_pjsip_transport_websocket.c                                                           |    4
+b/res/res_pjsip_xpidf_body_generator.c                                                          |    2
+b/res/res_rtp_asterisk.c                                                                        |   41
+b/res/res_rtp_multicast.c                                                                       |  139 +
+b/res/res_srtp.c                                                                                |   15
+b/res/res_stasis.c                                                                              |   20
+b/res/srtp/srtp_compat.h                                                                        |   29
+b/res/stasis_recording/stored.c                                                                 |    4
+b/rest-api-templates/res_ari_resource.c.mustache                                                |   35
+b/tests/test_bridging.c                                                                         |  292 ++
+b/tests/test_json.c                                                                             |   16
+b/tests/test_pbx.c                                                                              |   22
+b/third-party/configure.m4                                                                      |    5
+b/third-party/pjproject/Makefile                                                                |    2
+b/third-party/pjproject/Makefile.rules                                                          |    7
+b/third-party/pjproject/configure.m4                                                            |   24
+b/third-party/pjproject/patches/0070-Set-PJSIP_INV_SUPPORT_UPDATE-correctly-in-pjsip_inv_.patch |   16
+121 files changed, 5477 insertions(+), 2043 deletions(-)</pre><br></html>
\ No newline at end of file
diff -urpN asterisk-13.9.1/asterisk-13.17.0-summary.txt asterisk-13.17.0/asterisk-13.17.0-summary.txt
--- asterisk-13.9.1/asterisk-13.17.0-summary.txt	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/asterisk-13.17.0-summary.txt	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,814 @@
+                                Release Summary
+
+                                asterisk-13.17.0
+
+                                Date: 2017-07-12
+
+                           <asteriskteam@digium.com>
+
+     ----------------------------------------------------------------------
+
+                               Table of Contents
+
+    1. Summary
+    2. Contributors
+    3. Closed Issues
+    4. Open Issues
+    5. Other Changes
+    6. Diffstat
+
+     ----------------------------------------------------------------------
+
+                                    Summary
+
+                                 [Back to Top]
+
+   This release is a point release of an existing major version. The changes
+   included were made to address problems that have been identified in this
+   release series, or are minor, backwards compatible new features or
+   improvements. Users should be able to safely upgrade to this version if
+   this release series is already in use. Users considering upgrading from a
+   previous version are strongly encouraged to review the UPGRADE.txt
+   document as well as the CHANGES document for information about upgrading
+   to this release series.
+
+   The data in this summary reflects changes that have been made since the
+   previous release, asterisk-13.16.0.
+
+     ----------------------------------------------------------------------
+
+                                  Contributors
+
+                                 [Back to Top]
+
+   This table lists the people who have submitted code, those that have
+   tested patches, as well as those that reported issues on the issue tracker
+   that were resolved in this release. For coders, the number is how many of
+   their patches (of any size) were committed into this release. For testers,
+   the number is the number of times their name was listed as assisting with
+   testing a patch. Finally, for reporters, the number is the number of
+   issues that they reported that were affected by commits that went into
+   this release.
+
+   Coders                       Testers            Reporters                  
+   17 Sean Bright                                  4 Alexei Gradinari         
+   12 George Joseph                                4 Joshua Colp              
+   10 Joshua Colp                                  3 Kevin Harwell            
+   9 Alexei Gradinari                              3 Louis Jocelyn Paquet     
+   5 Richard Mudgett                               3 Tzafrir Cohen            
+   5 Kevin Harwell                                 3 George Joseph            
+   2 Torrey Searle                                 2 Guido Falsi              
+   2 Guido Falsi                                   2 Alexander Traud          
+   2 Alexander Traud                               2 Michael Walton           
+   1 Jan Friesse                                   2 Torrey Searle            
+   1 Florian Floimair                              1 Rusty Newton             
+   1 Ivan Poddubny                                 1 Matthew Fredrickson      
+   1 Matthew Fredrickson                           1 Jacek Konieczny          
+   1 Yasin CANER                                   1 Tim Morgan               
+   1 David M. Lee                                  1 Etienne Allovon          
+   1 Robert Mordec                                 1 alex                     
+   1 JA,rgen H                                     1 Kinsey Moore             
+   1 Rodrigo Ramirez Norambuena                    1 John Harris              
+   1 Frederic LE FOLL                              1 Javier Riveros           
+   1 Corey Farrell                                 1 Sean Bright              
+                                                   1 Robert Mordec            
+                                                   1 Ross Beer                
+                                                   1 Chris Howard             
+                                                   1 mdu113                   
+                                                   1 Andrew Nowrot            
+                                                   1 'alex'                   
+                                                   1 Lorne Gaetz              
+                                                   1 Ben Langfeld             
+                                                   1 John Fawcett             
+                                                   1 Corey Farrell            
+                                                   1 Frankie Chin             
+                                                   1 Zach R                   
+                                                   1 Matthias Binder          
+                                                   1 Christopher van de Sande 
+                                                   1 Stefan EngstrAP:m        
+                                                   1 Antoine Pitrou           
+                                                   1 Alex                     
+                                                   1 Etienne Lessard          
+                                                   1 Ryan Smith               
+                                                   1 Michael Maier            
+                                                   1 OpenBSD ports            
+                                                   1 Marek Cervenka           
+                                                   1 Ronald Raikes            
+                                                   1 Ove Aursand              
+                                                   1 Richard Mudgett          
+                                                   1 Frederic LE FOLL         
+                                                   1 wushumasters             
+                                                   1 Tony Mountifield         
+                                                   1 JA,rgen H                
+                                                   1 Michel R. Vaillancourt   
+                                                   1 David Brillert           
+                                                   1 Yasin CANER              
+
+     ----------------------------------------------------------------------
+
+                                 Closed Issues
+
+                                 [Back to Top]
+
+   This is a list of all issues from the issue tracker that were closed by
+   changes that went into this release.
+
+  Bug
+
+    Category: Addons/format_mp3
+
+   ASTERISK-23951: Asterisk attempts and fails to build format_mp3 even if
+   mp3lib was not downloaded
+   Reported by: Tzafrir Cohen
+     * [97b003f5e2] Sean Bright -- format_mp3: Re-work menuselect/build
+       issues
+     * [72213c98e3] Sean Bright -- format_mp3: Don't try to build format_mp3
+       if we don't have sources
+
+    Category: Applications/app_confbridge
+
+   ASTERISK-27012: app_confbridge: ConfBridge sometimes does not play user
+   name recording while leaving
+   Reported by: Robert Mordec
+     * [f1b32de2c5] Robert Mordec -- app_confbridge: Race between removing
+       and playing name recording while leaving
+
+    Category: Applications/app_meetme
+
+   ASTERISK-27025: channel / meetme: Fix missing parentheses
+   Reported by: Joshua Colp
+     * [dc05183f4b] Joshua Colp -- channel / app_meetme: Fix parentheses.
+
+    Category: Applications/app_queue
+
+   ASTERISK-25665: Duplicate logging in queue log for EXITEMPTY events
+   Reported by: Ove Aursand
+     * [2c43ca0ac5] Ivan Poddubny -- app_queue: Fix returning to dialplan
+       when a queue is empty
+   ASTERISK-27065: call hangup after leaving app_queue
+   Reported by: Marek Cervenka
+     * [2c43ca0ac5] Ivan Poddubny -- app_queue: Fix returning to dialplan
+       when a queue is empty
+   ASTERISK-26399: app_queue: Agent not called when caller is parked
+   Reported by: wushumasters
+     * [6bfcb1acc7] Joshua Colp -- app_queue: Fix members showing as being in
+       call when not.
+   ASTERISK-26400: app_queue: Queue member stops being called after AMI
+   "Redirect" action for queues with wrapuptime
+   Reported by: Etienne Lessard
+     * [6bfcb1acc7] Joshua Colp -- app_queue: Fix members showing as being in
+       call when not.
+   ASTERISK-26715: app_queue: Member will not receive any new calls after
+   doing a transfer if wrapuptime = greater than 0 and using Local channel
+   Reported by: David Brillert
+     * [6bfcb1acc7] Joshua Colp -- app_queue: Fix members showing as being in
+       call when not.
+   ASTERISK-26975: app_queue: Non-zero wrapup time can cause agents not to
+   receive queue calls after transfer queue call
+   Reported by: Lorne Gaetz
+     * [6bfcb1acc7] Joshua Colp -- app_queue: Fix members showing as being in
+       call when not.
+
+    Category: Applications/app_voicemail/IMAP
+
+   ASTERISK-24052: app_voicemail reloads result in leaked IMAP sockets.
+   Reported by: Louis Jocelyn Paquet
+     * [8f356192d1] Alexei Gradinari -- app_voicemail: IMAP connection
+       control
+     * [3b6c327c51] Alexei Gradinari -- app_voicemail: IMAP logout on
+       reload/unload
+     * [08be5e01e8] Alexei Gradinari -- app_voicemail: IMAP logout on MWI
+       unsubscribe
+
+    Category: Bridges/bridge_simple
+
+   ASTERISK-26973: bridge: Crash when freeing frame and snooping
+   Reported by: Michel R. Vaillancourt
+     * [adfb28882b] Kevin Harwell -- channel: ast_write frame wrongly freed
+       after call to audiohooks
+
+    Category: Channels/chan_pjsip
+
+   ASTERISK-27039: chan_pjsip: Device state is idle when channel from
+   endpoint is in early media
+   Reported by: Joshua Colp
+     * [1f10c6b3b0] Joshua Colp -- chan_pjsip: Update device state when in
+       early media.
+   ASTERISK-26996: chan_pjsip: Flipping between codecs
+   Reported by: Michael Maier
+     * [996a4791ff] Joshua Colp -- pjsip: Extend 'asymmetric_rtp_codec'
+       option to include us changing.
+   ASTERISK-26281: chan_pjsip would send INVITE to 'Unreachable' endpoints
+   Reported by: Jacek Konieczny
+     * [746c2c5745] Joshua Colp -- res_pjsip: Add support for returning only
+       reachable contacts and use it.
+
+    Category: Channels/chan_sip/General
+
+   ASTERISK-27106: [patch] autodomain (SIP Domain Support): Add only really
+   different domain with TLS.
+   Reported by: Alexander Traud
+     * [39d2ebbf56] Alexander Traud -- chan_sip: Only when different, add
+       TCP|TLS in autodomain (SIP Domain Support).
+     * [9f4b3b966e] Alexander Traud -- chan_sip: Fix a typo for tlsbindaddr
+       in autodomain (SIP Domain Support).
+   ASTERISK-26982: chan_sip: rtcp_mux setting may cause ice completion
+   failure/delay if client offers rtcp-mux as negotiable
+   Reported by: Stefan EngstrAP:m
+     * [4479038073] Sean Bright -- chan_sip: Better ICE handling for RTCP-MUX
+
+    Category: Channels/chan_sip/SRTP
+
+   ASTERISK-25101: DTLS configuration can not be specified in the general
+   section - documentation
+   Reported by: Ben Langfeld
+     * [971a401ce9] Sean Bright -- sip.conf.sample: Clarify where DTLS
+       settings are permitted
+
+    Category: Codecs/General
+
+   ASTERISK-24858: [patch]Asterisk 13 PJSIP sends RTP packets in wrong byte
+   order on Intel platform when using slin codec
+   Reported by: Frankie Chin
+     * [70e5887906] Sean Bright -- format: Reintroduce smoother flags
+
+    Category: Core/Bridging
+
+   ASTERISK-27075: bridge: stuck channel(s) after failed attended transfer
+   Reported by: Kevin Harwell
+     * [67664fbf95] Kevin Harwell -- bridge: stuck channel(s) after failed
+       attended transfer
+   ASTERISK-26923: bridging: T.38 request is lost when channels are added to
+   bridge
+   Reported by: Torrey Searle
+     * [e414833f6e] Joshua Colp -- bridge: Add a deferred queue.
+
+    Category: Core/Channels
+
+   ASTERISK-27100: channel: ast_waitfordigit_full fails to clear flag in an
+   error branch.
+   Reported by: Corey Farrell
+     * [73520e9f58] Corey Farrell -- channel: Clear channel flag in error
+       branch.
+   ASTERISK-27074: core_local: local channel data not being properly unref'ed
+   and unlocked
+   Reported by: Kevin Harwell
+     * [1f9913f272] Kevin Harwell -- core_local: local channel data not being
+       properly unref'ed and unlocked
+   ASTERISK-26923: bridging: T.38 request is lost when channels are added to
+   bridge
+   Reported by: Torrey Searle
+     * [e414833f6e] Joshua Colp -- bridge: Add a deferred queue.
+   ASTERISK-27025: channel / meetme: Fix missing parentheses
+   Reported by: Joshua Colp
+     * [dc05183f4b] Joshua Colp -- channel / app_meetme: Fix parentheses.
+
+    Category: Core/General
+
+   ASTERISK-26789: Audit manipulation of channel flags without locks
+   Reported by: Joshua Colp
+     * [1618203964] Joshua Colp -- asterisk: Audit locking of channel when
+       manipulating flags.
+
+    Category: Core/PBX
+
+   ASTERISK-27041: Core/PBX: [patch] Deadlock between dialplan execution and
+   application unregistration
+   Reported by: Frederic LE FOLL
+     * [dc307af7f2] Frederic LE FOLL -- Core/PBX: Deadlock between dialplan
+       execution and application unregistration.
+
+    Category: Core/RTP
+
+   ASTERISK-26978: rtp: Crash in ast_rtp_codecs_payload_code()
+   Reported by: Ross Beer
+     * [eb48e99bd4] George Joseph -- bridge_native_rtp: Keep rtp instance
+       refs on bridge_channel
+   ASTERISK-24858: [patch]Asterisk 13 PJSIP sends RTP packets in wrong byte
+   order on Intel platform when using slin codec
+   Reported by: Frankie Chin
+     * [70e5887906] Sean Bright -- format: Reintroduce smoother flags
+
+    Category: Core/Sorcery
+
+   ASTERISK-27057: Seg Fault in ast_sorcery_object_get_id at sorcery.c
+   Reported by: Ryan Smith
+     * [c2eea791e4] George Joseph -- res_pjsip_pubsub: Fix reference to
+       released endpoint
+
+    Category: Documentation
+
+   ASTERISK-23839: AGI - RECORD FILE - documentation doesn't describe BEEP
+   argument
+   Reported by: Rusty Newton
+     * [3eb7fbba72] Sean Bright -- res_agi: Clarify 'RECORD FILE'
+       documentation
+
+    Category: General
+
+   ASTERISK-27108: Crash using 'data get' CLI command
+   Reported by: Sean Bright
+     * [6258de458b] Sean Bright -- core: Fix segfault when invoking 'data
+       get' CLI command
+   ASTERISK-27060: Comment typo format_g729.c
+   Reported by: Matthew Fredrickson
+     * [0a40073750] Matthew Fredrickson -- formats/format_g729: Fix typo in
+       comment
+
+    Category: PBX/pbx_realtime
+
+   ASTERISK-19291: Background in realtime
+   Reported by: Andrew Nowrot
+     * [283cc59af7] Sean Bright -- pbx_builtin: Properly handle hangup during
+       Background
+
+    Category: Resources/res_agi
+
+   ASTERISK-23839: AGI - RECORD FILE - documentation doesn't describe BEEP
+   argument
+   Reported by: Rusty Newton
+     * [3eb7fbba72] Sean Bright -- res_agi: Clarify 'RECORD FILE'
+       documentation
+   ASTERISK-22432: Async AGI crashes Asterisk when issuing "set variable"
+   command without args
+   Reported by: Antoine Pitrou
+     * [f306e451f6] Sean Bright -- res_agi: Prevent crash when SET VARIABLE
+       called without arguments
+   ASTERISK-25662: Malformed AGI 520 Usage response
+   Reported by: Tony Mountifield
+     * [a007e438c3] Sean Bright -- res_agi: Fix malformed AGI usage response
+
+    Category: Resources/res_ari
+
+   ASTERISK-27026: res_ari: Crash when no ari.conf configuration file exists
+   Reported by: Ronald Raikes
+     * [7901b9853e] George Joseph -- res_ari: Add "module loaded" check to
+       ari stubs
+
+    Category: Resources/res_ari_recordings
+
+   ASTERISK-27021: GET /recordings/stored returns 500 Internal Server Error
+   Reported by: Tim Morgan
+     * [cf6cf59646] Sean Bright -- stasis_recording: Correct ast_asprintf
+       error checking
+
+    Category: Resources/res_format_attr_h264
+
+   ASTERISK-27008: res_format_attr_h264: SDP parse fails if fmtp optional
+   parameters have a space
+   Reported by: John Harris
+     * [700ef6861a] Sean Bright -- res_format_attr_h26x: Trim blanks in fmtp
+       attributes
+
+    Category: Resources/res_parking
+
+   ASTERISK-26399: app_queue: Agent not called when caller is parked
+   Reported by: wushumasters
+     * [6bfcb1acc7] Joshua Colp -- app_queue: Fix members showing as being in
+       call when not.
+
+    Category: Resources/res_pjsip
+
+   ASTERISK-27090: PJSIP: Deadlock using TCP transport
+   Reported by: Richard Mudgett
+     * [0d64cbde57] Richard Mudgett -- pjsip_distributor.c: Fix deadlock with
+       TCP type transports.
+
+    Category: Resources/res_pjsip/Bundling
+
+   ASTERISK-27052: Asterisk build process fails with flag
+   --with-pjproject-bundled with curl download command and slow network
+   Reported by: alex
+     * [0bde568669] George Joseph -- pjproject_bundled: Use the asterisk
+       github mirror for download
+
+    Category: Resources/res_pjsip_refer
+
+   ASTERISK-27053: res_pjsip_refer/session: Calls dropped during transfer
+   Reported by: Kevin Harwell
+     * [6cdf3191d3] Kevin Harwell -- res_pjsip_refer/session: Calls dropped
+       during transfer
+
+    Category: Resources/res_pjsip_session
+
+   ASTERISK-27024: nat/external_media settings ignored in 14.4.1
+   Reported by: Christopher van de Sande
+     * [2dee95cc7a] Florian Floimair -- res_pjsip_session: Correct inverted
+       test in session_outgoing_nat_hook
+   ASTERISK-27053: res_pjsip_refer/session: Calls dropped during transfer
+   Reported by: Kevin Harwell
+     * [6cdf3191d3] Kevin Harwell -- res_pjsip_refer/session: Calls dropped
+       during transfer
+   ASTERISK-26964: res_pjsip_session: Wrong From on reinvite when request and
+   To URI differ
+   Reported by: Yasin CANER
+     * [36628cc9c4] Yasin CANER -- res_pjsip_session : fixed wrong From
+       Header number On Re-invite
+
+    Category: Resources/res_pjsip_transport_websocket
+
+   ASTERISK-27046: res_pjsip_transport_websocket: segfault in
+   get_write_timeout
+   Reported by: JA,rgen H
+     * [e16a669c70] JA,rgen H -- res_pjsip_transport_websocket: Add NULL
+       check in get_write_timeout
+
+    Category: Resources/res_rtp_asterisk
+
+   ASTERISK-27022: res_rtp_asterisk: Incorrect SSRC change for RTCP component
+   Reported by: Michael Walton
+     * [7dafe82751] George Joseph -- res_rtp_asterisk: Fix ssrc change for
+       rtcp srtp
+   ASTERISK-24858: [patch]Asterisk 13 PJSIP sends RTP packets in wrong byte
+   order on Intel platform when using slin codec
+   Reported by: Frankie Chin
+     * [70e5887906] Sean Bright -- format: Reintroduce smoother flags
+   ASTERISK-25101: DTLS configuration can not be specified in the general
+   section - documentation
+   Reported by: Ben Langfeld
+     * [971a401ce9] Sean Bright -- sip.conf.sample: Clarify where DTLS
+       settings are permitted
+   ASTERISK-26979: res_rtp_asterisk: SRTP unprotect failed with
+   authentication failure 10 or 110
+   Reported by: Javier Riveros
+     * [e91efef2bb] Kevin Harwell -- res_rtp_asterisk: rtcp mux using the
+       wrong srtp unprotecting algorithm
+   ASTERISK-26982: chan_sip: rtcp_mux setting may cause ice completion
+   failure/delay if client offers rtcp-mux as negotiable
+   Reported by: Stefan EngstrAP:m
+     * [4479038073] Sean Bright -- chan_sip: Better ICE handling for RTCP-MUX
+
+    Category: Resources/res_srtp
+
+   ASTERISK-25294: srtp's crypto_get_random deprecated
+   Reported by: Tzafrir Cohen
+     * [5e9cd1f20d] Sean Bright -- res_srtp: Add support for libsrtp2
+   ASTERISK-25101: DTLS configuration can not be specified in the general
+   section - documentation
+   Reported by: Ben Langfeld
+     * [971a401ce9] Sean Bright -- sip.conf.sample: Clarify where DTLS
+       settings are permitted
+   ASTERISK-26979: res_rtp_asterisk: SRTP unprotect failed with
+   authentication failure 10 or 110
+   Reported by: Javier Riveros
+     * [e91efef2bb] Kevin Harwell -- res_rtp_asterisk: rtcp mux using the
+       wrong srtp unprotecting algorithm
+
+    Category: Resources/res_stasis_snoop
+
+   ASTERISK-26973: bridge: Crash when freeing frame and snooping
+   Reported by: Michel R. Vaillancourt
+     * [adfb28882b] Kevin Harwell -- channel: ast_write frame wrongly freed
+       after call to audiohooks
+
+    Category: pjproject/pjsip
+
+   ASTERISK-26333: Problems with Blind Transfer, PJSIP (Aastra 6869i)
+   Reported by: Matthias Binder
+     * [6af2dd34af] Alexei Gradinari -- res_pjsip: New endpoint option
+       "refer_blind_progress"
+
+  Improvement
+
+    Category: Core/BuildSystem
+
+   ASTERISK-27043: Core/BuildSystem: Add defines to fix build with LibreSSL
+   Reported by: Guido Falsi
+     * [6a64f65fe6] Guido Falsi -- BuildSystem: Add patches to allow building
+       with recent LibreSSL
+
+    Category: Core/Channels
+
+   ASTERISK-26419: audiohooks: Remove redundant codec translations when using
+   audiohooks
+   Reported by: Michael Walton
+     * [adfb28882b] Kevin Harwell -- channel: ast_write frame wrongly freed
+       after call to audiohooks
+
+    Category: Core/General
+
+   ASTERISK-26419: audiohooks: Remove redundant codec translations when using
+   audiohooks
+   Reported by: Michael Walton
+     * [adfb28882b] Kevin Harwell -- channel: ast_write frame wrongly freed
+       after call to audiohooks
+
+    Category: Core/Portability
+
+   ASTERISK-27042: Unpatched asterisk sources fail to build on FreeBSD due to
+   missing crypt.h file
+   Reported by: Guido Falsi
+     * [44cee2f4a1] Guido Falsi -- BuildSystem: Fix build on FreeBSD due to
+       missing crypt.h
+
+    Category: Resources/res_agi
+
+   ASTERISK-26124: res_agi: Set audio format for EAGI audio stream
+   Reported by: John Fawcett
+     * [90237dca11] Sean Bright -- res_agi: Allow configuration of audio
+       format of EAGI pipe
+
+    Category: Resources/res_pjsip_mwi
+
+   ASTERISK-26230: [patch] res_pjsip_mwi: unsolicited mwi could block PJSIP
+   taskprocessor on startup
+   Reported by: Alexei Gradinari
+     * [0f6a9617eb] Alexei Gradinari -- res_pjsip_mwi: update unsolicited MWI
+       subscriptions on updating contact
+     * [59c9bbe696] Alexei Gradinari -- res_pjsip_mwi: don't create mwi
+       subscriptions if initial unsolicited disabled
+
+    Category: Resources/res_rtp_asterisk
+
+   ASTERISK-26976: libsrtp-2.x.x support
+   Reported by: Alex
+     * [5e9cd1f20d] Sean Bright -- res_srtp: Add support for libsrtp2
+
+     ----------------------------------------------------------------------
+
+                                  Open Issues
+
+                                 [Back to Top]
+
+   This is a list of all open issues from the issue tracker that were
+   referenced by changes that went into this release.
+
+  Bug
+
+    Category: Bridges/bridge_simple
+
+   ASTERISK-26469: Infinite loop after a dual Redirect
+   Reported by: Etienne Allovon
+     * [b07b216235] Joshua Colp -- manager: Clear the flag on the other
+       channel.
+
+    Category: Channels/chan_pjsip
+
+   ASTERISK-27095: chan_pjsip: When connected_line_method is set to invite,
+   we're not trying UPDATE
+   Reported by: George Joseph
+     * [6bd7c0f37c] George Joseph -- chan_pjsip: Fix ability to send UPDATE
+       on COLP
+
+    Category: Core/Bridging
+
+   ASTERISK-27016: Crash occurs when a channel in a 'mixing,dtmf_events'
+   bridge is muted multiple times.
+   Reported by: Chris Howard
+     * [4910a3bf40] Joshua Colp -- channel: Fix reference counting in
+       ast_channel_suppress.
+
+    Category: General
+
+   ASTERISK-27088: res_rtp_asterisk: Better handle ICE renegotiation and
+   unidirectional negotiation
+   Reported by: Joshua Colp
+     * [0426b1d88a] Joshua Colp -- res_rtp_asterisk: Fix issues with ICE
+       renegotiation.
+
+    Category: Resources/res_corosync
+
+   ASTERISK-25370: res_corosync segfaults at startup with corosync version >
+   2.x
+   Reported by: mdu113
+     * [005a4afa6b] Jan Friesse -- res_corosync: Change thread stack size
+
+    Category: Resources/res_pjsip_dialog_info_body_generator
+
+   ASTERISK-26919: res_pjsip_dialog_info_body_generator: Ringing&&InUse
+   behavior difference between chan_sip and res_pjsip
+   Reported by: Zach R
+     * [a6e4899612] Alexei Gradinari -- res_pjsip: New endpoint option
+       "notify_early_inuse_ringing"
+
+    Category: Resources/res_pjsip_mwi
+
+   ASTERISK-27051: res_pjsip_mwi: unsolicited MWI has to be unsubscribed on
+   deleting the endpoint's last contact
+   Reported by: Alexei Gradinari
+     * [8e749c8f51] Alexei Gradinari -- res_pjsip_mwi: unsubscribe
+       unsolicited MWI on deleting endpoint last contact
+
+    Category: Resources/res_stasis
+
+   ASTERISK-27059: res_stasis: Stolen channel references are leaking
+   Reported by: George Joseph
+     * [edfdb4dff5] George Joseph -- res_stasis: Plug reference leak on
+       stolen channels
+
+    Category: Third-Party/pjproject
+
+   ASTERISK-27097: pjproject_bundled: We don't pass options needed for
+   cross-compile to pjproject configure
+   Reported by: George Joseph
+     * [bbe68f139d] George Joseph -- pjproject_bundled: Allow passing
+       configure options to bundled
+
+  Improvement
+
+    Category: Applications/app_voicemail/IMAP
+
+   ASTERISK-27068: app_voicemail: Add global option "imap_poll_logout" to
+   specify post-polling disconnect
+   Reported by: Alexei Gradinari
+     * [8f356192d1] Alexei Gradinari -- app_voicemail: IMAP connection
+       control
+
+    Category: Channels/chan_pjsip
+
+   ASTERISK-27066: res_pjsip: Add DTMF INFO Failback mode
+   Reported by: Torrey Searle
+     * [9fbc34d2bd] Torrey Searle -- res_pjsip: Add DTMF INFO Failback mode
+
+    Category: Resources/res_pjsip
+
+   ASTERISK-27066: res_pjsip: Add DTMF INFO Failback mode
+   Reported by: Torrey Searle
+     * [9fbc34d2bd] Torrey Searle -- res_pjsip: Add DTMF INFO Failback mode
+
+     ----------------------------------------------------------------------
+
+                      Commits Not Associated with an Issue
+
+                                 [Back to Top]
+
+   This is a list of all changes that went into this release that did not
+   reference a JIRA issue.
+
+   +------------------------------------------------------------------------+
+   | Revision   | Author           | Summary                                |
+   |------------+------------------+----------------------------------------|
+   | 0c00ee754b | George Joseph    | Update for 13.17.0-rc1                 |
+   |------------+------------------+----------------------------------------|
+   | 379fe65831 | George Joseph    | Fix alembic branches                   |
+   |------------+------------------+----------------------------------------|
+   | 905d18e8bf | Richard Mudgett  | pjsip_distributor.c: Fix               |
+   |            |                  | unidentified_requests hash functions.  |
+   |------------+------------------+----------------------------------------|
+   | 1f59d08924 | Torrey Searle    | res/res_pjsip_t38: fix incorrect       |
+   |            |                  | increment of media_count               |
+   |------------+------------------+----------------------------------------|
+   | 764d04fa87 | Richard Mudgett  | res_pjsip_mwi.c: Eliminate RAII_VAR in |
+   |            |                  | contact delete observer                |
+   |------------+------------------+----------------------------------------|
+   | cecf6540dc | Rodrigo RamArez  | cdr: fix mistake spelling of a word    |
+   |            | Norambuena       | for Unanswered.                        |
+   |------------+------------------+----------------------------------------|
+   | b9a4ab8c8c | Richard Mudgett  | chan_pjsip: Fix PJSIP_MEDIA_OFFER      |
+   |            |                  | dialplan function read.                |
+   |------------+------------------+----------------------------------------|
+   | f1a209d5ac | Richard Mudgett  | app_voicemail.c: Fix compile error     |
+   |            |                  | when IMAP enabled.                     |
+   |------------+------------------+----------------------------------------|
+   | 68de35a6a0 | David M. Lee     | CFLAGS for BIND8 support               |
+   |------------+------------------+----------------------------------------|
+   | da3312457e | Sean Bright      | codecs.conf.sample: Fix max_bandwidth  |
+   |            |                  | speling error                          |
+   |------------+------------------+----------------------------------------|
+   | 590ffcaf0b | Sean Bright      | eventfd: Disable during cross          |
+   |            |                  | compilation                            |
+   |------------+------------------+----------------------------------------|
+   | 5520b6c201 | Alexei Gradinari | CHANGES: correct version for a new     |
+   |            |                  | option 'refer_blind_progress'          |
+   |------------+------------------+----------------------------------------|
+   | c093bf8072 | Sean Bright      | res_rtp_multicast: Use consistent      |
+   |            |                  | timestamps when possible               |
+   |------------+------------------+----------------------------------------|
+   | c10341646d | George Joseph    | test_json: Fix test names with         |
+   |            |                  | reserved words                         |
+   |------------+------------------+----------------------------------------|
+   | 65898c3af8 | George Joseph    | unittests: Add a unit test that causes |
+   |            |                  | a SEGV and...                          |
+   +------------------------------------------------------------------------+
+
+     ----------------------------------------------------------------------
+
+                                Diffstat Results
+
+                                 [Back to Top]
+
+   This is a summary of the changes to the source code that went into this
+   release that was generated using the diffstat utility.
+
+ asterisk-13.16.0-summary.html                                                                   |  405 ---
+ asterisk-13.16.0-summary.txt                                                                    |  952 ---------
+ b/.version                                                                                      |    2
+ b/CHANGES                                                                                       |   54
+ b/ChangeLog                                                                                     | 1045 +++++++++-
+ b/Makefile                                                                                      |    3
+ b/addons/Makefile                                                                               |   10
+ b/apps/app_chanspy.c                                                                            |   16
+ b/apps/app_confbridge.c                                                                         |   79
+ b/apps/app_dial.c                                                                               |    6
+ b/apps/app_disa.c                                                                               |   10
+ b/apps/app_dumpchan.c                                                                           |    4
+ b/apps/app_externalivr.c                                                                        |    6
+ b/apps/app_meetme.c                                                                             |    2
+ b/apps/app_queue.c                                                                              |  109 -
+ b/apps/app_voicemail.c                                                                          |   80
+ b/asterisk-13.17.0-rc1-summary.html                                                             |  311 ++
+ b/asterisk-13.17.0-rc1-summary.txt                                                              |  832 +++++++
+ b/autoconf/ast_ext_lib.m4                                                                       |   36
+ b/bridges/bridge_native_rtp.c                                                                   |  677 +++++-
+ b/bridges/bridge_simple.c                                                                       |   32
+ b/channels/chan_pjsip.c                                                                         |   68
+ b/channels/chan_sip.c                                                                           |    8
+ b/channels/pjsip/dialplan_functions.c                                                           |   37
+ b/configs/samples/cdr.conf.sample                                                               |    2
+ b/configs/samples/codecs.conf.sample                                                            |    6
+ b/configs/samples/pjsip.conf.sample                                                             |   20
+ b/configs/samples/sip.conf.sample                                                               |    3
+ b/configs/samples/voicemail.conf.sample                                                         |    3
+ b/configure                                                                                     |  434 +++-
+ b/configure.ac                                                                                  |  100
+ b/contrib/ast-db-manage/config/versions/164abbd708c_add_auto_info_to_endpoint_dtmf_mode.py      |   58
+ b/contrib/ast-db-manage/config/versions/86bb1efa278d_add_ps_endpoints_refer_blind_progress.py   |   30
+ b/contrib/ast-db-manage/config/versions/d7983954dd96_add_ps_endpoints_notify_early_inuse_.py    |   30
+ b/contrib/realtime/mssql/mssql_config.sql                                                       |   46
+ b/contrib/realtime/mysql/mysql_config.sql                                                       |   18
+ b/contrib/realtime/oracle/oracle_config.sql                                                     |   46
+ b/contrib/realtime/postgresql/postgresql_config.sql                                             |   22
+ b/formats/format_g729.c                                                                         |    2
+ b/include/asterisk/ari.h                                                                        |   10
+ b/include/asterisk/autoconfig.h.in                                                              |    3
+ b/include/asterisk/bridge_channel.h                                                             |    2
+ b/include/asterisk/bridge_channel_internal.h                                                    |   11
+ b/include/asterisk/bridge_technology.h                                                          |    3
+ b/include/asterisk/channel.h                                                                    |   25
+ b/include/asterisk/codec.h                                                                      |    3
+ b/include/asterisk/core_local.h                                                                 |   37
+ b/include/asterisk/format.h                                                                     |   11
+ b/include/asterisk/res_pjsip.h                                                                  |   74
+ b/include/asterisk/res_pjsip_presence_xml.h                                                     |    3
+ b/include/asterisk/res_pjsip_session.h                                                          |   11
+ b/include/asterisk/rtp_engine.h                                                                 |    9
+ b/include/asterisk/smoother.h                                                                   |    1
+ b/include/asterisk/test.h                                                                       |    8
+ b/main/autoservice.c                                                                            |    2
+ b/main/bridge.c                                                                                 |   10
+ b/main/bridge_after.c                                                                           |    2
+ b/main/bridge_channel.c                                                                         |   38
+ b/main/channel.c                                                                                |   90
+ b/main/codec_builtin.c                                                                          |   19
+ b/main/core_local.c                                                                             |   54
+ b/main/crypt.c                                                                                  |    2
+ b/main/data.c                                                                                   |    4
+ b/main/file.c                                                                                   |   20
+ b/main/format.c                                                                                 |    8
+ b/main/libasteriskssl.c                                                                         |    4
+ b/main/manager.c                                                                                |    8
+ b/main/pbx.c                                                                                    |    4
+ b/main/pbx_app.c                                                                                |    7
+ b/main/pbx_builtins.c                                                                           |    8
+ b/main/tcptls.c                                                                                 |    4
+ b/main/test.c                                                                                   |    4
+ b/makeopts.in                                                                                   |    2
+ b/res/res_agi.c                                                                                 |   73
+ b/res/res_ari_applications.c                                                                    |    4
+ b/res/res_ari_asterisk.c                                                                        |    4
+ b/res/res_ari_bridges.c                                                                         |    4
+ b/res/res_ari_channels.c                                                                        |    4
+ b/res/res_ari_device_states.c                                                                   |    4
+ b/res/res_ari_endpoints.c                                                                       |    4
+ b/res/res_ari_events.c                                                                          |   33
+ b/res/res_ari_mailboxes.c                                                                       |    4
+ b/res/res_ari_playbacks.c                                                                       |    4
+ b/res/res_ari_recordings.c                                                                      |    4
+ b/res/res_ari_sounds.c                                                                          |    4
+ b/res/res_corosync.c                                                                            |   29
+ b/res/res_format_attr_h263.c                                                                    |    2
+ b/res/res_format_attr_h264.c                                                                    |    2
+ b/res/res_musiconhold.c                                                                         |    4
+ b/res/res_pjsip.c                                                                               |   31
+ b/res/res_pjsip/location.c                                                                      |   53
+ b/res/res_pjsip/pjsip_configuration.c                                                           |    9
+ b/res/res_pjsip/pjsip_distributor.c                                                             |  242 +-
+ b/res/res_pjsip/presence_xml.c                                                                  |    9
+ b/res/res_pjsip_dialog_info_body_generator.c                                                    |   10
+ b/res/res_pjsip_mwi.c                                                                           |   87
+ b/res/res_pjsip_pidf_body_generator.c                                                           |    2
+ b/res/res_pjsip_pidf_eyebeam_body_supplement.c                                                  |    2
+ b/res/res_pjsip_pubsub.c                                                                        |    8
+ b/res/res_pjsip_refer.c                                                                         |   28
+ b/res/res_pjsip_sdp_rtp.c                                                                       |   38
+ b/res/res_pjsip_session.c                                                                       |   37
+ b/res/res_pjsip_session.exports.in                                                              |    1
+ b/res/res_pjsip_t38.c                                                                           |    2
+ b/res/res_pjsip_transport_websocket.c                                                           |    4
+ b/res/res_pjsip_xpidf_body_generator.c                                                          |    2
+ b/res/res_rtp_asterisk.c                                                                        |   41
+ b/res/res_rtp_multicast.c                                                                       |  139 +
+ b/res/res_srtp.c                                                                                |   15
+ b/res/res_stasis.c                                                                              |   20
+ b/res/srtp/srtp_compat.h                                                                        |   29
+ b/res/stasis_recording/stored.c                                                                 |    4
+ b/rest-api-templates/res_ari_resource.c.mustache                                                |   35
+ b/tests/test_bridging.c                                                                         |  292 ++
+ b/tests/test_json.c                                                                             |   16
+ b/tests/test_pbx.c                                                                              |   22
+ b/third-party/configure.m4                                                                      |    5
+ b/third-party/pjproject/Makefile                                                                |    2
+ b/third-party/pjproject/Makefile.rules                                                          |    7
+ b/third-party/pjproject/configure.m4                                                            |   24
+ b/third-party/pjproject/patches/0070-Set-PJSIP_INV_SUPPORT_UPDATE-correctly-in-pjsip_inv_.patch |   16
+ 121 files changed, 5477 insertions(+), 2043 deletions(-)
diff -urpN asterisk-13.9.1/asterisk-13.9.1-summary.html asterisk-13.17.0/asterisk-13.9.1-summary.html
--- asterisk-13.9.1/asterisk-13.9.1-summary.html	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/asterisk-13.9.1-summary.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><title>Release Summary - asterisk-13.9.1</title><h1 align="center"><a name="top">Release Summary</a></h1><h3 align="center">asterisk-13.9.1</h3><h3 align="center">Date: 2016-05-13</h3><h3 align="center">&lt;asteriskteam@digium.com&gt;</h3><hr><h2 align="center">Table of Contents</h2><ol>
-<li><a href="#summary">Summary</a></li>
-<li><a href="#contributors">Contributors</a></li>
-<li><a href="#closed_issues">Closed Issues</a></li>
-<li><a href="#commits">Other Changes</a></li>
-<li><a href="#diffstat">Diffstat</a></li>
-</ol><hr><a name="summary"><h2 align="center">Summary</h2></a><center><a href="#top">[Back to Top]</a></center><p>This release is a point release of an existing major version. The changes included were made to address problems that have been identified in this release series, or are minor, backwards compatible new features or improvements. Users should be able to safely upgrade to this version if this release series is already in use. Users considering upgrading from a previous version are strongly encouraged to review the UPGRADE.txt document as well as the CHANGES document for information about upgrading to this release series.</p><p>The data in this summary reflects changes that have been made since the previous release, asterisk-13.9.0.</p><hr><a name="contributors"><h2 align="center">Contributors</h2></a><center><a href="#top">[Back to Top]</a></center><p>This table lists the people who have submitted code, those that have tested patches, as well as those that reported issues on the issue tracker that were resolved in this release. For coders, the number is how many of their patches (of any size) were committed into this release. For testers, the number is the number of times their name was listed as assisting with testing a patch. Finally, for reporters, the number is the number of issues that they reported that were affected by commits that went into this release.</p><table width="100%" border="0">
-<tr><th width="33%">Coders</th><th width="33%">Testers</th><th width="33%">Reporters</th></tr>
-<tr valign="top"><td width="33%">4 Kevin Harwell <kharwell@digium.com><br/>2 Mark Michelson <mmichelson@digium.com><br/></td><td width="33%"><td width="33%">2 Greg Siemon <greg@siemon.id.au><br/>2 Greg Siemon<br/></td></tr>
-</table><hr><a name="closed_issues"><h2 align="center">Closed Issues</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a list of all issues from the issue tracker that were closed by changes that went into this release.</p><h3>Bug</h3><h4>Category: Resources/res_pjsip</h4><a href="https://issues.asterisk.org/jira/browse/ASTERISK-26007">ASTERISK-26007</a>: res_pjsip: Endpoints deleting early after upgrade from 13.8.2 to 13.9<br/>Reported by: Greg Siemon<ul>
-<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=15c427c64daffbbce082c1356d41244c46266bf6">[15c427c64d]</a> Mark Michelson -- Use doubles instead of floats for conversions when comparing strings.</li>
-<li><a href="https://code.asterisk.org/code/changelog/asterisk?cs=d27ee3b1bf3553ca16aa1237252747b962473a0d">[d27ee3b1bf]</a> Mark Michelson -- res_sorcery_astdb: Fix creation of retrieved objects.</li>
-</ul><br><hr><a name="commits"><h2 align="center">Commits Not Associated with an Issue</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a list of all changes that went into this release that did not reference a JIRA issue.</p><table width="100%" border="1">
-<tr><th>Revision</th><th>Author</th><th>Summary</th></tr>
-<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=1cff642773f42a5e7555e03ad7f5b2968e67ae2f">1cff642773</a></td><td>Kevin Harwell</td><td>Release summaries: Remove previous versions</td></tr>
-<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=03be442bf03bc6d06258c9e385b3bfc6284ab66a">03be442bf0</a></td><td>Kevin Harwell</td><td>.version: Update for 13.9.1</td></tr>
-<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=ee94d92141b4a3af7cc8763c5add6570511064fd">ee94d92141</a></td><td>Kevin Harwell</td><td>.lastclean: Update for 13.9.1</td></tr>
-<tr><td><a href="https://code.asterisk.org/code/changelog/asterisk?cs=05da780cc77d303dd2b84537eb936e8202c9bae3">05da780cc7</a></td><td>Kevin Harwell</td><td>realtime: Add database scripts for 13.9.1</td></tr>
-</table><hr><a name="diffstat"><h2 align="center">Diffstat Results</h2></a><center><a href="#top">[Back to Top]</a></center><p>This is a summary of the changes to the source code that went into this release that was generated using the diffstat utility.</p><pre>asterisk-13.9.0-summary.html |  333 -----------------
-asterisk-13.9.0-summary.txt  |  821 -------------------------------------------
-b/.version                   |    2
-3 files changed, 1 insertion(+), 1155 deletions(-)</pre><br></html>
\ No newline at end of file
diff -urpN asterisk-13.9.1/asterisk-13.9.1-summary.txt asterisk-13.17.0/asterisk-13.9.1-summary.txt
--- asterisk-13.9.1/asterisk-13.9.1-summary.txt	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/asterisk-13.9.1-summary.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,111 +0,0 @@
-                                Release Summary
-
-                                asterisk-13.9.1
-
-                                Date: 2016-05-13
-
-                           <asteriskteam@digium.com>
-
-     ----------------------------------------------------------------------
-
-                               Table of Contents
-
-    1. Summary
-    2. Contributors
-    3. Closed Issues
-    4. Other Changes
-    5. Diffstat
-
-     ----------------------------------------------------------------------
-
-                                    Summary
-
-                                 [Back to Top]
-
-   This release is a point release of an existing major version. The changes
-   included were made to address problems that have been identified in this
-   release series, or are minor, backwards compatible new features or
-   improvements. Users should be able to safely upgrade to this version if
-   this release series is already in use. Users considering upgrading from a
-   previous version are strongly encouraged to review the UPGRADE.txt
-   document as well as the CHANGES document for information about upgrading
-   to this release series.
-
-   The data in this summary reflects changes that have been made since the
-   previous release, asterisk-13.9.0.
-
-     ----------------------------------------------------------------------
-
-                                  Contributors
-
-                                 [Back to Top]
-
-   This table lists the people who have submitted code, those that have
-   tested patches, as well as those that reported issues on the issue tracker
-   that were resolved in this release. For coders, the number is how many of
-   their patches (of any size) were committed into this release. For testers,
-   the number is the number of times their name was listed as assisting with
-   testing a patch. Finally, for reporters, the number is the number of
-   issues that they reported that were affected by commits that went into
-   this release.
-
-   Coders                   Testers                  Reporters                
-   4 Kevin Harwell                                   2 Greg Siemon            
-   2 Mark Michelson                                  2 Greg Siemon            
-
-     ----------------------------------------------------------------------
-
-                                 Closed Issues
-
-                                 [Back to Top]
-
-   This is a list of all issues from the issue tracker that were closed by
-   changes that went into this release.
-
-  Bug
-
-    Category: Resources/res_pjsip
-
-   ASTERISK-26007: res_pjsip: Endpoints deleting early after upgrade from
-   13.8.2 to 13.9
-   Reported by: Greg Siemon
-     * [15c427c64d] Mark Michelson -- Use doubles instead of floats for
-       conversions when comparing strings.
-     * [d27ee3b1bf] Mark Michelson -- res_sorcery_astdb: Fix creation of
-       retrieved objects.
-
-     ----------------------------------------------------------------------
-
-                      Commits Not Associated with an Issue
-
-                                 [Back to Top]
-
-   This is a list of all changes that went into this release that did not
-   reference a JIRA issue.
-
-   +------------------------------------------------------------------------+
-   | Revision   | Author        | Summary                                   |
-   |------------+---------------+-------------------------------------------|
-   | 1cff642773 | Kevin Harwell | Release summaries: Remove previous        |
-   |            |               | versions                                  |
-   |------------+---------------+-------------------------------------------|
-   | 03be442bf0 | Kevin Harwell | .version: Update for 13.9.1               |
-   |------------+---------------+-------------------------------------------|
-   | ee94d92141 | Kevin Harwell | .lastclean: Update for 13.9.1             |
-   |------------+---------------+-------------------------------------------|
-   | 05da780cc7 | Kevin Harwell | realtime: Add database scripts for 13.9.1 |
-   +------------------------------------------------------------------------+
-
-     ----------------------------------------------------------------------
-
-                                Diffstat Results
-
-                                 [Back to Top]
-
-   This is a summary of the changes to the source code that went into this
-   release that was generated using the diffstat utility.
-
- asterisk-13.9.0-summary.html |  333 -----------------
- asterisk-13.9.0-summary.txt  |  821 -------------------------------------------
- b/.version                   |    2
- 3 files changed, 1 insertion(+), 1155 deletions(-)
diff -urpN asterisk-13.9.1/autoconf/acx_pthread.m4 asterisk-13.17.0/autoconf/acx_pthread.m4
--- asterisk-13.9.1/autoconf/acx_pthread.m4	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/autoconf/acx_pthread.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,243 +0,0 @@
-dnl @synopsis ACX_PTHREAD([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])
-dnl
-dnl @summary figure out how to build C programs using POSIX threads
-dnl
-dnl This macro figures out how to build C programs using POSIX threads.
-dnl It sets the PTHREAD_LIBS output variable to the threads library and
-dnl linker flags, and the PTHREAD_CFLAGS output variable to any special
-dnl C compiler flags that are needed. (The user can also force certain
-dnl compiler flags/libs to be tested by setting these environment
-dnl variables.)
-dnl
-dnl Also sets PTHREAD_CC to any special C compiler that is needed for
-dnl multi-threaded programs (defaults to the value of CC otherwise).
-dnl (This is necessary on AIX to use the special cc_r compiler alias.)
-dnl
-dnl NOTE: You are assumed to not only compile your program with these
-dnl flags, but also link it with them as well. e.g. you should link
-dnl with $PTHREAD_CC $CFLAGS $PTHREAD_CFLAGS $LDFLAGS ... $PTHREAD_LIBS
-dnl $LIBS
-dnl
-dnl If you are only building threads programs, you may wish to use
-dnl these variables in your default LIBS, CFLAGS, and CC:
-dnl
-dnl        LIBS="$PTHREAD_LIBS $LIBS"
-dnl        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-dnl        CC="$PTHREAD_CC"
-dnl
-dnl In addition, if the PTHREAD_CREATE_JOINABLE thread-attribute
-dnl constant has a nonstandard name, defines PTHREAD_CREATE_JOINABLE to
-dnl that name (e.g. PTHREAD_CREATE_UNDETACHED on AIX).
-dnl
-dnl ACTION-IF-FOUND is a list of shell commands to run if a threads
-dnl library is found, and ACTION-IF-NOT-FOUND is a list of commands to
-dnl run it if it is not found. If ACTION-IF-FOUND is not specified, the
-dnl default action will define HAVE_PTHREAD.
-dnl
-dnl Please let the authors know if this macro fails on any platform, or
-dnl if you have any other suggestions or comments. This macro was based
-dnl on work by SGJ on autoconf scripts for FFTW (www.fftw.org) (with
-dnl help from M. Frigo), as well as ac_pthread and hb_pthread macros
-dnl posted by Alejandro Forero Cuervo to the autoconf macro repository.
-dnl We are also grateful for the helpful feedback of numerous users.
-dnl
-dnl @category InstalledPackages
-dnl @author Steven G. Johnson <stevenj@alum.mit.edu>
-dnl @version 2006-05-29
-dnl @license GPLWithACException
-
-AC_DEFUN([ACX_PTHREAD],
-[
-AC_REQUIRE([AC_CANONICAL_HOST])
-AC_LANG_SAVE
-AC_LANG_C
-acx_pthread_ok=no
-
-# We used to check for pthread.h first, but this fails if pthread.h
-# requires special compiler flags (e.g. on True64 or Sequent).
-# It gets checked for in the link test anyway.
-
-# First of all, check if the user has set any of the PTHREAD_LIBS,
-# etcetera environment variables, and if threads linking works using
-# them:
-if test x"$PTHREAD_LIBS$PTHREAD_CFLAGS" != x; then
-        save_CFLAGS="$CFLAGS"
-        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-        save_LIBS="$LIBS"
-        LIBS="$PTHREAD_LIBS $LIBS"
-        AC_MSG_CHECKING([for pthread_join in LIBS=$PTHREAD_LIBS with CFLAGS=$PTHREAD_CFLAGS])
-        AC_TRY_LINK_FUNC(pthread_join, acx_pthread_ok=yes)
-        AC_MSG_RESULT($acx_pthread_ok)
-        if test x"$acx_pthread_ok" = xno; then
-                PTHREAD_LIBS=""
-                PTHREAD_CFLAGS=""
-        fi
-        LIBS="$save_LIBS"
-        CFLAGS="$save_CFLAGS"
-fi
-
-# We must check for the threads library under a number of different
-# names; the ordering is very important because some systems
-# (e.g. DEC) have both -lpthread and -lpthreads, where one of the
-# libraries is broken (non-POSIX).
-
-# Create a list of thread flags to try.  Items starting with a "-" are
-# C compiler flags, and other items are library names, except for "none"
-# which indicates that we try without any flags at all, and "pthread-config"
-# which is a program returning the flags for the Pth emulation library.
-
-acx_pthread_flags="pthreads none -Kthread -kthread lthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config"
-
-# The ordering *is* (sometimes) important.  Some notes on the
-# individual items follow:
-
-# pthreads: AIX (must check this before -lpthread)
-# none: in case threads are in libc; should be tried before -Kthread and
-#       other compiler flags to prevent continual compiler warnings
-# -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
-# -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
-# lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
-# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads)
-# -pthreads: Solaris/gcc
-# -mthreads: Mingw32/gcc, Lynx/gcc
-# -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
-#      doesn't hurt to check since this sometimes defines pthreads too;
-#      also defines -D_REENTRANT)
-#      ... -mt is also the pthreads flag for HP/aCC
-# pthread: Linux, etcetera
-# --thread-safe: KAI C++
-# pthread-config: use pthread-config program (for GNU Pth library)
-
-case "${host_cpu}-${host_os}" in
-        *solaris*)
-
-        # On Solaris (at least, for some versions), libc contains stubbed
-        # (non-functional) versions of the pthreads routines, so link-based
-        # tests will erroneously succeed.  (We need to link with -pthreads/-mt/
-        # -lpthread.)  (The stubs are missing pthread_cleanup_push, or rather
-        # a function called by this macro, so we could check for that, but
-        # who knows whether they'll stub that too in a future libc.)  So,
-        # we'll just look for -pthreads and -lpthread first:
-
-        acx_pthread_flags="-pthreads pthread -mt -pthread $acx_pthread_flags"
-        ;;
-esac
-
-if test x"$acx_pthread_ok" = xno; then
-for flag in $acx_pthread_flags; do
-
-        case $flag in
-                none)
-                AC_MSG_CHECKING([whether pthreads work without any flags])
-                ;;
-
-                -*)
-                AC_MSG_CHECKING([whether pthreads work with $flag])
-                PTHREAD_CFLAGS="$flag"
-                ;;
-
-		pthread-config)
-		AC_CHECK_PROG(acx_pthread_config, pthread-config, yes, no)
-		if test x"$acx_pthread_config" = xno; then continue; fi
-		PTHREAD_CFLAGS="`pthread-config --cflags`"
-		PTHREAD_LIBS="`pthread-config --ldflags` `pthread-config --libs`"
-		;;
-
-                *)
-                AC_MSG_CHECKING([for the pthreads library -l$flag])
-                PTHREAD_LIBS="-l$flag"
-                ;;
-        esac
-
-        save_LIBS="$LIBS"
-        save_CFLAGS="$CFLAGS"
-        LIBS="$PTHREAD_LIBS $LIBS"
-        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-
-        # Check for various functions.  We must include pthread.h,
-        # since some functions may be macros.  (On the Sequent, we
-        # need a special flag -Kthread to make this header compile.)
-        # We check for pthread_join because it is in -lpthread on IRIX
-        # while pthread_create is in libc.  We check for pthread_attr_init
-        # due to DEC craziness with -lpthreads.  We check for
-        # pthread_cleanup_push because it is one of the few pthread
-        # functions on Solaris that doesn't have a non-functional libc stub.
-        # We try pthread_create on general principles.
-        AC_TRY_LINK([#include <pthread.h>],
-                    [pthread_t th; pthread_join(th, 0);
-                     pthread_attr_init(0); pthread_cleanup_push(0, 0);
-                     pthread_create(0,0,0,0); pthread_cleanup_pop(0); ],
-                    [acx_pthread_ok=yes])
-
-        LIBS="$save_LIBS"
-        CFLAGS="$save_CFLAGS"
-
-        AC_MSG_RESULT($acx_pthread_ok)
-        if test "x$acx_pthread_ok" = xyes; then
-                break;
-        fi
-
-        PTHREAD_LIBS=""
-        PTHREAD_CFLAGS=""
-done
-fi
-
-# Various other checks:
-if test "x$acx_pthread_ok" = xyes; then
-        save_LIBS="$LIBS"
-        LIBS="$PTHREAD_LIBS $LIBS"
-        save_CFLAGS="$CFLAGS"
-        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-
-        # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.
-	AC_MSG_CHECKING([for joinable pthread attribute])
-	attr_name=unknown
-	for attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do
-	    AC_TRY_LINK([#include <pthread.h>], [int attr=$attr; return attr;],
-                        [attr_name=$attr; break])
-	done
-        AC_MSG_RESULT($attr_name)
-        if test "$attr_name" != PTHREAD_CREATE_JOINABLE; then
-            AC_DEFINE_UNQUOTED(PTHREAD_CREATE_JOINABLE, $attr_name,
-                               [Define to necessary symbol if this constant
-                                uses a non-standard name on your system.])
-        fi
-
-        AC_MSG_CHECKING([if more special flags are required for pthreads])
-        flag=no
-        case "${host_cpu}-${host_os}" in
-            *-aix* | *-freebsd* | *-darwin*) flag="-D_THREAD_SAFE";;
-            *solaris* | *-osf* | *-hpux*) flag="-D_REENTRANT";;
-        esac
-        AC_MSG_RESULT(${flag})
-        if test "x$flag" != xno; then
-            PTHREAD_CFLAGS="$flag $PTHREAD_CFLAGS"
-        fi
-
-        LIBS="$save_LIBS"
-        CFLAGS="$save_CFLAGS"
-
-        # More AIX lossage: must compile with xlc_r or cc_r
-	if test x"$GCC" != xyes; then
-          AC_CHECK_PROGS(PTHREAD_CC, xlc_r cc_r, ${CC})
-        else
-          PTHREAD_CC=$CC
-	fi
-else
-        PTHREAD_CC="$CC"
-fi
-
-AC_SUBST(PTHREAD_LIBS)
-AC_SUBST(PTHREAD_CFLAGS)
-AC_SUBST(PTHREAD_CC)
-
-# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:
-if test x"$acx_pthread_ok" = xyes; then
-        ifelse([$1],,AC_DEFINE(HAVE_PTHREAD,1,[Define if you have POSIX threads libraries and header files.]),[$1])
-        :
-else
-        acx_pthread_ok=no
-        $2
-fi
-AC_LANG_RESTORE
-])dnl ACX_PTHREAD
diff -urpN asterisk-13.9.1/autoconf/ast_ext_lib.m4 asterisk-13.17.0/autoconf/ast_ext_lib.m4
--- asterisk-13.9.1/autoconf/ast_ext_lib.m4	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/autoconf/ast_ext_lib.m4	2017-07-12 13:12:08.000000000 +0200
@@ -11,7 +11,7 @@ AC_DEFUN([AST_EXT_LIB_SETUP],
     $1_DESCRIP="$2"
     $1_OPTION="$3"
     PBX_$1=0
-    AC_ARG_WITH([$3], AC_HELP_STRING([--with-$3=PATH],[use $2 files in PATH$4]),
+    AC_ARG_WITH([$3], AS_HELP_STRING([--with-$3=PATH],[use $2 files in PATH$4]),
     [
 	case ${withval} in
 	n|no)
@@ -164,3 +164,39 @@ _ACEOF
 fi
 m4_ifval([$7], [AH_TEMPLATE(m4_bpatsubst([[HAVE_$1_VERSION]], [(.*)]), [Define to the version of the $2 library.])])
 ])
+
+# Check if the previously discovered library can be dynamically linked.
+#
+# AST_EXT_LIB_CHECK_SHARED([package], [library], [function], [header],
+#	 [extra libs], [extra cflags], [action-if-true], [action-if-false])
+AC_DEFUN([AST_EXT_LIB_CHECK_SHARED],
+[
+if test "x${PBX_$1}" = "x1"; then
+   ast_ext_lib_check_shared_saved_libs="${LIBS}"
+   ast_ext_lib_check_shared_saved_ldflags="${LDFLAGS}"
+   ast_ext_lib_check_shared_saved_cflags="${CFLAGS}"
+   LIBS="${LIBS} ${$1_LIB} $5"
+   LDFLAGS="${LDFLAGS} -shared -fPIC"
+   CFLAGS="${CFLAGS} ${$1_INCLUDE} $6"
+   AC_MSG_CHECKING(for the ability of -l$2 to be linked in a shared object)
+   AC_LINK_IFELSE(
+   [
+       AC_LANG_PROGRAM(
+           [#include <$4>],
+           [$3();]
+       )
+   ],
+   [
+      AC_MSG_RESULT(yes)
+      $7
+   ],
+   [
+      AC_MSG_RESULT(no)
+      $8
+   ]
+   )
+   CFLAGS="${ast_ext_lib_check_shared_saved_cflags}"
+   LDFLAGS="${ast_ext_lib_check_shared_saved_ldflags}"
+   LIBS="${ast_ext_lib_check_shared_saved_libs}"
+fi
+])
diff -urpN asterisk-13.9.1/autoconf/ast_prog_ld.m4 asterisk-13.17.0/autoconf/ast_prog_ld.m4
--- asterisk-13.9.1/autoconf/ast_prog_ld.m4	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/autoconf/ast_prog_ld.m4	2017-07-12 13:12:08.000000000 +0200
@@ -3,7 +3,7 @@
 # find the pathname to the GNU or non-GNU linker
 AC_DEFUN([AST_PROG_LD],
 [AC_ARG_WITH([gnu-ld],
-    [AC_HELP_STRING([--with-gnu-ld],
+    [AS_HELP_STRING([--with-gnu-ld],
 	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
     [test "$withval" = no || with_gnu_ld=yes],
     [with_gnu_ld=no])
diff -urpN asterisk-13.9.1/autoconf/ax_pthread.m4 asterisk-13.17.0/autoconf/ax_pthread.m4
--- asterisk-13.9.1/autoconf/ax_pthread.m4	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/autoconf/ax_pthread.m4	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,485 @@
+# ===========================================================================
+#        http://www.gnu.org/software/autoconf-archive/ax_pthread.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PTHREAD([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])
+#
+# DESCRIPTION
+#
+#   This macro figures out how to build C programs using POSIX threads. It
+#   sets the PTHREAD_LIBS output variable to the threads library and linker
+#   flags, and the PTHREAD_CFLAGS output variable to any special C compiler
+#   flags that are needed. (The user can also force certain compiler
+#   flags/libs to be tested by setting these environment variables.)
+#
+#   Also sets PTHREAD_CC to any special C compiler that is needed for
+#   multi-threaded programs (defaults to the value of CC otherwise). (This
+#   is necessary on AIX to use the special cc_r compiler alias.)
+#
+#   NOTE: You are assumed to not only compile your program with these flags,
+#   but also to link with them as well. For example, you might link with
+#   $PTHREAD_CC $CFLAGS $PTHREAD_CFLAGS $LDFLAGS ... $PTHREAD_LIBS $LIBS
+#
+#   If you are only building threaded programs, you may wish to use these
+#   variables in your default LIBS, CFLAGS, and CC:
+#
+#     LIBS="$PTHREAD_LIBS $LIBS"
+#     CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+#     CC="$PTHREAD_CC"
+#
+#   In addition, if the PTHREAD_CREATE_JOINABLE thread-attribute constant
+#   has a nonstandard name, this macro defines PTHREAD_CREATE_JOINABLE to
+#   that name (e.g. PTHREAD_CREATE_UNDETACHED on AIX).
+#
+#   Also HAVE_PTHREAD_PRIO_INHERIT is defined if pthread is found and the
+#   PTHREAD_PRIO_INHERIT symbol is defined when compiling with
+#   PTHREAD_CFLAGS.
+#
+#   ACTION-IF-FOUND is a list of shell commands to run if a threads library
+#   is found, and ACTION-IF-NOT-FOUND is a list of commands to run it if it
+#   is not found. If ACTION-IF-FOUND is not specified, the default action
+#   will define HAVE_PTHREAD.
+#
+#   Please let the authors know if this macro fails on any platform, or if
+#   you have any other suggestions or comments. This macro was based on work
+#   by SGJ on autoconf scripts for FFTW (http://www.fftw.org/) (with help
+#   from M. Frigo), as well as ac_pthread and hb_pthread macros posted by
+#   Alejandro Forero Cuervo to the autoconf macro repository. We are also
+#   grateful for the helpful feedback of numerous users.
+#
+#   Updated for Autoconf 2.68 by Daniel Richard G.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2011 Daniel Richard G. <skunk@iSKUNK.ORG>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 23
+
+AU_ALIAS([ACX_PTHREAD], [AX_PTHREAD])
+AC_DEFUN([AX_PTHREAD], [
+AC_REQUIRE([AC_CANONICAL_HOST])
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AC_PROG_SED])
+AC_LANG_PUSH([C])
+ax_pthread_ok=no
+
+# We used to check for pthread.h first, but this fails if pthread.h
+# requires special compiler flags (e.g. on Tru64 or Sequent).
+# It gets checked for in the link test anyway.
+
+# First of all, check if the user has set any of the PTHREAD_LIBS,
+# etcetera environment variables, and if threads linking works using
+# them:
+if test "x$PTHREAD_CFLAGS$PTHREAD_LIBS" != "x"; then
+        ax_pthread_save_CC="$CC"
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        AS_IF([test "x$PTHREAD_CC" != "x"], [CC="$PTHREAD_CC"])
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+        AC_MSG_CHECKING([for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS])
+        AC_LINK_IFELSE([AC_LANG_CALL([], [pthread_join])], [ax_pthread_ok=yes])
+        AC_MSG_RESULT([$ax_pthread_ok])
+        if test "x$ax_pthread_ok" = "xno"; then
+                PTHREAD_LIBS=""
+                PTHREAD_CFLAGS=""
+        fi
+        CC="$ax_pthread_save_CC"
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+fi
+
+# We must check for the threads library under a number of different
+# names; the ordering is very important because some systems
+# (e.g. DEC) have both -lpthread and -lpthreads, where one of the
+# libraries is broken (non-POSIX).
+
+# Create a list of thread flags to try.  Items starting with a "-" are
+# C compiler flags, and other items are library names, except for "none"
+# which indicates that we try without any flags at all, and "pthread-config"
+# which is a program returning the flags for the Pth emulation library.
+
+ax_pthread_flags="pthreads none -Kthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config"
+
+# The ordering *is* (sometimes) important.  Some notes on the
+# individual items follow:
+
+# pthreads: AIX (must check this before -lpthread)
+# none: in case threads are in libc; should be tried before -Kthread and
+#       other compiler flags to prevent continual compiler warnings
+# -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
+# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads), Tru64
+#           (Note: HP C rejects this with "bad form for `-t' option")
+# -pthreads: Solaris/gcc (Note: HP C also rejects)
+# -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
+#      doesn't hurt to check since this sometimes defines pthreads and
+#      -D_REENTRANT too), HP C (must be checked before -lpthread, which
+#      is present but should not be used directly; and before -mthreads,
+#      because the compiler interprets this as "-mt" + "-hreads")
+# -mthreads: Mingw32/gcc, Lynx/gcc
+# pthread: Linux, etcetera
+# --thread-safe: KAI C++
+# pthread-config: use pthread-config program (for GNU Pth library)
+
+case $host_os in
+
+        freebsd*)
+
+        # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
+        # lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
+
+        ax_pthread_flags="-kthread lthread $ax_pthread_flags"
+        ;;
+
+        hpux*)
+
+        # From the cc(1) man page: "[-mt] Sets various -D flags to enable
+        # multi-threading and also sets -lpthread."
+
+        ax_pthread_flags="-mt -pthread pthread $ax_pthread_flags"
+        ;;
+
+        openedition*)
+
+        # IBM z/OS requires a feature-test macro to be defined in order to
+        # enable POSIX threads at all, so give the user a hint if this is
+        # not set. (We don't define these ourselves, as they can affect
+        # other portions of the system API in unpredictable ways.)
+
+        AC_EGREP_CPP([AX_PTHREAD_ZOS_MISSING],
+            [
+#            if !defined(_OPEN_THREADS) && !defined(_UNIX03_THREADS)
+             AX_PTHREAD_ZOS_MISSING
+#            endif
+            ],
+            [AC_MSG_WARN([IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support.])])
+        ;;
+
+        solaris*)
+
+        # On Solaris (at least, for some versions), libc contains stubbed
+        # (non-functional) versions of the pthreads routines, so link-based
+        # tests will erroneously succeed. (N.B.: The stubs are missing
+        # pthread_cleanup_push, or rather a function called by this macro,
+        # so we could check for that, but who knows whether they'll stub
+        # that too in a future libc.)  So we'll check first for the
+        # standard Solaris way of linking pthreads (-mt -lpthread).
+
+        ax_pthread_flags="-mt,pthread pthread $ax_pthread_flags"
+        ;;
+esac
+
+# GCC generally uses -pthread, or -pthreads on some platforms (e.g. SPARC)
+
+AS_IF([test "x$GCC" = "xyes"],
+      [ax_pthread_flags="-pthread -pthreads $ax_pthread_flags"])
+
+# The presence of a feature test macro requesting re-entrant function
+# definitions is, on some systems, a strong hint that pthreads support is
+# correctly enabled
+
+case $host_os in
+        darwin* | hpux* | linux* | osf* | solaris*)
+        ax_pthread_check_macro="_REENTRANT"
+        ;;
+
+        aix*)
+        ax_pthread_check_macro="_THREAD_SAFE"
+        ;;
+
+        *)
+        ax_pthread_check_macro="--"
+        ;;
+esac
+AS_IF([test "x$ax_pthread_check_macro" = "x--"],
+      [ax_pthread_check_cond=0],
+      [ax_pthread_check_cond="!defined($ax_pthread_check_macro)"])
+
+# Are we compiling with Clang?
+
+AC_CACHE_CHECK([whether $CC is Clang],
+    [ax_cv_PTHREAD_CLANG],
+    [ax_cv_PTHREAD_CLANG=no
+     # Note that Autoconf sets GCC=yes for Clang as well as GCC
+     if test "x$GCC" = "xyes"; then
+        AC_EGREP_CPP([AX_PTHREAD_CC_IS_CLANG],
+            [/* Note: Clang 2.7 lacks __clang_[a-z]+__ */
+#            if defined(__clang__) && defined(__llvm__)
+             AX_PTHREAD_CC_IS_CLANG
+#            endif
+            ],
+            [ax_cv_PTHREAD_CLANG=yes])
+     fi
+    ])
+ax_pthread_clang="$ax_cv_PTHREAD_CLANG"
+
+ax_pthread_clang_warning=no
+
+# Clang needs special handling, because older versions handle the -pthread
+# option in a rather... idiosyncratic way
+
+if test "x$ax_pthread_clang" = "xyes"; then
+
+        # Clang takes -pthread; it has never supported any other flag
+
+        # (Note 1: This will need to be revisited if a system that Clang
+        # supports has POSIX threads in a separate library.  This tends not
+        # to be the way of modern systems, but it's conceivable.)
+
+        # (Note 2: On some systems, notably Darwin, -pthread is not needed
+        # to get POSIX threads support; the API is always present and
+        # active.  We could reasonably leave PTHREAD_CFLAGS empty.  But
+        # -pthread does define _REENTRANT, and while the Darwin headers
+        # ignore this macro, third-party headers might not.)
+
+        PTHREAD_CFLAGS="-pthread"
+        PTHREAD_LIBS=
+
+        ax_pthread_ok=yes
+
+        # However, older versions of Clang make a point of warning the user
+        # that, in an invocation where only linking and no compilation is
+        # taking place, the -pthread option has no effect ("argument unused
+        # during compilation").  They expect -pthread to be passed in only
+        # when source code is being compiled.
+        #
+        # Problem is, this is at odds with the way Automake and most other
+        # C build frameworks function, which is that the same flags used in
+        # compilation (CFLAGS) are also used in linking.  Many systems
+        # supported by AX_PTHREAD require exactly this for POSIX threads
+        # support, and in fact it is often not straightforward to specify a
+        # flag that is used only in the compilation phase and not in
+        # linking.  Such a scenario is extremely rare in practice.
+        #
+        # Even though use of the -pthread flag in linking would only print
+        # a warning, this can be a nuisance for well-run software projects
+        # that build with -Werror.  So if the active version of Clang has
+        # this misfeature, we search for an option to squash it.
+
+        AC_CACHE_CHECK([whether Clang needs flag to prevent "argument unused" warning when linking with -pthread],
+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG],
+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=unknown
+             # Create an alternate version of $ac_link that compiles and
+             # links in two steps (.c -> .o, .o -> exe) instead of one
+             # (.c -> exe), because the warning occurs only in the second
+             # step
+             ax_pthread_save_ac_link="$ac_link"
+             ax_pthread_sed='s/conftest\.\$ac_ext/conftest.$ac_objext/g'
+             ax_pthread_link_step=`$as_echo "$ac_link" | sed "$ax_pthread_sed"`
+             ax_pthread_2step_ac_link="($ac_compile) && (echo ==== >&5) && ($ax_pthread_link_step)"
+             ax_pthread_save_CFLAGS="$CFLAGS"
+             for ax_pthread_try in '' -Qunused-arguments -Wno-unused-command-line-argument unknown; do
+                AS_IF([test "x$ax_pthread_try" = "xunknown"], [break])
+                CFLAGS="-Werror -Wunknown-warning-option $ax_pthread_try -pthread $ax_pthread_save_CFLAGS"
+                ac_link="$ax_pthread_save_ac_link"
+                AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],
+                    [ac_link="$ax_pthread_2step_ac_link"
+                     AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],
+                         [break])
+                    ])
+             done
+             ac_link="$ax_pthread_save_ac_link"
+             CFLAGS="$ax_pthread_save_CFLAGS"
+             AS_IF([test "x$ax_pthread_try" = "x"], [ax_pthread_try=no])
+             ax_cv_PTHREAD_CLANG_NO_WARN_FLAG="$ax_pthread_try"
+            ])
+
+        case "$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG" in
+                no | unknown) ;;
+                *) PTHREAD_CFLAGS="$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG $PTHREAD_CFLAGS" ;;
+        esac
+
+fi # $ax_pthread_clang = yes
+
+if test "x$ax_pthread_ok" = "xno"; then
+for ax_pthread_try_flag in $ax_pthread_flags; do
+
+        case $ax_pthread_try_flag in
+                none)
+                AC_MSG_CHECKING([whether pthreads work without any flags])
+                ;;
+
+                -mt,pthread)
+                AC_MSG_CHECKING([whether pthreads work with -mt -lpthread])
+                PTHREAD_CFLAGS="-mt"
+                PTHREAD_LIBS="-lpthread"
+                ;;
+
+                -*)
+                AC_MSG_CHECKING([whether pthreads work with $ax_pthread_try_flag])
+                PTHREAD_CFLAGS="$ax_pthread_try_flag"
+                ;;
+
+                pthread-config)
+                AC_CHECK_PROG([ax_pthread_config], [pthread-config], [yes], [no])
+                AS_IF([test "x$ax_pthread_config" = "xno"], [continue])
+                PTHREAD_CFLAGS="`pthread-config --cflags`"
+                PTHREAD_LIBS="`pthread-config --ldflags` `pthread-config --libs`"
+                ;;
+
+                *)
+                AC_MSG_CHECKING([for the pthreads library -l$ax_pthread_try_flag])
+                PTHREAD_LIBS="-l$ax_pthread_try_flag"
+                ;;
+        esac
+
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+
+        # Check for various functions.  We must include pthread.h,
+        # since some functions may be macros.  (On the Sequent, we
+        # need a special flag -Kthread to make this header compile.)
+        # We check for pthread_join because it is in -lpthread on IRIX
+        # while pthread_create is in libc.  We check for pthread_attr_init
+        # due to DEC craziness with -lpthreads.  We check for
+        # pthread_cleanup_push because it is one of the few pthread
+        # functions on Solaris that doesn't have a non-functional libc stub.
+        # We try pthread_create on general principles.
+
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>
+#                       if $ax_pthread_check_cond
+#                        error "$ax_pthread_check_macro must be defined"
+#                       endif
+                        static void routine(void *a) { a = 0; }
+                        static void *start_routine(void *a) { return a; }],
+                       [pthread_t th; pthread_attr_t attr;
+                        pthread_create(&th, 0, start_routine, 0);
+                        pthread_join(th, 0);
+                        pthread_attr_init(&attr);
+                        pthread_cleanup_push(routine, 0);
+                        pthread_cleanup_pop(0) /* ; */])],
+            [ax_pthread_ok=yes],
+            [])
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        AC_MSG_RESULT([$ax_pthread_ok])
+        AS_IF([test "x$ax_pthread_ok" = "xyes"], [break])
+
+        PTHREAD_LIBS=""
+        PTHREAD_CFLAGS=""
+done
+fi
+
+# Various other checks:
+if test "x$ax_pthread_ok" = "xyes"; then
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+
+        # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.
+        AC_CACHE_CHECK([for joinable pthread attribute],
+            [ax_cv_PTHREAD_JOINABLE_ATTR],
+            [ax_cv_PTHREAD_JOINABLE_ATTR=unknown
+             for ax_pthread_attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do
+                 AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],
+                                                 [int attr = $ax_pthread_attr; return attr /* ; */])],
+                                [ax_cv_PTHREAD_JOINABLE_ATTR=$ax_pthread_attr; break],
+                                [])
+             done
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xunknown" && \
+               test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xPTHREAD_CREATE_JOINABLE" && \
+               test "x$ax_pthread_joinable_attr_defined" != "xyes"],
+              [AC_DEFINE_UNQUOTED([PTHREAD_CREATE_JOINABLE],
+                                  [$ax_cv_PTHREAD_JOINABLE_ATTR],
+                                  [Define to necessary symbol if this constant
+                                   uses a non-standard name on your system.])
+               ax_pthread_joinable_attr_defined=yes
+              ])
+
+        AC_CACHE_CHECK([whether more special flags are required for pthreads],
+            [ax_cv_PTHREAD_SPECIAL_FLAGS],
+            [ax_cv_PTHREAD_SPECIAL_FLAGS=no
+             case $host_os in
+             solaris*)
+             ax_cv_PTHREAD_SPECIAL_FLAGS="-D_POSIX_PTHREAD_SEMANTICS"
+             ;;
+             esac
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_SPECIAL_FLAGS" != "xno" && \
+               test "x$ax_pthread_special_flags_added" != "xyes"],
+              [PTHREAD_CFLAGS="$ax_cv_PTHREAD_SPECIAL_FLAGS $PTHREAD_CFLAGS"
+               ax_pthread_special_flags_added=yes])
+
+        AC_CACHE_CHECK([for PTHREAD_PRIO_INHERIT],
+            [ax_cv_PTHREAD_PRIO_INHERIT],
+            [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <pthread.h>]],
+                                             [[int i = PTHREAD_PRIO_INHERIT;]])],
+                            [ax_cv_PTHREAD_PRIO_INHERIT=yes],
+                            [ax_cv_PTHREAD_PRIO_INHERIT=no])
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_PRIO_INHERIT" = "xyes" && \
+               test "x$ax_pthread_prio_inherit_defined" != "xyes"],
+              [AC_DEFINE([HAVE_PTHREAD_PRIO_INHERIT], [1], [Have PTHREAD_PRIO_INHERIT.])
+               ax_pthread_prio_inherit_defined=yes
+              ])
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        # More AIX lossage: compile with *_r variant
+        if test "x$GCC" != "xyes"; then
+            case $host_os in
+                aix*)
+                AS_CASE(["x/$CC"],
+                    [x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6],
+                    [#handle absolute path differently from PATH based program lookup
+                     AS_CASE(["x$CC"],
+                         [x/*],
+                         [AS_IF([AS_EXECUTABLE_P([${CC}_r])],[PTHREAD_CC="${CC}_r"])],
+                         [AC_CHECK_PROGS([PTHREAD_CC],[${CC}_r],[$CC])])])
+                ;;
+            esac
+        fi
+fi
+
+test -n "$PTHREAD_CC" || PTHREAD_CC="$CC"
+
+AC_SUBST([PTHREAD_LIBS])
+AC_SUBST([PTHREAD_CFLAGS])
+AC_SUBST([PTHREAD_CC])
+
+# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:
+if test "x$ax_pthread_ok" = "xyes"; then
+        ifelse([$1],,[AC_DEFINE([HAVE_PTHREAD],[1],[Define if you have POSIX threads libraries and header files.])],[$1])
+        :
+else
+        ax_pthread_ok=no
+        $2
+fi
+AC_LANG_POP
+])dnl AX_PTHREAD
diff -urpN asterisk-13.9.1/autoconf/libcurl.m4 asterisk-13.17.0/autoconf/libcurl.m4
--- asterisk-13.9.1/autoconf/libcurl.m4	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/autoconf/libcurl.m4	2017-07-12 13:12:08.000000000 +0200
@@ -1,3 +1,24 @@
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) 2006, David Shaw <dshaw@jabberwocky.com>
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at https://curl.haxx.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+###########################################################################
 # LIBCURL_CHECK_CONFIG ([DEFAULT-ACTION], [MINIMUM-VERSION],
 #                       [ACTION-IF-YES], [ACTION-IF-NO])
 # ----------------------------------------------------------
@@ -55,10 +76,14 @@ AC_DEFUN([AST_LIBCURL_CHECK_CONFIG],
   AH_TEMPLATE([LIBCURL_PROTOCOL_LDAP],[Defined if libcurl supports LDAP])
   AH_TEMPLATE([LIBCURL_PROTOCOL_DICT],[Defined if libcurl supports DICT])
   AH_TEMPLATE([LIBCURL_PROTOCOL_TFTP],[Defined if libcurl supports TFTP])
+  AH_TEMPLATE([LIBCURL_PROTOCOL_RTSP],[Defined if libcurl supports RTSP])
+  AH_TEMPLATE([LIBCURL_PROTOCOL_POP3],[Defined if libcurl supports POP3])
+  AH_TEMPLATE([LIBCURL_PROTOCOL_IMAP],[Defined if libcurl supports IMAP])
+  AH_TEMPLATE([LIBCURL_PROTOCOL_SMTP],[Defined if libcurl supports SMTP])
   AC_SUBST(PBX_CURL)
 
   AC_ARG_WITH(libcurl,
-     AC_HELP_STRING([--with-libcurl=DIR],[look for the curl library in DIR]),
+     AS_HELP_STRING([--with-libcurl=PREFIX],[look for the curl library in PREFIX/lib and headers in PREFIX/include]),
      [_libcurl_with=$withval],[_libcurl_with=ifelse([$1],,[yes],[$1])])
 
   if test "$_libcurl_with" != "no" ; then
@@ -72,10 +97,10 @@ AC_DEFUN([AST_LIBCURL_CHECK_CONFIG],
      if test -d "$_libcurl_with" ; then
         CURL_INCLUDE="-I$withval/include"
         _libcurl_ldflags="-L$withval/lib"
-        AC_PATH_PROG([_libcurl_config],[curl-config],["$withval/bin"],
+        AC_PATH_PROG([_libcurl_config],[curl-config],[],
                      ["$withval/bin"])
      else
-        AC_PATH_PROG([_libcurl_config],[curl-config])
+        AC_PATH_PROG([_libcurl_config],[curl-config],[],[$PATH])
      fi
 
      if test x$_libcurl_config != "x" ; then
@@ -143,18 +168,19 @@ AC_DEFUN([AST_LIBCURL_CHECK_CONFIG],
            _libcurl_save_libs=$LIBS
            LIBS="$CURL_LIB $LIBS"
 
-           AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <curl/curl.h>],[
+           AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <curl/curl.h>]],[[
 /* Try and use a few common options to force a failure if we are
    missing symbols or can't link. */
 int x;
 curl_easy_setopt(NULL,CURLOPT_URL,NULL);
 x=CURL_ERROR_SIZE;
 x=CURLOPT_WRITEFUNCTION;
-x=CURLOPT_FILE;
+x=CURLOPT_WRITEDATA;
 x=CURLOPT_ERRORBUFFER;
 x=CURLOPT_STDERR;
 x=CURLOPT_VERBOSE;
-])],libcurl_cv_lib_curl_usable=yes,libcurl_cv_lib_curl_usable=no)
+if (x) {;}
+]])],libcurl_cv_lib_curl_usable=yes,libcurl_cv_lib_curl_usable=no)
 
            CPPFLAGS=$_libcurl_save_cppflags
            LIBS=$_libcurl_save_libs
@@ -196,17 +222,23 @@ x=CURLOPT_VERBOSE;
 
               # We don't have --protocols, so just assume that all
               # protocols are available
-              _libcurl_protocols="HTTP FTP FILE TELNET LDAP DICT"
+              _libcurl_protocols="HTTP FTP FILE TELNET LDAP DICT TFTP"
 
               if test x$libcurl_feature_SSL = xyes ; then
                  _libcurl_protocols="$_libcurl_protocols HTTPS"
 
                  # FTPS wasn't standards-compliant until version
-                 # 7.11.0
+                 # 7.11.0 (0x070b00 == 461568)
                  if test $_libcurl_version -ge 461568; then
                     _libcurl_protocols="$_libcurl_protocols FTPS"
                  fi
               fi
+
+              # RTSP, IMAP, POP3 and SMTP were added in
+              # 7.20.0 (0x071400 == 463872)
+              if test $_libcurl_version -ge 463872; then
+                 _libcurl_protocols="$_libcurl_protocols RTSP IMAP POP3 SMTP"
+              fi
            fi
 
            for _libcurl_protocol in $_libcurl_protocols ; do
@@ -241,4 +273,3 @@ x=CURLOPT_VERBOSE;
 
   unset _libcurl_with
 ])dnl
-
diff -urpN asterisk-13.9.1/bootstrap.sh asterisk-13.17.0/bootstrap.sh
--- asterisk-13.9.1/bootstrap.sh	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/bootstrap.sh	2017-07-12 13:12:08.000000000 +0200
@@ -46,7 +46,7 @@ check_for_app aclocal${MY_AM_VER}
 
 echo "Generating the configure script ..."
 
-aclocal${MY_AM_VER} -I autoconf `find third-party/ -maxdepth 1 -type d -printf "-I %p "`
+aclocal${MY_AM_VER} -I autoconf `find third-party -maxdepth 1 -type d | xargs -I {} echo -I {}`
 autoconf${MY_AC_VER}
 autoheader${MY_AC_VER}
 automake${MY_AM_VER} --add-missing --copy 2>/dev/null
diff -urpN asterisk-13.9.1/bridges/bridge_builtin_features.c asterisk-13.17.0/bridges/bridge_builtin_features.c
--- asterisk-13.9.1/bridges/bridge_builtin_features.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/bridges/bridge_builtin_features.c	2017-07-12 13:12:08.000000000 +0200
@@ -202,6 +202,8 @@ static void start_automonitor(struct ast
 		return;
 	}
 
+	ast_monitor_setjoinfiles(peer_chan, 1);
+
 	if (features_cfg && !ast_strlen_zero(features_cfg->courtesytone)) {
 		ast_bridge_channel_queue_playfile(bridge_channel, NULL, features_cfg->courtesytone, NULL);
 		ast_bridge_channel_write_playfile(bridge_channel, NULL, features_cfg->courtesytone, NULL);
diff -urpN asterisk-13.9.1/bridges/bridge_native_rtp.c asterisk-13.17.0/bridges/bridge_native_rtp.c
--- asterisk-13.9.1/bridges/bridge_native_rtp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/bridges/bridge_native_rtp.c	2017-07-12 13:12:08.000000000 +0200
@@ -46,76 +46,214 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/frame.h"
 #include "asterisk/rtp_engine.h"
 
-/*! \brief Internal structure which contains information about bridged RTP channels */
-struct native_rtp_bridge_data {
+/*! \brief Internal structure which contains bridged RTP channel hook data */
+struct native_rtp_framehook_data {
 	/*! \brief Framehook used to intercept certain control frames */
 	int id;
 	/*! \brief Set when this framehook has been detached */
 	unsigned int detached;
 };
 
-/*! \brief Internal helper function which gets all RTP information (glue and instances) relating to the given channels */
-static enum ast_rtp_glue_result native_rtp_bridge_get(struct ast_channel *c0, struct ast_channel *c1, struct ast_rtp_glue **glue0,
-	struct ast_rtp_glue **glue1, struct ast_rtp_instance **instance0, struct ast_rtp_instance **instance1,
-	struct ast_rtp_instance **vinstance0, struct ast_rtp_instance **vinstance1)
-{
-	enum ast_rtp_glue_result audio_glue0_res;
-	enum ast_rtp_glue_result video_glue0_res;
-	enum ast_rtp_glue_result audio_glue1_res;
-	enum ast_rtp_glue_result video_glue1_res;
+struct rtp_glue_stream {
+	/*! \brief RTP instance */
+	struct ast_rtp_instance *instance;
+	/*! \brief glue result */
+	enum ast_rtp_glue_result result;
+};
 
-	if (!(*glue0 = ast_rtp_instance_get_glue(ast_channel_tech(c0)->type)) ||
-		!(*glue1 = ast_rtp_instance_get_glue(ast_channel_tech(c1)->type))) {
-		return AST_RTP_GLUE_RESULT_FORBID;
+struct rtp_glue_data {
+	/*!
+	 * \brief glue callbacks
+	 *
+	 * \note The glue data is considered valid if cb is not NULL.
+	 */
+	struct ast_rtp_glue *cb;
+	struct rtp_glue_stream audio;
+	struct rtp_glue_stream video;
+	/*! Combined glue result of both bridge channels. */
+	enum ast_rtp_glue_result result;
+};
+
+/*! \brief Internal structure which contains instance information about bridged RTP channels */
+struct native_rtp_bridge_channel_data {
+	/*! \brief Channel's hook data */
+	struct native_rtp_framehook_data *hook_data;
+	/*!
+	 * \brief Glue callbacks to bring remote channel streams back to Asterisk.
+	 * \note NULL if channel streams are local.
+	 */
+	struct ast_rtp_glue *remote_cb;
+	/*! \brief Channel's cached RTP glue information */
+	struct rtp_glue_data glue;
+};
+
+static void rtp_glue_data_init(struct rtp_glue_data *glue)
+{
+	glue->cb = NULL;
+	glue->audio.instance = NULL;
+	glue->audio.result = AST_RTP_GLUE_RESULT_FORBID;
+	glue->video.instance = NULL;
+	glue->video.result = AST_RTP_GLUE_RESULT_FORBID;
+	glue->result = AST_RTP_GLUE_RESULT_FORBID;
+}
+
+static void rtp_glue_data_destroy(struct rtp_glue_data *glue)
+{
+	if (!glue) {
+		return;
 	}
+	ao2_cleanup(glue->audio.instance);
+	ao2_cleanup(glue->video.instance);
+}
 
-	audio_glue0_res = (*glue0)->get_rtp_info(c0, instance0);
-	video_glue0_res = (*glue0)->get_vrtp_info ? (*glue0)->get_vrtp_info(c0, vinstance0) : AST_RTP_GLUE_RESULT_FORBID;
+static void rtp_glue_data_reset(struct rtp_glue_data *glue)
+{
+	rtp_glue_data_destroy(glue);
+	rtp_glue_data_init(glue);
+}
+
+static void native_rtp_bridge_channel_data_free(struct native_rtp_bridge_channel_data *data)
+{
+	ast_debug(2, "Destroying channel tech_pvt data %p\n", data);
+
+	/*
+	 * hook_data will probably already have been unreferenced by the framehook detach
+	 * and the pointer set to null.
+	 */
+	ao2_cleanup(data->hook_data);
+
+	rtp_glue_data_reset(&data->glue);
+	ast_free(data);
+}
+
+static struct native_rtp_bridge_channel_data *native_rtp_bridge_channel_data_alloc(void)
+{
+	struct native_rtp_bridge_channel_data *data;
 
-	audio_glue1_res = (*glue1)->get_rtp_info(c1, instance1);
-	video_glue1_res = (*glue1)->get_vrtp_info ? (*glue1)->get_vrtp_info(c1, vinstance1) : AST_RTP_GLUE_RESULT_FORBID;
+	data = ast_calloc(1, sizeof(*data));
+	if (data) {
+		rtp_glue_data_init(&data->glue);
+	}
+	return data;
+}
+
+/*!
+ * \internal
+ * \brief Helper function which gets all RTP information (glue and instances) relating to the given channels
+ *
+ * \retval 0 on success.
+ * \retval -1 on error.
+ */
+static int rtp_glue_data_get(struct ast_channel *c0, struct rtp_glue_data *glue0,
+	struct ast_channel *c1, struct rtp_glue_data *glue1)
+{
+	struct ast_rtp_glue *cb0;
+	struct ast_rtp_glue *cb1;
+	enum ast_rtp_glue_result combined_result;
+
+	cb0 = ast_rtp_instance_get_glue(ast_channel_tech(c0)->type);
+	cb1 = ast_rtp_instance_get_glue(ast_channel_tech(c1)->type);
+	if (!cb0 || !cb1) {
+		/* One or both channels doesn't have any RTP glue registered. */
+		return -1;
+	}
+
+	/* The glue callbacks bump the RTP instance refcounts for us. */
+
+	glue0->cb = cb0;
+	glue0->audio.result = cb0->get_rtp_info(c0, &glue0->audio.instance);
+	glue0->video.result = cb0->get_vrtp_info
+		? cb0->get_vrtp_info(c0, &glue0->video.instance) : AST_RTP_GLUE_RESULT_FORBID;
+
+	glue1->cb = cb1;
+	glue1->audio.result = cb1->get_rtp_info(c1, &glue1->audio.instance);
+	glue1->video.result = cb1->get_vrtp_info
+		? cb1->get_vrtp_info(c1, &glue1->video.instance) : AST_RTP_GLUE_RESULT_FORBID;
+
+	/*
+	 * Now determine the combined glue result.
+	 */
 
 	/* Apply any limitations on direct media bridging that may be present */
-	if (audio_glue0_res == audio_glue1_res && audio_glue1_res == AST_RTP_GLUE_RESULT_REMOTE) {
-		if ((*glue0)->allow_rtp_remote && !((*glue0)->allow_rtp_remote(c0, *instance1))) {
+	if (glue0->audio.result == glue1->audio.result && glue1->audio.result == AST_RTP_GLUE_RESULT_REMOTE) {
+		if (glue0->cb->allow_rtp_remote && !glue0->cb->allow_rtp_remote(c0, glue1->audio.instance)) {
 			/* If the allow_rtp_remote indicates that remote isn't allowed, revert to local bridge */
-			audio_glue0_res = audio_glue1_res = AST_RTP_GLUE_RESULT_LOCAL;
-		} else if ((*glue1)->allow_rtp_remote && !((*glue1)->allow_rtp_remote(c1, *instance0))) {
-			audio_glue0_res = audio_glue1_res = AST_RTP_GLUE_RESULT_LOCAL;
+			glue0->audio.result = glue1->audio.result = AST_RTP_GLUE_RESULT_LOCAL;
+		} else if (glue1->cb->allow_rtp_remote && !glue1->cb->allow_rtp_remote(c1, glue0->audio.instance)) {
+			glue0->audio.result = glue1->audio.result = AST_RTP_GLUE_RESULT_LOCAL;
 		}
 	}
-	if (video_glue0_res == video_glue1_res && video_glue1_res == AST_RTP_GLUE_RESULT_REMOTE) {
-		if ((*glue0)->allow_vrtp_remote && !((*glue0)->allow_vrtp_remote(c0, *instance1))) {
+	if (glue0->video.result == glue1->video.result && glue1->video.result == AST_RTP_GLUE_RESULT_REMOTE) {
+		if (glue0->cb->allow_vrtp_remote && !glue0->cb->allow_vrtp_remote(c0, glue1->audio.instance)) {
 			/* if the allow_vrtp_remote indicates that remote isn't allowed, revert to local bridge */
-			video_glue0_res = video_glue1_res = AST_RTP_GLUE_RESULT_LOCAL;
-		} else if ((*glue1)->allow_vrtp_remote && !((*glue1)->allow_vrtp_remote(c1, *instance0))) {
-			video_glue0_res = video_glue1_res = AST_RTP_GLUE_RESULT_LOCAL;
+			glue0->video.result = glue1->video.result = AST_RTP_GLUE_RESULT_LOCAL;
+		} else if (glue1->cb->allow_vrtp_remote && !glue1->cb->allow_vrtp_remote(c1, glue0->audio.instance)) {
+			glue0->video.result = glue1->video.result = AST_RTP_GLUE_RESULT_LOCAL;
 		}
 	}
 
 	/* If we are carrying video, and both sides are not going to remotely bridge... fail the native bridge */
-	if (video_glue0_res != AST_RTP_GLUE_RESULT_FORBID
-		&& (audio_glue0_res != AST_RTP_GLUE_RESULT_REMOTE
-			|| video_glue0_res != AST_RTP_GLUE_RESULT_REMOTE)) {
-		audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
-	}
-	if (video_glue1_res != AST_RTP_GLUE_RESULT_FORBID
-		&& (audio_glue1_res != AST_RTP_GLUE_RESULT_REMOTE
-			|| video_glue1_res != AST_RTP_GLUE_RESULT_REMOTE)) {
-		audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
+	if (glue0->video.result != AST_RTP_GLUE_RESULT_FORBID
+		&& (glue0->audio.result != AST_RTP_GLUE_RESULT_REMOTE
+			|| glue0->video.result != AST_RTP_GLUE_RESULT_REMOTE)) {
+		glue0->audio.result = AST_RTP_GLUE_RESULT_FORBID;
+	}
+	if (glue1->video.result != AST_RTP_GLUE_RESULT_FORBID
+		&& (glue1->audio.result != AST_RTP_GLUE_RESULT_REMOTE
+			|| glue1->video.result != AST_RTP_GLUE_RESULT_REMOTE)) {
+		glue1->audio.result = AST_RTP_GLUE_RESULT_FORBID;
 	}
 
 	/* The order of preference is: forbid, local, and remote. */
-	if (audio_glue0_res == AST_RTP_GLUE_RESULT_FORBID ||
-		audio_glue1_res == AST_RTP_GLUE_RESULT_FORBID) {
+	if (glue0->audio.result == AST_RTP_GLUE_RESULT_FORBID
+		|| glue1->audio.result == AST_RTP_GLUE_RESULT_FORBID) {
 		/* If any sort of bridge is forbidden just completely bail out and go back to generic bridging */
-		return AST_RTP_GLUE_RESULT_FORBID;
-	} else if (audio_glue0_res == AST_RTP_GLUE_RESULT_LOCAL ||
-		audio_glue1_res == AST_RTP_GLUE_RESULT_LOCAL) {
-		return AST_RTP_GLUE_RESULT_LOCAL;
+		combined_result = AST_RTP_GLUE_RESULT_FORBID;
+	} else if (glue0->audio.result == AST_RTP_GLUE_RESULT_LOCAL
+		|| glue1->audio.result == AST_RTP_GLUE_RESULT_LOCAL) {
+		combined_result = AST_RTP_GLUE_RESULT_LOCAL;
 	} else {
-		return AST_RTP_GLUE_RESULT_REMOTE;
+		combined_result = AST_RTP_GLUE_RESULT_REMOTE;
 	}
+	glue0->result = combined_result;
+	glue1->result = combined_result;
+
+	return 0;
+}
+
+/*!
+ * \internal
+ * \brief Get the current RTP native bridge combined glue result.
+ * \since 15.0.0
+ *
+ * \param c0 First bridge channel
+ * \param c1 Second bridge channel
+ *
+ * \note Both channels must be locked when calling this function.
+ *
+ * \return Current combined glue result.
+ */
+static enum ast_rtp_glue_result rtp_glue_get_current_combined_result(struct ast_channel *c0,
+	struct ast_channel *c1)
+{
+	struct rtp_glue_data glue_a;
+	struct rtp_glue_data glue_b;
+	struct rtp_glue_data *glue0;
+	struct rtp_glue_data *glue1;
+	enum ast_rtp_glue_result combined_result;
+
+	rtp_glue_data_init(&glue_a);
+	glue0 = &glue_a;
+	rtp_glue_data_init(&glue_b);
+	glue1 = &glue_b;
+	if (rtp_glue_data_get(c0, glue0, c1, glue1)) {
+		return AST_RTP_GLUE_RESULT_FORBID;
+	}
+
+	combined_result = glue0->result;
+	rtp_glue_data_destroy(glue0);
+	rtp_glue_data_destroy(glue1);
+	return combined_result;
 }
 
 /*!
@@ -131,50 +269,91 @@ static void native_rtp_bridge_start(stru
 {
 	struct ast_bridge_channel *bc0 = AST_LIST_FIRST(&bridge->channels);
 	struct ast_bridge_channel *bc1 = AST_LIST_LAST(&bridge->channels);
+	struct native_rtp_bridge_channel_data *data0;
+	struct native_rtp_bridge_channel_data *data1;
+	struct rtp_glue_data *glue0;
+	struct rtp_glue_data *glue1;
+	struct ast_format_cap *cap0;
+	struct ast_format_cap *cap1;
 	enum ast_rtp_glue_result native_type;
-	struct ast_rtp_glue *glue0, *glue1;
-	RAII_VAR(struct ast_rtp_instance *, instance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, instance1, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, vinstance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, vinstance1, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, tinstance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, tinstance1, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_format_cap *, cap0, ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT), ao2_cleanup);
-	RAII_VAR(struct ast_format_cap *, cap1, ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT), ao2_cleanup);
 
 	if (bc0 == bc1) {
 		return;
 	}
+	data0 = bc0->tech_pvt;
+	data1 = bc1->tech_pvt;
+	if (!data0 || !data1) {
+		/* Not all channels are joined with the bridge tech yet */
+		return;
+	}
+	glue0 = &data0->glue;
+	glue1 = &data1->glue;
 
 	ast_channel_lock_both(bc0->chan, bc1->chan);
-	native_type = native_rtp_bridge_get(bc0->chan, bc1->chan, &glue0, &glue1, &instance0, &instance1, &vinstance0, &vinstance1);
+
+	if (!glue0->cb || !glue1->cb) {
+		/*
+		 * Somebody doesn't have glue data so the bridge isn't running
+		 *
+		 * Actually neither side should have glue data.
+		 */
+		ast_assert(!glue0->cb && !glue1->cb);
+
+		if (rtp_glue_data_get(bc0->chan, glue0, bc1->chan, glue1)) {
+			/*
+			 * This might happen if one of the channels got masqueraded
+			 * at a critical time.  It's a bit of a stretch even then
+			 * since the channel is in a bridge.
+			 */
+			goto done;
+		}
+	}
+
+	ast_debug(2, "Bridge '%s'.  Tech starting '%s' and '%s' with target '%s'\n",
+		bridge->uniqueid, ast_channel_name(bc0->chan), ast_channel_name(bc1->chan),
+		target ? ast_channel_name(target) : "none");
+
+	native_type = glue0->result;
 
 	switch (native_type) {
 	case AST_RTP_GLUE_RESULT_LOCAL:
-		if (ast_rtp_instance_get_engine(instance0)->local_bridge) {
-			ast_rtp_instance_get_engine(instance0)->local_bridge(instance0, instance1);
+		if (ast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge) {
+			ast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge(glue0->audio.instance, glue1->audio.instance);
 		}
-		if (ast_rtp_instance_get_engine(instance1)->local_bridge) {
-			ast_rtp_instance_get_engine(instance1)->local_bridge(instance1, instance0);
+		if (ast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge) {
+			ast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge(glue1->audio.instance, glue0->audio.instance);
 		}
-		ast_rtp_instance_set_bridged(instance0, instance1);
-		ast_rtp_instance_set_bridged(instance1, instance0);
+		ast_rtp_instance_set_bridged(glue0->audio.instance, glue1->audio.instance);
+		ast_rtp_instance_set_bridged(glue1->audio.instance, glue0->audio.instance);
 		ast_verb(4, "Locally RTP bridged '%s' and '%s' in stack\n",
 			ast_channel_name(bc0->chan), ast_channel_name(bc1->chan));
 		break;
-
 	case AST_RTP_GLUE_RESULT_REMOTE:
-		if (glue0->get_codec) {
-			glue0->get_codec(bc0->chan, cap0);
+		cap0 = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+		cap1 = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+		if (!cap0 || !cap1) {
+			ao2_cleanup(cap0);
+			ao2_cleanup(cap1);
+			break;
 		}
-		if (glue1->get_codec) {
-			glue1->get_codec(bc1->chan, cap1);
+
+		if (glue0->cb->get_codec) {
+			glue0->cb->get_codec(bc0->chan, cap0);
+		}
+		if (glue1->cb->get_codec) {
+			glue1->cb->get_codec(bc1->chan, cap1);
 		}
 
-		/* If we have a target, it's the channel that received the UNHOLD or UPDATE_RTP_PEER frame and was told to resume */
+		/*
+		 * If we have a target, it's the channel that received the UNHOLD or
+		 * UPDATE_RTP_PEER frame and was told to resume
+		 */
 		if (!target) {
-			glue0->update_peer(bc0->chan, instance1, vinstance1, tinstance1, cap1, 0);
-			glue1->update_peer(bc1->chan, instance0, vinstance0, tinstance0, cap0, 0);
+			/* Send both channels to remote */
+			data0->remote_cb = glue0->cb;
+			data1->remote_cb = glue1->cb;
+			glue0->cb->update_peer(bc0->chan, glue1->audio.instance, glue1->video.instance, NULL, cap1, 0);
+			glue1->cb->update_peer(bc1->chan, glue0->audio.instance, glue0->video.instance, NULL, cap0, 0);
 			ast_verb(4, "Remotely bridged '%s' and '%s' - media will flow directly between them\n",
 				ast_channel_name(bc0->chan), ast_channel_name(bc1->chan));
 		} else {
@@ -184,51 +363,121 @@ static void native_rtp_bridge_start(stru
 			 * already set up to handle the new media path or will have its own set of updates independent
 			 * of this pass.
 			 */
+			ast_debug(2, "Bridge '%s'.  Sending '%s' back to remote\n",
+				bridge->uniqueid, ast_channel_name(target));
 			if (bc0->chan == target) {
-				glue0->update_peer(bc0->chan, instance1, vinstance1, tinstance1, cap1, 0);
+				data0->remote_cb = glue0->cb;
+				glue0->cb->update_peer(bc0->chan, glue1->audio.instance, glue1->video.instance, NULL, cap1, 0);
 			} else {
-				glue1->update_peer(bc1->chan, instance0, vinstance0, tinstance0, cap0, 0);
+				data1->remote_cb = glue1->cb;
+				glue1->cb->update_peer(bc1->chan, glue0->audio.instance, glue0->video.instance, NULL, cap0, 0);
 			}
 		}
+
+		ao2_cleanup(cap0);
+		ao2_cleanup(cap1);
 		break;
 	case AST_RTP_GLUE_RESULT_FORBID:
 		break;
 	}
 
+	if (native_type != AST_RTP_GLUE_RESULT_REMOTE) {
+		/* Bring any remaining channels back to us. */
+		if (data0->remote_cb) {
+			ast_debug(2, "Bridge '%s'.  Bringing back '%s' to us\n",
+				bridge->uniqueid, ast_channel_name(bc0->chan));
+			data0->remote_cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);
+			data0->remote_cb = NULL;
+		}
+		if (data1->remote_cb) {
+			ast_debug(2, "Bridge '%s'.  Bringing back '%s' to us\n",
+				bridge->uniqueid, ast_channel_name(bc1->chan));
+			data1->remote_cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);
+			data1->remote_cb = NULL;
+		}
+	}
+
+done:
 	ast_channel_unlock(bc0->chan);
 	ast_channel_unlock(bc1->chan);
 }
 
+/*!
+ * \internal
+ * \brief Stop native RTP bridging of two channels
+ *
+ * \param bridge The bridge that had native RTP bridging happening on it
+ * \param target If remote RTP bridging, the channel that is held.
+ *
+ * \note The first channel to leave the bridge triggers the cleanup for both channels
+ */
 static void native_rtp_bridge_stop(struct ast_bridge *bridge, struct ast_channel *target)
 {
 	struct ast_bridge_channel *bc0 = AST_LIST_FIRST(&bridge->channels);
 	struct ast_bridge_channel *bc1 = AST_LIST_LAST(&bridge->channels);
-	enum ast_rtp_glue_result native_type;
-	struct ast_rtp_glue *glue0, *glue1 = NULL;
-	RAII_VAR(struct ast_rtp_instance *, instance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, instance1, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, vinstance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, vinstance1, NULL, ao2_cleanup);
+	struct native_rtp_bridge_channel_data *data0;
+	struct native_rtp_bridge_channel_data *data1;
+	struct rtp_glue_data *glue0;
+	struct rtp_glue_data *glue1;
 
 	if (bc0 == bc1) {
 		return;
 	}
+	data0 = bc0->tech_pvt;
+	data1 = bc1->tech_pvt;
+	if (!data0 || !data1) {
+		/* Not all channels are joined with the bridge tech */
+		return;
+	}
+	glue0 = &data0->glue;
+	glue1 = &data1->glue;
+
+	ast_debug(2, "Bridge '%s'.  Tech stopping '%s' and '%s' with target '%s'\n",
+		bridge->uniqueid, ast_channel_name(bc0->chan), ast_channel_name(bc1->chan),
+		target ? ast_channel_name(target) : "none");
+
+	if (!glue0->cb || !glue1->cb) {
+		/*
+		 * Somebody doesn't have glue data so the bridge isn't running
+		 *
+		 * Actually neither side should have glue data.
+		 */
+		ast_assert(!glue0->cb && !glue1->cb);
+		/* At most one channel can be left at the remote endpoint here. */
+		ast_assert(!data0->remote_cb || !data1->remote_cb);
+
+		/* Bring selected channel streams back to us */
+		if (data0->remote_cb && (!target || target == bc0->chan)) {
+			ast_channel_lock(bc0->chan);
+			ast_debug(2, "Bridge '%s'.  Bringing back '%s' to us\n",
+				bridge->uniqueid, ast_channel_name(bc0->chan));
+			data0->remote_cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);
+			data0->remote_cb = NULL;
+			ast_channel_unlock(bc0->chan);
+		}
+		if (data1->remote_cb && (!target || target == bc1->chan)) {
+			ast_channel_lock(bc1->chan);
+			ast_debug(2, "Bridge '%s'.  Bringing back '%s' to us\n",
+				bridge->uniqueid, ast_channel_name(bc1->chan));
+			data1->remote_cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);
+			data1->remote_cb = NULL;
+			ast_channel_unlock(bc1->chan);
+		}
+		return;
+	}
 
 	ast_channel_lock_both(bc0->chan, bc1->chan);
-	native_type = native_rtp_bridge_get(bc0->chan, bc1->chan, &glue0, &glue1, &instance0, &instance1, &vinstance0, &vinstance1);
 
-	switch (native_type) {
+	switch (glue0->result) {
 	case AST_RTP_GLUE_RESULT_LOCAL:
-		if (ast_rtp_instance_get_engine(instance0)->local_bridge) {
-			ast_rtp_instance_get_engine(instance0)->local_bridge(instance0, NULL);
+		if (ast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge) {
+			ast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge(glue0->audio.instance, NULL);
 		}
-		if (instance1 && ast_rtp_instance_get_engine(instance1)->local_bridge) {
-			ast_rtp_instance_get_engine(instance1)->local_bridge(instance1, NULL);
-		}
-		ast_rtp_instance_set_bridged(instance0, NULL);
-		if (instance1) {
-			ast_rtp_instance_set_bridged(instance1, NULL);
+		if (ast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge) {
+			ast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge(glue1->audio.instance, NULL);
 		}
+		ast_rtp_instance_set_bridged(glue0->audio.instance, NULL);
+		ast_rtp_instance_set_bridged(glue1->audio.instance, NULL);
 		break;
 	case AST_RTP_GLUE_RESULT_REMOTE:
 		if (target) {
@@ -236,10 +485,38 @@ static void native_rtp_bridge_stop(struc
 			 * If a target was provided, it is being put on hold and should expect to
 			 * receive media from Asterisk instead of what it was previously connected to.
 			 */
+			ast_debug(2, "Bridge '%s'.  Bringing back '%s' to us\n",
+				bridge->uniqueid, ast_channel_name(target));
 			if (bc0->chan == target) {
-				glue0->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);
+				data0->remote_cb = NULL;
+				glue0->cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);
 			} else {
-				glue1->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);
+				data1->remote_cb = NULL;
+				glue1->cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);
+			}
+		} else {
+			data0->remote_cb = NULL;
+			data1->remote_cb = NULL;
+			/*
+			 * XXX We don't want to bring back the channels if we are
+			 * switching to T.38.  We have received a reinvite on one channel
+			 * and we will be sending a reinvite on the other to start T.38.
+			 * If we bring the streams back now we confuse the chan_pjsip
+			 * channel driver processing the incoming T.38 reinvite with
+			 * reinvite glare.  I think this is really a bug in chan_pjsip
+			 * that this exception case is working around.
+			 */
+			if (rtp_glue_get_current_combined_result(bc0->chan, bc1->chan)
+				!= AST_RTP_GLUE_RESULT_FORBID) {
+				ast_debug(2, "Bridge '%s'.  Bringing back '%s' and '%s' to us\n",
+					bridge->uniqueid, ast_channel_name(bc0->chan),
+					ast_channel_name(bc1->chan));
+				glue0->cb->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);
+				glue1->cb->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);
+			} else {
+				ast_debug(2, "Bridge '%s'.  Skip bringing back '%s' and '%s' to us\n",
+					bridge->uniqueid, ast_channel_name(bc0->chan),
+					ast_channel_name(bc1->chan));
 			}
 		}
 		break;
@@ -247,10 +524,8 @@ static void native_rtp_bridge_stop(struc
 		break;
 	}
 
-	if (!target && native_type != AST_RTP_GLUE_RESULT_FORBID) {
-		glue0->update_peer(bc0->chan, NULL, NULL, NULL, NULL, 0);
-		glue1->update_peer(bc1->chan, NULL, NULL, NULL, NULL, 0);
-	}
+	rtp_glue_data_reset(glue0);
+	rtp_glue_data_reset(glue1);
 
 	ast_debug(2, "Discontinued RTP bridging of '%s' and '%s' - media will flow through Asterisk core\n",
 		ast_channel_name(bc0->chan), ast_channel_name(bc1->chan));
@@ -259,18 +534,21 @@ static void native_rtp_bridge_stop(struc
 	ast_channel_unlock(bc1->chan);
 }
 
-/*! \brief Frame hook that is called to intercept hold/unhold */
-static struct ast_frame *native_rtp_framehook(struct ast_channel *chan, struct ast_frame *f, enum ast_framehook_event event, void *data)
+/*!
+ * \internal
+ * \brief Frame hook that is called to intercept hold/unhold
+ */
+static struct ast_frame *native_rtp_framehook(struct ast_channel *chan,
+	struct ast_frame *f, enum ast_framehook_event event, void *data)
 {
 	RAII_VAR(struct ast_bridge *, bridge, NULL, ao2_cleanup);
-	struct native_rtp_bridge_data *native_data = data;
+	struct native_rtp_framehook_data *native_data = data;
 
 	if (!f || (event != AST_FRAMEHOOK_EVENT_WRITE)) {
 		return f;
 	}
 
 	bridge = ast_channel_get_bridge(chan);
-
 	if (bridge) {
 		/* native_rtp_bridge_start/stop are not being called from bridging
 		   core so we need to lock the bridge prior to calling these functions
@@ -294,44 +572,49 @@ static struct ast_frame *native_rtp_fram
 		}
 		ast_bridge_unlock(bridge);
 		ast_channel_lock(chan);
-
 	}
 
 	return f;
 }
 
-/*! \brief Callback function which informs upstream if we are consuming a frame of a specific type */
+/*!
+ * \internal
+ * \brief Callback function which informs upstream if we are consuming a frame of a specific type
+ */
 static int native_rtp_framehook_consume(void *data, enum ast_frame_type type)
 {
 	return (type == AST_FRAME_CONTROL ? 1 : 0);
 }
 
-/*! \brief Internal helper function which checks whether the channels are compatible with our native bridging */
+/*!
+ * \internal
+ * \brief Internal helper function which checks whether a channel is compatible with our native bridging
+ */
 static int native_rtp_bridge_capable(struct ast_channel *chan)
 {
 	return !ast_channel_has_hook_requiring_audio(chan);
 }
 
-static int native_rtp_bridge_compatible(struct ast_bridge *bridge)
+/*!
+ * \internal
+ * \brief Internal helper function which checks whether both channels are compatible with our native bridging
+ */
+static int native_rtp_bridge_compatible_check(struct ast_bridge *bridge, struct ast_bridge_channel *bc0, struct ast_bridge_channel *bc1)
 {
-	struct ast_bridge_channel *bc0 = AST_LIST_FIRST(&bridge->channels);
-	struct ast_bridge_channel *bc1 = AST_LIST_LAST(&bridge->channels);
 	enum ast_rtp_glue_result native_type;
-	struct ast_rtp_glue *glue0, *glue1;
-	RAII_VAR(struct ast_rtp_instance *, instance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, instance1, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, vinstance0, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_rtp_instance *, vinstance1, NULL, ao2_cleanup);
+	int read_ptime0;
+	int read_ptime1;
+	int write_ptime0;
+	int write_ptime1;
+	struct rtp_glue_data glue_a;
+	struct rtp_glue_data glue_b;
 	RAII_VAR(struct ast_format_cap *, cap0, NULL, ao2_cleanup);
 	RAII_VAR(struct ast_format_cap *, cap1, NULL, ao2_cleanup);
-	int read_ptime0, read_ptime1, write_ptime0, write_ptime1;
+	RAII_VAR(struct rtp_glue_data *, glue0, NULL, rtp_glue_data_destroy);
+	RAII_VAR(struct rtp_glue_data *, glue1, NULL, rtp_glue_data_destroy);
 
-	/* We require two channels before even considering native bridging */
-	if (bridge->num_channels != 2) {
-		ast_debug(1, "Bridge '%s' can not use native RTP bridge as two channels are required\n",
-			bridge->uniqueid);
-		return 0;
-	}
+	ast_debug(1, "Bridge '%s'.  Checking compatability for channels '%s' and '%s'\n",
+		bridge->uniqueid, ast_channel_name(bc0->chan), ast_channel_name(bc1->chan));
 
 	if (!native_rtp_bridge_capable(bc0->chan)) {
 		ast_debug(1, "Bridge '%s' can not use native RTP bridge as channel '%s' has features which prevent it\n",
@@ -345,29 +628,43 @@ static int native_rtp_bridge_compatible(
 		return 0;
 	}
 
-	if ((native_type = native_rtp_bridge_get(bc0->chan, bc1->chan, &glue0, &glue1, &instance0, &instance1, &vinstance0, &vinstance1))
-		== AST_RTP_GLUE_RESULT_FORBID) {
+	rtp_glue_data_init(&glue_a);
+	glue0 = &glue_a;
+	rtp_glue_data_init(&glue_b);
+	glue1 = &glue_b;
+	if (rtp_glue_data_get(bc0->chan, glue0, bc1->chan, glue1)) {
+		ast_debug(1, "Bridge '%s' can not use native RTP bridge as could not get details\n",
+			bridge->uniqueid);
+		return 0;
+	}
+	native_type = glue0->result;
+
+	if (native_type == AST_RTP_GLUE_RESULT_FORBID) {
 		ast_debug(1, "Bridge '%s' can not use native RTP bridge as it was forbidden while getting details\n",
 			bridge->uniqueid);
 		return 0;
 	}
 
-	if (ao2_container_count(bc0->features->dtmf_hooks) && ast_rtp_instance_dtmf_mode_get(instance0)) {
+	if (ao2_container_count(bc0->features->dtmf_hooks)
+		&& ast_rtp_instance_dtmf_mode_get(glue0->audio.instance)) {
 		ast_debug(1, "Bridge '%s' can not use native RTP bridge as channel '%s' has DTMF hooks\n",
 			bridge->uniqueid, ast_channel_name(bc0->chan));
 		return 0;
 	}
 
-	if (ao2_container_count(bc1->features->dtmf_hooks) && ast_rtp_instance_dtmf_mode_get(instance1)) {
+	if (ao2_container_count(bc1->features->dtmf_hooks)
+		&& ast_rtp_instance_dtmf_mode_get(glue1->audio.instance)) {
 		ast_debug(1, "Bridge '%s' can not use native RTP bridge as channel '%s' has DTMF hooks\n",
 			bridge->uniqueid, ast_channel_name(bc1->chan));
 		return 0;
 	}
 
-	if ((native_type == AST_RTP_GLUE_RESULT_LOCAL) && ((ast_rtp_instance_get_engine(instance0)->local_bridge !=
-		ast_rtp_instance_get_engine(instance1)->local_bridge) ||
-		(ast_rtp_instance_get_engine(instance0)->dtmf_compatible &&
-			!ast_rtp_instance_get_engine(instance0)->dtmf_compatible(bc0->chan, instance0, bc1->chan, instance1)))) {
+	if (native_type == AST_RTP_GLUE_RESULT_LOCAL
+		&& (ast_rtp_instance_get_engine(glue0->audio.instance)->local_bridge
+			!= ast_rtp_instance_get_engine(glue1->audio.instance)->local_bridge
+			|| (ast_rtp_instance_get_engine(glue0->audio.instance)->dtmf_compatible
+				&& !ast_rtp_instance_get_engine(glue0->audio.instance)->dtmf_compatible(bc0->chan,
+					glue0->audio.instance, bc1->chan, glue1->audio.instance)))) {
 		ast_debug(1, "Bridge '%s' can not use local native RTP bridge as local bridge or DTMF is not compatible\n",
 			bridge->uniqueid);
 		return 0;
@@ -380,17 +677,22 @@ static int native_rtp_bridge_compatible(
 	}
 
 	/* Make sure that codecs match */
-	if (glue0->get_codec) {
-		glue0->get_codec(bc0->chan, cap0);
+	if (glue0->cb->get_codec) {
+		glue0->cb->get_codec(bc0->chan, cap0);
 	}
-	if (glue1->get_codec) {
-		glue1->get_codec(bc1->chan, cap1);
+	if (glue1->cb->get_codec) {
+		glue1->cb->get_codec(bc1->chan, cap1);
 	}
-	if (ast_format_cap_count(cap0) != 0 && ast_format_cap_count(cap1) != 0 && !ast_format_cap_iscompatible(cap0, cap1)) {
+	if (ast_format_cap_count(cap0) != 0
+		&& ast_format_cap_count(cap1) != 0
+		&& !ast_format_cap_iscompatible(cap0, cap1)) {
 		struct ast_str *codec_buf0 = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
 		struct ast_str *codec_buf1 = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
-		ast_debug(1, "Channel codec0 = %s is not codec1 = %s, cannot native bridge in RTP.\n",
-			ast_format_cap_get_names(cap0, &codec_buf0), ast_format_cap_get_names(cap1, &codec_buf1));
+
+		ast_debug(1, "Bridge '%s': Channel codec0 = %s is not codec1 = %s, cannot native bridge in RTP.\n",
+			bridge->uniqueid,
+			ast_format_cap_get_names(cap0, &codec_buf0),
+			ast_format_cap_get_names(cap1, &codec_buf1));
 		return 0;
 	}
 
@@ -400,18 +702,50 @@ static int native_rtp_bridge_compatible(
 	write_ptime1 = ast_format_cap_get_format_framing(cap1, ast_channel_rawwriteformat(bc1->chan));
 
 	if (read_ptime0 != write_ptime1 || read_ptime1 != write_ptime0) {
-		ast_debug(1, "Packetization differs between RTP streams (%d != %d or %d != %d). Cannot native bridge in RTP\n",
-				read_ptime0, write_ptime1, read_ptime1, write_ptime0);
+		ast_debug(1, "Bridge '%s': Packetization differs between RTP streams (%d != %d or %d != %d). Cannot native bridge in RTP\n",
+			bridge->uniqueid,
+			read_ptime0, write_ptime1, read_ptime1, write_ptime0);
 		return 0;
 	}
 
 	return 1;
 }
 
-/*! \brief Helper function which adds frame hook to bridge channel */
+/*!
+ * \internal
+ * \brief Called by the bridge core "compatible' callback
+ */
+static int native_rtp_bridge_compatible(struct ast_bridge *bridge)
+{
+	struct ast_bridge_channel *bc0;
+	struct ast_bridge_channel *bc1;
+	int is_compatible;
+
+	/* We require two channels before even considering native bridging */
+	if (bridge->num_channels != 2) {
+		ast_debug(1, "Bridge '%s' can not use native RTP bridge as two channels are required\n",
+			bridge->uniqueid);
+		return 0;
+	}
+
+	bc0 = AST_LIST_FIRST(&bridge->channels);
+	bc1 = AST_LIST_LAST(&bridge->channels);
+
+	ast_channel_lock_both(bc0->chan, bc1->chan);
+	is_compatible = native_rtp_bridge_compatible_check(bridge, bc0, bc1);
+	ast_channel_unlock(bc0->chan);
+	ast_channel_unlock(bc1->chan);
+
+	return is_compatible;
+}
+
+/*!
+ * \internal
+ * \brief Helper function which adds frame hook to bridge channel
+ */
 static int native_rtp_bridge_framehook_attach(struct ast_bridge_channel *bridge_channel)
 {
-	struct native_rtp_bridge_data *data = ao2_alloc(sizeof(*data), NULL);
+	struct native_rtp_bridge_channel_data *data = bridge_channel->tech_pvt;
 	static struct ast_framehook_interface hook = {
 		.version = AST_FRAMEHOOK_INTERFACE_VERSION,
 		.event_cb = native_rtp_framehook,
@@ -420,45 +754,82 @@ static int native_rtp_bridge_framehook_a
 		.disable_inheritance = 1,
 	};
 
-	if (!data) {
+	ast_assert(data->hook_data == NULL);
+	data->hook_data = ao2_alloc_options(sizeof(*data->hook_data), NULL,
+		AO2_ALLOC_OPT_LOCK_NOLOCK);
+	if (!data->hook_data) {
 		return -1;
 	}
 
+	ast_debug(2, "Bridge '%s'.  Attaching hook data %p to '%s'\n",
+		bridge_channel->bridge->uniqueid, data, ast_channel_name(bridge_channel->chan));
+
 	ast_channel_lock(bridge_channel->chan);
-	hook.data = ao2_bump(data);
-	data->id = ast_framehook_attach(bridge_channel->chan, &hook);
+	/* We're giving 1 ref to the framehook and keeping the one from the alloc for ourselves */
+	hook.data = ao2_bump(data->hook_data);
+	data->hook_data->id = ast_framehook_attach(bridge_channel->chan, &hook);
 	ast_channel_unlock(bridge_channel->chan);
-	if (data->id < 0) {
-		/* We need to drop both the reference we hold, and the one the framehook would hold */
-		ao2_ref(data, -2);
+	if (data->hook_data->id < 0) {
+		/*
+		 * We need to drop both the reference we hold in data,
+		 * and the one the framehook would hold.
+		 */
+		ao2_ref(data->hook_data, -2);
+		data->hook_data = NULL;
+
 		return -1;
 	}
 
-	bridge_channel->tech_pvt = data;
-
 	return 0;
 }
 
-/*! \brief Helper function which removes frame hook from bridge channel */
+/*!
+ * \internal
+ * \brief Helper function which removes frame hook from bridge channel
+ */
 static void native_rtp_bridge_framehook_detach(struct ast_bridge_channel *bridge_channel)
 {
-	RAII_VAR(struct native_rtp_bridge_data *, data, bridge_channel->tech_pvt, ao2_cleanup);
+	struct native_rtp_bridge_channel_data *data = bridge_channel->tech_pvt;
 
-	if (!data) {
+	if (!data || !data->hook_data) {
 		return;
 	}
 
+	ast_debug(2, "Bridge '%s'.  Detaching hook data %p from '%s'\n",
+		bridge_channel->bridge->uniqueid, data->hook_data, ast_channel_name(bridge_channel->chan));
+
 	ast_channel_lock(bridge_channel->chan);
-	ast_framehook_detach(bridge_channel->chan, data->id);
-	data->detached = 1;
+	ast_framehook_detach(bridge_channel->chan, data->hook_data->id);
+	data->hook_data->detached = 1;
 	ast_channel_unlock(bridge_channel->chan);
-	bridge_channel->tech_pvt = NULL;
+	ao2_cleanup(data->hook_data);
+	data->hook_data = NULL;
 }
 
+/*!
+ * \internal
+ * \brief Called by the bridge core 'join' callback for each channel joining he bridge
+ */
 static int native_rtp_bridge_join(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
 {
-	native_rtp_bridge_framehook_detach(bridge_channel);
+	ast_debug(2, "Bridge '%s'.  Channel '%s' is joining bridge tech\n",
+		bridge->uniqueid, ast_channel_name(bridge_channel->chan));
+
+	ast_assert(bridge_channel->tech_pvt == NULL);
+
+	if (bridge_channel->suspended) {
+		/* The channel will rejoin when it is unsuspended */
+		return 0;
+	}
+
+	bridge_channel->tech_pvt = native_rtp_bridge_channel_data_alloc();
+	if (!bridge_channel->tech_pvt) {
+		return -1;
+	}
+
 	if (native_rtp_bridge_framehook_attach(bridge_channel)) {
+		native_rtp_bridge_channel_data_free(bridge_channel->tech_pvt);
+		bridge_channel->tech_pvt = NULL;
 		return -1;
 	}
 
@@ -466,20 +837,81 @@ static int native_rtp_bridge_join(struct
 	return 0;
 }
 
+/*!
+ * \internal
+ * \brief Add the channel back into the bridge
+ */
 static void native_rtp_bridge_unsuspend(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
 {
+	ast_debug(2, "Bridge '%s'.  Channel '%s' is unsuspended back to bridge tech\n",
+		bridge->uniqueid, ast_channel_name(bridge_channel->chan));
 	native_rtp_bridge_join(bridge, bridge_channel);
 }
 
+/*!
+ * \internal
+ * \brief Leave the bridge
+ */
 static void native_rtp_bridge_leave(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
 {
+	ast_debug(2, "Bridge '%s'.  Channel '%s' is leaving bridge tech\n",
+		bridge->uniqueid, ast_channel_name(bridge_channel->chan));
+
+	if (!bridge_channel->tech_pvt) {
+		return;
+	}
+
 	native_rtp_bridge_framehook_detach(bridge_channel);
 	native_rtp_bridge_stop(bridge, NULL);
+
+	native_rtp_bridge_channel_data_free(bridge_channel->tech_pvt);
+	bridge_channel->tech_pvt = NULL;
+}
+
+/*!
+ * \internal
+ * \brief Suspend the channel from the bridge
+ */
+static void native_rtp_bridge_suspend(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
+{
+	ast_debug(2, "Bridge '%s'.  Channel '%s' is suspending from bridge tech\n",
+		bridge->uniqueid, ast_channel_name(bridge_channel->chan));
+	native_rtp_bridge_leave(bridge, bridge_channel);
 }
 
 static int native_rtp_bridge_write(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, struct ast_frame *frame)
 {
-	return ast_bridge_queue_everyone_else(bridge, bridge_channel, frame);
+	const struct ast_control_t38_parameters *t38_parameters;
+	int defer = 0;
+
+	if (!ast_bridge_queue_everyone_else(bridge, bridge_channel, frame)) {
+		/* This frame was successfully queued so no need to defer */
+		return 0;
+	}
+
+	/* Depending on the frame defer it so when the next channel joins it receives it */
+	switch (frame->frametype) {
+	case AST_FRAME_CONTROL:
+		switch (frame->subclass.integer) {
+		case AST_CONTROL_T38_PARAMETERS:
+			t38_parameters = frame->data.ptr;
+			switch (t38_parameters->request_response) {
+			case AST_T38_REQUEST_NEGOTIATE:
+				defer = -1;
+				break;
+			default:
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return defer;
 }
 
 static struct ast_bridge_technology native_rtp_bridge = {
@@ -489,7 +921,7 @@ static struct ast_bridge_technology nati
 	.join = native_rtp_bridge_join,
 	.unsuspend = native_rtp_bridge_unsuspend,
 	.leave = native_rtp_bridge_leave,
-	.suspend = native_rtp_bridge_leave,
+	.suspend = native_rtp_bridge_suspend,
 	.write = native_rtp_bridge_write,
 	.compatible = native_rtp_bridge_compatible,
 };
diff -urpN asterisk-13.9.1/bridges/bridge_simple.c asterisk-13.17.0/bridges/bridge_simple.c
--- asterisk-13.9.1/bridges/bridge_simple.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/bridges/bridge_simple.c	2017-07-12 13:12:08.000000000 +0200
@@ -63,7 +63,37 @@ static int simple_bridge_join(struct ast
 
 static int simple_bridge_write(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, struct ast_frame *frame)
 {
-	return ast_bridge_queue_everyone_else(bridge, bridge_channel, frame);
+	const struct ast_control_t38_parameters *t38_parameters;
+	int defer = 0;
+
+	if (!ast_bridge_queue_everyone_else(bridge, bridge_channel, frame)) {
+		/* This frame was successfully queued so no need to defer */
+		return 0;
+	}
+
+	/* Depending on the frame defer it so when the next channel joins it receives it */
+	switch (frame->frametype) {
+	case AST_FRAME_CONTROL:
+		switch (frame->subclass.integer) {
+		case AST_CONTROL_T38_PARAMETERS:
+			t38_parameters = frame->data.ptr;
+			switch (t38_parameters->request_response) {
+			case AST_T38_REQUEST_NEGOTIATE:
+				defer = -1;
+				break;
+			default:
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return defer;
 }
 
 static struct ast_bridge_technology simple_bridge = {
diff -urpN asterisk-13.9.1/bridges/bridge_softmix.c asterisk-13.17.0/bridges/bridge_softmix.c
--- asterisk-13.9.1/bridges/bridge_softmix.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/bridges/bridge_softmix.c	2017-07-12 13:12:08.000000000 +0200
@@ -306,7 +306,8 @@ static void softmix_process_write_audio(
 		if (entry->trans_pvt && !entry->out_frame) {
 			entry->out_frame = ast_translate(entry->trans_pvt, &sc->write_frame, 0);
 		}
-		if (entry->out_frame && (entry->out_frame->datalen < MAX_DATALEN)) {
+		if (entry->out_frame && entry->out_frame->frametype == AST_FRAME_VOICE
+				&& entry->out_frame->datalen < MAX_DATALEN) {
 			ao2_replace(sc->write_frame.subclass.format, entry->out_frame->subclass.format);
 			memcpy(sc->final_buf, entry->out_frame->data.ptr, entry->out_frame->datalen);
 			sc->write_frame.datalen = entry->out_frame->datalen;
@@ -359,6 +360,9 @@ static void set_softmix_bridge_data(int
 	struct ast_format *slin_format;
 	int setup_fail;
 
+	/* The callers have already ensured that sc is never NULL. */
+	ast_assert(sc != NULL);
+
 	slin_format = ast_format_cache_get_slin_by_rate(rate);
 
 	ast_mutex_lock(&sc->lock);
@@ -439,21 +443,6 @@ static void softmix_bridge_unsuspend(str
 	}
 }
 
-/*!
- * \internal
- * \brief Indicate a source change to the channel.
- * \since 12.0.0
- *
- * \param bridge_channel Which channel source is changing.
- *
- * \retval 0 on success.
- * \retval -1 on error.
- */
-static int softmix_src_change(struct ast_bridge_channel *bridge_channel)
-{
-	return ast_bridge_channel_queue_control_data(bridge_channel, AST_CONTROL_SRCCHANGE, NULL, 0);
-}
-
 /*! \brief Function called when a channel is joined into the bridge */
 static int softmix_bridge_join(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel)
 {
@@ -470,8 +459,6 @@ static int softmix_bridge_join(struct as
 		return -1;
 	}
 
-	softmix_src_change(bridge_channel);
-
 	/* Can't forget the lock */
 	ast_mutex_init(&sc->lock);
 
@@ -498,8 +485,6 @@ static void softmix_bridge_leave(struct
 	}
 	bridge_channel->tech_pvt = NULL;
 
-	softmix_src_change(bridge_channel);
-
 	/* Drop mutex lock */
 	ast_mutex_destroy(&sc->lock);
 
@@ -693,6 +678,15 @@ static int softmix_bridge_write_control(
 	 * XXX Softmix needs to use channel roles to determine what to
 	 * do with control frames.
 	 */
+
+	switch (frame->subclass.integer) {
+	case AST_CONTROL_VIDUPDATE:
+		ast_bridge_queue_everyone_else(bridge, NULL, frame);
+		break;
+	default:
+		break;
+	}
+
 	return 0;
 }
 
@@ -714,7 +708,7 @@ static int softmix_bridge_write(struct a
 {
 	int res = 0;
 
-	if (!bridge->tech_pvt || (bridge_channel && !bridge_channel->tech_pvt)) {
+	if (!bridge->tech_pvt || !bridge_channel || !bridge_channel->tech_pvt) {
 		/* "Accept" the frame and discard it. */
 		return 0;
 	}
@@ -984,6 +978,11 @@ static int softmix_mixing_loop(struct as
 		AST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {
 			struct softmix_channel *sc = bridge_channel->tech_pvt;
 
+			if (!sc) {
+				/* This channel failed to join successfully. */
+				continue;
+			}
+
 			/* Update the sample rate to match the bridge's native sample rate if necessary. */
 			if (update_all_rates) {
 				set_softmix_bridge_data(softmix_data->internal_rate, softmix_data->internal_mixing_interval, bridge_channel, 1);
@@ -1019,7 +1018,8 @@ static int softmix_mixing_loop(struct as
 		AST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {
 			struct softmix_channel *sc = bridge_channel->tech_pvt;
 
-			if (bridge_channel->suspended) {
+			if (!sc || bridge_channel->suspended) {
+				/* This channel failed to join successfully or is suspended. */
 				continue;
 			}
 
diff -urpN asterisk-13.9.1/build_tools/cflags.xml asterisk-13.17.0/build_tools/cflags.xml
--- asterisk-13.9.1/build_tools/cflags.xml	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/build_tools/cflags.xml	2017-07-12 13:12:08.000000000 +0200
@@ -19,10 +19,6 @@
 		<member name="STATIC_BUILD" displayname="Build static binaries">
 			<support_level>extended</support_level>
 		</member>
-		<member name="LOADABLE_MODULES" displayname="Runtime module loading">
-			<defaultenabled>yes</defaultenabled>
-			<support_level>core</support_level>
-		</member>
 		<member name="DEBUG_FD_LEAKS" displayname="Enable File Descriptor Leak Detection">
 			<support_level>core</support_level>
 		</member>
diff -urpN asterisk-13.9.1/build_tools/download_externals asterisk-13.17.0/build_tools/download_externals
--- asterisk-13.9.1/build_tools/download_externals	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/build_tools/download_externals	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,224 @@
+#!/usr/bin/env bash
+
+if [[ ( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} > 1 ) || ${BASH_VERSINFO[0]} > 4 ]] ; then
+	shopt -s compat41
+fi
+set -e
+
+ASTTOPDIR=${ASTTOPDIR:-.}
+
+module_name=${1%%-*}
+variant=${1##*-}
+
+if [[ "${variant}" = "${module_name}" ]] ; then
+	unset variant
+fi
+
+if [[ -z ${module_name} ]] ; then
+	echo "You must supply a module name."
+	exit 64
+fi
+
+tmpdir=$(mktemp -d)
+if [[ -z "${tmpdir}" ]] ; then
+	echo "${module_name}: Unable to create temporary directory."
+	exit 1
+fi
+trap "rm -rf ${tmpdir}" EXIT
+
+sed -r -e "s/^([^ =]+)\s*=\s*(.*)$/\1=\"\2\"/g" ${ASTTOPDIR}/makeopts >${tmpdir}/makeopts
+source ${tmpdir}/makeopts
+if [[ -z "${ASTMODDIR}" ]] ; then
+	echo "${module_name}: Unable to parse ${ASTTOPDIR}/makeopts."
+	exit 1
+fi
+
+XMLSTARLET=${XMLSTARLET:-xmlstarlet}
+if [[ "${XMLSTARLET}" = ":" ]] ; then
+	echo "${module_name}: The externals downloader requires xmlstarlet to be installed."
+	exit 1
+fi
+
+cache_dir="${EXTERNALS_CACHE_DIR}"
+if [[ -z ${cache_dir} ]] ; then
+	cache_dir=${tmpdir}
+fi
+
+version=$(${ASTTOPDIR}/build_tools/make_version ${ASTTOPDIR})
+if [[ ! ${version} =~ ^(GIT-)?(certified/)?([^.-]+)[.-].* ]] ; then
+	echo "${module_name}: Couldn't parse version ${version}"
+	exit 1
+fi
+major_version=${BASH_REMATCH[3]}
+
+if [[ "${major_version}" == "master" ]] ; then
+	echo "${module_name}: External module downloading is not available in the 'master' git branch.  Please disable in menuselect and download manually."
+	exit 1
+fi
+
+major_version=${major_version}.0
+
+if [[ "${HOST_CPU}" = "x86_64" ]] ; then
+	host_bits=64
+else
+	host_bits=32
+fi
+
+if [[ -z "${variant}" ]] ; then
+	variants=$(${XMLSTARLET} sel -t -m "/menu/category/member[@name = '${module_name}']/member_data/downloader/variants/variant" -v "@tag" -n ${ASTTOPDIR}/menuselect-tree || :)
+	member_name=${module_name}
+	for tag in ${variants} ; do
+		condition=$(${XMLSTARLET} sel -t -v "/menu/category/member[@name = '${module_name}']/member_data/downloader/variants/variant[@tag = '${tag}']/@condition" ${ASTTOPDIR}/menuselect-tree || :)
+		variant=$(eval "if $condition ; then echo $tag ; fi")
+		if [[ -n "${variant}" ]] ; then
+			break
+		fi
+	done
+else
+	member_name=${module_name}${variant:+-${variant}}
+fi
+
+full_name=${module_name}${variant:+-${variant}}
+variant_manifest=manifest${variant:+-${variant}}.xml
+
+# Override the remote base for all packages
+# useful for testing
+remote_url=${REMOTE_BASE:+${REMOTE_BASE}/asterisk-${major_version}/x86-${host_bits}}
+
+if [[ -z "${remote_url}" ]] ; then
+	remote_url=$(${XMLSTARLET} sel -t -v "/menu/category/member[@name = '${member_name}']/member_data/downloader/@remote_url" ${ASTTOPDIR}/menuselect-tree || :)
+	if [[ -n "${remote_url}" ]] ; then
+		remote_url="${remote_url}/asterisk-${major_version}/x86-${host_bits}"
+	else
+		directory_name=$(${XMLSTARLET} sel -t -v "/menu/category/member[@name = '${member_name}']/member_data/downloader/@directory_name" ${ASTTOPDIR}/menuselect-tree || :)
+		remote_url="http://downloads.digium.com/pub/telephony/${directory_name:-${module_name}}/asterisk-${major_version}/x86-${host_bits}"
+	fi
+fi
+
+version_convert() {
+	local v=${1##*_}
+	if [[ ${v} =~ ([0-9]+)[.]([0-9]+)[.]([0-9]+) ]] ; then
+		v=$(( ${BASH_REMATCH[1]}<<18 | ${BASH_REMATCH[2]}<<9 | ${BASH_REMATCH[3]} ))
+	fi
+	echo ${v}
+}
+
+${DOWNLOAD_TO_STDOUT} ${remote_url}/${variant_manifest} > ${tmpdir}/${variant_manifest} || {
+	echo "${full_name}: Unable to fetch ${remote_url}/${variant_manifest}"
+	exit 1
+}
+
+rpv=$(${XMLSTARLET} sel -t -v "/package/@version" ${tmpdir}/${variant_manifest})
+rpvi=$(version_convert ${rpv})
+echo "${full_name}: Remote package version ${rpv} (${rpvi})"
+
+module_dir=${full_name}-${rpv}-x86_${host_bits}
+tarball=${module_dir}.tar.gz
+
+export need_install=0
+
+if [[ -f ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml ]] ; then
+	package_arch=$(${XMLSTARLET} sel -t -v "/package/@arch" ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml)
+	ipv=$(${XMLSTARLET} sel -t -v "/package/@version" ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml)
+	package_variant=$(${XMLSTARLET} sel -t -v "/package/@variant" ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml || :)
+	ipvi=$(version_convert ${ipv})
+	ip_major=${ipv%_*}
+	echo "${full_name}: Installed package version ${ipv} (${ipvi})"
+	if [[ "${ip_major}" != "${major_version}" || "${package_arch}" != "x86_${host_bits}" || "${package_variant}" != "${variant}" ]] ; then
+		echo "${full_name}: The installed package is not for this version of Asterisk.  Reinstalling."
+		need_install=1
+	elif [[ ${rpvi} > ${ipvi} ]] ; then
+		echo "${full_name}: A newer package is available"
+		need_install=1
+	else
+		sums=$(${XMLSTARLET} sel -t -m "//file" -v "@md5sum" -n ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml)
+		for sum in ${sums} ; do
+			install_path=$(${XMLSTARLET} sel -t -v "//file[@md5sum = '${sum}']/@install_path" ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml )
+			executable=$(${XMLSTARLET} sel -t -v "//file[@md5sum = '${sum}']/@executable" ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml || : )
+			f=${DESTDIR}$(eval echo ${install_path})
+			if [[ ! -f ${f} ]] ; then
+				echo Not found: ${f}
+				need_install=1
+				break
+			else
+				if [[ "$executable" = "yes" ]] ; then
+					# There are easier ways of doing this (objcopy --dump-section) but not in older bunutils
+					length_offset=$(objdump -h $f | sed -n -r -e "s/^\s+[0-9]+\s+.ast_manifest\s+([0-9a-fA-F]+)\s+[0-9a-fA-F]+\s+[0-9a-fA-F]+\s+([0-9a-fA-F]+)\s+.*$/0x\1 0x\2/p")
+					tags=$($(eval 'printf "dd if=$f bs=1 count=%d skip=%d\n" $length_offset') 2>/dev/null)
+					if [[ -n "${tags}" && "${tags}" != "${module_name},${variant},${rpv}" ]] ; then
+						echo Tag mismatch: ${f} File: "${tags}" Manifest: "${module_name},${variant},${rpv}"
+						need_install=1
+						break
+					fi
+				fi
+
+				cs=$(md5sum ${f} | cut -b1-32)
+				if [[ "${cs}" !=  "${sum}" ]] ; then
+					echo Checksum mismatch: ${f}
+					need_install=1
+					break
+				fi
+			fi
+		done
+	fi
+else
+	need_install=1
+fi
+
+if [[ ${need_install} == 1 ]] ; then
+	if [[ ( -n "${ipvi}" ) && ${ipvi} > ${rpvi} ]] ; then
+		echo "${full_name}: Installed package is newer than that available for download."
+		exit 0
+	fi
+else
+	echo "${full_name} is up to date."
+	exit 0;
+fi
+
+need_download=1
+if [[ -f ${cache_dir}/${full_name}.manifest.xml ]] ; then
+	cpv=$(${XMLSTARLET} sel -t -v "/package/@version" ${cache_dir}/${full_name}.manifest.xml)
+	cpvi=$(version_convert ${cpv})
+	echo "${full_name}: Cached package version ${cpv} (${cpvi})"
+	if [[ ${cpvi} == ${rpvi} && ( -f ${cache_dir}/${tarball} ) ]] ; then
+		echo "${full_name}: Cached version is available."
+		need_download=0
+	fi
+fi
+
+if [[ ${need_download} = 1 ]] ; then
+	echo "${full_name}: Downloading ${remote_url}/${tarball}"
+	${DOWNLOAD_TO_STDOUT} ${remote_url}/${tarball} > ${cache_dir}/${tarball} || {
+		echo "${full_name}: Unable to fetch ${remote_url}/${tarball}"
+		exit 1
+	}
+	cp ${tmpdir}/${variant_manifest}  ${cache_dir}/${full_name}.manifest.xml
+fi
+
+tar -xzf ${cache_dir}/${tarball} -C ${cache_dir}
+trap "rm -rf ${cache_dir}/${module_dir} ; rm -rf ${tmpdir}" EXIT
+
+echo "${full_name}: Installing."
+
+if [[ $EUID == 0 ]] ; then
+	install_params="--group=0 --owner=0"
+fi
+
+names=$(${XMLSTARLET} sel -t -m "//file" -v "@name" -n ${cache_dir}/${module_dir}/manifest.xml)
+for name in ${names} ; do
+	source_path=${cache_dir}/${module_dir}/${name}
+	install_path=$(${XMLSTARLET} sel -t -v "//file[@name = '${name}']/@install_path" ${cache_dir}/${module_dir}/manifest.xml)
+	install_path=${DESTDIR}$(eval echo ${install_path})
+	executable=$(${XMLSTARLET} sel -t -v "//file[@name = '${name}']/@executable" ${cache_dir}/${module_dir}/manifest.xml || :)
+	if [[ "${executable}" = "yes" ]] ; then
+		mode=0755
+	else
+		mode=0644
+	fi
+
+	${INSTALL} -Dp ${install_params} --mode=${mode} ${source_path} ${install_path}
+
+done
+${INSTALL} -Dp ${install_params} --mode=0644 ${cache_dir}/${module_dir}/manifest.xml ${DESTDIR}${ASTMODDIR}/${module_name}.manifest.xml
+
+echo "${full_name}: Installed."
diff -urpN asterisk-13.9.1/build_tools/embed_modules.xml asterisk-13.17.0/build_tools/embed_modules.xml
--- asterisk-13.9.1/build_tools/embed_modules.xml	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/build_tools/embed_modules.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-	<category name="MENUSELECT_EMBED" displayname="Module Embedding" positive_output="yes" remove_on_change="main/asterisk">
-		<member name="EMBED_ADDONS" displayname="Add-ons" remove_on_change="addons/*.o addons/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_APPS" displayname="Applications" remove_on_change="apps/*.o apps/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_BRIDGES" displayname="Bridging Technologies" remove_on_change="bridges/*.o bridges/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_CDR" displayname="Call Detail Recording" remove_on_change="cdr/*.o cdr/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_CHANNELS" displayname="Channels" remove_on_change="channels/*.o channels/*/*.o channels/*.oo channels/*/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_CODECS" displayname="Coders/Decoders" remove_on_change="codecs/*.o codecs/*/*.o codecs/*/*/*.o codecs/*/*.a codecs/*/*/*.a codecs/*.oo codecs/*/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_FORMATS" displayname="File Formats" remove_on_change="formats/*.o formats/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_FUNCS" displayname="Dialplan Functions" remove_on_change="funcs/*.o funcs/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_PBX" displayname="PBX Functionality" remove_on_change="pbx/*.o pbx/*/*.o pbx/*.oo pbx/*/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_RES" displayname="Resource Modules" remove_on_change="res/*.o res/*/*.o res/*.oo res/*/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-		<member name="EMBED_TEST" displayname="Test Modules" remove_on_change="tests/*.o tests/*.oo">
-			<depend>gnu_ld</depend>
-			<support_level>extended</support_level>
-		</member>
-	</category>
diff -urpN asterisk-13.9.1/build_tools/list_valid_installed_externals asterisk-13.17.0/build_tools/list_valid_installed_externals
--- asterisk-13.9.1/build_tools/list_valid_installed_externals	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/build_tools/list_valid_installed_externals	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,55 @@
+#!/usr/bin/env bash
+
+if [[ ( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} > 1 ) || ${BASH_VERSINFO[0]} > 4 ]] ; then
+	shopt -s compat41
+fi
+set -e
+
+ASTTOPDIR=${ASTTOPDIR:-.}
+
+tmpdir=$(mktemp -d)
+if [[ -z "${tmpdir}" ]] ; then
+	echo "${module_name}: Unable to create temporary directory."
+	exit 1
+fi
+trap "rm -rf ${tmpdir}" EXIT
+
+sed -r -e "s/^([^ =]+)\s*=\s*(.*)$/\1=\"\2\"/g" ${ASTTOPDIR}/makeopts >${tmpdir}/makeopts
+source ${tmpdir}/makeopts
+if [[ -z "${ASTMODDIR}" ]] ; then
+	echo "${module_name}: Unable to parse ${ASTTOPDIR}/makeopts."
+	exit 1
+fi
+
+XMLSTARLET=${XMLSTARLET:-xmlstarlet}
+if [[ "${XMLSTARLET}" = ":" ]] ; then
+	echo "${module_name}: The externals downloader requires xmlstarlet to be installed."
+	exit 1
+fi
+
+version=$(${ASTTOPDIR}/build_tools/make_version ${ASTTOPDIR})
+if [[ ! ${version} =~ ^(GIT-)?([^.-]+)[.-].* ]] ; then
+	echo "${module_name}: Couldn't parse version ${version}"
+	exit 1
+fi
+major_version=${BASH_REMATCH[2]}.0
+
+if [[ "${HOST_CPU}" = "x86_64" ]] ; then
+	host_bits=64
+else
+	host_bits=32
+fi
+
+names=""
+for manifest in ${DESTDIR}${ASTMODDIR}/*.manifest.xml ; do
+	if [ ! -f "$manifest" ] ; then
+		break
+	fi
+	package_version=$(${XMLSTARLET} sel -t -v "/package/@version" ${manifest})
+	package_major_version=${package_version%_*}
+	package_arch=$(${XMLSTARLET} sel -t -v "/package/@arch" ${manifest})
+	if [[ "$package_major_version" = "$major_version" && "${package_arch}" = "x86_${host_bits}" ]] ; then
+		names+=$(${XMLSTARLET} sel -t -m "//file[@executable = 'yes']" -v "concat(@name, ' ')" ${manifest})
+	fi
+done
+echo $names
diff -urpN asterisk-13.9.1/build_tools/make_build_h asterisk-13.17.0/build_tools/make_build_h
--- asterisk-13.9.1/build_tools/make_build_h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/build_tools/make_build_h	2017-07-12 13:12:08.000000000 +0200
@@ -1,13 +1,13 @@
 #!/bin/sh
-HOSTNAME=`uname -n`
-KERNEL=`uname -r`
-MACHINE=`uname -m`
+HOSTNAME=`uname -n | sed 's/\\\\/\\\\\\\\/g'`
+KERNEL=`uname -r   | sed 's/\\\\/\\\\\\\\/g'`
+MACHINE=`uname -m  | sed 's/\\\\/\\\\\\\\/g'`
 OS=`uname -s`
-USER=`id | awk -F")" '{print $1}'| awk -F"(" '{print $2}'`
+USER=`id | awk -F")" '{print $1}'| awk -F"(" '{print $2}' | sed 's/\\\\/\\\\\\\\/g'`
 DATE=`date -u "+%Y-%m-%d %H:%M:%S"`
 cat << END
 /*
- * build.h 
+ * build.h
  * Automatically generated
  */
 #define BUILD_HOSTNAME "${HOSTNAME}"
diff -urpN asterisk-13.9.1/build_tools/make_version asterisk-13.17.0/build_tools/make_version
--- asterisk-13.9.1/build_tools/make_version	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/build_tools/make_version	2017-07-12 13:12:08.000000000 +0200
@@ -89,11 +89,13 @@ elif [ -d ${1}/.git ]; then
     if [ -z ${GIT} ]; then
         GIT="git"
     fi
-
+	
     if ! command -v ${GIT} >/dev/null 2>&1; then
         echo "UNKNOWN__and_probably_unsupported"
         exit 1
     fi
+	cd ${1} 
+    
     # If the first log commit messages indicates that this is checked into
     # subversion, we'll just use the SVN- form of the revision.
     MODIFIED=""
diff -urpN asterisk-13.9.1/build_tools/menuselect-deps.in asterisk-13.17.0/build_tools/menuselect-deps.in
--- asterisk-13.9.1/build_tools/menuselect-deps.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/build_tools/menuselect-deps.in	2017-07-12 13:12:08.000000000 +0200
@@ -30,6 +30,8 @@ KQUEUE=@PBX_KQUEUE@
 LDAP=@PBX_LDAP@
 LIBEDIT=@PBX_LIBEDIT@
 LIBXML2=@PBX_LIBXML2@
+XMLSTARLET=@PBX_XMLSTARLET@
+BASH=@PBX_BASH@
 LTDL=@PBX_LTDL@
 LUA=@PBX_LUA@
 MISDN=@PBX_MISDN@
diff -urpN asterisk-13.9.1/cdr/cdr_custom.c asterisk-13.17.0/cdr/cdr_custom.c
--- asterisk-13.9.1/cdr/cdr_custom.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/cdr/cdr_custom.c	2017-07-12 13:12:08.000000000 +0200
@@ -81,8 +81,10 @@ static AST_RWLIST_HEAD_STATIC(sinks, cdr
 static void free_config(void)
 {
 	struct cdr_custom_config *sink;
+
 	while ((sink = AST_RWLIST_REMOVE_HEAD(&sinks, list))) {
 		ast_mutex_destroy(&sink->lock);
+		ast_string_field_free_memory(sink);
 		ast_free(sink);
 	}
 }
@@ -203,7 +205,7 @@ static enum ast_module_load_result load_
 {
 	if (AST_RWLIST_WRLOCK(&sinks)) {
 		ast_log(LOG_ERROR, "Unable to lock sink list.  Load failed.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	load_config();
@@ -216,7 +218,7 @@ static int reload(void)
 {
 	if (AST_RWLIST_WRLOCK(&sinks)) {
 		ast_log(LOG_ERROR, "Unable to lock sink list.  Load failed.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	free_config();
diff -urpN asterisk-13.9.1/cdr/cdr_pgsql.c asterisk-13.17.0/cdr/cdr_pgsql.c
--- asterisk-13.9.1/cdr/cdr_pgsql.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/cdr/cdr_pgsql.c	2017-07-12 13:12:08.000000000 +0200
@@ -217,6 +217,7 @@ static int pgsql_log(struct ast_cdr *cdr
 	struct ast_tm tm;
 	char *pgerror;
 	PGresult *result;
+	int res = -1;
 
 	ast_mutex_lock(&pgsql_lock);
 
@@ -246,13 +247,14 @@ static int pgsql_log(struct ast_cdr *cdr
 	if (connected) {
 		struct columns *cur;
 		struct ast_str *sql = ast_str_create(maxsize), *sql2 = ast_str_create(maxsize2);
-		char buf[257], escapebuf[513], *value;
+		char buf[257];
+		char *escapebuf = NULL, *value;
 		int first = 1;
+		size_t bufsize = 513;
 
-		if (!sql || !sql2) {
-			ast_free(sql);
-			ast_free(sql2);
-			return -1;
+		escapebuf = ast_malloc(bufsize);
+		if (!escapebuf || !sql || !sql2) {
+			goto ast_log_cleanup;
 		}
 
 		ast_str_set(&sql, 0, "INSERT INTO %s (", table);
@@ -373,10 +375,28 @@ static int pgsql_log(struct ast_cdr *cdr
 					}
 				/* XXX Might want to handle dates, times, and other misc fields here XXX */
 				} else {
-					if (value)
+					if (value) {
+						size_t required_size = strlen(value) * 2 + 1;
+
+						/* If our argument size exceeds our buffer, grow it,
+						 * as PQescapeStringConn() expects the buffer to be
+						 * adequitely sized and does *NOT* do size checking.
+						 */
+						if (required_size > bufsize) {
+							char *tmpbuf = ast_realloc(escapebuf, required_size);
+
+							if (!tmpbuf) {
+								AST_RWLIST_UNLOCK(&psql_columns);
+								goto ast_log_cleanup;
+							}
+
+							escapebuf = tmpbuf;
+							bufsize = required_size;
+						}
 						PQescapeStringConn(conn, escapebuf, value, strlen(value), NULL);
-					else
+					} else {
 						escapebuf[0] = '\0';
+					}
 					LENGTHEN_BUF2(strlen(escapebuf) + 3);
 					ast_str_append(&sql2, 0, "%s'%s'", first ? "" : ",", escapebuf);
 				}
@@ -410,10 +430,7 @@ static int pgsql_log(struct ast_cdr *cdr
 				PQfinish(conn);
 				conn = NULL;
 				connected = 0;
-				ast_mutex_unlock(&pgsql_lock);
-				ast_free(sql);
-				ast_free(sql2);
-				return -1;
+				goto ast_log_cleanup;
 			}
 		}
 		result = PQexec(conn, ast_str_buffer(sql));
@@ -434,30 +451,28 @@ static int pgsql_log(struct ast_cdr *cdr
 					pgerror = PQresultErrorMessage(result);
 					ast_log(LOG_ERROR, "HARD ERROR!  Attempted reconnection failed.  DROPPING CALL RECORD!\n");
 					ast_log(LOG_ERROR, "Reason: %s\n", pgerror);
-				}  else {
+				} else {
 					/* Second try worked out ok */
 					totalrecords++;
 					records++;
-					ast_mutex_unlock(&pgsql_lock);
-					PQclear(result);
-					return 0;
+					res = 0;
 				}
 			}
-			ast_mutex_unlock(&pgsql_lock);
-			PQclear(result);
-			ast_free(sql);
-			ast_free(sql2);
-			return -1;
 		} else {
 			totalrecords++;
 			records++;
+			res = 0;
 		}
 		PQclear(result);
+
+ast_log_cleanup:
+		ast_free(escapebuf);
 		ast_free(sql);
 		ast_free(sql2);
 	}
+
 	ast_mutex_unlock(&pgsql_lock);
-	return 0;
+	return res;
 }
 
 /* This function should be called without holding the pgsql_columns lock */
diff -urpN asterisk-13.9.1/cdr/cdr_syslog.c asterisk-13.17.0/cdr/cdr_syslog.c
--- asterisk-13.9.1/cdr/cdr_syslog.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/cdr/cdr_syslog.c	2017-07-12 13:12:08.000000000 +0200
@@ -76,8 +76,10 @@ static AST_RWLIST_HEAD_STATIC(sinks, cdr
 static void free_config(void)
 {
 	struct cdr_syslog_config *sink;
+
 	while ((sink = AST_RWLIST_REMOVE_HEAD(&sinks, list))) {
 		ast_mutex_destroy(&sink->lock);
+		ast_string_field_free_memory(sink);
 		ast_free(sink);
 	}
 }
diff -urpN asterisk-13.9.1/cel/cel_custom.c asterisk-13.17.0/cel/cel_custom.c
--- asterisk-13.9.1/cel/cel_custom.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/cel/cel_custom.c	2017-07-12 13:12:08.000000000 +0200
@@ -71,8 +71,10 @@ static AST_RWLIST_HEAD_STATIC(sinks, cel
 static void free_config(void)
 {
 	struct cel_config *sink;
+
 	while ((sink = AST_RWLIST_REMOVE_HEAD(&sinks, list))) {
 		ast_mutex_destroy(&sink->lock);
+		ast_string_field_free_memory(sink);
 		ast_free(sink);
 	}
 }
@@ -191,14 +193,15 @@ static enum ast_module_load_result load_
 {
 	if (AST_RWLIST_WRLOCK(&sinks)) {
 		ast_log(LOG_ERROR, "Unable to lock sink list.  Load failed.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	load_config();
 	AST_RWLIST_UNLOCK(&sinks);
 
 	if (ast_cel_backend_register(CUSTOM_BACKEND_NAME, custom_log)) {
-		return AST_MODULE_LOAD_FAILURE;
+		free_config();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
@@ -207,7 +210,7 @@ static int reload(void)
 {
 	if (AST_RWLIST_WRLOCK(&sinks)) {
 		ast_log(LOG_ERROR, "Unable to lock sink list.  Load failed.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	free_config();
diff -urpN asterisk-13.9.1/cel/cel_odbc.c asterisk-13.17.0/cel/cel_odbc.c
--- asterisk-13.9.1/cel/cel_odbc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/cel/cel_odbc.c	2017-07-12 13:12:08.000000000 +0200
@@ -37,6 +37,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #include <sys/types.h>
 #include <time.h>
+#include <math.h>
 
 #include <sql.h>
 #include <sqlext.h>
@@ -291,6 +292,7 @@ static int load_config(void)
 		else
 			ast_free(tableptr);
 	}
+	ast_config_destroy(cfg);
 	return res;
 }
 
@@ -615,40 +617,62 @@ static void odbc_log(struct ast_event *e
 					if (ast_strlen_zero(colptr)) {
 						continue;
 					} else {
-						int year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0, fraction = 0;
-						if (strcasecmp(entry->name, "eventdate") == 0) {
-							struct ast_tm tm;
-							ast_localtime(&record.event_time, &tm, tableptr->usegmtime ? "UTC" : NULL);
-							year = tm.tm_year + 1900;
-							month = tm.tm_mon + 1;
-							day = tm.tm_mday;
-							hour = tm.tm_hour;
-							minute = tm.tm_min;
-							second = (tableptr->allowleapsec || tm.tm_sec < 60) ? tm.tm_sec : 59;
-							fraction = tm.tm_usec;
+						if (datefield) {
+							/*
+							 * We've already properly formatted the timestamp so there's no need
+							 * to parse it and re-format it.
+							 */
+							ast_str_append(&sql, 0, "%s%s", first ? "" : ",", entry->name);
+							LENGTHEN_BUF2(27);
+							ast_str_append(&sql2, 0, "%s{ts '%s'}", first ? "" : ",", colptr);
 						} else {
-							int count = sscanf(colptr, "%4d-%2d-%2d %2d:%2d:%2d.%6d", &year, &month, &day, &hour, &minute, &second, &fraction);
-
-							if ((count != 3 && count != 5 && count != 6 && count != 7) || year <= 0 ||
-								month <= 0 || month > 12 || day < 0 || day > 31 ||
-								((month == 4 || month == 6 || month == 9 || month == 11) && day == 31) ||
-								(month == 2 && year % 400 == 0 && day > 29) ||
-								(month == 2 && year % 100 == 0 && day > 28) ||
-								(month == 2 && year % 4 == 0 && day > 29) ||
-								(month == 2 && year % 4 != 0 && day > 28) ||
-								hour > 23 || minute > 59 || second > (tableptr->allowleapsec ? 60 : 59) || hour < 0 || minute < 0 || second < 0 || fraction < 0) {
-								ast_log(LOG_WARNING, "CEL variable %s is not a valid timestamp ('%s').\n", entry->name, colptr);
-								continue;
+							int year = 0, month = 0, day = 0, hour = 0, minute = 0;
+							/* MUST use double for microsecond precision */
+							double second = 0.0;
+							if (strcasecmp(entry->name, "eventdate") == 0) {
+								/*
+								 * There doesn't seem to be any reference to 'eventdate' anywhere
+								 * other than in this module.  It should be considered for removal
+								 * at a later date.
+								 */
+								struct ast_tm tm;
+								ast_localtime(&record.event_time, &tm, tableptr->usegmtime ? "UTC" : NULL);
+								year = tm.tm_year + 1900;
+								month = tm.tm_mon + 1;
+								day = tm.tm_mday;
+								hour = tm.tm_hour;
+								minute = tm.tm_min;
+								second = (tableptr->allowleapsec || tm.tm_sec < 60) ? tm.tm_sec : 59;
+								second += (tm.tm_usec / 1000000.0);
+							} else {
+								/*
+								 * If we're here, the data to be inserted MAY be a timestamp
+								 * but the column is.  We parse as much as we can.
+								 */
+								int count = sscanf(colptr, "%4d-%2d-%2d %2d:%2d:%lf", &year, &month, &day, &hour, &minute, &second);
+
+								if ((count != 3 && count != 5 && count != 6) || year <= 0 ||
+									month <= 0 || month > 12 || day < 0 || day > 31 ||
+									((month == 4 || month == 6 || month == 9 || month == 11) && day == 31) ||
+									(month == 2 && year % 400 == 0 && day > 29) ||
+									(month == 2 && year % 100 == 0 && day > 28) ||
+									(month == 2 && year % 4 == 0 && day > 29) ||
+									(month == 2 && year % 4 != 0 && day > 28) ||
+									hour > 23 || minute > 59 || ((int)floor(second)) > (tableptr->allowleapsec ? 60 : 59) ||
+									hour < 0 || minute < 0 || ((int)floor(second)) < 0) {
+									ast_log(LOG_WARNING, "CEL variable %s is not a valid timestamp ('%s').\n", entry->name, colptr);
+									continue;
+								}
+
+								if (year > 0 && year < 100) {
+									year += 2000;
+								}
 							}
 
-							if (year > 0 && year < 100) {
-								year += 2000;
-							}
+							ast_str_append(&sql, 0, "%s%s", first ? "" : ",", entry->name);
+							LENGTHEN_BUF2(27);
+							ast_str_append(&sql2, 0, "%s{ts '%04d-%02d-%02d %02d:%02d:%09.6lf'}", first ? "" : ",", year, month, day, hour, minute, second);
 						}
-
-						ast_str_append(&sql, 0, "%s%s", first ? "" : ",", entry->name);
-						LENGTHEN_BUF2(27);
-						ast_str_append(&sql2, 0, "%s{ts '%04d-%02d-%02d %02d:%02d:%02d.%d'}", first ? "" : ",", year, month, day, hour, minute, second, fraction);
 					}
 					break;
 				case SQL_INTEGER:
@@ -809,13 +833,14 @@ static int load_module(void)
 
 	if (AST_RWLIST_WRLOCK(&odbc_tables)) {
 		ast_log(LOG_ERROR, "Unable to lock column list.  Load failed.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	load_config();
 	AST_RWLIST_UNLOCK(&odbc_tables);
 	if (ast_cel_backend_register(ODBC_BACKEND_NAME, odbc_log)) {
 		ast_log(LOG_ERROR, "Unable to subscribe to CEL events\n");
-		return AST_MODULE_LOAD_FAILURE;
+		free_config();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
@@ -824,7 +849,7 @@ static int reload(void)
 {
 	if (AST_RWLIST_WRLOCK(&odbc_tables)) {
 		ast_log(LOG_ERROR, "Unable to lock column list.  Reload failed.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	free_config();
diff -urpN asterisk-13.9.1/cel/cel_pgsql.c asterisk-13.17.0/cel/cel_pgsql.c
--- asterisk-13.9.1/cel/cel_pgsql.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/cel/cel_pgsql.c	2017-07-12 13:12:08.000000000 +0200
@@ -184,11 +184,14 @@ static void pgsql_log(struct ast_event *
 	if (connected) {
 		struct columns *cur;
 		struct ast_str *sql = ast_str_create(maxsize), *sql2 = ast_str_create(maxsize2);
-		char buf[257], escapebuf[513];
+		char buf[257];
+		char *escapebuf = NULL;
 		const char *value;
 		int first = 1;
+		size_t bufsize = 513;
 
-		if (!sql || !sql2) {
+		escapebuf = ast_malloc(bufsize);
+		if (!escapebuf || !sql || !sql2) {
 			goto ast_log_cleanup;
 		}
 
@@ -312,6 +315,23 @@ static void pgsql_log(struct ast_event *
 					/* XXX Might want to handle dates, times, and other misc fields here XXX */
 				} else {
 					if (value) {
+						size_t required_size = strlen(value) * 2 + 1;
+
+						/* If our argument size exceeds our buffer, grow it,
+						 * as PQescapeStringConn() expects the buffer to be
+						 * adequitely sized and does *NOT* do size checking.
+						 */
+						if (required_size > bufsize) {
+							char *tmpbuf = ast_realloc(escapebuf, required_size);
+
+							if (!tmpbuf) {
+								AST_RWLIST_UNLOCK(&psql_columns);
+								goto ast_log_cleanup;
+							}
+
+							escapebuf = tmpbuf;
+							bufsize = required_size;
+						}
 						PQescapeStringConn(conn, escapebuf, value, strlen(value), NULL);
 					} else {
 						escapebuf[0] = '\0';
@@ -366,14 +386,13 @@ static void pgsql_log(struct ast_event *
 					ast_log(LOG_ERROR, "Reason: %s\n", pgerror);
 				}
 			}
-			PQclear(result);
-			goto ast_log_cleanup;
 		}
 		PQclear(result);
 
 ast_log_cleanup:
 		ast_free(sql);
 		ast_free(sql2);
+		ast_free(escapebuf);
 	}
 
 	ast_mutex_unlock(&pgsql_lock);
diff -urpN asterisk-13.9.1/channels/Makefile asterisk-13.17.0/channels/Makefile
--- asterisk-13.9.1/channels/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -30,13 +30,13 @@ clean::
 	rm -f iax2/*.o iax2/*.i iax2/*.gcda iax2/*.gcno
 	rm -f pjsip/*.o pjsip/*.i pjsip/*.gcda pjsip/*.gcno
 
-$(if $(filter chan_iax2,$(EMBEDDED_MODS)),modules.link,chan_iax2.so): $(subst .c,.o,$(wildcard iax2/*.c))
+chan_iax2.so: $(subst .c,.o,$(wildcard iax2/*.c))
 $(subst .c,.o,$(wildcard iax2/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_iax2)
 
-$(if $(filter chan_sip,$(EMBEDDED_MODS)),modules.link,chan_sip.so): $(subst .c,.o,$(wildcard sip/*.c))
+chan_sip.so: $(subst .c,.o,$(wildcard sip/*.c))
 $(subst .c,.o,$(wildcard sip/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_sip)
 
-$(if $(filter chan_pjsip,$(EMBEDDED_MODS)),modules.link,chan_pjsip.so): $(subst .c,.o,$(wildcard pjsip/*.c))
+chan_pjsip.so: $(subst .c,.o,$(wildcard pjsip/*.c))
 $(subst .c,.o,$(wildcard pjsip/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_pjsip)
 
 # Additional objects to combine with chan_dahdi.so
@@ -46,7 +46,7 @@ CHAN_DAHDI_OBJS= \
 	sig_pri.o	\
 	sig_ss7.o	\
 
-$(if $(filter chan_dahdi,$(EMBEDDED_MODS)),modules.link,chan_dahdi.so): $(CHAN_DAHDI_OBJS)
+chan_dahdi.so: $(CHAN_DAHDI_OBJS)
 $(CHAN_DAHDI_OBJS): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_dahdi)
 
 chan_misdn.o: _ASTCFLAGS+=-Imisdn
@@ -55,10 +55,10 @@ misdn_config.o: _ASTCFLAGS+=-Imisdn
 
 misdn/isdn_lib.o: _ASTCFLAGS+=-Wno-strict-aliasing
 
-$(if $(filter chan_misdn,$(EMBEDDED_MODS)),modules.link,chan_misdn.so): misdn_config.o misdn/isdn_lib.o misdn/isdn_msg_parser.o
+chan_misdn.so: misdn_config.o misdn/isdn_lib.o misdn/isdn_msg_parser.o
 misdn_config.o misdn/isdn_lib.o misdn/isdn_msg_parser.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_misdn)
 
-$(if $(filter chan_oss,$(EMBEDDED_MODS)),modules.link,chan_oss.so): console_video.o vgrabbers.o console_board.o
+chan_oss.so: console_video.o vgrabbers.o console_board.o
 console_video.o vgrabbers.o console_board.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_oss)
 
 chan_usbradio.o: ./xpmr/xpmr.c ./xpmr/xpmr.h ./xpmr/xpmr_coef.h
diff -urpN asterisk-13.9.1/channels/chan_alsa.c asterisk-13.17.0/channels/chan_alsa.c
--- asterisk-13.9.1/channels/chan_alsa.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_alsa.c	2017-07-12 13:12:08.000000000 +0200
@@ -639,29 +639,13 @@ static struct ast_channel *alsa_request(
 	return tmp;
 }
 
-static char *autoanswer_complete(const char *line, const char *word, int pos, int state)
-{
-	switch (state) {
-		case 0:
-			if (!ast_strlen_zero(word) && !strncasecmp(word, "on", MIN(strlen(word), 2)))
-				return ast_strdup("on");
-		case 1:
-			if (!ast_strlen_zero(word) && !strncasecmp(word, "off", MIN(strlen(word), 3)))
-				return ast_strdup("off");
-		default:
-			return NULL;
-	}
-
-	return NULL;
-}
-
 static char *console_autoanswer(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	char *res = CLI_SUCCESS;
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "console autoanswer";
+		e->command = "console autoanswer [on|off]";
 		e->usage =
 			"Usage: console autoanswer [on|off]\n"
 			"       Enables or disables autoanswer feature.  If used without\n"
@@ -669,7 +653,7 @@ static char *console_autoanswer(struct a
 			"       The default value of autoanswer is in 'alsa.conf'.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return autoanswer_complete(a->line, a->word, a->pos, a->n);
+		return NULL;
 	}
 
 	if ((a->argc != 2) && (a->argc != 3))
@@ -942,6 +926,26 @@ static struct ast_cli_entry cli_alsa[] =
 	AST_CLI_DEFINE(console_mute, "Disable/Enable mic input"),
 };
 
+static int unload_module(void)
+{
+	ast_channel_unregister(&alsa_tech);
+	ast_cli_unregister_multiple(cli_alsa, ARRAY_LEN(cli_alsa));
+
+	if (alsa.icard)
+		snd_pcm_close(alsa.icard);
+	if (alsa.ocard)
+		snd_pcm_close(alsa.ocard);
+	if (alsa.owner)
+		ast_softhangup(alsa.owner, AST_SOFTHANGUP_APPUNLOAD);
+	if (alsa.owner)
+		return -1;
+
+	ao2_cleanup(alsa_tech.capabilities);
+	alsa_tech.capabilities = NULL;
+
+	return 0;
+}
+
 /*!
  * \brief Load the module
  *
@@ -1012,12 +1016,16 @@ static int load_module(void)
 	if (soundcard_init() < 0) {
 		ast_verb(2, "No sound card detected -- console channel will be unavailable\n");
 		ast_verb(2, "Turn off ALSA support by adding 'noload=chan_alsa.so' in /etc/asterisk/modules.conf\n");
+		unload_module();
+
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_channel_register(&alsa_tech)) {
 		ast_log(LOG_ERROR, "Unable to register channel class 'Console'\n");
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	ast_cli_register_multiple(cli_alsa, ARRAY_LEN(cli_alsa));
@@ -1025,26 +1033,6 @@ static int load_module(void)
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-static int unload_module(void)
-{
-	ast_channel_unregister(&alsa_tech);
-	ast_cli_unregister_multiple(cli_alsa, ARRAY_LEN(cli_alsa));
-
-	if (alsa.icard)
-		snd_pcm_close(alsa.icard);
-	if (alsa.ocard)
-		snd_pcm_close(alsa.ocard);
-	if (alsa.owner)
-		ast_softhangup(alsa.owner, AST_SOFTHANGUP_APPUNLOAD);
-	if (alsa.owner)
-		return -1;
-
-	ao2_cleanup(alsa_tech.capabilities);
-	alsa_tech.capabilities = NULL;
-
-	return 0;
-}
-
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "ALSA Console Channel Driver",
 		.support_level = AST_MODULE_SUPPORT_EXTENDED,
 		.load = load_module,
diff -urpN asterisk-13.9.1/channels/chan_dahdi.c asterisk-13.17.0/channels/chan_dahdi.c
--- asterisk-13.9.1/channels/chan_dahdi.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_dahdi.c	2017-07-12 13:12:08.000000000 +0200
@@ -180,6 +180,60 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>This application will Accept the R2 call either with charge or no charge.</para>
 		</description>
 	</application>
+	<info name="CHANNEL" language="en_US" tech="DAHDI">
+		<enumlist>
+			<enum name="dahdi_channel">
+				<para>R/O DAHDI channel related to this channel.</para>
+			</enum>
+			<enum name="dahdi_span">
+				<para>R/O DAHDI span related to this channel.</para>
+			</enum>
+			<enum name="dahdi_type">
+				<para>R/O DAHDI channel type, one of:</para>
+				<enumlist>
+					<enum name="analog" />
+					<enum name="mfc/r2" />
+					<enum name="pri" />
+					<enum name="pseudo" />
+					<enum name="ss7" />
+				</enumlist>
+			</enum>
+			<enum name="keypad_digits">
+				<para>R/O PRI Keypad digits that came in with the SETUP message.</para>
+			</enum>
+			<enum name="reversecharge">
+				<para>R/O PRI Reverse Charging Indication, one of:</para>
+				<enumlist>
+					<enum name="-1"> <para>None</para></enum>
+					<enum name=" 1"> <para>Reverse Charging Requested</para></enum>
+				</enumlist>
+			</enum>
+			<enum name="no_media_path">
+				<para>R/O PRI Nonzero if the channel has no B channel.
+				The channel is either on hold or a call waiting call.</para>
+			</enum>
+			<enum name="buffers">
+				<para>W/O Change the channel's buffer policy (for the current call only)</para>
+				<para>This option takes two arguments:</para>
+				<para>	Number of buffers,</para>
+				<para>	Buffer policy being one of:</para>
+				<para>	    <literal>full</literal></para>
+				<para>	    <literal>immediate</literal></para>
+				<para>	    <literal>half</literal></para>
+			</enum>
+			<enum name="echocan_mode">
+				<para>W/O Change the configuration of the active echo
+				canceller on the channel (if any), for the current call
+				only.</para>
+				<para>Possible values are:</para>
+				<para>	<literal>on</literal>	Normal mode (the echo canceller is actually reinitalized)</para>
+				<para>	<literal>off</literal>	Disabled</para>
+				<para>	<literal>fax</literal>	FAX/data mode (NLP disabled if possible, otherwise
+					completely disabled)</para>
+				<para>	<literal>voice</literal>	Voice mode (returns from FAX mode, reverting the changes that were made)</para>
+			</enum>
+		</enumlist>
+	</info>
 	<manager name="DAHDITransfer" language="en_US">
 		<synopsis>
 			Transfer DAHDI Channel.
@@ -1696,26 +1750,28 @@ static void my_handle_dtmf(void *pvt, st
 				if (strcmp(ast_channel_exten(ast), "fax")) {
 					const char *target_context = S_OR(ast_channel_macrocontext(ast), ast_channel_context(ast));
 
-					/* We need to unlock 'ast' here because ast_exists_extension has the
+					/*
+					 * We need to unlock 'ast' here because ast_exists_extension has the
 					 * potential to start autoservice on the channel. Such action is prone
-					 * to deadlock.
+					 * to deadlock if the channel is locked.
+					 *
+					 * ast_async_goto() has its own restriction on not holding the
+					 * channel lock.
 					 */
 					ast_mutex_unlock(&p->lock);
 					ast_channel_unlock(ast);
 					if (ast_exists_extension(ast, target_context, "fax", 1,
 						S_COR(ast_channel_caller(ast)->id.number.valid, ast_channel_caller(ast)->id.number.str, NULL))) {
-						ast_channel_lock(ast);
-						ast_mutex_lock(&p->lock);
 						ast_verb(3, "Redirecting %s to fax extension\n", ast_channel_name(ast));
 						/* Save the DID/DNIS when we transfer the fax call to a "fax" extension */
 						pbx_builtin_setvar_helper(ast, "FAXEXTEN", ast_channel_exten(ast));
 						if (ast_async_goto(ast, target_context, "fax", 1))
 							ast_log(LOG_WARNING, "Failed to async goto '%s' into fax of '%s'\n", ast_channel_name(ast), target_context);
 					} else {
-						ast_channel_lock(ast);
-						ast_mutex_lock(&p->lock);
 						ast_log(LOG_NOTICE, "Fax detected, but no fax extension\n");
 					}
+					ast_channel_lock(ast);
+					ast_mutex_lock(&p->lock);
 				} else {
 					ast_debug(1, "Already in a fax extension, not redirecting\n");
 				}
@@ -2348,7 +2404,6 @@ static void my_pri_ss7_open_media(void *
 
 	if (pvt->dsp_features && pvt->dsp) {
 		ast_dsp_set_features(pvt->dsp, pvt->dsp_features);
-		pvt->dsp_features = 0;
 	}
 }
 #endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) */
@@ -7203,26 +7258,28 @@ static void dahdi_handle_dtmf(struct ast
 				if (strcmp(ast_channel_exten(ast), "fax")) {
 					const char *target_context = S_OR(ast_channel_macrocontext(ast), ast_channel_context(ast));
 
-					/* We need to unlock 'ast' here because ast_exists_extension has the
+					/*
+					 * We need to unlock 'ast' here because ast_exists_extension has the
 					 * potential to start autoservice on the channel. Such action is prone
-					 * to deadlock.
+					 * to deadlock if the channel is locked.
+					 *
+					 * ast_async_goto() has its own restriction on not holding the
+					 * channel lock.
 					 */
 					ast_mutex_unlock(&p->lock);
 					ast_channel_unlock(ast);
 					if (ast_exists_extension(ast, target_context, "fax", 1,
 						S_COR(ast_channel_caller(ast)->id.number.valid, ast_channel_caller(ast)->id.number.str, NULL))) {
-						ast_channel_lock(ast);
-						ast_mutex_lock(&p->lock);
 						ast_verb(3, "Redirecting %s to fax extension\n", ast_channel_name(ast));
 						/* Save the DID/DNIS when we transfer the fax call to a "fax" extension */
 						pbx_builtin_setvar_helper(ast, "FAXEXTEN", ast_channel_exten(ast));
 						if (ast_async_goto(ast, target_context, "fax", 1))
 							ast_log(LOG_WARNING, "Failed to async goto '%s' into fax of '%s'\n", ast_channel_name(ast), target_context);
 					} else {
-						ast_channel_lock(ast);
-						ast_mutex_lock(&p->lock);
 						ast_log(LOG_NOTICE, "Fax detected, but no fax extension\n");
 					}
+					ast_channel_lock(ast);
+					ast_mutex_lock(&p->lock);
 				} else {
 					ast_debug(1, "Already in a fax extension, not redirecting\n");
 				}
@@ -8643,6 +8700,15 @@ static struct ast_frame *dahdi_read(stru
 		/* Perform busy detection etc on the dahdi line */
 		int mute;
 
+		if ((p->dsp_features & DSP_FEATURE_FAX_DETECT)
+			&& p->faxdetect_timeout
+			&& p->faxdetect_timeout <= ast_channel_get_up_time(ast)) {
+			p->dsp_features &= ~DSP_FEATURE_FAX_DETECT;
+			ast_dsp_set_features(p->dsp, p->dsp_features);
+			ast_debug(1, "Channel driver fax CNG detection timeout on %s\n",
+				ast_channel_name(ast));
+		}
+
 		f = ast_dsp_process(ast, p->dsp, &p->subs[idx].f);
 
 		/* Check if DSP code thinks we should be muting this frame and mute the conference if so */
@@ -12542,6 +12608,7 @@ static struct dahdi_pvt *mkintf(int chan
 		tmp->callprogress = conf->chan.callprogress;
 		tmp->waitfordialtone = conf->chan.waitfordialtone;
 		tmp->dialtone_detect = conf->chan.dialtone_detect;
+		tmp->faxdetect_timeout = conf->chan.faxdetect_timeout;
 		tmp->cancallforward = conf->chan.cancallforward;
 		tmp->dtmfrelax = conf->chan.dtmfrelax;
 		tmp->callwaiting = tmp->permcallwaiting;
@@ -17793,6 +17860,10 @@ static int process_dahdi(struct dahdi_ch
 				confp->chan.callprogress |= CALLPROGRESS_FAX_OUTGOING;
 			} else if (!strcasecmp(v->value, "both") || ast_true(v->value))
 				confp->chan.callprogress |= CALLPROGRESS_FAX_INCOMING | CALLPROGRESS_FAX_OUTGOING;
+		} else if (!strcasecmp(v->name, "faxdetect_timeout")) {
+			if (sscanf(v->value, "%30u", &confp->chan.faxdetect_timeout) != 1) {
+				confp->chan.faxdetect_timeout = 0;
+			}
 		} else if (!strcasecmp(v->name, "echocancel")) {
 			process_echocancel(confp, v->value, v->lineno);
 		} else if (!strcasecmp(v->name, "echotraining")) {
@@ -18834,8 +18905,8 @@ static int process_dahdi(struct dahdi_ch
 				}
 
 				/* This check is only needed to satisfy the compiler that element_count can't cause an out of bounds */
-				if (element_count >= ARRAY_LEN(c)) {
-					element_count = ARRAY_LEN(c) - 1;
+				if (element_count > ARRAY_LEN(c)) {
+					element_count = ARRAY_LEN(c);
 				}
 
 				/* Ring cadences cannot be negative */
@@ -19538,11 +19609,11 @@ static int load_module(void)
 #endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) */
 
 	if (STASIS_MESSAGE_TYPE_INIT(dahdichannel_type)) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(dahdi_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_format_cap_append(dahdi_tech.capabilities, ast_format_slin, 0);
 	ast_format_cap_append(dahdi_tech.capabilities, ast_format_ulaw, 0);
@@ -19550,7 +19621,7 @@ static int load_module(void)
 
 	if (dahdi_native_load(ast_module_info->self, &dahdi_tech)) {
 		ao2_ref(dahdi_tech.capabilities, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 #ifdef HAVE_PRI
@@ -19568,7 +19639,7 @@ static int load_module(void)
 	if (ast_cc_agent_register(&dahdi_pri_cc_agent_callbacks)
 		|| ast_cc_monitor_register(&dahdi_pri_cc_monitor_callbacks)) {
 		__unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 #endif	/* defined(HAVE_PRI_CCSS) */
 	if (sig_pri_load(
@@ -19579,7 +19650,7 @@ static int load_module(void)
 #endif	/* defined(HAVE_PRI_CCSS) */
 		)) {
 		__unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 #endif
 #if defined(HAVE_SS7)
@@ -19602,7 +19673,7 @@ static int load_module(void)
 	if (ast_channel_register(&dahdi_tech)) {
 		ast_log(LOG_ERROR, "Unable to register channel class 'DAHDI'\n");
 		__unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 #ifdef HAVE_PRI
 	ast_cli_register_multiple(dahdi_pri_cli, ARRAY_LEN(dahdi_pri_cli));
diff -urpN asterisk-13.9.1/channels/chan_dahdi.h asterisk-13.17.0/channels/chan_dahdi.h
--- asterisk-13.9.1/channels/chan_dahdi.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_dahdi.h	2017-07-12 13:12:08.000000000 +0200
@@ -612,6 +612,11 @@ struct dahdi_pvt {
 	 */
 	int dialtone_detect;
 	int dialtone_scanning_time_elapsed;	/*!< Amount of audio scanned for dialtone, in frames */
+	/*!
+	 * \brief The number of seconds into call to disable fax detection.  (0 = disabled)
+	 * \note Set from the "faxdetect_timeout" value read in from chan_dahdi.conf
+	 */
+	unsigned int faxdetect_timeout;
 	struct timeval waitingfordt;			/*!< Time we started waiting for dialtone */
 	struct timeval flashtime;			/*!< Last flash-hook time */
 	/*! \brief Opaque DSP configuration structure. */
diff -urpN asterisk-13.9.1/channels/chan_iax2.c asterisk-13.17.0/channels/chan_iax2.c
--- asterisk-13.9.1/channels/chan_iax2.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_iax2.c	2017-07-12 13:12:08.000000000 +0200
@@ -213,6 +213,25 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Gets or sets a variable that is sent to a remote IAX2 peer during call setup.</para>
 		</description>
 	</function>
+	<info name="CHANNEL" language="en_US" tech="IAX">
+		<enumlist>
+			<enum name="osptoken">
+				<para>R/O Get the peer's osptoken.</para>
+			</enum>
+			<enum name="peerip">
+				<para>R/O Get the peer's ip address.</para>
+			</enum>
+			<enum name="peername">
+				<para>R/O Get the peer's username.</para>
+			</enum>
+			<enum name="secure_signaling">
+				<para>R/O Get the if the IAX channel is secured.</para>
+			</enum>
+			<enum name="secure_media">
+				<para>R/O Get the if the IAX channel is secured.</para>
+			</enum>
+		</enumlist>
+	</info>
 	<manager name="IAXpeers" language="en_US">
 		<synopsis>
 			List IAX peers.
@@ -12909,7 +12928,13 @@ static struct iax2_peer *build_peer(cons
 					/* Non-dynamic.  Make sure we become that way if we're not */
 					AST_SCHED_DEL(sched, peer->expire);
 					ast_clear_flag64(peer, IAX_DYNAMIC);
-					peer->addr.ss.ss_family = AST_AF_UNSPEC;
+					if (peer->dnsmgr) {
+						// Make sure we refresh dnsmgr if we're using it
+						ast_dnsmgr_refresh(peer->dnsmgr);
+					} else {
+						// Or just invalidate the address
+						peer->addr.ss.ss_family = AST_AF_UNSPEC;
+					}
 					if (ast_dnsmgr_lookup(v->value, &peer->addr, &peer->dnsmgr, srvlookup ? "_iax._udp" : NULL)) {
 						return peer_unref(peer);
 					}
@@ -14864,7 +14889,7 @@ container_fail:
 	if (calltoken_ignores) {
 		ao2_ref(calltoken_ignores, -1);
 	}
-	return AST_MODULE_LOAD_FAILURE;
+	return -1;
 }
 
 
@@ -15069,12 +15094,14 @@ static int load_module(void)
 	struct iax2_registry *reg = NULL;
 
 	if (!(iax2_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_format_cap_append_by_type(iax2_tech.capabilities, AST_MEDIA_TYPE_UNKNOWN);
 
 	if (load_objects()) {
-		return AST_MODULE_LOAD_FAILURE;
+		ao2_ref(iax2_tech.capabilities, -1);
+		iax2_tech.capabilities = NULL;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	memset(iaxs, 0, sizeof(iaxs));
@@ -15085,28 +15112,36 @@ static int load_module(void)
 
 	if (!(sched = ast_sched_context_create())) {
 		ast_log(LOG_ERROR, "Failed to create scheduler thread\n");
-		return AST_MODULE_LOAD_FAILURE;
+		ao2_ref(iax2_tech.capabilities, -1);
+		iax2_tech.capabilities = NULL;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_sched_start_thread(sched)) {
 		ast_sched_context_destroy(sched);
+		ao2_ref(iax2_tech.capabilities, -1);
+		iax2_tech.capabilities = NULL;
 		sched = NULL;
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(io = io_context_create())) {
 		ast_log(LOG_ERROR, "Failed to create I/O context\n");
 		ast_sched_context_destroy(sched);
+		ao2_ref(iax2_tech.capabilities, -1);
+		iax2_tech.capabilities = NULL;
 		sched = NULL;
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(netsock = ast_netsock_list_alloc())) {
 		ast_log(LOG_ERROR, "Failed to create netsock list\n");
 		io_context_destroy(io);
 		ast_sched_context_destroy(sched);
+		ao2_ref(iax2_tech.capabilities, -1);
+		iax2_tech.capabilities = NULL;
 		sched = NULL;
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_netsock_init(netsock);
 
@@ -15115,8 +15150,10 @@ static int load_module(void)
 		ast_log(LOG_ERROR, "Could not allocate outsock list.\n");
 		io_context_destroy(io);
 		ast_sched_context_destroy(sched);
+		ao2_ref(iax2_tech.capabilities, -1);
+		iax2_tech.capabilities = NULL;
 		sched = NULL;
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_netsock_init(outsock);
 
@@ -15135,6 +15172,7 @@ static int load_module(void)
 			ast_timer_close(timer);
 			timer = NULL;
 		}
+		__unload_module();
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -15160,7 +15198,7 @@ static int load_module(void)
  	if (ast_channel_register(&iax2_tech)) {
 		ast_log(LOG_ERROR, "Unable to register channel class %s\n", "IAX2");
 		__unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_register_switch(&iax2_switch)) {
@@ -15170,7 +15208,7 @@ static int load_module(void)
 	if (start_network_thread()) {
 		ast_log(LOG_ERROR, "Unable to start network thread\n");
 		__unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	} else {
 		ast_verb(2, "IAX Ready and Listening\n");
 	}
diff -urpN asterisk-13.9.1/channels/chan_mgcp.c asterisk-13.17.0/channels/chan_mgcp.c
--- asterisk-13.9.1/channels/chan_mgcp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_mgcp.c	2017-07-12 13:12:08.000000000 +0200
@@ -4851,11 +4851,11 @@ static int reload_config(int reload)
 static int load_module(void)
 {
 	if (!(global_capability = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	if (!(mgcp_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
 		ao2_ref(global_capability, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_format_cap_append(global_capability, ast_format_ulaw, 0);
 	ast_format_cap_append(mgcp_tech.capabilities, ast_format_ulaw, 0);
@@ -4864,7 +4864,7 @@ static int load_module(void)
 		ast_log(LOG_WARNING, "Unable to create schedule context\n");
 		ao2_ref(global_capability, -1);
 		ao2_ref(mgcp_tech.capabilities, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(io = io_context_create())) {
@@ -4872,7 +4872,7 @@ static int load_module(void)
 		ast_sched_context_destroy(sched);
 		ao2_ref(global_capability, -1);
 		ao2_ref(mgcp_tech.capabilities, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (reload_config(0)) {
@@ -4888,7 +4888,7 @@ static int load_module(void)
 		ast_sched_context_destroy(sched);
 		ao2_ref(global_capability, -1);
 		ao2_ref(mgcp_tech.capabilities, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	ast_rtp_glue_register(&mgcp_rtp_glue);
diff -urpN asterisk-13.9.1/channels/chan_motif.c asterisk-13.17.0/channels/chan_motif.c
--- asterisk-13.9.1/channels/chan_motif.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_motif.c	2017-07-12 13:12:08.000000000 +0200
@@ -2794,7 +2794,7 @@ end:
 	ao2_cleanup(jingle_tech.capabilities);
 	jingle_tech.capabilities = NULL;
 
-	return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_DECLINE;
 }
 
 /*! \brief Reload module */
diff -urpN asterisk-13.9.1/channels/chan_multicast_rtp.c asterisk-13.17.0/channels/chan_multicast_rtp.c
--- asterisk-13.9.1/channels/chan_multicast_rtp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_multicast_rtp.c	2017-07-12 13:12:08.000000000 +0200
@@ -28,7 +28,8 @@
  */
 
 /*** MODULEINFO
-	<support_level>core</support_level>
+	<support_level>deprecated</support_level>
+	<defaultenabled>no</defaultenabled>
  ***/
 
 #include "asterisk.h"
@@ -215,8 +216,8 @@ static int unload_module(void)
 	return 0;
 }
 
-AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Multicast RTP Paging Channel",
-	.support_level = AST_MODULE_SUPPORT_CORE,
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Multicast RTP Paging Channel (use chan_rtp instead)",
+	.support_level = AST_MODULE_SUPPORT_DEPRECATED,
 	.load = load_module,
 	.unload = unload_module,
 	.load_pri = AST_MODPRI_CHANNEL_DRIVER,
diff -urpN asterisk-13.9.1/channels/chan_nbs.c asterisk-13.17.0/channels/chan_nbs.c
--- asterisk-13.9.1/channels/chan_nbs.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_nbs.c	2017-07-12 13:12:08.000000000 +0200
@@ -259,12 +259,14 @@ static int unload_module(void)
 static int load_module(void)
 {
 	if (!(nbs_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_format_cap_append(nbs_tech.capabilities, ast_format_slin, 0);
 	/* Make sure we can register our channel type */
 	if (ast_channel_register(&nbs_tech)) {
 		ast_log(LOG_ERROR, "Unable to register channel class %s\n", type);
+		ao2_ref(nbs_tech.capabilities, -1);
+		nbs_tech.capabilities = NULL;
 		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/channels/chan_oss.c asterisk-13.17.0/channels/chan_oss.c
--- asterisk-13.9.1/channels/chan_oss.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_oss.c	2017-07-12 13:12:08.000000000 +0200
@@ -727,7 +727,7 @@ static struct ast_frame *oss_read(struct
 		return f;
 	/* ok we can build and deliver the frame to the caller */
 	f->frametype = AST_FRAME_VOICE;
-	f->subclass.format = ao2_bump(ast_format_slin);
+	f->subclass.format = ast_format_slin;
 	f->samples = FRAME_SIZE;
 	f->datalen = FRAME_SIZE * 2;
 	f->data.ptr = o->oss_read_buf + AST_FRIENDLY_OFFSET;
@@ -1437,6 +1437,31 @@ error:
 #endif
 }
 
+static int unload_module(void)
+{
+	struct chan_oss_pvt *o, *next;
+
+	ast_channel_unregister(&oss_tech);
+	ast_cli_unregister_multiple(cli_oss, ARRAY_LEN(cli_oss));
+
+	o = oss_default.next;
+	while (o) {
+		close(o->sounddev);
+		if (o->owner)
+			ast_softhangup(o->owner, AST_SOFTHANGUP_APPUNLOAD);
+		if (o->owner)
+			return -1;
+		next = o->next;
+		ast_free(o->name);
+		ast_free(o);
+		o = next;
+	}
+	ao2_cleanup(oss_tech.capabilities);
+	oss_tech.capabilities = NULL;
+
+	return 0;
+}
+
 /*!
  * \brief Load the module
  *
@@ -1474,12 +1499,12 @@ static int load_module(void)
 	if (find_desc(oss_active) == NULL) {
 		ast_log(LOG_NOTICE, "Device %s not found\n", oss_active);
 		/* XXX we could default to 'dsp' perhaps ? */
-		/* XXX should cleanup allocated memory etc. */
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(oss_tech.capabilities = ast_format_cap_alloc(0))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_format_cap_append(oss_tech.capabilities, ast_format_slin, 0);
 
@@ -1496,31 +1521,5 @@ static int load_module(void)
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-
-static int unload_module(void)
-{
-	struct chan_oss_pvt *o, *next;
-
-	ast_channel_unregister(&oss_tech);
-	ast_cli_unregister_multiple(cli_oss, ARRAY_LEN(cli_oss));
-
-	o = oss_default.next;
-	while (o) {
-		close(o->sounddev);
-		if (o->owner)
-			ast_softhangup(o->owner, AST_SOFTHANGUP_APPUNLOAD);
-		if (o->owner)
-			return -1;
-		next = o->next;
-		ast_free(o->name);
-		ast_free(o);
-		o = next;
-	}
-	ao2_cleanup(oss_tech.capabilities);
-	oss_tech.capabilities = NULL;
-
-	return 0;
-}
-
 AST_MODULE_INFO_STANDARD_EXTENDED(ASTERISK_GPL_KEY, "OSS Console Channel Driver");
 
diff -urpN asterisk-13.9.1/channels/chan_phone.c asterisk-13.17.0/channels/chan_phone.c
--- asterisk-13.9.1/channels/chan_phone.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_phone.c	2017-07-12 13:12:08.000000000 +0200
@@ -1418,7 +1418,7 @@ static int load_module(void)
 	if (ast_mutex_lock(&iflock)) {
 		/* It's a little silly to lock it, but we mind as well just to be sure */
 		ast_log(LOG_ERROR, "Unable to lock interface list???\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	v = ast_variable_browse(cfg, "interfaces");
 	while(v) {
@@ -1434,7 +1434,7 @@ static int load_module(void)
 					ast_config_destroy(cfg);
 					ast_mutex_unlock(&iflock);
 					__unload_module();
-					return AST_MODULE_LOAD_FAILURE;
+					return AST_MODULE_LOAD_DECLINE;
 				}
 		} else if (!strcasecmp(v->name, "silencesupression")) {
 			silencesupression = ast_true(v->value);
@@ -1510,7 +1510,7 @@ static int load_module(void)
 		ast_log(LOG_ERROR, "Unable to register channel class 'Phone'\n");
 		ast_config_destroy(cfg);
 		__unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_config_destroy(cfg);
 	/* And start the monitor for the first time */
diff -urpN asterisk-13.9.1/channels/chan_pjsip.c asterisk-13.17.0/channels/chan_pjsip.c
--- asterisk-13.9.1/channels/chan_pjsip.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_pjsip.c	2017-07-12 13:12:08.000000000 +0200
@@ -219,9 +219,7 @@ static enum ast_rtp_glue_result chan_pjs
 /*! \brief Function called by RTP engine to get peer capabilities */
 static void chan_pjsip_get_codec(struct ast_channel *chan, struct ast_format_cap *result)
 {
-	struct ast_sip_channel_pvt *channel = ast_channel_tech_pvt(chan);
-
-	ast_format_cap_append_from_cap(result, channel->session->endpoint->media.codecs, AST_MEDIA_TYPE_UNKNOWN);
+	ast_format_cap_append_from_cap(result, ast_channel_nativeformats(chan), AST_MEDIA_TYPE_UNKNOWN);
 }
 
 /*! \brief Destructor function for \ref transport_info_data */
@@ -269,6 +267,9 @@ static int direct_media_mitigate_glare(s
 	return 0;
 }
 
+/*!
+ * \pre chan is locked
+ */
 static int check_for_rtp_changes(struct ast_channel *chan, struct ast_rtp_instance *rtp,
 		struct ast_sip_session_media *media, int rtcp_fd)
 {
@@ -338,6 +339,11 @@ static int send_direct_media_request(voi
 	int changed = 0;
 	int res = 0;
 
+	/* The channel needs to be locked when checking for RTP changes.
+	 * Otherwise, we could end up destroying an underlying RTCP structure
+	 * at the same time that the channel thread is attempting to read RTCP
+	 */
+	ast_channel_lock(cdata->chan);
 	if (pvt->media[SIP_MEDIA_AUDIO]) {
 		changed |= check_for_rtp_changes(
 			cdata->chan, cdata->rtp, pvt->media[SIP_MEDIA_AUDIO], 1);
@@ -346,6 +352,7 @@ static int send_direct_media_request(voi
 		changed |= check_for_rtp_changes(
 			cdata->chan, cdata->vrtp, pvt->media[SIP_MEDIA_VIDEO], 3);
 	}
+	ast_channel_unlock(cdata->chan);
 
 	if (direct_media_mitigate_glare(cdata->session)) {
 		ast_debug(4, "Disregarding setting RTP on %s: mitigating re-INVITE glare\n", ast_channel_name(cdata->chan));
@@ -550,6 +557,12 @@ static int answer(void *data)
 	struct ast_sip_session *session = data;
 
 	if (session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			session->inv_session->cause,
+			pjsip_get_status_text(session->inv_session->cause)->ptr);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(session->inv_session);
+#endif
 		return 0;
 	}
 
@@ -566,6 +579,10 @@ static int answer(void *data)
 		ast_sip_session_send_response(session, packet);
 	}
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
+
 	return (status == PJ_SUCCESS) ? 0 : -1;
 }
 
@@ -582,12 +599,23 @@ static int chan_pjsip_answer(struct ast_
 	ast_setstate(ast, AST_STATE_UP);
 	session = ao2_bump(channel->session);
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	if (pjsip_inv_add_ref(session->inv_session) != PJ_SUCCESS) {
+		ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+		ao2_ref(session, -1);
+		return -1;
+	}
+#endif
+
 	/* the answer task needs to be pushed synchronously otherwise a race condition
 	   can occur between this thread and bridging (specifically when native bridging
 	   attempts to do direct media) */
 	ast_channel_unlock(ast);
 	if (ast_sip_push_task_synchronous(session->serializer, answer, session)) {
 		ast_log(LOG_WARNING, "Unable to push answer task to the threadpool. Cannot answer call\n");
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(session->inv_session);
+#endif
 		ao2_ref(session, -1);
 		ast_channel_lock(ast);
 		return -1;
@@ -603,10 +631,12 @@ static struct ast_frame *chan_pjsip_cng_
 {
 	const char *target_context;
 	int exists;
+	int dsp_features;
 
-	/* If we only needed this DSP for fax detection purposes we can just drop it now */
-	if (session->endpoint->dtmf == AST_SIP_DTMF_INBAND || session->endpoint->dtmf == AST_SIP_DTMF_AUTO) {
-		ast_dsp_set_features(session->dsp, DSP_FEATURE_DIGIT_DETECT);
+	dsp_features = ast_dsp_get_features(session->dsp);
+	dsp_features &= ~DSP_FEATURE_FAX_DETECT;
+	if (dsp_features) {
+		ast_dsp_set_features(session->dsp, dsp_features);
 	} else {
 		ast_dsp_free(session->dsp);
 		session->dsp = NULL;
@@ -619,16 +649,19 @@ static struct ast_frame *chan_pjsip_cng_
 
 	target_context = S_OR(ast_channel_macrocontext(session->channel), ast_channel_context(session->channel));
 
-	/* We need to unlock the channel here because ast_exists_extension has the
+	/*
+	 * We need to unlock the channel here because ast_exists_extension has the
 	 * potential to start and stop an autoservice on the channel. Such action
 	 * is prone to deadlock if the channel is locked.
+	 *
+	 * ast_async_goto() has its own restriction on not holding the channel lock.
 	 */
 	ast_channel_unlock(session->channel);
+	ast_frfree(f);
+	f = &ast_null_frame;
 	exists = ast_exists_extension(session->channel, target_context, "fax", 1,
 		S_COR(ast_channel_caller(session->channel)->id.number.valid,
 			ast_channel_caller(session->channel)->id.number.str, NULL));
-	ast_channel_lock(session->channel);
-
 	if (exists) {
 		ast_verb(2, "Redirecting '%s' to fax extension due to CNG detection\n",
 			ast_channel_name(session->channel));
@@ -637,20 +670,24 @@ static struct ast_frame *chan_pjsip_cng_
 			ast_log(LOG_ERROR, "Failed to async goto '%s' into fax extension in '%s'\n",
 				ast_channel_name(session->channel), target_context);
 		}
-		ast_frfree(f);
-		f = &ast_null_frame;
 	} else {
 		ast_log(LOG_NOTICE, "FAX CNG detected on '%s' but no fax extension in '%s'\n",
 			ast_channel_name(session->channel), target_context);
 	}
+	ast_channel_lock(session->channel);
 
 	return f;
 }
 
-/*! \brief Function called by core to read any waiting frames */
+/*!
+ * \brief Function called by core to read any waiting frames 
+ *
+ * \note The channel is already locked.
+ */
 static struct ast_frame *chan_pjsip_read(struct ast_channel *ast)
 {
 	struct ast_sip_channel_pvt *channel = ast_channel_tech_pvt(ast);
+	struct ast_sip_session *session;
 	struct chan_pjsip_pvt *pvt = channel->pvt;
 	struct ast_frame *f;
 	struct ast_sip_session_media *media = NULL;
@@ -688,22 +725,67 @@ static struct ast_frame *chan_pjsip_read
 		return f;
 	}
 
-	if (ast_format_cap_iscompatible_format(channel->session->endpoint->media.codecs, f->subclass.format) == AST_FORMAT_CMP_NOT_EQUAL) {
-		ast_debug(1, "Oooh, got a frame with format of %s on channel '%s' when endpoint '%s' is not configured for it\n",
-			ast_format_get_name(f->subclass.format), ast_channel_name(ast),
-			ast_sorcery_object_get_id(channel->session->endpoint));
+	session = channel->session;
+
+	if (ast_format_cap_iscompatible_format(ast_channel_nativeformats(ast), f->subclass.format) == AST_FORMAT_CMP_NOT_EQUAL) {
+		ast_debug(1, "Oooh, got a frame with format of %s on channel '%s' when it has not been negotiated\n",
+			ast_format_get_name(f->subclass.format), ast_channel_name(ast));
 
 		ast_frfree(f);
 		return &ast_null_frame;
 	}
 
-	if (channel->session->dsp) {
-		f = ast_dsp_process(ast, channel->session->dsp, f);
+	if (!session->endpoint->asymmetric_rtp_codec &&
+		ast_format_cmp(ast_channel_rawwriteformat(ast), f->subclass.format) == AST_FORMAT_CMP_NOT_EQUAL) {
+		struct ast_format_cap *caps;
+
+		/* For maximum compatibility we ensure that the formats match that of the received media */
+		ast_debug(1, "Oooh, got a frame with format of %s on channel '%s' when we're sending '%s', switching to match\n",
+			ast_format_get_name(f->subclass.format), ast_channel_name(ast),
+			ast_format_get_name(ast_channel_rawwriteformat(ast)));
+
+		caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+		if (caps) {
+			ast_format_cap_append_from_cap(caps, ast_channel_nativeformats(ast), AST_MEDIA_TYPE_UNKNOWN);
+			ast_format_cap_remove_by_type(caps, AST_MEDIA_TYPE_AUDIO);
+			ast_format_cap_append(caps, f->subclass.format, 0);
+			ast_channel_nativeformats_set(ast, caps);
+			ao2_ref(caps, -1);
+		}
+
+		ast_set_write_format_path(ast, ast_channel_writeformat(ast), f->subclass.format);
+		ast_set_read_format_path(ast, ast_channel_readformat(ast), f->subclass.format);
+
+		if (ast_channel_is_bridged(ast)) {
+			ast_channel_set_unbridged_nolock(ast, 1);
+		}
+	}
+
+	if (session->dsp) {
+		int dsp_features;
 
+		dsp_features = ast_dsp_get_features(session->dsp);
+		if ((dsp_features & DSP_FEATURE_FAX_DETECT)
+			&& session->endpoint->faxdetect_timeout
+			&& session->endpoint->faxdetect_timeout <= ast_channel_get_up_time(ast)) {
+			dsp_features &= ~DSP_FEATURE_FAX_DETECT;
+			if (dsp_features) {
+				ast_dsp_set_features(session->dsp, dsp_features);
+			} else {
+				ast_dsp_free(session->dsp);
+				session->dsp = NULL;
+			}
+			ast_debug(3, "Channel driver fax CNG detection timeout on %s\n",
+				ast_channel_name(ast));
+		}
+	}
+	if (session->dsp) {
+		f = ast_dsp_process(ast, session->dsp, f);
 		if (f && (f->frametype == AST_FRAME_DTMF)) {
 			if (f->subclass.integer == 'f') {
-				ast_debug(3, "Fax CNG detected on %s\n", ast_channel_name(ast));
-				f = chan_pjsip_cng_tone_detected(channel->session, f);
+				ast_debug(3, "Channel driver fax CNG detected on %s\n",
+					ast_channel_name(ast));
+				f = chan_pjsip_cng_tone_detected(session, f);
 			} else {
 				ast_debug(3, "* Detected inband DTMF '%c' on '%s'\n", f->subclass.integer,
 					ast_channel_name(ast));
@@ -1071,6 +1153,9 @@ static int indicate(void *data)
 		ast_sip_session_send_response(session, packet);
 	}
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
 	ao2_ref(ind_data, -1);
 
 	return 0;
@@ -1098,17 +1183,35 @@ static int transmit_info_with_vidupdate(
 	RAII_VAR(struct ast_sip_session *, session, data, ao2_cleanup);
 	struct pjsip_tx_data *tdata;
 
+	if (session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			session->inv_session->cause,
+			pjsip_get_status_text(session->inv_session->cause)->ptr);
+		goto failure;
+	}
+
 	if (ast_sip_create_request("INFO", session->inv_session->dlg, session->endpoint, NULL, NULL, &tdata)) {
 		ast_log(LOG_ERROR, "Could not create text video update INFO request\n");
-		return -1;
+		goto failure;
 	}
 	if (ast_sip_add_body(tdata, &body)) {
 		ast_log(LOG_ERROR, "Could not add body to text video update INFO request\n");
-		return -1;
+		goto failure;
 	}
 	ast_sip_session_send_request(session, tdata);
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
+
 	return 0;
+
+failure:
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
+	return -1;
+
 }
 
 /*!
@@ -1151,6 +1254,17 @@ static int update_connected_line_informa
 {
 	struct ast_sip_session *session = data;
 
+	if (session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			session->inv_session->cause,
+			pjsip_get_status_text(session->inv_session->cause)->ptr);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(session->inv_session);
+#endif
+		ao2_ref(session, -1);
+		return -1;
+	}
+
 	if (ast_channel_state(session->channel) == AST_STATE_UP
 		|| session->inv_session->role == PJSIP_ROLE_UAC) {
 		if (is_colp_update_allowed(session)) {
@@ -1158,8 +1272,7 @@ static int update_connected_line_informa
 			int generate_new_sdp;
 
 			method = session->endpoint->id.refresh_method;
-			if (session->inv_session->invite_tsx
-				&& (session->inv_session->options & PJSIP_INV_SUPPORT_UPDATE)) {
+			if (session->inv_session->options & PJSIP_INV_SUPPORT_UPDATE) {
 				method = AST_SIP_SESSION_REFRESH_METHOD_UPDATE;
 			}
 
@@ -1188,6 +1301,10 @@ static int update_connected_line_informa
 		}
 	}
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
+
 	ao2_ref(session, -1);
 	return 0;
 }
@@ -1251,6 +1368,7 @@ static int chan_pjsip_indicate(struct as
 		} else {
 			res = -1;
 		}
+		ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "PJSIP/%s", ast_sorcery_object_get_id(channel->session->endpoint));
 		break;
 	case AST_CONTROL_VIDUPDATE:
 		media = pvt->media[SIP_MEDIA_VIDEO];
@@ -1268,10 +1386,18 @@ static int chan_pjsip_indicate(struct as
 				res = ast_rtp_instance_write(media->rtp, &fr);
 			} else {
 				ao2_ref(channel->session, +1);
-
-				if (ast_sip_push_task(channel->session->serializer, transmit_info_with_vidupdate, channel->session)) {
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+				if (pjsip_inv_add_ref(channel->session->inv_session) != PJ_SUCCESS) {
+					ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
 					ao2_cleanup(channel->session);
+				} else {
+#endif
+					if (ast_sip_push_task(channel->session->serializer, transmit_info_with_vidupdate, channel->session)) {
+						ao2_cleanup(channel->session);
+					}
+#ifdef HAVE_PJSIP_INV_SESSION_REF
 				}
+#endif
 			}
 			ast_test_suite_event_notify("AST_CONTROL_VIDUPDATE", "Result: Success");
 		} else {
@@ -1281,7 +1407,17 @@ static int chan_pjsip_indicate(struct as
 		break;
 	case AST_CONTROL_CONNECTED_LINE:
 		ao2_ref(channel->session, +1);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		if (pjsip_inv_add_ref(channel->session->inv_session) != PJ_SUCCESS) {
+			ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+			ao2_cleanup(channel->session);
+			return -1;
+		}
+#endif
 		if (ast_sip_push_task(channel->session->serializer, update_connected_line_information, channel->session)) {
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+			pjsip_inv_dec_ref(channel->session->inv_session);
+#endif
 			ao2_cleanup(channel->session);
 		}
 		break;
@@ -1358,9 +1494,23 @@ static int chan_pjsip_indicate(struct as
 
 	if (response_code) {
 		struct indicate_data *ind_data = indicate_data_alloc(channel->session, condition, response_code, data, datalen);
-		if (!ind_data || ast_sip_push_task(channel->session->serializer, indicate, ind_data)) {
+
+		if (!ind_data) {
+			return -1;
+		}
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		if (pjsip_inv_add_ref(ind_data->session->inv_session) != PJ_SUCCESS) {
+			ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+			ao2_cleanup(ind_data);
+			return -1;
+		}
+#endif
+		if (ast_sip_push_task(channel->session->serializer, indicate, ind_data)) {
 			ast_log(LOG_NOTICE, "Cannot send response code %d to endpoint %s. Could not queue task properly\n",
 					response_code, ast_sorcery_object_get_id(channel->session->endpoint));
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+			pjsip_inv_dec_ref(ind_data->session->inv_session);
+#endif
 			ao2_cleanup(ind_data);
 			res = -1;
 		}
@@ -1408,7 +1558,8 @@ static void transfer_redirect(struct ast
 	pjsip_contact_hdr *contact;
 	pj_str_t tmp;
 
-	if (pjsip_inv_end_session(session->inv_session, 302, NULL, &packet) != PJ_SUCCESS) {
+	if (pjsip_inv_end_session(session->inv_session, 302, NULL, &packet) != PJ_SUCCESS
+		|| !packet) {
 		ast_log(LOG_WARNING, "Failed to redirect PJSIP session for channel %s\n",
 			ast_channel_name(session->channel));
 		message = AST_TRANSFER_FAILED;
@@ -1480,21 +1631,31 @@ static int transfer(void *data)
 	struct ast_sip_contact *contact = NULL;
 	const char *target = trnf_data->target;
 
-	/* See if we have an endpoint; if so, use its contact */
-	endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", target);
-	if (endpoint) {
-		contact = ast_sip_location_retrieve_contact_from_aor_list(endpoint->aors);
-		if (contact && !ast_strlen_zero(contact->uri)) {
-			target = contact->uri;
+	if (trnf_data->session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			trnf_data->session->inv_session->cause,
+			pjsip_get_status_text(trnf_data->session->inv_session->cause)->ptr);
+	} else {
+		/* See if we have an endpoint; if so, use its contact */
+		endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", target);
+		if (endpoint) {
+			contact = ast_sip_location_retrieve_contact_from_aor_list(endpoint->aors);
+			if (contact && !ast_strlen_zero(contact->uri)) {
+				target = contact->uri;
+			}
 		}
-	}
 
-	if (ast_channel_state(trnf_data->session->channel) == AST_STATE_RING) {
-		transfer_redirect(trnf_data->session, target);
-	} else {
-		transfer_refer(trnf_data->session, target);
+		if (ast_channel_state(trnf_data->session->channel) == AST_STATE_RING) {
+			transfer_redirect(trnf_data->session, target);
+		} else {
+			transfer_refer(trnf_data->session, target);
+		}
 	}
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(trnf_data->session->inv_session);
+#endif
+
 	ao2_ref(trnf_data, -1);
 	ao2_cleanup(endpoint);
 	ao2_cleanup(contact);
@@ -1511,8 +1672,19 @@ static int chan_pjsip_transfer(struct as
 		return -1;
 	}
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	if (pjsip_inv_add_ref(trnf_data->session->inv_session) != PJ_SUCCESS) {
+		ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+		ao2_cleanup(trnf_data);
+		return -1;
+	}
+#endif
+
 	if (ast_sip_push_task(channel->session->serializer, transfer, trnf_data)) {
 		ast_log(LOG_WARNING, "Error requesting transfer\n");
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(trnf_data->session->inv_session);
+#endif
 		ao2_cleanup(trnf_data);
 		return -1;
 	}
@@ -1535,14 +1707,20 @@ static int chan_pjsip_digit_begin(struct
 		}
 
 		ast_rtp_instance_dtmf_begin(media->rtp, digit);
-                break;
+		break;
 	case AST_SIP_DTMF_AUTO:
-                       if (!media || !media->rtp || (ast_rtp_instance_dtmf_mode_get(media->rtp) == AST_RTP_DTMF_MODE_INBAND)) {
-                        return -1;
-                }
+		if (!media || !media->rtp || (ast_rtp_instance_dtmf_mode_get(media->rtp) == AST_RTP_DTMF_MODE_INBAND)) {
+			return -1;
+		}
 
-                ast_rtp_instance_dtmf_begin(media->rtp, digit);
-                break;
+		ast_rtp_instance_dtmf_begin(media->rtp, digit);
+		break;
+	case AST_SIP_DTMF_AUTO_INFO:
+		if (!media || !media->rtp || (ast_rtp_instance_dtmf_mode_get(media->rtp) == AST_RTP_DTMF_MODE_NONE)) {
+			return -1;
+		}
+		ast_rtp_instance_dtmf_begin(media->rtp, digit);
+		break;
 	case AST_SIP_DTMF_NONE:
 		break;
 	case AST_SIP_DTMF_INBAND:
@@ -1594,9 +1772,16 @@ static int transmit_info_dtmf(void *data
 		.subtype = "dtmf-relay",
 	};
 
+	if (session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			session->inv_session->cause,
+			pjsip_get_status_text(session->inv_session->cause)->ptr);
+		goto failure;
+	}
+
 	if (!(body_text = ast_str_create(32))) {
 		ast_log(LOG_ERROR, "Could not allocate buffer for INFO DTMF.\n");
-		return -1;
+		goto failure;
 	}
 	ast_str_set(&body_text, 0, "Signal=%c\r\nDuration=%u\r\n", dtmf_data->digit, dtmf_data->duration);
 
@@ -1604,16 +1789,27 @@ static int transmit_info_dtmf(void *data
 
 	if (ast_sip_create_request("INFO", session->inv_session->dlg, session->endpoint, NULL, NULL, &tdata)) {
 		ast_log(LOG_ERROR, "Could not create DTMF INFO request\n");
-		return -1;
+		goto failure;
 	}
 	if (ast_sip_add_body(tdata, &body)) {
 		ast_log(LOG_ERROR, "Could not add body to DTMF INFO request\n");
 		pjsip_tx_data_dec_ref(tdata);
-		return -1;
+		goto failure;
 	}
 	ast_sip_session_send_request(session, tdata);
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
+
 	return 0;
+
+failure:
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(session->inv_session);
+#endif
+	return -1;
+
 }
 
 /*! \brief Function called by core to stop a DTMF digit */
@@ -1625,6 +1821,20 @@ static int chan_pjsip_digit_end(struct a
 	int res = 0;
 
 	switch (channel->session->endpoint->dtmf) {
+	case AST_SIP_DTMF_AUTO_INFO:
+	{
+		if (!media || !media->rtp) {
+			return -1;
+		}
+		if (ast_rtp_instance_dtmf_mode_get(media->rtp) != AST_RTP_DTMF_MODE_NONE) {
+			ast_debug(3, "Told to send end of digit on Auto-Info channel %s RFC4733 negotiated so using it.\n", ast_channel_name(ast));
+			ast_rtp_instance_dtmf_end_with_duration(media->rtp, digit, duration);
+			break;
+		}
+		/* If RFC_4733 was not negotiated, fail through to the DTMF_INFO processing */
+		ast_debug(3, "Told to send end of digit on Auto-Info channel %s RFC4733 NOT negotiated using INFO instead.\n", ast_channel_name(ast));
+	}
+
 	case AST_SIP_DTMF_INFO:
 	{
 		struct info_dtmf_data *dtmf_data = info_dtmf_data_alloc(channel->session, digit, duration);
@@ -1633,8 +1843,19 @@ static int chan_pjsip_digit_end(struct a
 			return -1;
 		}
 
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		if (pjsip_inv_add_ref(dtmf_data->session->inv_session) != PJ_SUCCESS) {
+			ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+			ao2_cleanup(dtmf_data);
+			return -1;
+		}
+#endif
+
 		if (ast_sip_push_task(channel->session->serializer, transmit_info_dtmf, dtmf_data)) {
 			ast_log(LOG_WARNING, "Error sending DTMF via INFO.\n");
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+			pjsip_inv_dec_ref(dtmf_data->session->inv_session);
+#endif
 			ao2_cleanup(dtmf_data);
 			return -1;
 		}
@@ -1646,14 +1867,15 @@ static int chan_pjsip_digit_end(struct a
 		}
 
 		ast_rtp_instance_dtmf_end_with_duration(media->rtp, digit, duration);
-                break;
-        case AST_SIP_DTMF_AUTO:
-                if (!media || !media->rtp || (ast_rtp_instance_dtmf_mode_get(media->rtp) == AST_RTP_DTMF_MODE_INBAND)) {
-                        return -1;
-                }
+		break;
+	case AST_SIP_DTMF_AUTO:
+		if (!media || !media->rtp || (ast_rtp_instance_dtmf_mode_get(media->rtp) == AST_RTP_DTMF_MODE_INBAND)) {
+			 return -1;
+		}
+
+		ast_rtp_instance_dtmf_end_with_duration(media->rtp, digit, duration);
+		break;
 
-                ast_rtp_instance_dtmf_end_with_duration(media->rtp, digit, duration);
-                break;
 
 	case AST_SIP_DTMF_NONE:
 		break;
@@ -1817,11 +2039,16 @@ static int hangup(void *data)
 	struct ast_sip_session *session = channel->session;
 	int cause = h_data->cause;
 
-	ast_sip_session_terminate(session, cause);
+	/*
+	 * It's possible that session_terminate might cause the session to be destroyed
+	 * immediately so we need to keep a reference to it so we can NULL session->channel
+	 * afterwards.
+	 */
+	ast_sip_session_terminate(ao2_bump(session), cause);
 	clear_session_and_channel(session, ast, pvt);
+	ao2_cleanup(session);
 	ao2_cleanup(channel);
 	ao2_cleanup(h_data);
-
 	return 0;
 }
 
@@ -1890,22 +2117,53 @@ static int request(void *obj)
 
 	AST_NONSTANDARD_APP_ARGS(args, tmp, '/');
 
-	/* If a request user has been specified extract it from the endpoint name portion */
-	if ((endpoint_name = strchr(args.endpoint, '@'))) {
-		request_user = args.endpoint;
-		*endpoint_name++ = '\0';
+	if (ast_sip_get_disable_multi_domain()) {
+		/* If a request user has been specified extract it from the endpoint name portion */
+		if ((endpoint_name = strchr(args.endpoint, '@'))) {
+			request_user = args.endpoint;
+			*endpoint_name++ = '\0';
+		} else {
+			endpoint_name = args.endpoint;
+		}
+
+		if (ast_strlen_zero(endpoint_name)) {
+			ast_log(LOG_ERROR, "Unable to create PJSIP channel with empty endpoint name\n");
+			req_data->cause = AST_CAUSE_CHANNEL_UNACCEPTABLE;
+			return -1;
+		} else if (!(endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", endpoint_name))) {
+			ast_log(LOG_ERROR, "Unable to create PJSIP channel - endpoint '%s' was not found\n", endpoint_name);
+			req_data->cause = AST_CAUSE_NO_ROUTE_DESTINATION;
+			return -1;
+		}
 	} else {
+		/* First try to find an exact endpoint match, for single (user) or multi-domain (user@domain) */
 		endpoint_name = args.endpoint;
-	}
+		if (ast_strlen_zero(endpoint_name)) {
+			ast_log(LOG_ERROR, "Unable to create PJSIP channel with empty endpoint name\n");
+			req_data->cause = AST_CAUSE_CHANNEL_UNACCEPTABLE;
+			return -1;
+		} else if (!(endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", endpoint_name))) {
+			/* It seems it's not a multi-domain endpoint or single endpoint exact match,
+			 * it's possible that it's a SIP trunk with a specified user (user@trunkname),
+			 * so extract the user before @ sign.
+			 */
+			if ((endpoint_name = strchr(args.endpoint, '@'))) {
+				request_user = args.endpoint;
+				*endpoint_name++ = '\0';
+			}
 
-	if (ast_strlen_zero(endpoint_name)) {
-		ast_log(LOG_ERROR, "Unable to create PJSIP channel with empty endpoint name\n");
-		req_data->cause = AST_CAUSE_CHANNEL_UNACCEPTABLE;
-		return -1;
-	} else if (!(endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", endpoint_name))) {
-		ast_log(LOG_ERROR, "Unable to create PJSIP channel - endpoint '%s' was not found\n", endpoint_name);
-		req_data->cause = AST_CAUSE_NO_ROUTE_DESTINATION;
-		return -1;
+			if (ast_strlen_zero(endpoint_name)) {
+				ast_log(LOG_ERROR, "Unable to create PJSIP channel with empty endpoint name\n");
+				req_data->cause = AST_CAUSE_CHANNEL_UNACCEPTABLE;
+				return -1;
+			}
+
+			if (!(endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", endpoint_name))) {
+				ast_log(LOG_ERROR, "Unable to create PJSIP channel - endpoint '%s' was not found\n", endpoint_name);
+				req_data->cause = AST_CAUSE_NO_ROUTE_DESTINATION;
+				return -1;
+			}
+		}
 	}
 
 	if (!(session = ast_sip_session_create_outgoing(endpoint, NULL, args.aor, request_user, req_data->caps))) {
@@ -1980,11 +2238,21 @@ static int sendtext(void *obj)
 		.body_text = data->text
 	};
 
-	ast_debug(3, "Sending in dialog SIP message\n");
+	if (data->session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			data->session->inv_session->cause,
+			pjsip_get_status_text(data->session->inv_session->cause)->ptr);
+	} else {
+		ast_debug(3, "Sending in dialog SIP message\n");
+
+		ast_sip_create_request("MESSAGE", data->session->inv_session->dlg, data->session->endpoint, NULL, NULL, &tdata);
+		ast_sip_add_body(tdata, &body);
+		ast_sip_send_request(tdata, data->session->inv_session->dlg, data->session->endpoint, NULL, NULL);
+	}
 
-	ast_sip_create_request("MESSAGE", data->session->inv_session->dlg, data->session->endpoint, NULL, NULL, &tdata);
-	ast_sip_add_body(tdata, &body);
-	ast_sip_send_request(tdata, data->session->inv_session->dlg, data->session->endpoint, NULL, NULL);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(data->session->inv_session);
+#endif
 
 	return 0;
 }
@@ -1995,7 +2263,22 @@ static int chan_pjsip_sendtext(struct as
 	struct ast_sip_channel_pvt *channel = ast_channel_tech_pvt(ast);
 	struct sendtext_data *data = sendtext_data_create(channel->session, text);
 
-	if (!data || ast_sip_push_task(channel->session->serializer, sendtext, data)) {
+	if (!data) {
+		return -1;
+	}
+
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	if (pjsip_inv_add_ref(data->session->inv_session) != PJ_SUCCESS) {
+		ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+		ao2_ref(data, -1);
+		return -1;
+	}
+#endif
+
+	if (ast_sip_push_task(channel->session->serializer, sendtext, data)) {
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(data->session->inv_session);
+#endif
 		ao2_ref(data, -1);
 		return -1;
 	}
@@ -2173,7 +2456,8 @@ static int chan_pjsip_incoming_request(s
 	ast_sip_session_add_datastore(session, datastore);
 
 	if (!(session->channel = chan_pjsip_new(session, AST_STATE_RING, session->exten, NULL, NULL, NULL, NULL))) {
-		if (pjsip_inv_end_session(session->inv_session, 503, NULL, &packet) == PJ_SUCCESS) {
+		if (pjsip_inv_end_session(session->inv_session, 503, NULL, &packet) == PJ_SUCCESS
+			&& packet) {
 			ast_sip_session_send_response(session, packet);
 		}
 
@@ -2285,6 +2569,21 @@ static void chan_pjsip_incoming_response
 		return;
 	}
 
+	/* Build and send the tech-specific cause information */
+	/* size of the string making up the cause code is "SIP " number + " " + reason length */
+	data_size += 4 + 4 + pj_strlen(&status.reason);
+	cause_code = ast_alloca(data_size);
+	memset(cause_code, 0, data_size);
+
+	ast_copy_string(cause_code->chan_name, ast_channel_name(session->channel), AST_CHANNEL_NAME);
+
+	snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "SIP %d %.*s", status.code,
+	(int) pj_strlen(&status.reason), pj_strbuf(&status.reason));
+
+	cause_code->ast_cause = hangup_sip2cause(status.code);
+	ast_queue_control_data(session->channel, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
+	ast_channel_hangupcause_hash_set(session->channel, cause_code, data_size);
+
 	switch (status.code) {
 	case 180:
 		ast_queue_control(session->channel, AST_CONTROL_RINGING);
@@ -2303,21 +2602,6 @@ static void chan_pjsip_incoming_response
 	default:
 		break;
 	}
-
-	/* Build and send the tech-specific cause information */
-	/* size of the string making up the cause code is "SIP " number + " " + reason length */
-	data_size += 4 + 4 + pj_strlen(&status.reason);
-	cause_code = ast_alloca(data_size);
-	memset(cause_code, 0, data_size);
-
-	ast_copy_string(cause_code->chan_name, ast_channel_name(session->channel), AST_CHANNEL_NAME);
-
-	snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "SIP %d %.*s", status.code,
-		(int) pj_strlen(&status.reason), pj_strbuf(&status.reason));
-
-	cause_code->ast_cause = hangup_sip2cause(status.code);
-	ast_queue_control_data(session->channel, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
-	ast_channel_hangupcause_hash_set(session->channel, cause_code, data_size);
 }
 
 static int chan_pjsip_incoming_ack(struct ast_sip_session *session, struct pjsip_rx_data *rdata)
@@ -2348,6 +2632,11 @@ static struct ast_custom_function media_
 	.write = pjsip_acf_media_offer_write
 };
 
+static struct ast_custom_function session_refresh_function = {
+	.name = "PJSIP_SEND_SESSION_REFRESH",
+	.write = pjsip_acf_session_refresh_write,
+};
+
 /*!
  * \brief Load the module
  *
@@ -2387,6 +2676,11 @@ static int load_module(void)
 		goto end;
 	}
 
+	if (ast_custom_function_register(&session_refresh_function)) {
+		ast_log(LOG_WARNING, "Unable to register PJSIP_SEND_SESSION_REFRESH dialplan function\n");
+		goto end;
+	}
+
 	if (ast_sip_session_register_supplement(&chan_pjsip_supplement)) {
 		ast_log(LOG_ERROR, "Unable to register PJSIP supplement\n");
 		goto end;
@@ -2443,10 +2737,11 @@ end:
 	pjsip_uids_onhold = NULL;
 	ast_custom_function_unregister(&media_offer_function);
 	ast_custom_function_unregister(&chan_pjsip_dial_contacts_function);
+	ast_custom_function_unregister(&session_refresh_function);
 	ast_channel_unregister(&chan_pjsip_tech);
 	ast_rtp_glue_unregister(&chan_pjsip_rtp_glue);
 
-	return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_DECLINE;
 }
 
 /*! \brief Unload the PJSIP channel from Asterisk */
@@ -2464,6 +2759,7 @@ static int unload_module(void)
 
 	ast_custom_function_unregister(&media_offer_function);
 	ast_custom_function_unregister(&chan_pjsip_dial_contacts_function);
+	ast_custom_function_unregister(&session_refresh_function);
 
 	ast_channel_unregister(&chan_pjsip_tech);
 	ao2_ref(chan_pjsip_tech.capabilities, -1);
diff -urpN asterisk-13.9.1/channels/chan_rtp.c asterisk-13.17.0/channels/chan_rtp.c
--- asterisk-13.9.1/channels/chan_rtp.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/channels/chan_rtp.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,420 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2009 - 2014, Digium, Inc.
+ *
+ * Joshua Colp <jcolp@digium.com>
+ * Andreas 'MacBrody' Brodmann <andreas.brodmann@gmail.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \author Joshua Colp <jcolp@digium.com>
+ * \author Andreas 'MacBrody' Broadmann <andreas.brodmann@gmail.com>
+ *
+ * \brief RTP (Multicast and Unicast) Media Channel
+ *
+ * \ingroup channel_drivers
+ */
+
+/*** MODULEINFO
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_REGISTER_FILE()
+
+#include "asterisk/channel.h"
+#include "asterisk/module.h"
+#include "asterisk/pbx.h"
+#include "asterisk/acl.h"
+#include "asterisk/app.h"
+#include "asterisk/rtp_engine.h"
+#include "asterisk/causes.h"
+#include "asterisk/format_cache.h"
+#include "asterisk/multicast_rtp.h"
+
+/* Forward declarations */
+static struct ast_channel *multicast_rtp_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause);
+static struct ast_channel *unicast_rtp_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause);
+static int rtp_call(struct ast_channel *ast, const char *dest, int timeout);
+static int rtp_hangup(struct ast_channel *ast);
+static struct ast_frame *rtp_read(struct ast_channel *ast);
+static int rtp_write(struct ast_channel *ast, struct ast_frame *f);
+
+/* Multicast channel driver declaration */
+static struct ast_channel_tech multicast_rtp_tech = {
+	.type = "MulticastRTP",
+	.description = "Multicast RTP Paging Channel Driver",
+	.requester = multicast_rtp_request,
+	.call = rtp_call,
+	.hangup = rtp_hangup,
+	.read = rtp_read,
+	.write = rtp_write,
+};
+
+/* Unicast channel driver declaration */
+static struct ast_channel_tech unicast_rtp_tech = {
+	.type = "UnicastRTP",
+	.description = "Unicast RTP Media Channel Driver",
+	.requester = unicast_rtp_request,
+	.call = rtp_call,
+	.hangup = rtp_hangup,
+	.read = rtp_read,
+	.write = rtp_write,
+};
+
+/*! \brief Function called when we should read a frame from the channel */
+static struct ast_frame  *rtp_read(struct ast_channel *ast)
+{
+	struct ast_rtp_instance *instance = ast_channel_tech_pvt(ast);
+	int fdno = ast_channel_fdno(ast);
+
+	switch (fdno) {
+	case 0:
+		return ast_rtp_instance_read(instance, 0);
+	default:
+		return &ast_null_frame;
+	}
+}
+
+/*! \brief Function called when we should write a frame to the channel */
+static int rtp_write(struct ast_channel *ast, struct ast_frame *f)
+{
+	struct ast_rtp_instance *instance = ast_channel_tech_pvt(ast);
+
+	return ast_rtp_instance_write(instance, f);
+}
+
+/*! \brief Function called when we should actually call the destination */
+static int rtp_call(struct ast_channel *ast, const char *dest, int timeout)
+{
+	struct ast_rtp_instance *instance = ast_channel_tech_pvt(ast);
+
+	ast_queue_control(ast, AST_CONTROL_ANSWER);
+
+	return ast_rtp_instance_activate(instance);
+}
+
+/*! \brief Function called when we should hang the channel up */
+static int rtp_hangup(struct ast_channel *ast)
+{
+	struct ast_rtp_instance *instance = ast_channel_tech_pvt(ast);
+
+	ast_rtp_instance_destroy(instance);
+
+	ast_channel_tech_pvt_set(ast, NULL);
+
+	return 0;
+}
+
+/*! \brief Function called when we should prepare to call the multicast destination */
+static struct ast_channel *multicast_rtp_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause)
+{
+	char *parse;
+	struct ast_rtp_instance *instance;
+	struct ast_sockaddr control_address;
+	struct ast_sockaddr destination_address;
+	struct ast_channel *chan;
+	struct ast_format_cap *caps = NULL;
+	struct ast_format *fmt = NULL;
+	AST_DECLARE_APP_ARGS(args,
+		AST_APP_ARG(type);
+		AST_APP_ARG(destination);
+		AST_APP_ARG(control);
+		AST_APP_ARG(options);
+	);
+	struct ast_multicast_rtp_options *mcast_options = NULL;
+
+	if (ast_strlen_zero(data)) {
+		ast_log(LOG_ERROR, "A multicast type and destination must be given to the 'MulticastRTP' channel\n");
+		goto failure;
+	}
+	parse = ast_strdupa(data);
+	AST_NONSTANDARD_APP_ARGS(args, parse, '/');
+
+	if (ast_strlen_zero(args.type)) {
+		ast_log(LOG_ERROR, "Type is required for the 'MulticastRTP' channel\n");
+		goto failure;
+	}
+
+	if (ast_strlen_zero(args.destination)) {
+		ast_log(LOG_ERROR, "Destination is required for the 'MulticastRTP' channel\n");
+		goto failure;
+	}
+	if (!ast_sockaddr_parse(&destination_address, args.destination, PARSE_PORT_REQUIRE)) {
+		ast_log(LOG_ERROR, "Destination address '%s' could not be parsed\n",
+			args.destination);
+		goto failure;
+	}
+
+	ast_sockaddr_setnull(&control_address);
+	if (!ast_strlen_zero(args.control)
+		&& !ast_sockaddr_parse(&control_address, args.control, PARSE_PORT_REQUIRE)) {
+		ast_log(LOG_ERROR, "Control address '%s' could not be parsed\n", args.control);
+		goto failure;
+	}
+
+	mcast_options = ast_multicast_rtp_create_options(args.type, args.options);
+	if (!mcast_options) {
+		goto failure;
+	}
+
+	fmt = ast_multicast_rtp_options_get_format(mcast_options);
+	if (!fmt) {
+		fmt = ast_format_cap_get_format(cap, 0);
+	}
+	if (!fmt) {
+		ast_log(LOG_ERROR, "No codec available for sending RTP to '%s'\n",
+			args.destination);
+		goto failure;
+	}
+
+	caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!caps) {
+		goto failure;
+	}
+
+	instance = ast_rtp_instance_new("multicast", NULL, &control_address, mcast_options);
+	if (!instance) {
+		ast_log(LOG_ERROR,
+			"Could not create '%s' multicast RTP instance for sending media to '%s'\n",
+			args.type, args.destination);
+		goto failure;
+	}
+
+	chan = ast_channel_alloc(1, AST_STATE_DOWN, "", "", "", "", "", assignedids,
+		requestor, 0, "MulticastRTP/%p", instance);
+	if (!chan) {
+		ast_rtp_instance_destroy(instance);
+		goto failure;
+	}
+	ast_rtp_instance_set_channel_id(instance, ast_channel_uniqueid(chan));
+	ast_rtp_instance_set_remote_address(instance, &destination_address);
+
+	ast_channel_tech_set(chan, &multicast_rtp_tech);
+
+	ast_format_cap_append(caps, fmt, 0);
+	ast_channel_nativeformats_set(chan, caps);
+	ast_channel_set_writeformat(chan, fmt);
+	ast_channel_set_rawwriteformat(chan, fmt);
+	ast_channel_set_readformat(chan, fmt);
+	ast_channel_set_rawreadformat(chan, fmt);
+
+	ast_channel_tech_pvt_set(chan, instance);
+
+	ast_channel_unlock(chan);
+
+	ao2_ref(fmt, -1);
+	ao2_ref(caps, -1);
+	ast_multicast_rtp_free_options(mcast_options);
+
+	return chan;
+
+failure:
+	ao2_cleanup(fmt);
+	ao2_cleanup(caps);
+	ast_multicast_rtp_free_options(mcast_options);
+	*cause = AST_CAUSE_FAILURE;
+	return NULL;
+}
+
+enum {
+	OPT_RTP_CODEC =  (1 << 0),
+	OPT_RTP_ENGINE = (1 << 1),
+};
+
+enum {
+	OPT_ARG_RTP_CODEC,
+	OPT_ARG_RTP_ENGINE,
+	/* note: this entry _MUST_ be the last one in the enum */
+	OPT_ARG_ARRAY_SIZE
+};
+
+AST_APP_OPTIONS(unicast_rtp_options, BEGIN_OPTIONS
+	/*! Set the codec to be used for unicast RTP */
+	AST_APP_OPTION_ARG('c', OPT_RTP_CODEC, OPT_ARG_RTP_CODEC),
+	/*! Set the RTP engine to use for unicast RTP */
+	AST_APP_OPTION_ARG('e', OPT_RTP_ENGINE, OPT_ARG_RTP_ENGINE),
+END_OPTIONS );
+
+/*! \brief Function called when we should prepare to call the unicast destination */
+static struct ast_channel *unicast_rtp_request(const char *type, struct ast_format_cap *cap, const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *data, int *cause)
+{
+	char *parse;
+	struct ast_rtp_instance *instance;
+	struct ast_sockaddr address;
+	struct ast_sockaddr local_address;
+	struct ast_channel *chan;
+	struct ast_format_cap *caps = NULL;
+	struct ast_format *fmt = NULL;
+	const char *engine_name;
+	AST_DECLARE_APP_ARGS(args,
+		AST_APP_ARG(destination);
+		AST_APP_ARG(options);
+	);
+	struct ast_flags opts = { 0, };
+	char *opt_args[OPT_ARG_ARRAY_SIZE];
+
+	if (ast_strlen_zero(data)) {
+		ast_log(LOG_ERROR, "Destination is required for the 'UnicastRTP' channel\n");
+		goto failure;
+	}
+	parse = ast_strdupa(data);
+	AST_NONSTANDARD_APP_ARGS(args, parse, '/');
+
+	if (ast_strlen_zero(args.destination)) {
+		ast_log(LOG_ERROR, "Destination is required for the 'UnicastRTP' channel\n");
+		goto failure;
+	}
+	if (!ast_sockaddr_parse(&address, args.destination, PARSE_PORT_REQUIRE)) {
+		ast_log(LOG_ERROR, "Destination '%s' could not be parsed\n", args.destination);
+		goto failure;
+	}
+
+	if (!ast_strlen_zero(args.options)
+		&& ast_app_parse_options(unicast_rtp_options, &opts, opt_args,
+			ast_strdupa(args.options))) {
+		ast_log(LOG_ERROR, "'UnicastRTP' channel options '%s' parse error\n",
+			args.options);
+		goto failure;
+	}
+
+	if (ast_test_flag(&opts, OPT_RTP_CODEC)
+		&& !ast_strlen_zero(opt_args[OPT_ARG_RTP_CODEC])) {
+		fmt = ast_format_cache_get(opt_args[OPT_ARG_RTP_CODEC]);
+		if (!fmt) {
+			ast_log(LOG_ERROR, "Codec '%s' not found for sending RTP to '%s'\n",
+				opt_args[OPT_ARG_RTP_CODEC], args.destination);
+			goto failure;
+		}
+	} else {
+		fmt = ast_format_cap_get_format(cap, 0);
+		if (!fmt) {
+			ast_log(LOG_ERROR, "No codec available for sending RTP to '%s'\n",
+				args.destination);
+			goto failure;
+		}
+	}
+
+	caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!caps) {
+		goto failure;
+	}
+
+	engine_name = S_COR(ast_test_flag(&opts, OPT_RTP_ENGINE),
+		opt_args[OPT_ARG_RTP_ENGINE], "asterisk");
+
+	ast_sockaddr_copy(&local_address, &address);
+	if (ast_ouraddrfor(&address, &local_address)) {
+		ast_log(LOG_ERROR, "Could not get our address for sending media to '%s'\n",
+			args.destination);
+		goto failure;
+	}
+	instance = ast_rtp_instance_new(engine_name, NULL, &local_address, NULL);
+	if (!instance) {
+		ast_log(LOG_ERROR,
+			"Could not create %s RTP instance for sending media to '%s'\n",
+			S_OR(engine_name, "default"), args.destination);
+		goto failure;
+	}
+
+	chan = ast_channel_alloc(1, AST_STATE_DOWN, "", "", "", "", "", assignedids,
+		requestor, 0, "UnicastRTP/%s-%p", args.destination, instance);
+	if (!chan) {
+		ast_rtp_instance_destroy(instance);
+		goto failure;
+	}
+	ast_rtp_instance_set_channel_id(instance, ast_channel_uniqueid(chan));
+	ast_rtp_instance_set_remote_address(instance, &address);
+	ast_channel_set_fd(chan, 0, ast_rtp_instance_fd(instance, 0));
+
+	ast_channel_tech_set(chan, &unicast_rtp_tech);
+
+	ast_format_cap_append(caps, fmt, 0);
+	ast_channel_nativeformats_set(chan, caps);
+	ast_channel_set_writeformat(chan, fmt);
+	ast_channel_set_rawwriteformat(chan, fmt);
+	ast_channel_set_readformat(chan, fmt);
+	ast_channel_set_rawreadformat(chan, fmt);
+
+	ast_channel_tech_pvt_set(chan, instance);
+
+	pbx_builtin_setvar_helper(chan, "UNICASTRTP_LOCAL_ADDRESS",
+		ast_sockaddr_stringify_addr(&local_address));
+	ast_rtp_instance_get_local_address(instance, &local_address);
+	pbx_builtin_setvar_helper(chan, "UNICASTRTP_LOCAL_PORT",
+		ast_sockaddr_stringify_port(&local_address));
+
+	ast_channel_unlock(chan);
+
+	ao2_ref(fmt, -1);
+	ao2_ref(caps, -1);
+
+	return chan;
+
+failure:
+	ao2_cleanup(fmt);
+	ao2_cleanup(caps);
+	*cause = AST_CAUSE_FAILURE;
+	return NULL;
+}
+
+/*! \brief Function called when our module is unloaded */
+static int unload_module(void)
+{
+	ast_channel_unregister(&multicast_rtp_tech);
+	ao2_cleanup(multicast_rtp_tech.capabilities);
+	multicast_rtp_tech.capabilities = NULL;
+
+	ast_channel_unregister(&unicast_rtp_tech);
+	ao2_cleanup(unicast_rtp_tech.capabilities);
+	unicast_rtp_tech.capabilities = NULL;
+
+	return 0;
+}
+
+/*! \brief Function called when our module is loaded */
+static int load_module(void)
+{
+	if (!(multicast_rtp_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+	ast_format_cap_append_by_type(multicast_rtp_tech.capabilities, AST_MEDIA_TYPE_UNKNOWN);
+	if (ast_channel_register(&multicast_rtp_tech)) {
+		ast_log(LOG_ERROR, "Unable to register channel class 'MulticastRTP'\n");
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	if (!(unicast_rtp_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
+	ast_format_cap_append_by_type(unicast_rtp_tech.capabilities, AST_MEDIA_TYPE_UNKNOWN);
+	if (ast_channel_register(&unicast_rtp_tech)) {
+		ast_log(LOG_ERROR, "Unable to register channel class 'UnicastRTP'\n");
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "RTP Media Channel",
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DRIVER,
+);
diff -urpN asterisk-13.9.1/channels/chan_sip.c asterisk-13.17.0/channels/chan_sip.c
--- asterisk-13.9.1/channels/chan_sip.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_sip.c	2017-07-12 13:12:08.000000000 +0200
@@ -568,11 +568,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			for all of the sip peers will be retrieved.</para>
 		</description>
 	</manager>
-	<info name="SIPMessageFromInfo" language="en_US" tech="SIP">
+	<info name="MessageFromInfo" language="en_US" tech="SIP">
 		<para>The <literal>from</literal> parameter can be a configured peer name
 		or in the form of "display-name" &lt;URI&gt;.</para>
 	</info>
-	<info name="SIPMessageToInfo" language="en_US" tech="SIP">
+	<info name="MessageToInfo" language="en_US" tech="SIP">
 		<para>Specifying a prefix of <literal>sip:</literal> will send the
 		message as a SIP MESSAGE request.</para>
 	</info>
@@ -609,6 +609,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 	</managerEvent>
  ***/
 
+static int log_level = -1;
+
 static int min_expiry = DEFAULT_MIN_EXPIRY;        /*!< Minimum accepted registration time */
 static int max_expiry = DEFAULT_MAX_EXPIRY;        /*!< Maximum accepted registration time */
 static int default_expiry = DEFAULT_DEFAULT_EXPIRY;
@@ -1208,7 +1210,8 @@ static int process_sdp(struct sip_pvt *p
 static int process_sdp_o(const char *o, struct sip_pvt *p);
 static int process_sdp_c(const char *c, struct ast_sockaddr *addr);
 static int process_sdp_a_sendonly(const char *a, int *sendonly);
-static int process_sdp_a_ice(const char *a, struct sip_pvt *p, struct ast_rtp_instance *instance);
+static int process_sdp_a_ice(const char *a, struct sip_pvt *p, struct ast_rtp_instance *instance, int rtcp_mux);
+static int process_sdp_a_rtcp_mux(const char *a, struct sip_pvt *p, int *requested);
 static int process_sdp_a_dtls(const char *a, struct sip_pvt *p, struct ast_rtp_instance *instance);
 static int process_sdp_a_audio(const char *a, struct sip_pvt *p, struct ast_rtp_codecs *newaudiortp, int *last_rtpmap_codec);
 static int process_sdp_a_video(const char *a, struct sip_pvt *p, struct ast_rtp_codecs *newvideortp, int *last_rtpmap_codec);
@@ -1277,6 +1280,7 @@ static void mwi_event_cb(void *, struct
 static void network_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message);
 static void acl_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message);
 static void sip_keepalive_all_peers(void);
+#define peer_in_destruction(peer) (ao2_ref(peer, 0) == 0)
 
 /*--- Applications, functions, CLI and manager command helpers */
 static const char *sip_nat_mode(const struct sip_pvt *p);
@@ -1477,7 +1481,8 @@ static int handle_response_register(stru
 static void handle_response(struct sip_pvt *p, int resp, const char *rest, struct sip_request *req, uint32_t seqno);
 
 /*------ SRTP Support -------- */
-static int process_crypto(struct sip_pvt *p, struct ast_rtp_instance *rtp, struct ast_sdp_srtp **srtp, const char *a);
+static int process_crypto(struct sip_pvt *p, struct ast_rtp_instance *rtp, struct ast_sdp_srtp **srtp,
+		const char *a, int secure_transport);
 
 /*------ T38 Support --------- */
 static int transmit_response_with_t38_sdp(struct sip_pvt *p, char *msg, struct sip_request *req, int retrans);
@@ -1772,7 +1777,7 @@ static void destroy_escs(void)
 {
 	int i;
 	for (i = 0; i < ARRAY_LEN(event_state_compositors); i++) {
-		ao2_cleanup(event_state_compositors[i].compositor);
+		ao2_replace(event_state_compositors[i].compositor, NULL);
 	}
 }
 
@@ -2501,7 +2506,7 @@ static void sip_threadinfo_destructor(vo
 	struct sip_threadinfo *th = obj;
 	struct tcptls_packet *packet;
 
-	if (th->alert_pipe[1] > -1) {
+	if (th->alert_pipe[0] > -1) {
 		close(th->alert_pipe[0]);
 	}
 	if (th->alert_pipe[1] > -1) {
@@ -2957,6 +2962,7 @@ static void *_sip_tcp_helper_thread(stru
 		if (!(me = sip_threadinfo_create(tcptls_session, tcptls_session->ssl ? AST_TRANSPORT_TLS : AST_TRANSPORT_TCP))) {
 			goto cleanup;
 		}
+		me->threadid = pthread_self();
 		ao2_t_ref(me, +1, "Adding threadinfo ref for tcp_helper_thread");
 	} else {
 		struct sip_threadinfo tmp = {
@@ -2964,8 +2970,13 @@ static void *_sip_tcp_helper_thread(stru
 		};
 
 		if ((!(ca = tcptls_session->parent)) ||
-			(!(me = ao2_t_find(threadt, &tmp, OBJ_POINTER, "ao2_find, getting sip_threadinfo in tcp helper thread"))) ||
-			(!(tcptls_session = ast_tcptls_client_start(tcptls_session)))) {
+			(!(me = ao2_t_find(threadt, &tmp, OBJ_POINTER, "ao2_find, getting sip_threadinfo in tcp helper thread")))) {
+			goto cleanup;
+		}
+
+		me->threadid = pthread_self();
+
+		if (!(tcptls_session = ast_tcptls_client_start(tcptls_session))) {
 			goto cleanup;
 		}
 	}
@@ -2976,7 +2987,6 @@ static void *_sip_tcp_helper_thread(stru
 		goto cleanup;
 	}
 
-	me->threadid = pthread_self();
 	ast_debug(2, "Starting thread for %s server\n", tcptls_session->ssl ? "TLS" : "TCP");
 
 	/* set up pollfd to watch for reads on both the socket and the alert_pipe */
@@ -3837,7 +3847,7 @@ static void ast_sip_ouraddrfor(const str
 	    (!sip_cfg.matchexternaddrlocally || !ast_apply_ha(localaddr, us)) ) {
 		/* if we used externhost, see if it is time to refresh the info */
 		if (externexpire && time(NULL) >= externexpire) {
-			if (ast_sockaddr_resolve_first(&externaddr, externhost, 0)) {
+			if (ast_sockaddr_resolve_first_af(&externaddr, externhost, 0, AST_AF_INET)) {
 				ast_log(LOG_NOTICE, "Warning: Re-lookup of '%s' failed!\n", externhost);
 			}
 			externexpire = time(NULL) + externrefresh;
@@ -3927,6 +3937,9 @@ static __attribute__((format(printf, 2,
 	}
 	AST_LIST_INSERT_TAIL(p->history, hist, list);
 	p->history_entries++;
+	if (log_level != -1) {
+		ast_log_dynamic_level(log_level, "%s\n", buf);
+	}
 }
 
 /*! \brief Append to SIP dialog history with arg list  */
@@ -4200,19 +4213,6 @@ static enum sip_result __sip_reliable_xm
 		p->pendinginvite = seqno;
 	}
 
-	/* If the transport is something reliable (TCP or TLS) then don't really send this reliably */
-	/* I removed the code from retrans_pkt that does the same thing so it doesn't get loaded into the scheduler */
-	/*! \todo According to the RFC some packets need to be retransmitted even if its TCP, so this needs to get revisited */
-	if (!(p->socket.type & AST_TRANSPORT_UDP)) {
-		xmitres = __sip_xmit(p, data);	/* Send packet */
-		if (xmitres == XMIT_ERROR) {	/* Serious network trouble, no need to try again */
-			append_history(p, "XmitErr", "%s", fatal ? "(Critical)" : "(Non-critical)");
-			return AST_FAILURE;
-		} else {
-			return AST_SUCCESS;
-		}
-	}
-
 	pkt = ao2_alloc_options(sizeof(*pkt), sip_pkt_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);
 	if (!pkt) {
 		return AST_FAILURE;
@@ -4249,6 +4249,13 @@ static enum sip_result __sip_reliable_xm
 	pkt->time_sent = ast_tvnow(); /* time packet was sent */
 	pkt->retrans_stop_time = 64 * (pkt->timer_t1 ? pkt->timer_t1 : DEFAULT_TIMER_T1); /* time in ms after pkt->time_sent to stop retransmission */
 
+	if (!(p->socket.type & AST_TRANSPORT_UDP)) {
+		/* TCP does not need retransmits as that's built in, but with
+		 * retrans_stop set, we must give it the full timer_H treatment */
+		pkt->retrans_stop = 1;
+		siptimer_a = pkt->retrans_stop_time;
+	}
+
 	/* Schedule retransmission */
 	ao2_t_ref(pkt, +1, "Schedule packet retransmission");
 	pkt->retransid = ast_sched_add_variable(sched, siptimer_a, retrans_pkt, pkt, 1);
@@ -5202,13 +5209,24 @@ static void destroy_mailbox(struct sip_m
 	ast_free(mailbox);
 }
 
+#define REMOVE_MAILBOX_WITH_LOCKED_PEER(__peer) \
+({\
+	struct sip_mailbox *__mailbox;\
+	ao2_lock(__peer);\
+	__mailbox = AST_LIST_REMOVE_HEAD(&(__peer->mailboxes), entry);\
+	ao2_unlock(__peer);\
+	__mailbox;\
+})
+
 /*! Destroy all peer-related mailbox subscriptions */
 static void clear_peer_mailboxes(struct sip_peer *peer)
 {
 	struct sip_mailbox *mailbox;
 
-	while ((mailbox = AST_LIST_REMOVE_HEAD(&peer->mailboxes, entry)))
+	/* Lock the peer while accessing/updating the linked list but NOT while destroying the mailbox */
+	while ((mailbox = REMOVE_MAILBOX_WITH_LOCKED_PEER(peer))) {
 		destroy_mailbox(mailbox);
+	}
 }
 
 static void sip_destroy_peer_fn(void *peer)
@@ -5878,6 +5896,38 @@ static void copy_socket_data(struct sip_
 	*to_sock = *from_sock;
 }
 
+/*! Cleanup the RTP and SRTP portions of a dialog
+ *
+ * \note This procedure excludes vsrtp as it is initialized differently.
+ */
+static void dialog_clean_rtp(struct sip_pvt *p)
+{
+	if (p->rtp) {
+		ast_rtp_instance_destroy(p->rtp);
+		p->rtp = NULL;
+	}
+
+	if (p->vrtp) {
+		ast_rtp_instance_destroy(p->vrtp);
+		p->vrtp = NULL;
+	}
+
+	if (p->trtp) {
+		ast_rtp_instance_destroy(p->trtp);
+		p->trtp = NULL;
+	}
+
+	if (p->srtp) {
+		ast_sdp_srtp_destroy(p->srtp);
+		p->srtp = NULL;
+	}
+
+	if (p->tsrtp) {
+		ast_sdp_srtp_destroy(p->tsrtp);
+		p->tsrtp = NULL;
+	}
+}
+
 /*! \brief Initialize DTLS-SRTP support on an RTP instance */
 static int dialog_initialize_dtls_srtp(const struct sip_pvt *dialog, struct ast_rtp_instance *rtp, struct ast_sdp_srtp **srtp)
 {
@@ -5925,6 +5975,9 @@ static int dialog_initialize_rtp(struct
 		return 0;
 	}
 
+	/* Make sure previous RTP instances/FD's do not leak */
+	dialog_clean_rtp(dialog);
+
 	ast_sockaddr_copy(&bindaddr_tmp, &bindaddr);
 	if (!(dialog->rtp = ast_rtp_instance_new(dialog->engine, sched, &bindaddr_tmp, NULL))) {
 		return -1;
@@ -5956,7 +6009,7 @@ static int dialog_initialize_rtp(struct
 		ast_rtp_instance_set_hold_timeout(dialog->vrtp, dialog->rtpholdtimeout);
 		ast_rtp_instance_set_keepalive(dialog->vrtp, dialog->rtpkeepalive);
 
-		ast_rtp_instance_set_prop(dialog->vrtp, AST_RTP_PROPERTY_RTCP, 1);
+		ast_rtp_instance_set_prop(dialog->vrtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_STANDARD);
 		ast_rtp_instance_set_qos(dialog->vrtp, global_tos_video, global_cos_video, "SIP VIDEO");
 	}
 
@@ -5976,14 +6029,14 @@ static int dialog_initialize_rtp(struct
 		/* Do not timeout text as its not constant*/
 		ast_rtp_instance_set_keepalive(dialog->trtp, dialog->rtpkeepalive);
 
-		ast_rtp_instance_set_prop(dialog->trtp, AST_RTP_PROPERTY_RTCP, 1);
+		ast_rtp_instance_set_prop(dialog->trtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_STANDARD);
 	}
 
 	ast_rtp_instance_set_timeout(dialog->rtp, dialog->rtptimeout);
 	ast_rtp_instance_set_hold_timeout(dialog->rtp, dialog->rtpholdtimeout);
 	ast_rtp_instance_set_keepalive(dialog->rtp, dialog->rtpkeepalive);
 
-	ast_rtp_instance_set_prop(dialog->rtp, AST_RTP_PROPERTY_RTCP, 1);
+	ast_rtp_instance_set_prop(dialog->rtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_STANDARD);
 	ast_rtp_instance_set_prop(dialog->rtp, AST_RTP_PROPERTY_DTMF, ast_test_flag(&dialog->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833);
 	ast_rtp_instance_set_prop(dialog->rtp, AST_RTP_PROPERTY_DTMF_COMPENSATE, ast_test_flag(&dialog->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
 
@@ -6601,18 +6654,10 @@ static void sip_pvt_dtor(void *vdoomed)
 		ast_free(p->notify);
 		p->notify = NULL;
 	}
-	if (p->rtp) {
-		ast_rtp_instance_destroy(p->rtp);
-		p->rtp = NULL;
-	}
-	if (p->vrtp) {
-		ast_rtp_instance_destroy(p->vrtp);
-		p->vrtp = NULL;
-	}
-	if (p->trtp) {
-		ast_rtp_instance_destroy(p->trtp);
-		p->trtp = NULL;
-	}
+
+	/* Free RTP and SRTP instances */
+	dialog_clean_rtp(p);
+
 	if (p->udptl) {
 		ast_udptl_destroy(p->udptl);
 		p->udptl = NULL;
@@ -6645,21 +6690,11 @@ static void sip_pvt_dtor(void *vdoomed)
 
 	destroy_msg_headers(p);
 
-	if (p->srtp) {
-		ast_sdp_srtp_destroy(p->srtp);
-		p->srtp = NULL;
-	}
-
 	if (p->vsrtp) {
 		ast_sdp_srtp_destroy(p->vsrtp);
 		p->vsrtp = NULL;
 	}
 
-	if (p->tsrtp) {
-		ast_sdp_srtp_destroy(p->tsrtp);
-		p->tsrtp = NULL;
-	}
-
 	if (p->directmediaacl) {
 		p->directmediaacl = ast_free_acl_list(p->directmediaacl);
 	}
@@ -6858,10 +6893,9 @@ static int update_call_counter(struct si
 		ast_log(LOG_ERROR, "update_call_counter(%s, %d) called with no event!\n", name, event);
 	}
 
-	if (p) {
-		ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", p->name);
-		sip_unref_peer(p, "update_call_counter: sip_unref_peer from call counter");
-	}
+	ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", p->name);
+	sip_unref_peer(p, "update_call_counter: sip_unref_peer from call counter");
+
 	return 0;
 }
 
@@ -7343,6 +7377,12 @@ static void try_suggested_sip_codec(stru
 
 		ao2_ref(fmt, -1);
 	}
+
+	/* The original joint formats may have contained negotiated parameters (fmtp)
+	 * like the Opus Codec or iLBC 20. The cached formats contain the default
+	 * parameters, which could be different than the negotiated (joint) result. */
+	ast_format_cap_replace_from_cap(p->jointcaps, original_jointcaps, AST_MEDIA_TYPE_UNKNOWN);
+
 	ao2_ref(original_jointcaps, -1);
 	return;
  }
@@ -7665,7 +7705,8 @@ static int interpret_t38_parameters(stru
 			ast_udptl_set_local_max_ifp(p->udptl, p->t38.our_parms.max_ifp);
 			change_t38_state(p, T38_ENABLED);
 			transmit_response_with_t38_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
-		} else if (p->t38.state != T38_ENABLED) {
+		} else if ((p->t38.state != T38_ENABLED) || ((p->t38.state == T38_ENABLED) &&
+				(parameters->request_response == AST_T38_REQUEST_NEGOTIATE))) {
 			p->t38.our_parms = *parameters;
 			ast_udptl_set_local_max_ifp(p->udptl, p->t38.our_parms.max_ifp);
 			change_t38_state(p, T38_LOCAL_REINVITE);
@@ -7714,6 +7755,15 @@ static int interpret_t38_parameters(stru
 	return res;
 }
 
+enum sip_media_fds {
+	SIP_AUDIO_RTP_FD,
+	SIP_AUDIO_RTCP_FD,
+	SIP_VIDEO_RTP_FD,
+	SIP_VIDEO_RTCP_FD,
+	SIP_TEXT_RTP_FD,
+	SIP_UDPTL_FD,
+};
+
 /*!
  * \internal
  * \brief Create and initialize UDPTL for the specified dialog
@@ -7742,7 +7792,7 @@ static int initialize_udptl(struct sip_p
 	/* T38 can be supported by this dialog, create it and set the derived properties */
 	if ((p->udptl = ast_udptl_new_with_bindaddr(sched, io, 0, &bindaddr))) {
 		if (p->owner) {
-			ast_channel_set_fd(p->owner, 5, ast_udptl_fd(p->udptl));
+			ast_channel_set_fd(p->owner, SIP_UDPTL_FD, ast_udptl_fd(p->udptl));
 		}
 
 		ast_udptl_setqos(p->udptl, global_tos_audio, global_cos_audio);
@@ -8103,7 +8153,9 @@ static struct ast_channel *sip_new(struc
 		if (!fmt) {
 			ast_log(LOG_WARNING, "No compatible formats could be found for %s\n", ast_channel_name(tmp));
 			ao2_ref(caps, -1);
-			tmp = ast_channel_unref(tmp);
+			ast_channel_stage_snapshot_done(tmp);
+			ast_channel_unlock(tmp);
+			ast_hangup(tmp);
 			return NULL;
 		}
 	}
@@ -8123,12 +8175,17 @@ static struct ast_channel *sip_new(struc
 	   We also check for vrtp. If it's not there, we are not allowed do any video anyway.
 	 */
 	if (i->vrtp) {
-		if (ast_test_flag(&i->flags[1], SIP_PAGE2_VIDEOSUPPORT))
+		if (ast_test_flag(&i->flags[1], SIP_PAGE2_VIDEOSUPPORT_ALWAYS))
 			needvideo = 1;
 		else if (ast_format_cap_count(i->prefcaps))
 			needvideo = ast_format_cap_has_type(i->prefcaps, AST_MEDIA_TYPE_VIDEO);	/* Outbound call */
 		else
 			needvideo = ast_format_cap_has_type(i->jointcaps, AST_MEDIA_TYPE_VIDEO);	/* Inbound call */
+
+		if (!needvideo) {
+			ast_rtp_instance_destroy(i->vrtp);
+			i->vrtp = NULL;
+		}
 	}
 
 	if (i->trtp) {
@@ -8161,20 +8218,28 @@ static struct ast_channel *sip_new(struc
 	 * UDPTL is created as needed in the lifetime of a dialog, its file
 	 * descriptor is set in initialize_udptl */
 	if (i->rtp) {
-		ast_channel_set_fd(tmp, 0, ast_rtp_instance_fd(i->rtp, 0));
-		ast_channel_set_fd(tmp, 1, ast_rtp_instance_fd(i->rtp, 1));
+		ast_channel_set_fd(tmp, SIP_AUDIO_RTP_FD, ast_rtp_instance_fd(i->rtp, 0));
+		if (ast_test_flag(&i->flags[2], SIP_PAGE3_RTCP_MUX)) {
+			ast_channel_set_fd(tmp, SIP_AUDIO_RTCP_FD, -1);
+		} else {
+			ast_channel_set_fd(tmp, SIP_AUDIO_RTCP_FD, ast_rtp_instance_fd(i->rtp, 1));
+		}
 		ast_rtp_instance_set_write_format(i->rtp, fmt);
 		ast_rtp_instance_set_read_format(i->rtp, fmt);
 	}
 	if (needvideo && i->vrtp) {
-		ast_channel_set_fd(tmp, 2, ast_rtp_instance_fd(i->vrtp, 0));
-		ast_channel_set_fd(tmp, 3, ast_rtp_instance_fd(i->vrtp, 1));
+		ast_channel_set_fd(tmp, SIP_VIDEO_RTP_FD, ast_rtp_instance_fd(i->vrtp, 0));
+		if (ast_test_flag(&i->flags[2], SIP_PAGE3_RTCP_MUX)) {
+			ast_channel_set_fd(tmp, SIP_VIDEO_RTCP_FD, -1);
+		} else {
+			ast_channel_set_fd(tmp, SIP_VIDEO_RTCP_FD, ast_rtp_instance_fd(i->vrtp, 1));
+		}
 	}
 	if (needtext && i->trtp) {
-		ast_channel_set_fd(tmp, 4, ast_rtp_instance_fd(i->trtp, 0));
+		ast_channel_set_fd(tmp, SIP_TEXT_RTP_FD, ast_rtp_instance_fd(i->trtp, 0));
 	}
 	if (i->udptl) {
-		ast_channel_set_fd(tmp, 5, ast_udptl_fd(i->udptl));
+		ast_channel_set_fd(tmp, SIP_UDPTL_FD, ast_udptl_fd(i->udptl));
 	}
 
 	if (state == AST_STATE_RING) {
@@ -8416,8 +8481,6 @@ static const char *__get_header(const st
 	 * one afterwards.  If you shouldn't do it, what absolute idiot decided it was
 	 * a good idea to say you can do it, and if you can do it, why in the hell would.
 	 * you say you shouldn't.
-	 * Anyways, pedanticsipchecking controls whether we allow spaces before ':',
-	 * and we always allow spaces after that for compatibility.
 	 */
 	const char *sname = find_alias(name, NULL);
 	int x, len = strlen(name), slen = (sname ? 1 : 0);
@@ -8430,10 +8493,10 @@ static const char *__get_header(const st
 		if (match || smatch) {
 			/* skip name */
 			const char *r = header + (match ? len : slen );
-			if (sip_cfg.pedanticsipchecking) {
-				r = ast_skip_blanks(r);
+			/* HCOLON has optional SP/HTAB; skip past those */
+			while (*r == ' ' || *r == '\t') {
+				++r;
 			}
-
 			if (*r == ':') {
 				*start = x+1;
 				return ast_skip_blanks(r+1);
@@ -8604,29 +8667,31 @@ static struct ast_frame *sip_read(struct
 	if (faxdetected && ast_test_flag(&p->flags[1], SIP_PAGE2_FAX_DETECT_CNG)) {
 		if (strcmp(ast_channel_exten(ast), "fax")) {
 			const char *target_context = S_OR(ast_channel_macrocontext(ast), ast_channel_context(ast));
-			/* We need to unlock 'ast' here because
+			/*
+			 * We need to unlock 'ast' here because
 			 * ast_exists_extension has the potential to start and
 			 * stop an autoservice on the channel. Such action is
 			 * prone to deadlock if the channel is locked.
+			 *
+			 * ast_async_goto() has its own restriction on not holding
+			 * the channel lock.
 			 */
 			sip_pvt_unlock(p);
 			ast_channel_unlock(ast);
+			ast_frfree(fr);
+			fr = &ast_null_frame;
 			if (ast_exists_extension(ast, target_context, "fax", 1,
 				S_COR(ast_channel_caller(ast)->id.number.valid, ast_channel_caller(ast)->id.number.str, NULL))) {
-				ast_channel_lock(ast);
-				sip_pvt_lock(p);
 				ast_verb(2, "Redirecting '%s' to fax extension due to CNG detection\n", ast_channel_name(ast));
 				pbx_builtin_setvar_helper(ast, "FAXEXTEN", ast_channel_exten(ast));
 				if (ast_async_goto(ast, target_context, "fax", 1)) {
 					ast_log(LOG_NOTICE, "Failed to async goto '%s' into fax of '%s'\n", ast_channel_name(ast), target_context);
 				}
-				ast_frfree(fr);
-				fr = &ast_null_frame;
 			} else {
-				ast_channel_lock(ast);
-				sip_pvt_lock(p);
 				ast_log(LOG_NOTICE, "FAX CNG detected but no fax extension\n");
 			}
+			ast_channel_lock(ast);
+			sip_pvt_lock(p);
 		}
 	}
 
@@ -10043,6 +10108,60 @@ static int has_media_stream(struct sip_p
 	return 0;
 }
 
+static void configure_rtcp(struct sip_pvt *p, struct ast_rtp_instance *instance, int which, int remote_rtcp_mux)
+{
+	int local_rtcp_mux = ast_test_flag(&p->flags[2], SIP_PAGE3_RTCP_MUX);
+	int fd = -1;
+
+	if (local_rtcp_mux && remote_rtcp_mux) {
+		ast_rtp_instance_set_prop(instance, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_MUX);
+	} else {
+		ast_rtp_instance_set_prop(instance, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_STANDARD);
+		fd = ast_rtp_instance_fd(instance, 1);
+	}
+
+	if (p->owner) {
+		ast_channel_set_fd(p->owner, which, fd);
+	}
+}
+
+static void set_ice_components(struct sip_pvt *p, struct ast_rtp_instance *instance, int remote_rtcp_mux)
+{
+	struct ast_rtp_engine_ice *ice;
+	int local_rtcp_mux = ast_test_flag(&p->flags[2], SIP_PAGE3_RTCP_MUX);
+
+	ice = ast_rtp_instance_get_ice(instance);
+	if (!ice) {
+		return;
+	}
+
+	if (local_rtcp_mux && remote_rtcp_mux) {
+		/* We both support RTCP mux. Only one ICE component necessary */
+		ice->change_components(instance, 1);
+	} else {
+		/* They either don't support RTCP mux or we don't know if they do yet. */
+		ice->change_components(instance, 2);
+	}
+}
+
+static int has_media_level_attribute(int start, struct sip_request *req, const char *attr)
+{
+	int next = start;
+	char type;
+	const char *value;
+
+	/* We don't care about the return result here */
+	get_sdp_iterate(&next, req, "m");
+
+	while ((type = get_sdp_line(&start, next, req, &value)) != '\0') {
+		if (type == 'a' && !strcasecmp(value, attr)) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
 /*! \brief Process SIP SDP offer, select formats and activate media channels
 	If offer is rejected, we will not change any properties of the call
  	Return 0 on success, a negative value on errors.
@@ -10101,6 +10220,10 @@ static int process_sdp(struct sip_pvt *p
 	int secure_audio = FALSE;
 	int secure_video = FALSE;
 
+	/* RTCP Multiplexing */
+	int remote_rtcp_mux_audio = FALSE;
+	int remote_rtcp_mux_video = FALSE;
+
 	/* Others */
 	int sendonly = -1;
 	unsigned int numberofports;
@@ -10181,13 +10304,13 @@ static int process_sdp(struct sip_pvt *p
 			else if (process_sdp_a_image(value, p))
 				processed = TRUE;
 
-			if (process_sdp_a_ice(value, p, p->rtp)) {
+			if (process_sdp_a_ice(value, p, p->rtp, 0)) {
 				processed = TRUE;
 			}
-			if (process_sdp_a_ice(value, p, p->vrtp)) {
+			if (process_sdp_a_ice(value, p, p->vrtp, 0)) {
 				processed = TRUE;
 			}
-			if (process_sdp_a_ice(value, p, p->trtp)) {
+			if (process_sdp_a_ice(value, p, p->trtp, 0)) {
 				processed = TRUE;
 			}
 
@@ -10227,6 +10350,7 @@ static int process_sdp(struct sip_pvt *p
 		int image = FALSE;
 		int text = FALSE;
 		int processed_crypto = FALSE;
+		int rtcp_mux_offered = 0;
 		char protocol[18] = {0,};
 		unsigned int x;
 		struct ast_rtp_engine_dtls *dtls;
@@ -10246,6 +10370,9 @@ static int process_sdp(struct sip_pvt *p
 		AST_LIST_INSERT_TAIL(&p->offered_media, offer, next);
 		offer->type = SDP_UNKNOWN;
 
+		/* We need to check for this ahead of time */
+		rtcp_mux_offered = has_media_level_attribute(iterator, req, "rtcp-mux");
+
 		/* Check for 'audio' media offer */
 		if (strncmp(m, "audio ", 6) == 0) {
 			if ((sscanf(m, "audio %30u/%30u %17s %n", &x, &numberofports, protocol, &len) == 3 && len > 0) ||
@@ -10612,7 +10739,7 @@ static int process_sdp(struct sip_pvt *p
 			case 'a':
 				/* Audio specific scanning */
 				if (audio) {
-					if (process_sdp_a_ice(value, p, p->rtp)) {
+					if (process_sdp_a_ice(value, p, p->rtp, rtcp_mux_offered)) {
 						processed = TRUE;
 					} else if (process_sdp_a_dtls(value, p, p->rtp)) {
 						processed_crypto = TRUE;
@@ -10622,16 +10749,18 @@ static int process_sdp(struct sip_pvt *p
 						}
 					} else if (process_sdp_a_sendonly(value, &sendonly)) {
 						processed = TRUE;
-					} else if (!processed_crypto && process_crypto(p, p->rtp, &p->srtp, value)) {
+					} else if (!processed_crypto && process_crypto(p, p->rtp, &p->srtp, value, secure_audio)) {
 						processed_crypto = TRUE;
 						processed = TRUE;
 					} else if (process_sdp_a_audio(value, p, &newaudiortp, &last_rtpmap_codec)) {
 						processed = TRUE;
+					} else if (process_sdp_a_rtcp_mux(value, p, &remote_rtcp_mux_audio)) {
+						processed = TRUE;
 					}
 				}
 				/* Video specific scanning */
 				else if (video) {
-					if (process_sdp_a_ice(value, p, p->vrtp)) {
+					if (process_sdp_a_ice(value, p, p->vrtp, rtcp_mux_offered)) {
 						processed = TRUE;
 					} else if (process_sdp_a_dtls(value, p, p->vrtp)) {
 						processed_crypto = TRUE;
@@ -10639,20 +10768,22 @@ static int process_sdp(struct sip_pvt *p
 						if (p->vsrtp) {
 							ast_set_flag(p->vsrtp, AST_SRTP_CRYPTO_OFFER_OK);
 						}
-					} else if (!processed_crypto && process_crypto(p, p->vrtp, &p->vsrtp, value)) {
+					} else if (!processed_crypto && process_crypto(p, p->vrtp, &p->vsrtp, value, secure_video)) {
 						processed_crypto = TRUE;
 						processed = TRUE;
 					} else if (process_sdp_a_video(value, p, &newvideortp, &last_rtpmap_codec)) {
 						processed = TRUE;
+					} else if (process_sdp_a_rtcp_mux(value, p, &remote_rtcp_mux_video)) {
+						processed = TRUE;
 					}
 				}
 				/* Text (T.140) specific scanning */
 				else if (text) {
-					if (process_sdp_a_ice(value, p, p->trtp)) {
+					if (process_sdp_a_ice(value, p, p->trtp, rtcp_mux_offered)) {
 						processed = TRUE;
 					} else if (process_sdp_a_text(value, p, &newtextrtp, red_fmtp, &red_num_gen, red_data_pt, &last_rtpmap_codec)) {
 						processed = TRUE;
-					} else if (!processed_crypto && process_crypto(p, p->trtp, &p->tsrtp, value)) {
+					} else if (!processed_crypto && process_crypto(p, p->trtp, &p->tsrtp, value, 1)) {
 						processed_crypto = TRUE;
 						processed = TRUE;
 					}
@@ -10765,6 +10896,9 @@ static int process_sdp(struct sip_pvt *p
 		struct ast_str *vpeer_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
 		struct ast_str *tpeer_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
 		struct ast_str *joint_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
+		struct ast_str *s1 = ast_str_alloca(SIPBUFSIZE);
+		struct ast_str *s2 = ast_str_alloca(SIPBUFSIZE);
+		struct ast_str *s3 = ast_str_alloca(SIPBUFSIZE);
 
 		ast_verbose("Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n",
 			    ast_format_cap_get_names(p->caps, &cap_buf),
@@ -10772,11 +10906,6 @@ static int process_sdp(struct sip_pvt *p
 			    ast_format_cap_get_names(vpeercapability, &vpeer_buf),
 			    ast_format_cap_get_names(tpeercapability, &tpeer_buf),
 			    ast_format_cap_get_names(newjointcapability, &joint_buf));
-	}
-	if (debug) {
-		struct ast_str *s1 = ast_str_alloca(SIPBUFSIZE);
-		struct ast_str *s2 = ast_str_alloca(SIPBUFSIZE);
-		struct ast_str *s3 = ast_str_alloca(SIPBUFSIZE);
 
 		ast_verbose("Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n",
 			    ast_rtp_lookup_mime_multiple2(s1, NULL, p->noncodeccapability, 0, 0),
@@ -10810,6 +10939,7 @@ static int process_sdp(struct sip_pvt *p
 		if (sa && portno > 0) {
 			/* Start ICE negotiation here, only when it is response, and setting that we are conrolling agent,
 			   as we are offerer */
+			set_ice_components(p, p->rtp, remote_rtcp_mux_audio);
 			if (req->method == SIP_RESPONSE) {
 				start_ice(p->rtp, 1);
 			}
@@ -10823,11 +10953,7 @@ static int process_sdp(struct sip_pvt *p
 			ast_rtp_codecs_payloads_copy(&newaudiortp, ast_rtp_instance_get_codecs(p->rtp), p->rtp);
 			/* Ensure RTCP is enabled since it may be inactive
 			   if we're coming back from a T.38 session */
-			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, 1);
-			/* Ensure audio RTCP reads are enabled */
-			if (p->owner) {
-				ast_channel_set_fd(p->owner, 1, ast_rtp_instance_fd(p->rtp, 1));
-			}
+			configure_rtcp(p, p->rtp, SIP_AUDIO_RTCP_FD, remote_rtcp_mux_audio);
 
 			if (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO) {
 				ast_clear_flag(&p->flags[0], SIP_DTMF);
@@ -10850,10 +10976,10 @@ static int process_sdp(struct sip_pvt *p
 
 			/* Prevent audio RTCP reads */
 			if (p->owner) {
-				ast_channel_set_fd(p->owner, 1, -1);
+				ast_channel_set_fd(p->owner, SIP_AUDIO_RTCP_FD, -1);
 			}
 			/* Silence RTCP while audio RTP is inactive */
-			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, 0);
+			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_DISABLED);
 		} else {
 			ast_rtp_instance_stop(p->rtp);
 			if (debug)
@@ -10864,6 +10990,7 @@ static int process_sdp(struct sip_pvt *p
 	/* Setup video address and port */
 	if (p->vrtp) {
 		if (vsa && vportno > 0) {
+			set_ice_components(p, p->vrtp, remote_rtcp_mux_video);
 			start_ice(p->vrtp, (req->method != SIP_RESPONSE) ? 0 : 1);
 			ast_sockaddr_set_port(vsa, vportno);
 			ast_rtp_instance_set_remote_address(p->vrtp, vsa);
@@ -10872,6 +10999,7 @@ static int process_sdp(struct sip_pvt *p
 					    ast_sockaddr_stringify(vsa));
 			}
 			ast_rtp_codecs_payloads_copy(&newvideortp, ast_rtp_instance_get_codecs(p->vrtp), p->vrtp);
+			configure_rtcp(p, p->vrtp, SIP_VIDEO_RTCP_FD, remote_rtcp_mux_video);
 		} else {
 			ast_rtp_instance_stop(p->vrtp);
 			if (debug)
@@ -11163,7 +11291,7 @@ static int process_sdp_a_sendonly(const
 	return found;
 }
 
-static int process_sdp_a_ice(const char *a, struct sip_pvt *p, struct ast_rtp_instance *instance)
+static int process_sdp_a_ice(const char *a, struct sip_pvt *p, struct ast_rtp_instance *instance, int rtcp_mux_offered)
 {
 	struct ast_rtp_engine_ice *ice;
 	int found = FALSE;
@@ -11183,6 +11311,12 @@ static int process_sdp_a_ice(const char
 		found = TRUE;
 	} else if (sscanf(a, "candidate: %31s %30u %3s %30u %23s %30u typ %5s %*s %23s %*s %30u", foundation, &candidate.id, transport, (unsigned *)&candidate.priority,
 			  address, &port, cand_type, relay_address, &relay_port) >= 7) {
+
+		if (rtcp_mux_offered && ast_test_flag(&p->flags[2], SIP_PAGE3_RTCP_MUX) && candidate.id > 1) {
+			/* If we support RTCP-MUX and they offered it, don't consider RTCP candidates */
+			return TRUE;
+		}
+
 		candidate.foundation = foundation;
 		candidate.transport = transport;
 
@@ -11218,6 +11352,18 @@ static int process_sdp_a_ice(const char
 	return found;
 }
 
+static int process_sdp_a_rtcp_mux(const char *a, struct sip_pvt *p, int *requested)
+{
+	int found = FALSE;
+
+	if (!strncasecmp(a, "rtcp-mux", 8)) {
+		*requested = TRUE;
+		found = TRUE;
+	}
+
+	return found;
+}
+
 static int process_sdp_a_dtls(const char *a, struct sip_pvt *p, struct ast_rtp_instance *instance)
 {
 	struct ast_rtp_engine_dtls *dtls;
@@ -11332,25 +11478,7 @@ static int process_sdp_a_audio(const cha
 				ast_rtp_codecs_payloads_unset(newaudiortp, NULL, codec);
 			}
 
-			if (ast_format_cmp(format, ast_format_siren7) == AST_FORMAT_CMP_EQUAL) {
-				if (sscanf(fmtp_string, "bitrate=%30u", &bit_rate) == 1) {
-					if (bit_rate != 32000) {
-						ast_log(LOG_WARNING, "Got Siren7 offer at %u bps, but only 32000 bps supported; ignoring.\n", bit_rate);
-						ast_rtp_codecs_payloads_unset(newaudiortp, NULL, codec);
-					} else {
-						found = TRUE;
-					}
-				}
-			} else if (ast_format_cmp(format, ast_format_siren14) == AST_FORMAT_CMP_EQUAL) {
-				if (sscanf(fmtp_string, "bitrate=%30u", &bit_rate) == 1) {
-					if (bit_rate != 48000) {
-						ast_log(LOG_WARNING, "Got Siren14 offer at %u bps, but only 48000 bps supported; ignoring.\n", bit_rate);
-						ast_rtp_codecs_payloads_unset(newaudiortp, NULL, codec);
-					} else {
-						found = TRUE;
-					}
-				}
-			} else if (ast_format_cmp(format, ast_format_g719) == AST_FORMAT_CMP_EQUAL) {
+			if (ast_format_cmp(format, ast_format_g719) == AST_FORMAT_CMP_EQUAL) {
 				if (sscanf(fmtp_string, "bitrate=%30u", &bit_rate) == 1) {
 					if (bit_rate != 64000) {
 						ast_log(LOG_WARNING, "Got G.719 offer at %u bps, but only 64000 bps supported; ignoring.\n", bit_rate);
@@ -13003,18 +13131,9 @@ static void add_codec_to_sdp(const struc
 
 	framing = ast_format_cap_get_format_framing(p->caps, format);
 
-	if (ast_format_cmp(format, ast_format_g729) == AST_FORMAT_CMP_EQUAL) {
-		/* Indicate that we don't support VAD (G.729 annex B) */
-		ast_str_append(a_buf, 0, "a=fmtp:%d annexb=no\r\n", rtp_code);
-	} else if (ast_format_cmp(format, ast_format_g723) == AST_FORMAT_CMP_EQUAL) {
+	if (ast_format_cmp(format, ast_format_g723) == AST_FORMAT_CMP_EQUAL) {
 		/* Indicate that we don't support VAD (G.723.1 annex A) */
 		ast_str_append(a_buf, 0, "a=fmtp:%d annexa=no\r\n", rtp_code);
-	} else if (ast_format_cmp(format, ast_format_siren7) == AST_FORMAT_CMP_EQUAL) {
-		/* Indicate that we only expect 32Kbps */
-		ast_str_append(a_buf, 0, "a=fmtp:%d bitrate=32000\r\n", rtp_code);
-	} else if (ast_format_cmp(format, ast_format_siren14) == AST_FORMAT_CMP_EQUAL) {
-		/* Indicate that we only expect 48Kbps */
-		ast_str_append(a_buf, 0, "a=fmtp:%d bitrate=48000\r\n", rtp_code);
 	} else if (ast_format_cmp(format, ast_format_g719) == AST_FORMAT_CMP_EQUAL) {
 		/* Indicate that we only expect 64Kbps */
 		ast_str_append(a_buf, 0, "a=fmtp:%d bitrate=64000\r\n", rtp_code);
@@ -13599,6 +13718,12 @@ static enum sip_result add_sdp(struct si
 
 			add_dtls_to_sdp(p->rtp, &a_audio);
 		}
+
+		/* If we've got rtcp-mux enabled, just unconditionally offer it in all SDPs */
+		if (ast_test_flag(&p->flags[2], SIP_PAGE3_RTCP_MUX)) {
+			ast_str_append(&a_audio, 0, "a=rtcp-mux\r\n");
+			ast_str_append(&a_video, 0, "a=rtcp-mux\r\n");
+		}
 	}
 
 	if (add_t38) {
@@ -13966,18 +14091,18 @@ static int transmit_reinvite_with_sdp(st
 	if (p->rtp) {
 		if (t38version) {
 			/* Silence RTCP while audio RTP is inactive */
-			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, 0);
+			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_DISABLED);
 			if (p->owner) {
 				/* Prevent audio RTCP reads */
-				ast_channel_set_fd(p->owner, 1, -1);
+				ast_channel_set_fd(p->owner, SIP_AUDIO_RTCP_FD, -1);
 			}
 		} else if (ast_sockaddr_isnull(&p->redirip)) {
 			/* Enable RTCP since it will be inactive if we're coming back
 			 * with this reinvite */
-			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, 1);
+			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_STANDARD);
 			if (p->owner) {
 				/* Enable audio RTCP reads */
-				ast_channel_set_fd(p->owner, 1, ast_rtp_instance_fd(p->rtp, 1));
+				ast_channel_set_fd(p->owner, SIP_AUDIO_RTCP_FD, ast_rtp_instance_fd(p->rtp, 1));
 			}
 		}
 	}
@@ -14133,6 +14258,7 @@ static void build_contact(struct sip_pvt
 	char tmp[SIPBUFSIZE];
 	char *user = ast_uri_encode(p->exten, tmp, sizeof(tmp), ast_uri_sip_user);
 	int use_sips;
+	char *transport = ast_strdupa(sip_get_transport(p->socket.type));
 
 	if (incoming) {
 		use_sips = uas_sips_contact(req);
@@ -14147,16 +14273,17 @@ static void build_contact(struct sip_pvt
 	} else {
 		ast_string_field_build(p, our_contact, "<%s:%s%s%s;transport=%s>",
 			use_sips ? "sips" : "sip", user, ast_strlen_zero(user) ? "" : "@",
-			ast_sockaddr_stringify_remote(&p->ourip), sip_get_transport(p->socket.type));
+			ast_sockaddr_stringify_remote(&p->ourip), ast_str_to_lower(transport));
 	}
 }
 
 /*! \brief Initiate new SIP request to peer/user */
 static void initreqprep(struct sip_request *req, struct sip_pvt *p, int sipmethod, const char * const explicit_uri)
 {
-	struct ast_str *invite = ast_str_alloca(256);
-	char from[256];
-	char to[256];
+#define SIPHEADER 256
+	struct ast_str *invite = ast_str_create(SIPHEADER);
+	struct ast_str *from = ast_str_create(SIPHEADER);
+	struct ast_str *to = ast_str_create(SIPHEADER);
 	char tmp_n[SIPBUFSIZE/2];	/* build a local copy of 'n' if needed */
 	char tmp_l[SIPBUFSIZE/2];	/* build a local copy of 'l' if needed */
 	const char *l = NULL;	/* XXX what is this, exactly ? */
@@ -14258,34 +14385,40 @@ static void initreqprep(struct sip_reque
 	ourport = (p->fromdomainport && (p->fromdomainport != STANDARD_SIP_PORT)) ? p->fromdomainport : ast_sockaddr_port(&p->ourip);
 
 	if (!sip_standard_port(p->socket.type, ourport)) {
-		ret = snprintf(from, sizeof(from), "<sip:%s@%s:%d>;tag=%s", tmp_l, d, ourport, p->tag);
+		ret = ast_str_set(&from, 0, "<sip:%s@%s:%d>;tag=%s", tmp_l, d, ourport, p->tag);
 	} else {
-		ret = snprintf(from, sizeof(from), "<sip:%s@%s>;tag=%s", tmp_l, d, p->tag);
+		ret = ast_str_set(&from, 0, "<sip:%s@%s>;tag=%s", tmp_l, d, p->tag);
 	}
-	if (ret < 0 || ret >= sizeof(from)) { /* a return value of size or more means that the output was truncated */
+	if (ret == AST_DYNSTR_BUILD_FAILED) {
 		/* We don't have an escape path from here... */
 		ast_log(LOG_ERROR, "The From header was truncated in call '%s'. This call setup will fail.\n", p->callid);
+		/* Make sure that the field contains something non-broken.
+		   See https://issues.asterisk.org/jira/browse/ASTERISK-26069
+		*/
+		ast_str_set(&from, 3, "<>");
+
 	}
 
 	/* If a caller id name was specified, prefix a display name, if there is enough room. */
 	if (cid_has_name || !cid_has_num) {
-		size_t written = strlen(from);
-		ssize_t left = sizeof(from) - written - 4; /* '"" \0' */
-		if (left > 0) {
-			size_t name_len;
-			if (sip_cfg.pedanticsipchecking) {
-				ast_escape_quoted(n, tmp_n, MIN(left + 1, sizeof(tmp_n)));
-				n = tmp_n;
-			}
-			name_len = strlen(n);
-			if (left < name_len) {
-				name_len = left;
-			}
-			memmove(from + name_len + 3, from, written + 1);
-			from[0] = '"';
-			memcpy(from + 1, n, name_len);
-			from[name_len + 1] = '"';
-			from[name_len + 2] = ' ';
+		size_t written = ast_str_strlen(from);
+		size_t name_len;
+		if (sip_cfg.pedanticsipchecking) {
+			ast_escape_quoted(n, tmp_n, sizeof(tmp_n));
+			n = tmp_n;
+		}
+		name_len = strlen(n);
+		ret = ast_str_make_space(&from, name_len + written + 4);
+
+		if (ret == 0) {
+			/* needed again, as ast_str_make_space coud've changed the pointer */
+			char *from_buf = ast_str_buffer(from);
+
+			memmove(from_buf + name_len + 3, from_buf, written + 1);
+			from_buf[0] = '"';
+			memcpy(from_buf + 1, n, name_len);
+			from_buf[name_len + 1] = '"';
+			from_buf[name_len + 2] = ' ';
 		}
 	}
 
@@ -14328,24 +14461,28 @@ static void initreqprep(struct sip_reque
  		/*! \todo Need to add back the VXML URL here at some point, possibly use build_string for all this junk */
  		if (!strchr(p->todnid, '@')) {
  			/* We have no domain in the dnid */
-			ret = snprintf(to, sizeof(to), "<sip:%s@%s>%s%s", p->todnid, p->tohost, ast_strlen_zero(p->theirtag) ? "" : ";tag=", p->theirtag);
+			ret = ast_str_set(&to, 0, "<sip:%s@%s>%s%s", p->todnid, p->tohost, ast_strlen_zero(p->theirtag) ? "" : ";tag=", p->theirtag);
  		} else {
-			ret = snprintf(to, sizeof(to), "<sip:%s>%s%s", p->todnid, ast_strlen_zero(p->theirtag) ? "" : ";tag=", p->theirtag);
+			ret = ast_str_set(&to, 0, "<sip:%s>%s%s", p->todnid, ast_strlen_zero(p->theirtag) ? "" : ";tag=", p->theirtag);
  		}
  	} else {
  		if (sipmethod == SIP_NOTIFY && !ast_strlen_zero(p->theirtag)) {
  			/* If this is a NOTIFY, use the From: tag in the subscribe (RFC 3265) */
-			ret = snprintf(to, sizeof(to), "<%s%s>;tag=%s", (strncasecmp(p->uri, "sip:", 4) ? "sip:" : ""), p->uri, p->theirtag);
+			ret = ast_str_set(&to, 0, "<%s%s>;tag=%s", (strncasecmp(p->uri, "sip:", 4) ? "sip:" : ""), p->uri, p->theirtag);
  		} else if (p->options && p->options->vxml_url) {
  			/* If there is a VXML URL append it to the SIP URL */
-			ret = snprintf(to, sizeof(to), "<%s>;%s", p->uri, p->options->vxml_url);
+			ret = ast_str_set(&to, 0, "<%s>;%s", p->uri, p->options->vxml_url);
  		} else {
-			ret = snprintf(to, sizeof(to), "<%s>", p->uri);
+			ret = ast_str_set(&to, 0, "<%s>", p->uri);
 		}
  	}
-	if (ret < 0 || ret >= sizeof(to)) { /* a return value of size or more means that the output was truncated */
+	if (ret == AST_DYNSTR_BUILD_FAILED) {
 		/* We don't have an escape path from here... */
 		ast_log(LOG_ERROR, "The To header was truncated in call '%s'. This call setup will fail.\n", p->callid);
+		/* Make sure that the field contains something non-broken.
+		   See https://issues.asterisk.org/jira/browse/ASTERISK-26069
+		*/
+		ast_str_set(&to, 3, "<>");
 	}
 
 	init_req(req, sipmethod, p->uri);
@@ -14360,8 +14497,8 @@ static void initreqprep(struct sip_reque
 	 */
 	add_route(req, &p->route, 0);
 
-	add_header(req, "From", from);
-	add_header(req, "To", to);
+	add_header(req, "From", ast_str_buffer(from));
+	add_header(req, "To", ast_str_buffer(to));
 	ast_string_field_set(p, exten, l);
 	build_contact(p, req, 0);
 	add_header(req, "Contact", p->our_contact);
@@ -14370,6 +14507,10 @@ static void initreqprep(struct sip_reque
 	if (!ast_strlen_zero(global_useragent)) {
 		add_header(req, "User-Agent", global_useragent);
 	}
+
+	ast_free(from);
+	ast_free(to);
+	ast_free(invite);
 }
 
 /*! \brief Add "Diversion" header to outgoing message
@@ -14528,10 +14669,12 @@ static int transmit_invite(struct sip_pv
 		add_header(&req, "Require", "replaces");
 	}
 
-	/* Add Session-Timers related headers */
-	if (st_get_mode(p, 0) == SESSION_TIMER_MODE_ORIGINATE
+	/* Add Session-Timers related headers if not already there */
+	if (ast_strlen_zero(sip_get_header(&req, "Session-Expires")) &&
+		(sipmethod == SIP_INVITE || sipmethod == SIP_UPDATE) &&
+		(st_get_mode(p, 0) == SESSION_TIMER_MODE_ORIGINATE
 		|| (st_get_mode(p, 0) == SESSION_TIMER_MODE_ACCEPT
-			&& st_get_se(p, FALSE) != DEFAULT_MIN_SE)) {
+			&& st_get_se(p, FALSE) != DEFAULT_MIN_SE))) {
 		char i2astr[10];
 
 		if (!p->stimer->st_interval) {
@@ -15788,11 +15931,12 @@ static void start_register_timeout(struc
 
 static const char *sip_sanitized_host(const char *host)
 {
-	struct ast_sockaddr addr = { { 0, 0, }, };
+	struct ast_sockaddr addr;
 
 	/* peer/sip_pvt->tohost and sip_registry->hostname should never have a port
 	 * in them, so we use PARSE_PORT_FORBID here. If this lookup fails, we return
 	 * the original host which is most likely a host name and not an IP. */
+	memset(&addr, 0, sizeof(addr));
 	if (!ast_sockaddr_parse(&addr, host, PARSE_PORT_FORBID)) {
 		return host;
 	}
@@ -16734,7 +16878,7 @@ static enum parse_register_result parse_
 	}
 
 	if ((transport_type != AST_TRANSPORT_WS) && (transport_type != AST_TRANSPORT_WSS) &&
-	    (!ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) && !ast_test_flag(&peer->flags[0], SIP_NAT_RPORT_PRESENT))) {
+	    (!ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) && !ast_test_flag(&pvt->flags[0], SIP_NAT_RPORT_PRESENT))) {
 		/* use the data provided in the Contact header for call routing */
 		ast_debug(1, "Store REGISTER's Contact header for call routing.\n");
 		/* XXX This could block for a long time XXX */
@@ -17187,21 +17331,21 @@ static void sip_peer_hold(struct sip_pvt
 /*! \brief Receive MWI events that we have subscribed to */
 static void mwi_event_cb(void *userdata, struct stasis_subscription *sub, struct stasis_message *msg)
 {
-	char *peer_name = userdata;
-	struct sip_peer *peer = sip_find_peer(peer_name, NULL, TRUE, FINDALLDEVICES, FALSE, 0);
+	struct sip_peer *peer = userdata;
 
-	if (stasis_subscription_final_message(sub, msg)) {
-		if (peer) {
-			/* configuration reloaded */
-			return;
-		}
-		ast_free(peer_name);
+	/*
+	 * peer can't be NULL here but the peer can be in the process of being
+	 * destroyed.  If it is, we don't want to send any messages.  In most cases,
+	 * the peer is actually gone and there's no sense sending NOTIFYs that will
+	 * never be answered.
+	 */
+	if (stasis_subscription_final_message(sub, msg) || peer_in_destruction(peer)) {
 		return;
 	}
-	if (peer && ast_mwi_state_type() == stasis_message_type(msg)) {
+
+	if (ast_mwi_state_type() == stasis_message_type(msg)) {
 		sip_send_mwi_to_peer(peer, 0);
 	}
-	ao2_cleanup(peer);
 }
 
 static void network_change_stasis_subscribe(void)
@@ -17669,6 +17813,10 @@ static enum check_auth_result register_v
 	if (!peer && sip_cfg.autocreatepeer != AUTOPEERS_DISABLED) {
 		/* Create peer if we have autocreate mode enabled */
 		peer = temp_peer(name);
+		if (peer && !(peer->endpoint = ast_endpoint_create("SIP", name))) {
+			ao2_t_ref(peer, -1, "failed to allocate Stasis endpoint, drop peer");
+			peer = NULL;
+		}
 		if (peer) {
 			ao2_t_link(peers, peer, "link peer into peer table");
 			if (!ast_sockaddr_isnull(&peer->addr)) {
@@ -18265,10 +18413,11 @@ static enum sip_get_dest_result get_dest
 
 	/* If this is a subscription we actually just need to see if a hint exists for the extension */
 	if (req->method == SIP_SUBSCRIBE) {
-		char hint[AST_MAX_EXTENSION];
 		int which = 0;
-		if (ast_get_hint(hint, sizeof(hint), NULL, 0, NULL, p->context, uri) ||
-		    (ast_get_hint(hint, sizeof(hint), NULL, 0, NULL, p->context, decoded_uri) && (which = 1))) {
+
+		if (ast_get_hint(NULL, 0, NULL, 0, NULL, p->context, uri)
+			|| (ast_get_hint(NULL, 0, NULL, 0, NULL, p->context, decoded_uri)
+				&& (which = 1))) {
 			if (!oreq) {
 				ast_string_field_set(p, exten, which ? decoded_uri : uri);
 			}
@@ -18344,7 +18493,7 @@ static enum sip_get_dest_result get_dest
 static int get_sip_pvt_from_replaces(const char *callid, const char *totag,
 		const char *fromtag, struct sip_pvt **out_pvt, struct ast_channel **out_chan)
 {
-	struct sip_pvt *sip_pvt_ptr;
+	RAII_VAR(struct sip_pvt *, sip_pvt_ptr, NULL, ao2_cleanup);
 	struct sip_pvt tmp_dialog = {
 		.callid = callid,
 	};
@@ -18419,6 +18568,9 @@ static int get_sip_pvt_from_replaces(con
 		}
 	}
 
+	/* If we're here sip_pvt_ptr has been copied to *out_pvt, prevent RAII_VAR cleanup */
+	sip_pvt_ptr = NULL;
+
 	return 0;
 }
 
@@ -19485,7 +19637,7 @@ static char *sip_show_inuse(struct ast_c
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "sip show inuse";
+		e->command = "sip show inuse [all]";
 		e->usage =
 			"Usage: sip show inuse [all]\n"
 			"       List all SIP devices usage counters and limits.\n"
@@ -19675,7 +19827,7 @@ static char *sip_show_users(struct ast_c
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "sip show users";
+		e->command = "sip show users [like]";
 		e->usage =
 			"Usage: sip show users [like <pattern>]\n"
 			"       Lists all known SIP users.\n"
@@ -19814,7 +19966,7 @@ static char *sip_show_peers(struct ast_c
 {
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "sip show peers";
+		e->command = "sip show peers [like]";
 		e->usage =
 			"Usage: sip show peers [like <pattern>]\n"
 			"       Lists all known SIP peers.\n"
@@ -20040,7 +20192,9 @@ static struct sip_peer *_sip_show_peers_
 		"ACL: %s\r\n"
 		"Status: %s\r\n"
 		"RealtimeDevice: %s\r\n"
-		"Description: %s\r\n\r\n",
+		"Description: %s\r\n"
+		"Accountcode: %s\r\n"
+		"\r\n",
 		cont->idtext,
 		peer->name,
 		ast_sockaddr_isnull(&peer->addr) ? "-none-" : tmp_host,
@@ -20055,7 +20209,8 @@ static struct sip_peer *_sip_show_peers_
 		ast_acl_list_is_empty(peer->acl) ? "no" : "yes",       /* permit/deny/acl */
 		status,
 		cont->realtimepeers ? (peer->is_realtime ? "yes" : "no") : "no",
-		peer->description);
+		peer->description,
+		peer->accountcode);
 	}
 	ao2_unlock(peer);
 
@@ -20525,7 +20680,12 @@ static char *sip_show_peer(struct ast_cl
 			"       Option \"load\" forces lookup of peer in realtime storage.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_sip_show_peer(a->line, a->word, a->pos, a->n);
+		if (a->pos == 4) {
+			static const char * const completions[] = { "load", NULL };
+			return ast_cli_complete(a->word, completions, a->n);
+		} else {
+			return complete_sip_show_peer(a->line, a->word, a->pos, a->n);
+		}
 	}
 	return _sip_show_peer(0, a->fd, NULL, NULL, a->argc, (const char **) a->argv);
 }
@@ -20695,7 +20855,12 @@ static char *sip_qualify_peer(struct ast
 			"       Option \"load\" forces lookup of peer in realtime storage.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_sip_show_peer(a->line, a->word, a->pos, a->n);
+		if (a->pos == 4) {
+			static const char * const completions[] = { "load", NULL };
+			return ast_cli_complete(a->word, completions, a->n);
+		} else {
+			return complete_sip_show_peer(a->line, a->word, a->pos, a->n);
+		}
 	}
 	return _sip_qualify_peer(0, a->fd, NULL, NULL, a->argc, (const char **) a->argv);
 }
@@ -20905,6 +21070,7 @@ static char *_sip_show_peer(int type, in
 		ast_cli(fd, "  Parkinglot   : %s\n", peer->parkinglot);
 		ast_cli(fd, "  Use Reason   : %s\n", AST_CLI_YESNO(ast_test_flag(&peer->flags[1], SIP_PAGE2_Q850_REASON)));
 		ast_cli(fd, "  Encryption   : %s\n", AST_CLI_YESNO(ast_test_flag(&peer->flags[1], SIP_PAGE2_USE_SRTP)));
+		ast_cli(fd, "  RTCP Mux     : %s\n", AST_CLI_YESNO(ast_test_flag(&peer->flags[2], SIP_PAGE3_RTCP_MUX)));
 		ast_cli(fd, "\n");
 		peer = sip_unref_peer(peer, "sip_show_peer: sip_unref_peer: done with peer ptr");
 	} else  if (peer && type == 1) { /* manager listing */
@@ -20975,6 +21141,7 @@ static char *_sip_show_peer(int type, in
 		astman_append(s, "SIP-Sess-Min: %d\r\n", peer->stimer.st_min_se);
 		astman_append(s, "SIP-RTP-Engine: %s\r\n", peer->engine);
 		astman_append(s, "SIP-Encryption: %s\r\n", ast_test_flag(&peer->flags[1], SIP_PAGE2_USE_SRTP) ? "Y" : "N");
+		astman_append(s, "SIP-RTCP-Mux: %s\r\n", ast_test_flag(&peer->flags[2], SIP_PAGE3_RTCP_MUX) ? "Y" : "N");
 
 		/* - is enumerated */
 		astman_append(s, "SIP-DTMFmode: %s\r\n", dtmfmode2str(ast_test_flag(&peer->flags[0], SIP_DTMF)));
@@ -21066,7 +21233,12 @@ static char *sip_show_user(struct ast_cl
 			"       Option \"load\" forces lookup of peer in realtime storage.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_sip_show_user(a->line, a->word, a->pos, a->n);
+		if (a->pos == 4) {
+			static const char * const completions[] = { "load", NULL };
+			return ast_cli_complete(a->word, completions, a->n);
+		} else {
+			return complete_sip_show_user(a->line, a->word, a->pos, a->n);
+		}
 	}
 
 	if (a->argc < 4)
@@ -21278,15 +21450,13 @@ static char *sip_unregister(struct ast_c
 }
 
 /*! \brief Callback for show_chanstats */
-static int show_chanstats_cb(void *__cur, void *__arg, int flags)
+static int show_chanstats_cb(struct sip_pvt *cur, struct __show_chan_arg *arg)
 {
 #define FORMAT2 "%-15.15s  %-11.11s  %-8.8s %-10.10s  %-10.10s (     %%) %-6.6s %-10.10s  %-10.10s (     %%) %-6.6s\n"
 #define FORMAT  "%-15.15s  %-11.11s  %-8.8s %-10.10u%-1.1s %-10.10u (%5.2f%%) %-6.4lf %-10.10u%-1.1s %-10.10u (%5.2f%%) %-6.4lf\n"
-	struct sip_pvt *cur = __cur;
 	struct ast_rtp_instance_stats stats;
 	char durbuf[10];
 	struct ast_channel *c;
-	struct __show_chan_arg *arg = __arg;
 	int fd = arg->fd;
 
 	sip_pvt_lock(cur);
@@ -21346,6 +21516,8 @@ static int show_chanstats_cb(void *__cur
 static char *sip_show_channelstats(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct __show_chan_arg arg = { .fd = a->fd, .numchans = 0 };
+	struct sip_pvt *cur;
+	struct ao2_iterator i;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -21363,8 +21535,14 @@ static char *sip_show_channelstats(struc
 		return CLI_SHOWUSAGE;
 
 	ast_cli(a->fd, FORMAT2, "Peer", "Call ID", "Duration", "Recv: Pack", "Lost", "Jitter", "Send: Pack", "Lost", "Jitter");
+
 	/* iterate on the container and invoke the callback on each item */
-	ao2_t_callback(dialogs, OBJ_NODATA, show_chanstats_cb, &arg, "callback to sip show chanstats");
+	i = ao2_iterator_init(dialogs, 0);
+	for (; (cur = ao2_iterator_next(&i)); ao2_ref(cur, -1)) {
+		show_chanstats_cb(cur, &arg);
+	}
+	ao2_iterator_destroy(&i);
+
 	ast_cli(a->fd, "%d active SIP channel%s\n", arg.numchans, (arg.numchans != 1) ? "s" : "");
 	return CLI_SUCCESS;
 }
@@ -21547,7 +21725,7 @@ static char *sip_show_settings(struct as
 	ast_cli(a->fd, "  Sub. max duration:      %d secs\n", max_subexpiry);
 	ast_cli(a->fd, "  Outbound reg. timeout:  %d secs\n", global_reg_timeout);
 	ast_cli(a->fd, "  Outbound reg. attempts: %d\n", global_regattempts_max);
-	ast_cli(a->fd, "  Outbound reg. retry 403:%d\n", global_reg_retry_403);
+	ast_cli(a->fd, "  Outbound reg. retry 403:%s\n", AST_CLI_YESNO(global_reg_retry_403));
 	ast_cli(a->fd, "  Notify ringing state:   %s\n", AST_CLI_YESNO(sip_cfg.notifyringing));
 	if (sip_cfg.notifyringing) {
 		ast_cli(a->fd, "    Include CID:          %s%s\n",
@@ -21588,6 +21766,7 @@ static char *sip_show_settings(struct as
 	ast_cli(a->fd, "  MOH Interpret:          %s\n", default_mohinterpret);
 	ast_cli(a->fd, "  MOH Suggest:            %s\n", default_mohsuggest);
 	ast_cli(a->fd, "  Voice Mail Extension:   %s\n", default_vmexten);
+	ast_cli(a->fd, "  RTCP Multiplexing:      %s\n", AST_CLI_YESNO(ast_test_flag(&global_flags[2], SIP_PAGE3_RTCP_MUX)));
 
 
 	if (realtimepeers || realtimeregs) {
@@ -21680,10 +21859,8 @@ static const struct cfsubscription_types
 #define FORMAT  "%-15.15s  %-15.15s  %-15.15s  %-15.15s  %-3.3s %-3.3s  %-15.15s %-10.10s %-10.10s\n"
 
 /*! \brief callback for show channel|subscription */
-static int show_channels_cb(void *__cur, void *__arg, int flags)
+static int show_channels_cb(struct sip_pvt *cur, struct __show_chan_arg *arg)
 {
-	struct sip_pvt *cur = __cur;
-	struct __show_chan_arg *arg = __arg;
 	const struct ast_sockaddr *dst;
 
 	sip_pvt_lock(cur);
@@ -21735,7 +21912,8 @@ static int show_channels_cb(void *__cur,
 static char *sip_show_channels(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct __show_chan_arg arg = { .fd = a->fd, .numchans = 0 };
-
+	struct sip_pvt *cur;
+	struct ao2_iterator i;
 
 	if (cmd == CLI_INIT) {
 		e->command = "sip show {channels|subscriptions}";
@@ -21757,7 +21935,11 @@ static char *sip_show_channels(struct as
 		ast_cli(arg.fd, FORMAT3, "Peer", "User", "Call ID", "Extension", "Last state", "Type", "Mailbox", "Expiry");
 
 	/* iterate on the container and invoke the callback on each item */
-	ao2_t_callback(dialogs, OBJ_NODATA, show_channels_cb, &arg, "callback to show channels");
+	i = ao2_iterator_init(dialogs, 0);
+	for (; (cur = ao2_iterator_next(&i)); ao2_ref(cur, -1)) {
+		show_channels_cb(cur, &arg);
+	}
+	ao2_iterator_destroy(&i);
 
 	/* print summary information */
 	ast_cli(arg.fd, "%d active SIP %s%s\n", arg.numchans,
@@ -23845,6 +24027,7 @@ static void handle_response_invite(struc
 	case 422: /* Session-Timers: Session interval too small */
 		xmitres = transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, FALSE);
 		ast_string_field_set(p, theirtag, NULL);
+		p->invitestate = INV_CALLING;
 		proc_422_rsp(p, req);
 		break;
 
@@ -24581,6 +24764,7 @@ static void handle_response(struct sip_p
 	char *c_copy = ast_strdupa(c);
 	/* Skip the Cseq and its subsequent spaces */
 	const char *msg = ast_skip_blanks(ast_skip_nonblanks(c_copy));
+	int ack_res = FALSE;
 
 	if (!msg)
 		msg = "";
@@ -24609,28 +24793,24 @@ static void handle_response(struct sip_p
 			ast_channel_hangupcause_set(owner, hangup_sip2cause(resp));
 	}
 
-	if (p->socket.type == AST_TRANSPORT_UDP) {
-		int ack_res = FALSE;
-
-		/* Acknowledge whatever it is destined for */
-		if ((resp >= 100) && (resp <= 199)) {
-			/* NON-INVITE messages do not ack a 1XX response. RFC 3261 section 17.1.2.2 */
-			if (sipmethod == SIP_INVITE) {
-				ack_res = __sip_semi_ack(p, seqno, 0, sipmethod);
-			}
-		} else {
-			ack_res = __sip_ack(p, seqno, 0, sipmethod);
+	/* Acknowledge whatever it is destined for */
+	if ((resp >= 100) && (resp <= 199)) {
+		/* NON-INVITE messages do not ack a 1XX response. RFC 3261 section 17.1.2.2 */
+		if (sipmethod == SIP_INVITE) {
+			ack_res = __sip_semi_ack(p, seqno, 0, sipmethod);
 		}
+	} else {
+		ack_res = __sip_ack(p, seqno, 0, sipmethod);
+	}
 
-		if (ack_res == FALSE) {
-			/* RFC 3261 13.2.2.4 and 17.1.1.2 - We must re-send ACKs to re-transmitted final responses */
-			if (sipmethod == SIP_INVITE && resp >= 200) {
-				transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, resp < 300 ? TRUE: FALSE);
-			}
-
-			append_history(p, "Ignore", "Ignoring this retransmit\n");
-			return;
+	if (ack_res == FALSE) {
+		/* RFC 3261 13.2.2.4 and 17.1.1.2 - We must re-send ACKs to re-transmitted final responses */
+		if (sipmethod == SIP_INVITE && resp >= 200) {
+			transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, resp < 300 ? TRUE: FALSE);
 		}
+
+		append_history(p, "Ignore", "Ignoring this retransmit\n");
+		return;
 	}
 
 	/* If this is a NOTIFY for a subscription clear the flag that indicates that we have a NOTIFY pending */
@@ -25617,8 +25797,7 @@ static int handle_request_update(struct
  * \retval 0 ok
  * \retval -1 failure
  */
-static int handle_request_invite_st(struct sip_pvt *p, struct sip_request *req,
-		const char *required, int reinvite)
+static int handle_request_invite_st(struct sip_pvt *p, struct sip_request *req, int reinvite)
 {
 	const char *p_uac_se_hdr;       /* UAC's Session-Expires header string                      */
 	const char *p_uac_min_se;       /* UAC's requested Min-SE interval (char string)            */
@@ -25698,8 +25877,8 @@ static int handle_request_invite_st(stru
 
 		case SESSION_TIMER_MODE_REFUSE:
 			if (p->reqsipoptions & SIP_OPT_TIMER) {
-				transmit_response_with_unsupported(p, "420 Option Disabled", req, required);
-				ast_log(LOG_WARNING, "Received SIP INVITE with supported but disabled option: %s\n", required);
+				transmit_response_with_unsupported(p, "420 Option Disabled", req, "timer");
+				ast_log(LOG_WARNING, "Received SIP INVITE with supported but disabled option: timer\n");
 				return -1;
 			}
 			break;
@@ -25805,7 +25984,7 @@ static int handle_request_invite(struct
 	 * then send a 420 with only those unsupported options listed */
 	if (!ast_strlen_zero(unsupported)) {
 		transmit_response_with_unsupported(p, "420 Bad extension (unsupported)", req, unsupported);
-		ast_log(LOG_WARNING, "Received SIP INVITE with unsupported required extension: required:%s unsupported:%s\n", required, unsupported);
+		ast_log(LOG_WARNING, "Received SIP INVITE with unsupported required extension: %s\n", unsupported);
 		p->invitestate = INV_COMPLETED;
 		if (!p->lastinvite) {
 			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
@@ -26041,12 +26220,15 @@ static int handle_request_invite(struct
 		copy_request(&p->initreq, req);		/* Save this INVITE as the transaction basis */
 		if (sipdebug)
 			ast_debug(1, "Initializing initreq for method %s - callid %s\n", sip_methods[req->method].text, p->callid);
+
+		/* Parse new contact both for existing (re-invite) and new calls. */
+		parse_ok_contact(p, req);
+
 		if (!p->owner) {	/* Not a re-invite */
 			if (req->debug)
 				ast_verbose("Using INVITE request as basis request - %s\n", p->callid);
 			if (newcall)
 				append_history(p, "Invite", "New call: %s", p->callid);
-			parse_ok_contact(p, req);
 		} else {	/* Re-invite on existing call */
 			ast_clear_flag(&p->flags[0], SIP_OUTGOING);	/* This is now an inbound dialog */
 			if (get_rpid(p, req)) {
@@ -26240,7 +26422,7 @@ static int handle_request_invite(struct
 
 			make_our_tag(p);
 
-			if (handle_request_invite_st(p, req, required, reinvite)) {
+			if (handle_request_invite_st(p, req, reinvite)) {
 				p->invitestate = INV_COMPLETED;
 				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
 				res = INV_REQ_ERROR;
@@ -26282,7 +26464,7 @@ static int handle_request_invite(struct
 		if (!req->ignore)
 			reinvite = 1;
 
-		if (handle_request_invite_st(p, req, required, reinvite)) {
+		if (handle_request_invite_st(p, req, reinvite)) {
 			p->invitestate = INV_COMPLETED;
 			if (!p->lastinvite) {
 				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
@@ -27910,15 +28092,14 @@ static void add_peer_mwi_subs(struct sip
 
 	AST_LIST_TRAVERSE(&peer->mailboxes, mailbox, entry) {
 		struct stasis_topic *mailbox_specific_topic;
-		mailbox->event_sub = stasis_unsubscribe(mailbox->event_sub);
+
+		if (mailbox->status != SIP_MAILBOX_STATUS_NEW) {
+			continue;
+		}
 
 		mailbox_specific_topic = ast_mwi_topic(mailbox->id);
 		if (mailbox_specific_topic) {
-			char *peer_name = ast_strdup(peer->name);
-			if (!peer_name) {
-				return;
-			}
-			mailbox->event_sub = stasis_subscribe_pool(mailbox_specific_topic, mwi_event_cb, peer_name);
+			mailbox->event_sub = stasis_subscribe_pool(mailbox_specific_topic, mwi_event_cb, peer);
 		}
 	}
 }
@@ -28747,7 +28928,7 @@ static int handle_incoming(struct sip_pv
 					return -1;
 				}
 				if (ast_test_flag(&p->flags[0], SIP_DIRECT_MEDIA)) {
-					ast_queue_control(p->owner, AST_CONTROL_SRCCHANGE);
+					ast_queue_control(p->owner, AST_CONTROL_UPDATE_RTP_PEER);
 				}
 			}
 			sched_check_pendings(p);
@@ -29071,6 +29252,17 @@ static int sip_prepare_socket(struct sip
 		}
 	}
 
+	/* If a bind address has been specified, use it */
+	if ((s->type == AST_TRANSPORT_TLS) && !ast_sockaddr_isnull(&sip_tls_desc.local_address)) {
+		ca->local_address = sip_tls_desc.local_address;
+	}
+	else if ((s->type == AST_TRANSPORT_TCP) && !ast_sockaddr_isnull(&sip_tcp_desc.local_address)) {
+		ca->local_address = sip_tcp_desc.local_address;
+	}
+	/* Reset tcp source port to zero to let system pick a random one */
+	if (!ast_sockaddr_isnull(&ca->local_address)) {
+		ast_sockaddr_set_port(&ca->local_address, 0);
+	}
 	/* Create a client connection for address, this does not start the connection, just sets it up. */
 	if (!(s->tcptls_session = ast_tcptls_client_create(ca))) {
 		goto create_tcptls_session_fail;
@@ -29143,7 +29335,9 @@ static int get_cached_mwi(struct sip_pee
 }
 
 /*! \brief Send message waiting indication to alert peer that they've got voicemail
- *  \note Both peer and associated sip_pvt must be unlocked prior to calling this function
+ *  \note Both peer and associated sip_pvt must be unlocked prior to calling this function.
+ *  It's possible that this function will get called during peer destruction as final messages
+ *  are processed.  The peer will still be valid however.
  *  \returns -1 on failure, 0 on success
  */
 static int sip_send_mwi_to_peer(struct sip_peer *peer, int cache_only)
@@ -30346,9 +30540,10 @@ static struct ast_channel *sip_request_c
 	if (p->relatedpeer) {
 
 		if (!ast_strlen_zero(p->relatedpeer->fullcontact) && !p->natdetected &&
-			(ast_test_flag(&p->flags[2], SIP_PAGE3_NAT_AUTO_RPORT) && !ast_test_flag(&p->flags[0], SIP_NAT_FORCE_RPORT))) {
+		    ((ast_test_flag(&p->flags[2], SIP_PAGE3_NAT_AUTO_RPORT) && !ast_test_flag(&p->flags[0], SIP_NAT_FORCE_RPORT)) ||
+		     (ast_test_flag(&p->flags[2], SIP_PAGE3_NAT_AUTO_COMEDIA) && !ast_test_flag(&p->flags[1], SIP_PAGE2_SYMMETRICRTP)))) {
 			/* We need to make an attempt to determine if a peer is behind NAT
-			   if the peer has the auto_force_rport flag set. */
+			   if the peer has the flags auto_force_rport or auto_comedia set. */
 			struct ast_sockaddr tmpaddr;
 
 			__set_address_from_contact(p->relatedpeer->fullcontact, &tmpaddr, 0);
@@ -30635,6 +30830,9 @@ static int handle_common_options(struct
 	} else if (!strcasecmp(v->name, "buggymwi")) {
 		ast_set_flag(&mask[1], SIP_PAGE2_BUGGY_MWI);
 		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_BUGGY_MWI);
+	} else if (!strcasecmp(v->name, "rtcp_mux")) {
+		ast_set_flag(&mask[2], SIP_PAGE3_RTCP_MUX);
+		ast_set2_flag(&flags[2], ast_true(v->value), SIP_PAGE3_RTCP_MUX);
 	} else
 		res = 0;
 
@@ -30966,6 +31164,7 @@ static void add_peer_mailboxes(struct si
 		AST_LIST_TRAVERSE(&peer->mailboxes, mailbox, entry) {
 			if (!strcmp(mailbox->id, mbox)) {
 				duplicate = 1;
+				mailbox->status = SIP_MAILBOX_STATUS_EXISTING;
 				break;
 			}
 		}
@@ -30978,14 +31177,18 @@ static void add_peer_mailboxes(struct si
 			continue;
 		}
 		strcpy(mailbox->id, mbox); /* SAFE */
+		mailbox->status = SIP_MAILBOX_STATUS_NEW;
+		mailbox->peer = peer;
 
 		AST_LIST_INSERT_TAIL(&peer->mailboxes, mailbox, entry);
 	}
 }
 
 /*! \brief Build peer from configuration (file or realtime static/dynamic) */
-static struct sip_peer *build_peer(const char *name, struct ast_variable *v, struct ast_variable *alt, int realtime, int devstate_only)
+static struct sip_peer *build_peer(const char *name, struct ast_variable *v_head, struct ast_variable *alt, int realtime, int devstate_only)
 {
+	/* We preserve the original value of v_head to make analyzing backtraces easier */
+	struct ast_variable *v = v_head;
 	struct sip_peer *peer = NULL;
 	struct ast_acl_list *oldacl = NULL;
 	struct ast_acl_list *olddirectmediaacl = NULL;
@@ -31026,12 +31229,15 @@ static struct sip_peer *build_peer(const
 			firstpass = 0;
 		} else {
 			ast_format_cap_remove_by_type(peer->caps, AST_MEDIA_TYPE_UNKNOWN);
+			ast_rtp_dtls_cfg_free(&peer->dtls_cfg);
+			memset(&peer->dtls_cfg, 0, sizeof(peer->dtls_cfg));
 		}
 	} else {
 		if (!(peer = ao2_t_alloc(sizeof(*peer), sip_destroy_peer_fn, "allocate a peer struct"))) {
 			return NULL;
 		}
 		if (!(peer->endpoint = ast_endpoint_create("SIP", name))) {
+			ao2_t_ref(peer, -1, "failed to allocate endpoint, drop peer");
 			return NULL;
 		}
 		if (!(peer->caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
@@ -31048,6 +31254,7 @@ static struct sip_peer *build_peer(const
 			return NULL;
 		}
 
+
 		if (realtime && !ast_test_flag(&global_flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
 			ast_atomic_fetchadd_int(&rpeerobjs, 1);
 			ast_debug(3, "-REALTIME- peer built. Name: %s. Peer objects: %d\n", name, rpeerobjs);
@@ -31097,7 +31304,7 @@ static struct sip_peer *build_peer(const
 	if (!devstate_only) {
 		struct sip_mailbox *mailbox;
 		AST_LIST_TRAVERSE(&peer->mailboxes, mailbox, entry) {
-			mailbox->delme = 1;
+			mailbox->status = SIP_MAILBOX_STATUS_UNKNOWN;
 		}
 	}
 
@@ -31546,7 +31753,7 @@ static struct sip_peer *build_peer(const
 	if (!devstate_only) {
 		struct sip_mailbox *mailbox;
 		AST_LIST_TRAVERSE_SAFE_BEGIN(&peer->mailboxes, mailbox, entry) {
-			if (mailbox->delme) {
+			if (mailbox->status == SIP_MAILBOX_STATUS_UNKNOWN) {
 				AST_LIST_REMOVE_CURRENT(entry);
 				destroy_mailbox(mailbox);
 			}
@@ -32432,7 +32639,7 @@ static int reload_config(enum channelrel
 			externexpire = 0;
 		} else if (!strcasecmp(v->name, "externhost")) {
 			ast_copy_string(externhost, v->value, sizeof(externhost));
-			if (ast_sockaddr_resolve_first(&externaddr, externhost, 0)) {
+			if (ast_sockaddr_resolve_first_af(&externaddr, externhost, 0, AST_AF_INET)) {
 				ast_log(LOG_WARNING, "Invalid address for externhost keyword: %s\n", externhost);
 			}
 			externexpire = time(NULL);
@@ -32964,17 +33171,17 @@ static int reload_config(enum channelrel
 
 		/* If TCP is running on a different IP than UDP, then add it too */
 		if (!ast_sockaddr_isnull(&sip_tcp_desc.local_address) &&
-		    !ast_sockaddr_cmp(&bindaddr, &sip_tcp_desc.local_address)) {
+		    ast_sockaddr_cmp_addr(&bindaddr, &sip_tcp_desc.local_address)) {
 			add_sip_domain(ast_sockaddr_stringify_addr(&sip_tcp_desc.local_address),
 				       SIP_DOMAIN_AUTO, NULL);
 		}
 
 		/* If TLS is running on a different IP than UDP and TCP, then add that too */
 		if (!ast_sockaddr_isnull(&sip_tls_desc.local_address) &&
-		    !ast_sockaddr_cmp(&bindaddr, &sip_tls_desc.local_address) &&
-		    !ast_sockaddr_cmp(&sip_tcp_desc.local_address,
+		    ast_sockaddr_cmp_addr(&bindaddr, &sip_tls_desc.local_address) &&
+		    ast_sockaddr_cmp_addr(&sip_tcp_desc.local_address,
 				      &sip_tls_desc.local_address)) {
-			add_sip_domain(ast_sockaddr_stringify_addr(&sip_tcp_desc.local_address),
+			add_sip_domain(ast_sockaddr_stringify_addr(&sip_tls_desc.local_address),
 				       SIP_DOMAIN_AUTO, NULL);
 		}
 
@@ -33227,9 +33434,9 @@ static int sip_set_rtp_peer(struct ast_c
 
 		if (p->rtp) {
 			/* Prevent audio RTCP reads */
-			ast_channel_set_fd(chan, 1, -1);
+			ast_channel_set_fd(chan, SIP_AUDIO_RTCP_FD, -1);
 			/* Silence RTCP while audio RTP is inactive */
-			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, 0);
+			ast_rtp_instance_set_prop(p->rtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_DISABLED);
 		}
 	} else if (!ast_sockaddr_isnull(&p->redirip)) {
 		memset(&p->redirip, 0, sizeof(p->redirip));
@@ -33241,9 +33448,9 @@ static int sip_set_rtp_peer(struct ast_c
 
 		if (p->vrtp) {
 			/* Prevent video RTCP reads */
-			ast_channel_set_fd(chan, 3, -1);
+			ast_channel_set_fd(chan, SIP_VIDEO_RTCP_FD, -1);
 			/* Silence RTCP while video RTP is inactive */
-			ast_rtp_instance_set_prop(p->vrtp, AST_RTP_PROPERTY_RTCP, 0);
+			ast_rtp_instance_set_prop(p->vrtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_DISABLED);
 		}
 	} else if (!ast_sockaddr_isnull(&p->vredirip)) {
 		memset(&p->vredirip, 0, sizeof(p->vredirip));
@@ -33252,9 +33459,9 @@ static int sip_set_rtp_peer(struct ast_c
 		if (p->vrtp) {
 			/* Enable RTCP since it will be inactive if we're coming back
 			 * from a reinvite */
-			ast_rtp_instance_set_prop(p->vrtp, AST_RTP_PROPERTY_RTCP, 1);
+			ast_rtp_instance_set_prop(p->vrtp, AST_RTP_PROPERTY_RTCP, AST_RTP_INSTANCE_RTCP_STANDARD);
 			/* Enable video RTCP reads */
-			ast_channel_set_fd(chan, 3, ast_rtp_instance_fd(p->vrtp, 1));
+			ast_channel_set_fd(chan, SIP_VIDEO_RTCP_FD, ast_rtp_instance_fd(p->vrtp, 1));
 		}
 	}
 
@@ -33302,9 +33509,7 @@ static int sip_set_rtp_peer(struct ast_c
 
 static void sip_get_codec(struct ast_channel *chan, struct ast_format_cap *result)
 {
-	struct sip_pvt *p = ast_channel_tech_pvt(chan);
-
-	ast_format_cap_append_from_cap(result, !ast_format_cap_count(p->peercaps) ? p->caps : p->peercaps, AST_MEDIA_TYPE_UNKNOWN);
+	ast_format_cap_append_from_cap(result, ast_channel_nativeformats(chan), AST_MEDIA_TYPE_UNKNOWN);
 }
 
 static struct ast_rtp_glue sip_rtp_glue = {
@@ -33641,7 +33846,8 @@ static void sip_send_all_mwi_subscriptio
 	ao2_iterator_destroy(&iter);
 }
 
-static int process_crypto(struct sip_pvt *p, struct ast_rtp_instance *rtp, struct ast_sdp_srtp **srtp, const char *a)
+static int process_crypto(struct sip_pvt *p, struct ast_rtp_instance *rtp, struct ast_sdp_srtp **srtp,
+		const char *a, int secure_transport)
 {
 	struct ast_rtp_engine_dtls *dtls;
 
@@ -33657,6 +33863,23 @@ static int process_crypto(struct sip_pvt
 	/* skip "crypto:" */
 	a += strlen("crypto:");
 
+	if (!secure_transport) {
+		/* > The Secure Real-time Transport Protocol (SRTP)
+		 * > [RFC3711] provides security services for RTP media
+		 * > and is signaled by use of secure RTP transport (e.g.,
+		 * > "RTP/SAVP" or "RTP/SAVPF") in an SDP media (m=) line.
+		 * > ...
+		 * > The "crypto" attribute MUST only appear at the SDP
+		 * > media level (not at the session level).
+		 *
+		 * Ergo, we can trust RTP/(S)AVP to be read from the m=
+		 * line before we get here. If it was RTP/AVP, then this
+		 * is SNOM-specific optional SRTP. Ignore it.
+		 */
+		ast_log(LOG_WARNING, "Ignoring crypto attribute in SDP because RTP transport is insecure\n");
+		return FALSE;
+	}
+
 	if (!*srtp) {
 		if (ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
 			ast_log(LOG_WARNING, "Ignoring unexpected crypto attribute in SDP answer\n");
@@ -35004,20 +35227,24 @@ static int load_module(void)
 	struct sip_peer *bogus_peer;
 
 	ast_verbose("SIP channel loading...\n");
+	log_level = ast_logger_register_level("SIP_HISTORY");
+	if (log_level < 0) {
+		ast_log(LOG_WARNING, "Unable to register history log level\n");
+	}
 
 	if (STASIS_MESSAGE_TYPE_INIT(session_timeout_type)) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(sip_tech.capabilities = ast_format_cap_alloc(0))) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_sip_api_provider_register(&chan_sip_api_provider)) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* the fact that ao2_containers can't resize automatically is a major worry! */
@@ -35032,12 +35259,12 @@ static int load_module(void)
 		|| !threadt) {
 		ast_log(LOG_ERROR, "Unable to create primary SIP container(s)\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(sip_cfg.caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_format_cap_append_by_type(sip_tech.capabilities, AST_MEDIA_TYPE_AUDIO);
 
@@ -35048,13 +35275,13 @@ static int load_module(void)
 	if (!(sched = ast_sched_context_create())) {
 		ast_log(LOG_ERROR, "Unable to create scheduler context\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(io = io_context_create())) {
 		ast_log(LOG_ERROR, "Unable to create I/O context\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	sip_reloadreason = CHANNEL_MODULE_LOAD;
@@ -35069,7 +35296,7 @@ static int load_module(void)
 	if (!(bogus_peer = temp_peer("(bogus_peer)"))) {
 		ast_log(LOG_ERROR, "Unable to create bogus_peer for authentication\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	/* Make sure the auth will always fail. */
 	ast_string_field_set(bogus_peer, md5secret, BOGUS_PEER_MD5SECRET);
@@ -35086,14 +35313,14 @@ static int load_module(void)
 
 	if (ast_msg_tech_register(&sip_msg_tech)) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Make sure we can register our sip channel type */
 	if (ast_channel_register(&sip_tech)) {
 		ast_log(LOG_ERROR, "Unable to register channel type 'SIP'\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 #ifdef TEST_FRAMEWORK
@@ -35201,7 +35428,9 @@ static int unload_module(void)
 	struct sip_pvt *p;
 	struct sip_threadinfo *th;
 	struct ao2_iterator i;
-	int wait_count;
+	struct timeval start;
+
+	ast_sched_dump(sched);
 
 	ast_sip_api_provider_unregister();
 
@@ -35212,12 +35441,11 @@ static int unload_module(void)
 	network_change_stasis_unsubscribe();
 	acl_change_event_stasis_unsubscribe();
 
-	ast_sched_dump(sched);
-
 	/* First, take us out of the channel type list */
 	ast_channel_unregister(&sip_tech);
-
 	ast_msg_tech_unregister(&sip_msg_tech);
+	ast_cc_monitor_unregister(&sip_cc_monitor_callbacks);
+	ast_cc_agent_unregister(&sip_cc_agent_callbacks);
 
 	/* Unregister dial plan functions */
 	ast_custom_function_unregister(&sippeer_function);
@@ -35281,8 +35509,6 @@ static int unload_module(void)
 	}
 	ao2_iterator_destroy(&i);
 
-	unlink_all_peers_from_tables();
-
 	ast_mutex_lock(&monlock);
 	if (monitor_thread && (monitor_thread != AST_PTHREADT_STOP) && (monitor_thread != AST_PTHREADT_NULL)) {
 		pthread_t th = monitor_thread;
@@ -35296,7 +35522,12 @@ static int unload_module(void)
 		ast_mutex_unlock(&monlock);
 	}
 
+	/* Clear containers */
+	unlink_all_peers_from_tables();
 	cleanup_all_regs();
+	sip_epa_unregister_all();
+	destroy_escs();
+	clear_sip_domains();
 
 	{
 		struct ao2_iterator iter;
@@ -35325,6 +35556,23 @@ static int unload_module(void)
 	 */
 	ast_sched_runq(sched);
 
+	/*
+	 * Wait awhile for the TCP/TLS thread container to become empty.
+	 *
+	 * XXX This is a hack, but the worker threads cannot be created
+	 * joinable.  They can die on their own and remove themselves
+	 * from the container thus resulting in a huge memory leak.
+	 */
+	start = ast_tvnow();
+	while (ao2_container_count(threadt) && (ast_tvdiff_sec(ast_tvnow(), start) < 5)) {
+		sched_yield();
+	}
+	if (ao2_container_count(threadt)) {
+		ast_debug(2, "TCP/TLS thread container did not become empty :(\n");
+
+		return -1;
+	}
+
 	/* Free memory for local network address mask */
 	ast_free_ha(localaddr);
 
@@ -35335,30 +35583,12 @@ static int unload_module(void)
 	}
 	ast_mutex_unlock(&authl_lock);
 
-	sip_epa_unregister_all();
-	destroy_escs();
-
 	ast_free(default_tls_cfg.certfile);
 	ast_free(default_tls_cfg.pvtfile);
 	ast_free(default_tls_cfg.cipher);
 	ast_free(default_tls_cfg.cafile);
 	ast_free(default_tls_cfg.capath);
 
-	/*
-	 * Wait awhile for the TCP/TLS thread container to become empty.
-	 *
-	 * XXX This is a hack, but the worker threads cannot be created
-	 * joinable.  They can die on their own and remove themselves
-	 * from the container thus resulting in a huge memory leak.
-	 */
-	wait_count = 1000;
-	while (ao2_container_count(threadt) && --wait_count) {
-		sched_yield();
-	}
-	if (!wait_count) {
-		ast_debug(2, "TCP/TLS thread container did not become empty :(\n");
-	}
-
 	ao2_cleanup(registry_list);
 	ao2_cleanup(subscription_mwi_list);
 
@@ -35372,7 +35602,6 @@ static int unload_module(void)
 	ao2_t_cleanup(threadt, "unref the thread table");
 	ao2_t_cleanup(sip_monitor_instances, "unref the sip_monitor_instances table");
 
-	clear_sip_domains();
 	sip_cfg.contact_acl = ast_free_acl_list(sip_cfg.contact_acl);
 	if (sipsock_read_id) {
 		ast_io_remove(io, sipsock_read_id);
@@ -35385,8 +35614,6 @@ static int unload_module(void)
 	ast_context_destroy_by_name(used_context, "SIP");
 	ast_unload_realtime("sipregs");
 	ast_unload_realtime("sippeers");
-	ast_cc_monitor_unregister(&sip_cc_monitor_callbacks);
-	ast_cc_agent_unregister(&sip_cc_agent_callbacks);
 
 	sip_reqresp_parser_exit();
 	sip_unregister_tests();
@@ -35402,6 +35629,9 @@ static int unload_module(void)
 	sip_cfg.caps = NULL;
 
 	STASIS_MESSAGE_TYPE_CLEANUP(session_timeout_type);
+	if (log_level != -1) {
+		ast_logger_unregister_level("SIP_HISTORY");
+	}
 
 	return 0;
 }
diff -urpN asterisk-13.9.1/channels/chan_skinny.c asterisk-13.17.0/channels/chan_skinny.c
--- asterisk-13.9.1/channels/chan_skinny.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_skinny.c	2017-07-12 13:12:08.000000000 +0200
@@ -3924,24 +3924,40 @@ static char *complete_skinny_show_device
 
 static char *complete_skinny_reset(const char *line, const char *word, int pos, int state)
 {
-	return (pos == 2 ? complete_skinny_devices(word, state) : NULL);
+	if (pos == 2) {
+		static const char * const completions[] = { "all", NULL };
+		char *ret = ast_cli_complete(word, completions, state);
+		if (!ret) {
+			ret = complete_skinny_devices(word, state - 1);
+		}
+		return ret;
+	} else if (pos == 3) {
+		static const char * const completions[] = { "restart", NULL };
+		return ast_cli_complete(word, completions, state);
+	}
+
+	return NULL;
 }
 
 static char *complete_skinny_show_line(const char *line, const char *word, int pos, int state)
 {
-	struct skinny_device *d;
-	struct skinny_line *l;
-	int wordlen = strlen(word), which = 0;
-
-	if (pos != 3)
-		return NULL;
-
-	AST_LIST_TRAVERSE(&devices, d, list) {
-		AST_LIST_TRAVERSE(&d->lines, l, list) {
-			if (!strncasecmp(word, l->name, wordlen) && ++which > state) {
-				return ast_strdup(l->name);
+	if (pos == 3) {
+		struct skinny_device *d;
+		struct skinny_line *l;
+		int wordlen = strlen(word), which = 0;
+
+		AST_LIST_TRAVERSE(&devices, d, list) {
+			AST_LIST_TRAVERSE(&d->lines, l, list) {
+				if (!strncasecmp(word, l->name, wordlen) && ++which > state) {
+					return ast_strdup(l->name);
+				}
 			}
 		}
+	} else if (pos == 4) {
+		static const char * const completions[] = { "on", NULL };
+		return ast_cli_complete(word, completions, state);
+	} else if (pos == 5) {
+		return complete_skinny_devices(word, state);
 	}
 
 	return NULL;
@@ -4583,7 +4599,7 @@ static char *handle_skinny_show_line(str
 	case CLI_INIT:
 		e->command = "skinny show line";
 		e->usage =
-			"Usage: skinny show line <Line> [ on <DeviceID|DeviceName> ]\n"
+			"Usage: skinny show line <Line> [on <DeviceID|DeviceName>]\n"
 			"       List all lineinformation of a specific line known to the Skinny subsystem.\n";
 		return NULL;
 	case CLI_GENERATE:
@@ -6645,7 +6661,7 @@ static int handle_capabilities_res_messa
 #ifdef AST_DEVMODE
 	struct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
 #endif
-	
+
 
 	if (!codecs) {
 		return 0;
@@ -7486,6 +7502,8 @@ static void skinny_session_cleanup(void
 	destroy_session(s);
 }
 
+#define PACKET_TIMEOUT 10000
+
 static void *skinny_session(void *data)
 {
 	int res;
@@ -7532,78 +7550,86 @@ static void *skinny_session(void *data)
 			}
 		}
 
-		if (fds[0].revents) {
+		if (!fds[0].revents) {
+			continue;
+		}
+		ast_debug(1, "Reading header\n");
 
-			if (!(req = ast_calloc(1, SKINNY_MAX_PACKET))) {
-				ast_log(LOG_WARNING, "Unable to allocated memorey for skinny_req.\n");
-				break;
-			}
+		if (!(req = ast_calloc(1, SKINNY_MAX_PACKET))) {
+			ast_log(LOG_WARNING, "Unable to allocated memorey for skinny_req.\n");
+			break;
+		}
 
-			ast_mutex_lock(&s->lock);
-			s->lockstate = 1;
+		ast_mutex_lock(&s->lock);
+		s->lockstate = 1;
 
-			if ((res = read(s->fd, req, skinny_header_size)) != skinny_header_size) {
-				if (res < 0) {
-					ast_log(LOG_WARNING, "Header read() returned error: %s\n", strerror(errno));
-				} else {
-					ast_log(LOG_WARNING, "Unable to read header. Only found %d bytes.\n", res);
-				}
-				break;
+		if ((res = read(s->fd, req, skinny_header_size)) != skinny_header_size) {
+			if (res < 0) {
+				ast_log(LOG_WARNING, "Header read() returned error: %s\n", strerror(errno));
+			} else {
+				ast_log(LOG_WARNING, "Unable to read header. Only found %d bytes.\n", res);
 			}
+			break;
+		}
 
-			eventmessage = letohl(req->e);
-			if (eventmessage < 0) {
-				ast_log(LOG_ERROR, "Event Message is NULL from socket %d, This is bad\n", s->fd);
-				break;
-			}
+		eventmessage = letohl(req->e);
+		if (eventmessage < 0) {
+			ast_log(LOG_ERROR, "Event Message is NULL from socket %d, This is bad\n", s->fd);
+			break;
+		}
 
-			dlen = letohl(req->len) - 4;
-			if (dlen < 0) {
-				ast_log(LOG_WARNING, "Skinny Client sent invalid data.\n");
-				break;
-			}
-			if (dlen > (SKINNY_MAX_PACKET - skinny_header_size)) {
-				ast_log(LOG_WARNING, "Skinny packet too large (%d bytes), max length(%d bytes)\n", dlen+8, SKINNY_MAX_PACKET);
-				break;
-			}
+		dlen = letohl(req->len) - 4;
+		if (dlen < 0) {
+			ast_log(LOG_WARNING, "Skinny Client sent invalid data.\n");
+			break;
+		}
+		if (dlen > (SKINNY_MAX_PACKET - skinny_header_size)) {
+			ast_log(LOG_WARNING, "Skinny packet too large (%d bytes), max length(%d bytes)\n", dlen+8, SKINNY_MAX_PACKET);
+			break;
+		}
 
-			bytesread = 0;
-			while (1) {
-				if ((res = read(s->fd, ((char*)&req->data)+bytesread, dlen-bytesread)) < 0) {
-					ast_log(LOG_WARNING, "Data read() returned error: %s\n", strerror(errno));
-					break;
-				}
-				bytesread += res;
-				if (bytesread >= dlen) {
-					if (res < bytesread) {
-						ast_log(LOG_WARNING, "Rest of partial data received.\n");
-					}
-					if (bytesread > dlen) {
-						ast_log(LOG_WARNING, "Client sent wrong amount of data (%d), expected (%d).\n", bytesread, dlen);
-						res = -1;
-					}
-					break;
-				}
+		ast_debug(1, "Read header: Message ID: 0x%04x,  %d bytes in packet\n", eventmessage, dlen);
 
-				ast_log(LOG_WARNING, "Partial data received, waiting (%d bytes read of %d)\n", bytesread, dlen);
-				if (sched_yield() < 0) {
-					ast_log(LOG_WARNING, "Data yield() returned error: %s\n", strerror(errno));
-					res = -1;
-					break;
+		bytesread = 0;
+		while (bytesread < dlen) {
+			ast_debug(1, "Waiting %dms for %d bytes of %d\n", PACKET_TIMEOUT, dlen - bytesread, dlen);
+			fds[0].revents = 0;
+			res = ast_poll(fds, 1, PACKET_TIMEOUT);
+			if (res <= 0) {
+				if (res == 0) {
+					ast_debug(1, "Poll timed out waiting for %d bytes\n", dlen - bytesread);
+				} else {
+					ast_log(LOG_WARNING, "Poll failed waiting for %d bytes: %s\n",
+						dlen - bytesread, strerror(errno));
 				}
+				ast_verb(3, "Ending Skinny session from %s (bad input)\n", ast_inet_ntoa(s->sin.sin_addr));
+				res = -1;
+
+				break;
+			}
+			if (!fds[0].revents) {
+				continue;
 			}
 
-			s->lockstate = 0;
-			ast_mutex_unlock(&s->lock);
+			res = read(s->fd, ((char*)&req->data)+bytesread, dlen-bytesread);
 			if (res < 0) {
+				ast_log(LOG_WARNING, "Data read() returned error: %s\n", strerror(errno));
 				break;
 			}
+			bytesread += res;
+			ast_debug(1, "Read %d bytes.  %d of %d now read\n", res, bytesread, dlen);
+		}
 
-			pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
-			res = handle_message(req, s);
-			pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+		s->lockstate = 0;
+		ast_mutex_unlock(&s->lock);
+		if (res < 0) {
+			break;
 		}
 
+		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+		res = handle_message(req, s);
+		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+
 		if (req) {
 			ast_free(req);
 			req = NULL;
@@ -7626,7 +7652,6 @@ static void *accept_thread(void *ignore)
 	struct sockaddr_in sin;
 	socklen_t sinlen;
 	struct skinnysession *s;
-	struct protoent *p;
 	int arg = 1;
 
 	for (;;) {
@@ -7643,12 +7668,10 @@ static void *accept_thread(void *ignore)
 			continue;
 		}
 
-		p = getprotobyname("tcp");
-		if(p) {
-			if( setsockopt(as, p->p_proto, TCP_NODELAY, (char *)&arg, sizeof(arg) ) < 0 ) {
-				ast_log(LOG_WARNING, "Failed to set Skinny tcp connection to TCP_NODELAY mode: %s\n", strerror(errno));
-			}
+		if (setsockopt(as, IPPROTO_TCP, TCP_NODELAY, (char *) &arg, sizeof(arg)) < 0) {
+			ast_log(LOG_WARNING, "Failed to set TCP_NODELAY on Skinny TCP connection: %s\n", strerror(errno));
 		}
+
 		if (!(s = ast_calloc(1, sizeof(struct skinnysession)))) {
 			close(as);
 			ast_atomic_fetchadd_int(&unauth_sessions, -1);
@@ -8681,7 +8704,7 @@ static int load_module(void)
 		ao2_ref(skinny_tech.capabilities, -1);
 		ao2_ref(default_cap, -1);
 		ast_log(LOG_WARNING, "Unable to create schedule context\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Make sure we can register our skinny channel type */
@@ -8689,7 +8712,7 @@ static int load_module(void)
 		ao2_ref(default_cap, -1);
 		ao2_ref(skinny_tech.capabilities, -1);
 		ast_log(LOG_ERROR, "Unable to register channel class 'Skinny'\n");
-		return -1;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	ast_rtp_glue_register(&skinny_rtp_glue);
@@ -8706,7 +8729,7 @@ static int load_module(void)
 		ast_channel_unregister(&skinny_tech);
 		ao2_ref(default_cap, -1);
 		ao2_ref(skinny_tech.capabilities, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/channels/chan_unistim.c asterisk-13.17.0/channels/chan_unistim.c
--- asterisk-13.9.1/channels/chan_unistim.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/chan_unistim.c	2017-07-12 13:12:08.000000000 +0200
@@ -163,6 +163,7 @@ enum autoprov_extn {
 #define LED_HEADPHONE_ON		0x011
 #define LED_MUTE_OFF			0x018
 #define LED_MUTE_ON			0x019
+#define LED_MUTE_BLINK			0x1A
 
 #define SIZE_HEADER	     6
 #define SIZE_MAC_ADDR	   17
@@ -359,8 +360,8 @@ struct unistim_subchannel {
 	int softkey;			/*! Softkey assigned */
 	pthread_t ss_thread;		/*! unistim_ss thread handle */
 	int alreadygone;
-	char ringvolume;
-	char ringstyle;
+	signed char ringvolume;
+	signed char ringstyle;
 	int moh;					/*!< Music on hold in progress */
 	AST_LIST_ENTRY(unistim_subchannel) list;
 };
@@ -415,13 +416,13 @@ static struct unistim_device {
 	char maintext2[25];		     /*!< when the phone is idle, display this string on line 2 */
 	char titledefault[13];	  /*!< title (text before date/time) */
 	char datetimeformat;	    /*!< format used for displaying time/date */
-	char contrast;			  /*!< contrast */
+	signed char contrast;			  /*!< contrast */
 	char country[3];			/*!< country used for dial tone frequency */
 	struct ast_tone_zone *tz;	       /*!< Tone zone for res_indications (ring, busy, congestion) */
-	char ringvolume;			/*!< Ring volume */
-	char ringstyle;			 /*!< Ring melody */
-	char cwvolume;			/*!< Ring volume on call waiting */
-	char cwstyle;			 /*!< Ring melody on call waiting */
+	signed char ringvolume;			/*!< Ring volume */
+	signed char ringstyle;			 /*!< Ring melody */
+	signed char cwvolume;			/*!< Ring volume on call waiting */
+	signed char cwstyle;			 /*!< Ring melody on call waiting */
 	int interdigit_timer;		/*!< Interdigit timer for dialing number by timeout */
 	int dtmfduration;		/*!< DTMF playback duration */
 	time_t nextdial;		/*!< Timer used for dial by timeout */
@@ -445,7 +446,7 @@ static struct unistim_device {
 	int nat;					/*!< Used by the obscure ast_rtp_setnat */
 	enum autoprov_extn extension;   /*!< See ifdef EXTENSION for valid values */
 	char extension_number[11];      /*!< Extension number entered by the user */
-	char to_delete;			 /*!< Used in reload */
+	signed char to_delete;			 /*!< Used in reload */
 	struct ast_silence_generator *silence_generator;
 	AST_LIST_HEAD(,unistim_subchannel) subs; /*!< pointer to our current connection, channel... */
 	AST_LIST_HEAD(,unistim_line) lines;
@@ -567,8 +568,10 @@ static const unsigned char packet_send_s
 	{ 0x16, 0x05, 0x1c, 0x00, 0x00 };
 
 static const unsigned char packet_send_mute[] = { 0x16, 0x05, 0x04, 0x00, 0x00 };
+#ifdef NOT_USED
 static const unsigned char packet_send_CloseAudioStreamRX[] = { 0x16, 0x05, 0x31, 0x00, 0xff };
 static const unsigned char packet_send_CloseAudioStreamTX[] = { 0x16, 0x05, 0x31, 0xff, 0x00 };
+#endif
 static const unsigned char packet_send_stream_based_tone_on[] =
 	{ 0x16, 0x06, 0x1b, 0x00, 0x00, 0x05 };
 static const unsigned char packet_send_stream_based_tone_single_freq[] =
@@ -1021,7 +1024,7 @@ static int get_to_address(int fd, struct
 	memcpy(&toAddr->sin_addr, &ip_msg.address, sizeof(struct in_addr));
 	return err;
 #else
-	memcpy(&toAddr, &public_ip, sizeof(&toAddr));
+	memcpy(toAddr, &public_ip, sizeof(*toAddr));
 	return 0;
 #endif
 }
@@ -1701,7 +1704,7 @@ send_select_output(struct unistimsession
 	}
 	pte->device->output = output;
 }
-static void send_ring(struct unistimsession *pte, char volume, char style)
+static void send_ring(struct unistimsession *pte, signed char volume, signed char style)
 {
 	BUFFSEND;
 	if (unistimdebug) {
@@ -4126,7 +4129,7 @@ static void show_main_page(struct unisti
 			send_date_time2(pte);
 			send_idle_clock(pte);
 			if (strlen(pte->device->maintext0)) {
-				send_text(TEXT_LINE0, TEXT_NORMAL, pte, pte->device->maintext0);
+				send_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext(pte->device->maintext0, pte));
 			}
 		} else {
 			if (pte->device->missed_call == 1) {
@@ -4145,11 +4148,11 @@ static void show_main_page(struct unisti
 			strcat(tmpbuf, ast_inet_ntoa(pte->sin.sin_addr));
 			send_text(TEXT_LINE2, TEXT_NORMAL, pte, tmpbuf);
 		} else {
-			send_text(TEXT_LINE2, TEXT_NORMAL, pte, pte->device->maintext2);
+			send_text(TEXT_LINE2, TEXT_NORMAL, pte, ustmtext(pte->device->maintext2, pte));
 		}
 	}
 
-	send_texttitle(pte, pte->device->titledefault);
+	send_texttitle(pte, ustmtext(pte->device->titledefault, pte));
 	change_favorite_icon(pte, FAV_LINE_ICON);
 }
 
@@ -4404,7 +4407,7 @@ static void init_phone_step2(struct unis
 			strcat(tmp, pte->macaddr);
 			send_text(TEXT_LINE2, TEXT_NORMAL, pte, tmp);
 			send_text_status(pte, "");
-			send_texttitle(pte, "UNISTIM for*");
+			send_texttitle(pte, ustmtext("UNISTIM for*", pte));
 			return;
 		}
 	}
@@ -4834,7 +4837,7 @@ static int unistim_call(struct ast_chann
 	int res = 0, i;
 	struct unistim_subchannel *sub, *sub_real;
 	struct unistimsession *session;
-	char ringstyle, ringvolume;
+	signed char ringstyle, ringvolume;
 
 	session = channel_to_session(ast);
 	if (!session) {
@@ -4894,14 +4897,15 @@ static int unistim_hangup_clean(struct a
 	ast_channel_tech_pvt_set(ast, NULL);
 	unistim_set_owner(sub, NULL);
 	sub->alreadygone = 0;
-	ast_mutex_unlock(&sub->lock);
 	if (sub->rtp) {
 		if (unistimdebug) {
 			ast_verb(0, "Destroying RTP session\n");
 		}
+		ast_rtp_instance_stop(sub->rtp);
 		ast_rtp_instance_destroy(sub->rtp);
 		sub->rtp = NULL;
 	}
+	ast_mutex_unlock(&sub->lock);
 	return 0;
 }
 
@@ -5436,8 +5440,8 @@ static struct unistim_subchannel *find_s
 							if ((*at < '0') || (*at > '7')) { /* ring style */
 								ast_log(LOG_WARNING, "Invalid ring selection (%s)", at);
 							} else {
-								char ring_volume = -1;
-								char ring_style = *at - '0';
+								signed char ring_volume = -1;
+								signed char ring_style = *at - '0';
 								at++;
 								if ((*at >= '0') && (*at <= '3')) {      /* ring volume */
 									ring_volume = *at - '0';
@@ -6402,7 +6406,7 @@ static struct unistim_device *build_devi
 	int create = 1;
 	int nbsoftkey, dateformat, timeformat, callhistory, sharpdial, linecnt;
 	char linelabel[AST_MAX_EXTENSION];
-	char ringvolume, ringstyle, cwvolume, cwstyle;
+	signed char ringvolume, ringstyle, cwvolume, cwstyle;
 
 	/* First, we need to know if we already have this name in our list */
 	/* Get a lock for the device chained list */
@@ -7115,7 +7119,7 @@ buff_failed:
 	global_cap = NULL;
 	ao2_cleanup(unistim_tech.capabilities);
 	unistim_tech.capabilities = NULL;
-	return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_DECLINE;
 }
 
 static int unload_module(void)
diff -urpN asterisk-13.9.1/channels/pjsip/cli_commands.c asterisk-13.17.0/channels/pjsip/cli_commands.c
--- asterisk-13.9.1/channels/pjsip/cli_commands.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/pjsip/cli_commands.c	2017-07-12 13:12:08.000000000 +0200
@@ -346,11 +346,10 @@ static int cli_channelstats_print_body(v
 	struct ast_sip_channel_pvt *cpvt = channel ? ast_channel_tech_pvt(channel) : NULL;
 	struct chan_pjsip_pvt *pvt = cpvt ? cpvt->pvt : NULL;
 	struct ast_sip_session_media *media = pvt ? pvt->media[SIP_MEDIA_AUDIO] : NULL;
-	struct ast_rtp_codecs *codecs = media && media->rtp ? ast_rtp_instance_get_codecs(media->rtp) : NULL;
-	struct ast_format *format = codecs ? ast_rtp_codecs_get_payload_format(codecs, 0) : NULL;
 	struct ast_rtp_instance_stats stats;
 	char *print_name = NULL;
 	char *print_time = alloca(32);
+	char codec_in_use[7];
 
 	ast_assert(context->output_buffer != NULL);
 
@@ -360,6 +359,16 @@ static int cli_channelstats_print_body(v
 		return -1;
 	}
 
+	codec_in_use[0] = '\0';
+
+	if (channel) {
+		ast_channel_lock(channel);
+		if (ast_channel_rawreadformat(channel)) {
+			ast_copy_string(codec_in_use, ast_format_get_name(ast_channel_rawreadformat(channel)), sizeof(codec_in_use));
+		}
+		ast_channel_unlock(channel);
+	}
+
 	print_name = ast_strdupa(snapshot->name);
 	/* Skip the PJSIP/.  We know what channel type it is and we need the space. */
 	print_name += 6;
@@ -374,7 +383,7 @@ static int cli_channelstats_print_body(v
 			snapshot->bridgeid,
 			print_name,
 			print_time,
-			format ? ast_format_get_name(format) : "",
+			codec_in_use,
 			stats.rxcount > 100000 ? stats.rxcount / 1000 : stats.rxcount,
 			stats.rxcount > 100000 ? "K": " ",
 			stats.rxploss > 100000 ? stats.rxploss / 1000 : stats.rxploss,
@@ -391,7 +400,6 @@ static int cli_channelstats_print_body(v
 		);
 	}
 
-	ao2_cleanup(format);
 	ao2_cleanup(channel);
 
 	return 0;
diff -urpN asterisk-13.9.1/channels/pjsip/dialplan_functions.c asterisk-13.17.0/channels/pjsip/dialplan_functions.c
--- asterisk-13.9.1/channels/pjsip/dialplan_functions.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/pjsip/dialplan_functions.c	2017-07-12 13:12:08.000000000 +0200
@@ -59,10 +59,57 @@
 		</parameter>
 	</syntax>
 	<description>
-		<para>Returns the codecs offered based upon the media choice</para>
+		<para>When read, returns the codecs offered based upon the media choice.</para>
+		<para>When written, sets the codecs to offer when an outbound dial attempt is made,
+		or when a session refresh is sent using <replaceable>PJSIP_SEND_SESSION_REFRESH</replaceable>.
+		</para>
 	</description>
+	<see-also>
+		<ref type="function">PJSIP_SEND_SESSION_REFRESH</ref>
+	</see-also>
 </function>
-<info name="PJSIPCHANNEL" language="en_US" tech="PJSIP">
+<function name="PJSIP_SEND_SESSION_REFRESH" language="en_US">
+	<synopsis>
+		W/O: Initiate a session refresh via an UPDATE or re-INVITE on an established media session
+	</synopsis>
+	<syntax>
+		<parameter name="update_type" required="false">
+			<para>The type of update to send. Default is <literal>invite</literal>.</para>
+			<enumlist>
+				<enum name="invite">
+					<para>Send the session refresh as a re-INVITE.</para>
+				</enum>
+				<enum name="update">
+					<para>Send the session refresh as an UPDATE.</para>
+				</enum>
+			</enumlist>
+		</parameter>
+	</syntax>
+	<description>
+		<para>This function will cause the PJSIP stack to immediately refresh
+		the media session for the channel. This will be done using either a
+		re-INVITE (default) or an UPDATE request.
+		</para>
+		<para>This is most useful when combined with the <replaceable>PJSIP_MEDIA_OFFER</replaceable>
+		dialplan function, as it allows the formats in use on a channel to be
+		re-negotiated after call setup.</para>
+		<warning>
+			<para>The formats the endpoint supports are <emphasis>not</emphasis>
+			checked or enforced by this function. Using this function to offer
+			formats not supported by the endpoint <emphasis>may</emphasis> result
+			in a loss of media.</para>
+		</warning>
+		<example title="Re-negotiate format to g722">
+		 ; Within some existing extension on an answered channel
+		 same => n,Set(PJSIP_MEDIA_OFFER(audio)=!all,g722)
+		 same => n,Set(PJSIP_SEND_SESSION_REFRESH()=invite)
+		</example>
+	</description>
+	<see-also>
+		<ref type="function">PJSIP_MEDIA_OFFER</ref>
+	</see-also>
+</function>
+<info name="CHANNEL" language="en_US" tech="PJSIP">
 	<enumlist>
 		<enum name="rtp">
 			<para>R/O Retrieve media related information.</para>
@@ -364,6 +411,19 @@
 		</enum>
 	</enumlist>
 </info>
+<info name="CHANNEL_EXAMPLES" language="en_US" tech="PJSIP">
+	<example title="PJSIP specific CHANNEL examples">
+		; Log the current Call-ID
+		same => n,Log(NOTICE, ${CHANNEL(pjsip,call-id)})
+
+		; Log the destination address of the audio stream
+		same => n,Log(NOTICE, ${CHANNEL(rtp,dest)})
+
+		; Store the round-trip time associated with a
+		; video stream in the CDR field video-rtt
+		same => n,Set(CDR(video-rtt)=${CHANNEL(rtcp,rtt,video)})
+	</example>
+</info>
 ***/
 
 #include "asterisk.h"
@@ -662,7 +722,7 @@ static int channel_read_pjsip(struct ast
 
 /*! \brief Struct used to push function arguments to task processor */
 struct pjsip_func_args {
-	struct ast_channel *chan;
+	struct ast_sip_session *session;
 	const char *param;
 	const char *type;
 	const char *field;
@@ -677,49 +737,45 @@ static int read_pjsip(void *data)
 	struct pjsip_func_args *func_args = data;
 
 	if (!strcmp(func_args->param, "rtp")) {
-		func_args->ret = channel_read_rtp(func_args->chan, func_args->type,
+		if (!func_args->session->channel) {
+			func_args->ret = -1;
+			return 0;
+		}
+		func_args->ret = channel_read_rtp(func_args->session->channel, func_args->type,
 		                                  func_args->field, func_args->buf,
 		                                  func_args->len);
 	} else if (!strcmp(func_args->param, "rtcp")) {
-		func_args->ret = channel_read_rtcp(func_args->chan, func_args->type,
+		if (!func_args->session->channel) {
+			func_args->ret = -1;
+			return 0;
+		}
+		func_args->ret = channel_read_rtcp(func_args->session->channel, func_args->type,
 		                                   func_args->field, func_args->buf,
 		                                   func_args->len);
 	} else if (!strcmp(func_args->param, "endpoint")) {
-		struct ast_sip_channel_pvt *pvt = ast_channel_tech_pvt(func_args->chan);
-
-		if (!pvt) {
-			ast_log(AST_LOG_WARNING, "Channel %s has no pvt!\n", ast_channel_name(func_args->chan));
-			return -1;
-		}
-		if (!pvt->session || !pvt->session->endpoint) {
-			ast_log(AST_LOG_WARNING, "Channel %s has no endpoint!\n", ast_channel_name(func_args->chan));
-			return -1;
+		if (!func_args->session->endpoint) {
+			ast_log(AST_LOG_WARNING, "Channel %s has no endpoint!\n", func_args->session->channel ?
+				ast_channel_name(func_args->session->channel) : "<unknown>");
+			func_args->ret = -1;
+			return 0;
 		}
-		snprintf(func_args->buf, func_args->len, "%s", ast_sorcery_object_get_id(pvt->session->endpoint));
+		snprintf(func_args->buf, func_args->len, "%s", ast_sorcery_object_get_id(func_args->session->endpoint));
 	} else if (!strcmp(func_args->param, "contact")) {
-		struct ast_sip_channel_pvt *pvt = ast_channel_tech_pvt(func_args->chan);
-
-		if (!pvt) {
-			ast_log(AST_LOG_WARNING, "Channel %s has no pvt!\n", ast_channel_name(func_args->chan));
-			return -1;
-		}
-		if (!pvt->session || !pvt->session->contact) {
+		if (!func_args->session->contact) {
 			return 0;
 		}
-		snprintf(func_args->buf, func_args->len, "%s", ast_sorcery_object_get_id(pvt->session->contact));
+		snprintf(func_args->buf, func_args->len, "%s", ast_sorcery_object_get_id(func_args->session->contact));
 	} else if (!strcmp(func_args->param, "aor")) {
-		struct ast_sip_channel_pvt *pvt = ast_channel_tech_pvt(func_args->chan);
-
-		if (!pvt) {
-			ast_log(AST_LOG_WARNING, "Channel %s has no pvt!\n", ast_channel_name(func_args->chan));
-			return -1;
-		}
-		if (!pvt->session || !pvt->session->aor) {
+		if (!func_args->session->aor) {
 			return 0;
 		}
-		snprintf(func_args->buf, func_args->len, "%s", ast_sorcery_object_get_id(pvt->session->aor));
+		snprintf(func_args->buf, func_args->len, "%s", ast_sorcery_object_get_id(func_args->session->aor));
 	} else if (!strcmp(func_args->param, "pjsip")) {
-		func_args->ret = channel_read_pjsip(func_args->chan, func_args->type,
+		if (!func_args->session->channel) {
+			func_args->ret = -1;
+			return 0;
+		}
+		func_args->ret = channel_read_pjsip(func_args->session->channel, func_args->type,
 		                                    func_args->field, func_args->buf,
 		                                    func_args->len);
 	} else {
@@ -746,7 +802,6 @@ int pjsip_acf_channel_read(struct ast_ch
 		ast_log(LOG_WARNING, "No channel was provided to %s function.\n", cmd);
 		return -1;
 	}
-	channel = ast_channel_tech_pvt(chan);
 
 	/* Check for zero arguments */
 	if (ast_strlen_zero(parse)) {
@@ -756,29 +811,44 @@ int pjsip_acf_channel_read(struct ast_ch
 
 	AST_STANDARD_APP_ARGS(args, parse);
 
+	ast_channel_lock(chan);
+
 	/* Sanity check */
 	if (strcmp(ast_channel_tech(chan)->type, "PJSIP")) {
 		ast_log(LOG_WARNING, "Cannot call %s on a non-PJSIP channel\n", cmd);
+		ast_channel_unlock(chan);
 		return 0;
 	}
 
+	channel = ast_channel_tech_pvt(chan);
 	if (!channel) {
-		ast_log(AST_LOG_WARNING, "Channel %s has no pvt!\n", ast_channel_name(chan));
+		ast_log(LOG_WARNING, "Channel %s has no pvt!\n", ast_channel_name(chan));
+		ast_channel_unlock(chan);
+		return -1;
+	}
+
+	if (!channel->session) {
+		ast_log(LOG_WARNING, "Channel %s has no session\n", ast_channel_name(chan));
+		ast_channel_unlock(chan);
 		return -1;
 	}
 
+	func_args.session = ao2_bump(channel->session);
+	ast_channel_unlock(chan);
+
 	memset(buf, 0, len);
 
-	func_args.chan = chan;
 	func_args.param = args.param;
 	func_args.type = args.type;
 	func_args.field = args.field;
 	func_args.buf = buf;
 	func_args.len = len;
-	if (ast_sip_push_task_synchronous(channel->session->serializer, read_pjsip, &func_args)) {
+	if (ast_sip_push_task_synchronous(func_args.session->serializer, read_pjsip, &func_args)) {
 		ast_log(LOG_WARNING, "Unable to read properties of channel %s: failed to push task\n", ast_channel_name(chan));
+		ao2_ref(func_args.session, -1);
 		return -1;
 	}
+	ao2_ref(func_args.session, -1);
 
 	return func_args.ret;
 }
@@ -828,7 +898,7 @@ int pjsip_acf_dial_contacts_read(struct
 		if (!aor) {
 			/* If the AOR provided is not found skip it, there may be more */
 			continue;
-		} else if (!(contacts = ast_sip_location_retrieve_aor_contacts(aor))) {
+		} else if (!(contacts = ast_sip_location_retrieve_aor_contacts_filtered(aor, AST_SIP_CONTACT_FILTER_REACHABLE))) {
 			/* No contacts are available, skip it as well */
 			continue;
 		} else if (!ao2_container_count(contacts)) {
@@ -859,36 +929,40 @@ int pjsip_acf_dial_contacts_read(struct
 static int media_offer_read_av(struct ast_sip_session *session, char *buf,
 			       size_t len, enum ast_media_type media_type)
 {
-	int i, size = 0;
+	int idx;
+	size_t accum = 0;
 
-	for (i = 0; i < ast_format_cap_count(session->req_caps); i++) {
-		struct ast_format *fmt = ast_format_cap_get_format(session->req_caps, i);
+	/* Note: buf is not terminated while the string is being built. */
+	for (idx = 0; idx < ast_format_cap_count(session->req_caps); ++idx) {
+		struct ast_format *fmt;
+		size_t size;
 
+		fmt = ast_format_cap_get_format(session->req_caps, idx);
 		if (ast_format_get_type(fmt) != media_type) {
 			ao2_ref(fmt, -1);
 			continue;
 		}
 
-		/* add one since we'll include a comma */
+		/* Add one for a comma or terminator */
 		size = strlen(ast_format_get_name(fmt)) + 1;
 		if (len < size) {
 			ao2_ref(fmt, -1);
 			break;
 		}
-		len -= size;
-
-		/* no reason to use strncat here since we have already ensured buf has
-                   enough space, so strcat can be safely used */
-		strcat(buf, ast_format_get_name(fmt));
-		strcat(buf, ",");
 
+		/* Append the format name */
+		strcpy(buf + accum, ast_format_get_name(fmt));/* Safe */
 		ao2_ref(fmt, -1);
-	}
 
-	if (size) {
-		/* remove the extra comma */
-		buf[strlen(buf) - 1] = '\0';
+		accum += size;
+		len -= size;
+
+		/* The last comma on the built string will be set to the terminator. */
+		buf[accum - 1] = ',';
 	}
+
+	/* Remove the trailing comma or terminate an empty buffer. */
+	buf[accum ? accum - 1 : 0] = '\0';
 	return 0;
 }
 
@@ -928,6 +1002,9 @@ int pjsip_acf_media_offer_read(struct as
 		return media_offer_read_av(channel->session, buf, len, AST_MEDIA_TYPE_AUDIO);
 	} else if (!strcmp(data, "video")) {
 		return media_offer_read_av(channel->session, buf, len, AST_MEDIA_TYPE_VIDEO);
+	} else {
+		/* Ensure that the buffer is empty */
+		buf[0] = '\0';
 	}
 
 	return 0;
@@ -961,3 +1038,70 @@ int pjsip_acf_media_offer_write(struct a
 
 	return ast_sip_push_task_synchronous(channel->session->serializer, media_offer_write_av, &mdata);
 }
+
+struct refresh_data {
+	struct ast_sip_session *session;
+	enum ast_sip_session_refresh_method method;
+};
+
+static int sip_session_response_cb(struct ast_sip_session *session, pjsip_rx_data *rdata)
+{
+	struct ast_format *fmt;
+
+	if (!session->channel) {
+		/* Egads! */
+		return 0;
+	}
+
+	fmt = ast_format_cap_get_best_by_type(ast_channel_nativeformats(session->channel), AST_MEDIA_TYPE_AUDIO);
+	if (!fmt) {
+		/* No format? That's weird. */
+		return 0;
+	}
+	ast_channel_set_writeformat(session->channel, fmt);
+	ast_channel_set_rawwriteformat(session->channel, fmt);
+	ast_channel_set_readformat(session->channel, fmt);
+	ast_channel_set_rawreadformat(session->channel, fmt);
+	ao2_ref(fmt, -1);
+
+	return 0;
+}
+
+static int refresh_write_cb(void *obj)
+{
+	struct refresh_data *data = obj;
+
+	ast_sip_session_refresh(data->session, NULL, NULL,
+		sip_session_response_cb, data->method, 1);
+
+	return 0;
+}
+
+int pjsip_acf_session_refresh_write(struct ast_channel *chan, const char *cmd, char *data, const char *value)
+{
+	struct ast_sip_channel_pvt *channel;
+	struct refresh_data rdata = {
+		.method = AST_SIP_SESSION_REFRESH_METHOD_INVITE,
+	};
+
+	if (!chan) {
+		ast_log(LOG_WARNING, "No channel was provided to %s function.\n", cmd);
+		return -1;
+	}
+
+	if (strcmp(ast_channel_tech(chan)->type, "PJSIP")) {
+		ast_log(LOG_WARNING, "Cannot call %s on a non-PJSIP channel\n", cmd);
+		return -1;
+	}
+
+	channel = ast_channel_tech_pvt(chan);
+	rdata.session = channel->session;
+
+	if (!strcmp(value, "invite")) {
+		rdata.method = AST_SIP_SESSION_REFRESH_METHOD_INVITE;
+	} else if (!strcmp(value, "update")) {
+		rdata.method = AST_SIP_SESSION_REFRESH_METHOD_UPDATE;
+	}
+
+	return ast_sip_push_task_synchronous(channel->session->serializer, refresh_write_cb, &rdata);
+}
diff -urpN asterisk-13.9.1/channels/pjsip/include/dialplan_functions.h asterisk-13.17.0/channels/pjsip/include/dialplan_functions.h
--- asterisk-13.9.1/channels/pjsip/include/dialplan_functions.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/pjsip/include/dialplan_functions.h	2017-07-12 13:12:08.000000000 +0200
@@ -61,6 +61,18 @@ int pjsip_acf_media_offer_write(struct a
 int pjsip_acf_media_offer_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len);
 
 /*!
+ * \brief PJSIP_SEND_SESSION_REFRESH function write callback
+ * \param chan The channel the function is called on
+ * \param cmd the Name of the function
+ * \param data Arguments passed to the function
+ * \param value Value to be set by the function
+ *
+ * \retval 0 on success
+ * \retval -1 on failure
+ */
+int pjsip_acf_session_refresh_write(struct ast_channel *chan, const char *cmd, char *data, const char *value);
+
+/*!
  * \brief PJSIP_DIAL_CONTACTS function read callback
  * \param chan The channel the function is called on
  * \param cmd The name of the function
diff -urpN asterisk-13.9.1/channels/sip/config_parser.c asterisk-13.17.0/channels/sip/config_parser.c
--- asterisk-13.9.1/channels/sip/config_parser.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/sip/config_parser.c	2017-07-12 13:12:08.000000000 +0200
@@ -274,6 +274,7 @@ int sip_parse_register_line(struct sip_r
 	return 0;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(sip_parse_register_line_test)
 {
 	int res = AST_TEST_PASS;
@@ -643,6 +644,7 @@ alloc_fail:
 	ast_test_status_update(test, "Out of memory. \n");
 	return res;
 }
+#endif
 
 int sip_parse_host(char *line, int lineno, char **hostname, int *portnum, enum ast_transport *transport)
 {
@@ -708,6 +710,7 @@ int sip_parse_host(char *line, int linen
 	return 0;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(sip_parse_host_line_test)
 {
 	int res = AST_TEST_PASS;
@@ -787,6 +790,7 @@ AST_TEST_DEFINE(sip_parse_host_line_test
 	return res;
 
 }
+#endif
 
 /*! \brief Parse the comma-separated nat= option values */
 void sip_parse_nat_option(const char *value, struct ast_flags *mask, struct ast_flags *flags)
@@ -834,6 +838,7 @@ void sip_parse_nat_option(const char *va
 	}
 }
 
+#ifdef TEST_FRAMEWORK
 #define TEST_FORCE_RPORT      1 << 0
 #define TEST_COMEDIA          1 << 1
 #define TEST_AUTO_FORCE_RPORT 1 << 2
@@ -904,6 +909,8 @@ AST_TEST_DEFINE(sip_parse_nat_test)
 
 	return res;
 }
+#endif
+
 /*! \brief SIP test registration */
 void sip_config_parser_register_tests(void)
 {
diff -urpN asterisk-13.9.1/channels/sip/dialplan_functions.c asterisk-13.17.0/channels/sip/dialplan_functions.c
--- asterisk-13.9.1/channels/sip/dialplan_functions.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/sip/dialplan_functions.c	2017-07-12 13:12:08.000000000 +0200
@@ -23,6 +23,88 @@
 	<support_level>extended</support_level>
  ***/
 
+/*** DOCUMENTATION
+<info name="CHANNEL" language="en_US" tech="SIP">
+	<enumlist>
+		<enum name="peerip">
+			<para>R/O Get the IP address of the peer.</para>
+		</enum>
+		<enum name="recvip">
+			<para>R/O Get the source IP address of the peer.</para>
+		</enum>
+		<enum name="recvport">
+			<para>R/O Get the source port of the peer.</para>
+		</enum>
+		<enum name="from">
+			<para>R/O Get the URI from the From: header.</para>
+		</enum>
+		<enum name="uri">
+			<para>R/O Get the URI from the Contact: header.</para>
+		</enum>
+		<enum name="useragent">
+			<para>R/O Get the useragent.</para>
+		</enum>
+		<enum name="peername">
+			<para>R/O Get the name of the peer.</para>
+		</enum>
+		<enum name="t38passthrough">
+			<para>R/O <literal>1</literal> if T38 is offered or enabled in this channel,
+			otherwise <literal>0</literal></para>
+		</enum>
+		<enum name="rtpqos">
+			<para>R/O Get QOS information about the RTP stream</para>
+			<para>    This option takes two additional arguments:</para>
+			<para>    Argument 1:</para>
+			<para>     <literal>audio</literal>             Get data about the audio stream</para>
+			<para>     <literal>video</literal>             Get data about the video stream</para>
+			<para>     <literal>text</literal>              Get data about the text stream</para>
+			<para>    Argument 2:</para>
+			<para>     <literal>local_ssrc</literal>        Local SSRC (stream ID)</para>
+			<para>     <literal>local_lostpackets</literal> Local lost packets</para>
+			<para>     <literal>local_jitter</literal>      Local calculated jitter</para>
+			<para>     <literal>local_maxjitter</literal>   Local calculated jitter (maximum)</para>
+			<para>     <literal>local_minjitter</literal>   Local calculated jitter (minimum)</para>
+			<para>     <literal>local_normdevjitter</literal>Local calculated jitter (normal deviation)</para>
+			<para>     <literal>local_stdevjitter</literal> Local calculated jitter (standard deviation)</para>
+			<para>     <literal>local_count</literal>       Number of received packets</para>
+			<para>     <literal>remote_ssrc</literal>       Remote SSRC (stream ID)</para>
+			<para>     <literal>remote_lostpackets</literal>Remote lost packets</para>
+			<para>     <literal>remote_jitter</literal>     Remote reported jitter</para>
+			<para>     <literal>remote_maxjitter</literal>  Remote calculated jitter (maximum)</para>
+			<para>     <literal>remote_minjitter</literal>  Remote calculated jitter (minimum)</para>
+			<para>     <literal>remote_normdevjitter</literal>Remote calculated jitter (normal deviation)</para>
+			<para>     <literal>remote_stdevjitter</literal>Remote calculated jitter (standard deviation)</para>
+			<para>     <literal>remote_count</literal>      Number of transmitted packets</para>
+			<para>     <literal>rtt</literal>               Round trip time</para>
+			<para>     <literal>maxrtt</literal>            Round trip time (maximum)</para>
+			<para>     <literal>minrtt</literal>            Round trip time (minimum)</para>
+			<para>     <literal>normdevrtt</literal>        Round trip time (normal deviation)</para>
+			<para>     <literal>stdevrtt</literal>          Round trip time (standard deviation)</para>
+			<para>     <literal>all</literal>               All statistics (in a form suited to logging,
+			but not for parsing)</para>
+		</enum>
+		<enum name="rtpdest">
+			<para>R/O Get remote RTP destination information.</para>
+			<para>   This option takes one additional argument:</para>
+			<para>    Argument 1:</para>
+			<para>     <literal>audio</literal>             Get audio destination</para>
+			<para>     <literal>video</literal>             Get video destination</para>
+			<para>     <literal>text</literal>              Get text destination</para>
+			<para>   Defaults to <literal>audio</literal> if unspecified.</para>
+		</enum>
+		<enum name="rtpsource">
+			<para>R/O Get source RTP destination information.</para>
+			<para>   This option takes one additional argument:</para>
+			<para>    Argument 1:</para>
+			<para>     <literal>audio</literal>             Get audio destination</para>
+			<para>     <literal>video</literal>             Get video destination</para>
+			<para>     <literal>text</literal>              Get text destination</para>
+			<para>   Defaults to <literal>audio</literal> if unspecified.</para>
+		</enum>
+	</enumlist>
+</info>
+ ***/
+
 #include "asterisk.h"
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
diff -urpN asterisk-13.9.1/channels/sip/include/sip.h asterisk-13.17.0/channels/sip/include/sip.h
--- asterisk-13.9.1/channels/sip/include/sip.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/sip/include/sip.h	2017-07-12 13:12:08.000000000 +0200
@@ -384,11 +384,12 @@
 #define SIP_PAGE3_IGNORE_PREFCAPS        (1 << 7)  /*!< DP: Ignore prefcaps when setting up an outgoing call leg */
 #define SIP_PAGE3_DISCARD_REMOTE_HOLD_RETRIEVAL  (1 << 8)  /*!< DGP: Stop telling the peer to start music on hold */
 #define SIP_PAGE3_FORCE_AVP              (1 << 9)  /*!< DGP: Force 'RTP/AVP' for all streams, even DTLS */
+#define SIP_PAGE3_RTCP_MUX               (1 << 10) /*!< DGP: Attempt to negotiate RFC 5761 RTCP multiplexing */
 
 #define SIP_PAGE3_FLAGS_TO_COPY \
 	(SIP_PAGE3_SNOM_AOC | SIP_PAGE3_SRTP_TAG_32 | SIP_PAGE3_NAT_AUTO_RPORT | SIP_PAGE3_NAT_AUTO_COMEDIA | \
 	 SIP_PAGE3_DIRECT_MEDIA_OUTGOING | SIP_PAGE3_USE_AVPF | SIP_PAGE3_ICE_SUPPORT | SIP_PAGE3_IGNORE_PREFCAPS | \
-	 SIP_PAGE3_DISCARD_REMOTE_HOLD_RETRIEVAL | SIP_PAGE3_FORCE_AVP)
+	 SIP_PAGE3_DISCARD_REMOTE_HOLD_RETRIEVAL | SIP_PAGE3_FORCE_AVP | SIP_PAGE3_RTCP_MUX)
 
 #define CHECK_AUTH_BUF_INITLEN   256
 
@@ -1230,6 +1231,12 @@ struct sip_pkt {
 	struct ast_str *data;
 };
 
+enum sip_mailbox_status {
+	SIP_MAILBOX_STATUS_UNKNOWN = 0,
+	SIP_MAILBOX_STATUS_EXISTING,
+	SIP_MAILBOX_STATUS_NEW,
+};
+
 /*!
  * \brief A peer's mailbox
  *
@@ -1240,7 +1247,8 @@ struct sip_mailbox {
 	/*! Associated MWI subscription */
 	struct stasis_subscription *event_sub;
 	AST_LIST_ENTRY(sip_mailbox) entry;
-	unsigned int delme:1;
+	struct sip_peer *peer;
+	enum sip_mailbox_status status;
 	char id[1];
 };
 
diff -urpN asterisk-13.9.1/channels/sip/reqresp_parser.c asterisk-13.17.0/channels/sip/reqresp_parser.c
--- asterisk-13.9.1/channels/sip/reqresp_parser.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/channels/sip/reqresp_parser.c	2017-07-12 13:12:08.000000000 +0200
@@ -258,7 +258,7 @@ int parse_uri_full(char *uri, const char
 	return error;
 }
 
-
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(sip_parse_uri_full_test)
 {
 	int res = AST_TEST_PASS;
@@ -514,7 +514,7 @@ AST_TEST_DEFINE(sip_parse_uri_full_test)
 
 	return res;
 }
-
+#endif
 
 int parse_uri(char *uri, const char *scheme, char **user, char **pass,
 	      char **hostport, char **transport) {
@@ -530,6 +530,7 @@ int parse_uri(char *uri, const char *sch
 	return ret;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(sip_parse_uri_test)
 {
 	int res = AST_TEST_PASS;
@@ -687,6 +688,7 @@ AST_TEST_DEFINE(sip_parse_uri_test)
 
 	return res;
 }
+#endif
 
 /*! \brief  Get caller id name from SIP headers, copy into output buffer
  *
@@ -817,6 +819,7 @@ const char *get_calleridname(const char
 	return input;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(get_calleridname_test)
 {
 	int res = AST_TEST_PASS;
@@ -899,6 +902,7 @@ AST_TEST_DEFINE(get_calleridname_test)
 
 	return res;
 }
+#endif
 
 int get_name_and_number(const char *hdr, char **name, char **number)
 {
@@ -940,6 +944,7 @@ int get_name_and_number(const char *hdr,
 	return 0;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(get_name_and_number_test)
 {
 	int res = AST_TEST_PASS;
@@ -1044,6 +1049,7 @@ AST_TEST_DEFINE(get_name_and_number_test
 
 	return res;
 }
+#endif
 
 int get_in_brackets_const(const char *src,const char **start,int *length)
 {
@@ -1176,6 +1182,7 @@ char *get_in_brackets(char *tmp)
 	return out;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(get_in_brackets_test)
 {
 	int res = AST_TEST_PASS;
@@ -1252,7 +1259,7 @@ AST_TEST_DEFINE(get_in_brackets_test)
 
 	return res;
 }
-
+#endif
 
 int parse_name_andor_addr(char *uri, const char *scheme, char **name,
 			  char **user, char **pass, char **hostport,
@@ -1298,6 +1305,7 @@ int parse_name_andor_addr(char *uri, con
 	return parse_uri_full(uri, scheme, user, pass, hostport, params, headers, residue2);
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(parse_name_andor_addr_test)
 {
 	int res = AST_TEST_PASS;
@@ -1427,6 +1435,7 @@ AST_TEST_DEFINE(parse_name_andor_addr_te
 
 	return res;
 }
+#endif
 
 int get_comma(char *in, char **out)
 {
@@ -1523,6 +1532,7 @@ int parse_contact_header(char *contacthe
 	return last;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(parse_contact_header_test)
 {
 	int res = AST_TEST_PASS;
@@ -1668,6 +1678,7 @@ AST_TEST_DEFINE(parse_contact_header_tes
 
 	return res;
 }
+#endif
 
 /*!
  * \brief Parse supported header in incoming packet
@@ -1755,6 +1766,7 @@ unsigned int parse_sip_options(const cha
 	return profile;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(sip_parse_options_test)
 {
 	int res = AST_TEST_PASS;
@@ -1892,6 +1904,7 @@ AST_TEST_DEFINE(sip_parse_options_test)
 
 	return res;
 }
+#endif
 
 /*! \brief helper routine for sip_uri_cmp to compare URI parameters
  *
@@ -2246,6 +2259,7 @@ int sip_uri_cmp(const char *input1, cons
 #define URI_CMP_MATCH 0
 #define URI_CMP_NOMATCH 1
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(sip_uri_cmp_test)
 {
 	static const struct {
@@ -2362,6 +2376,7 @@ AST_TEST_DEFINE(sip_uri_cmp_test)
 
 	return test_res;
 }
+#endif
 
 void free_via(struct sip_via *v)
 {
@@ -2448,6 +2463,7 @@ struct sip_via *parse_via(const char *he
 	return v;
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(parse_via_test)
 {
 	int res = AST_TEST_PASS;
@@ -2625,6 +2641,7 @@ AST_TEST_DEFINE(parse_via_test)
 	}
 	return res;
 }
+#endif
 
 void sip_request_parser_register_tests(void)
 {
diff -urpN asterisk-13.9.1/codecs/Makefile asterisk-13.17.0/codecs/Makefile
--- asterisk-13.9.1/codecs/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -38,7 +38,7 @@ include $(ASTTOPDIR)/Makefile.moddir_rul
 ifneq ($(GSM_INTERNAL),no)
 GSM_INCLUDE := -I$(SUB_GSM)/inc
 
-$(if $(filter codec_gsm,$(EMBEDDED_MODS)),modules.link,codec_gsm.so): $(SUB_GSM)/lib/libgsm.a
+codec_gsm.so: $(SUB_GSM)/lib/libgsm.a
 endif
 
 # Don't run the implicit rules for this target.
@@ -59,7 +59,7 @@ clean::
 .PHONY: $(SUB_DIRS)
 
 
-$(if $(filter codec_lpc10,$(EMBEDDED_MODS)),modules.link,codec_lpc10.so): $(LIBLPC10)
+codec_lpc10.so: $(LIBLPC10)
 
 # Don't run the implicit rules for this target.
 $(LIBLPC10): $(SUB_LPC10) ;
@@ -69,7 +69,7 @@ $(SUB_LPC10):
 
 
 ifneq ($(ILBC_INTERNAL),no)
-$(if $(filter codec_ilbc,$(EMBEDDED_MODS)),modules.link,codec_ilbc.so): $(LIBILBC)
+codec_ilbc.so: $(LIBILBC)
 else
 ILBC_INCLUDE += -DILBC_WEBRTC
 endif
@@ -81,7 +81,7 @@ $(SUB_ILBC):
 	@$(MAKE) -C $(SUB_ILBC) all _ASTCFLAGS="$(filter-out -Wmissing-prototypes -Wmissing-declarations -Wshadow,$(_ASTCFLAGS)) $(AST_NO_STRICT_OVERFLOW)"
 
 
-$(if $(filter codec_g722,$(EMBEDDED_MODS)),modules.link,codec_g722.so): g722/g722_encode.o g722/g722_decode.o
+codec_g722.so: g722/g722_encode.o g722/g722_decode.o
 
 g722/g722_encode.o g722/g722_decode.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,codec_g722)
 
@@ -92,6 +92,6 @@ else
 SPEEX_RESAMPLE_CFLAGS:=
 endif
 
-$(if $(filter codec_resample,$(EMBEDDED_MODS)),modules.link,codec_resample.so): speex/resample.o
+codec_resample.so: speex/resample.o
 
 speex/resample.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,codec_resample) $(SPEEX_RESAMPLE_CFLAGS)
diff -urpN asterisk-13.9.1/codecs/codec_a_mu.c asterisk-13.17.0/codecs/codec_a_mu.c
--- asterisk-13.9.1/codecs/codec_a_mu.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_a_mu.c	2017-07-12 13:12:08.000000000 +0200
@@ -143,7 +143,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_adpcm.c asterisk-13.17.0/codecs/codec_adpcm.c
--- asterisk-13.9.1/codecs/codec_adpcm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_adpcm.c	2017-07-12 13:12:08.000000000 +0200
@@ -348,7 +348,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_alaw.c asterisk-13.17.0/codecs/codec_alaw.c
--- asterisk-13.9.1/codecs/codec_alaw.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_alaw.c	2017-07-12 13:12:08.000000000 +0200
@@ -132,7 +132,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_dahdi.c asterisk-13.17.0/codecs/codec_dahdi.c
--- asterisk-13.9.1/codecs/codec_dahdi.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_dahdi.c	2017-07-12 13:12:08.000000000 +0200
@@ -36,11 +36,11 @@
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
+#include <poll.h>
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
 #include <dahdi/user.h>
 
 #include "asterisk/lock.h"
diff -urpN asterisk-13.9.1/codecs/codec_g722.c asterisk-13.17.0/codecs/codec_g722.c
--- asterisk-13.9.1/codecs/codec_g722.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_g722.c	2017-07-12 13:12:08.000000000 +0200
@@ -243,7 +243,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}	
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_g726.c asterisk-13.17.0/codecs/codec_g726.c
--- asterisk-13.9.1/codecs/codec_g726.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_g726.c	2017-07-12 13:12:08.000000000 +0200
@@ -892,7 +892,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}	
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_gsm.c asterisk-13.17.0/codecs/codec_gsm.c
--- asterisk-13.9.1/codecs/codec_gsm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_gsm.c	2017-07-12 13:12:08.000000000 +0200
@@ -241,7 +241,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_ilbc.c asterisk-13.17.0/codecs/codec_ilbc.c
--- asterisk-13.9.1/codecs/codec_ilbc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_ilbc.c	2017-07-12 13:12:08.000000000 +0200
@@ -248,7 +248,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_lpc10.c asterisk-13.17.0/codecs/codec_lpc10.c
--- asterisk-13.9.1/codecs/codec_lpc10.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_lpc10.c	2017-07-12 13:12:08.000000000 +0200
@@ -274,7 +274,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_resample.c asterisk-13.17.0/codecs/codec_resample.c
--- asterisk-13.9.1/codecs/codec_resample.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_resample.c	2017-07-12 13:12:08.000000000 +0200
@@ -155,7 +155,7 @@ static int load_module(void)
 
 	trans_size = ARRAY_LEN(codec_list) * (ARRAY_LEN(codec_list) - 1);
 	if (!(translators = ast_calloc(1, sizeof(struct ast_translator) * trans_size))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	for (x = 0; x < ARRAY_LEN(codec_list); x++) {
@@ -182,7 +182,7 @@ static int load_module(void)
 	ast_unregister_translator won't fail.*/
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codec_ulaw.c asterisk-13.17.0/codecs/codec_ulaw.c
--- asterisk-13.9.1/codecs/codec_ulaw.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/codecs/codec_ulaw.c	2017-07-12 13:12:08.000000000 +0200
@@ -183,7 +183,7 @@ static int load_module(void)
 
 	if (res) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/codecs/codecs.xml asterisk-13.17.0/codecs/codecs.xml
--- asterisk-13.9.1/codecs/codecs.xml	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/codecs/codecs.xml	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+<member name="codec_opus" displayname="Download the Opus codec from Digium.  See http://downloads.digium.com/pub/telephony/codec_opus/README.">
+	<support_level>external</support_level>
+	<depend>xmlstarlet</depend>
+	<depend>bash</depend>
+	<depend>res_format_attr_opus</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="codec_silk" displayname="Download the SILK codec from Digium.  See http://downloads.digium.com/pub/telephony/codec_silk/README.">
+	<support_level>external</support_level>
+	<depend>xmlstarlet</depend>
+	<depend>bash</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="codec_siren7" displayname="Download the Siren7 codec from Digium.  See http://downloads.digium.com/pub/telephony/codec_siren7/README.">
+	<support_level>external</support_level>
+	<depend>xmlstarlet</depend>
+	<depend>bash</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="codec_siren14" displayname="Download the Siren14 codec from Digium.  See http://downloads.digium.com/pub/telephony/codec_siren14/README.">
+	<support_level>external</support_level>
+	<depend>xmlstarlet</depend>
+	<depend>bash</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="codec_g729a" displayname="Download the g729a codec from Digium.  A license must be purchased for this codec.  See http://downloads.digium.com/pub/telephony/codec_g729/README.">
+	<support_level>external</support_level>
+	<depend>xmlstarlet</depend>
+	<depend>bash</depend>
+	<defaultenabled>no</defaultenabled>
+	<member_data><downloader directory_name="codec_g729"/></member_data>
+</member>
diff -urpN asterisk-13.9.1/config.guess asterisk-13.17.0/config.guess
--- asterisk-13.9.1/config.guess	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/config.guess	2017-07-12 13:12:08.000000000 +0200
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2014 Free Software Foundation, Inc.
+#   Copyright 1992-2017 Free Software Foundation, Inc.
 
-timestamp='2014-03-23'
+timestamp='2017-03-05'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -24,12 +24,12 @@ timestamp='2014-03-23'
 # program.  This Exception is an additional permission under section 7
 # of the GNU General Public License, version 3 ("GPLv3").
 #
-# Originally written by Per Bothner.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 #
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 
 
 me=`echo "$0" | sed -e 's,.*/,,'`
@@ -50,7 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2014 Free Software Foundation, Inc.
+Copyright 1992-2017 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -168,19 +168,29 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
+	# to ELF recently (or will in the future) and ABI.
 	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -197,6 +207,13 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -207,13 +224,13 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
 	exit ;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
@@ -223,6 +240,10 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-libertybsd${UNAME_RELEASE}
+	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
 	exit ;;
@@ -235,6 +256,9 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
     *:MirBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
+    *:Sortix:*:*)
+	echo ${UNAME_MACHINE}-unknown-sortix
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -251,42 +275,42 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
@@ -359,16 +383,16 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
 	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -393,7 +417,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
@@ -579,8 +603,9 @@ EOF
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -617,13 +642,13 @@ EOF
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
 		    case "${sc_cpu_version}" in
-		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
 			case "${sc_kernel_bits}" in
-			  32) HP_ARCH="hppa2.0n" ;;
-			  64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
@@ -662,11 +687,11 @@ EOF
 		    exit (0);
 		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ ${HP_ARCH} = hppa2.0w ]
 	then
 	    eval $set_cc_for_build
 
@@ -679,12 +704,12 @@ EOF
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
@@ -789,14 +814,14 @@ EOF
 	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
@@ -812,10 +837,11 @@ EOF
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
 	case ${UNAME_PROCESSOR} in
 	    amd64)
-		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    *)
-		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
 	esac
+	echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
 	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
@@ -878,7 +904,7 @@ EOF
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
@@ -901,7 +927,7 @@ EOF
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arc:Linux:*:* | arceb:Linux:*:*)
@@ -932,6 +958,9 @@ EOF
     crisv32:Linux:*:*)
 	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     frv:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
@@ -944,6 +973,9 @@ EOF
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
+    k1om:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     m32r*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
@@ -969,6 +1001,9 @@ EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
+    mips64el:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     openrisc*:Linux:*:*)
 	echo or1k-unknown-linux-${LIBC}
 	exit ;;
@@ -1001,6 +1036,9 @@ EOF
     ppcle:Linux:*:*)
 	echo powerpcle-unknown-linux-${LIBC}
 	exit ;;
+    riscv32:Linux:*:* | riscv64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
@@ -1020,7 +1058,7 @@ EOF
 	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
@@ -1099,7 +1137,7 @@ EOF
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
 	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
 	exit ;;
@@ -1248,6 +1286,9 @@ EOF
     SX-8R:SUPER-UX:*:*)
 	echo sx8r-nec-superux${UNAME_RELEASE}
 	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
@@ -1261,9 +1302,9 @@ EOF
 	    UNAME_PROCESSOR=powerpc
 	fi
 	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
-	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		    grep IS_64BIT_ARCH >/dev/null
 		then
 		    case $UNAME_PROCESSOR in
@@ -1285,7 +1326,7 @@ EOF
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
@@ -1303,6 +1344,9 @@ EOF
     NSR-?:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
 	exit ;;
+    NSX-?:NONSTOP_KERNEL:*:*)
+	echo nsx-tandem-nsk${UNAME_RELEASE}
+	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
 	exit ;;
@@ -1316,7 +1360,7 @@ EOF
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
@@ -1358,7 +1402,7 @@ EOF
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
 	exit ;;
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
@@ -1369,23 +1413,25 @@ EOF
     x86_64:VMkernel:*:*)
 	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
+	exit ;;
 esac
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite
+config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
diff -urpN asterisk-13.9.1/config.sub asterisk-13.17.0/config.sub
--- asterisk-13.9.1/config.sub	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/config.sub	2017-07-12 13:12:08.000000000 +0200
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2014 Free Software Foundation, Inc.
+#   Copyright 1992-2017 Free Software Foundation, Inc.
 
-timestamp='2014-05-01'
+timestamp='2017-04-02'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@ timestamp='2014-05-01'
 # of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -33,7 +33,7 @@ timestamp='2014-05-01'
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -53,8 +53,7 @@ timestamp='2014-05-01'
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
 
 Canonicalize a configuration name.
 
@@ -68,7 +67,7 @@ Report bugs and patches to <config-patch
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2014 Free Software Foundation, Inc.
+Copyright 1992-2017 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -117,8 +116,8 @@ maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
-  kopensolaris*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
+  kopensolaris*-gnu* | cloudabi*-eabi* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
@@ -255,15 +254,16 @@ case $basic_machine in
 	| arc | arceb \
 	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
 	| avr | avr32 \
+	| ba \
 	| be32 | be64 \
 	| bfin \
 	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
-	| i370 | i860 | i960 | ia64 \
+	| i370 | i860 | i960 | ia16 | ia64 \
 	| ip2k | iq2000 \
 	| k1om \
 	| le32 | le64 \
@@ -301,10 +301,12 @@ case $basic_machine in
 	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
+	| pru \
 	| pyramid \
+	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
@@ -312,6 +314,8 @@ case $basic_machine in
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
+	| wasm32 \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -326,6 +330,9 @@ case $basic_machine in
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
 	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -371,17 +378,18 @@ case $basic_machine in
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| ba-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| hexagon-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
+	| i*86-* | i860-* | i960-* | ia16-* | ia64-* \
 	| ip2k-* | iq2000-* \
 	| k1om-* \
 	| le32-* | le64-* \
@@ -422,13 +430,15 @@ case $basic_machine in
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
+	| pru-* \
 	| pyramid-* \
+	| riscv32-* | riscv64-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile*-* \
@@ -436,6 +446,8 @@ case $basic_machine in
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
+	| wasm32-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -512,6 +524,9 @@ case $basic_machine in
 		basic_machine=i386-pc
 		os=-aros
 		;;
+	asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -632,6 +647,14 @@ case $basic_machine in
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
+	e500v[12])
+		basic_machine=powerpc-unknown
+		os=$os"spe"
+		;;
+	e500v[12]-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=$os"spe"
+		;;
 	ebmon29k)
 		basic_machine=a29k-amd
 		os=-ebmon
@@ -773,6 +796,9 @@ case $basic_machine in
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -828,6 +854,10 @@ case $basic_machine in
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -920,6 +950,9 @@ case $basic_machine in
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
+	nsx-tandem)
+		basic_machine=nsx-tandem
+		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
@@ -1004,7 +1037,7 @@ case $basic_machine in
 	ppc-* | ppcbe-*)
 		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
+	ppcle | powerpclittle)
 		basic_machine=powerpcle-unknown
 		;;
 	ppcle-* | powerpclittle-*)
@@ -1014,7 +1047,7 @@ case $basic_machine in
 		;;
 	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+	ppc64le | powerpc64little)
 		basic_machine=powerpc64le-unknown
 		;;
 	ppc64le-* | powerpc64little-*)
@@ -1215,6 +1248,9 @@ case $basic_machine in
 		basic_machine=a29k-wrs
 		os=-vxworks
 		;;
+	wasm32)
+		basic_machine=wasm32-unknown
+		;;
 	w65*)
 		basic_machine=w65-wdc
 		os=-none
@@ -1360,27 +1396,28 @@ case $os in
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
 	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -bitrig* | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* | -cegcc* \
+	      | -chorusos* | -chorusrdb* | -cegcc* | -glidix* \
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
+	      | -onefs* | -tirtos* | -phoenix* | -fuchsia* | -redox*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1512,6 +1549,8 @@ case $os in
 		;;
 	-nacl*)
 		;;
+	-ios)
+		;;
 	-none)
 		;;
 	*)
@@ -1607,6 +1646,9 @@ case $basic_machine in
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
+	pru-*)
+		os=-elf
+		;;
 	*-be)
 		os=-beos
 		;;
diff -urpN asterisk-13.9.1/configs/basic-pbx/asterisk.conf asterisk-13.17.0/configs/basic-pbx/asterisk.conf
--- asterisk-13.9.1/configs/basic-pbx/asterisk.conf	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/basic-pbx/asterisk.conf	2017-07-12 13:12:08.000000000 +0200
@@ -1,26 +1,13 @@
-[directories]
-astetcdir = /etc/asterisk
-astmoddir = /usr/lib/asterisk/modules
-astvarlibdir = /var/lib/asterisk
-astdbdir = /var/lib/asterisk
-astkeydir = /var/lib/asterisk
-astdatadir = /var/lib/asterisk
-astagidir = /var/lib/asterisk/agi-bin
-astspooldir = /var/spool/asterisk
-astrundir = /var/run/asterisk
-astlogdir = /var/log/asterisk
-astsbindir = /usr/sbin
-
 [options]
 ; If we want to start Asterisk with a default verbosity for the verbose
-; or debug logger channel types, then we use these settings.
+; or debug logger channel types, then we use these settings (by default
+; they are disabled).
 ;verbose = 5
-;debug = 5
+;debug = 2
 
 ; User and group to run asterisk as. NOTE: This will require changes to
 ; directory and device permissions.
-;runuser = asterisk		; The user to run as.
-;rungroup = asterisk		; The group to run as.
+;runuser = asterisk		; The user to run as. The default is root.
+;rungroup = asterisk		; The group to run as. The default is root
 
-defaultlanguage = en
-documentation_language = en_US
+;defaultlanguage = es
diff -urpN asterisk-13.9.1/configs/basic-pbx/modules.conf asterisk-13.17.0/configs/basic-pbx/modules.conf
--- asterisk-13.9.1/configs/basic-pbx/modules.conf	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/basic-pbx/modules.conf	2017-07-12 13:12:08.000000000 +0200
@@ -60,11 +60,9 @@ load = func_strings.so
 ; Core/PBX
 
 load = pbx_config.so
-load = pbx_functions.so
 
 ; Resources
 
-load = res_hep_pjsip.so
 load = res_musiconhold.so
 load = res_pjproject.so
 load = res_pjsip_acl.so
@@ -78,7 +76,6 @@ load = res_pjsip_endpoint_identifier_ip.
 load = res_pjsip_endpoint_identifier_user.so
 load = res_pjsip_exten_state.so
 load = res_pjsip_header_funcs.so
-load = res_pjsip_log_forwarder.so
 load = res_pjsip_logger.so
 load = res_pjsip_messaging.so
 load = res_pjsip_multihomed.so
@@ -91,7 +88,6 @@ load = res_pjsip_outbound_authenticator_
 load = res_pjsip_outbound_publish.so
 load = res_pjsip_outbound_registration.so
 load = res_pjsip_path.so
-load = res_pjsip_phoneprov_provider.so
 load = res_pjsip_pidf_body_generator.so
 load = res_pjsip_pidf_digium_body_supplement.so
 load = res_pjsip_pidf_eyebeam_body_supplement.so
diff -urpN asterisk-13.9.1/configs/basic-pbx/pjsip.conf asterisk-13.17.0/configs/basic-pbx/pjsip.conf
--- asterisk-13.9.1/configs/basic-pbx/pjsip.conf	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/basic-pbx/pjsip.conf	2017-07-12 13:12:08.000000000 +0200
@@ -15,7 +15,6 @@ bind = 0.0.0.0
 
 [dcs-trunk]
 type = registration
-transport = transport-udp-nat
 outbound_auth = dcs-trunk-auth
 server_uri = sip:sip.digiumcloud.net
 ;client_uri = sip:myaccountID@sip.digiumcloud.net
@@ -31,7 +30,6 @@ auth_type = userpass
 
 [dcs-endpoint]
 type=endpoint
-transport = transport-udp-nat
 context = DCS-Incoming
 allow = !all,g722,ulaw
 outbound_auth = dcs-auth
@@ -59,7 +57,6 @@ endpoint = dcs-endpoint
 ; Our primary endpoint template for internal desk phones.
 [endpoint-internal-d70](!)
 type = endpoint
-transport = transport-udp-nat
 context = Long-Distance
 allow = !all,g722,ulaw
 direct_media = no
diff -urpN asterisk-13.9.1/configs/samples/alsa.conf.sample asterisk-13.17.0/configs/samples/alsa.conf.sample
--- asterisk-13.9.1/configs/samples/alsa.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/alsa.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -46,7 +46,7 @@ extension=s
 ; systems where there will be no return audio path, such as overhead pagers.
 ;noaudiocapture=true
 
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of an
                               ; ALSA channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -74,5 +74,5 @@ extension=s
                               ; network normally has low jitter, but occasionally has spikes.
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
diff -urpN asterisk-13.9.1/configs/samples/ast_debug_tools.conf.sample asterisk-13.17.0/configs/samples/ast_debug_tools.conf.sample
--- asterisk-13.9.1/configs/samples/ast_debug_tools.conf.sample	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/configs/samples/ast_debug_tools.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,57 @@
+#
+# This file is used by the Asterisk debug tools.
+# Unlike other Asterisk config files, this one is
+# "sourced" by bash and must adhere to bash semantics.
+#
+
+# A list of coredumps and/or coredump search patterns.
+# Bash extended globs are enabled and any resulting files
+# that aren't actually coredumps are silently ignored
+# so you can be liberal with the globs.
+#
+# If your patterns contains spaces be sure to only quote
+# the portion of the pattern that DOESN'T contain wildcard
+# expressions.  If you quote the whole pattern, it won't
+# be expanded and the glob characters will be treated as
+# literals.
+#
+# The exclusion of files ending ".txt" is just for
+# demonstration purposes as non-coredumps will be ignored
+# anyway.
+COREDUMPS=(/tmp/core[-._]asterisk!(*.txt) /tmp/core[-._]$(hostname)!(*.txt))
+
+# Date command for the "running" coredump and tarballs.
+# DATEFORMAT will be executed to get the timestamp.
+# Don't put quotes around the format string or they'll be
+# treated as literal characters.  Also be aware of colons
+# in the output as you can't upload files with colons in
+# the name to Jira.
+#
+# Unix timestamp
+#DATEFORMAT='date +%s.%N'
+#
+# Unix timestamp on *BSD/MacOS after installing coreutils
+#DATEFORMAT='gdate +%s.%N'
+#
+# Readable GMT
+#DATEFORMAT='date -u +%FT%H-%M-%S%z'
+#
+# Readable Local time
+DATEFORMAT='date +%FT%H-%M-%S%z'
+
+# A list of log files and/or log file search patterns using the
+# same syntax as COREDUMPS.
+#
+LOGFILES=(/var/log/asterisk/messages* /var/log/asterisk/queue* \
+	/var/log/asterisk/debug* /var/log/asterisk/security*)
+
+# ast_loggrabber converts POSIX timestamps to readable format
+# using this Python strftime format string.  If not specified
+# or an empty string, no format covnersion is done.
+LOG_DATEFORMAT="%m/%d-%H:%M:%S.%f"
+
+# The timezone to use when converting POSIX timestamps to
+# readable format.  It can be specified in "<continent>/<city>"
+# format or in abbreviation format such as "CST6CDT".  If not
+# specified, the "local" timezone is used.
+# LOG_TIMEZONE=
diff -urpN asterisk-13.9.1/configs/samples/asterisk.conf.sample asterisk-13.17.0/configs/samples/asterisk.conf.sample
--- asterisk-13.9.1/configs/samples/asterisk.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/asterisk.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -88,6 +88,23 @@ documentation_language = en_US	; Set the
 				; considered dangerous because they can allow
 				; privilege escalation.
 				; Default no
+;entityid=00:11:22:33:44:55	; Entity ID.
+				; This is in the form of a MAC address.
+				; It should be universally unique.
+				; It must be unique between servers communicating
+				; with a protocol that uses this value.
+				; This is currently is used by DUNDi and
+				; Exchanging Device and Mailbox State
+				; using protocols: XMPP, Corosync and PJSIP.
+;rtp_pt_dynamic = 96		; Normally the Dynamic RTP Payload Type numbers
+				; are 96-127, which allow 32 formats. When you
+				; use more and receive the message "No Dynamic
+				; RTP mapping available", extend the dynamic
+				; range by going for 35 (or 0) instead of 96.
+				; This allows 29 (or 64) more formats. 96 is the
+				; default because any number below might be
+				; rejected by a remote implementation; although
+				; no such broken implementation is known, yet.
 
 ; Changing the following lines may compromise your security.
 ;[files]
diff -urpN asterisk-13.9.1/configs/samples/ccss.conf.sample asterisk-13.17.0/configs/samples/ccss.conf.sample
--- asterisk-13.9.1/configs/samples/ccss.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/ccss.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -64,9 +64,9 @@
 ;           PLEASE READ THIS!!!
 ;===========================================
 ;
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;                                Timers
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;There are three configurable timers for all types of CC: the
 ;cc_offer_timer, the ccbs_available_timer, and the ccnr_available_timer.
 ;In addition, when using a generic agent, there is a fourth timer,
@@ -98,9 +98,9 @@
 ; only affects operation when using a generic agent.
 ;
 ;cc_recall_timer = 20
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;                                Policies
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ; Policy settings tell Asterisk how to behave and what sort of
 ; resources to allocate in order to facilitate CC. There are two
 ; settings to control the actions Asterisk will take.
@@ -153,9 +153,9 @@
 ;cc_monitor_policy=never
 ;
 ;
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;                              Limits
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;
 ; The use of CC requires Asterisk to potentially use more memory than
 ; some administrators would like. As such, it is a good idea to limit
@@ -175,9 +175,9 @@
 ;
 ;cc_max_monitors = 5
 ;
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;                            Other
-;---------------------------------------------------------------------
+; --------------------------------------------------------------------
 ;
 ; When using a generic CC agent, the caller who requested CC will be
 ; called back when a called party becomes available. When the caller
diff -urpN asterisk-13.9.1/configs/samples/cdr.conf.sample asterisk-13.17.0/configs/samples/cdr.conf.sample
--- asterisk-13.9.1/configs/samples/cdr.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/cdr.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -17,7 +17,7 @@
 ; party. Setting this to "yes" will make calls to extensions that don't answer
 ; and don't set a B side channel (such as by using the Dial application)
 ; receive CDR log entries. If this option is set to "no", then those log
-; entries will not be created. Unasnwered Calls which get offered to an
+; entries will not be created. Unanswered Calls which get offered to an
 ; outgoing line will always receive log entries regardless of this option, and
 ; that is the intended behaviour.
 ;unanswered = no
diff -urpN asterisk-13.9.1/configs/samples/cdr_mysql.conf.sample asterisk-13.17.0/configs/samples/cdr_mysql.conf.sample
--- asterisk-13.9.1/configs/samples/cdr_mysql.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/cdr_mysql.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -18,7 +18,10 @@
 ;user=asteriskcdruser
 ;port=3306
 ;sock=/tmp/mysql.sock
-;timezone=UTC ; Previously called usegmtime
+; By default CDRs are logged in the system's time zone
+;cdrzone=UTC               ; log CDRs with UTC
+;usegmtime=yes ;log date/time in GMT.  Default is "no"
+;cdrzone=America/New_York  ; or use a specific time zone
 ;
 ; If your system's locale differs from mysql database character set,
 ; cdr_mysql can damage non-latin characters in CDR variables. Use this
diff -urpN asterisk-13.9.1/configs/samples/chan_dahdi.conf.sample asterisk-13.17.0/configs/samples/chan_dahdi.conf.sample
--- asterisk-13.9.1/configs/samples/chan_dahdi.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/chan_dahdi.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -1119,6 +1119,15 @@ pickupgroup=1
 ;faxdetect=outgoing
 ;faxdetect=no
 ;
+; When 'faxdetect' is enabled, one could use 'faxdetect_timeout' to disable fax
+; detection after the specified number of seconds into a call.  Be aware that
+; outgoing analog channels may consider the channel is answered immediately
+; when dialing completes.  Analog does not have a reliable method of detecting
+; when the far end answers.  Zero disables the timeout.
+; Default is 0 to disable the timeout.
+;
+;faxdetect_timeout=30
+;
 ; When 'faxdetect' is used, one could use 'faxbuffers' to configure the DAHDI
 ; transmit buffer policy.  The default is *OFF*.  When this configuration
 ; option is used, the faxbuffer policy will be used for the life of the call
@@ -1211,7 +1220,7 @@ pickupgroup=1
 ;
 ;jitterbuffers=4
 ;
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
                               ; DAHDI channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -1239,7 +1248,7 @@ pickupgroup=1
                               ; network normally has low jitter, but occasionally has spikes.
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 ;
 ; You can define your own custom ring cadences here.  You can define up to 8
 ; pairs.  If the silence is negative, it indicates where the caller ID spill is
diff -urpN asterisk-13.9.1/configs/samples/codecs.conf.sample asterisk-13.17.0/configs/samples/codecs.conf.sample
--- asterisk-13.9.1/configs/samples/codecs.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/codecs.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -151,3 +151,57 @@ packetloss_percentage=10;
 ;[celt32]
 ;type=celt
 ;samprate=32000
+
+;============================ OPUS Section Options ============================
+;
+;[opus]
+;type= ; Must be of type "opus" (default: "")
+;packet_loss= ; Encoder's packet loss percentage. Can be any number between 0
+              ; and 100, inclusive. A higher value results in more loss
+              ; resistance. (default: 0)
+;complexity= ; Encoder's computational complexity. Can be any number between 0
+             ; and 10, inclusive. Note, 10 equals the highest complexity.
+             ; (default: 10)
+;max_bandwidth= ; Encoder's maximum bandwidth allowed. Sets an upper bandwidth
+                ; bound on the encoder. Can be any of the following: narrow,
+                ; medium, wide, super_wide, full. (default: full)
+;signal= ; Encoder's signal type. Aids in mode selection on the encoder: Can
+         ; be any of the following: auto, voice, music. (default: auto)
+;application= ; Encoder's application type. Can be any of the following: voip,
+              ; audio, low_delay. (default: voip)
+;max_playback_rate= ; Override the maximum playback rate in the offer's SDP.
+                    ; Any value between 8000 and 48000 (inclusive) is valid,
+                    ; however typically it should match one of the usual opus
+                    ; bandwidths. A value of "sdp" is also allowed. When set
+                    ; to "sdp" then the value from the offer's SDP is used.
+                    ; (default: "sdp")
+;bitrate= ; Override the maximum average bitrate in the offer's SDP. Any value
+          ; between 500 and 512000 is valid. The following values are also
+          ; allowed: auto, max, sdp. When set to "sdp" then the value from
+          ; the offer's sdp is used. (default: "sdp")
+;cbr= ; Override the constant bit rate parameter in the offer's SDP. A value of
+      ; 0/false/no represents a variable bit rate whereas 1/true/yes represents
+      ; a constant bit rate. A value of "sdp" is also allowed. When set to "sdp"
+      ; then the value from the offer's sdp is used. (default: "sdp")
+;fec= ; Override the use inband fec parameter in the offer's SDP. A value of
+      ; 0/false/no represents disabled whereas 1/true/yes represents enabled.
+      ; A value of "sdp" is also allowed. When set to "sdp" then the value from
+      ; the offer's sdp is used. (default: "sdp")
+;dtx= ; Override the use dtx parameter in the offer's SDP. A value of 0/false/no
+      ; represents disabled whereas 1/true/yes represents enabled. A value of
+      ; "sdp" is also allowed. When set to "sdp" then the value from the offer's
+      ; sdp is used. (default: "sdp")
+
+;=============================== OPUS Examples ================================
+;
+;[opus]
+;type=opus
+;max_playback_rate=8000 ; Limit the maximum playback rate on the encoder
+;fec=no ; Force no inband fec on the encoder (i.e don't use what's on the SDP)
+
+;[myopus]
+;type=opus
+;max_bandwidth=wide ; Maximum encoded bandwidth set to wide band (0-8000 Hz
+;                   ; audio bandwidth at 16Khz sample rate)
+;cbr=yes ; Force a constant bit rate (i.e don't use what's on the SDP)
+
diff -urpN asterisk-13.9.1/configs/samples/confbridge.conf.sample asterisk-13.17.0/configs/samples/confbridge.conf.sample
--- asterisk-13.9.1/configs/samples/confbridge.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/confbridge.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -211,6 +211,8 @@ type=bridge
 ;language=en               ; Set the language used for announcements to the conference.
                            ; Default is en (English).
 
+;regcontext=conferences    ; The name of the context into which to register conference names as extensions.
+
 ; All sounds in the conference are customizable using the bridge profile options below.
 ; Simply state the option followed by the filename or full path of the filename after
 ; the option.  Example: sound_had_joined=conf-hasjoin  This will play the conf-hasjoin
diff -urpN asterisk-13.9.1/configs/samples/console.conf.sample asterisk-13.17.0/configs/samples/console.conf.sample
--- asterisk-13.9.1/configs/samples/console.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/console.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -44,7 +44,7 @@
 ;
 ;mohinterpret=default
 
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of an
                               ; Console channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -72,7 +72,7 @@
                               ; network normally has low jitter, but occasionally has spikes.
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 
 ;
diff -urpN asterisk-13.9.1/configs/samples/dsp.conf.sample asterisk-13.17.0/configs/samples/dsp.conf.sample
--- asterisk-13.9.1/configs/samples/dsp.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/dsp.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -8,28 +8,28 @@
 
 ; DTMF Reverse Twist and Normal Twist is the difference in power between the row and column energies.
 ;
-; Normal Twist is where the Column energy is greater than the Row energy
-; Reverse Twist is where the Row energy is greater.
+; Normal Twist is where the row energy is greater than the column energy.
+; Reverse Twist is where the column energy is greater.
 ;
 ; Power level difference between frequencies for different Administrations/RPOAs
-;		Power Gain		equiv
-;		normal	reverse		dB's
-; AT&T(default) 6.31	2.51		8dB(normal), 4dB(reverse)
-; NTT		3.16	3.16		Max. 5dB
-; Danish	3.98	3.98		Max. 6dB
-; Australian	10.0	10.0		Max. 10dB
-; Brazilian	7.94	7.94		Max. 9dB
-; ETSI		3.98	3.98		Max. 6dB
+;               Power Gain              equiv
+;               normal  reverse         dB's
+; AT&T(default) 6.31    2.51            8dB(normal), 4dB(reverse)
+; NTT           3.16    3.16            Max. 5dB
+; Danish        3.98    3.98            Max. 6dB
+; Australian    10.0    10.0            Max. 10dB
+; Brazilian     7.94    7.94            Max. 9dB
+; ETSI          3.98    3.98            Max. 6dB
 
 ;previous version compatible AT&T values
 ; RADIO_RELAX disabled, and relaxdtmf=no
-;		6.30	2.50		7.99dB(normal), 3.98dB(reverse)
+;               6.30    2.50            7.99dB(normal), 3.98dB(reverse)
 ; RADIO_RELAX disabled, and relaxdtmf=yes
-;		6.30	4.00		7.99dB(normal), 6.02dB(reverse)
+;               6.30    4.00            7.99dB(normal), 6.02dB(reverse)
 ; RADIO_RELAX enabled, and relaxdtmf=no
-;		6.30	2.50		7.99dB(normal), 3.984dB(reverse)
+;               6.30    2.50            7.99dB(normal), 3.984dB(reverse)
 ; RADIO_RELAX enabled, and relaxdtmf=yes
-;		6.30	6.50		7.99dB(normal), 8.13dB(reverse)
+;               6.30    6.50            7.99dB(normal), 8.13dB(reverse)
 
 ;If you don't know what these mean, don't change them.
 ;dtmf_normal_twist=6.31
diff -urpN asterisk-13.9.1/configs/samples/extconfig.conf.sample asterisk-13.17.0/configs/samples/extconfig.conf.sample
--- asterisk-13.9.1/configs/samples/extconfig.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/extconfig.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -84,6 +84,9 @@
 ;ps_aors => odbc,asterisk
 ;ps_domain_aliases => odbc,asterisk
 ;ps_endpoint_id_ips => odbc,asterisk
+;ps_outbound_publishes => odbc,asterisk
+;ps_inbound_publications = odbc,asterisk
+;ps_asterisk_publications = odbc,asterisk
 ;voicemail => odbc,asterisk
 ;extensions => odbc,asterisk
 ;meetme => mysql,general
diff -urpN asterisk-13.9.1/configs/samples/extensions.conf.sample asterisk-13.17.0/configs/samples/extensions.conf.sample
--- asterisk-13.9.1/configs/samples/extensions.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/extensions.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -443,8 +443,8 @@ same => n,Congestion()
 ;
 exten => s,1,Dial(${ARG1})
 exten => s,n,Goto(s-${DIALSTATUS},1)
-exten => s-NOANSWER,1,Hangup
-exten => s-BUSY,1,Hangup
+exten => s-NOANSWER,1,Hangup()
+exten => s-BUSY,1,Hangup()
 exten => _s-.,1,NoOp
 
 [stdexten]
@@ -473,15 +473,15 @@ exten => _X.,n,Set(LOCAL(mbx)=${ext}${IF
 exten => _X.,n,Dial(${dev},20)				; Ring the interface, 20 seconds maximum
 exten => _X.,n,Goto(stdexten-${DIALSTATUS},1)		; Jump based on status (NOANSWER,BUSY,CHANUNAVAIL,CONGESTION,ANSWER)
 
-exten => stdexten-NOANSWER,1,Voicemail(${mbx},u)	; If unavailable, send to voicemail w/ unavail announce
+exten => stdexten-NOANSWER,1,VoiceMail(${mbx},u)	; If unavailable, send to voicemail w/ unavail announce
 exten => stdexten-NOANSWER,n,Return()			; If they press #, return to start
 
-exten => stdexten-BUSY,1,Voicemail(${mbx},b)		; If busy, send to voicemail w/ busy announce
+exten => stdexten-BUSY,1,VoiceMail(${mbx},b)		; If busy, send to voicemail w/ busy announce
 exten => stdexten-BUSY,n,Return()			; If they press #, return to start
 
 exten => _stde[x]te[n]-.,1,Goto(stdexten-NOANSWER,1)	; Treat anything else as no answer
 
-exten => a,1,VoicemailMain(${mbx})			; If they press *, send the user into VoicemailMain
+exten => a,1,VoiceMailMain(${mbx})			; If they press *, send the user into VoicemailMain
 exten => a,n,Return()
 
 [stdPrivacyexten]
@@ -507,11 +507,11 @@ exten => _X.,n,Dial(${dev},20,p)			; Rin
 						; option (or use P for databased call _X.creening)
 exten => _X.,n,Goto(stdexten-${DIALSTATUS},1)		; Jump based on status (NOANSWER,BUSY,CHANUNAVAIL,CONGESTION,ANSWER)
 
-exten => stdexten-NOANSWER,1,Voicemail(${mbx},u)	; If unavailable, send to voicemail w/ unavail announce
+exten => stdexten-NOANSWER,1,VoiceMail(${mbx},u)	; If unavailable, send to voicemail w/ unavail announce
 exten => stdexten-NOANSWER,n,NoOp(Finish stdPrivacyexten NOANSWER)
 exten => stdexten-NOANSWER,n,Return()			; If they press #, return to start
 
-exten => stdexten-BUSY,1,Voicemail(${mbx},b)		; If busy, send to voicemail w/ busy announce
+exten => stdexten-BUSY,1,VoiceMail(${mbx},b)		; If busy, send to voicemail w/ busy announce
 exten => stdexten-BUSY,n,NoOp(Finish stdPrivacyexten BUSY)
 exten => stdexten-BUSY,n,Return()			; If they press #, return to start
 
@@ -521,10 +521,10 @@ exten => stdexten-TORTURE,1,Goto(${tortc
 
 exten => _stde[x]te[n]-.,1,Goto(stdexten-NOANSWER,1)	; Treat anything else as no answer
 
-exten => a,1,VoicemailMain(${mbx})		; If they press *, send the user into VoicemailMain
-exten => a,n,Return
+exten => a,1,VoiceMailMain(${mbx})		; If they press *, send the user into VoicemailMain
+exten => a,n,Return()
 
-[macro-page];
+[macro-page]
 ;
 ; Paging macro:
 ;
@@ -533,12 +533,12 @@ exten => a,n,Return
 ;   ${ARG1} - Device to page
 
 exten => s,1,ChanIsAvail(${ARG1},s)			; s is for ANY call
-exten => s,n,GoToIf($[${AVAILSTATUS} = "1"]?autoanswer:fail)
+exten => s,n,GotoIf($[${AVAILSTATUS} = "1"]?autoanswer:fail)
 exten => s,n(autoanswer),Set(_ALERT_INFO="RA")			; This is for the PolyComs
 exten => s,n,SIPAddHeader(Call-Info: Answer-After=0)	; This is for the Grandstream, Snoms, and Others
 exten => s,n,NoOp()					; Add others here and Post on the Wiki!!!!
 exten => s,n,Dial(${ARG1})
-exten => s,n(fail),Hangup
+exten => s,n(fail),Hangup()
 
 
 [demo]
@@ -547,12 +547,12 @@ include => stdexten
 ; We start with what to do when a call first comes in.
 ;
 exten => s,1,Wait(1)			; Wait a second, just for fun
-exten => s,n,Answer			; Answer the line
+exten => s,n,Answer()			; Answer the line
 exten => s,n,Set(TIMEOUT(digit)=5)	; Set Digit Timeout to 5 seconds
 exten => s,n,Set(TIMEOUT(response)=10)	; Set Response Timeout to 10 seconds
 exten => s,n(restart),BackGround(demo-congrats)	; Play a congratulatory message
 exten => s,n(instruct),BackGround(demo-instruct)	; Play some instructions
-exten => s,n,WaitExten			; Wait for an extension to be dialed.
+exten => s,n,WaitExten()		; Wait for an extension to be dialed.
 
 exten => 2,1,BackGround(demo-moreinfo)	; Give some more information.
 exten => 2,n,Goto(s,instruct)
@@ -570,16 +570,16 @@ exten => 1234,1,Playback(transfer,skip)
 exten => 1234,n,Gosub(${EXTEN},stdexten(${GLOBAL(CONSOLE)}))
 exten => 1234,n,Goto(default,s,1)		; exited Voicemail
 
-exten => 1235,1,Voicemail(1234,u)		; Right to voicemail
+exten => 1235,1,VoiceMail(1234,u)		; Right to voicemail
 
 exten => 1236,1,Dial(Console/dsp)		; Ring forever
-exten => 1236,n,Voicemail(1234,b)		; Unless busy
+exten => 1236,n,VoiceMail(1234,b)		; Unless busy
 
 ;
 ; # for when they're done with the demo
 ;
 exten => #,1,Playback(demo-thanks)	; "Thanks for trying the demo"
-exten => #,n,Hangup			; Hang them up.
+exten => #,n,Hangup()			; Hang them up.
 
 ;
 ; A timeout and "invalid extension rule"
@@ -591,7 +591,7 @@ exten => i,1,Playback(invalid)		; "That'
 ; Create an extension, 500, for dialing the
 ; Asterisk demo.
 ;
-exten => 500,1,Playback(demo-abouttotry); Let them know what's going on
+exten => 500,1,Playback(demo-abouttotry)	; Let them know what's going on
 exten => 500,n,Dial(IAX2/guest@pbx.digium.com/s@default)	; Call the Asterisk demo
 exten => 500,n,Playback(demo-nogo)	; Couldn't connect to the demo site
 exten => 500,n,Goto(s,6)		; Return to the start over message.
@@ -600,7 +600,7 @@ exten => 500,n,Goto(s,6)		; Return to th
 ; Create an extension, 600, for evaluating echo latency.
 ;
 exten => 600,1,Playback(demo-echotest)	; Let them know what's going on
-exten => 600,n,Echo			; Do the echo test
+exten => 600,n,Echo()			; Do the echo test
 exten => 600,n,Playback(demo-echodone)	; Let them know it's over
 exten => 600,n,Goto(s,6)		; Start over
 
@@ -618,7 +618,7 @@ exten => 7999,2,Page(Local/Grandstream1@
 
 ; Give voicemail at extension 8500
 ;
-exten => 8500,1,VoicemailMain
+exten => 8500,1,VoiceMailMain()
 exten => 8500,n,Goto(s,6)
 ;
 ; Here's what a phone entry would look like (IXJ for example)
@@ -684,9 +684,9 @@ include => demo
 ;exten => 6245,hint,SIP/Grandstream1&SIP/Xlite1(Joe Schmoe) ; Channel hints for presence
 ;exten => 6245,1,Dial(SIP/Grandstream1,20,rt)	; permit transfer
 ;exten => 6245,n(dial),Dial(${HINT},20,rtT)	; Use hint as listed
-;exten => 6245,n,Voicemail(6245,u)		; Voicemail (unavailable)
+;exten => 6245,n,VoiceMail(6245,u)		; Voicemail (unavailable)
 ;exten => 6245,s+1,Hangup			; s+1, same as n
-;exten => 6245,dial+101,Voicemail(6245,b)	; Voicemail (busy)
+;exten => 6245,dial+101,VoiceMail(6245,b)	; Voicemail (busy)
 ;exten => 6361,1,Dial(IAX2/JaneDoe,,rm)		; ring without time limit
 ;exten => 6389,1,Dial(MGCP/aaln/1@192.168.0.14)
 ;exten => 6390,1,Dial(JINGLE/caller/callee) ; Dial via jingle using labels
diff -urpN asterisk-13.9.1/configs/samples/func_odbc.conf.sample asterisk-13.17.0/configs/samples/func_odbc.conf.sample
--- asterisk-13.9.1/configs/samples/func_odbc.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/func_odbc.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -1,6 +1,20 @@
 ;
 ; func_odbc.conf
 ;
+[general]
+;
+; Asterisk uses separate connections for every database operation.
+; If single_db_connection is enabled then func_odbc will use a single
+; database connection per DSN.
+; This option exists for those who expect that a second func_odbc call
+; works on the same connection. That allows you to do a LAST_INSERT_ID()
+; in a second func_odbc call.
+; Note that you'll need additional dialplan locks for this behaviour to work.
+; There are better ways: using stored procedures/functions instead.
+; This option is enabled by default.
+;single_db_connection=yes
+;
+;
 ; Each context is a separately defined function.  By convention, all
 ; functions are entirely uppercase, so the defined contexts should also
 ; be all-uppercase, but there is nothing that enforces this.  All functions
diff -urpN asterisk-13.9.1/configs/samples/hep.conf.sample asterisk-13.17.0/configs/samples/hep.conf.sample
--- asterisk-13.9.1/configs/samples/hep.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/hep.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -2,9 +2,18 @@
 ; res_hep Module configuration for Asterisk
 ;
 
+;
+; Note that this configuration file is consumed by res_hep, which is responsible
+; for the HEPv3 protocol manipulation and managing the connection to the Homer
+; capture server. Additional modules provide specific messages to be sent to
+; the Homer server:
+;  - res_hep_pjsip: Send SIP messages transmitted/received by the PJSIP stack
+;  - res_hep_rtcp: Send RTCP information (all channels)
+;
+
 ; All settings are currently set in the general section.
 [general]
-enabled = yes                      ; Enable/disable forwarding of packets to a
+enabled = no                       ; Enable/disable forwarding of packets to a
                                    ; HEP server. Default is "yes".
 capture_address = 192.168.1.1:9061 ; The address of the HEP capture server.
 capture_password = foo             ; If specified, the authorization passsword
@@ -13,4 +22,11 @@ capture_password = foo             ; If
 capture_id = 1234                  ; A unique integer identifier for this
                                    ; server. This ID will be embedded sent
                                    ; with each packet from this server.
-
+uuid_type = call-id                ; Specify the preferred source for the Homer
+                                   ; correlation UUID. Valid options are:
+                                   ; - 'call-id' for the PJSIP or chan_sip SIP
+                                   ;             Call-ID
+                                   ; - 'channel' for the Asterisk channel name
+                                   ; Note: If 'call-id' is specified but the
+                                   ; channel is not PJSIP or chan_sip then the
+                                   ; Asterisk channel name will be used instead.
diff -urpN asterisk-13.9.1/configs/samples/logger.conf.sample asterisk-13.17.0/configs/samples/logger.conf.sample
--- asterisk-13.9.1/configs/samples/logger.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/logger.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -78,6 +78,14 @@
 ; Directory for log files is configures in asterisk.conf
 ; option astlogdir
 ;
+; All log messages go to a queue serviced by a single thread
+; which does all the IO.  This setting controls how big that
+; queue can get (and therefore how much memory is allocated)
+; before new messages are discarded.
+; The default is 1000
+;logger_queue_limit = 250
+;
+;
 [logfiles]
 ;
 ; Format is "filename" and then "levels" of debugging to be included:
diff -urpN asterisk-13.9.1/configs/samples/manager.conf.sample asterisk-13.17.0/configs/samples/manager.conf.sample
--- asterisk-13.9.1/configs/samples/manager.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/manager.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -125,7 +125,9 @@ bindaddr = 0.0.0.0
 ;
 ; all       - All event classes below (including any we may have missed).
 ; system    - General information about the system and ability to run system
-;             management commands, such as Shutdown, Restart, and Reload.
+;             management commands, such as Shutdown, Restart, and Reload. This
+;             class also includes dialplan manipulation actions such as
+;             DialplanExtensionAdd and DialplanExtensionRemove.
 ; call      - Information about channels and ability to set information in a
 ;             running channel.
 ; log       - Logging information.  Read-only. (Defined but not yet used.)
diff -urpN asterisk-13.9.1/configs/samples/mgcp.conf.sample asterisk-13.17.0/configs/samples/mgcp.conf.sample
--- asterisk-13.9.1/configs/samples/mgcp.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/mgcp.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -11,12 +11,12 @@
 ;cos=3			; Sets 802.1p priority for signaling packets.
 ;cos_audio=5		; Sets 802.1p priority for RTP audio packets.
 
-;---------------------- DIGIT TIMEOUTS ----------------------------
+; --------------------- DIGIT TIMEOUTS ----------------------------
 firstdigittimeout = 30000 ; default 16000 = 16s
 gendigittimeout = 10000   ; default  8000 = 8s 
 matchdigittimeout = 5000  ; defaults 3000 = 3s
 
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
                               ; MGCP channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -48,7 +48,7 @@ matchdigittimeout = 5000  ; defaults 300
                               ; network normally has low jitter, but occasionally has spikes.
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 ;[dlinkgw]
 ;host = 192.168.0.64
diff -urpN asterisk-13.9.1/configs/samples/minivm.conf.sample asterisk-13.17.0/configs/samples/minivm.conf.sample
--- asterisk-13.9.1/configs/samples/minivm.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/minivm.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -12,7 +12,7 @@
 ; this configuration file or realtime. The idea is to build voicemail as building blocks so that
 ; a complete and adaptive voicemail system can be built in the dialplan
 ;
-;------------------------------ Variables to use in subject, from and message body ------------------
+; ----------------------------- Variables to use in subject, from and message body ------------------
 ; Change the from, body and/or subject, variables:
 ;     MVM_NAME, MVM_DUR, MVM_MSGNUM, VM_MAILBOX, MVM_CALLERID, MVM_CIDNUM,
 ;     MVM_CIDNAME, MVM_DATE
@@ -24,7 +24,7 @@
 ; Note: The emailbody config row can only be up to 512 characters due to a
 ;       limitation in the Asterisk configuration subsystem.
 ;	To create longer mails, use the templatefile option when creating the template
-;----------------------------------------------------------------------------------------------------
+; ---------------------------------------------------------------------------------------------------
 
 [general]
 ; Default format for storing and sending voicemail
@@ -64,7 +64,7 @@ silencethreshold=128
 ; This is used both for e-mail and pager messages
 ;mailcmd=/usr/sbin/sendmail -t
 ;
-;--------------Default e-mail message template (used if no templates are used) ------
+; -------------Default e-mail message template (used if no templates are used) ------
 ;fromstring=The Asterisk PBX
 ;
 
@@ -82,7 +82,7 @@ emaildateformat=%A, %B %d, %Y at %r
 ; 24h date format
 ;emaildateformat=%A, %d %B %Y at %H:%M:%S
 ;
-;--------------Default pager message template (used if no templates are used) ------
+; -------------Default pager message template (used if no templates are used) ------
 ; You can also change the Pager From: string, the pager body and/or subject.
 ; The above defined variables also can be used here
 ;pagerfromstring=The Asterisk PBX
@@ -90,7 +90,7 @@ emaildateformat=%A, %B %d, %Y at %r
 ;pagerbody=New ${MVM_DUR} long msg in box ${MVM_MAILBOX}\nfrom ${MVM_CALLERID}, on ${MVM_DATE}
 ;
 ;
-;--------------Timezone definitions (used in voicemail accounts) -------------------
+; -------------Timezone definitions (used in voicemail accounts) -------------------
 ;
 ; Users may be located in different timezones, or may have different
 ; message announcements for their introductory message when they enter
@@ -133,7 +133,7 @@ central=America/Chicago|'vm-received' Q
 central24=America/Chicago|'vm-received' q 'digits/at' H N 'hours'
 military=Zulu|'vm-received' q 'digits/at' H N 'hours' 'phonetic/z_p'
 
-;----------------------- Message body templates---------------------
+; ---------------------- Message body templates---------------------
 ; [template-name]	; "template-" is a verbatim marker
 ; fromaddress = Your Friendly Asterisk Server
 ; fromemail = asteriskvm@digium.com
@@ -187,7 +187,7 @@ dateformat=%A, %B %d, %Y at %r
 ;subject = Dear old chap, you've got an electronic communique
 ;charset=ascii
 
-;----------------------- Mailbox accounts --------------------------
+; ---------------------- Mailbox accounts --------------------------
 ;Template for mailbox definition - all options
 ;
 ;	[username@domain]		; Has to be unique within domain (MWM_USERNAME, MWM_DOMAIN)
diff -urpN asterisk-13.9.1/configs/samples/misdn.conf.sample asterisk-13.17.0/configs/samples/misdn.conf.sample
--- asterisk-13.9.1/configs/samples/misdn.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/misdn.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -109,7 +109,7 @@ crypt_prefix=**
 ;
 crypt_keys=test,muh
 
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
                               ; SIP channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -140,7 +140,7 @@ crypt_keys=test,muh
                               ; network normally has low jitter, but occasionally has spikes.
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 ; users sections:
 ;
diff -urpN asterisk-13.9.1/configs/samples/musiconhold.conf.sample asterisk-13.17.0/configs/samples/musiconhold.conf.sample
--- asterisk-13.9.1/configs/samples/musiconhold.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/musiconhold.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -79,7 +79,11 @@ directory=moh
 ;[ulawstream]
 ;mode=custom
 ;application=/usr/bin/streamplayer 192.168.100.52 888
-;format=ulaw
+;format=ulaw    ; The 'format' option specifies the audio format that the
+;               ; 'application' will provide to Asterisk. In this example,
+;               ; streamplayer will output ulaw samples so we need to set the
+;               ; format to ulaw so that Asterisk knows how to interpret the
+;               ; incoming audio.
 
 ; mpg123 on Solaris does not always exit properly; madplay may be a better
 ; choice
diff -urpN asterisk-13.9.1/configs/samples/oss.conf.sample asterisk-13.17.0/configs/samples/oss.conf.sample
--- asterisk-13.9.1/configs/samples/oss.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/oss.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -46,7 +46,7 @@
     ; queuesize = 10		; frames in device driver
     ; frags = 8			; argument to SETFRAGMENT
 
-    ;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+    ; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
     ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of an
                                   ; OSS channel. Defaults to "no". An enabled jitterbuffer will
                                   ; be used only if the sending side can create and the receiving
@@ -74,7 +74,7 @@
                                   ; network normally has low jitter, but occasionally has spikes.
 
     ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-    ;-----------------------------------------------------------------------------------
+    ; ----------------------------------------------------------------------------------
 
 ; below is an entry for a second console channel
 ; [card1]
diff -urpN asterisk-13.9.1/configs/samples/pjproject.conf.sample asterisk-13.17.0/configs/samples/pjproject.conf.sample
--- asterisk-13.9.1/configs/samples/pjproject.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/pjproject.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -1,15 +1,36 @@
 ; Common pjproject options
 ;
 
+;[startup]
+;  NOTES: The name of this section in the pjproject.conf configuration file must
+;         remain startup or the configuration will not be applied.
+;
+;log_level=default   ; Initial maximum pjproject logging level to log
+                     ; Valid values are: 0-6, and default
+                     ;
+                     ; Note: This option is needed very early in the startup
+                     ; process so it can only be read from config files because
+                     ; the modules for other methods have not been loaded yet.
+;type=               ; Must be of type startup (default: "")
+
 ;========================LOG_MAPPINGS SECTION OPTIONS===============================
 ;[log_mappings]
 ;  SYNOPSIS: Provides pjproject to Asterisk log level mappings.
 ;  NOTES: The name of this section in the pjproject.conf configuration file must
 ;         remain log_mappings or the configuration will not be applied.
 ;         The defaults mentioned below only apply if this file or the 'log_mappings'
-;         object can'tbe found.  If the object is found, there are no defaults. If
+;         object can't be found.  If the object is found, there are no defaults. If
 ;         you don't specify an entry, nothing will be logged for that level.
 ;
+; These logging level meanings are typically used by pjproject:
+;  - 0: fatal error
+;  - 1: error
+;  - 2: warning
+;  - 3: info
+;  - 4: debug
+;  - 5: trace
+;  - 6: more detailed trace
+;
 ;asterisk_error =    ; A comma separated list of pjproject log levels to map to
                      ; Asterisk errors.
                      ; (default: "0,1")
@@ -24,5 +45,5 @@
                      ; (default: "")
 ;asterisk_debug =    ; A comma separated list of pjproject log levels to map to
                      ; Asterisk debug
-                     ; (default: "3,4,5")
+                     ; (default: "3,4,5,6")
 ;type=               ; Must be of type log_mappings (default: "")
diff -urpN asterisk-13.9.1/configs/samples/pjsip.conf.sample asterisk-13.17.0/configs/samples/pjsip.conf.sample
--- asterisk-13.9.1/configs/samples/pjsip.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/pjsip.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -12,6 +12,12 @@
 ; If you want to see more detail please check the documentation sources
 ; mentioned at the top of this file.
 
+; ============================================================================
+; NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
+;
+; This file does not maintain the complete option documentation.
+; ============================================================================
+
 ; Documentation
 ;
 ; The official documentation is at http://wiki.asterisk.org
@@ -71,6 +77,8 @@
 ;   * Defines a permission list or references one stored in acl.conf
 ; * Registration "registration"
 ;   * Contains information about an outbound SIP registration
+; * Resource Lists
+;   * Contains information for configuring resource lists.
 ; * Phone Provisioning "phoneprov"
 ;   * Contains information needed by res_phoneprov for autoprovisioning
 
@@ -112,9 +120,6 @@
 ; the prefix "external_" will only apply to communication with addresses
 ; outside the range set with "local_net=".
 ;
-; IPv6: For endpoints using IPv6, remember to set "rtp_ipv6=yes" so that the RTP
-; engine will also be able to bind to an IPv6 address.
-;
 ; You can have more than one of any type of transport, as long as it doesn't
 ; use the same resources (bind address, port, etc) as the others.
 
@@ -294,8 +299,6 @@
 ; If using the TLS enabled transport, you may want the "media_encryption=sdes"
 ; option to additionally enable SRTP, though they are not mutually inclusive.
 ;
-; Use the "rtp_ipv6=yes" option if you want to utilize RTP over an ipv6 transport.
-;
 ; If this endpoint were remote, and it was using a transport configured for NAT
 ; then you likely want to use "direct_media=no" to prevent audio issues.
 
@@ -315,7 +318,6 @@
 ;transport=transport-tls
 ;media_encryption=sdes
 ;transport=transport-udp-ipv6
-;rtp_ipv6=yes
 ;transport=transport-udp-nat
 ;direct_media=no
 ;
@@ -595,6 +597,7 @@
                 ; "yes")
 ;aggregate_mwi=yes      ;  (default: "yes")
 ;allow= ; Media Codec s to allow (default: "")
+;allow_overlap=yes ; Enable RFC3578 overlap dialing support. (default: "yes")
 ;aors=  ; AoR s to be used with the endpoint (default: "")
 ;auth=  ; Authentication Object s associated with the endpoint (default: "")
 ;callerid=      ; CallerID information for the endpoint (default: "")
@@ -605,8 +608,15 @@
 ;direct_media_glare_mitigation=none     ; Mitigation of direct media re INVITE
                                         ; glare (default: "none")
 ;direct_media_method=invite     ; Direct Media method type (default: "invite")
-;connected_line_method=invite   ; Connected line method type (default:
-                                ; "invite")
+;connected_line_method=invite   ; Connected line method type.
+                                ; When set to "invite", check the remote's
+                                ; Allow header and if UPDATE is allowed, send
+                                ; UPDATE instead of INVITE to avoid SDP
+                                ; renegotiation.  If UPDATE is not Allowed,
+                                ; send INVITE.
+                                ; If set to "update", send UPDATE regardless
+                                ; of what the remote Allows.
+                                ; (default: "invite")
 ;direct_media=yes       ; Determines whether media may flow directly between
                         ; endpoints (default: "yes")
 ;disable_direct_media_on_nat=no ; Disable direct media session refreshes when
@@ -620,8 +630,13 @@
                                 ; the specified address. (default: "no")
 ;force_rport=yes        ; Force use of return port (default: "yes")
 ;ice_support=no ; Enable the ICE mechanism to help traverse NAT (default: "no")
-;identify_by=username   ; Way s for Endpoint to be identified (default:
-                        ; "username")
+;identify_by=username   ; A comma-separated list of ways the Endpoint or AoR can be
+                        ; identified.
+                        ; "username": Identify by the From or To username and domain
+                        ; "auth_username": Identify by the Authorization username and realm
+                        ; In all cases, if an exact match on username and domain/realm fails,
+                        ; the match will be retried with just the username.
+                        ; (default: "username")
 ;redirect_method=user   ; How redirects received from an endpoint are handled
                         ; (default: "user")
 ;mailboxes=     ; NOTIFY the endpoint when state changes for any of the specified mailboxes.
@@ -635,11 +650,10 @@
 ;moh_suggest=default    ; Default Music On Hold class (default: "default")
 ;outbound_auth= ; Authentication object used for outbound requests (default:
                 ; "")
-;outbound_proxy=        ; Proxy through which to send requests a full SIP URI
+;outbound_proxy=        ; Proxy through which to send requests, a full SIP URI
                         ; must be provided (default: "")
 ;rewrite_contact=no     ; Allow Contact header to be rewritten with the source
                         ; IP address port (default: "no")
-;rtp_ipv6=no    ; Allow use of IPv6 for RTP traffic (default: "no")
 ;rtp_symmetric=no       ; Enforce that RTP must be symmetric (default: "no")
 ;send_diversion=yes     ; Send the Diversion header conveying the diversion
                         ; information to the called user agent (default: "yes")
@@ -665,7 +679,7 @@
                         ; usage of media encryption for this endpoint (default:
                         ; "no")
 ;media_encryption_optimistic=no ; Use encryption if possible but don't fail the call
-								; if not possible.
+                                ; if not possible.
 ;g726_non_standard=no   ; When set to "yes" and an endpoint negotiates g.726
                         ; audio then g.726 for AAL2 packing order is used contrary
                         ; to what is recommended in RFC3551. Note, 'g726aal2' also
@@ -686,10 +700,12 @@
 ;t38_udptl_maxdatagram=0        ; T 38 UDPTL maximum datagram size (default:
                                 ; "0")
 ;fax_detect=no  ; Whether CNG tone detection is enabled (default: "no")
+;fax_detect_timeout=30  ; How many seconds into a call before fax_detect is
+                        ; disabled for the call.
+                        ; Zero disables the timeout.
+                        ; (default: "0")
 ;t38_udptl_nat=no       ; Whether NAT support is enabled on UDPTL sessions
                         ; (default: "no")
-;t38_udptl_ipv6=no      ; Whether IPv6 is used for UDPTL Sessions (default:
-                        ; "no")
 ;tone_zone=     ; Set which country s indications to use for channels created
                 ; for this endpoint (default: "")
 ;language=      ; Set the default language to use for channels created for this
@@ -741,7 +757,7 @@
 ;srtp_tag_32=no ; Determines whether 32 byte tags should be used instead of 80
                 ; byte tags (default: "no")
 ;set_var=       ; Variable set on a channel involving the endpoint. For multiple
-		; channel variables specify multiple 'set_var'(s)
+                ; channel variables specify multiple 'set_var'(s)
 ;rtp_keepalive= ; Interval, in seconds, between comfort noise RTP packets if
                 ; RTP is not flowing. This setting is useful for ensuring that
                 ; holes in NATs and firewalls are kept open throughout a call.
@@ -751,10 +767,31 @@
 ;rtp_timeout_hold= ; Hang up channel if RTP is not received for the specified
                    ; number of seconds when the channel is on hold (default:
                    ; "0" or not enabled)
+;contact_user= ; On outgoing requests, force the user portion of the Contact
+               ; header to this value (default: "")
+;asymmetric_rtp_codec= ; Allow the sending and receiving codec to differ and
+                       ; not be automatically matched (default: "no")
+;refer_blind_progress= ; Whether to notifies all the progress details on blind
+                       ; transfer (default: "yes"). The value "no" is useful
+                       ; for some SIP phones (Mitel/Aastra, Snom) which expect
+                       ; a sip/frag "200 OK" after REFER has been accepted.
+;notify_early_inuse_ringing = ; Whether to notifies dialog-info 'early'
+                              ; on INUSE && RINGING state (default: "no").
+                              ; The value "yes" is useful for some SIP phones
+                              ; (Cisco SPA) to be able to indicate and pick up
+                              ; ringing devices.
 
 ;==========================AUTH SECTION OPTIONS=========================
 ;[auth]
 ;  SYNOPSIS: Authentication type
+;
+;  Note: Using the same auth section for inbound and outbound
+;  authentication is not recommended.  There is a difference in
+;  meaning for an empty realm setting between inbound and outbound
+;  authentication uses.  Look to the CLI config help
+;  "config show help res_pjsip auth realm" or on the wiki for the
+;  difference.
+;
 ;auth_type=userpass     ; Authentication type (default: "userpass")
 ;nonce_lifetime=32      ; Lifetime of a nonce associated with this
                         ; authentication config (default: "32")
@@ -783,7 +820,7 @@
                 ; (default: "")
 ;ca_list_path=  ; Path to directory containing certificates to read TLS ONLY.
                 ; PJProject version 2.4 or higher is required for this option to
-				; be used.
+                ; be used.
                 ; (default: "")
 ;cert_file=     ; Certificate file for endpoint TLS ONLY
                 ; Will read .crt or .pem file but only uses cert,
@@ -823,6 +860,17 @@
                     ; this option is set to 'no' (the default) changes to the
                     ; particular transport will be ignored. If set to 'yes',
                     ; changes (if any) will be applied.
+;symmetric_transport=no ; When a request from a dynamic contact comes in on a
+                        ; transport with this option set to 'yes', the transport
+                        ; name will be saved and used for subsequent outgoing
+                        ; requests like OPTIONS, NOTIFY and INVITE.  It's saved
+                        ; as a contact uri parameter named 'x-ast-txp' and will
+                        ; display with the contact uri in CLI, AMI, and ARI
+                        ; output.  On the outgoing request, if a transport
+                        ; wasn't explicitly set on the endpoint AND the request
+                        ; URI is not a hostname, the saved transport will be
+                        ; used and the 'x-ast-txp' parameter stripped from the
+                        ; outgoing packet.
 
 ;==========================AOR SECTION OPTIONS=========================
 ;[aor]
@@ -847,8 +895,8 @@
 ;qualify_timeout=3.0      ; Qualify timeout in fractional seconds (default: "3.0")
 ;authenticate_qualify=no        ; Authenticates a qualify request if needed
                                 ; (default: "no")
-;outbound_proxy=        ; Outbound proxy used when sending OPTIONS request
-                        ; (default: "")
+;outbound_proxy=        ; Proxy through which to send OPTIONS requests, a full SIP URI
+                        ; must be provided (default: "")
 
 
 ;==========================SYSTEM SECTION OPTIONS=========================
@@ -869,8 +917,8 @@
 ;disable_tcp_switch=yes ; Disable automatic switching from UDP to TCP transports
                         ; if outgoing request is too large.
                         ; See RFC 3261 section 18.1.1.
-						; Disabling this option has been known to cause interoperability
-						; issues, so disable at your own risk.
+                        ; Disabling this option has been known to cause interoperability
+                        ; issues, so disable at your own risk.
                         ; (default: "yes")
 ;type=  ; Must be of type system (default: "")
 
@@ -880,11 +928,10 @@
 ;max_forwards=70        ; Value used in Max Forwards header for SIP requests
                         ; (default: "70")
 ;type=  ; Must be of type global (default: "")
-;user_agent=Asterisk PBX SVN-branch-12-r404375  ; Value used in User Agent
-                                                ; header for SIP requests and
-                                                ; Server header for SIP
-                                                ; responses (default: "Asterisk
-                                                ; PBX SVN-branch-12-r404375")
+;user_agent=Asterisk PBX        ; Allows you to change the user agent string
+                                ; The default user agent string also contains
+                                ; the Asterisk version. If you don't want to
+                                ; expose this, change the user_agent string.
 ;default_outbound_endpoint=default_outbound_endpoint    ; Endpoint to use when
                                                         ; sending an outbound
                                                         ; request to a URI
@@ -899,10 +946,19 @@
                         ; (default: "0")
 ;contact_expiration_check_interval=30
                         ; The interval (in seconds) to check for expired contacts.
+;disable_multi_domain=no
+            ; Disable Multi Domain support.
+            ; If disabled it can improve realtime performace by reducing
+            ; number of database requsts
+            ; (default: "no")
 ;endpoint_identifier_order=ip,username,anonymous
             ; The order by which endpoint identifiers are given priority.
-            ; Identifier names are derived from res_pjsip_endpoint_identifier_*
-            ; modules. (default: ip,username,anonymous)
+            ; Currently, "ip", "username", "auth_username" and "anonymous" are valid
+            ; identifiers as registered by the res_pjsip_endpoint_identifier_* modules.
+            ; Some modules like res_pjsip_endpoint_identifier_user register more than
+            ; one identifier. Use the CLI command "pjsip show identifiers" to see the
+            ; identifiers currently available.
+            ; (default: ip,username,anonymous)
 ;max_initial_qualify_time=4 ; The maximum amount of time (in seconds) from
                             ; startup that qualifies should be attempted on all
                             ; contacts.  If greater than the qualify_frequency
@@ -915,7 +971,65 @@
                    ; The voicemail extension to send in the NOTIFY Message-Account header
                    ; if not set on endpoint or aor.
                    ; (default: "")
-
+;
+; The following unidentified_request options are only used when "auth_username"
+; matching is enabled in "endpoint_identifier_order".
+;
+;unidentified_request_count=5   ; The number of unidentified requests that can be
+                                ; received from a single IP address in
+                                ; unidentified_request_period seconds before a security
+                                ; event is generated. (default: 5)
+;unidentified_request_period=5  ; See above.  (default: 5 seconds)
+;unidentified_request_prune_interval=30
+                                ; The interval at which unidentified requests
+                                ; are check to see if they can be pruned.  If they're
+                                ; older than twice the unidentified_request_period,
+                                ; they're pruned.
+;
+;default_from_user=asterisk     ; When Asterisk generates an outgoing SIP request, the
+                                ; From header username will be set to this value if
+                                ; there is no better option (such as CallerID or
+                                ; endpoint/from_user) to be used
+;default_realm=asterisk         ; When Asterisk generates a challenge, the digest realm
+                                ; will be set to this value if there is no better option
+                                ; (such as auth/realm) to be used.
+
+                    ; Asterisk Task Processor Queue Size
+                    ; On heavy loaded system with DB storage you may need to increase
+                    ; taskprocessor queue.
+                    ; If the taskprocessor queue size reached high water level,
+                    ; the alert is triggered.
+                    ; If the alert is set the pjsip distibutor stops processing incoming
+                    ; requests until the alert is cleared.
+                    ; The alert is cleared when taskprocessor queue size drops to the
+                    ; low water clear level.
+                    ; The next options set taskprocessor queue levels for MWI.
+;mwi_tps_queue_high=500 ; Taskprocessor high water alert trigger level.
+;mwi_tps_queue_low=450  ; Taskprocessor low water clear alert level.
+                    ; The default is -1 for 90% of high water level.
+
+                    ; Unsolicited MWI
+                    ; If there are endpoints configured with unsolicited MWI
+                    ; then res_pjsip_mwi module tries to send MWI to all endpoints on startup.
+;mwi_disable_initial_unsolicited=no ; Disable sending unsolicited mwi to all endpoints on startup.
+                    ; If disabled then unsolicited mwi will start processing
+                    ; on the endpoint's next contact update.
+
+;ignore_uri_user_options=no ; Enable/Disable ignoring SIP URI user field options.
+                    ; If you have this option enabled and there are semicolons
+                    ; in the user field of a SIP URI then the field is truncated
+                    ; at the first semicolon.  This effectively makes the semicolon
+                    ; a non-usable character for PJSIP endpoint names, extensions,
+                    ; and AORs.  This can be useful for improving compatability with
+                    ; an ITSP that likes to use user options for whatever reason.
+                    ; Example:
+                    ; URI: "sip:1235557890;phone-context=national@x.x.x.x;user=phone"
+                    ; The user field is "1235557890;phone-context=national"
+                    ; Which becomes this: "1235557890"
+                    ;
+                    ; Note: The caller-id and redirecting number strings obtained
+                    ; from incoming SIP URI user fields are always truncated at the
+                    ; first semicolon.
 
 ; MODULE PROVIDING BELOW SECTION(S): res_pjsip_acl
 ;==========================ACL SECTION OPTIONS=========================
@@ -948,8 +1062,8 @@
 ;max_retries=10 ; Maximum number of registration attempts (default: "10")
 ;outbound_auth= ; Authentication object to be used for outbound registrations
                 ; (default: "")
-;outbound_proxy=        ; Outbound Proxy used to send registrations (default:
-                        ; "")
+;outbound_proxy=        ; Proxy through which to send registrations, a full SIP URI
+                        ; must be provided (default: "")
 ;retry_interval=60      ; Interval in seconds between retries if outbound
                         ; registration is unsuccessful (default: "60")
 ;forbidden_retry_interval=0     ; Interval used when receiving a 403 Forbidden
@@ -999,3 +1113,142 @@
                 ; Common variables include LINE, LINEKEYS, etc.
                 ; See phoneprov.conf.sample for others.
 ;type=          ; Must be of type phoneprov (default: "")
+
+
+
+; MODULE PROVIDING BELOW SECTION(S): res_pjsip_outbound_publish
+;======================OUTBOUND_PUBLISHEN SECTION OPTIONS=====================
+; See https://wiki.asterisk.org/wiki/display/AST/Publishing+Extension+State
+; for more information.
+;[outbound-publish]
+;type=outbound-publish     ; Must be of type 'outbound-publish'.
+
+;expiration=3600           ; Expiration time for publications in seconds
+
+;outbound_auth=            ; Authentication object(s) to be used for outbound
+                           ; publishes.
+                           ; This is a comma-delimited list of auth	sections
+                           ; defined in pjsip.conf used to respond to outbound
+                           ; authentication challenges.
+                           ; Using the same auth section for inbound and
+                           ; outbound authentication is not recommended.  There
+                           ; is a difference in meaning for an empty realm
+                           ; setting between inbound and outbound authentication
+                           ; uses. See the auth realm description for details.
+
+;outbound_proxy=           ; SIP URI of the outbound proxy used to send
+                           ; publishes
+
+;server_uri=               ; SIP URI of the server and entity to publish to.
+                           ; This is the URI at which to find the entity and
+                           ; server to send the outbound PUBLISH to.
+                           ; This URI is used as the request URI of the outbound
+                           ; PUBLISH request from Asterisk.
+
+;from_uri=                 ; SIP URI to use in the From header.
+                           ; This is the URI that will be placed into the From
+                           ; header of outgoing PUBLISH messages. If no URI is
+                           ; specified then the URI provided in server_uri will
+                           ; be used.
+
+;to_uri=                   ; SIP URI to use in the To header.
+                           ; This is the URI that will be placed into the To
+                           ; header of outgoing PUBLISH messages. If no URI is
+                           ; specified then the URI provided in server_uri will
+                           ; be used.
+
+;event=                    ; Event type of the PUBLISH.
+
+;max_auth_attempts=        ; Maximum number of authentication attempts before
+                           ; stopping the pub.
+
+;transport=                ; Transport used for outbound publish.
+                           ; A transport configured in pjsip.conf. As with other
+                           ; res_pjsip modules, this will use the first
+                           ; available transport of the appropriate type if
+                           ; unconfigured.
+
+;multi_user=no             ; Enable multi-user support (Asterisk 14+ only)
+
+
+
+; MODULE PROVIDING BELOW SECTION(S): res_pjsip_pubsub
+;=============================RESOURCE-LIST===================================
+; See https://wiki.asterisk.org/wiki/pages/viewpage.action?pageId=30278158
+; for more information.
+;[resource_list]
+;type=resource_list        ; Must be of type 'resource_list'.
+
+;event=                    ; The SIP event package that the list resource.
+                           ; belongs to.  The SIP event package describes the
+                           ; types of resources that Asterisk reports the state
+                           ; of.
+
+;list_item=                ; The name of a resource to report state on.
+                           ; In general Asterisk looks up list items in the
+                           ; following way:
+                           ;  1. Check if the list item refers to another
+                           ;     configured resource list.
+                           ;  2. Pass the name of the resource off to
+                           ;     event-package-specific handlers to find the
+                           ;     specified resource.
+                           ; The second part means that the way the list item
+                           ; is specified depends on what type of list this is.
+                           ; For instance, if you have the event set to
+                           ; presence, then list items should be in the form of
+                           ; dialplan_extension@dialplan_context. For
+                           ; message-summary, mailbox names should be listed.
+
+;full_state=no             ; Indicates if the entire list's state should be
+                           ; sent out.
+                           ; If this option is enabled, and a resource changes
+                           ; state, then Asterisk will construct a notification
+                           ; that contains the state of all resources in the
+                           ; list. If the option is disabled, Asterisk will
+                           ; construct a notification that only contains the
+                           ; states of resources that have changed.
+                           ; NOTE: Even with this option disabled, there are
+                           ; certain situations where Asterisk is forced to send
+                           ; a notification with the states of all resources in
+                           ; the list. When a subscriber renews or terminates
+                           ; its subscription to the list, Asterisk MUST send
+                           ; a full state notification.
+
+;notification_batch_interval=0
+                           ; Time Asterisk should wait, in milliseconds,
+                           ; before sending notifications.
+
+;==========================INBOUND_PUBLICATION================================
+; See https://wiki.asterisk.org/wiki/display/AST/Exchanging+Device+and+Mailbox+State+Using+PJSIP
+; for more information.
+;[inbound-publication]
+;type=                     ; Must be of type 'inbound-publication'.
+
+;endpoint=                 ; Optional name of an endpoint that is only allowed
+                           ; to publish to this resource.
+
+
+; MODULE PROVIDING BELOW SECTION(S): res_pjsip_publish_asterisk
+;==========================ASTERISK_PUBLICATION===============================
+; See https://wiki.asterisk.org/wiki/display/AST/Exchanging+Device+and+Mailbox+State+Using+PJSIP
+; for more information.
+;[asterisk-publication]
+;type=asterisk-publication ; Must be of type 'asterisk-publication'.
+
+;devicestate_publish=      ; Optional name of a publish item that can be used
+                           ; to publish a req.
+
+;mailboxstate_publish=     ; Optional name of a publish item that can be used
+                           ; to publish a req.
+
+;device_state=no           ; Whether we should permit incoming device state
+                           ; events.
+
+;device_state_filter=      ; Optional regular expression used to filter what
+                           ; devices we accept events for.
+
+;mailbox_state=no          ; Whether we should permit incoming mailbox state
+                           ; events.
+
+;mailbox_state_filter=     ; Optional regular expression used to filter what
+                           ; mailboxes we accept events for.
diff -urpN asterisk-13.9.1/configs/samples/pjsip_wizard.conf.sample asterisk-13.17.0/configs/samples/pjsip_wizard.conf.sample
--- asterisk-13.9.1/configs/samples/pjsip_wizard.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/pjsip_wizard.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -79,6 +79,13 @@
                          ; sends_auth must also be specified.
                          ; (default: "no")
 
+;sends_line_with_registrations=  ; Setting this to true will cause the wizard to
+                         ; skip the creation of an identify object to match
+                         ; incoming requests to the endpoint and instead add the
+                         ; line and endpoint parameters to the outbound
+                         ; registration object.
+                         ; (default: "no")
+
 ;accepts_registrations=  ; Will create an aor with dynamic contacts which will
                          ; accept registrations.
                          ; accepts_auth must also be specified.
@@ -96,6 +103,11 @@
                  ; SRV records are not currently supported.
                  ; (default: "")
 
+;outbound_proxy= ; Setting this is a shortcut for setting
+                 ; endpoint/outbound_proxy
+                 ; aor/outbound_proxy
+                 ; registration/outbound_proxy
+
 ;transport=      ; The transport to use for the endpoint and registrations
                  ; (default: the pjsip default)
 
diff -urpN asterisk-13.9.1/configs/samples/queues.conf.sample asterisk-13.17.0/configs/samples/queues.conf.sample
--- asterisk-13.9.1/configs/samples/queues.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/queues.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -129,7 +129,7 @@ monitor-type = MixMonitor
 ;
 ;penaltymemberslimit = 5
 ;
-;----------------------QUEUE TIMING OPTIONS------------------------------------
+; ---------------------QUEUE TIMING OPTIONS------------------------------------
 ; A Queue has two different "timeout" values associated with it. One is the
 ; timeout parameter configured in queues.conf. This timeout specifies the
 ; amount of time to try ringing a member's phone before considering the
@@ -181,7 +181,7 @@ monitor-type = MixMonitor
 ;retry = 5
 ;timeoutpriority = app|conf
 ;
-;-----------------------END QUEUE TIMING OPTIONS---------------------------------
+; ----------------------END QUEUE TIMING OPTIONS---------------------------------
 ; Weight of queue - when compared to other queues, higher weights get
 ; first shot at available channels when the same channel is included in
 ; more than one queue.
@@ -299,8 +299,8 @@ monitor-type = MixMonitor
 ;
 ;random-periodic-announce=no
 ;
-; If set to yes, the periodic announcment frequency will be timed from the end
-; of each announcment rather than from the start of each announcment.  This
+; If set to yes, the periodic announcement frequency will be timed from the end
+; of each announcement rather than from the start of each announcement.  This
 ; defaults to off.
 ;
 ;relative-periodic-announce=yes
diff -urpN asterisk-13.9.1/configs/samples/res_odbc.conf.sample asterisk-13.17.0/configs/samples/res_odbc.conf.sample
--- asterisk-13.9.1/configs/samples/res_odbc.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/res_odbc.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -38,18 +38,10 @@ pre-connect => yes
 ; record.  The default is "select 1".
 ;sanitysql => select 1
 ;
-; On some databases, the connection times out and a reconnection will be
-; necessary.  This setting configures the amount of time a connection
-; may sit idle (in seconds) before a reconnection will be attempted.
-;idlecheck => 3600
-;
-; Should we use a single connection for all queries?  Most databases will
-; allow sharing the connection, though Sybase and MS SQL Server will not.
-;share_connections => yes
-;
-; If we aren't sharing connections, what is the maximum number of connections
-; that we should attempt?
-;limit => 5
+; The maximum number of connections to have open at any given time.
+; This defaults to 1 and it is highly recommended to only set this higher
+; if using a version of UnixODBC greater than 2.3.1.
+;max_connections => 20
 ;
 ; When the channel is destroyed, should any uncommitted open transactions
 ; automatically be committed?
@@ -82,13 +74,11 @@ password => mypass
 pre-connect => yes
 
 ; Certain servers, such as MS SQL Server and Sybase use the TDS protocol, which
-; limits the number of active queries per connection to 1.  By telling res_odbc
-; not to share connections, Asterisk can be made to work with these servers.
+; limits the number of active queries per connection to 1.
 [sqlserver]
 enabled => no
 dsn => mickeysoft
-share_connections => no
-limit => 5
+max_connections => 5
 username => oscar
 password => thegrouch
 pre-connect => yes
diff -urpN asterisk-13.9.1/configs/samples/res_snmp.conf.sample asterisk-13.17.0/configs/samples/res_snmp.conf.sample
--- asterisk-13.9.1/configs/samples/res_snmp.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/res_snmp.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -1,6 +1,6 @@
 ;
 ; Configuration file for res_snmp
-;---------------------------------
+; --------------------------------
 ;
 ; Res_snmp can run as a subagent or standalone SNMP agent. The standalone snmp
 ; agent is based on net-snmp and will read a configuration file called
diff -urpN asterisk-13.9.1/configs/samples/rtp.conf.sample asterisk-13.17.0/configs/samples/rtp.conf.sample
--- asterisk-13.9.1/configs/samples/rtp.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/rtp.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -45,6 +45,25 @@ rtpend=20000
 ;
 ; stunaddr=
 ;
+; Some multihomed servers have IP interfaces that cannot reach the STUN
+; server specified by stunaddr.  Blacklist those interface subnets from
+; trying to send a STUN packet to find the external IP address.
+; Attempting to send the STUN packet needlessly delays processing incoming
+; and outgoing SIP INVITEs because we will wait for a response that can
+; never come until we give up on the response.
+; * Multiple subnets may be listed.
+; * Blacklisting applies to IPv4 only.  STUN isn't needed for IPv6.
+; * Blacklisting applies when binding RTP to specific IP addresses and not
+; the wildcard 0.0.0.0 address.  e.g., A PJSIP endpoint binding RTP to a
+; specific address using the bind_rtp_to_media_address and media_address
+; options.  Or the PJSIP endpoint specifies an explicit transport that binds
+; to a specific IP address.
+;
+; e.g. stun_blacklist = 192.168.1.0/255.255.255.0
+;      stun_blacklist = 10.32.77.0/255.255.255.0
+;
+; stun_blacklist =
+;
 ; Hostname or address for the TURN server to be used as a relay. The port
 ; number is optional. If omitted the default value of 3478 will be used.
 ; This option is disabled by default.
@@ -59,6 +78,18 @@ rtpend=20000
 ; Password used to authenticate with TURN relay server.
 ; turnpassword=
 ;
+; Subnets to exclude from ICE host, srflx and relay discovery. This is useful
+; to optimize the ICE process where a system has multiple host address ranges
+; and/or physical interfaces and certain of them are not expected to be used
+; for RTP. For example, VPNs and local interconnections may not be suitable or
+; necessary for ICE. Multiple subnets may be listed. If left unconfigured,
+; all discovered host addresses are used.
+;
+; e.g. ice_blacklist = 192.168.1.0/255.255.255.0
+;      ice_blacklist = 10.32.77.0/255.255.255.0
+;
+; ice_blacklist =
+;
 [ice_host_candidates]
 ;
 ; When Asterisk is behind a static one-to-one NAT and ICE is in use, ICE will
diff -urpN asterisk-13.9.1/configs/samples/sip.conf.sample asterisk-13.17.0/configs/samples/sip.conf.sample
--- asterisk-13.9.1/configs/samples/sip.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/sip.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -15,7 +15,7 @@
 ;		- context - Which set of services you offer various users
 ;
 ; SIP dial strings
-;-----------------------------------------------------------
+; ----------------------------------------------------------
 ; In the dialplan (extensions.conf) you can use several
 ; syntaxes for dialing SIP devices.
 ;        SIP/devicename
@@ -76,7 +76,7 @@
 ;   sip reload                   Reload configuration file
 ;   sip show settings            Show the current channel configuration
 ;
-;------- Naming devices ------------------------------------------------------
+; ------ Naming devices ------------------------------------------------------
 ;
 ; When naming devices, make sure you understand how Asterisk matches calls
 ; that come in.
@@ -100,7 +100,7 @@
 ;       not needed at all. Check below. In later releases, it's renamed
 ;       to "defaultuser" which is a better name, since it is used in
 ;       combination with the "defaultip" setting.
-;-----------------------------------------------------------------------------
+; ----------------------------------------------------------------------------
 
 ; ** Old configuration options **
 ; The "call-limit" configuation option is considered old is replaced
@@ -559,7 +559,7 @@ srvlookup=yes                   ; Enable
                                ; are not purged during SIP reloads.
 
 ;
-;------------------------ TLS settings ------------------------------------------------------------
+; ----------------------- TLS settings ------------------------------------------------------------
 ;tlscertfile=</path/to/certificate.pem> ; Certificate chain (*.pem format only) to use for TLS connections
                                         ; The certificates must be sorted starting with the subject's certificate
                                         ; and followed by intermediate CA certificates if applicable.
@@ -592,9 +592,18 @@ srvlookup=yes                   ; Enable
 ;
 ;tlsclientmethod=tlsv1     ; values include tlsv1, sslv3, sslv2.
                            ; Specify protocol for outbound client connections.
-                           ; If left unspecified, the default is sslv2.
+                           ; If left unspecified, the default is the general-
+                           ; purpose version-flexible SSL/TLS method (sslv23).
+                           ; With that, the actual protocol version used will
+                           ; be negotiated to the highest version mutually
+                           ; supported by Asterisk and the remote server, i.e.
+                           ; TLSv1.2. The supported protocols are listed at
+                           ; http://www.openssl.org/docs/ssl/SSL_CTX_new.html
+                           ; SSLv2 and SSLv3 are disabled within Asterisk.
+                           ; Your distribution might have changed that list
+                           ; further.
 ;
-;--------------------------- SIP timers ----------------------------------------------------
+; -------------------------- SIP timers ----------------------------------------------------
 ; These timers are used primarily in INVITE transactions.
 ; The default for Timer T1 is 500 ms or the measured run-trip time between
 ; Asterisk and the device if you have qualify=yes for the device.
@@ -608,7 +617,7 @@ srvlookup=yes                   ; Enable
                                 ; in this amount of time, the call will autocongest
                                 ; Defaults to 64*timert1
 
-;--------------------------- RTP timers ----------------------------------------------------
+; -------------------------- RTP timers ----------------------------------------------------
 ; These timers are currently used for both audio and video streams. The RTP timeouts
 ; are only applied to the audio channel.
 ; The settings are settable in the global section as well as per device
@@ -624,7 +633,7 @@ srvlookup=yes                   ; Enable
 ;rtpkeepalive=<secs>            ; Send keepalives in the RTP stream to keep NAT open
                                 ; (default is off - zero)
 
-;--------------------------- SIP Session-Timers (RFC 4028)------------------------------------
+; -------------------------- SIP Session-Timers (RFC 4028)------------------------------------
 ; SIP Session-Timers provide an end-to-end keep-alive mechanism for active SIP sessions.
 ; This mechanism can detect and reclaim SIP channels that do not terminate through normal
 ; signaling procedures. Session-Timers can be configured globally or at a user/peer level.
@@ -653,7 +662,7 @@ srvlookup=yes                   ; Enable
 ;session-minse=90
 ;session-refresher=uac
 ;
-;--------------------------- SIP DEBUGGING ---------------------------------------------------
+; -------------------------- SIP DEBUGGING ---------------------------------------------------
 ;sipdebug = yes                 ; Turn on SIP debugging by default, from
                                 ; the moment the channel loads this configuration.
                                 ; NOTE: You cannot use the CLI to turn it off. You'll
@@ -664,7 +673,7 @@ srvlookup=yes                   ; Enable
                                 ; SIP history is output to the DEBUG logging channel
 
 
-;--------------------------- STATUS NOTIFICATIONS (SUBSCRIPTIONS) ----------------------------
+; -------------------------- STATUS NOTIFICATIONS (SUBSCRIPTIONS) ----------------------------
 ; You can subscribe to the status of extensions with a "hint" priority
 ; (See extensions.conf.sample for examples)
 ; chan_sip support two major formats for notifications: dialog-info and SIMPLE
@@ -709,7 +718,7 @@ srvlookup=yes                   ; Enable
 ;callcounter = yes              ; Enable call counters on devices. This can be set per
                                 ; device too.
 
-;----------------------------------------- T.38 FAX SUPPORT ----------------------------------
+; ---------------------------------------- T.38 FAX SUPPORT ----------------------------------
 ;
 ; This setting is available in the [general] section as well as in device configurations.
 ; Setting this to yes enables T.38 FAX (UDPTL) on SIP calls; it defaults to off.
@@ -742,7 +751,7 @@ srvlookup=yes                   ; Enable
 ; faxdetect = cng		; Enables only CNG detection
 ; faxdetect = t38		; Enables only T.38 detection
 ;
-;----------------------------------------- OUTBOUND SIP REGISTRATIONS  ------------------------
+; ---------------------------------------- OUTBOUND SIP REGISTRATIONS  ------------------------
 ; Asterisk can register as a SIP user agent to a SIP proxy (provider)
 ; Format for the register statement is:
 ;       register => [peer?][transport://]user[@domain][:secret[:authuser]]@host[:port][/extension][~expiry]
@@ -819,7 +828,7 @@ srvlookup=yes                   ; Enable
                                 ; 401 responses and continue retrying according to normal
                                 ; retry rules.
 
-;----------------------------------------- OUTBOUND MWI SUBSCRIPTIONS -------------------------
+; ---------------------------------------- OUTBOUND MWI SUBSCRIPTIONS -------------------------
 ; Asterisk can subscribe to receive the MWI from another SIP server and store it locally for retrieval
 ; by other phones. At this time, you can only subscribe using UDP as the transport.
 ; Format for the mwi register statement is:
@@ -834,7 +843,7 @@ srvlookup=yes                   ; Enable
 ; MWI received will be stored in the 1234 mailbox of the SIP_Remote context.
 ; It can be used by other phones by following the below:
 ; mailbox=1234@SIP_Remote
-;----------------------------------------- NAT SUPPORT ------------------------
+; ---------------------------------------- NAT SUPPORT ------------------------
 ;
 ; WARNING: SIP operation behind a NAT is tricky and you really need
 ; to read and understand well the following section.
@@ -972,7 +981,7 @@ srvlookup=yes                   ; Enable
 ;
 ; icesupport = yes
 
-;----------------------------------- MEDIA HANDLING --------------------------------
+; ---------------------------------- MEDIA HANDLING --------------------------------
 ; By default, Asterisk tries to re-invite media streams to an optimal path. If there's
 ; no reason for Asterisk to stay in the media path, the media will be redirected.
 ; This does not really work well in the case where Asterisk is outside and the
@@ -1054,7 +1063,9 @@ srvlookup=yes                   ; Enable
 				; option may be specified at the global or peer scope.
 ;force_avp=yes			; Force 'RTP/AVP', 'RTP/AVPF', 'RTP/SAVP', and 'RTP/SAVPF' to be used for
 				; media streams when appropriate, even if a DTLS stream is present.
-;----------------------------------------- REALTIME SUPPORT ------------------------
+;rtcp_mux=yes			; Enable support for RFC 5761 RTCP multiplexing which is required for
+				; WebRTC support
+; ---------------------------------------- REALTIME SUPPORT ------------------------
 ; For additional information on ARA, the Asterisk Realtime Architecture,
 ; please read https://wiki.asterisk.org/wiki/display/AST/Realtime+Database+Configuration
 ;
@@ -1092,7 +1103,7 @@ srvlookup=yes                   ; Enable
                                 ; is still in memory (due to caching or other reasons), the
                                 ; information will not be removed from realtime storage
 
-;----------------------------------------- SIP DOMAIN SUPPORT ------------------------
+; ---------------------------------------- SIP DOMAIN SUPPORT ------------------------
 ; Incoming INVITE and REFER messages can be matched against a list of 'allowed'
 ; domains, each of which can direct the call to a specific context if desired.
 ; By default, all domains are accepted and sent to the default context or the
@@ -1131,13 +1142,13 @@ srvlookup=yes                   ; Enable
                                 ; destinations which do not have a prior
                                 ; account relationship with your server.
 
-;------------------------------ Advice of Charge CONFIGURATION --------------------------
+; ----------------------------- Advice of Charge CONFIGURATION --------------------------
 ; snom_aoc_enabled = yes;     ; This options turns on and off support for sending AOC-D and
                               ; AOC-E to snom endpoints.  This option can be used both in the
                               ; peer and global scope.  The default for this option is off.
 
 
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
                               ; SIP channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -1169,7 +1180,7 @@ srvlookup=yes                   ; Enable
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
 
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 [authentication]
 ; Global credentials for outbound calls, i.e. when a proxy challenges your
@@ -1188,7 +1199,7 @@ srvlookup=yes                   ; Enable
 ; You may also add auth= statements to [peer] definitions
 ; Peer auth= override all other authentication settings if we match on realm
 
-;------------------------------------------------------------------------------
+; -----------------------------------------------------------------------------
 ; DEVICE CONFIGURATION
 ;
 ; SIP entities have a 'type' which determines their roles within Asterisk.
@@ -1315,11 +1326,14 @@ srvlookup=yes                   ; Enable
 ;						; from the peer's configuration.
 ;
 
-;------------------------------------------------------------------------------
+; -----------------------------------------------------------------------------
 ; DTLS-SRTP CONFIGURATION
 ;
 ; DTLS-SRTP support is available if the underlying RTP engine in use supports it.
 ;
+; Note: DTLS configuration must be set directly on a user, peer, or friend. Setting these
+;       options globally in the [general] section will have no effect.
+;
 ; dtlsenable = yes                   ; Enable or disable DTLS-SRTP support
 ; dtlsverify = yes                   ; Verify that provided peer certificate and fingerprint are valid
 ;				     ; A value of 'yes' will perform both certificate and fingerprint verification
@@ -1370,7 +1384,7 @@ srvlookup=yes                   ; Enable
 ;port=80                          ; The port number we want to connect to on the remote side
                                   ; Also used as "defaultport" in combination with "defaultip" settings
 
-;--- sample definition for a provider
+; -- sample definition for a provider
 ;[provider1]
 ;type=peer
 ;host=sip.provider1.com
diff -urpN asterisk-13.9.1/configs/samples/skinny.conf.sample asterisk-13.17.0/configs/samples/skinny.conf.sample
--- asterisk-13.9.1/configs/samples/skinny.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/skinny.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -54,7 +54,7 @@ keepalive=120
 ;cos_audio=5		; Sets 802.1p priority for RTP audio packets.
 ;cos_video=4		; Sets 802.1p priority for RTP video packets.
 
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ;jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
                              ; skinny channel. Defaults to "no". An enabled jitterbuffer will
                              ; be used only if the sending side can create and the receiving
@@ -79,10 +79,10 @@ keepalive=120
                              ; Defaults to fixed.
 
 ;jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 [lines]
-;----------------------------------- LINES SECTION --------------------------------
+; ---------------------------------- LINES SECTION --------------------------------
 ; Options set under [lines] apply to all lines unless explicitly set for a particular
 ; device. The options that can be set under lines are specified in GENERAL LINE OPTIONS.
 ; These options can also be set for each individual device as well as those under SPECIFIC
@@ -95,15 +95,15 @@ keepalive=120
 ; Where options are common to both lines and devices, the results typically take that of
 ; the least permission. ie if a no is set for either line or device, the call will not be
 ; able to use that permission
-;-------------------------------- GENERAL LINE OPTIONS -----------------------------
+; ------------------------------- GENERAL LINE OPTIONS -----------------------------
 ;earlyrtp=1                  ; whether audio signalling should be provided by asterisk
 ;                            ; (earlyrtp=1) or device generated (earlyrtp=0). default=yes
 ;transfer=1                  ; whether the device is allowed to transfer. default=yes
 ;context=default             ; context to use for this line.
 ;callfwdtimeout=20000        ; ms before cfwd_noans occurs (default 20 secs)
-;------------------------------- SPECIFIC LINE OPTIONS -----------------------------
+; ------------------------------ SPECIFIC LINE OPTIONS -----------------------------
 ;setvar=        	     ; allows for the setting of chanvars.
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 ;[100]
 ;nat=yes
@@ -149,7 +149,7 @@ keepalive=120
 
 
 [devices]
-;---------------------------------- DEVICES SECTION -------------------------------
+; --------------------------------- DEVICES SECTION -------------------------------
 ; Options set under [devices] apply to all devices unless explicitly set for a particular
 ; device. The options that can be set under devices are specified in GENERAL DEVICE OPTIONS.
 ; These options can also be set for each individual device as well as those under SPECIFIC
@@ -162,16 +162,16 @@ keepalive=120
 ; Where options are common to both lines and devices, the results typically take that of
 ; the least permission. ie if a no is set for either line or device, the call will not be
 ; able to use that permission
-;------------------------------- GENERAL DEVICE OPTIONS ----------------------------
+; ------------------------------ GENERAL DEVICE OPTIONS ----------------------------
 ;earlyrtp=1                  ; whether audio signalling should be provided by asterisk
 ;                            ; (earlyrtp=1) or device generated (earlyrtp=0). default=yes
 ;transfer=1                  ; whether the device is allowed to transfer. default=yes
-;------------------------------ SPECIFIC DEVICE OPTIONS ----------------------------
+; ----------------------------- SPECIFIC DEVICE OPTIONS ----------------------------
 ;device="SEPxxxxxxxxxxxx     ; id of the device. Must be set.
 ;version=P002G204	     ; firmware version to be loaded. If this version is different
 ;                            ; to the one on the device, the device will try to load this
 ;                            ; version from the tftp server. Set to device firmware version.
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 ; Typical config for 12SP+
 ;[florian]
diff -urpN asterisk-13.9.1/configs/samples/sorcery.conf.sample asterisk-13.17.0/configs/samples/sorcery.conf.sample
--- asterisk-13.9.1/configs/samples/sorcery.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/sorcery.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -64,4 +64,15 @@ test=memory
 ;auth=realtime,ps_auths
 ;aor=realtime,ps_aors
 ;domain_alias=realtime,ps_domain_aliases
+
+;[res_pjsip_endpoint_identifier_ip]
 ;identify=realtime,ps_endpoint_id_ips
+
+;[res_pjsip_outbound_publish]
+;outbound-publish=realtime,ps_outbound_publishes
+
+;[res_pjsip_pubsub]
+;inbound-publication=realtime,ps_inbound_publications
+
+;[res_pjsip_publish_asterisk]
+;asterisk-publication=realtime,ps_asterisk_publications
diff -urpN asterisk-13.9.1/configs/samples/unistim.conf.sample asterisk-13.17.0/configs/samples/unistim.conf.sample
--- asterisk-13.9.1/configs/samples/unistim.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/unistim.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -17,7 +17,7 @@ port=5000                    ; UDP port
 ;autoprovisioning=no         ; Allow undeclared phones to register an extension. See README for important
                              ; informations. no (default), yes, tn.
 ;mohsuggest=default
-;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; ----------------------------- JITTER BUFFER CONFIGURATION --------------------------
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
                               ; SIP channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
@@ -41,7 +41,7 @@ port=5000                    ; UDP port
                               ; variable size, actually the new jb of IAX2). Defaults to fixed.
 
 ; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
-;-----------------------------------------------------------------------------------
+; ----------------------------------------------------------------------------------
 
 
 ;[black]                     ; name of the device
diff -urpN asterisk-13.9.1/configs/samples/voicemail.conf.sample asterisk-13.17.0/configs/samples/voicemail.conf.sample
--- asterisk-13.9.1/configs/samples/voicemail.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/voicemail.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -227,6 +227,9 @@ pagerdateformat=%A, %B %d, %Y at %r
 ;imapclosetimeout=60     ; The TCP close timeout (in seconds)
 ;imapreadtimeout=60      ; The TCP read timeout (in seconds)
 ;imapwritetimeout=60     ; The TCP write timeout (in seconds)
+;imap_poll_logout=no     ; If pollmailboxes=yes, then specify whether need to
+                         ; disconnect from the IMAP server after polling.
+                         ; Default: no
 
 ; -----------------------------------------------------------------------------
 ;
@@ -333,6 +336,13 @@ sendvoicemail=yes ; Allow the user to co
                     ; The default is "no".
 ; minpassword=0 ; Enforce minimum password length
 
+; vm-login=custom_sound
+			;     Customize which sound file is used instead of the default
+			;     prompt that says: "Comedian Mail. Mailbox?"
+; vm-newuser=custom_sound
+			;     Customize which sound file is used instead of the default
+			;     prompt that says: "Welcome to Comedian Mail. First, I will
+			;     guide you through a short setup process."
 ; vm-password=custom_sound
 			;     Customize which sound file is used instead of the default
 			;     prompt that says: "password"
@@ -376,6 +386,16 @@ sendvoicemail=yes ; Allow the user to co
 ; defaults to being off
 ; backupdeleted=100
 
+; Asterisk Task Processor Queue Size
+; On heavy loaded system you may need to increase 'app_voicemail' taskprocessor queue.
+; If the taskprocessor queue size reached high water level, the alert is triggered.
+; If the alert is set then some modules (for example pjsip) slow down its production
+; until the alert is cleared.
+; The alert is cleared when taskprocessor queue size drops to the low water clear level.
+; The next options set taskprocessor queue levels for this module.
+; tps_queue_high=500	; Taskprocessor high water alert trigger level.
+; tps_queue_low=450	; Taskprocessor low water clear alert level.
+			; The default is -1 for 90% of high water level.
 
 [zonemessages]
 ; Users may be located in different timezones, or may have different
@@ -422,7 +442,7 @@ european=Europe/Copenhagen|'vm-received'
 ; Note: The rest of the system must reference mailboxes defined here as mailbox@default.
 
 1234 => 4242,Example Mailbox,root@localhost
-;4200 => 9855,Mark Spencer,markster@linux-support.net,mypager@digium.com,attach=no|serveremail=myaddy@digium.com|tz=central|maxmsg=10
+;4200 => 9855,Mark Spencer,markster@linux-support.net,mypager@digium.com,attach=no|serveremail=myaddy@digium.com|fromstring=MySystem|tz=central|maxmsg=10
 ;4300 => 3456,Ben Rigas,ben@american-computer.net
 ;4310 => -5432,Sales,sales@marko.net
 ;4069 => 6522,Matt Brooks,matt@marko.net,,|tz=central|attach=yes|saycid=yes|dialout=fromvm|callback=fromvm|review=yes|operator=yes|envelope=yes|moveheard=yes|sayduration=yes|saydurationm=1
diff -urpN asterisk-13.9.1/configs/samples/vpb.conf.sample asterisk-13.17.0/configs/samples/vpb.conf.sample
--- asterisk-13.9.1/configs/samples/vpb.conf.sample	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configs/samples/vpb.conf.sample	2017-07-12 13:12:08.000000000 +0200
@@ -199,7 +199,7 @@ grunttimeout=3600
 ;
 mode=immediate
 
-;-------------------------------------------------------------------------
+; ------------------------------------------------------------------------
 ; Channel definitions
 ;
 ; Each channel inherits the settings specified above, unless the are
diff -urpN asterisk-13.9.1/configure asterisk-13.17.0/configure
--- asterisk-13.9.1/configure	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configure	2017-07-12 13:12:08.000000000 +0200
@@ -639,6 +639,11 @@ PBX_SYSLOG_FACILITY_LOG_DAEMON
 PBX_SYSLOG_FACILITY_LOG_CRON
 PBX_SYSLOG_FACILITY_LOG_AUTHPRIV
 PBX_SYSLOG_FACILITY_LOG_AUTH
+SYSTEMD_LIBS
+SYSTEMD_CFLAGS
+SYSTEMD_INCLUDE
+SYSTEMD_LIB
+PBX_SYSTEMD
 PBX_GENERIC_ODBC
 GENERIC_ODBC_INCLUDE
 GENERIC_ODBC_LIB
@@ -663,6 +668,10 @@ PWLIB_LIBDIR
 PWLIB_INCDIR
 PWLIBDIR
 PTLIB_CONFIG
+PYTHONDEV_LIBS
+PYTHONDEV_CFLAGS
+PYTHONDEV_INCLUDE
+PYTHONDEV_LIB
 PJPROJECT_LIBS
 PJPROJECT_CFLAGS
 PG_CONFIG
@@ -688,6 +697,7 @@ PBX_IP_MTU_DISCOVER
 PBX_RTLD_NOLOAD
 PBX_GLOB_BRACE
 PBX_GLOB_NOMAGIC
+BIND8_CFLAGS
 AST_RPATH
 AST_NATIVE_ARCH
 AST_SHADOW_WARNINGS
@@ -695,8 +705,6 @@ AST_NO_STRICT_OVERFLOW
 AST_FORTIFY_SOURCE
 AST_TRAMPOLINES
 AST_DECLARATION_AFTER_STATEMENT
-GC_LDFLAGS
-GC_CFLAGS
 AST_UNDEFINED_SANITIZER
 AST_LEAK_SANITIZER
 AST_THREAD_SANITIZER
@@ -758,6 +766,10 @@ PBX_SUPPSERV
 SUPPSERV_DIR
 SUPPSERV_INCLUDE
 SUPPSERV_LIB
+PBX_RT
+RT_DIR
+RT_INCLUDE
+RT_LIB
 PBX_OPENSSL
 OPENSSL_DIR
 OPENSSL_INCLUDE
@@ -798,7 +810,6 @@ PBX_SPANDSP
 SPANDSP_DIR
 SPANDSP_INCLUDE
 SPANDSP_LIB
-SOUNDS_CACHE_DIR
 PBX_SDL_IMAGE
 SDL_IMAGE_DIR
 SDL_IMAGE_INCLUDE
@@ -911,6 +922,26 @@ PBX_POPT
 POPT_DIR
 POPT_INCLUDE
 POPT_LIB
+PBX_PJSIP_TSX_LAYER_FIND_TSX2
+PJSIP_TSX_LAYER_FIND_TSX2_DIR
+PJSIP_TSX_LAYER_FIND_TSX2_INCLUDE
+PJSIP_TSX_LAYER_FIND_TSX2_LIB
+PBX_PJSIP_EVSUB_SET_UAS_TIMEOUT
+PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR
+PJSIP_EVSUB_SET_UAS_TIMEOUT_INCLUDE
+PJSIP_EVSUB_SET_UAS_TIMEOUT_LIB
+PBX_PJSIP_AUTH_CLT_DEINIT
+PJSIP_AUTH_CLT_DEINIT_DIR
+PJSIP_AUTH_CLT_DEINIT_INCLUDE
+PJSIP_AUTH_CLT_DEINIT_LIB
+PBX_PJSIP_INV_SESSION_REF
+PJSIP_INV_SESSION_REF_DIR
+PJSIP_INV_SESSION_REF_INCLUDE
+PJSIP_INV_SESSION_REF_LIB
+PBX_PJSIP_EVSUB_GRP_LOCK
+PJSIP_EVSUB_GRP_LOCK_DIR
+PJSIP_EVSUB_GRP_LOCK_INCLUDE
+PJSIP_EVSUB_GRP_LOCK_LIB
 PBX_PJSIP_TLS_TRANSPORT_PROTO
 PJSIP_TLS_TRANSPORT_PROTO_DIR
 PJSIP_TLS_TRANSPORT_PROTO_INCLUDE
@@ -939,11 +970,6 @@ PBX_PJSIP_DLG_CREATE_UAS_AND_INC_LOCK
 PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_DIR
 PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_INCLUDE
 PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_LIB
-PJPROJECT_BUNDLED
-PBX_PJPROJECT
-PJPROJECT_DIR
-PJPROJECT_INCLUDE
-PJPROJECT_LIB
 PBX_PGSQL
 PGSQL_DIR
 PGSQL_INCLUDE
@@ -1020,6 +1046,10 @@ PBX_LIBXML2
 LIBXML2_DIR
 LIBXML2_INCLUDE
 LIBXML2_LIB
+PBX_LIBEDIT_IS_UNICODE
+LIBEDIT_IS_UNICODE_DIR
+LIBEDIT_IS_UNICODE_INCLUDE
+LIBEDIT_IS_UNICODE_LIB
 PBX_LIBEDIT
 LIBEDIT_DIR
 LIBEDIT_INCLUDE
@@ -1108,10 +1138,6 @@ PBX_DAHDI
 DAHDI_DIR
 DAHDI_INCLUDE
 DAHDI_LIB
-PBX_OPENSSL_ECDH_AUTO
-OPENSSL_ECDH_AUTO_DIR
-OPENSSL_ECDH_AUTO_INCLUDE
-OPENSSL_ECDH_AUTO_LIB
 PBX_OPENSSL_EC
 OPENSSL_EC_DIR
 OPENSSL_EC_INCLUDE
@@ -1160,29 +1186,46 @@ PBX_ALSA
 ALSA_DIR
 ALSA_INCLUDE
 ALSA_LIB
+PJPROJECT_INCLUDE
+PJPROJECT_LIB
+PBX_PJPROJECT
+PJPROJECT_DIR
+PJPROJECT_BUNDLED
+PJPROJECT_CONFIGURE_OPTS
 AST_C_COMPILER_FAMILY
 AST_CLANG_BLOCKS
 AST_CLANG_BLOCKS_LIBS
 AST_NESTED_FUNCTIONS
 AST_CODE_COVERAGE
+EXTERNALS_CACHE_DIR
+SOUNDS_CACHE_DIR
 AST_DEVMODE_STRICT
 AST_DEVMODE
 NOISY_BUILD
 PTHREAD_CFLAGS
 PTHREAD_LIBS
 PTHREAD_CC
-acx_pthread_config
+ax_pthread_config
 MD5
 SOXMIX
+PBX_BASH
+PBX_XMLSTARLET
 PBX_FLEX
 PBX_BISON
 OPENSSL
 SHA1SUM
 LDCONFIG
+DOWNLOAD_TIMEOUT
+DOWNLOAD_TO_STDOUT
 DOWNLOAD
 FETCH
+NM
+PATCH
+TAR
+BZIP2
 ALEMBIC
 GIT
+BASH
 XMLSTARLET
 XMLLINT
 KPATHSEA
@@ -1199,6 +1242,7 @@ COMPRESS
 FIND
 PYTHON
 FLEX
+CAT
 CMP
 BISON
 GNU_LD
@@ -1308,7 +1352,10 @@ ac_user_opts='
 enable_option_checking
 with_gnu_ld
 enable_dev_mode
+with_sounds_cache
+with_externals_cache
 enable_coverage
+with_pjproject_bundled
 with_asound
 with_bfd
 with_execinfo
@@ -1359,7 +1406,6 @@ with_osptk
 with_oss
 with_postgres
 with_pjproject
-with_pjproject_bundled
 with_popt
 with_portaudio
 with_pri
@@ -1368,7 +1414,6 @@ with_radius
 with_resample
 with_sdl
 with_SDL_image
-with_sounds_cache
 with_spandsp
 with_ss7
 with_speex
@@ -1407,6 +1452,7 @@ CXX
 CXXFLAGS
 CCC
 CXXCPP
+PJPROJECT_CONFIGURE_OPTS
 PKG_CONFIG
 PKG_CONFIG_PATH
 PKG_CONFIG_LIBDIR
@@ -1416,10 +1462,14 @@ LIBEDIT_CFLAGS
 LIBEDIT_LIBS
 PJPROJECT_CFLAGS
 PJPROJECT_LIBS
+PYTHONDEV_CFLAGS
+PYTHONDEV_LIBS
 GMIME_CFLAGS
 GMIME_LIBS
 GTK2_CFLAGS
-GTK2_LIBS'
+GTK2_LIBS
+SYSTEMD_CFLAGS
+SYSTEMD_LIBS'
 
 
 # Initialize some variables set by options.
@@ -2045,6 +2095,12 @@ Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+  --with-sounds-cache=PATH
+                          use cached sound tarfiles in PATH
+  --with-externals-cache=PATH
+                          use cached external module tarfiles in PATH
+  --with-pjproject-bundled
+                          Use bundled pjproject libraries
   --with-asound=PATH      use Advanced Linux Sound Architecture files in PATH
   --with-bfd=PATH         use Debug symbol decoding files in PATH
   --with-execinfo=PATH    use Stack Backtrace files in PATH
@@ -2076,7 +2132,8 @@ Optional Packages:
   --with-uriparser=PATH   use uriparser library files in PATH
   --with-kqueue=PATH      use kqueue support files in PATH
   --with-ldap=PATH        use OpenLDAP files in PATH
-  --with-libcurl=DIR      look for the curl library in DIR
+  --with-libcurl=PREFIX   look for the curl library in PREFIX/lib and headers
+                          in PREFIX/include
   --with-libedit=PATH     use NetBSD Editline library files in PATH, use
                           'internal' Editline otherwise
   --with-libxml2=PATH     use LibXML2 files in PATH
@@ -2098,8 +2155,6 @@ Optional Packages:
   --with-oss=PATH         use Open Sound System files in PATH
   --with-postgres=PATH    use PostgreSQL files in PATH
   --with-pjproject=PATH   use PJPROJECT files in PATH
-  --with-pjproject-bundled
-                          Use bundled pjproject libraries
   --with-popt=PATH        use popt files in PATH
   --with-portaudio=PATH   use PortAudio files in PATH
   --with-pri=PATH         use ISDN PRI files in PATH
@@ -2108,8 +2163,6 @@ Optional Packages:
   --with-resample=PATH    use LIBRESAMPLE files in PATH
   --with-sdl=PATH         use Sdl files in PATH
   --with-SDL_image=PATH   use Sdl Image files in PATH
-  --with-sounds-cache=PATH
-                          use cached sound tarfiles in PATH
   --with-spandsp=PATH     use SPANDSP files in PATH
   --with-ss7=PATH         use ISDN SS7 files in PATH
   --with-speex=PATH       use Speex files in PATH
@@ -2143,6 +2196,8 @@ Some influential environment variables:
   CXX         C++ compiler command
   CXXFLAGS    C++ compiler flags
   CXXCPP      C++ preprocessor
+  PJPROJECT_CONFIGURE_OPTS
+              Additional configure options to pass to bundled pjproject
   PKG_CONFIG  path to pkg-config utility
   PKG_CONFIG_PATH
               directories to add to pkg-config's search path
@@ -2158,11 +2213,19 @@ Some influential environment variables:
               C compiler flags for PJPROJECT, overriding pkg-config
   PJPROJECT_LIBS
               linker flags for PJPROJECT, overriding pkg-config
+  PYTHONDEV_CFLAGS
+              C compiler flags for PYTHONDEV, overriding pkg-config
+  PYTHONDEV_LIBS
+              linker flags for PYTHONDEV, overriding pkg-config
   GMIME_CFLAGS
               C compiler flags for GMIME, overriding pkg-config
   GMIME_LIBS  linker flags for GMIME, overriding pkg-config
   GTK2_CFLAGS C compiler flags for GTK2, overriding pkg-config
   GTK2_LIBS   linker flags for GTK2, overriding pkg-config
+  SYSTEMD_CFLAGS
+              C compiler flags for SYSTEMD, overriding pkg-config
+  SYSTEMD_LIBS
+              linker flags for SYSTEMD, overriding pkg-config
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -4843,7 +4906,7 @@ case "${host_os}" in
      OSARCH=cygwin
      PBX_WINARCH=1
      ;;
-     linux-gnueabi* |  linux-gnuspe)
+     linux-gnu*)
      OSARCH=linux-gnu
      ;;
      kfreebsd*-gnu)
@@ -6709,6 +6772,47 @@ $as_echo "no" >&6; }
 fi
 
 
+# Extract the first word of "cat", so it can be a program name with args.
+set dummy cat; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_CAT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $CAT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_CAT="$CAT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_CAT="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_CAT" && ac_cv_path_CAT=":"
+  ;;
+esac
+fi
+CAT=$ac_cv_path_CAT
+if test -n "$CAT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CAT" >&5
+$as_echo "$CAT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 # Extract the first word of "flex", so it can be a program name with args.
 set dummy flex; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -7447,6 +7551,47 @@ $as_echo "no" >&6; }
 fi
 
 
+# Extract the first word of "bash", so it can be a program name with args.
+set dummy bash; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_BASH+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $BASH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_BASH="$BASH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_BASH="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_BASH" && ac_cv_path_BASH=":"
+  ;;
+esac
+fi
+BASH=$ac_cv_path_BASH
+if test -n "$BASH"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BASH" >&5
+$as_echo "$BASH" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 # Extract the first word of "git", so it can be a program name with args.
 set dummy git; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -7529,10 +7674,220 @@ $as_echo "no" >&6; }
 fi
 
 
+# Extract the first word of "bzip2", so it can be a program name with args.
+set dummy bzip2; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_BZIP2+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $BZIP2 in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_BZIP2="$BZIP2" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_BZIP2="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_BZIP2" && ac_cv_path_BZIP2=":"
+  ;;
+esac
+fi
+BZIP2=$ac_cv_path_BZIP2
+if test -n "$BZIP2"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BZIP2" >&5
+$as_echo "$BZIP2" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# Extract the first word of "tar", so it can be a program name with args.
+set dummy tar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_TAR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $TAR in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_TAR="$TAR" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_TAR="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_TAR" && ac_cv_path_TAR=":"
+  ;;
+esac
+fi
+TAR=$ac_cv_path_TAR
+if test -n "$TAR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $TAR" >&5
+$as_echo "$TAR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# Extract the first word of "patch", so it can be a program name with args.
+set dummy patch; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_PATCH+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $PATCH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PATCH="$PATCH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PATCH="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_PATCH" && ac_cv_path_PATCH=":"
+  ;;
+esac
+fi
+PATCH=$ac_cv_path_PATCH
+if test -n "$PATCH"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PATCH" >&5
+$as_echo "$PATCH" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# Extract the first word of "sed", so it can be a program name with args.
+set dummy sed; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_SED+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $SED in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_SED="$SED" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_SED="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_SED" && ac_cv_path_SED=":"
+  ;;
+esac
+fi
+SED=$ac_cv_path_SED
+if test -n "$SED"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $SED" >&5
+$as_echo "$SED" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# Extract the first word of "nm", so it can be a program name with args.
+set dummy nm; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_NM+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $NM in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_NM="$NM" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_NM="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_NM" && ac_cv_path_NM=":"
+  ;;
+esac
+fi
+NM=$ac_cv_path_NM
+if test -n "$NM"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NM" >&5
+$as_echo "$NM" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
 if test "${WGET}" != ":" ; then
   DOWNLOAD=${WGET}
+  DOWNLOAD_TO_STDOUT="${WGET} -q -O-"
+  DOWNLOAD_TIMEOUT='--timeout=$1'
 else if test "${CURL}" != ":" ; then
   DOWNLOAD="${CURL} -O --progress-bar -w \"%{url_effective}\n\""
+  DOWNLOAD_TO_STDOUT="${CURL} -Ls"
+  DOWNLOAD_TIMEOUT='--max-time $(or $2,$1)'
 else
   # Extract the first word of "fetch", so it can be a program name with args.
 set dummy fetch; ac_word=$2
@@ -7576,9 +7931,15 @@ fi
 
 
   DOWNLOAD=${FETCH}
+  DOWNLOAD_TO_STDOUT="${FETCH} -o-"
+  DOWNLOAD_TIMEOUT='--timeout=$(or $2,$1)'
 fi
 fi
 
+
+
+
+
 # Extract the first word of "ldconfig", so it can be a program name with args.
 set dummy ldconfig; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -7754,6 +8115,20 @@ else
 fi
 
 
+if test "x${XMLSTARLET}" = "x:" ; then
+	PBX_XMLSTARLET=0
+else
+	PBX_XMLSTARLET=1
+fi
+
+
+if test "x${BASH}" = "x:" ; then
+	PBX_BASH=0
+else
+	PBX_BASH=1
+fi
+
+
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}soxmix", so it can be a program name with args.
 set dummy ${ac_tool_prefix}soxmix; ac_word=$2
@@ -7899,6 +8274,76 @@ if test "${MD5}" = "digest" ; then
    MD5="${MD5} -a md5"
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if ${ac_cv_path_SED+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_SED" || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+
 
 
 
@@ -7908,22 +8353,26 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS con
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-acx_pthread_ok=no
+ax_pthread_ok=no
 
 # We used to check for pthread.h first, but this fails if pthread.h
-# requires special compiler flags (e.g. on True64 or Sequent).
+# requires special compiler flags (e.g. on Tru64 or Sequent).
 # It gets checked for in the link test anyway.
 
 # First of all, check if the user has set any of the PTHREAD_LIBS,
 # etcetera environment variables, and if threads linking works using
 # them:
-if test x"$PTHREAD_LIBS$PTHREAD_CFLAGS" != x; then
-        save_CFLAGS="$CFLAGS"
+if test "x$PTHREAD_CFLAGS$PTHREAD_LIBS" != "x"; then
+        ax_pthread_save_CC="$CC"
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        if test "x$PTHREAD_CC" != "x"; then :
+  CC="$PTHREAD_CC"
+fi
         CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-        save_LIBS="$LIBS"
         LIBS="$PTHREAD_LIBS $LIBS"
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_join in LIBS=$PTHREAD_LIBS with CFLAGS=$PTHREAD_CFLAGS" >&5
-$as_echo_n "checking for pthread_join in LIBS=$PTHREAD_LIBS with CFLAGS=$PTHREAD_CFLAGS... " >&6; }
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS" >&5
+$as_echo_n "checking for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS... " >&6; }
         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -7943,18 +8392,19 @@ return pthread_join ();
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  acx_pthread_ok=yes
+  ax_pthread_ok=yes
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_pthread_ok" >&5
-$as_echo "$acx_pthread_ok" >&6; }
-        if test x"$acx_pthread_ok" = xno; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_pthread_ok" >&5
+$as_echo "$ax_pthread_ok" >&6; }
+        if test "x$ax_pthread_ok" = "xno"; then
                 PTHREAD_LIBS=""
                 PTHREAD_CFLAGS=""
         fi
-        LIBS="$save_LIBS"
-        CFLAGS="$save_CFLAGS"
+        CC="$ax_pthread_save_CC"
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
 fi
 
 # We must check for the threads library under a number of different
@@ -7967,7 +8417,7 @@ fi
 # which indicates that we try without any flags at all, and "pthread-config"
 # which is a program returning the flags for the Pth emulation library.
 
-acx_pthread_flags="pthreads none -Kthread -kthread lthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config"
+ax_pthread_flags="pthreads none -Kthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config"
 
 # The ordering *is* (sometimes) important.  Some notes on the
 # individual items follow:
@@ -7976,59 +8426,269 @@ acx_pthread_flags="pthreads none -Kthrea
 # none: in case threads are in libc; should be tried before -Kthread and
 #       other compiler flags to prevent continual compiler warnings
 # -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
-# -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
-# lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
-# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads)
-# -pthreads: Solaris/gcc
-# -mthreads: Mingw32/gcc, Lynx/gcc
+# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads), Tru64
+#           (Note: HP C rejects this with "bad form for `-t' option")
+# -pthreads: Solaris/gcc (Note: HP C also rejects)
 # -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
-#      doesn't hurt to check since this sometimes defines pthreads too;
-#      also defines -D_REENTRANT)
-#      ... -mt is also the pthreads flag for HP/aCC
+#      doesn't hurt to check since this sometimes defines pthreads and
+#      -D_REENTRANT too), HP C (must be checked before -lpthread, which
+#      is present but should not be used directly; and before -mthreads,
+#      because the compiler interprets this as "-mt" + "-hreads")
+# -mthreads: Mingw32/gcc, Lynx/gcc
 # pthread: Linux, etcetera
 # --thread-safe: KAI C++
 # pthread-config: use pthread-config program (for GNU Pth library)
 
-case "${host_cpu}-${host_os}" in
-        *solaris*)
+case $host_os in
+
+        freebsd*)
+
+        # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
+        # lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
+
+        ax_pthread_flags="-kthread lthread $ax_pthread_flags"
+        ;;
+
+        hpux*)
+
+        # From the cc(1) man page: "[-mt] Sets various -D flags to enable
+        # multi-threading and also sets -lpthread."
+
+        ax_pthread_flags="-mt -pthread pthread $ax_pthread_flags"
+        ;;
+
+        openedition*)
+
+        # IBM z/OS requires a feature-test macro to be defined in order to
+        # enable POSIX threads at all, so give the user a hint if this is
+        # not set. (We don't define these ourselves, as they can affect
+        # other portions of the system API in unpredictable ways.)
+
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#            if !defined(_OPEN_THREADS) && !defined(_UNIX03_THREADS)
+             AX_PTHREAD_ZOS_MISSING
+#            endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "AX_PTHREAD_ZOS_MISSING" >/dev/null 2>&1; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support." >&5
+$as_echo "$as_me: WARNING: IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support." >&2;}
+fi
+rm -f conftest*
+
+        ;;
+
+        solaris*)
 
         # On Solaris (at least, for some versions), libc contains stubbed
         # (non-functional) versions of the pthreads routines, so link-based
-        # tests will erroneously succeed.  (We need to link with -pthreads/-mt/
-        # -lpthread.)  (The stubs are missing pthread_cleanup_push, or rather
-        # a function called by this macro, so we could check for that, but
-        # who knows whether they'll stub that too in a future libc.)  So,
-        # we'll just look for -pthreads and -lpthread first:
+        # tests will erroneously succeed. (N.B.: The stubs are missing
+        # pthread_cleanup_push, or rather a function called by this macro,
+        # so we could check for that, but who knows whether they'll stub
+        # that too in a future libc.)  So we'll check first for the
+        # standard Solaris way of linking pthreads (-mt -lpthread).
+
+        ax_pthread_flags="-mt,pthread pthread $ax_pthread_flags"
+        ;;
+esac
+
+# GCC generally uses -pthread, or -pthreads on some platforms (e.g. SPARC)
+
+if test "x$GCC" = "xyes"; then :
+  ax_pthread_flags="-pthread -pthreads $ax_pthread_flags"
+fi
+
+# The presence of a feature test macro requesting re-entrant function
+# definitions is, on some systems, a strong hint that pthreads support is
+# correctly enabled
+
+case $host_os in
+        darwin* | hpux* | linux* | osf* | solaris*)
+        ax_pthread_check_macro="_REENTRANT"
+        ;;
+
+        aix*)
+        ax_pthread_check_macro="_THREAD_SAFE"
+        ;;
 
-        acx_pthread_flags="-pthreads pthread -mt -pthread $acx_pthread_flags"
+        *)
+        ax_pthread_check_macro="--"
         ;;
 esac
+if test "x$ax_pthread_check_macro" = "x--"; then :
+  ax_pthread_check_cond=0
+else
+  ax_pthread_check_cond="!defined($ax_pthread_check_macro)"
+fi
+
+# Are we compiling with Clang?
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC is Clang" >&5
+$as_echo_n "checking whether $CC is Clang... " >&6; }
+if ${ax_cv_PTHREAD_CLANG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ax_cv_PTHREAD_CLANG=no
+     # Note that Autoconf sets GCC=yes for Clang as well as GCC
+     if test "x$GCC" = "xyes"; then
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Note: Clang 2.7 lacks __clang_[a-z]+__ */
+#            if defined(__clang__) && defined(__llvm__)
+             AX_PTHREAD_CC_IS_CLANG
+#            endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "AX_PTHREAD_CC_IS_CLANG" >/dev/null 2>&1; then :
+  ax_cv_PTHREAD_CLANG=yes
+fi
+rm -f conftest*
+
+     fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_PTHREAD_CLANG" >&5
+$as_echo "$ax_cv_PTHREAD_CLANG" >&6; }
+ax_pthread_clang="$ax_cv_PTHREAD_CLANG"
+
+ax_pthread_clang_warning=no
+
+# Clang needs special handling, because older versions handle the -pthread
+# option in a rather... idiosyncratic way
+
+if test "x$ax_pthread_clang" = "xyes"; then
+
+        # Clang takes -pthread; it has never supported any other flag
+
+        # (Note 1: This will need to be revisited if a system that Clang
+        # supports has POSIX threads in a separate library.  This tends not
+        # to be the way of modern systems, but it's conceivable.)
+
+        # (Note 2: On some systems, notably Darwin, -pthread is not needed
+        # to get POSIX threads support; the API is always present and
+        # active.  We could reasonably leave PTHREAD_CFLAGS empty.  But
+        # -pthread does define _REENTRANT, and while the Darwin headers
+        # ignore this macro, third-party headers might not.)
+
+        PTHREAD_CFLAGS="-pthread"
+        PTHREAD_LIBS=
+
+        ax_pthread_ok=yes
+
+        # However, older versions of Clang make a point of warning the user
+        # that, in an invocation where only linking and no compilation is
+        # taking place, the -pthread option has no effect ("argument unused
+        # during compilation").  They expect -pthread to be passed in only
+        # when source code is being compiled.
+        #
+        # Problem is, this is at odds with the way Automake and most other
+        # C build frameworks function, which is that the same flags used in
+        # compilation (CFLAGS) are also used in linking.  Many systems
+        # supported by AX_PTHREAD require exactly this for POSIX threads
+        # support, and in fact it is often not straightforward to specify a
+        # flag that is used only in the compilation phase and not in
+        # linking.  Such a scenario is extremely rare in practice.
+        #
+        # Even though use of the -pthread flag in linking would only print
+        # a warning, this can be a nuisance for well-run software projects
+        # that build with -Werror.  So if the active version of Clang has
+        # this misfeature, we search for an option to squash it.
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether Clang needs flag to prevent \"argument unused\" warning when linking with -pthread" >&5
+$as_echo_n "checking whether Clang needs flag to prevent \"argument unused\" warning when linking with -pthread... " >&6; }
+if ${ax_cv_PTHREAD_CLANG_NO_WARN_FLAG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=unknown
+             # Create an alternate version of $ac_link that compiles and
+             # links in two steps (.c -> .o, .o -> exe) instead of one
+             # (.c -> exe), because the warning occurs only in the second
+             # step
+             ax_pthread_save_ac_link="$ac_link"
+             ax_pthread_sed='s/conftest\.\$ac_ext/conftest.$ac_objext/g'
+             ax_pthread_link_step=`$as_echo "$ac_link" | sed "$ax_pthread_sed"`
+             ax_pthread_2step_ac_link="($ac_compile) && (echo ==== >&5) && ($ax_pthread_link_step)"
+             ax_pthread_save_CFLAGS="$CFLAGS"
+             for ax_pthread_try in '' -Qunused-arguments -Wno-unused-command-line-argument unknown; do
+                if test "x$ax_pthread_try" = "xunknown"; then :
+  break
+fi
+                CFLAGS="-Werror -Wunknown-warning-option $ax_pthread_try -pthread $ax_pthread_save_CFLAGS"
+                ac_link="$ax_pthread_save_ac_link"
+                cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(void){return 0;}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_link="$ax_pthread_2step_ac_link"
+                     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(void){return 0;}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  break
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+             done
+             ac_link="$ax_pthread_save_ac_link"
+             CFLAGS="$ax_pthread_save_CFLAGS"
+             if test "x$ax_pthread_try" = "x"; then :
+  ax_pthread_try=no
+fi
+             ax_cv_PTHREAD_CLANG_NO_WARN_FLAG="$ax_pthread_try"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_PTHREAD_CLANG_NO_WARN_FLAG" >&5
+$as_echo "$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG" >&6; }
+
+        case "$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG" in
+                no | unknown) ;;
+                *) PTHREAD_CFLAGS="$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG $PTHREAD_CFLAGS" ;;
+        esac
+
+fi # $ax_pthread_clang = yes
 
-if test x"$acx_pthread_ok" = xno; then
-for flag in $acx_pthread_flags; do
+if test "x$ax_pthread_ok" = "xno"; then
+for ax_pthread_try_flag in $ax_pthread_flags; do
 
-        case $flag in
+        case $ax_pthread_try_flag in
                 none)
                 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pthreads work without any flags" >&5
 $as_echo_n "checking whether pthreads work without any flags... " >&6; }
                 ;;
 
+                -mt,pthread)
+                { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pthreads work with -mt -lpthread" >&5
+$as_echo_n "checking whether pthreads work with -mt -lpthread... " >&6; }
+                PTHREAD_CFLAGS="-mt"
+                PTHREAD_LIBS="-lpthread"
+                ;;
+
                 -*)
-                { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pthreads work with $flag" >&5
-$as_echo_n "checking whether pthreads work with $flag... " >&6; }
-                PTHREAD_CFLAGS="$flag"
+                { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pthreads work with $ax_pthread_try_flag" >&5
+$as_echo_n "checking whether pthreads work with $ax_pthread_try_flag... " >&6; }
+                PTHREAD_CFLAGS="$ax_pthread_try_flag"
                 ;;
 
-		pthread-config)
-		# Extract the first word of "pthread-config", so it can be a program name with args.
+                pthread-config)
+                # Extract the first word of "pthread-config", so it can be a program name with args.
 set dummy pthread-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_acx_pthread_config+:} false; then :
+if ${ac_cv_prog_ax_pthread_config+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$acx_pthread_config"; then
-  ac_cv_prog_acx_pthread_config="$acx_pthread_config" # Let the user override the test.
+  if test -n "$ax_pthread_config"; then
+  ac_cv_prog_ax_pthread_config="$ax_pthread_config" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -8037,7 +8697,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_acx_pthread_config="yes"
+    ac_cv_prog_ax_pthread_config="yes"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -8045,35 +8705,37 @@ done
   done
 IFS=$as_save_IFS
 
-  test -z "$ac_cv_prog_acx_pthread_config" && ac_cv_prog_acx_pthread_config="no"
+  test -z "$ac_cv_prog_ax_pthread_config" && ac_cv_prog_ax_pthread_config="no"
 fi
 fi
-acx_pthread_config=$ac_cv_prog_acx_pthread_config
-if test -n "$acx_pthread_config"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_pthread_config" >&5
-$as_echo "$acx_pthread_config" >&6; }
+ax_pthread_config=$ac_cv_prog_ax_pthread_config
+if test -n "$ax_pthread_config"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_pthread_config" >&5
+$as_echo "$ax_pthread_config" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
-		if test x"$acx_pthread_config" = xno; then continue; fi
-		PTHREAD_CFLAGS="`pthread-config --cflags`"
-		PTHREAD_LIBS="`pthread-config --ldflags` `pthread-config --libs`"
-		;;
+                if test "x$ax_pthread_config" = "xno"; then :
+  continue
+fi
+                PTHREAD_CFLAGS="`pthread-config --cflags`"
+                PTHREAD_LIBS="`pthread-config --ldflags` `pthread-config --libs`"
+                ;;
 
                 *)
-                { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the pthreads library -l$flag" >&5
-$as_echo_n "checking for the pthreads library -l$flag... " >&6; }
-                PTHREAD_LIBS="-l$flag"
+                { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the pthreads library -l$ax_pthread_try_flag" >&5
+$as_echo_n "checking for the pthreads library -l$ax_pthread_try_flag... " >&6; }
+                PTHREAD_LIBS="-l$ax_pthread_try_flag"
                 ;;
         esac
 
-        save_LIBS="$LIBS"
-        save_CFLAGS="$CFLAGS"
-        LIBS="$PTHREAD_LIBS $LIBS"
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
         CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
 
         # Check for various functions.  We must include pthread.h,
         # since some functions may be macros.  (On the Sequent, we
@@ -8084,33 +8746,42 @@ $as_echo_n "checking for the pthreads li
         # pthread_cleanup_push because it is one of the few pthread
         # functions on Solaris that doesn't have a non-functional libc stub.
         # We try pthread_create on general principles.
+
         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <pthread.h>
+#                       if $ax_pthread_check_cond
+#                        error "$ax_pthread_check_macro must be defined"
+#                       endif
+                        static void routine(void *a) { a = 0; }
+                        static void *start_routine(void *a) { return a; }
 int
 main ()
 {
-pthread_t th; pthread_join(th, 0);
-                     pthread_attr_init(0); pthread_cleanup_push(0, 0);
-                     pthread_create(0,0,0,0); pthread_cleanup_pop(0);
+pthread_t th; pthread_attr_t attr;
+                        pthread_create(&th, 0, start_routine, 0);
+                        pthread_join(th, 0);
+                        pthread_attr_init(&attr);
+                        pthread_cleanup_push(routine, 0);
+                        pthread_cleanup_pop(0) /* ; */
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  acx_pthread_ok=yes
+  ax_pthread_ok=yes
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 
-        LIBS="$save_LIBS"
-        CFLAGS="$save_CFLAGS"
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
 
-        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_pthread_ok" >&5
-$as_echo "$acx_pthread_ok" >&6; }
-        if test "x$acx_pthread_ok" = xyes; then
-                break;
-        fi
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_pthread_ok" >&5
+$as_echo "$ax_pthread_ok" >&6; }
+        if test "x$ax_pthread_ok" = "xyes"; then :
+  break
+fi
 
         PTHREAD_LIBS=""
         PTHREAD_CFLAGS=""
@@ -8118,63 +8789,127 @@ done
 fi
 
 # Various other checks:
-if test "x$acx_pthread_ok" = xyes; then
-        save_LIBS="$LIBS"
-        LIBS="$PTHREAD_LIBS $LIBS"
-        save_CFLAGS="$CFLAGS"
+if test "x$ax_pthread_ok" = "xyes"; then
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
         CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
 
         # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for joinable pthread attribute" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for joinable pthread attribute" >&5
 $as_echo_n "checking for joinable pthread attribute... " >&6; }
-	attr_name=unknown
-	for attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do
-	    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+if ${ax_cv_PTHREAD_JOINABLE_ATTR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ax_cv_PTHREAD_JOINABLE_ATTR=unknown
+             for ax_pthread_attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do
+                 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <pthread.h>
 int
 main ()
 {
-int attr=$attr; return attr;
+int attr = $ax_pthread_attr; return attr /* ; */
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  attr_name=$attr; break
+  ax_cv_PTHREAD_JOINABLE_ATTR=$ax_pthread_attr; break
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-	done
-        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $attr_name" >&5
-$as_echo "$attr_name" >&6; }
-        if test "$attr_name" != PTHREAD_CREATE_JOINABLE; then
+             done
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_PTHREAD_JOINABLE_ATTR" >&5
+$as_echo "$ax_cv_PTHREAD_JOINABLE_ATTR" >&6; }
+        if test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xunknown" && \
+               test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xPTHREAD_CREATE_JOINABLE" && \
+               test "x$ax_pthread_joinable_attr_defined" != "xyes"; then :
 
 cat >>confdefs.h <<_ACEOF
-#define PTHREAD_CREATE_JOINABLE $attr_name
+#define PTHREAD_CREATE_JOINABLE $ax_cv_PTHREAD_JOINABLE_ATTR
 _ACEOF
 
-        fi
+               ax_pthread_joinable_attr_defined=yes
 
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if more special flags are required for pthreads" >&5
-$as_echo_n "checking if more special flags are required for pthreads... " >&6; }
-        flag=no
-        case "${host_cpu}-${host_os}" in
-            *-aix* | *-freebsd* | *-darwin*) flag="-D_THREAD_SAFE";;
-            *solaris* | *-osf* | *-hpux*) flag="-D_REENTRANT";;
-        esac
-        { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${flag}" >&5
-$as_echo "${flag}" >&6; }
-        if test "x$flag" != xno; then
-            PTHREAD_CFLAGS="$flag $PTHREAD_CFLAGS"
-        fi
+fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether more special flags are required for pthreads" >&5
+$as_echo_n "checking whether more special flags are required for pthreads... " >&6; }
+if ${ax_cv_PTHREAD_SPECIAL_FLAGS+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ax_cv_PTHREAD_SPECIAL_FLAGS=no
+             case $host_os in
+             solaris*)
+             ax_cv_PTHREAD_SPECIAL_FLAGS="-D_POSIX_PTHREAD_SEMANTICS"
+             ;;
+             esac
 
-        LIBS="$save_LIBS"
-        CFLAGS="$save_CFLAGS"
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_PTHREAD_SPECIAL_FLAGS" >&5
+$as_echo "$ax_cv_PTHREAD_SPECIAL_FLAGS" >&6; }
+        if test "x$ax_cv_PTHREAD_SPECIAL_FLAGS" != "xno" && \
+               test "x$ax_pthread_special_flags_added" != "xyes"; then :
+  PTHREAD_CFLAGS="$ax_cv_PTHREAD_SPECIAL_FLAGS $PTHREAD_CFLAGS"
+               ax_pthread_special_flags_added=yes
+fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for PTHREAD_PRIO_INHERIT" >&5
+$as_echo_n "checking for PTHREAD_PRIO_INHERIT... " >&6; }
+if ${ax_cv_PTHREAD_PRIO_INHERIT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <pthread.h>
+int
+main ()
+{
+int i = PTHREAD_PRIO_INHERIT;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ax_cv_PTHREAD_PRIO_INHERIT=yes
+else
+  ax_cv_PTHREAD_PRIO_INHERIT=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_PTHREAD_PRIO_INHERIT" >&5
+$as_echo "$ax_cv_PTHREAD_PRIO_INHERIT" >&6; }
+        if test "x$ax_cv_PTHREAD_PRIO_INHERIT" = "xyes" && \
+               test "x$ax_pthread_prio_inherit_defined" != "xyes"; then :
+
+$as_echo "#define HAVE_PTHREAD_PRIO_INHERIT 1" >>confdefs.h
+
+               ax_pthread_prio_inherit_defined=yes
 
-        # More AIX lossage: must compile with xlc_r or cc_r
-	if test x"$GCC" != xyes; then
-          for ac_prog in xlc_r cc_r
+fi
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        # More AIX lossage: compile with *_r variant
+        if test "x$GCC" != "xyes"; then
+            case $host_os in
+                aix*)
+                case "x/$CC" in #(
+  x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6) :
+    #handle absolute path differently from PATH based program lookup
+                     case "x$CC" in #(
+  x/*) :
+    if as_fn_executable_p ${CC}_r; then :
+  PTHREAD_CC="${CC}_r"
+fi ;; #(
+  *) :
+    for ac_prog in ${CC}_r
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
@@ -8215,27 +8950,31 @@ fi
 
   test -n "$PTHREAD_CC" && break
 done
-test -n "$PTHREAD_CC" || PTHREAD_CC="${CC}"
-
-        else
-          PTHREAD_CC=$CC
-	fi
-else
-        PTHREAD_CC="$CC"
+test -n "$PTHREAD_CC" || PTHREAD_CC="$CC"
+ ;;
+esac ;; #(
+  *) :
+     ;;
+esac
+                ;;
+            esac
+        fi
 fi
 
+test -n "$PTHREAD_CC" || PTHREAD_CC="$CC"
+
 
 
 
 
 # Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:
-if test x"$acx_pthread_ok" = xyes; then
+if test "x$ax_pthread_ok" = "xyes"; then
 
 $as_echo "#define HAVE_PTHREAD 1" >>confdefs.h
 
         :
 else
-        acx_pthread_ok=no
+        ax_pthread_ok=no
 
 fi
 ac_ext=c
@@ -8274,6 +9013,55 @@ fi
 
 
 
+
+
+# Check whether --with-sounds-cache was given.
+if test "${with_sounds_cache+set}" = set; then :
+  withval=$with_sounds_cache;
+	case ${withval} in
+	n|no)
+		unset SOUNDS_CACHE_DIR
+		;;
+	*)
+		if test "x${withval}" = "x"; then
+			:
+		else
+			SOUNDS_CACHE_DIR="${withval}"
+		fi
+		;;
+	esac
+
+else
+  :
+fi
+
+
+
+
+
+# Check whether --with-externals-cache was given.
+if test "${with_externals_cache+set}" = set; then :
+  withval=$with_externals_cache;
+	case ${withval} in
+	n|no)
+		unset EXTERNALS_CACHE_DIR
+		;;
+	*)
+		if test "x${withval}" = "x"; then
+			:
+		else
+			EXTERNALS_CACHE_DIR="${withval}"
+		fi
+		;;
+	esac
+
+else
+  :
+fi
+
+
+
+
 AST_CODE_COVERAGE=no
 # Check whether --enable-coverage was given.
 if test "${enable_coverage+set}" = set; then :
@@ -8426,23 +9214,163 @@ rm -f core conftest.err conftest.$ac_obj
 	CFLAGS="$save_CFLAGS"
 
 
-# AST_EXT_LIB_SETUP is used to tell configure to handle variables for
-# various packages.
-# $1 is the prefix for the variables in makeopts and autoconfig.h
-# $2 is the short comment, $4 is the long comment
-# $3 is the name used in --with- or --without- flags for configure.
-#
-# Package option names should be in alphabetical order
-# by the --with option name (the third field),
-# to make things easier for the users.
+PJPROJECT_BUNDLED=no
 
 
-    ALSA_DESCRIP="Advanced Linux Sound Architecture"
-    ALSA_OPTION="asound"
-    PBX_ALSA=0
 
-# Check whether --with-asound was given.
-if test "${with_asound+set}" = set; then :
+# Check whether --with-pjproject-bundled was given.
+if test "${with_pjproject_bundled+set}" = set; then :
+  withval=$with_pjproject_bundled; case "${withval}" in
+	      n|no) PJPROJECT_BUNDLED=no ;;
+	      *) PJPROJECT_BUNDLED=yes ;;
+	esac
+fi
+
+
+
+
+	if test "$PJPROJECT_BUNDLED" = "yes" ; then
+
+	if test "${ac_mandatory_list#*PJPROJECT*}" != "$ac_mandatory_list" ; then
+		as_fn_error $? "--with-pjproject and --with-pjproject-bundled can't both be specified" "$LINENO" 5
+	fi
+
+	ac_mandatory_list="$ac_mandatory_list PJPROJECT"
+	PJPROJECT_DIR="${ac_top_build_prefix}third-party/pjproject"
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for embedded pjproject (may have to download)" >&5
+$as_echo_n "checking for embedded pjproject (may have to download)... " >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: configuring" >&5
+$as_echo "configuring" >&6; }
+
+	if test "x${DOWNLOAD_TO_STDOUT}" = "x" ; then
+		as_fn_error $? "A download utility (wget, curl or fetch) is required to download bundled pjproject" "$LINENO" 5
+	fi
+	if test "${BZIP2}" = ":" ; then
+		as_fn_error $? "bzip2 is required to extract the pjproject tar file" "$LINENO" 5
+	fi
+	if test "${TAR}" = ":" ; then
+		as_fn_error $? "tar is required to extract the pjproject tar file" "$LINENO" 5
+	fi
+	if test "${PATCH}" = ":" ; then
+		as_fn_error $? "patch is required to configure bundled pjproject" "$LINENO" 5
+	fi
+	if test "${SED}" = ":" ; then
+		as_fn_error $? "sed is required to configure bundled pjproject" "$LINENO" 5
+	fi
+	if test "${NM}" = ":" ; then
+		as_fn_error $? "nm is required to build bundled pjproject" "$LINENO" 5
+	fi
+	if test "${MD5}" = ":" ; then
+		as_fn_error $? "md5sum is required to build bundled pjproject" "$LINENO" 5
+	fi
+	if test "${CAT}" = ":" ; then
+		as_fn_error $? "cat is required to build bundled pjproject" "$LINENO" 5
+	fi
+
+
+	this_host=$(./config.sub $(./config.guess))
+	if test "$build" != "$this_host" ; then
+		PJPROJECT_CONFIGURE_OPTS+=" --build=$build"
+	fi
+	if test "$host" != "$this_host" ; then
+		PJPROJECT_CONFIGURE_OPTS+=" --host=$host"
+	fi
+
+	export TAR PATCH SED NM EXTERNALS_CACHE_DIR DOWNLOAD_TO_STDOUT DOWNLOAD_TIMEOUT DOWNLOAD MD5 CAT
+	export NOISY_BUILD
+	${GNU_MAKE} --quiet --no-print-directory -C ${PJPROJECT_DIR} \
+		PJPROJECT_CONFIGURE_OPTS="$PJPROJECT_CONFIGURE_OPTS" \
+		EXTERNALS_CACHE_DIR="${EXTERNALS_CACHE_DIR}" \
+		configure
+	if test $? -ne 0 ; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
+$as_echo "failed" >&6; }
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: Unable to configure ${PJPROJECT_DIR}" >&5
+$as_echo "$as_me: Unable to configure ${PJPROJECT_DIR}" >&6;}
+		as_fn_error $? "Re-run the ./configure command with 'NOISY_BUILD=yes' appended to see error details." "$LINENO" 5
+	fi
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for bundled pjproject" >&5
+$as_echo_n "checking for bundled pjproject... " >&6; }
+
+	PJPROJECT_INCLUDE=$(${GNU_MAKE} --quiet --no-print-directory -C ${PJPROJECT_DIR} PJPROJECT_CONFIGURE_OPTS="$PJPROJECT_CONFIGURE_OPTS" EXTERNALS_CACHE_DIR="${EXTERNALS_CACHE_DIR}" echo_cflags)
+	PJPROJECT_CFLAGS="$PJPROJECT_INCLUDE"
+	PBX_PJPROJECT=1
+
+
+$as_echo "#define HAVE_PJPROJECT 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJPROJECT_BUNDLED 1" >>confdefs.h
+
+
+
+$as_echo "#define HAVE_PJSIP_DLG_CREATE_UAS_AND_INC_LOCK 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJ_TRANSACTION_GRP_LOCK 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_REPLACE_MEDIA_STREAM 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_GET_DEST_INFO 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJ_SSL_CERT_LOAD_FROM_FILES2 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_EXTERNAL_RESOLVER 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_TLS_TRANSPORT_PROTO 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_EVSUB_GRP_LOCK 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_INV_SESSION_REF 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_AUTH_CLT_DEINIT 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_EVSUB_SET_UAS_TIMEOUT 1" >>confdefs.h
+
+
+$as_echo "#define HAVE_PJSIP_TSX_LAYER_FIND_TSX2 1" >>confdefs.h
+
+
+
+
+
+
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+	fi
+
+
+
+# AST_EXT_LIB_SETUP is used to tell configure to handle variables for
+# various packages.
+# $1 is the prefix for the variables in makeopts and autoconfig.h
+# $2 is the short comment, $4 is the long comment
+# $3 is the name used in --with- or --without- flags for configure.
+#
+# Package option names should be in alphabetical order
+# by the --with option name (the third field),
+# to make things easier for the users.
+
+
+    ALSA_DESCRIP="Advanced Linux Sound Architecture"
+    ALSA_OPTION="asound"
+    PBX_ALSA=0
+
+# Check whether --with-asound was given.
+if test "${with_asound+set}" = set; then :
   withval=$with_asound;
 	case ${withval} in
 	n|no)
@@ -8764,18 +9692,6 @@ PBX_OPENSSL_EC=0
 
 
 
-OPENSSL_ECDH_AUTO_DESCRIP="OpenSSL Auto ECDH Support"
-OPENSSL_ECDH_AUTO_OPTION=crypto
-OPENSSL_ECDH_AUTO_DIR=${CRYPTO_DIR}
-
-PBX_OPENSSL_ECDH_AUTO=0
-
-
-
-
-
-
-
     DAHDI_DESCRIP="DAHDI"
     DAHDI_OPTION="dahdi"
     PBX_DAHDI=0
@@ -9437,6 +10353,10 @@ fi
 
 
 
+
+
+
+
 # Check whether --with-libcurl was given.
 if test "${with_libcurl+set}" = set; then :
   withval=$with_libcurl; _libcurl_with=$withval
@@ -9524,7 +10444,6 @@ done
   done
 IFS=$as_save_IFS
 
-  test -z "$ac_cv_path__libcurl_config" && ac_cv_path__libcurl_config=""$withval/bin""
   ;;
 esac
 fi
@@ -9674,10 +10593,11 @@ int x;
 curl_easy_setopt(NULL,CURLOPT_URL,NULL);
 x=CURL_ERROR_SIZE;
 x=CURLOPT_WRITEFUNCTION;
-x=CURLOPT_FILE;
+x=CURLOPT_WRITEDATA;
 x=CURLOPT_ERRORBUFFER;
 x=CURLOPT_STDERR;
 x=CURLOPT_VERBOSE;
+if (x) {;}
 
   ;
   return 0;
@@ -9744,17 +10664,23 @@ _ACEOF
 
               # We don't have --protocols, so just assume that all
               # protocols are available
-              _libcurl_protocols="HTTP FTP FILE TELNET LDAP DICT"
+              _libcurl_protocols="HTTP FTP FILE TELNET LDAP DICT TFTP"
 
               if test x$libcurl_feature_SSL = xyes ; then
                  _libcurl_protocols="$_libcurl_protocols HTTPS"
 
                  # FTPS wasn't standards-compliant until version
-                 # 7.11.0
+                 # 7.11.0 (0x070b00 == 461568)
                  if test $_libcurl_version -ge 461568; then
                     _libcurl_protocols="$_libcurl_protocols FTPS"
                  fi
               fi
+
+              # RTSP, IMAP, POP3 and SMTP were added in
+              # 7.20.0 (0x071400 == 463872)
+              if test $_libcurl_version -ge 463872; then
+                 _libcurl_protocols="$_libcurl_protocols RTSP IMAP POP3 SMTP"
+              fi
            fi
 
            for _libcurl_protocol in $_libcurl_protocols ; do
@@ -9825,6 +10751,18 @@ fi
 
 
 
+LIBEDIT_IS_UNICODE_DESCRIP="Libedit compiled for unicode"
+LIBEDIT_IS_UNICODE_OPTION=libedit
+LIBEDIT_IS_UNICODE_DIR=${LIBEDIT_DIR}
+
+PBX_LIBEDIT_IS_UNICODE=0
+
+
+
+
+
+
+
     LIBXML2_DESCRIP="LibXML2"
     LIBXML2_OPTION="libxml2"
     PBX_LIBXML2=0
@@ -10413,6 +11351,7 @@ fi
 
 
 
+if test "x${PBX_PJPROJECT}" != "x1" ; then
 
     PJPROJECT_DESCRIP="PJPROJECT"
     PJPROJECT_OPTION="pjproject"
@@ -10445,29 +11384,6 @@ fi
 
 
 
-PJPROJECT_BUNDLED=no
-
-
-
-# Check whether --with-pjproject-bundled was given.
-if test "${with_pjproject_bundled+set}" = set; then :
-  withval=$with_pjproject_bundled; case "${enableval}" in
-	      n|no) PJPROJECT_BUNDLED=no ;;
-	      *) PJPROJECT_BUNDLED=yes ;;
-	esac
-fi
-
-
-
-if test "$PJPROJECT_BUNDLED" = "yes" -a "${ac_mandatory_list#*PJPROJECT*}" != "$ac_mandatory_list" ; then
-   as_fn_error $? "--with-pjproject and --with-pjproject-bundled can't both be specified" "$LINENO" 5
-fi
-
-if test "$PJPROJECT_BUNDLED" = "yes" ; then
-   ac_mandatory_list="$ac_mandatory_list PJPROJECT"
-   PJPROJECT_DIR="${ac_top_build_prefix}third-party/pjproject"
-fi
-
 
 PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_DESCRIP="PJSIP Dialog Create UAS with Incremented Lock"
 PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_OPTION=pjsip
@@ -10553,6 +11469,67 @@ PBX_PJSIP_TLS_TRANSPORT_PROTO=0
 
 
 
+PJSIP_EVSUB_GRP_LOCK_DESCRIP="PJSIP EVSUB Group Lock support"
+PJSIP_EVSUB_GRP_LOCK_OPTION=pjsip
+PJSIP_EVSUB_GRP_LOCK_DIR=${PJPROJECT_DIR}
+
+PBX_PJSIP_EVSUB_GRP_LOCK=0
+
+
+
+
+
+
+
+PJSIP_INV_SESSION_REF_DESCRIP="PJSIP INVITE Session Reference Count support"
+PJSIP_INV_SESSION_REF_OPTION=pjsip
+PJSIP_INV_SESSION_REF_DIR=${PJPROJECT_DIR}
+
+PBX_PJSIP_INV_SESSION_REF=0
+
+
+
+
+
+
+
+PJSIP_AUTH_CLT_DEINIT_DESCRIP="pjsip_auth_clt_deinit support"
+PJSIP_AUTH_CLT_DEINIT_OPTION=pjsip
+PJSIP_AUTH_CLT_DEINIT_DIR=${PJPROJECT_DIR}
+
+PBX_PJSIP_AUTH_CLT_DEINIT=0
+
+
+
+
+
+
+
+PJSIP_EVSUB_SET_UAS_TIMEOUT_DESCRIP="PJSIP EVSUB Set UAS Timeout support"
+PJSIP_EVSUB_SET_UAS_TIMEOUT_OPTION=pjsip
+PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR=${PJPROJECT_DIR}
+
+PBX_PJSIP_EVSUB_SET_UAS_TIMEOUT=0
+
+
+
+
+
+
+
+PJSIP_TSX_LAYER_FIND_TSX2_DESCRIP="pjsip_tsx_layer_find_tsx2 support"
+PJSIP_TSX_LAYER_FIND_TSX2_OPTION=pjsip
+PJSIP_TSX_LAYER_FIND_TSX2_DIR=${PJPROJECT_DIR}
+
+PBX_PJSIP_TSX_LAYER_FIND_TSX2=0
+
+
+
+
+
+
+fi
+
 
     POPT_DESCRIP="popt"
     POPT_OPTION="popt"
@@ -11054,30 +12031,6 @@ fi
 
 
 
-
-# Check whether --with-sounds-cache was given.
-if test "${with_sounds_cache+set}" = set; then :
-  withval=$with_sounds_cache;
-	case ${withval} in
-	n|no)
-		unset SOUNDS_CACHE_DIR
-		;;
-	*)
-		if test "x${withval}" = "x"; then
-			:
-		else
-			SOUNDS_CACHE_DIR="${withval}"
-		fi
-		;;
-	esac
-
-else
-  :
-fi
-
-
-
-
     SPANDSP_DESCRIP="SPANDSP"
     SPANDSP_OPTION="spandsp"
     PBX_SPANDSP=0
@@ -11389,6 +12342,18 @@ fi
 
 
 
+RT_DESCRIP="Realtime functions"
+
+RT_DIR=${rt_DIR}
+
+PBX_RT=0
+
+
+
+
+
+
+
     SUPPSERV_DESCRIP="mISDN Supplemental Services"
     SUPPSERV_OPTION="suppserv"
     PBX_SUPPSERV=0
@@ -13049,6 +14014,112 @@ if test "x$JANSSON_LIB" == "x"; then
   as_fn_error $? "*** JSON support not found (this typically means the libjansson development package is missing)" "$LINENO" 5
 fi
 
+# See if clock_gettime is in librt
+
+if test "x${PBX_RT}" != "x1" -a "${USE_RT}" != "no"; then
+   pbxlibdir=""
+   # if --with-RT=DIR has been specified, use it.
+   if test "x${RT_DIR}" != "x"; then
+      if test -d ${RT_DIR}/lib; then
+         pbxlibdir="-L${RT_DIR}/lib"
+      else
+         pbxlibdir="-L${RT_DIR}"
+      fi
+   fi
+   pbxfuncname="clock_gettime"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_RT_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_rt_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lrt" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lrt... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrt ${pbxlibdir}  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_RT_FOUND=yes
+else
+  AST_RT_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_RT_FOUND}" = "yes"; then
+      RT_LIB="${pbxlibdir} -lrt "
+      # if --with-RT=DIR has been specified, use it.
+      if test "x${RT_DIR}" != "x"; then
+         RT_INCLUDE="-I${RT_DIR}/include"
+      fi
+      RT_INCLUDE="${RT_INCLUDE} "
+      if test "x" = "x" ; then	# no header, assume found
+         RT_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${RT_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "" "ac_cv_header_" "$ac_includes_default"
+if test "x$ac_cv_header_" = xyes; then :
+  RT_HEADER_FOUND=1
+else
+  RT_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${RT_HEADER_FOUND}" = "x0" ; then
+         RT_LIB=""
+         RT_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            RT_LIB=""
+         fi
+         PBX_RT=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_RT 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
 
 		if test "x${PBX_LIBXML2}" != "x1" -a "${USE_LIBXML2}" != "no"; then
 		PBX_LIBXML2=0
@@ -15138,46 +16209,6 @@ _ACEOF
 
 rm -f conftest*
 
-if ${ac_cv_func_setvbuf_reversed+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_func_setvbuf_reversed=no
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking return type of signal handlers" >&5
-$as_echo_n "checking return type of signal handlers... " >&6; }
-if ${ac_cv_type_signal+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <signal.h>
-
-int
-main ()
-{
-return *(signal (0, 0)) (0) == 1;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_type_signal=int
-else
-  ac_cv_type_signal=void
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_signal" >&5
-$as_echo "$ac_cv_type_signal" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define RETSIGTYPE $ac_cv_type_signal
-_ACEOF
-
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lstat correctly handles trailing slash" >&5
 $as_echo_n "checking whether lstat correctly handles trailing slash... " >&6; }
 if ${ac_cv_func_lstat_dereferences_slashed_symlink+:} false; then :
@@ -16769,6 +17800,39 @@ fi
 
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we have usable eventfd support" >&5
+$as_echo_n "checking if we have usable eventfd support... " >&6; }
+if test "$cross_compiling" = yes; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: cross-compile" >&5
+$as_echo "cross-compile" >&6; }
+
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/eventfd.h>
+int
+main ()
+{
+return eventfd(0, EFD_NONBLOCK | EFD_SEMAPHORE) == -1;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HAVE_EVENTFD 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for compiler 'attribute pure' support" >&5
 $as_echo_n "checking for compiler 'attribute pure' support... " >&6; }
@@ -17518,6 +18582,74 @@ CFLAGS="$saved_CFLAGS"
 
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for compiler 'attribute noreturn' support" >&5
+$as_echo_n "checking for compiler 'attribute noreturn' support... " >&6; }
+saved_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -Wall -Wno-unused -Werror"
+
+
+if test "xnoreturn" = "x"
+then
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ void __attribute__((noreturn)) *test(void *muffin, ...) {return (void *) 0;}
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_ATTRIBUTE_noreturn 1
+_ACEOF
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ void __attribute__((noreturn)) *test(void *muffin, ...) ;
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_ATTRIBUTE_noreturn 1
+_ACEOF
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+CFLAGS="$saved_CFLAGS"
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -fsanitize=address support" >&5
 $as_echo_n "checking for -fsanitize=address support... " >&6; }
 saved_sanitize_CFLAGS="${CFLAGS}"
@@ -17540,7 +18672,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
 $as_echo "yes" >&6; }
 	AST_ADDRESS_SANITIZER=1
 else
-  AST_ADDRESS_SANITIZER=
+  AST_ADDRESS_SANITIZER=0
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
@@ -17572,7 +18704,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
 $as_echo "yes" >&6; }
 	AST_THREAD_SANITIZER=1
 else
-  AST_THREAD_SANITIZER=
+  AST_THREAD_SANITIZER=0
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
@@ -17604,7 +18736,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
 $as_echo "yes" >&6; }
 	AST_LEAK_SANITIZER=1
 else
-  AST_LEAK_SANITIZER=
+  AST_LEAK_SANITIZER=0
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
@@ -17636,7 +18768,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
 $as_echo "yes" >&6; }
 	AST_UNDEFINED_SANITIZER=1
 else
-  AST_UNDEFINED_SANITIZER=
+  AST_UNDEFINED_SANITIZER=0
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
@@ -17646,62 +18778,6 @@ CFLAGS="${saved_sanitize_CFLAGS}"
 LDFLAGS="${saved_sanitize_LDFLAGS}"
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ffunction-sections support" >&5
-$as_echo_n "checking for -ffunction-sections support... " >&6; }
-saved_CFLAGS="${CFLAGS}"
-CFLAGS="${CFLAGS} -ffunction-sections"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-int x = 1;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-	saved_LDFLAGS="${LDFLAGS}"
-	LDFLAGS="${LDFLAGS} -Wl,--gc-sections"
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for --gc-sections support" >&5
-$as_echo_n "checking for --gc-sections support... " >&6; }
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-int x = 1;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		GC_CFLAGS="-ffunction-sections"
-		GC_LDFLAGS="-Wl,--gc-sections"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="${saved_LDFLAGS}"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-CFLAGS="${saved_CFLAGS}"
-
-
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -Wdeclaration-after-statement support" >&5
 $as_echo_n "checking for -Wdeclaration-after-statement support... " >&6; }
 if $(${CC} -Wdeclaration-after-statement -S -o /dev/null -xc /dev/null > /dev/null 2>&1); then
@@ -17770,19 +18846,13 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -march=native support" >&5
 $as_echo_n "checking for -march=native support... " >&6; }
 if $(${CC} -march=native -S -o /dev/null -xc /dev/null > /dev/null 2>&1); then
-	if test "${CONFIG_CFLAGS}" = ""; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
-		AST_NATIVE_ARCH=1
-	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: user CFLAGS present" >&5
-$as_echo "user CFLAGS present" >&6; }
-		AST_NATIVE_ARCH=
-	fi
+	AST_NATIVE_ARCH=1
 else
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	AST_NATIVE_ARCH=
+	AST_NATIVE_ARCH=0
 fi
 
 
@@ -18117,6 +19187,33 @@ fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BIND_8_COMPAT required" >&5
+$as_echo_n "checking for BIND_8_COMPAT required... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#undef BIND_8_COMPAT
+#include <arpa/nameser.h>
+
+int
+main ()
+{
+int x = NXDOMAIN
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+BIND8_CFLAGS=-DBIND_8_COMPAT
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 
     if test "x${PBX_GLOB_NOMAGIC}" != "x1"; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GLOB_NOMAGIC in glob.h" >&5
@@ -20000,34 +21097,81 @@ fi
    fi
 
       if test "$PBX_LIBEDIT" = "1"; then
-	 LIBEDIT_INTERNAL="no"
+      LIBEDIT_INTERNAL="no"
       fi
    fi
    if test "${LIBEDIT_INTERNAL}" = "yes"; then
       PBX_LIBEDIT=1
-   fi
-fi
+      LIBEDIT_IS_UNICODE=no
+   else
 
+    if test "x${PBX_LIBEDIT_IS_UNICODE}" != "x1" -a "${USE_LIBEDIT_IS_UNICODE}" != "no"; then
+        if test "xTesting for libedit unicode support" != "x"; then
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Testing for libedit unicode support" >&5
+$as_echo_n "checking for Testing for libedit unicode support... " >&6; }
+	else
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking if \"el_rfunc_t *callback;\" compiles using histedit.h" >&5
+$as_echo_n "checking if \"el_rfunc_t *callback;\" compiles using histedit.h... " >&6; }
+	fi
+	saved_cppflags="${CPPFLAGS}"
+	if test "x${LIBEDIT_IS_UNICODE_DIR}" != "x"; then
+	    LIBEDIT_IS_UNICODE_INCLUDE="-I${LIBEDIT_IS_UNICODE_DIR}/include"
+	fi
+	CPPFLAGS="${CPPFLAGS} ${LIBEDIT_IS_UNICODE_INCLUDE}"
 
-if test "x${PBX_ICONV}" != "x1" -a "${USE_ICONV}" != "no"; then
-   pbxlibdir=""
-   # if --with-ICONV=DIR has been specified, use it.
-   if test "x${ICONV_DIR}" != "x"; then
-      if test -d ${ICONV_DIR}/lib; then
-         pbxlibdir="-L${ICONV_DIR}/lib"
-      else
-         pbxlibdir="-L${ICONV_DIR}"
-      fi
-   fi
-   pbxfuncname="iconv_open"
-   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
-      AST_ICONV_FOUND=yes
-   else
-      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
-      CFLAGS="${CFLAGS} "
-      as_ac_Lib=`$as_echo "ac_cv_lib_iconv_${pbxfuncname}" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -liconv" >&5
-$as_echo_n "checking for ${pbxfuncname} in -liconv... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ #include <histedit.h>
+int
+main ()
+{
+ el_rfunc_t *callback;;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		PBX_LIBEDIT_IS_UNICODE=1
+
+$as_echo "#define HAVE_LIBEDIT_IS_UNICODE 1" >>confdefs.h
+
+
+
+else
+         { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+	CPPFLAGS="${saved_cppflags}"
+    fi
+
+   fi
+fi
+
+
+if test "x${PBX_ICONV}" != "x1" -a "${USE_ICONV}" != "no"; then
+   pbxlibdir=""
+   # if --with-ICONV=DIR has been specified, use it.
+   if test "x${ICONV_DIR}" != "x"; then
+      if test -d ${ICONV_DIR}/lib; then
+         pbxlibdir="-L${ICONV_DIR}/lib"
+      else
+         pbxlibdir="-L${ICONV_DIR}"
+      fi
+   fi
+   pbxfuncname="iconv_open"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_ICONV_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_iconv_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -liconv" >&5
+$as_echo_n "checking for ${pbxfuncname} in -liconv... " >&6; }
 if eval \${$as_ac_Lib+:} false; then :
   $as_echo_n "(cached) " >&6
 else
@@ -24215,245 +25359,7 @@ $as_echo "$as_me: *** including --withou
 fi
 
 if test "$USE_PJPROJECT" != "no" ; then
-   if test "$PJPROJECT_BUNDLED" = "yes" ; then
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for embedded pjproject (may have to download)" >&5
-$as_echo_n "checking for embedded pjproject (may have to download)... " >&6; }
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: configuring" >&5
-$as_echo "configuring" >&6; }
-	make --quiet --no-print-directory -C $PJPROJECT_DIR configure
-	if test $? -ne 0 ; then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
-$as_echo "failed" >&6; }
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: Unable to configure $PJPROJECT_DIR" >&5
-$as_echo "$as_me: Unable to configure $PJPROJECT_DIR" >&6;}
-		as_fn_error $? "Run \"make -C $PJPROJECT_DIR NOISY_BUILD=yes configure\" to see error details." "$LINENO" 5
-	fi
-
-	PJPROJECT_INCLUDE=$(make --quiet --no-print-directory -C $PJPROJECT_DIR echo_cflags)
-	PJPROJECT_CFLAGS="$PJPROJECT_INCLUDE"
-	PBX_PJPROJECT=1
-	PJPROJECT_BUNDLED=yes
-
-$as_echo "#define HAVE_PJPROJECT 1" >>confdefs.h
-
-
-$as_echo "#define HAVE_PJPROJECT_BUNDLED 1" >>confdefs.h
-
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for embedded pjproject" >&5
-$as_echo_n "checking for embedded pjproject... " >&6; }
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-
-	PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_INCLUDE="$PJPROJECT_INCLUDE"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pjsip_dlg_create_uas_and_inc_lock declared in pjsip.h" >&5
-$as_echo_n "checking for pjsip_dlg_create_uas_and_inc_lock declared in pjsip.h... " >&6; }
-
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <pjsip.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "pjsip_dlg_create_uas_and_inc_lock" >/dev/null 2>&1; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJSIP_DLG_CREATE_UAS_AND_INC_LOCK=1
-
-$as_echo "#define HAVE_PJSIP_DLG_CREATE_UAS_AND_INC_LOCK 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f conftest*
-
-
-	CPPGLAGS="$saved_cpp"
-	PJSIP_DLG_CREATE_UAS_AND_INC_LOCK_INCLUDE="$PJPROJECT_INCLUDE"
-
-
-	PJ_TRANSACTION_GRP_LOCK_INCLUDE="$PJPROJECT_INCLUDE"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pjsip_tsx_create_uac2 declared in pjsip.h" >&5
-$as_echo_n "checking for pjsip_tsx_create_uac2 declared in pjsip.h... " >&6; }
-
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <pjsip.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "pjsip_tsx_create_uac2" >/dev/null 2>&1; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJ_TRANSACTION_GRP_LOCK=1
-
-$as_echo "#define HAVE_PJ_TRANSACTION_GRP_LOCK 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f conftest*
-
-
-	CPPGLAGS="$saved_cpp"
-	PJ_TRANSACTION_GRP_LOCK_INCLUDE="$PJPROJECT_INCLUDE"
-
-
-	PJSIP_REPLACE_MEDIA_STREAM_INCLUDE="$PJPROJECT_INCLUDE"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE declared in pjmedia.h" >&5
-$as_echo_n "checking for PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE declared in pjmedia.h... " >&6; }
-
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <pjmedia.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE" >/dev/null 2>&1; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJSIP_REPLACE_MEDIA_STREAM=1
-
-$as_echo "#define HAVE_PJSIP_REPLACE_MEDIA_STREAM 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f conftest*
-
-
-	CPPGLAGS="$saved_cpp"
-	PJSIP_REPLACE_MEDIA_STREAM_INCLUDE="$PJPROJECT_INCLUDE"
-
-
-	PJSIP_GET_DEST_INFO_INCLUDE="$PJPROJECT_INCLUDE"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pjsip_get_dest_info declared in pjsip.h" >&5
-$as_echo_n "checking for pjsip_get_dest_info declared in pjsip.h... " >&6; }
-
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <pjsip.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "pjsip_get_dest_info" >/dev/null 2>&1; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJSIP_GET_DEST_INFO=1
-
-$as_echo "#define HAVE_PJSIP_GET_DEST_INFO 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f conftest*
-
-
-	CPPGLAGS="$saved_cpp"
-	PJSIP_GET_DEST_INFO_INCLUDE="$PJPROJECT_INCLUDE"
-
-
-	PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE="$PJPROJECT_INCLUDE"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pj_ssl_cert_load_from_files2 declared in pjlib.h" >&5
-$as_echo_n "checking for pj_ssl_cert_load_from_files2 declared in pjlib.h... " >&6; }
-
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <pjlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "pj_ssl_cert_load_from_files2" >/dev/null 2>&1; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJ_SSL_CERT_LOAD_FROM_FILES2=1
-
-$as_echo "#define HAVE_PJ_SSL_CERT_LOAD_FROM_FILES2 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f conftest*
-
-
-	CPPGLAGS="$saved_cpp"
-	PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE="$PJPROJECT_INCLUDE"
-
-
-	PJSIP_EXTERNAL_RESOLVER_INCLUDE="$PJPROJECT_INCLUDE"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pjsip_endpt_set_ext_resolver declared in pjsip.h" >&5
-$as_echo_n "checking for pjsip_endpt_set_ext_resolver declared in pjsip.h... " >&6; }
-
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <pjsip.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "pjsip_endpt_set_ext_resolver" >/dev/null 2>&1; then :
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJSIP_EXTERNAL_RESOLVER=1
-
-$as_echo "#define HAVE_PJSIP_EXTERNAL_RESOLVER 1" >>confdefs.h
-
-
-else
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f conftest*
-
-
-	CPPGLAGS="$saved_cpp"
-	PJSIP_EXTERNAL_RESOLVER_INCLUDE="$PJPROJECT_INCLUDE"
-
-
-$as_echo "#define HAVE_PJSIP_TLS_TRANSPORT_PROTO 1" >>confdefs.h
-
-
-   else
+   if test "$PJPROJECT_BUNDLED" = "no" ; then
 
    if test "x${PBX_PJPROJECT}" != "x1" -a "${USE_PJPROJECT}" != "no"; then
 
@@ -24919,7 +25825,7 @@ if test "x${PBX_PJ_SSL_CERT_LOAD_FROM_FI
          pbxlibdir="-L${PJ_SSL_CERT_LOAD_FROM_FILES2_DIR}"
       fi
    fi
-   pbxfuncname="pjsip/include/pjsip/sip_util.h"
+   pbxfuncname="pj_ssl_cert_load_from_files2"
    if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
       AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND=yes
    else
@@ -24964,47 +25870,620 @@ eval ac_res=\$$as_ac_Lib
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-  AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND=yes
+  AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND=yes
+else
+  AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND}" = "yes"; then
+      PJ_SSL_CERT_LOAD_FROM_FILES2_LIB="${pbxlibdir} -lpj $PJPROJECT_LIB"
+      # if --with-PJ_SSL_CERT_LOAD_FROM_FILES2=DIR has been specified, use it.
+      if test "x${PJ_SSL_CERT_LOAD_FROM_FILES2_DIR}" != "x"; then
+         PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE="-I${PJ_SSL_CERT_LOAD_FROM_FILES2_DIR}/include"
+      fi
+      PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE="${PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE} $PJPROJECT_CFLAGS"
+      if test "xpjlib.h" = "x" ; then	# no header, assume found
+         PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "pjlib.h" "ac_cv_header_pjlib_h" "$ac_includes_default"
+if test "x$ac_cv_header_pjlib_h" = xyes; then :
+  PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND=1
+else
+  PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND}" = "x0" ; then
+         PJ_SSL_CERT_LOAD_FROM_FILES2_LIB=""
+         PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            PJ_SSL_CERT_LOAD_FROM_FILES2_LIB=""
+         fi
+         PBX_PJ_SSL_CERT_LOAD_FROM_FILES2=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_PJ_SSL_CERT_LOAD_FROM_FILES2 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+if test "x${PBX_PJSIP_EXTERNAL_RESOLVER}" != "x1" -a "${USE_PJSIP_EXTERNAL_RESOLVER}" != "no"; then
+   pbxlibdir=""
+   # if --with-PJSIP_EXTERNAL_RESOLVER=DIR has been specified, use it.
+   if test "x${PJSIP_EXTERNAL_RESOLVER_DIR}" != "x"; then
+      if test -d ${PJSIP_EXTERNAL_RESOLVER_DIR}/lib; then
+         pbxlibdir="-L${PJSIP_EXTERNAL_RESOLVER_DIR}/lib"
+      else
+         pbxlibdir="-L${PJSIP_EXTERNAL_RESOLVER_DIR}"
+      fi
+   fi
+   pbxfuncname="pjsip_endpt_set_ext_resolver"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_PJSIP_EXTERNAL_RESOLVER_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} $PJPROJECT_CFLAGS"
+      as_ac_Lib=`$as_echo "ac_cv_lib_pjsip_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lpjsip" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lpjsip... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_PJSIP_EXTERNAL_RESOLVER_FOUND=yes
+else
+  AST_PJSIP_EXTERNAL_RESOLVER_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_PJSIP_EXTERNAL_RESOLVER_FOUND}" = "yes"; then
+      PJSIP_EXTERNAL_RESOLVER_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIBS"
+      # if --with-PJSIP_EXTERNAL_RESOLVER=DIR has been specified, use it.
+      if test "x${PJSIP_EXTERNAL_RESOLVER_DIR}" != "x"; then
+         PJSIP_EXTERNAL_RESOLVER_INCLUDE="-I${PJSIP_EXTERNAL_RESOLVER_DIR}/include"
+      fi
+      PJSIP_EXTERNAL_RESOLVER_INCLUDE="${PJSIP_EXTERNAL_RESOLVER_INCLUDE} $PJPROJECT_CFLAGS"
+      if test "xpjsip.h" = "x" ; then	# no header, assume found
+         PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${PJSIP_EXTERNAL_RESOLVER_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "pjsip.h" "ac_cv_header_pjsip_h" "$ac_includes_default"
+if test "x$ac_cv_header_pjsip_h" = xyes; then :
+  PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND=1
+else
+  PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND}" = "x0" ; then
+         PJSIP_EXTERNAL_RESOLVER_LIB=""
+         PJSIP_EXTERNAL_RESOLVER_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            PJSIP_EXTERNAL_RESOLVER_LIB=""
+         fi
+         PBX_PJSIP_EXTERNAL_RESOLVER=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_PJSIP_EXTERNAL_RESOLVER 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+      saved_cppflags="${CPPFLAGS}"
+      saved_libs="${LIBS}"
+      CPPFLAGS="${CPPFLAGS} ${PJPROJECT_CFLAGS}"
+      LIBS="${LIBS} ${PJPROJECT_LIB}"
+
+    if test "x${PBX_PJSIP_TLS_TRANSPORT_PROTO}" != "x1" -a "${USE_PJSIP_TLS_TRANSPORT_PROTO}" != "no"; then
+        if test "x" != "x"; then
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for " >&5
+$as_echo_n "checking for ... " >&6; }
+	else
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking if \"struct pjsip_tls_setting setting; int proto; proto = setting.proto;\" compiles using pjsip.h" >&5
+$as_echo_n "checking if \"struct pjsip_tls_setting setting; int proto; proto = setting.proto;\" compiles using pjsip.h... " >&6; }
+	fi
+	saved_cppflags="${CPPFLAGS}"
+	if test "x${PJSIP_TLS_TRANSPORT_PROTO_DIR}" != "x"; then
+	    PJSIP_TLS_TRANSPORT_PROTO_INCLUDE="-I${PJSIP_TLS_TRANSPORT_PROTO_DIR}/include"
+	fi
+	CPPFLAGS="${CPPFLAGS} ${PJSIP_TLS_TRANSPORT_PROTO_INCLUDE}"
+
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ #include <pjsip.h>
+int
+main ()
+{
+ struct pjsip_tls_setting setting; int proto; proto = setting.proto;;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+		PBX_PJSIP_TLS_TRANSPORT_PROTO=1
+
+$as_echo "#define HAVE_PJSIP_TLS_TRANSPORT_PROTO 1" >>confdefs.h
+
+
+
+else
+         { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+	CPPFLAGS="${saved_cppflags}"
+    fi
+
+      LIBS="${saved_libs}"
+      CPPFLAGS="${saved_cppflags}"
+
+
+if test "x${PBX_PJSIP_EVSUB_GRP_LOCK}" != "x1" -a "${USE_PJSIP_EVSUB_GRP_LOCK}" != "no"; then
+   pbxlibdir=""
+   # if --with-PJSIP_EVSUB_GRP_LOCK=DIR has been specified, use it.
+   if test "x${PJSIP_EVSUB_GRP_LOCK_DIR}" != "x"; then
+      if test -d ${PJSIP_EVSUB_GRP_LOCK_DIR}/lib; then
+         pbxlibdir="-L${PJSIP_EVSUB_GRP_LOCK_DIR}/lib"
+      else
+         pbxlibdir="-L${PJSIP_EVSUB_GRP_LOCK_DIR}"
+      fi
+   fi
+   pbxfuncname="pjsip_evsub_add_ref"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_PJSIP_EVSUB_GRP_LOCK_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} $PJPROJECT_CFLAGS"
+      as_ac_Lib=`$as_echo "ac_cv_lib_pjsip_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lpjsip" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lpjsip... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIB $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_PJSIP_EVSUB_GRP_LOCK_FOUND=yes
+else
+  AST_PJSIP_EVSUB_GRP_LOCK_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_PJSIP_EVSUB_GRP_LOCK_FOUND}" = "yes"; then
+      PJSIP_EVSUB_GRP_LOCK_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIB"
+      # if --with-PJSIP_EVSUB_GRP_LOCK=DIR has been specified, use it.
+      if test "x${PJSIP_EVSUB_GRP_LOCK_DIR}" != "x"; then
+         PJSIP_EVSUB_GRP_LOCK_INCLUDE="-I${PJSIP_EVSUB_GRP_LOCK_DIR}/include"
+      fi
+      PJSIP_EVSUB_GRP_LOCK_INCLUDE="${PJSIP_EVSUB_GRP_LOCK_INCLUDE} $PJPROJECT_CFLAGS"
+      if test "xpjsip.h" = "x" ; then	# no header, assume found
+         PJSIP_EVSUB_GRP_LOCK_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${PJSIP_EVSUB_GRP_LOCK_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "pjsip.h" "ac_cv_header_pjsip_h" "$ac_includes_default"
+if test "x$ac_cv_header_pjsip_h" = xyes; then :
+  PJSIP_EVSUB_GRP_LOCK_HEADER_FOUND=1
+else
+  PJSIP_EVSUB_GRP_LOCK_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${PJSIP_EVSUB_GRP_LOCK_HEADER_FOUND}" = "x0" ; then
+         PJSIP_EVSUB_GRP_LOCK_LIB=""
+         PJSIP_EVSUB_GRP_LOCK_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            PJSIP_EVSUB_GRP_LOCK_LIB=""
+         fi
+         PBX_PJSIP_EVSUB_GRP_LOCK=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_PJSIP_EVSUB_GRP_LOCK 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+if test "x${PBX_PJSIP_INV_SESSION_REF}" != "x1" -a "${USE_PJSIP_INV_SESSION_REF}" != "no"; then
+   pbxlibdir=""
+   # if --with-PJSIP_INV_SESSION_REF=DIR has been specified, use it.
+   if test "x${PJSIP_INV_SESSION_REF_DIR}" != "x"; then
+      if test -d ${PJSIP_INV_SESSION_REF_DIR}/lib; then
+         pbxlibdir="-L${PJSIP_INV_SESSION_REF_DIR}/lib"
+      else
+         pbxlibdir="-L${PJSIP_INV_SESSION_REF_DIR}"
+      fi
+   fi
+   pbxfuncname="pjsip_inv_add_ref"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_PJSIP_INV_SESSION_REF_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} $PJPROJECT_CFLAGS"
+      as_ac_Lib=`$as_echo "ac_cv_lib_pjsip_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lpjsip" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lpjsip... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIB $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_PJSIP_INV_SESSION_REF_FOUND=yes
+else
+  AST_PJSIP_INV_SESSION_REF_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_PJSIP_INV_SESSION_REF_FOUND}" = "yes"; then
+      PJSIP_INV_SESSION_REF_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIB"
+      # if --with-PJSIP_INV_SESSION_REF=DIR has been specified, use it.
+      if test "x${PJSIP_INV_SESSION_REF_DIR}" != "x"; then
+         PJSIP_INV_SESSION_REF_INCLUDE="-I${PJSIP_INV_SESSION_REF_DIR}/include"
+      fi
+      PJSIP_INV_SESSION_REF_INCLUDE="${PJSIP_INV_SESSION_REF_INCLUDE} $PJPROJECT_CFLAGS"
+      if test "xpjsip.h" = "x" ; then	# no header, assume found
+         PJSIP_INV_SESSION_REF_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${PJSIP_INV_SESSION_REF_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "pjsip.h" "ac_cv_header_pjsip_h" "$ac_includes_default"
+if test "x$ac_cv_header_pjsip_h" = xyes; then :
+  PJSIP_INV_SESSION_REF_HEADER_FOUND=1
+else
+  PJSIP_INV_SESSION_REF_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${PJSIP_INV_SESSION_REF_HEADER_FOUND}" = "x0" ; then
+         PJSIP_INV_SESSION_REF_LIB=""
+         PJSIP_INV_SESSION_REF_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            PJSIP_INV_SESSION_REF_LIB=""
+         fi
+         PBX_PJSIP_INV_SESSION_REF=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_PJSIP_INV_SESSION_REF 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+if test "x${PBX_PJSIP_AUTH_CLT_DEINIT}" != "x1" -a "${USE_PJSIP_AUTH_CLT_DEINIT}" != "no"; then
+   pbxlibdir=""
+   # if --with-PJSIP_AUTH_CLT_DEINIT=DIR has been specified, use it.
+   if test "x${PJSIP_AUTH_CLT_DEINIT_DIR}" != "x"; then
+      if test -d ${PJSIP_AUTH_CLT_DEINIT_DIR}/lib; then
+         pbxlibdir="-L${PJSIP_AUTH_CLT_DEINIT_DIR}/lib"
+      else
+         pbxlibdir="-L${PJSIP_AUTH_CLT_DEINIT_DIR}"
+      fi
+   fi
+   pbxfuncname="pjsip_auth_clt_deinit"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_PJSIP_AUTH_CLT_DEINIT_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} $PJPROJECT_CFLAGS"
+      as_ac_Lib=`$as_echo "ac_cv_lib_pjsip_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lpjsip" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lpjsip... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIB $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_PJSIP_AUTH_CLT_DEINIT_FOUND=yes
+else
+  AST_PJSIP_AUTH_CLT_DEINIT_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_PJSIP_AUTH_CLT_DEINIT_FOUND}" = "yes"; then
+      PJSIP_AUTH_CLT_DEINIT_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIB"
+      # if --with-PJSIP_AUTH_CLT_DEINIT=DIR has been specified, use it.
+      if test "x${PJSIP_AUTH_CLT_DEINIT_DIR}" != "x"; then
+         PJSIP_AUTH_CLT_DEINIT_INCLUDE="-I${PJSIP_AUTH_CLT_DEINIT_DIR}/include"
+      fi
+      PJSIP_AUTH_CLT_DEINIT_INCLUDE="${PJSIP_AUTH_CLT_DEINIT_INCLUDE} $PJPROJECT_CFLAGS"
+      if test "xpjsip.h" = "x" ; then	# no header, assume found
+         PJSIP_AUTH_CLT_DEINIT_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${PJSIP_AUTH_CLT_DEINIT_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "pjsip.h" "ac_cv_header_pjsip_h" "$ac_includes_default"
+if test "x$ac_cv_header_pjsip_h" = xyes; then :
+  PJSIP_AUTH_CLT_DEINIT_HEADER_FOUND=1
+else
+  PJSIP_AUTH_CLT_DEINIT_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${PJSIP_AUTH_CLT_DEINIT_HEADER_FOUND}" = "x0" ; then
+         PJSIP_AUTH_CLT_DEINIT_LIB=""
+         PJSIP_AUTH_CLT_DEINIT_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            PJSIP_AUTH_CLT_DEINIT_LIB=""
+         fi
+         PBX_PJSIP_AUTH_CLT_DEINIT=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_PJSIP_AUTH_CLT_DEINIT 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+if test "x${PBX_PJSIP_EVSUB_SET_UAS_TIMEOUT}" != "x1" -a "${USE_PJSIP_EVSUB_SET_UAS_TIMEOUT}" != "no"; then
+   pbxlibdir=""
+   # if --with-PJSIP_EVSUB_SET_UAS_TIMEOUT=DIR has been specified, use it.
+   if test "x${PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR}" != "x"; then
+      if test -d ${PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR}/lib; then
+         pbxlibdir="-L${PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR}/lib"
+      else
+         pbxlibdir="-L${PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR}"
+      fi
+   fi
+   pbxfuncname="pjsip_evsub_set_uas_timeout"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_PJSIP_EVSUB_SET_UAS_TIMEOUT_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} $PJPROJECT_CFLAGS"
+      as_ac_Lib=`$as_echo "ac_cv_lib_pjsip_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lpjsip" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lpjsip... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIB $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_PJSIP_EVSUB_SET_UAS_TIMEOUT_FOUND=yes
 else
-  AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND=no
+  AST_PJSIP_EVSUB_SET_UAS_TIMEOUT_FOUND=no
 fi
 
       CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
    fi
 
    # now check for the header.
-   if test "${AST_PJ_SSL_CERT_LOAD_FROM_FILES2_FOUND}" = "yes"; then
-      PJ_SSL_CERT_LOAD_FROM_FILES2_LIB="${pbxlibdir} -lpj $PJPROJECT_LIB"
-      # if --with-PJ_SSL_CERT_LOAD_FROM_FILES2=DIR has been specified, use it.
-      if test "x${PJ_SSL_CERT_LOAD_FROM_FILES2_DIR}" != "x"; then
-         PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE="-I${PJ_SSL_CERT_LOAD_FROM_FILES2_DIR}/include"
+   if test "${AST_PJSIP_EVSUB_SET_UAS_TIMEOUT_FOUND}" = "yes"; then
+      PJSIP_EVSUB_SET_UAS_TIMEOUT_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIB"
+      # if --with-PJSIP_EVSUB_SET_UAS_TIMEOUT=DIR has been specified, use it.
+      if test "x${PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR}" != "x"; then
+         PJSIP_EVSUB_SET_UAS_TIMEOUT_INCLUDE="-I${PJSIP_EVSUB_SET_UAS_TIMEOUT_DIR}/include"
       fi
-      PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE="${PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE} $PJPROJECT_CFLAGS"
-      if test "xpjlib.h" = "x" ; then	# no header, assume found
-         PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND="1"
+      PJSIP_EVSUB_SET_UAS_TIMEOUT_INCLUDE="${PJSIP_EVSUB_SET_UAS_TIMEOUT_INCLUDE} $PJPROJECT_CFLAGS"
+      if test "xpjsip.h" = "x" ; then	# no header, assume found
+         PJSIP_EVSUB_SET_UAS_TIMEOUT_HEADER_FOUND="1"
       else				# check for the header
          ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
-         CPPFLAGS="${CPPFLAGS} ${PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE}"
-         ac_fn_c_check_header_mongrel "$LINENO" "pjlib.h" "ac_cv_header_pjlib_h" "$ac_includes_default"
-if test "x$ac_cv_header_pjlib_h" = xyes; then :
-  PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND=1
+         CPPFLAGS="${CPPFLAGS} ${PJSIP_EVSUB_SET_UAS_TIMEOUT_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "pjsip.h" "ac_cv_header_pjsip_h" "$ac_includes_default"
+if test "x$ac_cv_header_pjsip_h" = xyes; then :
+  PJSIP_EVSUB_SET_UAS_TIMEOUT_HEADER_FOUND=1
 else
-  PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND=0
+  PJSIP_EVSUB_SET_UAS_TIMEOUT_HEADER_FOUND=0
 fi
 
 
          CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
       fi
-      if test "x${PJ_SSL_CERT_LOAD_FROM_FILES2_HEADER_FOUND}" = "x0" ; then
-         PJ_SSL_CERT_LOAD_FROM_FILES2_LIB=""
-         PJ_SSL_CERT_LOAD_FROM_FILES2_INCLUDE=""
+      if test "x${PJSIP_EVSUB_SET_UAS_TIMEOUT_HEADER_FOUND}" = "x0" ; then
+         PJSIP_EVSUB_SET_UAS_TIMEOUT_LIB=""
+         PJSIP_EVSUB_SET_UAS_TIMEOUT_INCLUDE=""
       else
          if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
-            PJ_SSL_CERT_LOAD_FROM_FILES2_LIB=""
+            PJSIP_EVSUB_SET_UAS_TIMEOUT_LIB=""
          fi
-         PBX_PJ_SSL_CERT_LOAD_FROM_FILES2=1
+         PBX_PJSIP_EVSUB_SET_UAS_TIMEOUT=1
          cat >>confdefs.h <<_ACEOF
-#define HAVE_PJ_SSL_CERT_LOAD_FROM_FILES2 1
+#define HAVE_PJSIP_EVSUB_SET_UAS_TIMEOUT 1
 _ACEOF
 
       fi
@@ -25013,19 +26492,19 @@ fi
 
 
 
-if test "x${PBX_PJSIP_EXTERNAL_RESOLVER}" != "x1" -a "${USE_PJSIP_EXTERNAL_RESOLVER}" != "no"; then
+if test "x${PBX_PJSIP_TSX_LAYER_FIND_TSX2}" != "x1" -a "${USE_PJSIP_TSX_LAYER_FIND_TSX2}" != "no"; then
    pbxlibdir=""
-   # if --with-PJSIP_EXTERNAL_RESOLVER=DIR has been specified, use it.
-   if test "x${PJSIP_EXTERNAL_RESOLVER_DIR}" != "x"; then
-      if test -d ${PJSIP_EXTERNAL_RESOLVER_DIR}/lib; then
-         pbxlibdir="-L${PJSIP_EXTERNAL_RESOLVER_DIR}/lib"
+   # if --with-PJSIP_TSX_LAYER_FIND_TSX2=DIR has been specified, use it.
+   if test "x${PJSIP_TSX_LAYER_FIND_TSX2_DIR}" != "x"; then
+      if test -d ${PJSIP_TSX_LAYER_FIND_TSX2_DIR}/lib; then
+         pbxlibdir="-L${PJSIP_TSX_LAYER_FIND_TSX2_DIR}/lib"
       else
-         pbxlibdir="-L${PJSIP_EXTERNAL_RESOLVER_DIR}"
+         pbxlibdir="-L${PJSIP_TSX_LAYER_FIND_TSX2_DIR}"
       fi
    fi
-   pbxfuncname="pjsip_endpt_set_ext_resolver"
+   pbxfuncname="pjsip_tsx_layer_find_tsx2"
    if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
-      AST_PJSIP_EXTERNAL_RESOLVER_FOUND=yes
+      AST_PJSIP_TSX_LAYER_FIND_TSX2_FOUND=yes
    else
       ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
       CFLAGS="${CFLAGS} $PJPROJECT_CFLAGS"
@@ -25036,7 +26515,7 @@ if eval \${$as_ac_Lib+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIBS $LIBS"
+LIBS="-lpjsip ${pbxlibdir} $PJPROJECT_LIB $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -25068,47 +26547,47 @@ eval ac_res=\$$as_ac_Lib
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-  AST_PJSIP_EXTERNAL_RESOLVER_FOUND=yes
+  AST_PJSIP_TSX_LAYER_FIND_TSX2_FOUND=yes
 else
-  AST_PJSIP_EXTERNAL_RESOLVER_FOUND=no
+  AST_PJSIP_TSX_LAYER_FIND_TSX2_FOUND=no
 fi
 
       CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
    fi
 
    # now check for the header.
-   if test "${AST_PJSIP_EXTERNAL_RESOLVER_FOUND}" = "yes"; then
-      PJSIP_EXTERNAL_RESOLVER_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIBS"
-      # if --with-PJSIP_EXTERNAL_RESOLVER=DIR has been specified, use it.
-      if test "x${PJSIP_EXTERNAL_RESOLVER_DIR}" != "x"; then
-         PJSIP_EXTERNAL_RESOLVER_INCLUDE="-I${PJSIP_EXTERNAL_RESOLVER_DIR}/include"
+   if test "${AST_PJSIP_TSX_LAYER_FIND_TSX2_FOUND}" = "yes"; then
+      PJSIP_TSX_LAYER_FIND_TSX2_LIB="${pbxlibdir} -lpjsip $PJPROJECT_LIB"
+      # if --with-PJSIP_TSX_LAYER_FIND_TSX2=DIR has been specified, use it.
+      if test "x${PJSIP_TSX_LAYER_FIND_TSX2_DIR}" != "x"; then
+         PJSIP_TSX_LAYER_FIND_TSX2_INCLUDE="-I${PJSIP_TSX_LAYER_FIND_TSX2_DIR}/include"
       fi
-      PJSIP_EXTERNAL_RESOLVER_INCLUDE="${PJSIP_EXTERNAL_RESOLVER_INCLUDE} $PJPROJECT_CFLAGS"
+      PJSIP_TSX_LAYER_FIND_TSX2_INCLUDE="${PJSIP_TSX_LAYER_FIND_TSX2_INCLUDE} $PJPROJECT_CFLAGS"
       if test "xpjsip.h" = "x" ; then	# no header, assume found
-         PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND="1"
+         PJSIP_TSX_LAYER_FIND_TSX2_HEADER_FOUND="1"
       else				# check for the header
          ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
-         CPPFLAGS="${CPPFLAGS} ${PJSIP_EXTERNAL_RESOLVER_INCLUDE}"
+         CPPFLAGS="${CPPFLAGS} ${PJSIP_TSX_LAYER_FIND_TSX2_INCLUDE}"
          ac_fn_c_check_header_mongrel "$LINENO" "pjsip.h" "ac_cv_header_pjsip_h" "$ac_includes_default"
 if test "x$ac_cv_header_pjsip_h" = xyes; then :
-  PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND=1
+  PJSIP_TSX_LAYER_FIND_TSX2_HEADER_FOUND=1
 else
-  PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND=0
+  PJSIP_TSX_LAYER_FIND_TSX2_HEADER_FOUND=0
 fi
 
 
          CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
       fi
-      if test "x${PJSIP_EXTERNAL_RESOLVER_HEADER_FOUND}" = "x0" ; then
-         PJSIP_EXTERNAL_RESOLVER_LIB=""
-         PJSIP_EXTERNAL_RESOLVER_INCLUDE=""
+      if test "x${PJSIP_TSX_LAYER_FIND_TSX2_HEADER_FOUND}" = "x0" ; then
+         PJSIP_TSX_LAYER_FIND_TSX2_LIB=""
+         PJSIP_TSX_LAYER_FIND_TSX2_INCLUDE=""
       else
          if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
-            PJSIP_EXTERNAL_RESOLVER_LIB=""
+            PJSIP_TSX_LAYER_FIND_TSX2_LIB=""
          fi
-         PBX_PJSIP_EXTERNAL_RESOLVER=1
+         PBX_PJSIP_TSX_LAYER_FIND_TSX2=1
          cat >>confdefs.h <<_ACEOF
-#define HAVE_PJSIP_EXTERNAL_RESOLVER 1
+#define HAVE_PJSIP_TSX_LAYER_FIND_TSX2 1
 _ACEOF
 
       fi
@@ -25116,60 +26595,99 @@ _ACEOF
 fi
 
 
+   fi
+fi
 
-      saved_cppflags="${CPPFLAGS}"
-      saved_libs="${LIBS}"
-      CPPFLAGS="${CPPFLAGS} ${PJPROJECT_CFLAGS}"
-      LIBS="${LIBS} ${PJPROJECT_LIB}"
 
-    if test "x${PBX_PJSIP_TLS_TRANSPORT_PROTO}" != "x1" -a "${USE_PJSIP_TLS_TRANSPORT_PROTO}" != "no"; then
-        if test "x" != "x"; then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for " >&5
-$as_echo_n "checking for ... " >&6; }
-	else
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking if \"struct pjsip_tls_setting setting; int proto; proto = setting.proto;\" compiles using pjsip.h" >&5
-$as_echo_n "checking if \"struct pjsip_tls_setting setting; int proto; proto = setting.proto;\" compiles using pjsip.h... " >&6; }
-	fi
-	saved_cppflags="${CPPFLAGS}"
-	if test "x${PJSIP_TLS_TRANSPORT_PROTO_DIR}" != "x"; then
-	    PJSIP_TLS_TRANSPORT_PROTO_INCLUDE="-I${PJSIP_TLS_TRANSPORT_PROTO_DIR}/include"
-	fi
-	CPPFLAGS="${CPPFLAGS} ${PJSIP_TLS_TRANSPORT_PROTO_INCLUDE}"
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
- #include <pjsip.h>
-int
-main ()
-{
- struct pjsip_tls_setting setting; int proto; proto = setting.proto;;
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-		PBX_PJSIP_TLS_TRANSPORT_PROTO=1
+   if test "x${PBX_PYTHONDEV}" != "x1" -a "${USE_PYTHONDEV}" != "no"; then
 
-$as_echo "#define HAVE_PJSIP_TLS_TRANSPORT_PROTO 1" >>confdefs.h
+pkg_failed=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for PYTHONDEV" >&5
+$as_echo_n "checking for PYTHONDEV... " >&6; }
+
+if test -n "$PYTHONDEV_CFLAGS"; then
+    pkg_cv_PYTHONDEV_CFLAGS="$PYTHONDEV_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"python\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "python") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_PYTHONDEV_CFLAGS=`$PKG_CONFIG --cflags "python" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+if test -n "$PYTHONDEV_LIBS"; then
+    pkg_cv_PYTHONDEV_LIBS="$PYTHONDEV_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"python\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "python") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_PYTHONDEV_LIBS=`$PKG_CONFIG --libs "python" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
 
 
 
-else
-         { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+if test $pkg_failed = yes; then
+   	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	CPPFLAGS="${saved_cppflags}"
-    fi
+        if test $_pkg_short_errors_supported = yes; then
+	        PYTHONDEV_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "python" 2>&1`
+        else
+	        PYTHONDEV_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "python" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$PYTHONDEV_PKG_ERRORS" >&5
+
+
+            PBX_PYTHONDEV=0
+
+
+elif test $pkg_failed = untried; then
+     	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+            PBX_PYTHONDEV=0
+
+
+else
+	PYTHONDEV_CFLAGS=$pkg_cv_PYTHONDEV_CFLAGS
+	PYTHONDEV_LIBS=$pkg_cv_PYTHONDEV_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+            PBX_PYTHONDEV=1
+            PYTHONDEV_INCLUDE="$PYTHONDEV_CFLAGS"
+            PYTHONDEV_LIB="$PYTHONDEV_LIBS"
+
+$as_echo "#define HAVE_PYTHONDEV 1" >>confdefs.h
+
 
-      LIBS="${saved_libs}"
-      CPPFLAGS="${saved_cppflags}"
-   fi
 fi
+   fi
+
 
 
 if test "x${PBX_POPT}" != "x1" -a "${USE_POPT}" != "no"; then
@@ -31040,53 +32558,6 @@ fi
 if test "$PBX_OPENSSL" = "1";
 then
 
-    if test "x${PBX_OPENSSL_ECDH_AUTO}" != "x1" -a "${USE_OPENSSL_ECDH_AUTO}" != "no"; then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for SSL_CTX_set_ecdh_auto declared in openssl/ssl.h" >&5
-$as_echo_n "checking for SSL_CTX_set_ecdh_auto declared in openssl/ssl.h... " >&6; }
-        saved_cppflags="${CPPFLAGS}"
-        if test "x${OPENSSL_ECDH_AUTO_DIR}" != "x"; then
-            OPENSSL_ECDH_AUTO_INCLUDE="-I${OPENSSL_ECDH_AUTO_DIR}/include"
-        fi
-        CPPFLAGS="${CPPFLAGS} ${OPENSSL_ECDH_AUTO_INCLUDE}"
-
-        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
- #include <openssl/ssl.h>
-int
-main ()
-{
-#if !defined(SSL_CTX_set_ecdh_auto)
-                                    (void) SSL_CTX_set_ecdh_auto;
-                                #endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-                PBX_OPENSSL_ECDH_AUTO=1
-
-$as_echo "#define HAVE_OPENSSL_ECDH_AUTO 1" >>confdefs.h
-
-
-
-else
-     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-        CPPFLAGS="${saved_cppflags}"
-    fi
-
-fi
-
-if test "$PBX_OPENSSL" = "1";
-then
-
     if test "x${PBX_SSL_OP_NO_TLSV1_1}" != "x1"; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SSL_OP_NO_TLSv1_1 in openssl/ssl.h" >&5
 $as_echo_n "checking for SSL_OP_NO_TLSv1_1 in openssl/ssl.h... " >&6; }
@@ -31197,6 +32668,308 @@ if test "x${PBX_SRTP}" != "x1" -a "${USE
    else
       ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
       CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_srtp2_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lsrtp2" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lsrtp2... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsrtp2 ${pbxlibdir}  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_SRTP_FOUND=yes
+else
+  AST_SRTP_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_SRTP_FOUND}" = "yes"; then
+      SRTP_LIB="${pbxlibdir} -lsrtp2 "
+      # if --with-SRTP=DIR has been specified, use it.
+      if test "x${SRTP_DIR}" != "x"; then
+         SRTP_INCLUDE="-I${SRTP_DIR}/include"
+      fi
+      SRTP_INCLUDE="${SRTP_INCLUDE} "
+      if test "xsrtp2/srtp.h" = "x" ; then	# no header, assume found
+         SRTP_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${SRTP_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "srtp2/srtp.h" "ac_cv_header_srtp2_srtp_h" "$ac_includes_default"
+if test "x$ac_cv_header_srtp2_srtp_h" = xyes; then :
+  SRTP_HEADER_FOUND=1
+else
+  SRTP_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${SRTP_HEADER_FOUND}" = "x0" ; then
+         SRTP_LIB=""
+         SRTP_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            SRTP_LIB=""
+         fi
+         PBX_SRTP=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_SRTP 1
+_ACEOF
+
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_SRTP_VERSION 2
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+if test "x${PBX_SRTP}" = "x1"; then
+   ast_ext_lib_check_shared_saved_libs="${LIBS}"
+   ast_ext_lib_check_shared_saved_ldflags="${LDFLAGS}"
+   ast_ext_lib_check_shared_saved_cflags="${CFLAGS}"
+   LIBS="${LIBS} ${SRTP_LIB} "
+   LDFLAGS="${LDFLAGS} -shared -fPIC"
+   CFLAGS="${CFLAGS} ${SRTP_INCLUDE} "
+   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the ability of -lsrtp2 to be linked in a shared object" >&5
+$as_echo_n "checking for the ability of -lsrtp2 to be linked in a shared object... " >&6; }
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+       #include <srtp2/srtp.h>
+int
+main ()
+{
+srtp_init();
+
+  ;
+  return 0;
+}
+
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+
+else
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
+$as_echo "$as_me: WARNING: ***" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** libsrtp2 could not be linked as a shared object." >&5
+$as_echo "$as_me: WARNING: *** libsrtp2 could not be linked as a shared object." >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** Try compiling libsrtp2 manually. Configure libsrtp2" >&5
+$as_echo "$as_me: WARNING: *** Try compiling libsrtp2 manually. Configure libsrtp2" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** with ./configure --prefix=/usr replacing /usr with" >&5
+$as_echo "$as_me: WARNING: *** with ./configure --prefix=/usr replacing /usr with" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** the prefix of your choice, and then make with" >&5
+$as_echo "$as_me: WARNING: *** the prefix of your choice, and then make with" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** 'make libsrtp2.so'" >&5
+$as_echo "$as_me: WARNING: *** 'make libsrtp2.so'" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
+$as_echo "$as_me: WARNING: ***" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** After re-installing libsrtp2, re-run the Asterisk" >&5
+$as_echo "$as_me: WARNING: *** After re-installing libsrtp2, re-run the Asterisk" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** configure script." >&5
+$as_echo "$as_me: WARNING: *** configure script." >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
+$as_echo "$as_me: WARNING: ***" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** If you do not need SRTP support re-run configure" >&5
+$as_echo "$as_me: WARNING: *** If you do not need SRTP support re-run configure" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** with the --without-srtp option." >&5
+$as_echo "$as_me: WARNING: *** with the --without-srtp option." >&2;}
+    exit 1
+
+
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+   CFLAGS="${ast_ext_lib_check_shared_saved_cflags}"
+   LDFLAGS="${ast_ext_lib_check_shared_saved_ldflags}"
+   LIBS="${ast_ext_lib_check_shared_saved_libs}"
+fi
+
+
+if test "x$PBX_SRTP" = x1;
+then
+
+if test "x${PBX_SRTP_SHUTDOWN}" != "x1" -a "${USE_SRTP_SHUTDOWN}" != "no"; then
+   pbxlibdir=""
+   # if --with-SRTP_SHUTDOWN=DIR has been specified, use it.
+   if test "x${SRTP_SHUTDOWN_DIR}" != "x"; then
+      if test -d ${SRTP_SHUTDOWN_DIR}/lib; then
+         pbxlibdir="-L${SRTP_SHUTDOWN_DIR}/lib"
+      else
+         pbxlibdir="-L${SRTP_SHUTDOWN_DIR}"
+      fi
+   fi
+   pbxfuncname="srtp_shutdown"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_SRTP_SHUTDOWN_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_srtp2_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lsrtp2" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lsrtp2... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsrtp2 ${pbxlibdir}  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_SRTP_SHUTDOWN_FOUND=yes
+else
+  AST_SRTP_SHUTDOWN_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_SRTP_SHUTDOWN_FOUND}" = "yes"; then
+      SRTP_SHUTDOWN_LIB="${pbxlibdir} -lsrtp2 "
+      # if --with-SRTP_SHUTDOWN=DIR has been specified, use it.
+      if test "x${SRTP_SHUTDOWN_DIR}" != "x"; then
+         SRTP_SHUTDOWN_INCLUDE="-I${SRTP_SHUTDOWN_DIR}/include"
+      fi
+      SRTP_SHUTDOWN_INCLUDE="${SRTP_SHUTDOWN_INCLUDE} "
+      if test "xsrtp2/srtp.h" = "x" ; then	# no header, assume found
+         SRTP_SHUTDOWN_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${SRTP_SHUTDOWN_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "srtp2/srtp.h" "ac_cv_header_srtp2_srtp_h" "$ac_includes_default"
+if test "x$ac_cv_header_srtp2_srtp_h" = xyes; then :
+  SRTP_SHUTDOWN_HEADER_FOUND=1
+else
+  SRTP_SHUTDOWN_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${SRTP_SHUTDOWN_HEADER_FOUND}" = "x0" ; then
+         SRTP_SHUTDOWN_LIB=""
+         SRTP_SHUTDOWN_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            SRTP_SHUTDOWN_LIB=""
+         fi
+         PBX_SRTP_SHUTDOWN=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_SRTP_SHUTDOWN 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+
+    # libsrtp2 removed support for PRNG, so we require OpenSSL
+    if test "x$PBX_OPENSSL" != x1;
+    then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
+$as_echo "$as_me: WARNING: ***" >&2;}
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** OpenSSL required when using libsrtp2, checking for libsrtp instead." >&5
+$as_echo "$as_me: WARNING: *** OpenSSL required when using libsrtp2, checking for libsrtp instead." >&2;}
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
+$as_echo "$as_me: WARNING: ***" >&2;}
+        PBX_SRTP=0
+    fi
+fi
+
+if test "x$PBX_SRTP" != x1;
+then
+
+if test "x${PBX_SRTP}" != "x1" -a "${USE_SRTP}" != "no"; then
+   pbxlibdir=""
+   # if --with-SRTP=DIR has been specified, use it.
+   if test "x${SRTP_DIR}" != "x"; then
+      if test -d ${SRTP_DIR}/lib; then
+         pbxlibdir="-L${SRTP_DIR}/lib"
+      else
+         pbxlibdir="-L${SRTP_DIR}"
+      fi
+   fi
+   pbxfuncname="srtp_init"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_SRTP_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
       as_ac_Lib=`$as_echo "ac_cv_lib_srtp_${pbxfuncname}" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lsrtp" >&5
 $as_echo_n "checking for ${pbxfuncname} in -lsrtp... " >&6; }
@@ -31279,26 +33052,29 @@ fi
 #define HAVE_SRTP 1
 _ACEOF
 
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_SRTP_VERSION 1
+_ACEOF
+
       fi
    fi
 fi
 
 
 
-if test "$PBX_SRTP" = "1";
-then
-    saved_libs="${LIBS}"
-    saved_ldflags="${LDFLAGS}"
-    saved_cflags="${CFLAGS}"
-    LIBS="${LIBS} ${SRTP_LIB}"
-    LDFLAGS="${LDFLAGS} -shared -fPIC"
-    CFLAGS="${CFLAGS} ${SRTP_INCLUDE}"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the ability of -lsrtp to be linked in a shared object" >&5
+if test "x${PBX_SRTP}" = "x1"; then
+   ast_ext_lib_check_shared_saved_libs="${LIBS}"
+   ast_ext_lib_check_shared_saved_ldflags="${LDFLAGS}"
+   ast_ext_lib_check_shared_saved_cflags="${CFLAGS}"
+   LIBS="${LIBS} ${SRTP_LIB} "
+   LDFLAGS="${LDFLAGS} -shared -fPIC"
+   CFLAGS="${CFLAGS} ${SRTP_INCLUDE} "
+   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the ability of -lsrtp to be linked in a shared object" >&5
 $as_echo_n "checking for the ability of -lsrtp to be linked in a shared object... " >&6; }
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-        #include <srtp/srtp.h>
+       #include <srtp/srtp.h>
 int
 main ()
 {
@@ -31310,12 +33086,16 @@ srtp_init();
 
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
+
+
 else
 
-        { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
+
         { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
 $as_echo "$as_me: WARNING: ***" >&2;}
         { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** libsrtp could not be linked as a shared object." >&5
@@ -31326,8 +33106,8 @@ $as_echo "$as_me: WARNING: *** Try compi
 $as_echo "$as_me: WARNING: *** with ./configure CFLAGS=-fPIC --prefix=/usr" >&2;}
         { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** replacing /usr with the prefix of your choice." >&5
 $as_echo "$as_me: WARNING: *** replacing /usr with the prefix of your choice." >&2;}
-        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** After re-installing libsrtp" >&5
-$as_echo "$as_me: WARNING: *** After re-installing libsrtp" >&2;}
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** After re-installing libsrtp, re-run the Asterisk" >&5
+$as_echo "$as_me: WARNING: *** After re-installing libsrtp, re-run the Asterisk" >&2;}
         { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: *** configure script." >&5
 $as_echo "$as_me: WARNING: *** configure script." >&2;}
         { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ***" >&5
@@ -31339,15 +33119,19 @@ $as_echo "$as_me: WARNING: *** with the
         exit 1
 
 
+
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-    LIBS="${saved_libs}"
-    LDFLAGS="${saved_ldflags}"
-    CFLAGS="${saved_cflags}"
+   CFLAGS="${ast_ext_lib_check_shared_saved_cflags}"
+   LDFLAGS="${ast_ext_lib_check_shared_saved_ldflags}"
+   LIBS="${ast_ext_lib_check_shared_saved_libs}"
 fi
 
 
+    if test "x$PBX_SRTP" = x1;
+    then
+
 if test "x${PBX_SRTP_SHUTDOWN}" != "x1" -a "${USE_SRTP_SHUTDOWN}" != "no"; then
    pbxlibdir=""
    # if --with-SRTP_SHUTDOWN=DIR has been specified, use it.
@@ -31451,6 +33235,8 @@ _ACEOF
 fi
 
 
+    fi
+fi
 
 for ver in 2.0 2.2 2.4 2.6; do
 
@@ -33216,6 +35002,98 @@ fi
 
 
 
+
+
+
+
+   if test "x${PBX_SYSTEMD}" != "x1" -a "${USE_SYSTEMD}" != "no"; then
+
+pkg_failed=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SYSTEMD" >&5
+$as_echo_n "checking for SYSTEMD... " >&6; }
+
+if test -n "$SYSTEMD_CFLAGS"; then
+    pkg_cv_SYSTEMD_CFLAGS="$SYSTEMD_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libsystemd\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libsystemd") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_SYSTEMD_CFLAGS=`$PKG_CONFIG --cflags "libsystemd" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+if test -n "$SYSTEMD_LIBS"; then
+    pkg_cv_SYSTEMD_LIBS="$SYSTEMD_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libsystemd\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libsystemd") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_SYSTEMD_LIBS=`$PKG_CONFIG --libs "libsystemd" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+
+
+
+if test $pkg_failed = yes; then
+   	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi
+        if test $_pkg_short_errors_supported = yes; then
+	        SYSTEMD_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "libsystemd" 2>&1`
+        else
+	        SYSTEMD_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "libsystemd" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$SYSTEMD_PKG_ERRORS" >&5
+
+
+            PBX_SYSTEMD=0
+
+
+elif test $pkg_failed = untried; then
+     	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+            PBX_SYSTEMD=0
+
+
+else
+	SYSTEMD_CFLAGS=$pkg_cv_SYSTEMD_CFLAGS
+	SYSTEMD_LIBS=$pkg_cv_SYSTEMD_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+            PBX_SYSTEMD=1
+            SYSTEMD_INCLUDE="$SYSTEMD_CFLAGS"
+            SYSTEMD_LIB="$SYSTEMD_LIBS"
+
+$as_echo "#define HAVE_SYSTEMD 1" >>confdefs.h
+
+
+fi
+   fi
+
+
 PBX_SYSLOG=0
 
 if test "${ac_cv_header_syslog_h}" = "yes"; then
diff -urpN asterisk-13.9.1/configure.ac asterisk-13.17.0/configure.ac
--- asterisk-13.9.1/configure.ac	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/configure.ac	2017-07-12 13:12:08.000000000 +0200
@@ -178,7 +178,7 @@ case "${host_os}" in
      OSARCH=cygwin
      PBX_WINARCH=1
      ;;
-     linux-gnueabi* |  linux-gnuspe)
+     linux-gnu*)
      OSARCH=linux-gnu
      ;;
      kfreebsd*-gnu)
@@ -264,6 +264,7 @@ AC_SUBST(GNU_LD)
 
 AC_PATH_PROG([BISON], [bison], :)
 AC_PATH_PROG([CMP], [cmp], :)
+AC_PATH_PROG([CAT], [cat], :)
 AC_PATH_PROG([FLEX], [flex], :)
 AC_PATH_PROG([GREP], [grep], :)
 AC_PATH_PROG([PYTHON], [python], :)
@@ -282,18 +283,35 @@ AC_PATH_PROG([CATDVI], [catdvi], :)
 AC_PATH_PROG([KPATHSEA], [kpsewhich], :)
 AC_PATH_PROG([XMLLINT], [xmllint], :)
 AC_PATH_PROG([XMLSTARLET], [xmlstarlet], :)
+AC_PATH_PROG([BASH], [bash], :)
 AC_PATH_PROG([GIT], [git], :)
 AC_PATH_PROG([ALEMBIC], [alembic], :)
+AC_PATH_PROG([BZIP2], [bzip2], :)
+AC_PATH_PROG([TAR], [tar], :)
+AC_PATH_PROG([PATCH], [patch], :)
+AC_PATH_PROG([SED], [sed], :)
+AC_PATH_PROG([NM], [nm], :)
+
 if test "${WGET}" != ":" ; then
   DOWNLOAD=${WGET}
+  DOWNLOAD_TO_STDOUT="${WGET} -q -O-"
+  DOWNLOAD_TIMEOUT='--timeout=$1'
 else if test "${CURL}" != ":" ; then
   DOWNLOAD="${CURL} -O --progress-bar -w \"%{url_effective}\n\""
+  DOWNLOAD_TO_STDOUT="${CURL} -Ls"
+  DOWNLOAD_TIMEOUT='--max-time $(or $2,$1)'
 else
   AC_PATH_PROG([FETCH], [fetch], [:])
   DOWNLOAD=${FETCH}
+  DOWNLOAD_TO_STDOUT="${FETCH} -o-"
+  DOWNLOAD_TIMEOUT='--timeout=$(or $2,$1)'
 fi
 fi
+
 AC_SUBST(DOWNLOAD)
+AC_SUBST(DOWNLOAD_TO_STDOUT)
+AC_SUBST(DOWNLOAD_TIMEOUT)
+
 AC_PATH_PROG([LDCONFIG], [ldconfig], :)
 AC_PATH_PROG([SHA1SUM], [sha1sum], $ac_aux_dir/build_tools/sha1sum-sh)
 AC_PATH_PROG([OPENSSL], [openssl], :)
@@ -341,6 +359,20 @@ else
 fi
 AC_SUBST(PBX_FLEX)
 
+if test "x${XMLSTARLET}" = "x:" ; then
+	PBX_XMLSTARLET=0
+else
+	PBX_XMLSTARLET=1
+fi
+AC_SUBST(PBX_XMLSTARLET)
+
+if test "x${BASH}" = "x:" ; then
+	PBX_BASH=0
+else
+	PBX_BASH=1
+fi
+AC_SUBST(PBX_BASH)
+
 AC_CHECK_TOOL([SOXMIX], [soxmix], [:])
 if test "${SOXMIX}" != ":" ; then
 	AC_DEFINE([HAVE_SOXMIX], 1, [Define to 1 if your system has soxmix application.])
@@ -352,7 +384,7 @@ if test "${MD5}" = "digest" ; then
    MD5="${MD5} -a md5"
 fi
 
-ACX_PTHREAD
+AX_PTHREAD
 
 AC_LANG(C)
 
@@ -376,6 +408,9 @@ AC_SUBST(NOISY_BUILD)
 AC_SUBST(AST_DEVMODE)
 AC_SUBST(AST_DEVMODE_STRICT)
 
+AST_OPTION_ONLY([sounds-cache], [SOUNDS_CACHE_DIR], [cached sound tarfiles], [])
+AST_OPTION_ONLY([externals-cache], [EXTERNALS_CACHE_DIR], [cached external module tarfiles], [])
+
 AST_CODE_COVERAGE=no
 AC_ARG_ENABLE([coverage],
 	[AS_HELP_STRING([--enable-coverage],
@@ -390,6 +425,19 @@ AC_SUBST(AST_CODE_COVERAGE)
 AST_CHECK_RAII()
 AST_CHECK_STRSEP_ARRAY_BOUNDS()
 
+PJPROJECT_BUNDLED=no
+AH_TEMPLATE(m4_bpatsubst([[HAVE_PJPROJECT_BUNDLED]], [(.*)]), [Define to 1 when using the bundled pjproject.])
+
+AC_ARG_WITH([pjproject-bundled],
+	[AS_HELP_STRING([--with-pjproject-bundled],
+		[Use bundled pjproject libraries])],
+	[case "${withval}" in
+	      n|no) PJPROJECT_BUNDLED=no ;;
+	      *) PJPROJECT_BUNDLED=yes ;;
+	esac])
+
+THIRD_PARTY_CONFIGURE()
+
 # AST_EXT_LIB_SETUP is used to tell configure to handle variables for
 # various packages.
 # $1 is the prefix for the variables in makeopts and autoconfig.h
@@ -415,7 +463,6 @@ AST_EXT_LIB_SETUP([CRYPT], [password and
 AST_EXT_LIB_SETUP([CRYPTO], [OpenSSL Cryptography], [crypto])
 AST_EXT_LIB_SETUP_OPTIONAL([OPENSSL_SRTP], [OpenSSL SRTP Extension Support], [CRYPTO], [crypto])
 AST_EXT_LIB_SETUP_OPTIONAL([OPENSSL_EC], [OpenSSL Elliptic Curve Support], [CRYPTO], [crypto])
-AST_EXT_LIB_SETUP_OPTIONAL([OPENSSL_ECDH_AUTO], [OpenSSL Auto ECDH Support], [CRYPTO], [crypto])
 AST_EXT_LIB_SETUP([DAHDI], [DAHDI], [dahdi])
 AST_EXT_LIB_SETUP([FFMPEG], [Ffmpeg and avcodec], [avcodec])
 AST_EXT_LIB_SETUP([GSM], [External GSM], [gsm], [, use 'internal' GSM otherwise])
@@ -438,6 +485,7 @@ AST_EXT_LIB_SETUP([KQUEUE], [kqueue supp
 AST_EXT_LIB_SETUP([LDAP], [OpenLDAP], [ldap])
 AST_LIBCURL_CHECK_CONFIG([], [7.10.1])
 AST_EXT_LIB_SETUP([LIBEDIT], [NetBSD Editline library], [libedit], [, use 'internal' Editline otherwise])
+AST_EXT_LIB_SETUP_OPTIONAL([LIBEDIT_IS_UNICODE], [Libedit compiled for unicode], [LIBEDIT], [libedit])
 AST_EXT_LIB_SETUP([LIBXML2], [LibXML2], [libxml2])
 AST_EXT_LIB_SETUP([LIBXSLT], [LibXSLT], [libxslt])
 AST_EXT_LIB_SETUP_OPTIONAL([LIBXSLT_CLEANUP], [LibXSLT Library Cleanup Function], [LIBXSLT], [libxslt])
@@ -458,28 +506,8 @@ AST_EXT_LIB_SETUP([OSPTK], [OSP Toolkit]
 AST_EXT_LIB_SETUP([OSS], [Open Sound System], [oss])
 AST_EXT_LIB_SETUP([PGSQL], [PostgreSQL], [postgres])
 
+if test "x${PBX_PJPROJECT}" != "x1" ; then
 AST_EXT_LIB_SETUP([PJPROJECT], [PJPROJECT], [pjproject])
-PJPROJECT_BUNDLED=no
-AH_TEMPLATE(m4_bpatsubst([[HAVE_PJPROJECT_BUNDLED]], [(.*)]), [Define to 1 when using the bundled pjproject.])
-
-AC_ARG_WITH([pjproject-bundled],
-	[AS_HELP_STRING([--with-pjproject-bundled],
-		[Use bundled pjproject libraries])],
-	[case "${enableval}" in
-	      n|no) PJPROJECT_BUNDLED=no ;;
-	      *) PJPROJECT_BUNDLED=yes ;;
-	esac])
-AC_SUBST(PJPROJECT_BUNDLED)
-
-if test "$PJPROJECT_BUNDLED" = "yes" -a "${ac_mandatory_list#*PJPROJECT*}" != "$ac_mandatory_list" ; then
-   AC_MSG_ERROR(--with-pjproject and --with-pjproject-bundled can't both be specified)
-fi
-
-if test "$PJPROJECT_BUNDLED" = "yes" ; then
-   ac_mandatory_list="$ac_mandatory_list PJPROJECT"
-   PJPROJECT_DIR="${ac_top_build_prefix}third-party/pjproject"
-fi
-
 AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_DLG_CREATE_UAS_AND_INC_LOCK], [PJSIP Dialog Create UAS with Incremented Lock], [PJPROJECT], [pjsip])
 AST_EXT_LIB_SETUP_OPTIONAL([PJ_TRANSACTION_GRP_LOCK], [PJSIP Transaction Group Lock Support], [PJPROJECT], [pjsip])
 AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_REPLACE_MEDIA_STREAM], [PJSIP Media Stream Replacement Support], [PJPROJECT], [pjsip])
@@ -487,6 +515,12 @@ AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_GET_DE
 AST_EXT_LIB_SETUP_OPTIONAL([PJ_SSL_CERT_LOAD_FROM_FILES2], [pj_ssl_cert_load_from_files2 support], [PJPROJECT], [pjsip])
 AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_EXTERNAL_RESOLVER], [PJSIP External Resolver Support], [PJPROJECT], [pjsip])
 AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_TLS_TRANSPORT_PROTO], [PJSIP TLS Transport proto field support], [PJPROJECT], [pjsip])
+AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_EVSUB_GRP_LOCK], [PJSIP EVSUB Group Lock support], [PJPROJECT], [pjsip])
+AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_INV_SESSION_REF], [PJSIP INVITE Session Reference Count support], [PJPROJECT], [pjsip])
+AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_AUTH_CLT_DEINIT], [pjsip_auth_clt_deinit support], [PJPROJECT], [pjsip])
+AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_EVSUB_SET_UAS_TIMEOUT], [PJSIP EVSUB Set UAS Timeout support], [PJPROJECT], [pjsip])
+AST_EXT_LIB_SETUP_OPTIONAL([PJSIP_TSX_LAYER_FIND_TSX2], [pjsip_tsx_layer_find_tsx2 support], [PJPROJECT], [pjsip])
+fi
 
 AST_EXT_LIB_SETUP([POPT], [popt], [popt])
 AST_EXT_LIB_SETUP([PORTAUDIO], [PortAudio], [portaudio])
@@ -520,7 +554,6 @@ AST_EXT_LIB_SETUP([RADIUS], [Radius Clie
 AST_EXT_LIB_SETUP([RESAMPLE], [LIBRESAMPLE], [resample])
 AST_EXT_LIB_SETUP([SDL], [Sdl], [sdl])
 AST_EXT_LIB_SETUP([SDL_IMAGE], [Sdl Image], [SDL_image])
-AST_OPTION_ONLY([sounds-cache], [SOUNDS_CACHE_DIR], [cached sound tarfiles], [])
 AST_EXT_LIB_SETUP([SPANDSP], [SPANDSP], [spandsp])
 AST_EXT_LIB_SETUP([SS7], [ISDN SS7], [ss7])
 AST_EXT_LIB_SETUP([SPEEX], [Speex], [speex])
@@ -532,6 +565,7 @@ AST_EXT_LIB_SETUP([SQLITE3], [SQLite], [
 AST_EXT_LIB_SETUP([SRTP], [Secure RTP], [srtp])
 AST_EXT_LIB_SETUP_OPTIONAL([SRTP_SHUTDOWN], [SRTP Library Shutdown Function], [SRTP], [srtp])
 AST_EXT_LIB_SETUP([OPENSSL], [OpenSSL Secure Sockets Layer], [ssl])
+AST_EXT_LIB_SETUP_OPTIONAL([RT], [Realtime functions], [rt])
 AST_EXT_LIB_SETUP([SUPPSERV], [mISDN Supplemental Services], [suppserv])
 AST_EXT_LIB_SETUP([FREETDS], [FreeTDS], [tds])
 AST_EXT_LIB_SETUP([TERMCAP], [Termcap], [termcap])
@@ -603,6 +637,9 @@ if test "x$JANSSON_LIB" == "x"; then
   AC_MSG_ERROR([*** JSON support not found (this typically means the libjansson development package is missing)])
 fi
 
+# See if clock_gettime is in librt
+AST_EXT_LIB_CHECK([RT], [rt], [clock_gettime])
+
 AST_EXT_TOOL_CHECK([LIBXML2], [xml2-config], , ,
         [#include <libxml/tree.h>
         #include <libxml/parser.h>],
@@ -682,8 +719,6 @@ AC_PROG_GCC_TRADITIONAL
 AC_FUNC_MEMCMP
 AC_FUNC_MMAP
 AC_FUNC_SELECT_ARGTYPES
-AC_FUNC_SETVBUF_REVERSED
-AC_TYPE_SIGNAL
 AC_FUNC_STAT
 AC_FUNC_STRCOLL
 AC_FUNC_STRFTIME
@@ -1063,6 +1098,16 @@ if test "${ac_cv_have_variable_fdset}x"
 		AC_DEFINE([CONFIGURE_RAN_AS_ROOT], 1, [Some configure tests will unexpectedly fail if configure is run by a non-root user.  These may be able to be tested at runtime.]))
 fi
 
+AC_MSG_CHECKING([if we have usable eventfd support])
+AC_RUN_IFELSE(
+  [AC_LANG_PROGRAM([#include <sys/eventfd.h>],
+      [return eventfd(0, EFD_NONBLOCK | EFD_SEMAPHORE) == -1;])],
+  AC_MSG_RESULT(yes)
+  AC_DEFINE([HAVE_EVENTFD], 1, [Define to 1 if your system supports eventfd and the EFD_NONBLOCK and EFD_SEMAPHORE flags.]),
+  AC_MSG_RESULT(no),
+  AC_MSG_RESULT(cross-compile)
+)
+
 AST_GCC_ATTRIBUTE(pure)
 AST_GCC_ATTRIBUTE(malloc)
 AST_GCC_ATTRIBUTE(const)
@@ -1074,6 +1119,7 @@ AST_GCC_ATTRIBUTE(warn_unused_result)
 AST_GCC_ATTRIBUTE(may_alias)
 AST_GCC_ATTRIBUTE(constructor)
 AST_GCC_ATTRIBUTE(destructor)
+AST_GCC_ATTRIBUTE(noreturn,noreturn)
 
 AC_MSG_CHECKING(for -fsanitize=address support)
 saved_sanitize_CFLAGS="${CFLAGS}"
@@ -1084,7 +1130,7 @@ AC_COMPILE_IFELSE(
 	[AC_LANG_PROGRAM([], [int x = 1;])],
 	AC_MSG_RESULT(yes)
 	[AST_ADDRESS_SANITIZER=1],
-	[AST_ADDRESS_SANITIZER=]
+	[AST_ADDRESS_SANITIZER=0]
 	AC_MSG_RESULT(no)
 )
 CFLAGS="${saved_sanitize_CFLAGS}"
@@ -1100,7 +1146,7 @@ AC_COMPILE_IFELSE(
 	[AC_LANG_PROGRAM([], [int x = 1;])],
 	AC_MSG_RESULT(yes)
 	[AST_THREAD_SANITIZER=1],
-	[AST_THREAD_SANITIZER=]
+	[AST_THREAD_SANITIZER=0]
 	AC_MSG_RESULT(no)
 )
 CFLAGS="${saved_sanitize_CFLAGS}"
@@ -1116,7 +1162,7 @@ AC_COMPILE_IFELSE(
 	[AC_LANG_PROGRAM([], [int x = 1;])],
 	AC_MSG_RESULT(yes)
 	[AST_LEAK_SANITIZER=1],
-	[AST_LEAK_SANITIZER=]
+	[AST_LEAK_SANITIZER=0]
 	AC_MSG_RESULT(no)
 )
 CFLAGS="${saved_sanitize_CFLAGS}"
@@ -1132,36 +1178,13 @@ AC_COMPILE_IFELSE(
 	[AC_LANG_PROGRAM([], [int x = 1;])],
 	AC_MSG_RESULT(yes)
 	[AST_UNDEFINED_SANITIZER=1],
-	[AST_UNDEFINED_SANITIZER=]
+	[AST_UNDEFINED_SANITIZER=0]
 	AC_MSG_RESULT(no)
 )
 CFLAGS="${saved_sanitize_CFLAGS}"
 LDFLAGS="${saved_sanitize_LDFLAGS}"
 AC_SUBST(AST_UNDEFINED_SANITIZER)
 
-AC_MSG_CHECKING(for -ffunction-sections support)
-saved_CFLAGS="${CFLAGS}"
-CFLAGS="${CFLAGS} -ffunction-sections"
-AC_COMPILE_IFELSE(
-	[AC_LANG_PROGRAM([], [int x = 1;])],
-	AC_MSG_RESULT(yes)
-	[saved_LDFLAGS="${LDFLAGS}"]
-	[LDFLAGS="${LDFLAGS} -Wl,--gc-sections"]
-	AC_MSG_CHECKING(for --gc-sections support)
-	AC_LINK_IFELSE(
-		[AC_LANG_PROGRAM([], [int x = 1;])],
-		AC_MSG_RESULT(yes)
-		[GC_CFLAGS="-ffunction-sections"]
-		[[GC_LDFLAGS="-Wl,--gc-sections"]],
-		AC_MSG_RESULT(no)
-	)
-	[LDFLAGS="${saved_LDFLAGS}"],
-	AC_MSG_RESULT(no)
-)
-CFLAGS="${saved_CFLAGS}"
-AC_SUBST(GC_CFLAGS)
-AC_SUBST(GC_LDFLAGS)
-
 AC_MSG_CHECKING(for -Wdeclaration-after-statement support)
 if $(${CC} -Wdeclaration-after-statement -S -o /dev/null -xc /dev/null > /dev/null 2>&1); then
 	AC_MSG_RESULT(yes)
@@ -1214,23 +1237,18 @@ AC_SUBST(AST_SHADOW_WARNINGS)
 
 AC_MSG_CHECKING(for -march=native support)
 if $(${CC} -march=native -S -o /dev/null -xc /dev/null > /dev/null 2>&1); then
-	if test "${CONFIG_CFLAGS}" = ""; then
-		AC_MSG_RESULT(yes)
-		AST_NATIVE_ARCH=1
-	else
-		AC_MSG_RESULT(user CFLAGS present)
-		AST_NATIVE_ARCH=
-	fi
+	AC_MSG_RESULT(yes)
+	AST_NATIVE_ARCH=1
 else
 	AC_MSG_RESULT(no)
-	AST_NATIVE_ARCH=
+	AST_NATIVE_ARCH=0
 fi
 AC_SUBST(AST_NATIVE_ARCH)
 
 
 dnl Check to see if rpath should be set in LDFLAGS
 AC_ARG_ENABLE(rpath,
-	[AC_HELP_STRING([--disable-rpath],
+	[AS_HELP_STRING([--disable-rpath],
 			[Disables rpath linker option checking])],
 	[case "${enableval}" in
 		y|ye|yes) check_rpath=yes ;;
@@ -1316,6 +1334,18 @@ AC_LINK_IFELSE(
 	AC_MSG_RESULT(no)
 )
 
+AC_MSG_CHECKING(for BIND_8_COMPAT required)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+[[
+#undef BIND_8_COMPAT
+#include <arpa/nameser.h>
+]],
+[[int x = NXDOMAIN]])],
+AC_MSG_RESULT(no),
+AC_MSG_RESULT(yes)
+[BIND8_CFLAGS=-DBIND_8_COMPAT])
+AC_SUBST(BIND8_CFLAGS)
+
 AST_C_DEFINE_CHECK([GLOB_NOMAGIC], [GLOB_NOMAGIC], [glob.h])
 
 AST_C_DEFINE_CHECK([GLOB_BRACE], [GLOB_BRACE], [glob.h])
@@ -1502,11 +1532,14 @@ if test "${USE_LIBEDIT}" != "no"; then
    if test "${LIBEDIT_SYSTEM}" = "yes"; then
       AST_PKG_CONFIG_CHECK(LIBEDIT, libedit)
       if test "$PBX_LIBEDIT" = "1"; then
-	 LIBEDIT_INTERNAL="no"
+      LIBEDIT_INTERNAL="no"
       fi
    fi
    if test "${LIBEDIT_INTERNAL}" = "yes"; then
       PBX_LIBEDIT=1
+      LIBEDIT_IS_UNICODE=no
+   else
+      AST_C_COMPILE_CHECK([LIBEDIT_IS_UNICODE], [el_rfunc_t *callback;], [histedit.h], [], [Testing for libedit unicode support])
    fi
 fi
 
@@ -2167,9 +2200,7 @@ if test "${PG_CONFIG}" != No; then
 fi
 
 if test "$USE_PJPROJECT" != "no" ; then
-   if test "$PJPROJECT_BUNDLED" = "yes" ; then
-       PJPROJECT_CONFIGURE([$PJPROJECT_DIR])
-   else
+   if test "$PJPROJECT_BUNDLED" = "no" ; then
       AST_PKG_CONFIG_CHECK([PJPROJECT], [libpjproject])
 
       AST_EXT_LIB_CHECK([PJSIP_DLG_CREATE_UAS_AND_INC_LOCK], [pjsip], [pjsip_dlg_create_uas_and_inc_lock], [pjsip.h], [$PJPROJECT_LIBS], [$PJPROJECT_CFLAGS])
@@ -2184,7 +2215,7 @@ if test "$USE_PJPROJECT" != "no" ; then
       CPPFLAGS="${saved_cppflags}"
 
       AST_EXT_LIB_CHECK([PJSIP_GET_DEST_INFO], [pjsip], [pjsip_get_dest_info], [pjsip.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
-      AST_EXT_LIB_CHECK([PJ_SSL_CERT_LOAD_FROM_FILES2], [pj], [pjsip/include/pjsip/sip_util.h], [pjlib.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
+      AST_EXT_LIB_CHECK([PJ_SSL_CERT_LOAD_FROM_FILES2], [pj], [pj_ssl_cert_load_from_files2], [pjlib.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
       AST_EXT_LIB_CHECK([PJSIP_EXTERNAL_RESOLVER], [pjsip], [pjsip_endpt_set_ext_resolver], [pjsip.h], [$PJPROJECT_LIBS], [$PJPROJECT_CFLAGS])
 
       saved_cppflags="${CPPFLAGS}"
@@ -2194,9 +2225,19 @@ if test "$USE_PJPROJECT" != "no" ; then
       AST_C_COMPILE_CHECK([PJSIP_TLS_TRANSPORT_PROTO], [struct pjsip_tls_setting setting; int proto; proto = setting.proto;], [pjsip.h])
       LIBS="${saved_libs}"
       CPPFLAGS="${saved_cppflags}"
+
+      AST_EXT_LIB_CHECK([PJSIP_EVSUB_GRP_LOCK], [pjsip], [pjsip_evsub_add_ref], [pjsip.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
+      AST_EXT_LIB_CHECK([PJSIP_INV_SESSION_REF], [pjsip], [pjsip_inv_add_ref], [pjsip.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
+      AST_EXT_LIB_CHECK([PJSIP_AUTH_CLT_DEINIT], [pjsip], [pjsip_auth_clt_deinit], [pjsip.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
+      AST_EXT_LIB_CHECK([PJSIP_EVSUB_SET_UAS_TIMEOUT], [pjsip], [pjsip_evsub_set_uas_timeout], [pjsip.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
+      AST_EXT_LIB_CHECK([PJSIP_TSX_LAYER_FIND_TSX2], [pjsip], [pjsip_tsx_layer_find_tsx2], [pjsip.h], [$PJPROJECT_LIB], [$PJPROJECT_CFLAGS])
    fi
 fi
 
+AC_SUBST([PYTHONDEV_LIB])
+AC_SUBST([PYTHONDEV_INCLUDE])
+AST_PKG_CONFIG_CHECK([PYTHONDEV], [python])
+
 AST_EXT_LIB_CHECK([POPT], [popt], [poptStrerror], [popt.h])
 
 AST_EXT_LIB_CHECK([PORTAUDIO], [portaudio], [Pa_GetDeviceCount], [portaudio.h])
@@ -2393,55 +2434,63 @@ fi
 
 if test "$PBX_OPENSSL" = "1";
 then
-        AST_C_DECLARE_CHECK([OPENSSL_ECDH_AUTO], [SSL_CTX_set_ecdh_auto], [openssl/ssl.h])
-fi
-
-if test "$PBX_OPENSSL" = "1";
-then
         AST_C_DEFINE_CHECK([SSL_OP_NO_TLSV1_1], [SSL_OP_NO_TLSv1_1], [openssl/ssl.h])
         AST_C_DEFINE_CHECK([SSL_OP_NO_TLSV1_2], [SSL_OP_NO_TLSv1_2], [openssl/ssl.h])
 fi
 
-AST_EXT_LIB_CHECK([SRTP], [srtp], [srtp_init], [srtp/srtp.h])
+AST_EXT_LIB_CHECK([SRTP], [srtp2], [srtp_init], [srtp2/srtp.h], [], [], [2])
+AST_EXT_LIB_CHECK_SHARED([SRTP], [srtp2], [srtp_init], [srtp2/srtp.h], [], [], [], [
+    AC_MSG_WARN([***])
+    AC_MSG_WARN([*** libsrtp2 could not be linked as a shared object.])
+    AC_MSG_WARN([*** Try compiling libsrtp2 manually. Configure libsrtp2])
+    AC_MSG_WARN([*** with ./configure --prefix=/usr replacing /usr with])
+    AC_MSG_WARN([*** the prefix of your choice, and then make with])
+    AC_MSG_WARN([*** 'make libsrtp2.so'])
+    AC_MSG_WARN([***])
+    AC_MSG_WARN([*** After re-installing libsrtp2, re-run the Asterisk])
+    AC_MSG_WARN([*** configure script.])
+    AC_MSG_WARN([***])
+    AC_MSG_WARN([*** If you do not need SRTP support re-run configure])
+    AC_MSG_WARN([*** with the --without-srtp option.])
+    exit 1
+])
 
-if test "$PBX_SRTP" = "1";
+if test "x$PBX_SRTP" = x1;
 then
-    saved_libs="${LIBS}"
-    saved_ldflags="${LDFLAGS}"
-    saved_cflags="${CFLAGS}"
-    LIBS="${LIBS} ${SRTP_LIB}"
-    LDFLAGS="${LDFLAGS} -shared -fPIC"
-    CFLAGS="${CFLAGS} ${SRTP_INCLUDE}"
-    AC_MSG_CHECKING(for the ability of -lsrtp to be linked in a shared object)
-    AC_LINK_IFELSE(
-    [
-        AC_LANG_PROGRAM(
-            [#include <srtp/srtp.h>],
-            [srtp_init();]
-        )
-    ],
-    [ AC_MSG_RESULT(yes) ],
-    [
-        AC_MSG_RESULT(no)
-        AC_MSG_WARN(***)
-        AC_MSG_WARN(*** libsrtp could not be linked as a shared object.)
-        AC_MSG_WARN(*** Try compiling libsrtp manually. Configure libsrtp)
-        AC_MSG_WARN(*** with ./configure CFLAGS=-fPIC --prefix=/usr)
-        AC_MSG_WARN(*** replacing /usr with the prefix of your choice.)
-        AC_MSG_WARN(*** After re-installing libsrtp, re-run the Asterisk)
-        AC_MSG_WARN(*** configure script.)
-        AC_MSG_WARN(***)
-        AC_MSG_WARN(*** If you do not need SRTP support re-run configure)
-        AC_MSG_WARN(*** with the --without-srtp option.)
-        exit 1
-    ]
-    )
-    LIBS="${saved_libs}"
-    LDFLAGS="${saved_ldflags}"
-    CFLAGS="${saved_cflags}"
+    AST_EXT_LIB_CHECK([SRTP_SHUTDOWN], [srtp2], [srtp_shutdown], [srtp2/srtp.h])
+
+    # libsrtp2 removed support for PRNG, so we require OpenSSL
+    if test "x$PBX_OPENSSL" != x1;
+    then
+        AC_MSG_WARN([***])
+        AC_MSG_WARN([*** OpenSSL required when using libsrtp2, checking for libsrtp instead.])
+        AC_MSG_WARN([***])
+        PBX_SRTP=0
+    fi
 fi
 
-AST_EXT_LIB_CHECK([SRTP_SHUTDOWN], [srtp], [srtp_shutdown], [srtp/srtp.h])
+if test "x$PBX_SRTP" != x1;
+then
+    AST_EXT_LIB_CHECK([SRTP], [srtp], [srtp_init], [srtp/srtp.h], [], [], [1])
+    AST_EXT_LIB_CHECK_SHARED([SRTP], [srtp], [srtp_init], [srtp/srtp.h], [], [], [], [
+        AC_MSG_WARN([***])
+        AC_MSG_WARN([*** libsrtp could not be linked as a shared object.])
+        AC_MSG_WARN([*** Try compiling libsrtp manually. Configure libsrtp])
+        AC_MSG_WARN([*** with ./configure CFLAGS=-fPIC --prefix=/usr])
+        AC_MSG_WARN([*** replacing /usr with the prefix of your choice.])
+        AC_MSG_WARN([*** After re-installing libsrtp, re-run the Asterisk])
+        AC_MSG_WARN([*** configure script.])
+        AC_MSG_WARN([***])
+        AC_MSG_WARN([*** If you do not need SRTP support re-run configure])
+        AC_MSG_WARN([*** with the --without-srtp option.])
+        exit 1
+    ])
+
+    if test "x$PBX_SRTP" = x1;
+    then
+        AST_EXT_LIB_CHECK([SRTP_SHUTDOWN], [srtp], [srtp_shutdown], [srtp/srtp.h])
+    fi
+fi
 
 for ver in 2.0 2.2 2.4 2.6; do
 	AST_PKG_CONFIG_CHECK([GMIME], gmime-$ver)
@@ -2588,6 +2637,11 @@ AC_SUBST([GENERIC_ODBC_LIB])
 AC_SUBST([GENERIC_ODBC_INCLUDE])
 AC_SUBST([PBX_GENERIC_ODBC])
 
+AC_SUBST([PBX_SYSTEMD])
+AC_SUBST([SYSTEMD_LIB])
+AC_SUBST([SYSTEMD_INCLUDE])
+AST_PKG_CONFIG_CHECK([SYSTEMD], [libsystemd])
+
 PBX_SYSLOG=0
 
 if test "${ac_cv_header_syslog_h}" = "yes"; then
diff -urpN asterisk-13.9.1/contrib/Makefile asterisk-13.17.0/contrib/Makefile
--- asterisk-13.9.1/contrib/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -20,10 +20,14 @@ clean:
 include $(ASTTOPDIR)/Makefile.rules
 
 install:
-	if [ -n "$(findstring REF_DEBUG,$(MENUSELECT_CFLAGS))" ]; then \
-		$(INSTALL) -d "$(DESTDIR)$(ASTDATADIR)/scripts"; \
-		$(INSTALL) -m 755 scripts/refcounter.py "$(DESTDIR)$(ASTDATADIR)/scripts/refcounter.py"; \
-	fi
+	$(INSTALL) -d "$(DESTDIR)$(ASTDATADIR)/scripts"
+	$(INSTALL) -m 755 scripts/ast_logescalator "$(DESTDIR)$(ASTDATADIR)/scripts/ast_logescalator"
+	$(INSTALL) -m 755 scripts/ast_loggrabber "$(DESTDIR)$(ASTDATADIR)/scripts/ast_loggrabber"
+	$(INSTALL) -m 755 scripts/ast_coredumper "$(DESTDIR)$(ASTDATADIR)/scripts/ast_coredumper"
+	$(INSTALL) -m 755 scripts/refcounter.py "$(DESTDIR)$(ASTDATADIR)/scripts/refcounter.py"
 
 uninstall:
-	rm -f "$(DESTDIR)$(ASTDATADIR)/scripts/refcounter.py"
+	-rm -f "$(DESTDIR)$(ASTDATADIR)/scripts/ast_logescalator"
+	-rm -f "$(DESTDIR)$(ASTDATADIR)/scripts/ast_loggrabber"
+	-rm -f "$(DESTDIR)$(ASTDATADIR)/scripts/ast_coredumper"
+	-rm -f "$(DESTDIR)$(ASTDATADIR)/scripts/refcounter.py"
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/README.md asterisk-13.17.0/contrib/ast-db-manage/README.md
--- asterisk-13.9.1/contrib/ast-db-manage/README.md	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/ast-db-manage/README.md	2017-07-12 13:12:08.000000000 +0200
@@ -9,6 +9,7 @@ This is implemented as a set of reposito
 migrations, using [Alembic](http://alembic.readthedocs.org).  The existing
 repositories include:
 
+ * `cdr` - Table used for Asterisk to store CDR records
  * `config` - Tables used for Asterisk realtime configuration
  * `voicemail` - Tables used for `ODBC_STOARGE` of voicemail messages
 
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/cdr/env.py asterisk-13.17.0/contrib/ast-db-manage/cdr/env.py
--- asterisk-13.9.1/contrib/ast-db-manage/cdr/env.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/ast-db-manage/cdr/env.py	2017-07-12 13:12:08.000000000 +0200
@@ -1,7 +1,10 @@
 from __future__ import with_statement
 from alembic import context
+from alembic.script import ScriptDirectory
+from alembic.operations import Operations
 from sqlalchemy import engine_from_config, pool
 from logging.config import fileConfig
+import logging
 
 # this is the Alembic Config object, which provides
 # access to the values within the .ini file in use.
@@ -14,6 +17,7 @@ try:
 except:
     pass
 
+logger = logging.getLogger('alembic.runtime.setup')
 # add your model's MetaData object here
 # for 'autogenerate' support
 # from myapp import mymodel
@@ -55,11 +59,72 @@ def run_migrations_online():
                 prefix='sqlalchemy.',
                 poolclass=pool.NullPool)
 
+    logger.info('Testing for an old alembic_version table.')
+
     connection = engine.connect()
     context.configure(
                 connection=connection,
-                target_metadata=target_metadata
+                target_metadata=target_metadata,
+                version_table='alembic_version'
+                )
+
+    script_location = config.get_main_option('script_location')
+    found = False
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    script = ScriptDirectory.from_config(config)
+    """ If there was an existing alembic_version table, we need to
+    check that it's current revision is in the history for the tree
+    we're working with.
+    """
+    for x in script.iterate_revisions('head', 'base'):
+        if x.revision == current_db_revision:
+            """ An alembic_versions table was found and it belongs to
+            this alembic tree
+            """
+            logger.info(
+                ('An old alembic_version table at revision %s was '
+                 'found for %s.  Renaming to alembic_version_%s.'),
+                        current_db_revision, script_location,
+                        script_location)
+            op = Operations(mc)
+            try:
+                with context.begin_transaction():
+                    op.rename_table(
+                        'alembic_version', 'alembic_version_%s'
+                        % script_location)
+                found = True
+            except:
+                logger.error(('Unable to rename alembic_version to '
+                             'alembic_version_%s.'),
+                             script_location)
+                connection.close()
+                return
+
+            break
+
+    if not found:
+        logger.info('Didn\'t find an old alembic_version table.')
+    logger.info('Trying alembic_version_%s.' % script_location)
+
+    """ We MAY have an alembic_version table that doesn't belong to
+    this tree but if we still don't have an alembic_version_<tree>
+    table, alembic will create it.
+    """
+    context.configure(
+                connection=connection,
+                target_metadata=target_metadata,
+                version_table='alembic_version_' + script_location
                 )
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    if current_db_revision:
+        logger.info(
+            'Using the alembic_version_%s table at revision %s.',
+            script_location, current_db_revision)
+    else:
+        logger.info('Creating new alembic_version_%s table.',
+                    script_location)
 
     try:
         with context.begin_transaction():
@@ -67,6 +132,7 @@ def run_migrations_online():
     finally:
         connection.close()
 
+
 if context.is_offline_mode():
     run_migrations_offline()
 else:
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/env.py asterisk-13.17.0/contrib/ast-db-manage/config/env.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/env.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/ast-db-manage/config/env.py	2017-07-12 13:12:08.000000000 +0200
@@ -1,7 +1,10 @@
 from __future__ import with_statement
 from alembic import context
+from alembic.script import ScriptDirectory
+from alembic.operations import Operations
 from sqlalchemy import engine_from_config, pool
 from logging.config import fileConfig
+import logging
 
 # this is the Alembic Config object, which provides
 # access to the values within the .ini file in use.
@@ -14,6 +17,7 @@ try:
 except:
     pass
 
+logger = logging.getLogger('alembic.runtime.setup')
 # add your model's MetaData object here
 # for 'autogenerate' support
 # from myapp import mymodel
@@ -55,11 +59,72 @@ def run_migrations_online():
                 prefix='sqlalchemy.',
                 poolclass=pool.NullPool)
 
+    logger.info('Testing for an old alembic_version table.')
+
     connection = engine.connect()
     context.configure(
                 connection=connection,
-                target_metadata=target_metadata
+                target_metadata=target_metadata,
+                version_table='alembic_version'
+                )
+
+    script_location = config.get_main_option('script_location')
+    found = False
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    script = ScriptDirectory.from_config(config)
+    """ If there was an existing alembic_version table, we need to
+    check that it's current revision is in the history for the tree
+    we're working with.
+    """
+    for x in script.iterate_revisions('head', 'base'):
+        if x.revision == current_db_revision:
+            """ An alembic_versions table was found and it belongs to
+            this alembic tree
+            """
+            logger.info(
+                ('An old alembic_version table at revision %s was '
+                 'found for %s.  Renaming to alembic_version_%s.'),
+                        current_db_revision, script_location,
+                        script_location)
+            op = Operations(mc)
+            try:
+                with context.begin_transaction():
+                    op.rename_table(
+                        'alembic_version', 'alembic_version_%s'
+                        % script_location)
+                found = True
+            except:
+                logger.error(('Unable to rename alembic_version to '
+                             'alembic_version_%s.'),
+                             script_location)
+                connection.close()
+                return
+
+            break
+
+    if not found:
+        logger.info('Didn\'t find an old alembic_version table.')
+    logger.info('Trying alembic_version_%s.' % script_location)
+
+    """ We MAY have an alembic_version table that doesn't belong to
+    this tree but if we still don't have an alembic_version_<tree>
+    table, alembic will create it.
+    """
+    context.configure(
+                connection=connection,
+                target_metadata=target_metadata,
+                version_table='alembic_version_' + script_location
                 )
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    if current_db_revision:
+        logger.info(
+            'Using the alembic_version_%s table at revision %s.',
+            script_location, current_db_revision)
+    else:
+        logger.info('Creating new alembic_version_%s table.',
+                    script_location)
 
     try:
         with context.begin_transaction():
@@ -67,6 +132,7 @@ def run_migrations_online():
     finally:
         connection.close()
 
+
 if context.is_offline_mode():
     run_migrations_offline()
 else:
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/15db7b91a97a_add_rtcp_mux.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/15db7b91a97a_add_rtcp_mux.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/15db7b91a97a_add_rtcp_mux.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/15db7b91a97a_add_rtcp_mux.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,31 @@
+"""empty message
+
+Revision ID: 15db7b91a97a
+Revises: 465e70e8c337
+Create Date: 2017-03-08 16:56:38.108162
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '15db7b91a97a'
+down_revision = '465e70e8c337'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_endpoints', sa.Column('rtcp_mux', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'rtcp_mux')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/164abbd708c_add_auto_info_to_endpoint_dtmf_mode.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/164abbd708c_add_auto_info_to_endpoint_dtmf_mode.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/164abbd708c_add_auto_info_to_endpoint_dtmf_mode.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/164abbd708c_add_auto_info_to_endpoint_dtmf_mode.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,58 @@
+"""Add auto_info to endpoint dtmf_mode
+
+Revision ID: 164abbd708c
+Revises: 86bb1efa278d
+Create Date: 2017-06-19 13:55:15.354706
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '164abbd708c'
+down_revision = 'd7983954dd96'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+OLD_ENUM = ['rfc4733', 'inband', 'info', 'auto']
+NEW_ENUM = ['rfc4733', 'inband', 'info', 'auto', 'auto_info']
+
+old_type = sa.Enum(*OLD_ENUM, name='pjsip_dtmf_mode_values_v2')
+new_type = sa.Enum(*NEW_ENUM, name='pjsip_dtmf_mode_values_v3')
+
+def upgrade():
+    context = op.get_context()
+
+    # Upgrading to this revision WILL clear your directmedia values.
+    if context.bind.dialect.name != 'postgresql':
+        op.alter_column('ps_endpoints', 'dtmf_mode',
+                        type_=new_type,
+                        existing_type=old_type)
+    else:
+        enum = ENUM('rfc4733', 'inband', 'info', 'auto', 'auto_info',
+                    name='pjsip_dtmf_mode_values_v3')
+        enum.create(op.get_bind(), checkfirst=False)
+
+        op.execute('ALTER TABLE ps_endpoints ALTER COLUMN dtmf_mode TYPE'
+                   ' pjsip_dtmf_mode_values_v3 USING'
+                   ' dtmf_mode::text::pjsip_dtmf_mode_values_v3')
+
+        ENUM(name="pjsip_dtmf_mode_values_v2").drop(op.get_bind(), checkfirst=False)
+
+def downgrade():
+    context = op.get_context()
+
+    if context.bind.dialect.name != 'postgresql':
+        op.alter_column('ps_endpoints', 'dtmf_mode',
+                        type_=old_type,
+                        existing_type=new_type)
+    else:
+        enum = ENUM('rfc4733', 'inband', 'info', 'auto',
+                    name='pjsip_dtmf_mode_values_v2')
+        enum.create(op.get_bind(), checkfirst=False)
+
+        op.execute('ALTER TABLE ps_endpoints ALTER COLUMN dtmf_mode TYPE'
+                   ' pjsip_dtmf_mode_values USING'
+                   ' dtmf_mode::text::pjsip_dtmf_mode_values_v2')
+
+        ENUM(name="pjsip_dtmf_mode_values_v3").drop(op.get_bind(), checkfirst=False)
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/1d0e332c32af_create_rls_table.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/1d0e332c32af_create_rls_table.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/1d0e332c32af_create_rls_table.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/1d0e332c32af_create_rls_table.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,39 @@
+"""create rls table
+
+Revision ID: 1d0e332c32af
+Revises: 2da192dbbc65
+Create Date: 2017-04-25 12:50:09.412662
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '1d0e332c32af'
+down_revision = '2da192dbbc65'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.create_table(
+        'ps_resource_list',
+        sa.Column('id', sa.String(40), nullable=False, unique=True),
+        sa.Column('list_item', sa.String(2048)),
+        sa.Column('event', sa.String(40)),
+        sa.Column('full_state', yesno_values),
+        sa.Column('notification_batch_interval', sa.Integer),
+    )
+
+    op.create_index('ps_resource_list_id', 'ps_resource_list', ['id'])
+
+def downgrade():
+    op.drop_table('ps_resource_list')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/28ab27a7826d_add_srv_lookups_to_identify.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/28ab27a7826d_add_srv_lookups_to_identify.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/28ab27a7826d_add_srv_lookups_to_identify.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/28ab27a7826d_add_srv_lookups_to_identify.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,31 @@
+"""add srv_lookups to identify
+
+Revision ID: 28ab27a7826d
+Revises: 4468b4a91372
+Create Date: 2017-01-06 14:53:38.829655
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '28ab27a7826d'
+down_revision = '4468b4a91372'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_endpoint_id_ips', sa.Column('srv_lookups', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_endpoint_id_ips', 'srv_lookups')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/2da192dbbc65_add_publish_tables.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/2da192dbbc65_add_publish_tables.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/2da192dbbc65_add_publish_tables.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/2da192dbbc65_add_publish_tables.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,73 @@
+"""add publish tables
+
+Revision ID: 2da192dbbc65
+Revises: 8fce4c573e15
+Create Date: 2017-04-05 10:16:52.504699
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '2da192dbbc65'
+down_revision = '8fce4c573e15'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.create_table(
+        'ps_outbound_publishes',
+        sa.Column('id', sa.String(40), nullable=False, unique=True),
+        sa.Column('expiration', sa.Integer),
+        sa.Column('outbound_auth', sa.String(40)),
+        sa.Column('outbound_proxy', sa.String(256)),
+        sa.Column('server_uri', sa.String(256)),
+        sa.Column('from_uri', sa.String(256)),
+        sa.Column('to_uri', sa.String(256)),
+        sa.Column('event', sa.String(40)),
+        sa.Column('max_auth_attempts', sa.Integer),
+        sa.Column('transport', sa.String(40)),
+        sa.Column('multi_user', yesno_values),
+        sa.Column('@body', sa.String(40)),
+        sa.Column('@context', sa.String(256)),
+        sa.Column('@exten', sa.String(256)),
+    )
+
+    op.create_index('ps_outbound_publishes_id', 'ps_outbound_publishes', ['id'])
+
+    op.create_table(
+        'ps_inbound_publications',
+        sa.Column('id', sa.String(40), nullable=False, unique=True),
+        sa.Column('endpoint', sa.String(40)),
+        sa.Column('event_asterisk-devicestate', sa.String(40)),
+        sa.Column('event_asterisk-mwi', sa.String(40)),
+    )
+
+    op.create_index('ps_inbound_publications_id', 'ps_inbound_publications', ['id'])
+
+    op.create_table(
+        'ps_asterisk_publications',
+        sa.Column('id', sa.String(40), nullable=False, unique=True),
+        sa.Column('devicestate_publish', sa.String(40)),
+        sa.Column('mailboxstate_publish', sa.String(40)),
+        sa.Column('device_state', yesno_values),
+        sa.Column('device_state_filter', sa.String(256)),
+        sa.Column('mailbox_state', yesno_values),
+        sa.Column('mailbox_state_filter', sa.String(256)),
+    )
+
+    op.create_index('ps_asterisk_publications_id', 'ps_asterisk_publications', ['id'])
+
+def downgrade():
+    op.drop_table('ps_outbound_publishes')
+    op.drop_table('ps_inbound_publications')
+    op.drop_table('ps_asterisk_publications')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/3772f8f828da_update_identify_by.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/3772f8f828da_update_identify_by.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/3772f8f828da_update_identify_by.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/3772f8f828da_update_identify_by.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,44 @@
+"""update_identify_by
+
+Revision ID: 3772f8f828da
+Revises: c7a44a5a0851
+Create Date: 2016-08-11 10:47:29.211063
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '3772f8f828da'
+down_revision = 'c7a44a5a0851'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def enum_update(table_name, column_name, enum_name, enum_values):
+    if op.get_context().bind.dialect.name != 'postgresql':
+        op.alter_column(table_name, column_name,
+                        type_=sa.Enum(*enum_values, name=enum_name))
+        return
+
+    # Postgres requires a few more steps
+    tmp = enum_name + '_tmp'
+
+    op.execute('ALTER TYPE ' + enum_name + ' RENAME TO ' + tmp)
+
+    updated = sa.Enum(*enum_values, name=enum_name)
+    updated.create(op.get_bind(), checkfirst=False)
+
+    op.execute('ALTER TABLE ' + table_name + ' ALTER COLUMN ' + column_name +
+               ' TYPE ' + enum_name + ' USING identify_by::text::' + enum_name)
+
+    op.execute('DROP TYPE ' + tmp)
+
+
+def upgrade():
+    enum_update('ps_endpoints', 'identify_by', 'pjsip_identify_by_values',
+                ['username', 'auth_username'])
+
+
+def downgrade():
+    enum_update('ps_endpoints', 'identify_by', 'pjsip_identify_by_values',
+                ['username'])
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/4468b4a91372_add_pjsip_asymmetric_rtp_codec.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/4468b4a91372_add_pjsip_asymmetric_rtp_codec.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/4468b4a91372_add_pjsip_asymmetric_rtp_codec.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/4468b4a91372_add_pjsip_asymmetric_rtp_codec.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,31 @@
+"""add pjsip asymmetric rtp codec
+
+Revision ID: 4468b4a91372
+Revises: a6ef36f1309
+Create Date: 2016-10-25 10:57:20.808815
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '4468b4a91372'
+down_revision = 'a6ef36f1309'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_endpoints', sa.Column('asymmetric_rtp_codec', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'asymmetric_rtp_codec')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/465e70e8c337_add_match_header_attribute_to_identify.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/465e70e8c337_add_match_header_attribute_to_identify.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/465e70e8c337_add_match_header_attribute_to_identify.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/465e70e8c337_add_match_header_attribute_to_identify.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,21 @@
+"""Add match_header attribute to identify
+
+Revision ID: 465e70e8c337
+Revises: 28ab27a7826d
+Create Date: 2017-03-14 08:13:53.986681
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '465e70e8c337'
+down_revision = '28ab27a7826d'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_endpoint_id_ips', sa.Column('match_header', sa.String(255)))
+
+def downgrade():
+    op.drop_column('ps_endpoint_id_ips', 'match_header')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/4a6c67fa9b7a_add_fax_detect_timeout_option.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/4a6c67fa9b7a_add_fax_detect_timeout_option.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/4a6c67fa9b7a_add_fax_detect_timeout_option.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/4a6c67fa9b7a_add_fax_detect_timeout_option.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,23 @@
+"""add fax_detect_timeout option
+
+Revision ID: 4a6c67fa9b7a
+Revises: 9deac0ae4717
+Create Date: 2016-07-18 18:20:44.249491
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '4a6c67fa9b7a'
+down_revision = '9deac0ae4717'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_endpoints', sa.Column('fax_detect_timeout', sa.Integer))
+
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'fax_detect_timeout')
+
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/4e2493ef32e6_add_contact_user_to_endpoint.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/4e2493ef32e6_add_contact_user_to_endpoint.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/4e2493ef32e6_add_contact_user_to_endpoint.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/4e2493ef32e6_add_contact_user_to_endpoint.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,22 @@
+"""Add contact_user to endpoint
+
+Revision ID: 4e2493ef32e6
+Revises: 3772f8f828da
+Create Date: 2016-08-16 14:19:58.918466
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '4e2493ef32e6'
+down_revision = '3772f8f828da'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_endpoints', sa.Column('contact_user', sa.String(80)))
+
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'contact_user')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/581a4264e537_adding_extensions.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/581a4264e537_adding_extensions.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/581a4264e537_adding_extensions.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/581a4264e537_adding_extensions.py	2017-07-12 13:12:08.000000000 +0200
@@ -31,20 +31,18 @@ down_revision = '43956d550a44'
 from alembic import op
 import sqlalchemy as sa
 
-
 def upgrade():
     op.create_table(
         'extensions',
         sa.Column('id', sa.BigInteger, primary_key=True, nullable=False,
                   unique=True, autoincrement=True),
-        sa.Column('context', sa.String(40), primary_key=True, nullable=False),
-        sa.Column('exten', sa.String(40), primary_key=True, nullable=False),
-        sa.Column('priority', sa.Integer, primary_key=True, nullable=False,
-                  autoincrement=True),
+        sa.Column('context', sa.String(40), nullable=False),
+        sa.Column('exten', sa.String(40), nullable=False),
+        sa.Column('priority', sa.Integer, nullable=False),
         sa.Column('app', sa.String(40), nullable=False),
         sa.Column('appdata', sa.String(256), nullable=False),
+        sa.UniqueConstraint('context', 'exten', 'priority')
     )
 
-
 def downgrade():
     op.drop_table('extensions')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/65eb22eb195_add_unidentified_request_options_to_.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/65eb22eb195_add_unidentified_request_options_to_.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/65eb22eb195_add_unidentified_request_options_to_.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/65eb22eb195_add_unidentified_request_options_to_.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,27 @@
+"""Add unidentified request options to global
+
+Revision ID: 65eb22eb195
+Revises: 8d478ab86e29
+Create Date: 2016-03-11 11:58:51.567959
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '65eb22eb195'
+down_revision = '8d478ab86e29'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_globals', sa.Column('unidentified_request_count', sa.Integer))
+    op.add_column('ps_globals', sa.Column('unidentified_request_period', sa.Integer))
+    op.add_column('ps_globals', sa.Column('unidentified_request_prune_interval', sa.Integer))
+    op.add_column('ps_globals', sa.Column('default_realm', sa.String(40)))
+
+def downgrade():
+    op.drop_column('ps_globals', 'unidentified_request_count')
+    op.drop_column('ps_globals', 'unidentified_request_period')
+    op.drop_column('ps_globals', 'unidentified_request_prune_interval')
+    op.drop_column('ps_globals', 'default_realm')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/6d8c104e6184_res_pjsip_add_contact_via_addr_and_.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/6d8c104e6184_res_pjsip_add_contact_via_addr_and_.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/6d8c104e6184_res_pjsip_add_contact_via_addr_and_.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/6d8c104e6184_res_pjsip_add_contact_via_addr_and_.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,25 @@
+"""res_pjsip: add contact via_addr and callid
+
+Revision ID: a845e4d8ade8
+Revises: bca7113d796f
+Create Date: 2016-05-19 15:51:33.410852
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'a845e4d8ade8'
+down_revision = 'bca7113d796f'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_contacts', sa.Column('via_addr', sa.String(40)))
+    op.add_column('ps_contacts', sa.Column('via_port', sa.Integer))
+    op.add_column('ps_contacts', sa.Column('call_id', sa.String(255)))
+
+def downgrade():
+    op.drop_column('ps_contacts', 'via_addr')
+    op.drop_column('ps_contacts', 'via_port')
+    op.drop_column('ps_contacts', 'call_id')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/81b01a191a46_pjsip_add_contact_reg_server.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/81b01a191a46_pjsip_add_contact_reg_server.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/81b01a191a46_pjsip_add_contact_reg_server.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/81b01a191a46_pjsip_add_contact_reg_server.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,23 @@
+"""pjsip: add contact reg_server
+
+Revision ID: 81b01a191a46
+Revises: 65eb22eb195
+Create Date: 2016-04-15 15:00:35.024525
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '81b01a191a46'
+down_revision = '65eb22eb195'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_contacts', sa.Column('reg_server', sa.String(20)))
+    op.create_unique_constraint('ps_contacts_uq', 'ps_contacts', ['id','reg_server'])
+
+def downgrade():
+    op.drop_constraint('ps_contacts_uq', 'ps_contacts', type_='unique')
+    op.drop_column('ps_contacts', 'reg_server')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/837aa67461fb_add_pjsip_endpoint_ip_access_control_.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/837aa67461fb_add_pjsip_endpoint_ip_access_control_.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/837aa67461fb_add_pjsip_endpoint_ip_access_control_.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/837aa67461fb_add_pjsip_endpoint_ip_access_control_.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+"""Add PJSIP Endpoint IP Access Control options
+
+Revision ID: bca7113d796f
+Revises: 6be31516058d
+Create Date: 2016-05-13 12:37:03.786359
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'bca7113d796f'
+down_revision = '6be31516058d'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_endpoints', sa.Column('deny', sa.String(95)))
+    op.add_column('ps_endpoints', sa.Column('permit', sa.String(95)))
+    op.add_column('ps_endpoints', sa.Column('acl', sa.String(40)))
+    op.add_column('ps_endpoints', sa.Column('contact_deny', sa.String(95)))
+    op.add_column('ps_endpoints', sa.Column('contact_permit', sa.String(95)))
+    op.add_column('ps_endpoints', sa.Column('contact_acl', sa.String(40)))
+
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'contact_acl')
+    op.drop_column('ps_endpoints', 'contact_permit')
+    op.drop_column('ps_endpoints', 'contact_deny')
+    op.drop_column('ps_endpoints', 'acl')
+    op.drop_column('ps_endpoints', 'permit')
+    op.drop_column('ps_endpoints', 'deny')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/837aa67461fb_ps_contacts_add_authenticate_qualify.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/837aa67461fb_ps_contacts_add_authenticate_qualify.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/837aa67461fb_ps_contacts_add_authenticate_qualify.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/837aa67461fb_ps_contacts_add_authenticate_qualify.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+"""ps_contacts add authenticate_qualify
+
+Revision ID: 6be31516058d
+Revises: 81b01a191a46
+Create Date: 2016-05-03 14:57:12.538179
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '6be31516058d'
+down_revision = '81b01a191a46'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_contacts', sa.Column('authenticate_qualify', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_contacts', 'authenticate_qualify')
+
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/86bb1efa278d_add_ps_endpoints_refer_blind_progress.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/86bb1efa278d_add_ps_endpoints_refer_blind_progress.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/86bb1efa278d_add_ps_endpoints_refer_blind_progress.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/86bb1efa278d_add_ps_endpoints_refer_blind_progress.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,30 @@
+"""add ps_endpoints.refer_blind_progress
+
+Revision ID: 86bb1efa278d
+Revises: 1d0e332c32af
+Create Date: 2017-05-08 16:52:36.615161
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '86bb1efa278d'
+down_revision = '1d0e332c32af'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_endpoints', sa.Column('refer_blind_progress', yesno_values))
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'refer_blind_progress')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/8d478ab86e29_pjsip_add_disable_multi_domain.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/8d478ab86e29_pjsip_add_disable_multi_domain.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/8d478ab86e29_pjsip_add_disable_multi_domain.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/8d478ab86e29_pjsip_add_disable_multi_domain.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,31 @@
+"""pjsip_add_disable_multi_domain
+
+Revision ID: 8d478ab86e29
+Revises: 1c688d9a003c
+Create Date: 2016-04-15 11:41:26.988997
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '8d478ab86e29'
+down_revision = '1c688d9a003c'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_globals', sa.Column('disable_multi_domain', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_globals', 'disable_multi_domain')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/8fce4c573e15_add_pjsip_allow_overlap.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/8fce4c573e15_add_pjsip_allow_overlap.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/8fce4c573e15_add_pjsip_allow_overlap.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/8fce4c573e15_add_pjsip_allow_overlap.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,31 @@
+"""add pjsip allow_overlap
+
+Revision ID: 8fce4c573e15
+Revises: f638dbe2eb23
+Create Date: 2017-03-21 15:14:27.612945
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '8fce4c573e15'
+down_revision = 'f638dbe2eb23'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_endpoints', sa.Column('allow_overlap', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'allow_overlap')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/9deac0ae4717_pjsip_add_subscribe_context.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/9deac0ae4717_pjsip_add_subscribe_context.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/9deac0ae4717_pjsip_add_subscribe_context.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/9deac0ae4717_pjsip_add_subscribe_context.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,21 @@
+"""pjsip_add_subscribe_context
+
+Revision ID: 9deac0ae4717
+Revises: ef7efc2d3964
+Create Date: 2016-07-04 12:11:28.117788
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = '9deac0ae4717'
+down_revision = 'ef7efc2d3964'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    op.add_column('ps_endpoints', sa.Column('subscribe_context', sa.String(40)))
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'subscribe_context')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/a6ef36f1309_ps_globals_add_ignore_uri_user_options.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/a6ef36f1309_ps_globals_add_ignore_uri_user_options.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/a6ef36f1309_ps_globals_add_ignore_uri_user_options.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/a6ef36f1309_ps_globals_add_ignore_uri_user_options.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+"""ps_globals add ignore_uri_user_options
+
+Revision ID: a6ef36f1309
+Revises: 4e2493ef32e6
+Create Date: 2016-08-31 12:24:22.368956
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'a6ef36f1309'
+down_revision = '4e2493ef32e6'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_globals', sa.Column('ignore_uri_user_options', yesno_values))
+
+
+def downgrade():
+    op.drop_column('ps_globals', 'ignore_uri_user_options')
+
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/c7a44a5a0851_pjsip_add_global_mwi_options.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/c7a44a5a0851_pjsip_add_global_mwi_options.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/c7a44a5a0851_pjsip_add_global_mwi_options.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/c7a44a5a0851_pjsip_add_global_mwi_options.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,35 @@
+"""pjsip: add global MWI options
+
+Revision ID: c7a44a5a0851
+Revises: 4a6c67fa9b7a
+Create Date: 2016-08-03 15:08:22.524727
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'c7a44a5a0851'
+down_revision = '4a6c67fa9b7a'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_globals', sa.Column('mwi_tps_queue_high', sa.Integer))
+    op.add_column('ps_globals', sa.Column('mwi_tps_queue_low', sa.Integer))
+    op.add_column('ps_globals', sa.Column('mwi_disable_initial_unsolicited', yesno_values))
+
+def downgrade():
+    op.drop_column('ps_globals', 'mwi_tps_queue_high')
+    op.drop_column('ps_globals', 'mwi_tps_queue_low')
+    op.drop_column('ps_globals', 'mwi_disable_initial_unsolicited')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/d7983954dd96_add_ps_endpoints_notify_early_inuse_.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/d7983954dd96_add_ps_endpoints_notify_early_inuse_.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/d7983954dd96_add_ps_endpoints_notify_early_inuse_.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/d7983954dd96_add_ps_endpoints_notify_early_inuse_.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,30 @@
+"""add ps_endpoints.notify_early_inuse_ringing
+
+Revision ID: d7983954dd96
+Revises: 86bb1efa278d
+Create Date: 2017-06-05 15:44:41.152280
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'd7983954dd96'
+down_revision = '86bb1efa278d'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_endpoints', sa.Column('notify_early_inuse_ringing', yesno_values))
+
+def downgrade():
+    op.drop_column('ps_endpoints', 'notify_early_inuse_ringing')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/ef7efc2d3964_ps_contacts_add_endpoint_and_modify_.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/ef7efc2d3964_ps_contacts_add_endpoint_and_modify_.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/ef7efc2d3964_ps_contacts_add_endpoint_and_modify_.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/ef7efc2d3964_ps_contacts_add_endpoint_and_modify_.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,33 @@
+"""ps_contacts add endpoint and modify expiration_time to bigint
+
+Revision ID: ef7efc2d3964
+Revises: a845e4d8ade8
+Create Date: 2016-06-02 18:18:46.231920
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'ef7efc2d3964'
+down_revision = 'a845e4d8ade8'
+
+from alembic import op
+import sqlalchemy as sa
+
+
+def upgrade():
+    context = op.get_context()
+
+    op.add_column('ps_contacts', sa.Column('endpoint', sa.String(40)))
+
+    if context.bind.dialect.name != 'postgresql':
+        op.alter_column('ps_contacts', 'expiration_time', type_=sa.BigInteger)
+    else:
+        op.execute('ALTER TABLE ps_contacts ALTER COLUMN expiration_time TYPE BIGINT USING expiration_time::bigint')
+
+    op.create_index('ps_contacts_qualifyfreq_exp', 'ps_contacts', ['qualify_frequency', 'expiration_time'])
+    op.create_index('ps_aors_qualifyfreq_contact', 'ps_aors', ['qualify_frequency', 'contact'])
+def downgrade():
+    op.drop_index('ps_aors_qualifyfreq_contact')
+    op.drop_index('ps_contacts_qualifyfreq_exp')
+    op.drop_column('ps_contacts', 'endpoint')
+    op.alter_column('ps_contacts', 'expiration_time', type_=sa.String(40))
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/config/versions/f638dbe2eb23_symmetric_transport.py asterisk-13.17.0/contrib/ast-db-manage/config/versions/f638dbe2eb23_symmetric_transport.py
--- asterisk-13.9.1/contrib/ast-db-manage/config/versions/f638dbe2eb23_symmetric_transport.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/config/versions/f638dbe2eb23_symmetric_transport.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+"""symmetric_transport
+
+Revision ID: f638dbe2eb23
+Revises: 15db7b91a97a
+Create Date: 2017-03-09 09:38:59.513479
+
+"""
+
+# revision identifiers, used by Alembic.
+revision = 'f638dbe2eb23'
+down_revision = '15db7b91a97a'
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects.postgresql import ENUM
+
+YESNO_NAME = 'yesno_values'
+YESNO_VALUES = ['yes', 'no']
+
+def upgrade():
+    ############################# Enums ##############################
+
+    # yesno_values have already been created, so use postgres enum object
+    # type to get around "already created" issue - works okay with mysql
+    yesno_values = ENUM(*YESNO_VALUES, name=YESNO_NAME, create_type=False)
+
+    op.add_column('ps_transports', sa.Column('symmetric_transport', yesno_values))
+    op.add_column('ps_subscription_persistence', sa.Column('contact_uri', sa.String(256)))
+
+def downgrade():
+    op.drop_column('ps_subscription_persistence', 'contact_uri')
+    op.drop_column('ps_transports', 'symmetric_transport')
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/env.py asterisk-13.17.0/contrib/ast-db-manage/env.py
--- asterisk-13.9.1/contrib/ast-db-manage/env.py	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/ast-db-manage/env.py	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,140 @@
+from __future__ import with_statement
+from alembic import context
+from alembic.script import ScriptDirectory
+from alembic.operations import Operations
+from sqlalchemy import engine_from_config, pool
+from logging.config import fileConfig
+import logging
+
+# this is the Alembic Config object, which provides
+# access to the values within the .ini file in use.
+config = context.config
+
+# Interpret the config file for Python logging.
+# This line sets up loggers basically.
+try:
+    fileConfig(config.config_file_name)
+except:
+    pass
+
+logger = logging.getLogger('alembic.runtime.setup')
+# add your model's MetaData object here
+# for 'autogenerate' support
+# from myapp import mymodel
+# target_metadata = mymodel.Base.metadata
+target_metadata = None
+
+# other values from the config, defined by the needs of env.py,
+# can be acquired:
+# my_important_option = config.get_main_option("my_important_option")
+# ... etc.
+
+def run_migrations_offline():
+    """Run migrations in 'offline' mode.
+
+    This configures the context with just a URL
+    and not an Engine, though an Engine is acceptable
+    here as well.  By skipping the Engine creation
+    we don't even need a DBAPI to be available.
+
+    Calls to context.execute() here emit the given string to the
+    script output.
+
+    """
+    url = config.get_main_option("sqlalchemy.url")
+    context.configure(url=url)
+
+    with context.begin_transaction():
+        context.run_migrations()
+
+def run_migrations_online():
+    """Run migrations in 'online' mode.
+
+    In this scenario we need to create an Engine
+    and associate a connection with the context.
+
+    """
+    engine = engine_from_config(
+                config.get_section(config.config_ini_section),
+                prefix='sqlalchemy.',
+                poolclass=pool.NullPool)
+
+    logger.info('Testing for an old alembic_version table.')
+
+    connection = engine.connect()
+    context.configure(
+                connection=connection,
+                target_metadata=target_metadata,
+                version_table='alembic_version'
+                )
+
+    script_location = config.get_main_option('script_location')
+    found = False
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    script = ScriptDirectory.from_config(config)
+    """ If there was an existing alembic_version table, we need to
+    check that it's current revision is in the history for the tree
+    we're working with.
+    """
+    for x in script.iterate_revisions('head', 'base'):
+        if x.revision == current_db_revision:
+            """ An alembic_versions table was found and it belongs to
+            this alembic tree
+            """
+            logger.info(
+                ('An old alembic_version table at revision %s was '
+                 'found for %s.  Renaming to alembic_version_%s.'),
+                        current_db_revision, script_location,
+                        script_location)
+            op = Operations(mc)
+            try:
+                with context.begin_transaction():
+                    op.rename_table(
+                        'alembic_version', 'alembic_version_%s'
+                        % script_location)
+                found = True
+            except:
+                logger.error(('Unable to rename alembic_version to '
+                             'alembic_version_%s.'),
+                             script_location)
+                connection.close()
+                return
+
+            break
+
+    if not found:
+        logger.info('Didn\'t find an old alembic_version table.')
+    logger.info('Trying alembic_version_%s.' % script_location)
+
+    """ We MAY have an alembic_version table that doesn't belong to
+    this tree but if we still don't have an alembic_version_<tree>
+    table, alembic will create it.
+    """
+    context.configure(
+                connection=connection,
+                target_metadata=target_metadata,
+                version_table='alembic_version_' + script_location
+                )
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    if current_db_revision:
+        logger.info(
+            'Using the alembic_version_%s table at revision %s.',
+            script_location, current_db_revision)
+    else:
+        logger.info('Creating new alembic_version_%s table.',
+                    script_location)
+
+    try:
+        with context.begin_transaction():
+            context.run_migrations()
+    finally:
+        connection.close()
+
+
+if context.is_offline_mode():
+    run_migrations_offline()
+else:
+    run_migrations_online()
+
diff -urpN asterisk-13.9.1/contrib/ast-db-manage/voicemail/env.py asterisk-13.17.0/contrib/ast-db-manage/voicemail/env.py
--- asterisk-13.9.1/contrib/ast-db-manage/voicemail/env.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/ast-db-manage/voicemail/env.py	2017-07-12 13:12:08.000000000 +0200
@@ -1,7 +1,10 @@
 from __future__ import with_statement
 from alembic import context
+from alembic.script import ScriptDirectory
+from alembic.operations import Operations
 from sqlalchemy import engine_from_config, pool
 from logging.config import fileConfig
+import logging
 
 # this is the Alembic Config object, which provides
 # access to the values within the .ini file in use.
@@ -14,6 +17,7 @@ try:
 except:
     pass
 
+logger = logging.getLogger('alembic.runtime.setup')
 # add your model's MetaData object here
 # for 'autogenerate' support
 # from myapp import mymodel
@@ -55,11 +59,72 @@ def run_migrations_online():
                 prefix='sqlalchemy.',
                 poolclass=pool.NullPool)
 
+    logger.info('Testing for an old alembic_version table.')
+
     connection = engine.connect()
     context.configure(
                 connection=connection,
-                target_metadata=target_metadata
+                target_metadata=target_metadata,
+                version_table='alembic_version'
+                )
+
+    script_location = config.get_main_option('script_location')
+    found = False
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    script = ScriptDirectory.from_config(config)
+    """ If there was an existing alembic_version table, we need to
+    check that it's current revision is in the history for the tree
+    we're working with.
+    """
+    for x in script.iterate_revisions('head', 'base'):
+        if x.revision == current_db_revision:
+            """ An alembic_versions table was found and it belongs to
+            this alembic tree
+            """
+            logger.info(
+                ('An old alembic_version table at revision %s was '
+                 'found for %s.  Renaming to alembic_version_%s.'),
+                        current_db_revision, script_location,
+                        script_location)
+            op = Operations(mc)
+            try:
+                with context.begin_transaction():
+                    op.rename_table(
+                        'alembic_version', 'alembic_version_%s'
+                        % script_location)
+                found = True
+            except:
+                logger.error(('Unable to rename alembic_version to '
+                             'alembic_version_%s.'),
+                             script_location)
+                connection.close()
+                return
+
+            break
+
+    if not found:
+        logger.info('Didn\'t find an old alembic_version table.')
+    logger.info('Trying alembic_version_%s.' % script_location)
+
+    """ We MAY have an alembic_version table that doesn't belong to
+    this tree but if we still don't have an alembic_version_<tree>
+    table, alembic will create it.
+    """
+    context.configure(
+                connection=connection,
+                target_metadata=target_metadata,
+                version_table='alembic_version_' + script_location
                 )
+    mc = context.get_context()
+    current_db_revision = mc.get_current_revision()
+    if current_db_revision:
+        logger.info(
+            'Using the alembic_version_%s table at revision %s.',
+            script_location, current_db_revision)
+    else:
+        logger.info('Creating new alembic_version_%s table.',
+                    script_location)
 
     try:
         with context.begin_transaction():
@@ -67,6 +132,7 @@ def run_migrations_online():
     finally:
         connection.close()
 
+
 if context.is_offline_mode():
     run_migrations_offline()
 else:
diff -urpN asterisk-13.9.1/contrib/realtime/mssql/mssql_config.sql asterisk-13.17.0/contrib/realtime/mssql/mssql_config.sql
--- asterisk-13.9.1/contrib/realtime/mssql/mssql_config.sql	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/realtime/mssql/mssql_config.sql	2017-07-12 13:12:08.000000000 +0200
@@ -557,7 +557,8 @@ CREATE TABLE extensions (
     priority INTEGER NOT NULL, 
     app VARCHAR(40) NOT NULL, 
     appdata VARCHAR(256) NOT NULL, 
-    PRIMARY KEY (id, context, exten, priority), 
+    PRIMARY KEY (id), 
+    UNIQUE (context, exten, priority), 
     UNIQUE (id)
 );
 
@@ -1322,6 +1323,436 @@ UPDATE alembic_version SET version_num='
 
 GO
 
+-- Running upgrade 1c688d9a003c -> 8d478ab86e29
+
+ALTER TABLE ps_globals ADD disable_multi_domain VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD CONSTRAINT yesno_values CHECK (disable_multi_domain IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='8d478ab86e29' WHERE alembic_version.version_num = '1c688d9a003c';
+
+GO
+
+-- Running upgrade 8d478ab86e29 -> 65eb22eb195
+
+ALTER TABLE ps_globals ADD unidentified_request_count INTEGER NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD unidentified_request_period INTEGER NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD unidentified_request_prune_interval INTEGER NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD default_realm VARCHAR(40) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='65eb22eb195' WHERE alembic_version.version_num = '8d478ab86e29';
+
+GO
+
+-- Running upgrade 65eb22eb195 -> 81b01a191a46
+
+ALTER TABLE ps_contacts ADD reg_server VARCHAR(20) NULL;
+
+GO
+
+ALTER TABLE ps_contacts ADD CONSTRAINT ps_contacts_uq UNIQUE (id, reg_server);
+
+GO
+
+UPDATE alembic_version SET version_num='81b01a191a46' WHERE alembic_version.version_num = '65eb22eb195';
+
+GO
+
+-- Running upgrade 81b01a191a46 -> 6be31516058d
+
+ALTER TABLE ps_contacts ADD authenticate_qualify VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_contacts ADD CONSTRAINT yesno_values CHECK (authenticate_qualify IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='6be31516058d' WHERE alembic_version.version_num = '81b01a191a46';
+
+GO
+
+-- Running upgrade 6be31516058d -> bca7113d796f
+
+ALTER TABLE ps_endpoints ADD [deny] VARCHAR(95) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD permit VARCHAR(95) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD acl VARCHAR(40) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD contact_deny VARCHAR(95) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD contact_permit VARCHAR(95) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD contact_acl VARCHAR(40) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='bca7113d796f' WHERE alembic_version.version_num = '6be31516058d';
+
+GO
+
+-- Running upgrade bca7113d796f -> a845e4d8ade8
+
+ALTER TABLE ps_contacts ADD via_addr VARCHAR(40) NULL;
+
+GO
+
+ALTER TABLE ps_contacts ADD via_port INTEGER NULL;
+
+GO
+
+ALTER TABLE ps_contacts ADD call_id VARCHAR(255) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='a845e4d8ade8' WHERE alembic_version.version_num = 'bca7113d796f';
+
+GO
+
+-- Running upgrade a845e4d8ade8 -> ef7efc2d3964
+
+ALTER TABLE ps_contacts ADD endpoint VARCHAR(40) NULL;
+
+GO
+
+ALTER TABLE ps_contacts ALTER COLUMN expiration_time BIGINT;
+
+GO
+
+CREATE INDEX ps_contacts_qualifyfreq_exp ON ps_contacts (qualify_frequency, expiration_time);
+
+GO
+
+CREATE INDEX ps_aors_qualifyfreq_contact ON ps_aors (qualify_frequency, contact);
+
+GO
+
+UPDATE alembic_version SET version_num='ef7efc2d3964' WHERE alembic_version.version_num = 'a845e4d8ade8';
+
+GO
+
+-- Running upgrade ef7efc2d3964 -> 9deac0ae4717
+
+ALTER TABLE ps_endpoints ADD subscribe_context VARCHAR(40) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='9deac0ae4717' WHERE alembic_version.version_num = 'ef7efc2d3964';
+
+GO
+
+-- Running upgrade 9deac0ae4717 -> 4a6c67fa9b7a
+
+ALTER TABLE ps_endpoints ADD fax_detect_timeout INTEGER NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='4a6c67fa9b7a' WHERE alembic_version.version_num = '9deac0ae4717';
+
+GO
+
+-- Running upgrade 4a6c67fa9b7a -> c7a44a5a0851
+
+ALTER TABLE ps_globals ADD mwi_tps_queue_high INTEGER NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD mwi_tps_queue_low INTEGER NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD mwi_disable_initial_unsolicited VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD CONSTRAINT yesno_values CHECK (mwi_disable_initial_unsolicited IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='c7a44a5a0851' WHERE alembic_version.version_num = '4a6c67fa9b7a';
+
+GO
+
+-- Running upgrade c7a44a5a0851 -> 3772f8f828da
+
+ALTER TABLE ps_endpoints ALTER COLUMN identify_by VARCHAR(13);
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT pjsip_identify_by_values CHECK (identify_by IN ('username', 'auth_username'));
+
+GO
+
+UPDATE alembic_version SET version_num='3772f8f828da' WHERE alembic_version.version_num = 'c7a44a5a0851';
+
+GO
+
+-- Running upgrade 3772f8f828da -> 4e2493ef32e6
+
+ALTER TABLE ps_endpoints ADD contact_user VARCHAR(80) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='4e2493ef32e6' WHERE alembic_version.version_num = '3772f8f828da';
+
+GO
+
+-- Running upgrade 4e2493ef32e6 -> a6ef36f1309
+
+ALTER TABLE ps_globals ADD ignore_uri_user_options VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_globals ADD CONSTRAINT yesno_values CHECK (ignore_uri_user_options IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='a6ef36f1309' WHERE alembic_version.version_num = '4e2493ef32e6';
+
+GO
+
+-- Running upgrade a6ef36f1309 -> 4468b4a91372
+
+ALTER TABLE ps_endpoints ADD asymmetric_rtp_codec VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (asymmetric_rtp_codec IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='4468b4a91372' WHERE alembic_version.version_num = 'a6ef36f1309';
+
+GO
+
+-- Running upgrade 4468b4a91372 -> 28ab27a7826d
+
+ALTER TABLE ps_endpoint_id_ips ADD srv_lookups VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_endpoint_id_ips ADD CONSTRAINT yesno_values CHECK (srv_lookups IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='28ab27a7826d' WHERE alembic_version.version_num = '4468b4a91372';
+
+GO
+
+-- Running upgrade 28ab27a7826d -> 465e70e8c337
+
+ALTER TABLE ps_endpoint_id_ips ADD match_header VARCHAR(255) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='465e70e8c337' WHERE alembic_version.version_num = '28ab27a7826d';
+
+GO
+
+-- Running upgrade 465e70e8c337 -> 15db7b91a97a
+
+ALTER TABLE ps_endpoints ADD rtcp_mux VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (rtcp_mux IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='15db7b91a97a' WHERE alembic_version.version_num = '465e70e8c337';
+
+GO
+
+-- Running upgrade 15db7b91a97a -> f638dbe2eb23
+
+ALTER TABLE ps_transports ADD symmetric_transport VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_transports ADD CONSTRAINT yesno_values CHECK (symmetric_transport IN ('yes', 'no'));
+
+GO
+
+ALTER TABLE ps_subscription_persistence ADD contact_uri VARCHAR(256) NULL;
+
+GO
+
+UPDATE alembic_version SET version_num='f638dbe2eb23' WHERE alembic_version.version_num = '15db7b91a97a';
+
+GO
+
+-- Running upgrade f638dbe2eb23 -> 8fce4c573e15
+
+ALTER TABLE ps_endpoints ADD allow_overlap VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (allow_overlap IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='8fce4c573e15' WHERE alembic_version.version_num = 'f638dbe2eb23';
+
+GO
+
+-- Running upgrade 8fce4c573e15 -> 2da192dbbc65
+
+CREATE TABLE ps_outbound_publishes (
+    id VARCHAR(40) NOT NULL, 
+    expiration INTEGER NULL, 
+    outbound_auth VARCHAR(40) NULL, 
+    outbound_proxy VARCHAR(256) NULL, 
+    server_uri VARCHAR(256) NULL, 
+    from_uri VARCHAR(256) NULL, 
+    to_uri VARCHAR(256) NULL, 
+    event VARCHAR(40) NULL, 
+    max_auth_attempts INTEGER NULL, 
+    transport VARCHAR(40) NULL, 
+    multi_user VARCHAR(3) NULL, 
+    [@body] VARCHAR(40) NULL, 
+    [@context] VARCHAR(256) NULL, 
+    [@exten] VARCHAR(256) NULL, 
+    UNIQUE (id), 
+    CONSTRAINT yesno_values CHECK (multi_user IN ('yes', 'no'))
+);
+
+GO
+
+CREATE INDEX ps_outbound_publishes_id ON ps_outbound_publishes (id);
+
+GO
+
+CREATE TABLE ps_inbound_publications (
+    id VARCHAR(40) NOT NULL, 
+    endpoint VARCHAR(40) NULL, 
+    [event_asterisk-devicestate] VARCHAR(40) NULL, 
+    [event_asterisk-mwi] VARCHAR(40) NULL, 
+    UNIQUE (id)
+);
+
+GO
+
+CREATE INDEX ps_inbound_publications_id ON ps_inbound_publications (id);
+
+GO
+
+CREATE TABLE ps_asterisk_publications (
+    id VARCHAR(40) NOT NULL, 
+    devicestate_publish VARCHAR(40) NULL, 
+    mailboxstate_publish VARCHAR(40) NULL, 
+    device_state VARCHAR(3) NULL, 
+    device_state_filter VARCHAR(256) NULL, 
+    mailbox_state VARCHAR(3) NULL, 
+    mailbox_state_filter VARCHAR(256) NULL, 
+    UNIQUE (id), 
+    CONSTRAINT yesno_values CHECK (device_state IN ('yes', 'no')), 
+    CONSTRAINT yesno_values CHECK (mailbox_state IN ('yes', 'no'))
+);
+
+GO
+
+CREATE INDEX ps_asterisk_publications_id ON ps_asterisk_publications (id);
+
+GO
+
+UPDATE alembic_version SET version_num='2da192dbbc65' WHERE alembic_version.version_num = '8fce4c573e15';
+
+GO
+
+-- Running upgrade 2da192dbbc65 -> 1d0e332c32af
+
+CREATE TABLE ps_resource_list (
+    id VARCHAR(40) NOT NULL, 
+    list_item VARCHAR(2048) NULL, 
+    event VARCHAR(40) NULL, 
+    full_state VARCHAR(3) NULL, 
+    notification_batch_interval INTEGER NULL, 
+    UNIQUE (id), 
+    CONSTRAINT yesno_values CHECK (full_state IN ('yes', 'no'))
+);
+
+GO
+
+CREATE INDEX ps_resource_list_id ON ps_resource_list (id);
+
+GO
+
+UPDATE alembic_version SET version_num='1d0e332c32af' WHERE alembic_version.version_num = '2da192dbbc65';
+
+GO
+
+-- Running upgrade 1d0e332c32af -> 86bb1efa278d
+
+ALTER TABLE ps_endpoints ADD refer_blind_progress VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (refer_blind_progress IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='86bb1efa278d' WHERE alembic_version.version_num = '1d0e332c32af';
+
+GO
+
+-- Running upgrade 86bb1efa278d -> d7983954dd96
+
+ALTER TABLE ps_endpoints ADD notify_early_inuse_ringing VARCHAR(3) NULL;
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (notify_early_inuse_ringing IN ('yes', 'no'));
+
+GO
+
+UPDATE alembic_version SET version_num='d7983954dd96' WHERE alembic_version.version_num = '86bb1efa278d';
+
+GO
+
+-- Running upgrade d7983954dd96 -> 164abbd708c
+
+ALTER TABLE ps_endpoints DROP CONSTRAINT pjsip_dtmf_mode_values_v2;
+
+GO
+
+ALTER TABLE ps_endpoints ALTER COLUMN dtmf_mode VARCHAR(9);
+
+GO
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT pjsip_dtmf_mode_values_v3 CHECK (dtmf_mode IN ('rfc4733', 'inband', 'info', 'auto', 'auto_info'));
+
+GO
+
+UPDATE alembic_version SET version_num='164abbd708c' WHERE alembic_version.version_num = 'd7983954dd96';
+
+GO
+
 COMMIT;
 
 GO
diff -urpN asterisk-13.9.1/contrib/realtime/mysql/mysql_config.sql asterisk-13.17.0/contrib/realtime/mysql/mysql_config.sql
--- asterisk-13.9.1/contrib/realtime/mysql/mysql_config.sql	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/realtime/mysql/mysql_config.sql	2017-07-12 13:12:08.000000000 +0200
@@ -398,7 +398,8 @@ CREATE TABLE extensions (
     priority INTEGER NOT NULL, 
     app VARCHAR(40) NOT NULL, 
     appdata VARCHAR(256) NOT NULL, 
-    PRIMARY KEY (id, context, exten, priority), 
+    PRIMARY KEY (id), 
+    UNIQUE (context, exten, priority), 
     UNIQUE (id)
 );
 
@@ -839,3 +840,231 @@ ALTER TABLE ps_endpoints ADD COLUMN mwi_
 
 UPDATE alembic_version SET version_num='1c688d9a003c' WHERE alembic_version.version_num = '5813202e92be';
 
+-- Running upgrade 1c688d9a003c -> 8d478ab86e29
+
+ALTER TABLE ps_globals ADD COLUMN disable_multi_domain ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='8d478ab86e29' WHERE alembic_version.version_num = '1c688d9a003c';
+
+-- Running upgrade 8d478ab86e29 -> 65eb22eb195
+
+ALTER TABLE ps_globals ADD COLUMN unidentified_request_count INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN unidentified_request_period INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN unidentified_request_prune_interval INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN default_realm VARCHAR(40);
+
+UPDATE alembic_version SET version_num='65eb22eb195' WHERE alembic_version.version_num = '8d478ab86e29';
+
+-- Running upgrade 65eb22eb195 -> 81b01a191a46
+
+ALTER TABLE ps_contacts ADD COLUMN reg_server VARCHAR(20);
+
+ALTER TABLE ps_contacts ADD CONSTRAINT ps_contacts_uq UNIQUE (id, reg_server);
+
+UPDATE alembic_version SET version_num='81b01a191a46' WHERE alembic_version.version_num = '65eb22eb195';
+
+-- Running upgrade 81b01a191a46 -> 6be31516058d
+
+ALTER TABLE ps_contacts ADD COLUMN authenticate_qualify ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='6be31516058d' WHERE alembic_version.version_num = '81b01a191a46';
+
+-- Running upgrade 6be31516058d -> bca7113d796f
+
+ALTER TABLE ps_endpoints ADD COLUMN deny VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN permit VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN acl VARCHAR(40);
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_deny VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_permit VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_acl VARCHAR(40);
+
+UPDATE alembic_version SET version_num='bca7113d796f' WHERE alembic_version.version_num = '6be31516058d';
+
+-- Running upgrade bca7113d796f -> a845e4d8ade8
+
+ALTER TABLE ps_contacts ADD COLUMN via_addr VARCHAR(40);
+
+ALTER TABLE ps_contacts ADD COLUMN via_port INTEGER;
+
+ALTER TABLE ps_contacts ADD COLUMN call_id VARCHAR(255);
+
+UPDATE alembic_version SET version_num='a845e4d8ade8' WHERE alembic_version.version_num = 'bca7113d796f';
+
+-- Running upgrade a845e4d8ade8 -> ef7efc2d3964
+
+ALTER TABLE ps_contacts ADD COLUMN endpoint VARCHAR(40);
+
+ALTER TABLE ps_contacts MODIFY expiration_time BIGINT NULL;
+
+CREATE INDEX ps_contacts_qualifyfreq_exp ON ps_contacts (qualify_frequency, expiration_time);
+
+CREATE INDEX ps_aors_qualifyfreq_contact ON ps_aors (qualify_frequency, contact);
+
+UPDATE alembic_version SET version_num='ef7efc2d3964' WHERE alembic_version.version_num = 'a845e4d8ade8';
+
+-- Running upgrade ef7efc2d3964 -> 9deac0ae4717
+
+ALTER TABLE ps_endpoints ADD COLUMN subscribe_context VARCHAR(40);
+
+UPDATE alembic_version SET version_num='9deac0ae4717' WHERE alembic_version.version_num = 'ef7efc2d3964';
+
+-- Running upgrade 9deac0ae4717 -> 4a6c67fa9b7a
+
+ALTER TABLE ps_endpoints ADD COLUMN fax_detect_timeout INTEGER;
+
+UPDATE alembic_version SET version_num='4a6c67fa9b7a' WHERE alembic_version.version_num = '9deac0ae4717';
+
+-- Running upgrade 4a6c67fa9b7a -> c7a44a5a0851
+
+ALTER TABLE ps_globals ADD COLUMN mwi_tps_queue_high INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN mwi_tps_queue_low INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN mwi_disable_initial_unsolicited ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='c7a44a5a0851' WHERE alembic_version.version_num = '4a6c67fa9b7a';
+
+-- Running upgrade c7a44a5a0851 -> 3772f8f828da
+
+ALTER TABLE ps_endpoints MODIFY identify_by ENUM('username','auth_username') NULL;
+
+UPDATE alembic_version SET version_num='3772f8f828da' WHERE alembic_version.version_num = 'c7a44a5a0851';
+
+-- Running upgrade 3772f8f828da -> 4e2493ef32e6
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_user VARCHAR(80);
+
+UPDATE alembic_version SET version_num='4e2493ef32e6' WHERE alembic_version.version_num = '3772f8f828da';
+
+-- Running upgrade 4e2493ef32e6 -> a6ef36f1309
+
+ALTER TABLE ps_globals ADD COLUMN ignore_uri_user_options ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='a6ef36f1309' WHERE alembic_version.version_num = '4e2493ef32e6';
+
+-- Running upgrade a6ef36f1309 -> 4468b4a91372
+
+ALTER TABLE ps_endpoints ADD COLUMN asymmetric_rtp_codec ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='4468b4a91372' WHERE alembic_version.version_num = 'a6ef36f1309';
+
+-- Running upgrade 4468b4a91372 -> 28ab27a7826d
+
+ALTER TABLE ps_endpoint_id_ips ADD COLUMN srv_lookups ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='28ab27a7826d' WHERE alembic_version.version_num = '4468b4a91372';
+
+-- Running upgrade 28ab27a7826d -> 465e70e8c337
+
+ALTER TABLE ps_endpoint_id_ips ADD COLUMN match_header VARCHAR(255);
+
+UPDATE alembic_version SET version_num='465e70e8c337' WHERE alembic_version.version_num = '28ab27a7826d';
+
+-- Running upgrade 465e70e8c337 -> 15db7b91a97a
+
+ALTER TABLE ps_endpoints ADD COLUMN rtcp_mux ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='15db7b91a97a' WHERE alembic_version.version_num = '465e70e8c337';
+
+-- Running upgrade 15db7b91a97a -> f638dbe2eb23
+
+ALTER TABLE ps_transports ADD COLUMN symmetric_transport ENUM('yes','no');
+
+ALTER TABLE ps_subscription_persistence ADD COLUMN contact_uri VARCHAR(256);
+
+UPDATE alembic_version SET version_num='f638dbe2eb23' WHERE alembic_version.version_num = '15db7b91a97a';
+
+-- Running upgrade f638dbe2eb23 -> 8fce4c573e15
+
+ALTER TABLE ps_endpoints ADD COLUMN allow_overlap ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='8fce4c573e15' WHERE alembic_version.version_num = 'f638dbe2eb23';
+
+-- Running upgrade 8fce4c573e15 -> 2da192dbbc65
+
+CREATE TABLE ps_outbound_publishes (
+    id VARCHAR(40) NOT NULL, 
+    expiration INTEGER, 
+    outbound_auth VARCHAR(40), 
+    outbound_proxy VARCHAR(256), 
+    server_uri VARCHAR(256), 
+    from_uri VARCHAR(256), 
+    to_uri VARCHAR(256), 
+    event VARCHAR(40), 
+    max_auth_attempts INTEGER, 
+    transport VARCHAR(40), 
+    multi_user ENUM('yes','no'), 
+    `@body` VARCHAR(40), 
+    `@context` VARCHAR(256), 
+    `@exten` VARCHAR(256), 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_outbound_publishes_id ON ps_outbound_publishes (id);
+
+CREATE TABLE ps_inbound_publications (
+    id VARCHAR(40) NOT NULL, 
+    endpoint VARCHAR(40), 
+    `event_asterisk-devicestate` VARCHAR(40), 
+    `event_asterisk-mwi` VARCHAR(40), 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_inbound_publications_id ON ps_inbound_publications (id);
+
+CREATE TABLE ps_asterisk_publications (
+    id VARCHAR(40) NOT NULL, 
+    devicestate_publish VARCHAR(40), 
+    mailboxstate_publish VARCHAR(40), 
+    device_state ENUM('yes','no'), 
+    device_state_filter VARCHAR(256), 
+    mailbox_state ENUM('yes','no'), 
+    mailbox_state_filter VARCHAR(256), 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_asterisk_publications_id ON ps_asterisk_publications (id);
+
+UPDATE alembic_version SET version_num='2da192dbbc65' WHERE alembic_version.version_num = '8fce4c573e15';
+
+-- Running upgrade 2da192dbbc65 -> 1d0e332c32af
+
+CREATE TABLE ps_resource_list (
+    id VARCHAR(40) NOT NULL, 
+    list_item VARCHAR(2048), 
+    event VARCHAR(40), 
+    full_state ENUM('yes','no'), 
+    notification_batch_interval INTEGER, 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_resource_list_id ON ps_resource_list (id);
+
+UPDATE alembic_version SET version_num='1d0e332c32af' WHERE alembic_version.version_num = '2da192dbbc65';
+
+-- Running upgrade 1d0e332c32af -> 86bb1efa278d
+
+ALTER TABLE ps_endpoints ADD COLUMN refer_blind_progress ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='86bb1efa278d' WHERE alembic_version.version_num = '1d0e332c32af';
+
+-- Running upgrade 86bb1efa278d -> d7983954dd96
+
+ALTER TABLE ps_endpoints ADD COLUMN notify_early_inuse_ringing ENUM('yes','no');
+
+UPDATE alembic_version SET version_num='d7983954dd96' WHERE alembic_version.version_num = '86bb1efa278d';
+
+-- Running upgrade d7983954dd96 -> 164abbd708c
+
+ALTER TABLE ps_endpoints MODIFY dtmf_mode ENUM('rfc4733','inband','info','auto','auto_info') NULL;
+
+UPDATE alembic_version SET version_num='164abbd708c' WHERE alembic_version.version_num = 'd7983954dd96';
+
diff -urpN asterisk-13.9.1/contrib/realtime/oracle/oracle_config.sql asterisk-13.17.0/contrib/realtime/oracle/oracle_config.sql
--- asterisk-13.9.1/contrib/realtime/oracle/oracle_config.sql	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/realtime/oracle/oracle_config.sql	2017-07-12 13:12:08.000000000 +0200
@@ -555,7 +555,8 @@ CREATE TABLE extensions (
     priority INTEGER NOT NULL, 
     app VARCHAR2(40 CHAR) NOT NULL, 
     appdata VARCHAR2(256 CHAR) NOT NULL, 
-    PRIMARY KEY (id, context, exten, priority), 
+    PRIMARY KEY (id), 
+    UNIQUE (context, exten, priority), 
     UNIQUE (id)
 )
 
@@ -1320,3 +1321,433 @@ UPDATE alembic_version SET version_num='
 
 /
 
+-- Running upgrade 1c688d9a003c -> 8d478ab86e29
+
+ALTER TABLE ps_globals ADD disable_multi_domain VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_globals ADD CONSTRAINT yesno_values CHECK (disable_multi_domain IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='8d478ab86e29' WHERE alembic_version.version_num = '1c688d9a003c'
+
+/
+
+-- Running upgrade 8d478ab86e29 -> 65eb22eb195
+
+ALTER TABLE ps_globals ADD unidentified_request_count INTEGER
+
+/
+
+ALTER TABLE ps_globals ADD unidentified_request_period INTEGER
+
+/
+
+ALTER TABLE ps_globals ADD unidentified_request_prune_interval INTEGER
+
+/
+
+ALTER TABLE ps_globals ADD default_realm VARCHAR2(40 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='65eb22eb195' WHERE alembic_version.version_num = '8d478ab86e29'
+
+/
+
+-- Running upgrade 65eb22eb195 -> 81b01a191a46
+
+ALTER TABLE ps_contacts ADD reg_server VARCHAR2(20 CHAR)
+
+/
+
+ALTER TABLE ps_contacts ADD CONSTRAINT ps_contacts_uq UNIQUE (id, reg_server)
+
+/
+
+UPDATE alembic_version SET version_num='81b01a191a46' WHERE alembic_version.version_num = '65eb22eb195'
+
+/
+
+-- Running upgrade 81b01a191a46 -> 6be31516058d
+
+ALTER TABLE ps_contacts ADD authenticate_qualify VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_contacts ADD CONSTRAINT yesno_values CHECK (authenticate_qualify IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='6be31516058d' WHERE alembic_version.version_num = '81b01a191a46'
+
+/
+
+-- Running upgrade 6be31516058d -> bca7113d796f
+
+ALTER TABLE ps_endpoints ADD deny VARCHAR2(95 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD permit VARCHAR2(95 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD acl VARCHAR2(40 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD contact_deny VARCHAR2(95 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD contact_permit VARCHAR2(95 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD contact_acl VARCHAR2(40 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='bca7113d796f' WHERE alembic_version.version_num = '6be31516058d'
+
+/
+
+-- Running upgrade bca7113d796f -> a845e4d8ade8
+
+ALTER TABLE ps_contacts ADD via_addr VARCHAR2(40 CHAR)
+
+/
+
+ALTER TABLE ps_contacts ADD via_port INTEGER
+
+/
+
+ALTER TABLE ps_contacts ADD call_id VARCHAR2(255 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='a845e4d8ade8' WHERE alembic_version.version_num = 'bca7113d796f'
+
+/
+
+-- Running upgrade a845e4d8ade8 -> ef7efc2d3964
+
+ALTER TABLE ps_contacts ADD endpoint VARCHAR2(40 CHAR)
+
+/
+
+ALTER TABLE ps_contacts MODIFY expiration_time NUMBER(19)
+
+/
+
+CREATE INDEX ps_contacts_qualifyfreq_exp ON ps_contacts (qualify_frequency, expiration_time)
+
+/
+
+CREATE INDEX ps_aors_qualifyfreq_contact ON ps_aors (qualify_frequency, contact)
+
+/
+
+UPDATE alembic_version SET version_num='ef7efc2d3964' WHERE alembic_version.version_num = 'a845e4d8ade8'
+
+/
+
+-- Running upgrade ef7efc2d3964 -> 9deac0ae4717
+
+ALTER TABLE ps_endpoints ADD subscribe_context VARCHAR2(40 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='9deac0ae4717' WHERE alembic_version.version_num = 'ef7efc2d3964'
+
+/
+
+-- Running upgrade 9deac0ae4717 -> 4a6c67fa9b7a
+
+ALTER TABLE ps_endpoints ADD fax_detect_timeout INTEGER
+
+/
+
+UPDATE alembic_version SET version_num='4a6c67fa9b7a' WHERE alembic_version.version_num = '9deac0ae4717'
+
+/
+
+-- Running upgrade 4a6c67fa9b7a -> c7a44a5a0851
+
+ALTER TABLE ps_globals ADD mwi_tps_queue_high INTEGER
+
+/
+
+ALTER TABLE ps_globals ADD mwi_tps_queue_low INTEGER
+
+/
+
+ALTER TABLE ps_globals ADD mwi_disable_initial_unsolicited VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_globals ADD CONSTRAINT yesno_values CHECK (mwi_disable_initial_unsolicited IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='c7a44a5a0851' WHERE alembic_version.version_num = '4a6c67fa9b7a'
+
+/
+
+-- Running upgrade c7a44a5a0851 -> 3772f8f828da
+
+ALTER TABLE ps_endpoints MODIFY identify_by VARCHAR(13 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT pjsip_identify_by_values CHECK (identify_by IN ('username', 'auth_username'))
+
+/
+
+UPDATE alembic_version SET version_num='3772f8f828da' WHERE alembic_version.version_num = 'c7a44a5a0851'
+
+/
+
+-- Running upgrade 3772f8f828da -> 4e2493ef32e6
+
+ALTER TABLE ps_endpoints ADD contact_user VARCHAR2(80 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='4e2493ef32e6' WHERE alembic_version.version_num = '3772f8f828da'
+
+/
+
+-- Running upgrade 4e2493ef32e6 -> a6ef36f1309
+
+ALTER TABLE ps_globals ADD ignore_uri_user_options VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_globals ADD CONSTRAINT yesno_values CHECK (ignore_uri_user_options IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='a6ef36f1309' WHERE alembic_version.version_num = '4e2493ef32e6'
+
+/
+
+-- Running upgrade a6ef36f1309 -> 4468b4a91372
+
+ALTER TABLE ps_endpoints ADD asymmetric_rtp_codec VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (asymmetric_rtp_codec IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='4468b4a91372' WHERE alembic_version.version_num = 'a6ef36f1309'
+
+/
+
+-- Running upgrade 4468b4a91372 -> 28ab27a7826d
+
+ALTER TABLE ps_endpoint_id_ips ADD srv_lookups VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_endpoint_id_ips ADD CONSTRAINT yesno_values CHECK (srv_lookups IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='28ab27a7826d' WHERE alembic_version.version_num = '4468b4a91372'
+
+/
+
+-- Running upgrade 28ab27a7826d -> 465e70e8c337
+
+ALTER TABLE ps_endpoint_id_ips ADD match_header VARCHAR2(255 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='465e70e8c337' WHERE alembic_version.version_num = '28ab27a7826d'
+
+/
+
+-- Running upgrade 465e70e8c337 -> 15db7b91a97a
+
+ALTER TABLE ps_endpoints ADD rtcp_mux VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (rtcp_mux IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='15db7b91a97a' WHERE alembic_version.version_num = '465e70e8c337'
+
+/
+
+-- Running upgrade 15db7b91a97a -> f638dbe2eb23
+
+ALTER TABLE ps_transports ADD symmetric_transport VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_transports ADD CONSTRAINT yesno_values CHECK (symmetric_transport IN ('yes', 'no'))
+
+/
+
+ALTER TABLE ps_subscription_persistence ADD contact_uri VARCHAR2(256 CHAR)
+
+/
+
+UPDATE alembic_version SET version_num='f638dbe2eb23' WHERE alembic_version.version_num = '15db7b91a97a'
+
+/
+
+-- Running upgrade f638dbe2eb23 -> 8fce4c573e15
+
+ALTER TABLE ps_endpoints ADD allow_overlap VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (allow_overlap IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='8fce4c573e15' WHERE alembic_version.version_num = 'f638dbe2eb23'
+
+/
+
+-- Running upgrade 8fce4c573e15 -> 2da192dbbc65
+
+CREATE TABLE ps_outbound_publishes (
+    id VARCHAR2(40 CHAR) NOT NULL, 
+    expiration INTEGER, 
+    outbound_auth VARCHAR2(40 CHAR), 
+    outbound_proxy VARCHAR2(256 CHAR), 
+    server_uri VARCHAR2(256 CHAR), 
+    from_uri VARCHAR2(256 CHAR), 
+    to_uri VARCHAR2(256 CHAR), 
+    event VARCHAR2(40 CHAR), 
+    max_auth_attempts INTEGER, 
+    transport VARCHAR2(40 CHAR), 
+    multi_user VARCHAR(3 CHAR), 
+    "@body" VARCHAR2(40 CHAR), 
+    "@context" VARCHAR2(256 CHAR), 
+    "@exten" VARCHAR2(256 CHAR), 
+    UNIQUE (id), 
+    CONSTRAINT yesno_values CHECK (multi_user IN ('yes', 'no'))
+)
+
+/
+
+CREATE INDEX ps_outbound_publishes_id ON ps_outbound_publishes (id)
+
+/
+
+CREATE TABLE ps_inbound_publications (
+    id VARCHAR2(40 CHAR) NOT NULL, 
+    endpoint VARCHAR2(40 CHAR), 
+    "event_asterisk-devicestate" VARCHAR2(40 CHAR), 
+    "event_asterisk-mwi" VARCHAR2(40 CHAR), 
+    UNIQUE (id)
+)
+
+/
+
+CREATE INDEX ps_inbound_publications_id ON ps_inbound_publications (id)
+
+/
+
+CREATE TABLE ps_asterisk_publications (
+    id VARCHAR2(40 CHAR) NOT NULL, 
+    devicestate_publish VARCHAR2(40 CHAR), 
+    mailboxstate_publish VARCHAR2(40 CHAR), 
+    device_state VARCHAR(3 CHAR), 
+    device_state_filter VARCHAR2(256 CHAR), 
+    mailbox_state VARCHAR(3 CHAR), 
+    mailbox_state_filter VARCHAR2(256 CHAR), 
+    UNIQUE (id), 
+    CONSTRAINT yesno_values CHECK (device_state IN ('yes', 'no')), 
+    CONSTRAINT yesno_values CHECK (mailbox_state IN ('yes', 'no'))
+)
+
+/
+
+CREATE INDEX ps_asterisk_publications_id ON ps_asterisk_publications (id)
+
+/
+
+UPDATE alembic_version SET version_num='2da192dbbc65' WHERE alembic_version.version_num = '8fce4c573e15'
+
+/
+
+-- Running upgrade 2da192dbbc65 -> 1d0e332c32af
+
+CREATE TABLE ps_resource_list (
+    id VARCHAR2(40 CHAR) NOT NULL, 
+    list_item VARCHAR2(2048 CHAR), 
+    event VARCHAR2(40 CHAR), 
+    full_state VARCHAR(3 CHAR), 
+    notification_batch_interval INTEGER, 
+    UNIQUE (id), 
+    CONSTRAINT yesno_values CHECK (full_state IN ('yes', 'no'))
+)
+
+/
+
+CREATE INDEX ps_resource_list_id ON ps_resource_list (id)
+
+/
+
+UPDATE alembic_version SET version_num='1d0e332c32af' WHERE alembic_version.version_num = '2da192dbbc65'
+
+/
+
+-- Running upgrade 1d0e332c32af -> 86bb1efa278d
+
+ALTER TABLE ps_endpoints ADD refer_blind_progress VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (refer_blind_progress IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='86bb1efa278d' WHERE alembic_version.version_num = '1d0e332c32af'
+
+/
+
+-- Running upgrade 86bb1efa278d -> d7983954dd96
+
+ALTER TABLE ps_endpoints ADD notify_early_inuse_ringing VARCHAR(3 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT yesno_values CHECK (notify_early_inuse_ringing IN ('yes', 'no'))
+
+/
+
+UPDATE alembic_version SET version_num='d7983954dd96' WHERE alembic_version.version_num = '86bb1efa278d'
+
+/
+
+-- Running upgrade d7983954dd96 -> 164abbd708c
+
+ALTER TABLE ps_endpoints DROP CONSTRAINT pjsip_dtmf_mode_values_v2
+
+/
+
+ALTER TABLE ps_endpoints MODIFY dtmf_mode VARCHAR(9 CHAR)
+
+/
+
+ALTER TABLE ps_endpoints ADD CONSTRAINT pjsip_dtmf_mode_values_v3 CHECK (dtmf_mode IN ('rfc4733', 'inband', 'info', 'auto', 'auto_info'))
+
+/
+
+UPDATE alembic_version SET version_num='164abbd708c' WHERE alembic_version.version_num = 'd7983954dd96'
+
+/
+
diff -urpN asterisk-13.9.1/contrib/realtime/postgresql/postgresql_config.sql asterisk-13.17.0/contrib/realtime/postgresql/postgresql_config.sql
--- asterisk-13.9.1/contrib/realtime/postgresql/postgresql_config.sql	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/realtime/postgresql/postgresql_config.sql	2017-07-12 13:12:08.000000000 +0200
@@ -450,7 +450,8 @@ CREATE TABLE extensions (
     priority INTEGER NOT NULL, 
     app VARCHAR(40) NOT NULL, 
     appdata VARCHAR(256) NOT NULL, 
-    PRIMARY KEY (id, context, exten, priority), 
+    PRIMARY KEY (id), 
+    UNIQUE (context, exten, priority), 
     UNIQUE (id)
 );
 
@@ -909,5 +910,243 @@ ALTER TABLE ps_endpoints ADD COLUMN mwi_
 
 UPDATE alembic_version SET version_num='1c688d9a003c' WHERE alembic_version.version_num = '5813202e92be';
 
+-- Running upgrade 1c688d9a003c -> 8d478ab86e29
+
+ALTER TABLE ps_globals ADD COLUMN disable_multi_domain yesno_values;
+
+UPDATE alembic_version SET version_num='8d478ab86e29' WHERE alembic_version.version_num = '1c688d9a003c';
+
+-- Running upgrade 8d478ab86e29 -> 65eb22eb195
+
+ALTER TABLE ps_globals ADD COLUMN unidentified_request_count INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN unidentified_request_period INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN unidentified_request_prune_interval INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN default_realm VARCHAR(40);
+
+UPDATE alembic_version SET version_num='65eb22eb195' WHERE alembic_version.version_num = '8d478ab86e29';
+
+-- Running upgrade 65eb22eb195 -> 81b01a191a46
+
+ALTER TABLE ps_contacts ADD COLUMN reg_server VARCHAR(20);
+
+ALTER TABLE ps_contacts ADD CONSTRAINT ps_contacts_uq UNIQUE (id, reg_server);
+
+UPDATE alembic_version SET version_num='81b01a191a46' WHERE alembic_version.version_num = '65eb22eb195';
+
+-- Running upgrade 81b01a191a46 -> 6be31516058d
+
+ALTER TABLE ps_contacts ADD COLUMN authenticate_qualify yesno_values;
+
+UPDATE alembic_version SET version_num='6be31516058d' WHERE alembic_version.version_num = '81b01a191a46';
+
+-- Running upgrade 6be31516058d -> bca7113d796f
+
+ALTER TABLE ps_endpoints ADD COLUMN deny VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN permit VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN acl VARCHAR(40);
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_deny VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_permit VARCHAR(95);
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_acl VARCHAR(40);
+
+UPDATE alembic_version SET version_num='bca7113d796f' WHERE alembic_version.version_num = '6be31516058d';
+
+-- Running upgrade bca7113d796f -> a845e4d8ade8
+
+ALTER TABLE ps_contacts ADD COLUMN via_addr VARCHAR(40);
+
+ALTER TABLE ps_contacts ADD COLUMN via_port INTEGER;
+
+ALTER TABLE ps_contacts ADD COLUMN call_id VARCHAR(255);
+
+UPDATE alembic_version SET version_num='a845e4d8ade8' WHERE alembic_version.version_num = 'bca7113d796f';
+
+-- Running upgrade a845e4d8ade8 -> ef7efc2d3964
+
+ALTER TABLE ps_contacts ADD COLUMN endpoint VARCHAR(40);
+
+ALTER TABLE ps_contacts ALTER COLUMN expiration_time TYPE BIGINT USING expiration_time::bigint;
+
+CREATE INDEX ps_contacts_qualifyfreq_exp ON ps_contacts (qualify_frequency, expiration_time);
+
+CREATE INDEX ps_aors_qualifyfreq_contact ON ps_aors (qualify_frequency, contact);
+
+UPDATE alembic_version SET version_num='ef7efc2d3964' WHERE alembic_version.version_num = 'a845e4d8ade8';
+
+-- Running upgrade ef7efc2d3964 -> 9deac0ae4717
+
+ALTER TABLE ps_endpoints ADD COLUMN subscribe_context VARCHAR(40);
+
+UPDATE alembic_version SET version_num='9deac0ae4717' WHERE alembic_version.version_num = 'ef7efc2d3964';
+
+-- Running upgrade 9deac0ae4717 -> 4a6c67fa9b7a
+
+ALTER TABLE ps_endpoints ADD COLUMN fax_detect_timeout INTEGER;
+
+UPDATE alembic_version SET version_num='4a6c67fa9b7a' WHERE alembic_version.version_num = '9deac0ae4717';
+
+-- Running upgrade 4a6c67fa9b7a -> c7a44a5a0851
+
+ALTER TABLE ps_globals ADD COLUMN mwi_tps_queue_high INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN mwi_tps_queue_low INTEGER;
+
+ALTER TABLE ps_globals ADD COLUMN mwi_disable_initial_unsolicited yesno_values;
+
+UPDATE alembic_version SET version_num='c7a44a5a0851' WHERE alembic_version.version_num = '4a6c67fa9b7a';
+
+-- Running upgrade c7a44a5a0851 -> 3772f8f828da
+
+ALTER TYPE pjsip_identify_by_values RENAME TO pjsip_identify_by_values_tmp;
+
+CREATE TYPE pjsip_identify_by_values AS ENUM ('username', 'auth_username');
+
+ALTER TABLE ps_endpoints ALTER COLUMN identify_by TYPE pjsip_identify_by_values USING identify_by::text::pjsip_identify_by_values;
+
+DROP TYPE pjsip_identify_by_values_tmp;
+
+UPDATE alembic_version SET version_num='3772f8f828da' WHERE alembic_version.version_num = 'c7a44a5a0851';
+
+-- Running upgrade 3772f8f828da -> 4e2493ef32e6
+
+ALTER TABLE ps_endpoints ADD COLUMN contact_user VARCHAR(80);
+
+UPDATE alembic_version SET version_num='4e2493ef32e6' WHERE alembic_version.version_num = '3772f8f828da';
+
+-- Running upgrade 4e2493ef32e6 -> a6ef36f1309
+
+ALTER TABLE ps_globals ADD COLUMN ignore_uri_user_options yesno_values;
+
+UPDATE alembic_version SET version_num='a6ef36f1309' WHERE alembic_version.version_num = '4e2493ef32e6';
+
+-- Running upgrade a6ef36f1309 -> 4468b4a91372
+
+ALTER TABLE ps_endpoints ADD COLUMN asymmetric_rtp_codec yesno_values;
+
+UPDATE alembic_version SET version_num='4468b4a91372' WHERE alembic_version.version_num = 'a6ef36f1309';
+
+-- Running upgrade 4468b4a91372 -> 28ab27a7826d
+
+ALTER TABLE ps_endpoint_id_ips ADD COLUMN srv_lookups yesno_values;
+
+UPDATE alembic_version SET version_num='28ab27a7826d' WHERE alembic_version.version_num = '4468b4a91372';
+
+-- Running upgrade 28ab27a7826d -> 465e70e8c337
+
+ALTER TABLE ps_endpoint_id_ips ADD COLUMN match_header VARCHAR(255);
+
+UPDATE alembic_version SET version_num='465e70e8c337' WHERE alembic_version.version_num = '28ab27a7826d';
+
+-- Running upgrade 465e70e8c337 -> 15db7b91a97a
+
+ALTER TABLE ps_endpoints ADD COLUMN rtcp_mux yesno_values;
+
+UPDATE alembic_version SET version_num='15db7b91a97a' WHERE alembic_version.version_num = '465e70e8c337';
+
+-- Running upgrade 15db7b91a97a -> f638dbe2eb23
+
+ALTER TABLE ps_transports ADD COLUMN symmetric_transport yesno_values;
+
+ALTER TABLE ps_subscription_persistence ADD COLUMN contact_uri VARCHAR(256);
+
+UPDATE alembic_version SET version_num='f638dbe2eb23' WHERE alembic_version.version_num = '15db7b91a97a';
+
+-- Running upgrade f638dbe2eb23 -> 8fce4c573e15
+
+ALTER TABLE ps_endpoints ADD COLUMN allow_overlap yesno_values;
+
+UPDATE alembic_version SET version_num='8fce4c573e15' WHERE alembic_version.version_num = 'f638dbe2eb23';
+
+-- Running upgrade 8fce4c573e15 -> 2da192dbbc65
+
+CREATE TABLE ps_outbound_publishes (
+    id VARCHAR(40) NOT NULL, 
+    expiration INTEGER, 
+    outbound_auth VARCHAR(40), 
+    outbound_proxy VARCHAR(256), 
+    server_uri VARCHAR(256), 
+    from_uri VARCHAR(256), 
+    to_uri VARCHAR(256), 
+    event VARCHAR(40), 
+    max_auth_attempts INTEGER, 
+    transport VARCHAR(40), 
+    multi_user yesno_values, 
+    "@body" VARCHAR(40), 
+    "@context" VARCHAR(256), 
+    "@exten" VARCHAR(256), 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_outbound_publishes_id ON ps_outbound_publishes (id);
+
+CREATE TABLE ps_inbound_publications (
+    id VARCHAR(40) NOT NULL, 
+    endpoint VARCHAR(40), 
+    "event_asterisk-devicestate" VARCHAR(40), 
+    "event_asterisk-mwi" VARCHAR(40), 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_inbound_publications_id ON ps_inbound_publications (id);
+
+CREATE TABLE ps_asterisk_publications (
+    id VARCHAR(40) NOT NULL, 
+    devicestate_publish VARCHAR(40), 
+    mailboxstate_publish VARCHAR(40), 
+    device_state yesno_values, 
+    device_state_filter VARCHAR(256), 
+    mailbox_state yesno_values, 
+    mailbox_state_filter VARCHAR(256), 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_asterisk_publications_id ON ps_asterisk_publications (id);
+
+UPDATE alembic_version SET version_num='2da192dbbc65' WHERE alembic_version.version_num = '8fce4c573e15';
+
+-- Running upgrade 2da192dbbc65 -> 1d0e332c32af
+
+CREATE TABLE ps_resource_list (
+    id VARCHAR(40) NOT NULL, 
+    list_item VARCHAR(2048), 
+    event VARCHAR(40), 
+    full_state yesno_values, 
+    notification_batch_interval INTEGER, 
+    UNIQUE (id)
+);
+
+CREATE INDEX ps_resource_list_id ON ps_resource_list (id);
+
+UPDATE alembic_version SET version_num='1d0e332c32af' WHERE alembic_version.version_num = '2da192dbbc65';
+
+-- Running upgrade 1d0e332c32af -> 86bb1efa278d
+
+ALTER TABLE ps_endpoints ADD COLUMN refer_blind_progress yesno_values;
+
+UPDATE alembic_version SET version_num='86bb1efa278d' WHERE alembic_version.version_num = '1d0e332c32af';
+
+-- Running upgrade 86bb1efa278d -> d7983954dd96
+
+ALTER TABLE ps_endpoints ADD COLUMN notify_early_inuse_ringing yesno_values;
+
+UPDATE alembic_version SET version_num='d7983954dd96' WHERE alembic_version.version_num = '86bb1efa278d';
+
+-- Running upgrade d7983954dd96 -> 164abbd708c
+
+CREATE TYPE pjsip_dtmf_mode_values_v3 AS ENUM ('rfc4733', 'inband', 'info', 'auto', 'auto_info');
+
+ALTER TABLE ps_endpoints ALTER COLUMN dtmf_mode TYPE pjsip_dtmf_mode_values_v3 USING dtmf_mode::text::pjsip_dtmf_mode_values_v3;
+
+DROP TYPE pjsip_dtmf_mode_values_v2;
+
+UPDATE alembic_version SET version_num='164abbd708c' WHERE alembic_version.version_num = 'd7983954dd96';
+
 COMMIT;
 
diff -urpN asterisk-13.9.1/contrib/scripts/ast_coredumper asterisk-13.17.0/contrib/scripts/ast_coredumper
--- asterisk-13.9.1/contrib/scripts/ast_coredumper	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/scripts/ast_coredumper	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,533 @@
+#!/usr/bin/env bash
+# Turn on extended globbing
+shopt -s extglob
+# Bail on any error
+set -e
+
+prog=$(basename $0)
+
+print_help() {
+cat <<EOF
+NAME
+	$prog - Dump and/or format asterisk coredump files
+
+SYNOPSIS
+	$prog [ --help ] [ --running | --RUNNING ] [ --latest ]
+		[ --tarball-coredumps ] [ --delete-coredumps-after ]
+		[ --tarball-results ] [ --delete-results-after ]
+		[ --tarball-uniqueid="<uniqueid>" ]
+		[ --no-default-search ] [ --append-coredumps ]
+		[ <coredump> | <pattern> ... ]
+
+DESCRIPTION
+
+	Extracts backtraces and lock tables from Asterisk coredump files.
+	For each coredump found, 4 new result files are created:
+	- <coredump>.brief.txt: The output of "thread apply all bt".
+
+	- <coredump>.thread1.txt: The output of "thread apply 1 bt full".
+
+	- <coredump>.full.txt: The output of "thread apply all bt full".
+
+	- <coredump>.locks.txt: If asterisk was compiled with
+		"DEBUG_THREADS", this file will contain a dump of the locks
+		table similar to doing a "core show locks" from the asterisk
+		CLI.
+
+	Optional features:
+	- The running asterisk process can be suspended and dumped.
+	- The coredumps can be merged into a tarball.
+	- The coredumps can be deleted after processing.
+	- The results files can be merged into a tarball.
+	- The results files can be deleted after processing.
+
+	Options:
+
+	--help
+		Print this help.
+
+	--running
+		Create a coredump from the running asterisk instance and
+		process it along with any other coredumps found (if any).
+		WARNING: This WILL interrupt call processing.  You will be
+		asked to confirm.
+
+	--RUNNING
+		Same as --running but without the confirmation prompt.
+		DANGEROUS!!
+
+	--latest
+		Process only the latest coredump from those specified (based
+		on last-modified time).  If a dump of the running process was
+		requested, it is always included in addition to the latest
+		from the existing coredumps.
+
+	--tarball-coredumps
+		Creates a gzipped tarball of all coredumps processed.
+		The tarball name will be:
+		/tmp/asterisk.<timestamp>.coredumps.tar.gz
+
+	--delete-coredumps-after
+		Deletes all processed coredumps regardless of whether
+		a tarball was created.
+
+	--tarball-results
+		Creates a gzipped tarball of all result files produced.
+		The tarball name will be:
+		/tmp/asterisk.<timestamp>.results.tar.gz
+
+	--delete-results-after
+		Deletes all processed results regardless of whether
+		a tarball was created.  It probably doesn't make sense
+		to use this option unless you have also specified
+		--tarball-results.
+
+	--tarball-uniqueid="<uniqueid>"
+		Normally DATEFORMAT is used to make the tarballs unique
+		but you can use your own unique id in the tarball names
+		such as the Jira issue id.
+
+	--no-default-search
+		Ignore COREDUMPS from the config files and process only
+		coredumps listed on the command line (if any) and/or
+		the running asterisk instance (if requested).
+
+	--append-coredumps
+		Append any coredumps specified on the command line to the
+		config file specified ones instead of overriding them.
+
+	<coredump> | <pattern>
+		A list of coredumps or coredump search patterns.  Unless
+		--append-coredumps was specified, these entries will override
+		those specified in the config files.
+
+		Any resulting file that isn't actually a coredump is silently
+		ignored.  If your patterns contains spaces be sure to only
+		quote the portion of the pattern that DOESN'T contain wildcard
+		expressions.  If you quote the whole pattern, it won't be
+		expanded.
+
+		If --no-default-search is specified and no files are specified
+		on the command line, then the only the running asterisk process
+		will be dumped (if requested).  Otherwise if no files are
+		specified on the command line the value of COREDUMPS from
+		ast_debug_tools.conf will be used.  Failing that, the following
+		patterns will be used:
+		/tmp/core[-._]asterisk!(*.txt)
+		/tmp/core[-._]\$(hostname)!(*.txt)
+
+NOTES
+	You must be root to use $prog.
+
+	The script relies on not only bash, but also recent GNU date and
+	gdb with python support.  *BSD operating systems may require
+	installation of the 'coreutils' and 'devel/gdb' packagess and minor
+	tweaking of the ast_debug_tools.conf file.
+
+	Any files output will have ':' characters changed to '-'.  This is
+	to facilitate uploading those files to Jira which doesn't like the
+	colons.
+
+FILES
+	/etc/asterisk/ast_debug_tools.conf
+	~/ast_debug_tools.conf
+	./ast_debug_tools.conf
+
+	#
+	# This file is used by the Asterisk debug tools.
+	# Unlike other Asterisk config files, this one is
+	# "sourced" by bash and must adhere to bash semantics.
+	#
+
+	# A list of coredumps and/or coredump search patterns.
+	# Bash extended globs are enabled and any resulting files
+	# that aren't actually coredumps are silently ignored
+	# so you can be liberal with the globs.
+	#
+	# If your patterns contains spaces be sure to only quote
+	# the portion of the pattern that DOESN'T contain wildcard
+	# expressions.  If you quote the whole pattern, it won't
+	# be expanded and the glob characters will be treated as
+	# literals.
+	#
+	# The exclusion of files ending ".txt" is just for
+	# demonstration purposes as non-coredumps will be ignored
+	# anyway.
+	COREDUMPS=(/tmp/core[-._]asterisk!(*.txt) /tmp/core[-._]\$(hostname)!(*.txt))
+
+	# Date command for the "running" coredump and tarballs.
+	# DATEFORMAT will be executed to get the timestamp.
+	# Don't put quotes around the format string or they'll be
+	# treated as literal characters.  Also be aware of colons
+	# in the output as you can't upload files with colons in
+	# the name to Jira.
+	#
+	# Unix timestamp
+	#DATEFORMAT='date +%s.%N'
+	#
+	# *BSD/MacOS doesn't support %N but after installing GNU
+	# coreutils...
+	#DATEFORMAT='gdate +%s.%N'
+	#
+	# Readable GMT
+	#DATEFORMAT='date -u +%FT%H-%M-%S%z'
+	#
+	# Readable Local time
+	DATEFORMAT='date +%FT%H-%M-%S%z'
+
+EOF
+	exit 1
+}
+
+if [ $EUID -ne 0 ] ; then
+	echo "You must be root to use $prog."
+	exit 1
+fi
+
+running=false
+RUNNING=false
+latest=false
+tarball_coredumps=false
+delete_coredumps_after=false
+tarball_results=false
+delete_results_after=false
+append_coredumps=false
+
+declare -a COREDUMPS
+declare -a ARGS_COREDUMPS
+
+# Read config files from least important to most important
+[ -f /etc/asterisk/ast_debug_tools.conf ] && source /etc/asterisk/ast_debug_tools.conf
+[ -f ~/ast_debug_tools.conf ] && source ~/ast_debug_tools.conf
+[ -f ./ast_debug_tools.conf ] && source ./ast_debug_tools.conf
+
+# For *BSD, the preferred gdb may be in /usr/local/bin so we
+# need to search for one that supports python.
+for g in $(which -a gdb) ; do
+	result=$($g --batch --ex "python print('hello')" 2>/dev/null || : )
+	if [[ "$result" =~ ^hello$ ]] ; then
+		GDB=$g
+		break
+	fi
+done
+
+if [ -z "$GDB" ] ; then
+	echo "No suitable gdb was found in $PATH"
+	exit 1
+fi
+
+if [ ${#COREDUMPS[@]} -eq 0 ] ; then
+	COREDUMPS+=(/tmp/core[-._]asterisk!(*.txt) /tmp/core[-._]$(hostname)!(*.txt))
+fi
+
+DATEFORMAT=${DATEFORMAT:-'date +%FT%H-%M-%S%z'}
+
+# Use "$@" (with the quotes) so spaces in patterns or
+# file names are preserved.
+# Later on when we have to iterate over COREDUMPS, we always
+# use the indexes rather than trying to expand the values of COREDUMPS
+# just in case.
+
+for a in "$@" ; do
+	case "$a" in
+	--running)
+		running=true
+		;;
+	--RUNNING)
+		RUNNING=true
+		;;
+	--no-default-search)
+		# Clean out COREDUMPS from config files
+		COREDUMPS=()
+		;;
+	--latest)
+		latest=true
+		;;
+	--tarball-coredumps)
+		tarball_coredumps=true
+		;;
+	--delete-coredumps-after)
+		delete_coredumps_after=true
+		;;
+	--tarball-results)
+		tarball_results=true
+		;;
+	--delete-results-after)
+		delete_results_after=true
+		;;
+	--append-coredumps)
+		append_coredumps=true
+		;;
+	--tarball-uniqueid=*)
+		tarball_uniqueid=${a#*=}
+		;;
+	--help|-*)
+		print_help
+		;;
+	*)
+		ARGS_COREDUMPS+=("$a")
+		# If any files are specified on the command line, ignore those
+		# specified in the config files unless append-coredumps was specified.
+		if ! $append_coredumps ; then
+			COREDUMPS=()
+		fi
+	esac
+done
+
+# append coredumps/patterns specified as command line arguments to COREDUMPS.
+for i in ${!ARGS_COREDUMPS[@]} ; do
+	COREDUMPS+=("${ARGS_COREDUMPS[$i]}")
+done
+
+# At this point, all glob entries that match files should be expanded.
+# Any entries that don't exist are probably globs that didn't match anything
+# and need to be pruned.  Any non coredumps are also pruned.
+
+for i in ${!COREDUMPS[@]} ; do
+	if [ ! -f "${COREDUMPS[$i]}" ] ; then
+		unset COREDUMPS[$i]
+		continue
+	fi
+	# Some versions of 'file' don't allow only the first n bytes of the
+	# file to be processed so we use dd to grab just the first 32 bytes.
+	mimetype=$(dd if="${COREDUMPS[$i]}" bs=32 count=1 2>/dev/null | file -bi -)
+	if [[ ! "$mimetype" =~ coredump ]] ; then
+		unset COREDUMPS[$i]
+		continue
+	fi
+done
+
+# Sort and weed out any dups
+IFS=$'\x0a'
+readarray -t COREDUMPS < <(echo -n "${COREDUMPS[*]}" | sort -u )
+unset IFS
+
+# If --latest, get the last modified timestamp of each file,
+# sort them, then return the latest.
+if [ ${#COREDUMPS[@]} -gt 0 ] && $latest ; then
+	lf=$(find "${COREDUMPS[@]}" -printf '%T@ %p\n' | sort -n | tail -1)
+	COREDUMPS=("${lf#* }")
+fi
+
+# Timestamp to use for output files
+df=${tarball_uniqueid:-$(${DATEFORMAT})}
+
+if $running || $RUNNING ; then
+	# We need to go through some gyrations to find the pid of the running
+	# MAIN asterisk process and not someone or something running asterisk -r.
+	# The pid file may NOT be in /var/run/asterisk so we need to find any
+	# running asterisk process and see if -C was specified on the command
+	# line.  The chances of more than 1 asterisk instance running with
+	# different -C options is so unlikely that we're going to ignore it.
+	#
+	# 'ps axo command' should work on Linux (back to CentOS6) and FreeBSD.
+	# If asterisk was started with -C, get the asterisk.conf file.
+	# If it wasn't, assume /etc/asterisk/asterisk.conf
+	astetcconf=`ps axo command | sed -n -r -e "s/.*asterisk\s+.*-C\s+([^ ]+).*/\1/gp" | tail -1`
+	[ x$astetcconf = x ] && astetcconf=/etc/asterisk/asterisk.conf
+	# Now parse out astrundir and cat asterisk.pid
+	astrundir=$(sed -n -r -e "s/astrundir\s+[=>]+\s+(.*)/\1/gp" $astetcconf)
+	pid=$(cat $astrundir/asterisk.pid 2>/dev/null || : )
+	if [ x$pid = x ] ; then
+		echo "Asterisk is not running"
+	else
+		if $RUNNING ; then
+			answer=Y
+		else
+			read -p "WARNING:  Taking a core dump of the running asterisk instance will suspend call processing while the dump is saved.  Do you wish to continue? (y/N) " answer
+		fi
+		if [[ "$answer" =~ ^[Yy] ]] ; then
+			cf="/tmp/core-asterisk-running-$df"
+			echo "Dumping running asterisk process to $cf"
+			${GDB} -p $pid -q --batch --ex "gcore $cf" >/dev/null 2>&1
+			COREDUMPS+=("$cf")
+		else
+			echo "Skipping dump of running process"
+		fi
+	fi
+fi
+
+if [ "${#COREDUMPS[@]}" -eq 0 ] ; then
+	echo "No coredumps found"
+	print_help
+fi
+
+# Extract the gdb scripts from the end of this script
+# and save them to /tmp/.gdbinit
+
+ss=`egrep -n "^#@@@SCRIPTSTART@@@" $0 |cut -f1 -d:`
+tail -n +${ss} $0 >/tmp/.ast_coredumper.gdbinit
+
+# Now iterate over the coredumps and dump the debugging info
+for i in ${!COREDUMPS[@]} ; do
+	cf=${COREDUMPS[$i]}
+	echo "Processing $cf"
+	${GDB} -n --batch -q --ex "source /tmp/.ast_coredumper.gdbinit" $(which asterisk) "$cf" 2>/dev/null | (
+		of=/dev/null
+		while IFS= read line ; do
+			if [[ "$line" =~ !@!@!@!\ ([^\ ]+)\ !@!@!@! ]] ; then
+				of=${cf}-${BASH_REMATCH[1]}
+				of=${of//:/-}
+				rm -f "$of"
+				echo "Creating $of"
+			fi
+			echo -e $"$line" >> "$of"
+		done
+	)
+done
+
+if $tarball_coredumps ; then
+	tf=/tmp/asterisk-$df.coredumps.tar
+	echo "Creating $tf.gz"
+	for i in ${!COREDUMPS[@]} ; do
+		tar -uvf $tf "${COREDUMPS[@]}" 2>/dev/null
+	done
+	gzip $tf
+fi
+
+if $delete_coredumps_after ; then
+	for i in ${!COREDUMPS[@]} ; do
+		rm -rf "${COREDUMPS[$i]}"
+	done
+fi
+
+if $tarball_results ; then
+	tf=/tmp/asterisk-$df-results.tar
+	echo "Creating $tf.gz"
+	for i in ${!COREDUMPS[@]} ; do
+		tar -uvf $tf "${COREDUMPS[$i]//:/-}"-{brief,full,thread1,locks}.txt 2>/dev/null
+	done
+	gzip $tf
+fi
+
+if $delete_results_after ; then
+	for i in ${!COREDUMPS[@]} ; do
+		rm -rf "${COREDUMPS[$i]//:/-}"-{brief,full,thread1,locks}.txt
+	done
+fi
+
+exit
+
+# Be careful editng the inline scripts.
+# They're space-indented.
+
+# We need the python bit because lock_infos isn't
+# a valid symbol in asterisk unless DEBUG_THREADS was
+# used during the compile.  Also, interrupt and continue
+# are only valid for a running program.
+
+#@@@SCRIPTSTART@@@
+python
+class DumpAsteriskCommand(gdb.Command):
+
+    def __init__(self):
+        super(DumpAsteriskCommand, self).__init__ ("dump-asterisk",
+            gdb.COMMAND_OBSCURE, gdb.COMPLETE_COMMAND)
+
+    def invoke(self, arg, from_tty):
+        try:
+            gdb.execute("interrupt", from_tty)
+        except:
+            pass
+        print("!@!@!@! thread1.txt !@!@!@!\n")
+        try:
+            gdb.execute("thread apply 1 bt full", from_tty)
+        except:
+            pass
+        print("!@!@!@! brief.txt !@!@!@!\n")
+        try:
+            gdb.execute("thread apply all bt", from_tty)
+        except:
+            pass
+        print("!@!@!@! full.txt !@!@!@!\n")
+        try:
+            gdb.execute("thread apply all bt full", from_tty)
+        except:
+            pass
+        print("!@!@!@! locks.txt !@!@!@!\n")
+        try:
+            gdb.execute("show_locks", from_tty)
+        except:
+            pass
+        try:
+            gdb.execute("continue", from_tty)
+        except:
+            pass
+
+DumpAsteriskCommand ()
+end
+
+define show_locks
+   set $n = lock_infos.first
+
+   if $argc == 0
+      printf "                                                                                                                    where_held count-|\n"
+      printf "                                                                                                                         suspended-| |\n"
+      printf "                                                                                                        type- |     times locked-| | |\n"
+      printf "thread         status   file                   line function                             lock name            | lock addr        | | |\n"
+   else
+      printf "thread,status,file,line,function,lock_name,lock_type,lock_addr,times_locked,suspended,where_held_count,where_held_file,where_held_line,where_held_function,there_held_thread\n"
+   end
+
+   while $n
+      if $n->num_locks > 0
+      set $i = 0
+      while $i < $n->num_locks
+         if $n->locks[$i]->suspended == 0
+            if ((ast_mutex_t *)$n->locks[$i]->lock_addr)->tracking
+               if $n->locks[$i]->type > 0
+                  set $track = ((ast_rwlock_t *)$n->locks[$i]->lock_addr)->track
+               else
+                  set $track = ((ast_mutex_t *)$n->locks[$i]->lock_addr)->track
+               end
+            end
+            set $reentrancy = $track->reentrancy
+            set $pending = $n->locks[$i]->pending
+            if $argc > 0
+               printf "%p,%d,%s,%d,%s,%s,%d,%p,%d,%d,%d",\
+                  $n->thread_id, $n->locks[$i]->pending, $n->locks[$i]->file, $n->locks[$i]->line_num, $n->locks[$i]->func,\
+                  $n->locks[$i]->lock_name, $n->locks[$i]->type, $n->locks[$i]->lock_addr, $n->locks[$i]->times_locked,\
+                  $n->locks[$i]->suspended, $track->reentrancy
+               if $reentrancy
+                  if $pending
+                     printf ",%s,%d,%s,%p", $track->file[0], $track->lineno[0], $track->func[0], $track->thread[0]
+                  end
+               end
+            else
+               if $n->locks[$i]->pending < 0
+                  printf "%p failed   %-20s %6d %-36s %-20s %d %14p %3d %d %d",\
+                     $n->thread_id,\
+                     $n->locks[$i]->file, $n->locks[$i]->line_num, $n->locks[$i]->func,\
+                     $n->locks[$i]->lock_name, $n->locks[$i]->type, $n->locks[$i]->lock_addr, $n->locks[$i]->times_locked,\
+                     $n->locks[$i]->suspended, $track->reentrancy
+               end
+               if $n->locks[$i]->pending == 0
+                  printf "%p holding  %-20s %6d %-36s %-20s %d %14p %3d %d %d",\
+                     $n->thread_id,\
+                     $n->locks[$i]->file, $n->locks[$i]->line_num, $n->locks[$i]->func,\
+                     $n->locks[$i]->lock_name, $n->locks[$i]->type, $n->locks[$i]->lock_addr, $n->locks[$i]->times_locked,\
+                     $n->locks[$i]->suspended, $track->reentrancy
+               end
+               if $n->locks[$i]->pending > 0
+                  printf "%p waiting  %-20s %6d %-36s %-20s %d %14p %3d %d %d",\
+                     $n->thread_id,\
+                     $n->locks[$i]->file, $n->locks[$i]->line_num, $n->locks[$i]->func,\
+                     $n->locks[$i]->lock_name, $n->locks[$i]->type, $n->locks[$i]->lock_addr, $n->locks[$i]->times_locked,\
+                     $n->locks[$i]->suspended, $track->reentrancy
+               end
+               if $reentrancy
+                  if $pending
+                     printf "\n               held at: %-20s %6d %-36s by 0x%08lx", $track->file[0], $track->lineno[0], $track->func[0], $track->thread_id[0]
+                  end
+               end
+            end
+            printf "\n"
+         end
+         set $i = $i + 1
+      end
+    end
+    set $n = $n->entry->next
+  end
+end
+
+dump-asterisk
diff -urpN asterisk-13.9.1/contrib/scripts/ast_logescalator asterisk-13.17.0/contrib/scripts/ast_logescalator
--- asterisk-13.9.1/contrib/scripts/ast_logescalator	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/scripts/ast_logescalator	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,399 @@
+#!/usr/bin/env bash
+# Turn on extended globbing
+shopt -s extglob
+# Bail on any error
+set -e
+
+prog=$(basename $0)
+
+print_help() {
+cat <<EOF
+NAME
+	$prog - Escalate Asterisk logging levels
+
+SYNOPSIS
+	$prog [ --help ] | [ [ --reset ] | [
+		[ --uniqueid="<uniqueid>" ]
+
+		[ --pjsip-debug=<on|off> ] [ --sip-debug=<on|off> ]
+		[ --iax2-debug=<on|off> ]
+
+		[ --agi-debug=<on|off> ] [ --ami-debug=<on|off> ]
+		[ --ari-debug=<on|off> ] [ --cdr-debug=<on|off> ]
+		[ --channel-debug=<on|off> ] [ --rtp-debug=<on|off> ]
+		[ --rtcp-debug=<on|off> ]
+
+		[ --dtmf-debug=<on|off> ] [ --fax-debug=<on|off> ]
+		[ --security-debug=<on|off> ]
+
+		[ --pjsip-history=<on|off> ] [ --sip-history=<on|off> ]
+
+		[ --verbose=<level> ] [ --debug=<level> ]
+		] ]
+
+DESCRIPTION
+
+	Escalates log and/or debug levels on Asterisk subsystems.
+
+	Options:
+
+	--help
+		Print this help.
+
+	--reset
+		Resets logging to the pre-escalation state.
+
+	--uniqueid="<uniqueid>"
+		Normally DATEFORMAT from ast_debug_tools.conf is used to make
+		the log files unique but you can set the unique id to
+		something else such as the Jira issue.  Once any logging
+		is enabled, the uniqueid is stored in cli.conf so any future
+		on/off commands will use the same uniqueid.  Use the --reset
+		option to reset it (and everything else).
+
+	--pjsip-debug  --sip-debug --iax2-debug --agi-debug --ami-debug
+	--ari-debug --cdr-debug --channel-debug --rtp-debug --rtcp-debug
+		Issues the subsystem appropriate command to turn on
+		or off debugging.  These are usually functional debug messages
+		such as packet dumps as opposed to code level messages and usually
+		go to the VERBOSE log channel.
+
+	--dtmf-debug --fax-debug --security-debug
+		These subsystems set up their own log channels so if turned
+		on, log files will be created in \$astlogdir for them.
+
+	--pjsip-history  --sip-history
+		The pjsip and sip channels have the ability to output an
+		abbreviated, one-line, packet summary.  If enabled, the summaries
+		will be written to \$astlogdir/pjsip_history.\$UNIQUEID and
+		\$astlogdir/sip_history.\$UNIQUEID.
+
+	--verbose-level --debug-level
+		Sets the levels for their respective messages.
+
+NOTES
+
+	The escalator works by creating a set of startup commands in cli.conf
+	that set up logger channels and issue the debug commands.  If asterisk
+	is running when $prog is executed, the same commands will be issued
+	to the running instance.  The original cli.conf is saved before any
+	changes are made and can be restored by executing '$prog --reset'.
+
+	The log output will be stored in...
+	\$astlogdir/message.\$uniqueid
+	\$astlogdir/debug.\$uniqueid
+	\$astlogdir/dtmf.\$uniqueid
+	\$astlogdir/fax.\$uniqueid
+	\$astlogdir/security.\$uniqueid
+	\$astlogdir/pjsip_history.\$uniqueid
+	\$astlogdir/sip_history.\$uniqueid
+
+EOF
+	exit 1
+}
+
+PJSIP_DEBUG_SPECIFIED=false
+PJSIP_HISTORY_SPECIFIED=false
+SIP_DEBUG_SPECIFIED=false
+SIP_HISTORY_SPECIFIED=false
+IAX2_DEBUG_SPECIFIED=false
+ARI_DEBUG_SPECIFIED=false
+AMI_DEBUG_SPECIFIED=false
+AGI_DEBUG_SPECIFIED=false
+CDR_DEBUG_SPECIFIED=false
+CHANNEL_DEBUG_SPECIFIED=false
+RTP_DEBUG_SPECIFIED=false
+RTCP_DEBUG_SPECIFIED=false
+DTMF_DEBUG_SPECIFIED=false
+FAX_DEBUG_SPECIFIED=false
+SECURITY_DEBUG_SPECIFIED=false
+DEBUG_LEVEL_SPECIFIED=false
+VERBOSE_LEVEL_SPECIFIED=false
+DEBUGS=false
+RESET=false
+
+declare -A DEBUG_COMMANDS=(
+[PJSIP,on]="pjsip set logger on" [PJSIP,off]="pjsip set logger off"
+[SIP,on]="sip set debug on" [SIP,off]="sip set debug off"
+[IAX2,on]="iax2 set debug on" [IAX2,off]="iax2 set debug off"
+[ARI,on]="ari set debug all on" [ARI,off]="ari set debug all off"
+[AMI,on]="manager set debug on" [AMI,off]="manager set debug off"
+[AGI,on]="agi set debug on" [AGI,off]="agi set debug off"
+[CDR,on]="cdr set debug on" [CDR,off]="cdr set debug off"
+[CHANNEL,on]="core set debug channel all" [CHANNEL,off]="core set debug channel all off"
+[RTP,on]="rtp set debug on" [RTP,on]="rtp set debug off"
+[RTCP,on]="rtcp set debug on" [RTCP,off]="rtcp set debug off"
+)
+
+VERBOSE_LEVELS="NOTICE,WARNING,ERROR,VERBOSE"
+DEBUG_LEVELS="DEBUG"
+
+# Read config files from least important to most important
+[ -f /etc/asterisk/ast_debug_tools.conf ] && source /etc/asterisk/ast_debug_tools.conf
+[ -f ~/ast_debug_tools.conf ] && source ~/ast_debug_tools.conf
+[ -f ./ast_debug_tools.conf ] && source ./ast_debug_tools.conf
+
+DATEFORMAT=${DATEFORMAT:-'date +%FT%H-%M-%S%z'}
+UNIQUEID=$($DATEFORMAT)
+UNIQUEID_SPECIFIED=false
+
+for a in "$@" ; do
+	case "$a" in
+	--*-debug=*)
+		subsystem=${a%-debug=*}
+		subsystem=${subsystem#--}
+		flag=${a#*=}
+		if [[ ${flag,,} =~ ^y(es)?|on ]] ; then
+			eval ${subsystem^^}_DEBUG=true
+		else
+			eval ${subsystem^^}_DEBUG=false
+		fi
+		eval ${subsystem^^}_DEBUG_SPECIFIED=true
+		DEBUGS=true
+		;;
+	--pjsip-history=*)
+		;&
+	--sip-history=*)
+		subsystem=${a%-history=*}
+		subsystem=${subsystem#--}
+		if [[ ${a#*=} =~ ^[Yy].* ]] ; then
+			eval ${subsystem^^}_HISTORY=true
+		else
+			eval ${subsystem^^}_HISTORY=false
+		fi
+		eval ${subsystem^^}_HISTORY_SPECIFIED=true
+		DEBUGS=true
+		;;
+	--verbose=*)
+		VERBOSE_LEVEL=${a#*=}
+		VERBOSE_LEVEL_SPECIFIED=true
+		DEBUGS=true
+		;;
+	--debug=*)
+		DEBUG_LEVEL=${a#*=}
+		DEBUG_LEVEL_SPECIFIED=true
+		DEBUGS=true
+		;;
+	--reset)
+		RESET=true
+		;;
+	--uniqueid=*)
+		UNIQUEID=${a#*=}
+		UNIQUEID_SPECIFIED=true
+		DEBUGS=true
+		;;
+	--help|*)
+		print_help
+		;;
+	esac
+done
+
+if $DEBUGS && $RESET ; then
+	echo "--reset must be specified by itself"
+	print_help
+fi
+
+if ! $DEBUGS && ! $RESET ; then
+	echo "No options specified."
+	print_help
+fi
+
+ASTERISK_IS_RUNNING=false
+CONFIG_DIR=/etc/asterisk
+LOG_DIR=/var/log/asterisk
+
+if [ "$(pidof asterisk)" != "" ] ; then
+	CONFIG_DIR=`asterisk -rx "core show settings" | sed -n -r -e "s/^\s*Configuration\s+directory:\s+(.*)$/\1/gp"`
+	LOG_DIR=`asterisk -rx "core show settings" | sed -n -r -e "s/^\s*Log\s+directory:\s+(.*)$/\1/gp"`
+	ASTERISK_IS_RUNNING=true
+fi
+CLI_CONF="$CONFIG_DIR/cli.conf"
+
+if [ ! -f "$CLI_CONF" ] ; then
+	echo "The location of cli.conf could not be determined."
+	exit 1
+fi
+
+if $RESET ; then
+	if [ -f "$CLI_CONF.unescalated" ] ; then
+		mv "$CLI_CONF.unescalated" "$CLI_CONF"
+	fi
+	if $ASTERISK_IS_RUNNING ; then
+		(
+		asterisk -rx "core set verbose 0"
+		asterisk -rx "core set debug 0"
+		asterisk -rx "pjsip set logger off"
+		asterisk -rx "pjsip set history off"
+		asterisk -rx "sip set debug off"
+		asterisk -rx "sip set history off"
+		asterisk -rx "iax2 set debug off"
+		asterisk -rx "manager set debug off"
+		asterisk -rx "ari set debug all off"
+		asterisk -rx "agi set debug off"
+		asterisk -rx "rtp set debug off"
+		asterisk -rx "rtcp set debug off"
+		asterisk -rx "cdr set debug off"
+		asterisk -rx "core set debug channel all off"
+		asterisk -rx "logger reload"
+		)  >/dev/null 2>&1 || :
+	fi
+	exit 1
+fi
+
+if ! grep -q "; --START DEBUG_LOGGING-- ;" $CLI_CONF ; then
+	VERBOSE_LOG="$LOG_DIR/message.${UNIQUEID}"
+	DEBUG_LOG="$LOG_DIR/debug.${UNIQUEID}"
+	PJSIP_HISTORY_LOG="$LOG_DIR/pjsip_history.${UNIQUEID}"
+	SIP_HISTORY_LOG="$LOG_DIR/sip_history.${UNIQUEID}"
+	DTMF_LOG="$LOG_DIR/dtmf.${UNIQUEID}"
+	FAX_LOG="$LOG_DIR/fax.${UNIQUEID}"
+	SECURITY_LOG="$LOG_DIR/security.${UNIQUEID}"
+
+	cp "$CLI_CONF" "$CLI_CONF.unescalated"
+
+	sed -i -r -e "s/\[startup_commands\]/[startup_commands_original](!)/g" "$CLI_CONF"
+
+	cat >> "$CLI_CONF" <<-EOF
+	; --START DEBUG_LOGGING-- ;
+
+	[pjsip_debug](!)
+	pjsip set logger on = yes
+
+	[sip_debug](!)
+	sip set debug on = yes
+
+	[iax2_debug](!)
+	iax2 set debug on = yes
+
+	[ari_debug](!)
+	ari set debug all on = yes
+
+	[ami_debug](!)
+	manager set debug on = yes
+
+	[agi_debug](!)
+	agi set debug on = yes
+
+	[cdr_debug](!)
+	cdr set debug on = yes
+
+	[channel_debug](!)
+	core set debug channel all = yes
+
+	[rtp_debug](!)
+	rtp set debug on = yes
+
+	[rtcp_debug](!)
+	rtcp set debug on = yes
+
+	[dtmf_debug](!)
+	logger add channel $DTMF_LOG DTMF = yes
+
+	[fax_debug](!)
+	logger add channel $FAX_LOG FAX = yes
+
+	[security_debug](!)
+	logger add channel $SECURITY_LOG SECURITY = yes
+
+	[pjsip_history](!)
+	logger add channel $PJSIP_HISTORY_LOG PJSIP_HISTORY = yes
+	pjsip set history on = yes
+
+	[sip_history](!)
+	logger add channel $SIP_HISTORY_LOG SIP_HISTORY = yes
+	sip set history on = yes
+
+	[verbose_level](!)
+	core set verbose 3 = yes
+
+	[debug_level](!)
+	core set debug 3 = yes
+
+	[log_channels](!)
+	logger add channel $VERBOSE_LOG NOTICE,WARNING,ERROR,VERBOSE = yes
+	logger add channel $DEBUG_LOG DEBUG = yes
+
+	[startup_commands](startup_commands_original,log_channels)
+
+	; --END DEBUG_LOGGING-- ;
+	EOF
+
+else
+	if $UNIQUEID_SPECIFIED ; then
+		echo "Debug logging is already active.  Either rerun $prog without --uniqueid or with --reset to start over."
+		exit 1
+	fi
+
+	VERBOSE_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/message\..+)\s+NOTICE.*@\1@p" "$CLI_CONF")
+	DEBUG_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/debug\..+)\s+DEBUG.*@\1@p" "$CLI_CONF")
+	PJSIP_HISTORY_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/pjsip_history\..+)\s+PJSIP.*@\1@p" "$CLI_CONF")
+	SIP_HISTORY_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/sip_history\..+)\s+SIP.*@\1@p" "$CLI_CONF")
+	DTMF_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/dtmf\..+)\s+DTMF.*@\1@p" "$CLI_CONF")
+	FAX_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/fax\..+)\s+FAX.*@\1@p" "$CLI_CONF")
+	SECURITY_LOG=$(sed -n -r -e "s@logger add channel ($LOG_DIR/security\..+)\s+SECURITY.*@\1@p" "$CLI_CONF")
+fi
+
+for x in PJSIP SIP ARI AMI AGI ARI IAX2 CDR RTP RTCP ; do
+	if eval \$${x}_DEBUG_SPECIFIED ; then
+		if eval \$${x}_DEBUG ; then
+			if $ASTERISK_IS_RUNNING ; then
+				asterisk -rx "${DEBUG_COMMANDS[$x,on]}"
+			fi
+			egrep -q "^\[startup_commands\].*${x,,}_debug.*" "$CLI_CONF" ||
+				sed -i -r -e "/\[startup_commands\]/ s/\((.*)\)/(\1,${x,,}_debug)/g" "$CLI_CONF"
+		else
+			if $ASTERISK_IS_RUNNING ; then
+				asterisk -rx "${DEBUG_COMMANDS[$x,off]}"
+			fi
+			sed -i -r -e "/\[startup_commands\].*${x,,}_debug.*/ s/,${x,,}_debug//g" "$CLI_CONF"
+		fi
+	fi
+done
+
+for x in DTMF FAX SECURITY ; do
+	if eval \$${x}_DEBUG_SPECIFIED ; then
+		if eval \$${x}_DEBUG ; then
+			if $ASTERISK_IS_RUNNING ; then
+				asterisk -rx "$(eval "echo logger add channel \$${x}_LOG ${x}")" >/dev/null 2>&1
+			fi
+			egrep -q "^\[startup_commands\].*${x,,}_debug.*" "$CLI_CONF" ||
+				sed -i -r -e "/\[startup_commands\]/ s/\((.*)\)/(\1,${x,,}_debug)/g" "$CLI_CONF"
+		else
+			if $ASTERISK_IS_RUNNING ; then
+				asterisk -rx "$(eval "echo logger remove channel \$${x}_LOG")"
+			fi
+			sed -i -r -e "/\[startup_commands\].*${x,,}_debug.*/ s/,${x,,}_debug//g" "$CLI_CONF"
+		fi
+	fi
+done
+
+for x in PJSIP SIP ; do
+	if eval \$${x}_HISTORY_SPECIFIED ; then
+		if eval \$${x}_HISTORY ; then
+			if $ASTERISK_IS_RUNNING ; then
+				asterisk -rx "$(eval "echo logger add channel \$${x}_HISTORY_LOG ${x}_HISTORY")"
+				asterisk -rx "${x,,} set history on"
+			fi
+			egrep -q "^\[startup_commands\].*${x,,}_history.*" "$CLI_CONF" ||
+				sed -i -r -e "/\[startup_commands\]/ s/\((.*)\)/(\1,${x,,}_history)/g" "$CLI_CONF"
+		else
+			if $ASTERISK_IS_RUNNING ; then
+				asterisk -rx "$(eval "echo logger remove channel \$${x}_HISTORY_LOG")"
+				asterisk -rx "${x,,} set history off"
+			fi
+			sed -i -r -e "/\[startup_commands\].*${x,,}_history.*/ s/,${x,,}_history//g" "$CLI_CONF"
+		fi
+	fi
+done
+
+for x in VERBOSE DEBUG ; do
+	if eval \$${x}_LEVEL_SPECIFIED ; then
+		if $ASTERISK_IS_RUNNING ; then
+			asterisk -rx "$(eval "echo logger add channel \$${x}_LOG \$${x}_LEVELS")"
+			asterisk -rx "$(eval "echo core set ${x,,} \$${x}_LEVEL")"
+		fi
+		sed -i -r -e "$(eval "echo s/core set ${x,,} .*/core set ${x,,} \$${x}_LEVEL/g")" "$CLI_CONF"
+		egrep -q "^\[startup_commands\].*${x,,}_level.*" "$CLI_CONF" ||
+			sed -i -r -e "/\[startup_commands\]/ s/\((.*)\)/(\1,${x,,}_level)/g" "$CLI_CONF"
+	fi
+done
diff -urpN asterisk-13.9.1/contrib/scripts/ast_loggrabber asterisk-13.17.0/contrib/scripts/ast_loggrabber
--- asterisk-13.9.1/contrib/scripts/ast_loggrabber	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/contrib/scripts/ast_loggrabber	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,255 @@
+#!/usr/bin/env bash
+# Turn on extended globbing
+shopt -s extglob
+# Bail on any error
+set -e
+
+prog=$(basename $0)
+
+print_help() {
+cat <<EOF
+NAME
+$prog - Gather asterisk log files
+
+SYNOPSIS
+	$prog [ --help ] [ --dateformat="<dateformat>" ]
+		[ --timezone="<timezone>" ] [ --append-logfiles ]
+		[ --tarball-uniqueid="<uniqueid>" ]
+		[ <logfiles> | <pattern> ... ]
+
+DESCRIPTION
+
+	Gathers log files, optionally converts POSIX timestamps
+	to readable format. and creates a tarball.
+
+	Options:
+
+	--help
+		Print this help.
+
+	--dateformat="<dateformat>"
+		A Python strftime format string to be used when converting
+		POSIX timestamps in log files to readable format.  If not
+		specified as an argument or in the config file, no conversion
+		is done.
+
+	--timezone="<timezone>"
+		The timezone to use when converting POSIX timestamps to
+		readable format.  It can be specified in "<continent>/<city>"
+		format or in abbreviation format such as "CST6CDT".  If not
+		specified as an argument or in the config file, the "local"
+		timezone is used.
+
+	--append-logfiles
+		Append any log files specified on the command line to the
+		config file specified ones instead of overriding them.
+
+	--tarball-uniqueid="<uniqueid>"
+		Normally DATEFORMAT is used to make the tarballs unique
+		but you can use your own unique id in the tarball names
+		such as a Jira issue id.
+
+	<logfiles> | <pattern>
+		A list of log files or log file search patterns.  Unless
+		--append-logfiles was specified, these entries will override
+		those specified in the config files.
+
+		If no files are specified on the command line the, value of
+		LOGFILES from ast_debug_tools.conf will be used.  Failing
+		that, the following patterns will be used:
+		/var/log/asterisk/messages*
+		/var/log/asterisk/queue*
+		/var/log/asterisk/debug*
+		/var/log/asterisk/security*
+
+NOTES
+	Any files output will have ':' characters changed to '-'.  This is
+	to facilitate uploading those files to Jira which doesn't like the
+	colons.
+
+FILES
+	/etc/asterisk/ast_debug_tools.conf
+	~/ast_debug_tools.conf
+	./ast_debug_tools.conf
+
+	# Readable Local time for the tarball names
+	DATEFORMAT='date +%FT%H-%M-%S%z'
+
+	# A list of log files and/or log file search patterns using the
+	# same syntax as COREDUMPS.
+	#
+	LOGFILES=(/var/log/asterisk/messages* /var/log/asterisk/queue* \\
+		/var/log/asterisk/debug* /var/log/asterisk/security*)
+
+	# $prog converts POSIX timestamps to readable format
+	# using this Python strftime format string.  If not specified
+	# or an empty string, no format covnersion is done.
+	LOG_DATEFORMAT="%m/%d %H:%M:%S.%f"
+
+	# The timezone to use when converting POSIX timestamps to
+	# readable format.  It can be specified in "<continent>/<city>"
+	# format or in abbreviation format such as "CST6CDT".  If not
+	# specified, the "local" timezone is used.
+	# LOG_TIMEZONE=
+
+EOF
+	exit 1
+}
+
+append_logfiles=false
+
+declare -a LOGFILES
+declare -a ARGS_LOGFILES
+
+# Read config files from least important to most important
+[ -f /etc/asterisk/ast_debug_tools.conf ] && source /etc/asterisk/ast_debug_tools.conf
+[ -f ~/ast_debug_tools.conf ] && source ~/ast_debug_tools.conf
+[ -f ./ast_debug_tools.conf ] && source ./ast_debug_tools.conf
+
+if [ ${#LOGFILES[@]} -eq 0 ] ; then
+	LOGFILES+=(/var/log/asterisk/messages* /var/log/asterisk/queue* \
+	/var/log/asterisk/debug* /var/log/asterisk/security*)
+fi
+
+DATEFORMAT=${DATEFORMAT:-'date +%FT%H-%M-%S%z'}
+
+# Use "$@" (with the quotes) so spaces in patterns or
+# file names are preserved.
+# Later on when we have to iterate over LOGFILES, we always
+# use the indexes rather than trying to expand the values of LOGFILES
+# just in case.
+
+for a in "$@" ; do
+	case "$a" in
+	--dateformat=*)
+		LOG_DATEFORMAT=${a#*=}
+		;;
+	--timezone=*)
+		LOG_TIMEZONE=${a#*=}
+		;;
+	--append-logfiles)
+		append_logfiles=true
+		;;
+	--tarball-uniqueid=*)
+		tarball_uniqueid=${a#*=}
+		;;
+	--help|-*)
+		print_help
+		;;
+	*)
+		ARGS_LOGFILES+=("$a")
+		# If any files are specified on the command line, ignore those
+		# specified in the config files unless append-logfiles was specified.
+		if ! $append_logfiles ; then
+			LOGFILES=()
+		fi
+	esac
+done
+
+# append logfiles/patterns specified as command line arguments to LOGFILES.
+for i in ${!ARGS_LOGFILES[@]} ; do
+	LOGFILES+=("${ARGS_LOGFILES[$i]}")
+done
+
+# At this point, all glob entries that match files should be expanded.
+# Any entries that don't exist are probably globs that didn't match anything
+# and need to be pruned.
+
+for i in ${!LOGFILES[@]} ; do
+	if [ ! -f "${LOGFILES[$i]}" ] ; then
+		unset LOGFILES[$i]
+		continue
+	fi
+done
+
+# Sort and weed out any dups
+IFS=$'\x0a'
+readarray -t LOGFILES < <(echo -n "${LOGFILES[*]}" | sort -u )
+unset IFS
+
+if [ "${#LOGFILES[@]}" -eq 0 ] ; then
+	echo "No log files found"
+	print_help
+fi
+
+# Timestamp to use for output files
+df=${tarball_uniqueid:-$(${DATEFORMAT})}
+
+# Extract the Python timestamp conver script from the end of this
+# script and save it to /tmp/.ast_tsconvert.py
+
+ss=`egrep -n "^#@@@SCRIPTSTART@@@" $0 |cut -f1 -d:`
+tail -n +${ss} $0 >/tmp/.ast_tsconvert.py
+
+tmpdir=$(mktemp -d)
+if [ -z "$tmpdir" ] ; then
+	echo "${prog}: Unable to create temporary directory."
+	exit 1
+fi
+trap "rm -rf $tmpdir" EXIT
+tardir=asterisk-${df}.logfiles
+
+# Now iterate over the logfiles
+for i in ${!LOGFILES[@]} ; do
+	lf=${LOGFILES[$i]}
+	destdir="$tmpdir/$tardir/$(dirname $lf)"
+	destfile="$tmpdir/$tardir/$lf"
+	mkdir -p "$destdir" 2>/dev/null || :
+	if [ -n "$LOG_DATEFORMAT" ] ; then
+		echo "Converting $lf"
+		cat "$lf" | python /tmp/.ast_tsconvert.py --format="$LOG_DATEFORMAT" --timezone="$LOG_TIMEZONE" > "${destfile}"
+	else
+		echo "Copying $lf"
+		cp "$lf" "${destfile}"
+	fi
+done
+
+echo "Creating /tmp/$tardir.tar.gz"
+tar -czvf /tmp/$tardir.tar.gz -C $tmpdir $tardir 2>/dev/null
+
+exit
+
+# Be careful editng the inline scripts.
+# They're space-indented.
+
+# We need the python bit because lock_infos isn't
+# a valid symbol in asterisk unless DEBUG_THREADS was
+# used during the compile.  Also, interrupt and continue
+# are only valid for a running program.
+
+#@@@SCRIPTSTART@@@
+import argparse
+import datetime as dt
+import dateutil.tz as tz
+import re
+import sys
+import time
+
+parser = argparse.ArgumentParser(description="Make POSIX timestamps readable")
+parser.add_argument('--format', action='store', required=True)
+parser.add_argument('--timezone', action='store', required=False)
+args=parser.parse_args()
+
+# We only convert timestamps that are at the beginning of a line
+# or are preceeded by a whilespace character or a '['
+rets = re.compile(r'(^|(?<=\s|\[))\d+(\.\d+)?', flags=re.M)
+if args.timezone and len(args.timezone) > 0:
+   tzf = tz.tzfile('/usr/share/zoneinfo/' + args.timezone)
+else:
+   tzf = tz.tzfile('/etc/localtime')
+
+now = time.time()
+a_year_ago = now - (86400.0 * 365)
+
+def convert(match):
+   ts = float(match.group(0))
+   if ts <= now and ts > a_year_ago and len(args.format) > 0:
+      return dt.datetime.fromtimestamp(ts, tzf).strftime(args.format)
+   else:
+      return match.group(0)
+
+while 1:
+   line = sys.stdin.readline()
+   if not line:
+      break
+   print(rets.sub(convert, line))
diff -urpN asterisk-13.9.1/contrib/scripts/autosupport asterisk-13.17.0/contrib/scripts/autosupport
--- asterisk-13.9.1/contrib/scripts/autosupport	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/scripts/autosupport	2017-07-12 13:12:08.000000000 +0200
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# Autosupport Version 2.1.0
+# Autosupport Version 2.1.3
 # Collect support information
 #
 # Copyright (C) 2005-2016, Digium, Inc.
@@ -187,7 +187,7 @@ echo >> $OUTPUT;
 # Add check to see if asterisk is running.
 if [ -e /var/run/asterisk.ctl ] || [ -e /var/run/asterisk/asterisk.ctl ]; then
   for command in "core show version" "pri show version" "dahdi show version" \
-      "pjsip show version" "pjsip show buildopts" \
+      "pjsip show version" "pjsip show buildopts" "pjproject show buildopts" \
       "core show translation" \
       "core show uptime" "core show settings" "core show sysinfo" "core show channels" \
       "pri show spans" "dahdi show status" "dahdi show channels" "dahdi show channel 1" \
diff -urpN asterisk-13.9.1/contrib/scripts/install_prereq asterisk-13.17.0/contrib/scripts/install_prereq
--- asterisk-13.9.1/contrib/scripts/install_prereq	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/scripts/install_prereq	2017-07-12 13:12:08.000000000 +0200
@@ -29,13 +29,15 @@ PACKAGES_DEBIAN="$PACKAGES_DEBIAN libope
 PACKAGES_DEBIAN="$PACKAGES_DEBIAN libsnmp-dev libiksemel-dev libcorosync-dev libnewt-dev libpopt-dev libical-dev libspandsp-dev libjack-dev"
 PACKAGES_DEBIAN="$PACKAGES_DEBIAN libresample-dev libc-client-dev binutils-dev libsrtp-dev libgsm1-dev libedit-dev doxygen libjansson-dev libldap-dev"
 PACKAGES_DEBIAN="$PACKAGES_DEBIAN subversion git libxslt1-dev automake libsrtp-dev libncurses5-dev python-dev"
-PACKAGES_RH="automake gcc gcc-c++ ncurses-devel openssl-devel libxml2-devel unixODBC-devel libcurl-devel libogg-devel libvorbis-devel speex-devel"
+PACKAGES_RH="automake bzip2 gcc gcc-c++ patch ncurses-devel openssl-devel libxml2-devel unixODBC-devel libcurl-devel libogg-devel libvorbis-devel speex-devel"
 PACKAGES_RH="$PACKAGES_RH spandsp-devel freetds-devel net-snmp-devel iksemel-devel corosynclib-devel newt-devel popt-devel libtool-ltdl-devel lua-devel"
 PACKAGES_RH="$PACKAGES_RH sqlite-devel libsqlite3x-devel radiusclient-ng-devel portaudio-devel postgresql-devel libresample-devel neon-devel libical-devel"
 PACKAGES_RH="$PACKAGES_RH openldap-devel gmime22-devel sqlite2-devel mysql-devel bluez-libs-devel jack-audio-connection-kit-devel gsm-devel libedit-devel libuuid-devel"
 PACKAGES_RH="$PACKAGES_RH jansson-devel libsrtp-devel pjproject-devel subversion git libxslt-devel python-devel"
 
 PACKAGES_OBSD="popt gmake wget libxml libogg libvorbis curl iksemel spandsp speex iodbc freetds-0.63p1-msdblib mysql-client gmime sqlite sqlite3 jack libxslt"
+PACKAGES_FBSD="autoconf gcc binutils popt gmake wget libxml2 libogg libvorbis curl iksemel spandsp speex unixODBC freetds-devel mysql55-client gmime2 sqlite"
+PACKAGES_FBSD="$PACKAGES_FBSD sqlite3 libxslt jansson e2fsprogs-libuuid gsm libsrtp libsamplerate"
 
 KVERS=`uname -r`
 
@@ -95,23 +97,45 @@ check_installed_pkgs() {
 	done
 }
 
+check_installed_fpkgs() {
+	for pack in "$@"
+	do
+		if [ `pkg info -a | grep $pack | wc -l` = 0 ]; then
+		echo $pack
+		fi
+	done
+}
+
 handle_debian() {
 	if ! [ -x "$(command -v aptitude)" ]; then
 		apt-get install aptitude
 	fi
 	extra_packs=`check_installed_debs $PACKAGES_DEBIAN`
 	$testcmd aptitude update
-	$testcmd aptitude install -y $extra_packs
+	if [ x"$extra_packs" != "x" ] ; then
+		$testcmd aptitude install -y $extra_packs
+	fi
 }
 
 handle_rh() {
 	extra_packs=`check_installed_rpms $PACKAGES_RH`
-	$testcmd yum install -y $extra_packs
+	if [ x"$extra_packs" != "x" ] ; then
+		$testcmd yum install -y $extra_packs
+	fi
 }
 
 handle_obsd() {
 	extra_packs=`check_installed_pkgs $PACKAGES_OBSD`
-	$testcmd pkg_add $extra_packs
+	if [ x"$extra_packs" != "x" ] ; then
+		$testcmd pkg_add $extra_packs
+	fi
+}
+
+handle_fbsd() {
+	extra_packs=`check_installed_fpkgs $PACKAGES_FBSD`
+	if [ x"$extra_packs" != "x" ] ; then
+		$testcmd pkg install -y $extra_packs
+	fi
 }
 
 install_unpackaged() {
@@ -151,7 +175,9 @@ install_unpackaged() {
 			cd libsrtp
 			git pull
 		fi
-		./configure CFLAGS=-fPIC && make libsrtp.a && make uninstall && make install
+		git checkout "1_5_x_throttle"
+		./configure --disable-debug --disable-stdout --enable-openssl
+		make shared_library uninstall install
 		cd ..
 		echo "/usr/local/lib" > /etc/ld.so.conf.d/usr_local.conf
 		/sbin/ldconfig
@@ -188,7 +214,7 @@ OS=`uname -s`
 unsupported_distro=''
 
 # A number of distributions we don't (yet?) support.
-if [ "$OS" != 'Linux' -a "$OS" != 'OpenBSD' ]; then
+if [ "$OS" != 'Linux' -a "$OS" != 'OpenBSD' -a "$OS" != 'FreeBSD' ]; then
 	echo >&2 "$0: Your OS ($OS) is currently not supported. Aborting."
 	exit 1
 fi
@@ -221,6 +247,8 @@ elif [ -r /etc/redhat-release ]; then
 	handle_rh
 elif [ "$OS" = 'OpenBSD' ]; then
 	handle_obsd
+elif [ "$OS" = 'FreeBSD' ]; then
+	handle_fbsd
 fi
 
 if ! in_test_mode; then
diff -urpN asterisk-13.9.1/contrib/scripts/safe_asterisk asterisk-13.17.0/contrib/scripts/safe_asterisk
--- asterisk-13.9.1/contrib/scripts/safe_asterisk	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/scripts/safe_asterisk	2017-07-12 13:12:08.000000000 +0200
@@ -120,13 +120,20 @@ if test -n "$TTY" && test "$TTY" != "no"
 		TTY=tty${TTY}
 	elif test -c /dev/vc/${TTY}; then
 		TTY=vc/${TTY}
+	elif test "$TTY" = "9"; then  # ignore default if it was untouched
+		# If there is no /dev/tty9 and not /dev/vc/9 we don't
+		# necessarily want to die at this point. Pretend that
+		# TTY wasn't set.
+		TTY=
 	else
 		message "Cannot find specified TTY (${TTY})"
 		exit 1
 	fi
-	ASTARGS="${ASTARGS} -vvvg"
-	if test "$CONSOLE" != "no"; then
-		ASTARGS="${ASTARGS} -c"
+	if test -n "$TTY"; then
+		ASTARGS="${ASTARGS} -vvvg"
+		if test "$CONSOLE" != "no"; then
+			ASTARGS="${ASTARGS} -c"
+		fi
 	fi
 fi
 
diff -urpN asterisk-13.9.1/contrib/scripts/sip_to_pjsip/astconfigparser.py asterisk-13.17.0/contrib/scripts/sip_to_pjsip/astconfigparser.py
--- asterisk-13.9.1/contrib/scripts/sip_to_pjsip/astconfigparser.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/scripts/sip_to_pjsip/astconfigparser.py	2017-07-12 13:12:08.000000000 +0200
@@ -1,3 +1,10 @@
+"""
+Copyright (C) 2016, Digium, Inc.
+
+This program is free software, distributed under the terms of
+the GNU General Public License Version 2.
+"""
+
 import re
 import itertools
 
@@ -44,6 +51,12 @@ class Section(MultiOrderedDict):
         """
         return cmp(self.id, other.id)
 
+    def __eq__(self, other):
+        """
+        Use self.id as means of determining equality
+        """
+        return self.id == other.id
+
     def get(self, key, from_self=True, from_templates=True,
             from_defaults=True):
         """
@@ -184,9 +197,17 @@ def remove_comment(line, is_comment):
         # otherwise it was an embedded comment so combine
         return ''.join([part[0].strip(), ' ', line]).rstrip(), False
 
-    # check for eol comment
-    return line.partition(COMMENT)[0].strip(), False
+    # find the first occurence of a comment that is not escaped
+    match = re.match(r'.*?([^\\];)', line)
+
+    if match:
+         # the end of where the real string is is where the comment starts
+         line = line[0:(match.end()-1)]
+    if line.startswith(";"):
+         # if the line is actually a comment just ignore it all
+         line = ""
 
+    return line.replace("\\", "").strip(), False
 
 def try_include(line):
     """
@@ -224,7 +245,7 @@ def try_section(line):
 
 def try_option(line):
     """Parses the line as an option, returning the key/value pair."""
-    data = re.split('=>?', line)
+    data = re.split('=>?', line, 1)
     # should split in two (key/val), but either way use first two elements
     return data[0].rstrip(), data[1].lstrip()
 
diff -urpN asterisk-13.9.1/contrib/scripts/sip_to_pjsip/sip_to_pjsip.py asterisk-13.17.0/contrib/scripts/sip_to_pjsip/sip_to_pjsip.py
--- asterisk-13.9.1/contrib/scripts/sip_to_pjsip/sip_to_pjsip.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/contrib/scripts/sip_to_pjsip/sip_to_pjsip.py	2017-07-12 13:12:08.000000000 +0200
@@ -1,10 +1,11 @@
 #!/usr/bin/python
 
 import optparse
+import socket
+import urlparse  # Python 2.7 required for Literal IPv6 Addresses
+
 import astdicts
 import astconfigparser
-import socket
-import re
 
 PREFIX = 'pjsip_'
 
@@ -16,7 +17,7 @@ PREFIX = 'pjsip_'
 def section_by_type(section, pjsip, type):
     """Finds a section based upon the given type, adding it if not found."""
     def __find_dict(mdicts, key, val):
-        """Given a list of mult-dicts, return the multi-dict that contains
+        """Given a list of multi-dicts, return the multi-dict that contains
            the given key/value pair."""
 
         def found(d):
@@ -54,10 +55,11 @@ def set_value(key=None, val=None, sectio
 
 
 def merge_value(key=None, val=None, section=None, pjsip=None,
-                nmapped=None, type='endpoint', section_to=None):
+                nmapped=None, type='endpoint', section_to=None,
+                key_to=None):
     """Merge values from the given section with those from the default."""
     def _merge_value(k, v, s, r, n):
-        merge_value(key if key else k, v, s, r, n, type, section_to)
+        merge_value(key if key else k, v, s, r, n, type, section_to, key_to)
 
     # if no value or section return the merge_value
     # function with the enclosed key and type
@@ -71,7 +73,8 @@ def merge_value(key=None, val=None, sect
         sect = sip.default(section)[0]
     # for each merged value add it to pjsip.conf
     for i in sect.get_merged(key):
-        set_value(key, i, section_to if section_to else section,
+        set_value(key_to if key_to else key, i,
+                  section_to if section_to else section,
                   pjsip, nmapped, type)
 
 
@@ -133,11 +136,14 @@ def set_timers(key, val, section, pjsip,
     found in sip.conf.
     """
     # pjsip.conf values can be yes/no, required, always
+    # 'required' is a new feature of chan_pjsip, which rejects
+    #            all SIP clients not supporting Session Timers
+    # 'Accept' is the default value of chan_sip and maps to 'yes'
+    # chan_sip ignores the case, for example 'session-timers=Refuse'
+    val = val.lower()
     if val == 'originate':
         set_value('timers', 'always', section, pjsip, nmapped)
-    elif val == 'accept':
-        set_value('timers', 'required', section, pjsip, nmapped)
-    elif val == 'never':
+    elif val == 'refuse':
         set_value('timers', 'no', section, pjsip, nmapped)
     else:
         set_value('timers', 'yes', section, pjsip, nmapped)
@@ -208,37 +214,42 @@ def from_progressinband(key, val, sectio
     set_value('inband_progress', val, section, pjsip, nmapped)
 
 
-def build_host(config, host, section, port_key):
+def build_host(config, host, section='general', port_key=None):
     """
     Returns a string composed of a host:port. This assumes that the host
-    may have a port as part of the initial value. The port_key is only used
-    if the host does not already have a port set on it.
-    Throws a LookupError if the key does not exist
+    may have a port as part of the initial value. The port_key overrides
+    a port in host, see parameter 'bindport' in chan_sip.
     """
-    port = None
-
     try:
         socket.inet_pton(socket.AF_INET6, host)
         if not host.startswith('['):
             # SIP URI will need brackets.
             host = '[' + host + ']'
-        else:
-            # If brackets are present, there may be a port as well
-            port = re.match('\[.*\]:(\d+)', host)
     except socket.error:
-        # No biggie. It's just not an IPv6 address
-        port = re.match('.*:(\d+)', host)
+        pass
 
-    result = host
+    # Literal IPv6 (like [::]), IPv4, or hostname
+    # does not work for IPv6 without brackets; case catched above
+    url = urlparse.urlparse('sip://' + host)
 
-    if not port:
+    if port_key:
         try:
             port = config.get(section, port_key)[0]
-            result += ':' + port
+            host = url.hostname # no port, but perhaps no brackets
+            try:
+                socket.inet_pton(socket.AF_INET6, host)
+                if not host.startswith('['):
+                    # SIP URI will need brackets.
+                    host = '[' + host + ']'
+            except socket.error:
+                pass
+            return host + ':' + port
         except LookupError:
             pass
 
-    return result
+    # Returns host:port, in brackets if required
+    # TODO Does not compress IPv6, for example 0:0:0:0:0:0:0:0 should get [::]
+    return url.netloc
 
 
 def from_host(key, val, section, pjsip, nmapped):
@@ -363,7 +374,7 @@ def from_dtlsenable(key, val, section, p
 ###############################################################################
 
 # options in pjsip.conf on an endpoint that have no sip.conf equivalent:
-# type, rtp_ipv6, 100rel, trust_id_outbound, aggregate_mwi,
+# type, 100rel, trust_id_outbound, aggregate_mwi,
 # connected_line_method
 
 # known sip.conf peer keys that can be mapped to a pjsip.conf section/key
@@ -383,9 +394,8 @@ peer_map = [
     ['session-timers',     set_timers],          # timers
     ['session-minse',      set_value('timers_min_se')],
     ['session-expires',    set_value('timers_sess_expires')],
-    ['externip',           set_value('external_media_address')],
-    ['externhost',         set_value('external_media_address')],
     # identify_by ?
+    ['canreinvite',        set_direct_media],    # direct_media alias
     ['directmedia',        set_direct_media],    # direct_media
                                                  # direct_media_method
                                                  # directed_media_glare_mitigation
@@ -396,7 +406,7 @@ peer_map = [
     ['trustpid',           set_value('trust_id_inbound')],
     ['sendrpid',           from_sendrpid],       # send_pai, send_rpid
     ['send_diversion',     set_value],
-    ['encrpytion',         set_media_encryption],
+    ['encryption',         set_media_encryption],
     ['avpf',               set_value('use_avpf')],
     ['recordonfeature',    set_record_on_feature],  # automixon
     ['recordofffeature',   set_record_off_feature],  # automixon
@@ -440,6 +450,9 @@ peer_map = [
 
     ['host',               from_host],           # contact, max_contacts
     ['qualifyfreq',        set_value('qualify_frequency', type='aor')],
+    ['maxexpiry',          set_value('maximum_expiration', type='aor')],
+    ['minexpiry',          set_value('minimum_expiration', type='aor')],
+    ['defaultexpiry',      set_value('default_expiration', type='aor')],
 
 ############################# maps to auth#####################################
 #        type = auth
@@ -454,9 +467,9 @@ peer_map = [
     ['permit',             merge_value(type='acl', section_to='acl')],
     ['deny',               merge_value(type='acl', section_to='acl')],
     ['acl',                merge_value(type='acl', section_to='acl')],
-    ['contactpermit',      merge_value('contact_permit', type='acl', section_to='acl')],
-    ['contactdeny',        merge_value('contact_deny', type='acl', section_to='acl')],
-    ['contactacl',         merge_value('contact_acl', type='acl', section_to='acl')],
+    ['contactpermit',      merge_value(type='acl', section_to='acl', key_to='contact_permit')],
+    ['contactdeny',        merge_value(type='acl', section_to='acl', key_to='contact_deny')],
+    ['contactacl',         merge_value(type='acl', section_to='acl', key_to='contact_acl')],
 
 ########################### maps to transport #################################
 #        type = transport
@@ -464,6 +477,7 @@ peer_map = [
 #        bind
 #        async_operations
 #        ca_list_file
+#        ca_list_path
 #        cert_file
 #        privkey_file
 #        password
@@ -499,81 +513,143 @@ peer_map = [
 ]
 
 
-def add_localnet(section, pjsip, nmapped):
+def split_hostport(addr):
     """
-    Adds localnet values from sip.conf's general section to a transport in
-    pjsip.conf. Ideally, we would have just created a template with the
-    localnet sections, but because this is a script, it's not hard to add
-    the same thing on to every transport.
+    Given an address in the form 'host:port' separate the host and port
+    components.
+    Returns a two-tuple of strings, (host, port). If no port is present in the
+    string, then the port section of the tuple is None.
     """
     try:
-        merge_value('local_net', sip.get('general', 'localnet')[0], 'general',
-                    pjsip, nmapped, 'transport', section)
-    except LookupError:
-        # No localnet options configured. No biggie!
+        socket.inet_pton(socket.AF_INET6, addr)
+        if not addr.startswith('['):
+            return (addr, None)
+    except socket.error:
         pass
 
+    # Literal IPv6 (like [::]), IPv4, or hostname
+    # does not work for IPv6 without brackets; case catched above
+    url = urlparse.urlparse('sip://' + addr)
+    # TODO Does not compress IPv6, for example 0:0:0:0:0:0:0:0 should get [::]
+    return (url.hostname, url.port)
+
 
-def set_transport_common(section, pjsip, nmapped):
+def set_transport_common(section, sip, pjsip, protocol, nmapped):
     """
     sip.conf has several global settings that in pjsip.conf apply to individual
     transports. This function adds these global settings to each individual
     transport.
 
     The settings included are:
+    externaddr (or externip)
+    externhost
+    externtcpport for TCP
+    externtlsport for TLS
     localnet
     tos_sip
     cos_sip
     """
+    try:
+        extern_addr = sip.multi_get('general', ['externaddr', 'externip',
+                                                'externhost'])[0]
+        host, port = split_hostport(extern_addr)
+        try:
+            port = sip.get('general', 'extern' + protocol + 'port')[0]
+        except LookupError:
+            pass
+        set_value('external_media_address', host, section, pjsip,
+                  nmapped, 'transport')
+        set_value('external_signaling_address', host, section, pjsip,
+                  nmapped, 'transport')
+        if port:
+            set_value('external_signaling_port', port, section, pjsip,
+                      nmapped, 'transport')
+    except LookupError:
+        pass
 
     try:
-        merge_value('local_net', sip.get('general', 'localnet')[0], 'general',
-                    pjsip, nmapped, 'transport', section)
+        merge_value('localnet', sip.get('general', 'localnet')[0], 'general',
+                    pjsip, nmapped, 'transport', section, "local_net")
     except LookupError:
         # No localnet options configured. Move on.
         pass
 
     try:
-        set_value('tos', sip.get('general', 'sip_tos')[0], 'general', pjsip,
-                  nmapped, 'transport', section)
+        set_value('tos', sip.get('general', 'tos_sip')[0], section, pjsip,
+                  nmapped, 'transport')
     except LookupError:
         pass
 
     try:
-        set_value('cos', sip.get('general', 'sip_cos')[0], 'general', pjsip,
-                  nmapped, 'transport', section)
+        set_value('cos', sip.get('general', 'cos_sip')[0], section, pjsip,
+                  nmapped, 'transport')
     except LookupError:
         pass
 
 
-def split_hostport(addr):
+def get_bind(sip, pjsip, protocol):
     """
-    Given an address in the form 'addr:port' separate the addr and port
-    components.
-    Returns a two-tuple of strings, (addr, port). If no port is present in the
-    string, then the port section of the tuple is None.
+    Given the protocol (udp, tcp, or tls), return
+    - the bind address, like [::] or 0.0.0.0
+    - name of the section to be created
     """
+    section = 'transport-' + protocol
+
+    # UDP cannot be disabled in chan_sip
+    if protocol != 'udp':
+        try:
+            enabled = sip.get('general', protocol + 'enable')[0]
+        except LookupError:
+            # No value means disabled by default. Don't create this transport
+            return (None, section)
+        if enabled != 'yes':
+            return (None, section)
+
     try:
-        socket.inet_pton(socket.AF_INET6, addr)
-        if not addr.startswith('['):
-            return (addr, None)
-        else:
-            # If brackets are present, there may be a port as well
-            match = re.match('\[(.*\)]:(\d+)', addr)
-            if match:
-                return (match.group(1), match.group(2))
-            else:
-                return (addr, None)
-    except socket.error:
+        bind = pjsip.get(section, 'bind')[0]
+        # The first run created an transport already but this
+        # server was not configured for IPv4/IPv6 Dual Stack
+        return (None, section)
+    except LookupError:
         pass
 
-    # IPv4 address or hostname
-    host, sep, port = addr.rpartition(':')
+    try:
+        bind = pjsip.get(section + '6', 'bind')[0]
+        # The first run created an IPv6 transport, because
+        # the server was configured with :: as bindaddr.
+        # Now, re-use its port and create the IPv4 transport
+        host, port = split_hostport(bind)
+        bind = '0.0.0.0'
+        if port:
+            bind += ':' + str(port)
+    except LookupError:
+        # This is the first run, no transport in pjsip exists.
+        try:
+            bind = sip.get('general', protocol + 'bindaddr')[0]
+        except LookupError:
+            if protocol == 'udp':
+                try:
+                    bind = sip.get('general', 'bindaddr')[0]
+                except LookupError:
+                    bind = '0.0.0.0'
+            else:
+                try:
+                    bind = pjsip.get('transport-udp6', 'bind')[0]
+                except LookupError:
+                    bind = pjsip.get('transport-udp', 'bind')[0]
+                # Only TCP reuses host:port of UDP, others reuse just host
+                if protocol == 'tls':
+                    bind, port = split_hostport(bind)
+        host, port = split_hostport(bind)
+        if host == '::':
+            section += '6'
 
-    if not sep and not port:
-        return (host, None)
+    if protocol == 'udp':
+        host = build_host(sip, bind, 'general', 'bindport')
     else:
-        return (host, port)
+        host = build_host(sip, bind)
+
+    return (host, section)
 
 
 def create_udp(sip, pjsip, nmapped):
@@ -583,32 +659,13 @@ def create_udp(sip, pjsip, nmapped):
 
     bindaddr (or udpbindaddr)
     bindport
-    externaddr (or externip)
-    externhost
     """
+    protocol = 'udp'
+    bind, section = get_bind(sip, pjsip, protocol)
 
-    try:
-        bind = sip.multi_get('general', ['udpbindaddr', 'bindaddr'])[0]
-    except LookupError:
-        bind = ''
-
-    bind = build_host(sip, bind, 'general', 'bindport')
-
-    try:
-        extern_addr = sip.multi_get('general', ['externaddr', 'externip',
-                                    'externhost'])[0]
-        host, port = split_hostport(extern_addr)
-        set_value('external_signaling_address', host, 'transport-udp', pjsip,
-                  nmapped, 'transport')
-        if port:
-            set_value('external_signaling_port', port, 'transport-udp', pjsip,
-                      nmapped, 'transport')
-    except LookupError:
-        pass
-
-    set_value('protocol', 'udp', 'transport-udp', pjsip, nmapped, 'transport')
-    set_value('bind', bind, 'transport-udp', pjsip, nmapped, 'transport')
-    set_transport_common('transport-udp', pjsip, nmapped)
+    set_value('protocol', protocol, section, pjsip, nmapped, 'transport')
+    set_value('bind', bind, section, pjsip, nmapped, 'transport')
+    set_transport_common(section, sip, pjsip, protocol, nmapped)
 
 
 def create_tcp(sip, pjsip, nmapped):
@@ -617,132 +674,71 @@ def create_tcp(sip, pjsip, nmapped):
     on the following settings from sip.conf:
 
     tcpenable
-    tcpbindaddr
-    externtcpport
+    tcpbindaddr (or bindaddr)
     """
-
-    try:
-        enabled = sip.get('general', 'tcpenable')[0]
-    except:
-        # No value means disabled by default. No need for a tranport
+    protocol = 'tcp'
+    bind, section = get_bind(sip, pjsip, protocol)
+    if not bind:
         return
 
-    if enabled == 'no':
-        return
-
-    try:
-        bind = sip.get('general', 'tcpbindaddr')[0]
-        bind = build_host(sip, bind, 'general', 'bindport')
-    except LookupError:
-        # No tcpbindaddr means to default to the udpbindaddr
-        bind = pjsip.get('transport-udp', 'bind')[0]
-
-    try:
-        extern_addr = sip.multi_get('general', ['externaddr', 'externip',
-                                    'externhost'])[0]
-        host, port = split_hostport(extern_addr)
-        try:
-            tcpport = sip.get('general', 'externtcpport')[0]
-        except:
-            tcpport = port
-        set_value('external_signaling_address', host, 'transport-tcp', pjsip,
-                  nmapped, 'transport')
-        if tcpport:
-            set_value('external_signaling_port', tcpport, 'transport-tcp',
-                      pjsip, nmapped, 'transport')
-    except LookupError:
-        pass
-
-    set_value('protocol', 'tcp', 'transport-tcp', pjsip, nmapped, 'transport')
-    set_value('bind', bind, 'transport-tcp', pjsip, nmapped, 'transport')
-    set_transport_common('transport-tcp', pjsip, nmapped)
-
-
-def set_tls_bindaddr(val, pjsip, nmapped):
-    """
-    Creates the TCP bind address. This has two possible methods of
-    working:
-    Use the 'tlsbindaddr' option from sip.conf directly if it has both
-    an address and port. If no port is present, use 5061
-    If there is no 'tlsbindaddr' option present in sip.conf, use the
-    previously-established UDP bind address and port 5061
-    """
-    try:
-        bind = sip.get('general', 'tlsbindaddr')[0]
-        explicit = True
-    except LookupError:
-        # No tlsbindaddr means to default to the bindaddr but with standard TLS
-        # port
-        bind = pjsip.get('transport-udp', 'bind')[0]
-        explicit = False
-
-    matchv4 = re.match('\d+\.\d+\.\d+\.\d+:\d+', bind)
-    matchv6 = re.match('\[.*\]:d+', bind)
-    if matchv4 or matchv6:
-        if explicit:
-            # They provided a port. We'll just use it.
-            set_value('bind', bind, 'transport-tls', pjsip, nmapped,
-                      'transport')
-            return
-        else:
-            # Need to strip the port from the UDP address
-            index = bind.rfind(':')
-            bind = bind[:index]
-
-    # Reaching this point means either there was no port provided or we
-    # stripped the port off. We need to add on the default 5061 port
+    set_value('protocol', protocol, section, pjsip, nmapped, 'transport')
+    set_value('bind', bind, section, pjsip, nmapped, 'transport')
+    set_transport_common(section, sip, pjsip, protocol, nmapped)
 
-    bind += ':5061'
 
-    set_value('bind', bind, 'transport-tls', pjsip, nmapped, 'transport')
+def set_tls_cert_file(val, pjsip, section, nmapped):
+    """Sets cert_file based on sip.conf tlscertfile"""
+    set_value('cert_file', val, section, pjsip, nmapped,
+              'transport')
 
 
-def set_tls_private_key(val, pjsip, nmapped):
+def set_tls_private_key(val, pjsip, section, nmapped):
     """Sets privkey_file based on sip.conf tlsprivatekey or sslprivatekey"""
-    set_value('priv_key_file', val, 'transport-tls', pjsip, nmapped,
+    set_value('priv_key_file', val, section, pjsip, nmapped,
               'transport')
 
 
-def set_tls_cipher(val, pjsip, nmapped):
+def set_tls_cipher(val, pjsip, section, nmapped):
     """Sets cipher based on sip.conf tlscipher or sslcipher"""
-    set_value('cipher', val, 'transport-tls', pjsip, nmapped, 'transport')
+    set_value('cipher', val, section, pjsip, nmapped, 'transport')
 
 
-def set_tls_cafile(val, pjsip, nmapped):
+def set_tls_cafile(val, pjsip, section, nmapped):
     """Sets ca_list_file based on sip.conf tlscafile"""
-    set_value('ca_list_file', val, 'transport-tls', pjsip, nmapped,
+    set_value('ca_list_file', val, section, pjsip, nmapped,
+              'transport')
+
+
+def set_tls_capath(val, pjsip, section, nmapped):
+    """Sets ca_list_path based on sip.conf tlscapath"""
+    set_value('ca_list_path', val, section, pjsip, nmapped,
               'transport')
 
 
-def set_tls_verifyclient(val, pjsip, nmapped):
+def set_tls_verifyclient(val, pjsip, section, nmapped):
     """Sets verify_client based on sip.conf tlsverifyclient"""
-    set_value('verify_client', val, 'transport-tls', pjsip, nmapped,
+    set_value('verify_client', val, section, pjsip, nmapped,
               'transport')
 
 
-def set_tls_verifyserver(val, pjsip, nmapped):
+def set_tls_verifyserver(val, pjsip, section, nmapped):
     """Sets verify_server based on sip.conf tlsdontverifyserver"""
 
     if val == 'no':
-        set_value('verify_server', 'yes', 'transport-tls', pjsip, nmapped,
+        set_value('verify_server', 'yes', section, pjsip, nmapped,
                   'transport')
     else:
-        set_value('verify_server', 'no', 'transport-tls', pjsip, nmapped,
+        set_value('verify_server', 'no', section, pjsip, nmapped,
                   'transport')
 
 
-def set_tls_method(val, pjsip, nmapped):
-    """Sets method based on sip.conf tlsclientmethod or sslclientmethod"""
-    set_value('method', val, 'transport-tls', pjsip, nmapped, 'transport')
-
-
 def create_tls(sip, pjsip, nmapped):
     """
     Creates a 'transport-tls' section in pjsip.conf based on the following
     settings from sip.conf:
 
     tlsenable (or sslenable)
-    tlsbindaddr (or sslbindaddr)
+    tlsbindaddr (or sslbindaddr or bindaddr)
     tlsprivatekey (or sslprivatekey)
     tlscipher (or sslcipher)
     tlscafile
@@ -752,50 +748,53 @@ def create_tls(sip, pjsip, nmapped):
     tlsdontverifyserver
     tlsclientmethod (or sslclientmethod)
     """
+    protocol = 'tls'
+    bind, section = get_bind(sip, pjsip, protocol)
+    if not bind:
+        return
+
+    set_value('protocol', protocol, section, pjsip, nmapped, 'transport')
+    set_value('bind', bind, section, pjsip, nmapped, 'transport')
+    set_transport_common(section, sip, pjsip, protocol, nmapped)
 
     tls_map = [
-        (['tlsbindaddr', 'sslbindaddr'], set_tls_bindaddr),
+        (['tlscertfile', 'sslcert', 'tlscert'], set_tls_cert_file),
         (['tlsprivatekey', 'sslprivatekey'], set_tls_private_key),
         (['tlscipher', 'sslcipher'], set_tls_cipher),
         (['tlscafile'], set_tls_cafile),
+        (['tlscapath', 'tlscadir'], set_tls_capath),
         (['tlsverifyclient'], set_tls_verifyclient),
-        (['tlsdontverifyserver'], set_tls_verifyserver),
-        (['tlsclientmethod', 'sslclientmethod'], set_tls_method)
+        (['tlsdontverifyserver'], set_tls_verifyserver)
     ]
 
-    try:
-        enabled = sip.multi_get('general', ['tlsenable', 'sslenable'])[0]
-    except LookupError:
-        # Not enabled. Don't create a transport
-        return
-
-    if enabled == 'no':
-        return
-
-    set_value('protocol', 'tls', 'transport-tls', pjsip, nmapped, 'transport')
-
     for i in tls_map:
         try:
-            i[1](sip.multi_get('general', i[0])[0], pjsip, nmapped)
+            i[1](sip.multi_get('general', i[0])[0], pjsip, section, nmapped)
         except LookupError:
             pass
 
-    set_transport_common('transport-tls', pjsip, nmapped)
     try:
-        extern_addr = sip.multi_get('general', ['externaddr', 'externip',
-                                    'externhost'])[0]
-        host, port = split_hostport(extern_addr)
-        try:
-            tlsport = sip.get('general', 'externtlsport')[0]
-        except:
-            tlsport = port
-        set_value('external_signaling_address', host, 'transport-tls', pjsip,
-                  nmapped, 'transport')
-        if tlsport:
-            set_value('external_signaling_port', tlsport, 'transport-tls',
-                      pjsip, nmapped, 'transport')
+        method = sip.multi_get('general', ['tlsclientmethod',
+                                           'sslclientmethod'])[0]
+        if section != 'transport-' + protocol + '6':  # print only once
+            print 'In chan_sip, you specified the TLS version. With chan_sip,' \
+                  ' this was just for outbound client connections. In' \
+                  ' chan_pjsip, this value is for client and server. Instead,' \
+                  ' consider not to specify \'tlsclientmethod\' for chan_sip' \
+                  ' and \'method = sslv23\' for chan_pjsip.'
     except LookupError:
-        pass
+        """
+        OpenSSL emerged during the 90s. SSLv2 and SSLv3 were the only
+        existing methods at that time. The OpenSSL project continued. And as
+        of today (OpenSSL 1.0.2) this does not start SSLv2 and SSLv3 anymore
+        but TLSv1.0 and v1.2. Or stated differently: This method should
+        have been called 'method = secure' or 'method = automatic' back in
+        the 90s. The PJProject did not realize this and uses 'tlsv1' as
+        default when unspecified, which disables TLSv1.2. chan_sip used
+        'sslv23' as default when unspecified, which gives TLSv1.0 and v1.2.
+        """
+        method = 'sslv23'
+    set_value('method', method, section, pjsip, nmapped, 'transport')
 
 
 def map_transports(sip, pjsip, nmapped):
@@ -805,23 +804,29 @@ def map_transports(sip, pjsip, nmapped):
     configuration sections in pjsip.conf.
 
     sip.conf only allows a single UDP transport, TCP transport,
-    and TLS transport. As such, the mapping into PJSIP can be made
-    consistent by defining three sections:
+    and TLS transport for each IP version. As such, the mapping
+    into PJSIP can be made consistent by defining six sections:
 
+    transport-udp6
     transport-udp
+    transport-tcp6
     transport-tcp
+    transport-tls6
     transport-tls
 
     To accommodate the default behaviors in sip.conf, we'll need to
-    create the UDP transport first, followed by the TCP and TLS transports.
+    create the UDP transports first, followed by the TCP and TLS transports.
     """
 
     # First create a UDP transport. Even if no bind parameters were provided
     # in sip.conf, chan_sip would always bind to UDP 0.0.0.0:5060
     create_udp(sip, pjsip, nmapped)
+    create_udp(sip, pjsip, nmapped)
 
     # TCP settings may be dependent on UDP settings, so do it second.
     create_tcp(sip, pjsip, nmapped)
+    create_tcp(sip, pjsip, nmapped)
+    create_tls(sip, pjsip, nmapped)
     create_tls(sip, pjsip, nmapped)
 
 
@@ -907,6 +912,17 @@ class Registration:
         the right of the user, then finish by using rpartition calls to remove
         everything to the left of the user.
         """
+        self.peer = ''
+        self.protocol = 'udp'
+        protocols = ['udp', 'tcp', 'tls']
+        for protocol in protocols:
+            position = user_part.find(protocol + '://')
+            if -1 < position:
+                post_transport = user_part[position + 6:]
+                self.peer, sep, self.protocol = user_part[:position + 3].rpartition('?')
+                user_part = post_transport
+                break
+
         colons = user_part.count(':')
         if (colons == 3):
             # :domainport:secret:authuser
@@ -927,11 +943,7 @@ class Registration:
             # Invalid setting
             raise
 
-        pre_domain, sep, self.domain = pre_auth.partition('@')
-        self.peer, sep, post_peer = pre_domain.rpartition('?')
-        transport, sep, self.user = post_peer.rpartition('://')
-
-        self.protocol = transport if transport else 'udp'
+        self.user, sep, self.domain = pre_auth.partition('@')
 
     def write(self, pjsip, nmapped):
         """
@@ -981,9 +993,8 @@ class Registration:
         if hasattr(self, 'secret') and self.secret:
             set_value('password', self.secret, auth_section, pjsip, nmapped,
                       'auth')
-            if hasattr(self, 'authuser'):
-                set_value('username', self.authuser or self.user, auth_section,
-                          pjsip, nmapped, 'auth')
+            set_value('username', self.authuser if hasattr(self, 'authuser')
+                      else self.user, auth_section, pjsip, nmapped, 'auth')
             set_value('outbound_auth', auth_section, section, pjsip, nmapped,
                       'registration')
 
@@ -1010,7 +1021,7 @@ class Registration:
 
         if self.outbound_proxy:
             set_value('outboundproxy', self.outbound_proxy, section, pjsip,
-                      nmapped, 'registartion')
+                      nmapped, 'registration')
 
 
 def map_registrations(sip, pjsip, nmapped):
@@ -1080,6 +1091,41 @@ def find_non_mapped(sections, nmapped):
             pass
 
 
+def map_system(sip, pjsip, nmapped):
+    section = 'system' # Just a label; you as user can change that
+    type = 'system' # Not a label, therefore not the same as section
+
+    try:
+        user_agent = sip.get('general', 'useragent')[0]
+        set_value('user_agent', user_agent, 'global', pjsip, nmapped, 'global')
+    except LookupError:
+        pass
+
+    try:
+        useroption_parsing = sip.get('general', 'legacy_useroption_parsing')[0]
+        set_value('ignore_uri_user_options', useroption_parsing, 'global', pjsip, nmapped, 'global')
+    except LookupError:
+        pass
+
+    try:
+        timer_t1 = sip.get('general', 'timert1')[0]
+        set_value('timer_t1', timer_t1, section, pjsip, nmapped, type)
+    except LookupError:
+        pass
+
+    try:
+        timer_b = sip.get('general', 'timerb')[0]
+        set_value('timer_b', timer_b, section, pjsip, nmapped, type)
+    except LookupError:
+        pass
+
+    try:
+        compact_headers = sip.get('general', 'compactheaders')[0]
+        set_value('compact_headers', compact_headers, section, pjsip, nmapped, type)
+    except LookupError:
+        pass
+
+
 def convert(sip, filename, non_mappings, include):
     """
     Entry point for configuration file conversion. This
@@ -1092,6 +1138,7 @@ def convert(sip, filename, non_mappings,
     nmapped = non_mapped(non_mappings[filename])
     if not include:
         # Don't duplicate transport and registration configs
+        map_system(sip, pjsip, nmapped)
         map_transports(sip, pjsip, nmapped)
         map_registrations(sip, pjsip, nmapped)
     map_auth(sip, pjsip, nmapped)
@@ -1141,7 +1188,7 @@ def cli_options():
     """
     global PREFIX
     usage = "usage: %prog [options] [input-file [output-file]]\n\n" \
-		"Converts the chan_sip configuration input-file to the chan_pjsip output-file.\n"\
+        "Converts the chan_sip configuration input-file to the chan_pjsip output-file.\n" \
         "The input-file defaults to 'sip.conf'.\n" \
         "The output-file defaults to 'pjsip.conf'."
     parser = optparse.OptionParser(usage=usage)
@@ -1160,6 +1207,8 @@ if __name__ == "__main__":
     sip_filename, pjsip_filename = cli_options()
     # configuration parser for sip.conf
     sip = astconfigparser.MultiOrderedConfigParser()
+    print 'Please, report any issue at:'
+    print '    https://issues.asterisk.org/'
     print 'Reading', sip_filename
     sip.read(sip_filename)
     print 'Converting to PJSIP...'
diff -urpN asterisk-13.9.1/doc/appdocsxml.dtd asterisk-13.17.0/doc/appdocsxml.dtd
--- asterisk-13.9.1/doc/appdocsxml.dtd	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/doc/appdocsxml.dtd	2017-07-12 13:12:08.000000000 +0200
@@ -67,7 +67,7 @@
   <!ELEMENT field (#PCDATA)>
   <!ATTLIST field name CDATA #REQUIRED>
 
-  <!ELEMENT info (para|note|warning|variablelist|enumlist|info|xi:include)*>
+  <!ELEMENT info (para|example|note|warning|variablelist|enumlist|info|xi:include)*>
   <!ATTLIST info name CDATA #REQUIRED>
   <!ATTLIST info language CDATA #REQUIRED>
   <!ATTLIST info tech CDATA #REQUIRED>
diff -urpN asterisk-13.9.1/doc/appdocsxml.xslt asterisk-13.17.0/doc/appdocsxml.xslt
--- asterisk-13.9.1/doc/appdocsxml.xslt	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/doc/appdocsxml.xslt	2017-07-12 13:12:08.000000000 +0200
@@ -6,7 +6,10 @@
 
     <xsl:template match="node()|@*">
         <xsl:copy>
-            <xsl:apply-templates select="node()|@*"/>
+            <xsl:for-each select="node()|@*">
+                <xsl:sort select="@tech"/>
+                <xsl:apply-templates select="."/>
+            </xsl:for-each>
         </xsl:copy>
     </xsl:template>
 
@@ -142,5 +145,25 @@
             </xsl:attribute>
             <para>Number of channels in the bridge</para>
         </xsl:element>
+        <xsl:element name="parameter">
+            <xsl:attribute name="name">
+                <xsl:value-of select="concat(@prefix, 'BridgeVideoSourceMode')" />
+            </xsl:attribute>
+            <enumlist>
+                <enum name="none"/>
+                <enum name="talker"/>
+                <enum name="single"/>
+            </enumlist>
+            <para>The video source mode for the bridge.</para>
+        </xsl:element>
+        <xsl:element name="parameter">
+            <xsl:attribute name="required">
+                false
+            </xsl:attribute>
+            <xsl:attribute name="name">
+                <xsl:value-of select="concat(@prefix, 'BridgeVideoSource')" />
+            </xsl:attribute>
+            <para>If there is a video source for the bridge, the unique ID of the channel that is the video source.</para>
+        </xsl:element>
     </xsl:template>
 </xsl:stylesheet>
diff -urpN asterisk-13.9.1/formats/format_g719.c asterisk-13.17.0/formats/format_g719.c
--- asterisk-13.9.1/formats/format_g719.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_g719.c	2017-07-12 13:12:08.000000000 +0200
@@ -47,8 +47,16 @@ static struct ast_frame *g719read(struct
 
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = BYTES_TO_SAMPLES(res);
diff -urpN asterisk-13.9.1/formats/format_g723.c asterisk-13.17.0/formats/format_g723.c
--- asterisk-13.9.1/formats/format_g723.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_g723.c	2017-07-12 13:12:08.000000000 +0200
@@ -66,8 +66,17 @@ static struct ast_frame *g723_read(struc
 	}
 	/* Read the data into the buffer */
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, size);
-	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != size) {
-		ast_log(LOG_WARNING, "Short read (%d of %d bytes) (%s)!\n", res, size, strerror(errno));
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = 240;
@@ -144,7 +153,7 @@ static int load_module(void)
 	g723_1_f.format = ast_format_g723;
 
 	if (ast_format_def_register(&g723_1_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_g726.c asterisk-13.17.0/formats/format_g726.c
--- asterisk-13.9.1/formats/format_g726.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_g726.c	2017-07-12 13:12:08.000000000 +0200
@@ -126,8 +126,16 @@ static struct ast_frame *g726_read(struc
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, frame_size[fs->rate]);
 	s->fr.samples = 8 * FRAME_TIME;
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples;
@@ -223,29 +231,30 @@ static struct ast_format_def f[] = {
 	{	.desc_size = 0 }	/* terminator */
 };
 
-static int load_module(void)
+static int unload_module(void)
 {
 	int i;
 
 	for (i = 0; f[i].desc_size ; i++) {
-		f[i].format = ast_format_g726;
-		if (ast_format_def_register(&f[i])) {	/* errors are fatal */
-			ast_log(LOG_WARNING, "Failed to register format %s.\n", f[i].name);
-			return AST_MODULE_LOAD_FAILURE;
-		}
+		if (ast_format_def_unregister(f[i].name))
+			ast_log(LOG_WARNING, "Failed to unregister format %s.\n", f[i].name);
 	}
-	return AST_MODULE_LOAD_SUCCESS;
+	return(0);
 }
 
-static int unload_module(void)
+static int load_module(void)
 {
 	int i;
 
 	for (i = 0; f[i].desc_size ; i++) {
-		if (ast_format_def_unregister(f[i].name))
-			ast_log(LOG_WARNING, "Failed to unregister format %s.\n", f[i].name);
+		f[i].format = ast_format_g726;
+		if (ast_format_def_register(&f[i])) {	/* errors are fatal */
+			ast_log(LOG_WARNING, "Failed to register format %s.\n", f[i].name);
+			unload_module();
+			return AST_MODULE_LOAD_DECLINE;
+		}
 	}
-	return(0);
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Raw G.726 (16/24/32/40kbps) data",
diff -urpN asterisk-13.9.1/formats/format_g729.c asterisk-13.17.0/formats/format_g729.c
--- asterisk-13.9.1/formats/format_g729.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_g729.c	2017-07-12 13:12:08.000000000 +0200
@@ -19,7 +19,7 @@
 /*! \file
  *
  * \brief Save to raw, headerless G729 data.
- * \note This is not an encoder/decoder. The codec fo g729 is only
+ * \note This is not an encoder/decoder. The codec for g729 is only
  * available with a commercial license from Digium, due to patent
  * restrictions. Check http://www.digium.com for information.
  * \arg Extensions: g729 
@@ -53,8 +53,16 @@ static struct ast_frame *g729_read(struc
 	s->fr.samples = G729A_SAMPLES;
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res && (res != 10))	/* XXX what for ? */
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples;
@@ -140,7 +148,7 @@ static int load_module(void)
 {
 	g729_f.format = ast_format_g729;
 	if (ast_format_def_register(&g729_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_gsm.c asterisk-13.17.0/formats/format_gsm.c
--- asterisk-13.9.1/formats/format_gsm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_gsm.c	2017-07-12 13:12:08.000000000 +0200
@@ -57,10 +57,18 @@ static struct ast_frame *gsm_read(struct
 {
 	int res;
 
-	AST_FRAME_SET_BUFFER(&(s->fr), s->buf, AST_FRIENDLY_OFFSET, GSM_FRAME_SIZE)
+	AST_FRAME_SET_BUFFER(&(s->fr), s->buf, AST_FRIENDLY_OFFSET, GSM_FRAME_SIZE);
 	if ((res = fread(s->fr.data.ptr, 1, GSM_FRAME_SIZE, s->f)) != GSM_FRAME_SIZE) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), GSM_FRAME_SIZE, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = GSM_SAMPLES;
@@ -133,7 +141,7 @@ static int gsm_seek(struct ast_filestrea
 		int i;
 		fseeko(fs->f, 0, SEEK_END);
 		for (i=0; i< (offset - max) / GSM_FRAME_SIZE; i++) {
-			if (!fwrite(gsm_silence, 1, GSM_FRAME_SIZE, fs->f)) {
+			if (fwrite(gsm_silence, 1, GSM_FRAME_SIZE, fs->f) != GSM_FRAME_SIZE) {
 				ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 			}
 		}
@@ -185,7 +193,7 @@ static int load_module(void)
 {
 	gsm_f.format = ast_format_gsm;
 	if (ast_format_def_register(&gsm_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_h263.c asterisk-13.17.0/formats/format_h263.c
--- asterisk-13.9.1/formats/format_h263.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_h263.c	2017-07-12 13:12:08.000000000 +0200
@@ -60,7 +60,7 @@ static int h263_open(struct ast_filestre
 {
 	unsigned int ts;
 
-	if (fread(&ts, 1, sizeof(ts), s->f) < sizeof(ts)) {
+	if (fread(&ts, 1, sizeof(ts), s->f) != sizeof(ts)) {
 		ast_log(LOG_WARNING, "Empty file!\n");
 		return -1;
 	}
@@ -76,7 +76,7 @@ static struct ast_frame *h263_read(struc
 	struct h263_desc *fs = (struct h263_desc *)s->_private;
 
 	/* Send a frame from the file to the appropriate channel */
-	if ((res = fread(&len, 1, sizeof(len), s->f)) < 1)
+	if ((res = fread(&len, 1, sizeof(len), s->f)) != sizeof(len))
 		return NULL;
 	len = ntohs(len);
 	mark = (len & FRAME_ENDED) ? 1 : 0;
@@ -87,8 +87,16 @@ static struct ast_frame *h263_read(struc
 	}
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, len);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	s->fr.samples = fs->lastts;	/* XXX what ? */
@@ -172,7 +180,7 @@ static int load_module(void)
 {
 	h263_f.format = ast_format_h263;
 	if (ast_format_def_register(&h263_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_h264.c asterisk-13.17.0/formats/format_h264.c
--- asterisk-13.9.1/formats/format_h264.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_h264.c	2017-07-12 13:12:08.000000000 +0200
@@ -52,7 +52,7 @@ struct h264_desc {
 static int h264_open(struct ast_filestream *s)
 {
 	unsigned int ts;
-	if (fread(&ts, 1, sizeof(ts), s->f) < sizeof(ts)) {
+	if (fread(&ts, 1, sizeof(ts), s->f) != sizeof(ts)) {
 		ast_log(LOG_WARNING, "Empty file!\n");
 		return -1;
 	}
@@ -68,7 +68,7 @@ static struct ast_frame *h264_read(struc
 	struct h264_desc *fs = (struct h264_desc *)s->_private;
 
 	/* Send a frame from the file to the appropriate channel */
-	if ((res = fread(&len, 1, sizeof(len), s->f)) < 1)
+	if ((res = fread(&len, 1, sizeof(len), s->f)) != sizeof(len))
 		return NULL;
 	len = ntohs(len);
 	mark = (len & FRAME_ENDED) ? 1 : 0;
@@ -79,8 +79,16 @@ static struct ast_frame *h264_read(struc
 	}
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, len);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d of %d) (%s)!\n", res, len, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	s->fr.samples = fs->lastts;
@@ -165,7 +173,7 @@ static int load_module(void)
 {
 	h264_f.format = ast_format_h264;
 	if (ast_format_def_register(&h264_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_ilbc.c asterisk-13.17.0/formats/format_ilbc.c
--- asterisk-13.9.1/formats/format_ilbc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_ilbc.c	2017-07-12 13:12:08.000000000 +0200
@@ -51,8 +51,16 @@ static struct ast_frame *ilbc_read(struc
 	/* Send a frame from the file to the appropriate channel */
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, ILBC_BUF_SIZE);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = ILBC_SAMPLES;
@@ -137,7 +145,7 @@ static int load_module(void)
 {
 	ilbc_f.format = ast_format_ilbc;
 	if (ast_format_def_register(&ilbc_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_jpeg.c asterisk-13.17.0/formats/format_jpeg.c
--- asterisk-13.9.1/formats/format_jpeg.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_jpeg.c	2017-07-12 13:12:08.000000000 +0200
@@ -98,7 +98,7 @@ static int load_module(void)
 {
 	jpeg_format.format = ast_format_jpeg;
 	if (ast_image_register(&jpeg_format))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_ogg_vorbis.c asterisk-13.17.0/formats/format_ogg_vorbis.c
--- asterisk-13.9.1/formats/format_ogg_vorbis.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_ogg_vorbis.c	2017-07-12 13:12:08.000000000 +0200
@@ -160,6 +160,7 @@ static int ogg_vorbis_rewrite(struct ast
 
 	if (vorbis_encode_init_vbr(&tmp->vi, 1, DEFAULT_SAMPLE_RATE, 0.4)) {
 		ast_log(LOG_ERROR, "Unable to initialize Vorbis encoder!\n");
+		vorbis_info_clear(&tmp->vi);
 		return -1;
 	}
 
@@ -182,10 +183,10 @@ static int ogg_vorbis_rewrite(struct ast
 	while (!tmp->eos) {
 		if (ogg_stream_flush(&tmp->os, &tmp->og) == 0)
 			break;
-		if (!fwrite(tmp->og.header, 1, tmp->og.header_len, s->f)) {
+		if (fwrite(tmp->og.header, 1, tmp->og.header_len, s->f) != tmp->og.header_len) {
 			ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 		}
-		if (!fwrite(tmp->og.body, 1, tmp->og.body_len, s->f)) {
+		if (fwrite(tmp->og.body, 1, tmp->og.body_len, s->f) != tmp->og.body_len) {
 			ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 		}
 		if (ogg_page_eos(&tmp->og))
@@ -212,10 +213,10 @@ static void write_stream(struct ogg_vorb
 				if (ogg_stream_pageout(&s->os, &s->og) == 0) {
 					break;
 				}
-				if (!fwrite(s->og.header, 1, s->og.header_len, f)) {
-				ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
+				if (fwrite(s->og.header, 1, s->og.header_len, f) != s->og.header_len) {
+					ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 				}
-				if (!fwrite(s->og.body, 1, s->og.body_len, f)) {
+				if (fwrite(s->og.body, 1, s->og.body_len, f) != s->og.body_len) {
 					ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 				}
 				if (ogg_page_eos(&s->og)) {
@@ -275,6 +276,13 @@ static void ogg_vorbis_close(struct ast_
 		 * and write out the rest of the data */
 		vorbis_analysis_wrote(&s->vd, 0);
 		write_stream(s, fs->f);
+
+		/* Cleanup */
+		ogg_stream_clear(&s->os);
+		vorbis_block_clear(&s->vb);
+		vorbis_dsp_clear(&s->vd);
+		vorbis_comment_clear(&s->vc);
+		vorbis_info_clear(&s->vi);
 	} else {
 		/* clear OggVorbis_File handle */
 		ov_clear(&s->ov_f);
@@ -425,7 +433,7 @@ static int load_module(void)
 {
 	vorbis_f.format = ast_format_slin;
 	if (ast_format_def_register(&vorbis_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_pcm.c asterisk-13.17.0/formats/format_pcm.c
--- asterisk-13.9.1/formats/format_pcm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_pcm.c	2017-07-12 13:12:08.000000000 +0200
@@ -85,9 +85,17 @@ static struct ast_frame *pcm_read(struct
 	/* Send a frame from the file to the appropriate channel */
 
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);
-	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) < 1) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	s->fr.datalen = res;
@@ -142,9 +150,10 @@ static int pcm_seek(struct ast_filestrea
 		const char *src = (ast_format_cmp(fs->fmt->format, ast_format_alaw) == AST_FORMAT_CMP_EQUAL) ? alaw_silence : ulaw_silence;
 
 		while (left) {
-			size_t written = fwrite(src, 1, (left > BUF_SIZE) ? BUF_SIZE : left, fs->f);
-			if (written == -1)
+			size_t written = fwrite(src, 1, MIN(left, BUF_SIZE), fs->f);
+			if (written < MIN(left, BUF_SIZE)) {
 				break;	/* error */
+			}
 			left -= written;
 		}
 		ret = 0; /* successful */
@@ -212,7 +221,10 @@ static int pcm_write(struct ast_filestre
 				to_write = fpos - cur;
 				if (to_write > sizeof(buf))
 					to_write = sizeof(buf);
-				fwrite(buf, 1, to_write, fs->f);
+				if (fwrite(buf, 1, to_write, fs->f) != to_write) {
+					ast_log(LOG_ERROR, "Failed to write to file: %s\n", strerror(errno));
+					return -1;
+				}
 				cur += to_write;
 			}
 		}
@@ -233,7 +245,7 @@ static int pcm_write(struct ast_filestre
 
 /* SUN .au support routines */
 
-#define AU_HEADER_SIZE		24
+#define MIN_AU_HEADER_SIZE	24
 #define AU_HEADER(var)		uint32_t var[6]
 
 #define AU_HDR_MAGIC_OFF	0
@@ -268,7 +280,11 @@ static int pcm_write(struct ast_filestre
 #endif
 #endif
 
-static int check_header(FILE *f)
+struct au_desc {
+	uint32_t hdr_size;
+};
+
+static int check_header(struct ast_filestream *fs)
 {
 	AU_HEADER(header);
 	uint32_t magic;
@@ -278,7 +294,10 @@ static int check_header(FILE *f)
 	uint32_t sample_rate;
 	uint32_t channels;
 
-	if (fread(header, 1, AU_HEADER_SIZE, f) != AU_HEADER_SIZE) {
+	struct au_desc *desc = fs->_private;
+	FILE *f = fs->f;
+
+	if (fread(header, 1, MIN_AU_HEADER_SIZE, f) != MIN_AU_HEADER_SIZE) {
 		ast_log(LOG_WARNING, "Read failed (header)\n");
 		return -1;
 	}
@@ -287,8 +306,8 @@ static int check_header(FILE *f)
 		ast_log(LOG_WARNING, "Bad magic: 0x%x\n", magic);
 	}
 	hdr_size = ltohl(header[AU_HDR_HDR_SIZE_OFF]);
-	if (hdr_size < AU_HEADER_SIZE) {
-		hdr_size = AU_HEADER_SIZE;
+	if (hdr_size < MIN_AU_HEADER_SIZE) {
+		hdr_size = MIN_AU_HEADER_SIZE;
 	}
 /*	data_size = ltohl(header[AU_HDR_DATA_SIZE_OFF]); */
 	encoding = ltohl(header[AU_HDR_ENCODING_OFF]);
@@ -313,20 +332,26 @@ static int check_header(FILE *f)
 		ast_log(LOG_WARNING, "Failed to skip to data: %u\n", hdr_size);
 		return -1;
 	}
+
+	/* We'll need this later */
+	desc->hdr_size = hdr_size;
+
 	return data_size;
 }
 
-static int update_header(FILE *f)
+static int update_header(struct ast_filestream *fs)
 {
 	off_t cur, end;
 	uint32_t datalen;
 	int bytes;
+	struct au_desc *desc = fs->_private;
+	FILE *f = fs->f;
 
 	cur = ftell(f);
 	fseek(f, 0, SEEK_END);
 	end = ftell(f);
 	/* data starts 24 bytes in */
-	bytes = end - AU_HEADER_SIZE;
+	bytes = end - desc->hdr_size;
 	datalen = htoll(bytes);
 
 	if (cur < 0) {
@@ -348,12 +373,15 @@ static int update_header(FILE *f)
 	return 0;
 }
 
-static int write_header(FILE *f)
+static int write_header(struct ast_filestream *fs)
 {
+	struct au_desc *desc = fs->_private;
+	FILE *f = fs->f;
+
 	AU_HEADER(header);
 
 	header[AU_HDR_MAGIC_OFF] = htoll((uint32_t) AU_MAGIC);
-	header[AU_HDR_HDR_SIZE_OFF] = htoll(AU_HEADER_SIZE);
+	header[AU_HDR_HDR_SIZE_OFF] = htoll(desc->hdr_size);
 	header[AU_HDR_DATA_SIZE_OFF] = 0;
 	header[AU_HDR_ENCODING_OFF] = htoll(AU_ENC_8BIT_ULAW);
 	header[AU_HDR_SAMPLE_RATE_OFF] = htoll(DEFAULT_SAMPLE_RATE);
@@ -361,7 +389,7 @@ static int write_header(FILE *f)
 
 	/* Write an au header, ignoring sizes which will be filled in later */
 	fseek(f, 0, SEEK_SET);
-	if (fwrite(header, 1, AU_HEADER_SIZE, f) != AU_HEADER_SIZE) {
+	if (fwrite(header, 1, MIN_AU_HEADER_SIZE, f) != MIN_AU_HEADER_SIZE) {
 		ast_log(LOG_WARNING, "Unable to write header\n");
 		return -1;
 	}
@@ -370,14 +398,18 @@ static int write_header(FILE *f)
 
 static int au_open(struct ast_filestream *s)
 {
-	if (check_header(s->f) < 0)
+	if (check_header(s) < 0)
 		return -1;
 	return 0;
 }
 
 static int au_rewrite(struct ast_filestream *s, const char *comment)
 {
-	if (write_header(s->f))
+	struct au_desc *desc = s->_private;
+
+	desc->hdr_size = MIN_AU_HEADER_SIZE;
+
+	if (write_header(s))
 		return -1;
 	return 0;
 }
@@ -385,8 +417,11 @@ static int au_rewrite(struct ast_filestr
 /* XXX check this, probably incorrect */
 static int au_seek(struct ast_filestream *fs, off_t sample_offset, int whence)
 {
-	off_t min = AU_HEADER_SIZE, max, cur;
+	off_t min, max, cur;
 	long offset = 0, bytes;
+	struct au_desc *desc = fs->_private;
+
+	min = desc->hdr_size;
 
 	if (ast_format_cmp(fs->fmt->format, ast_format_g722) == AST_FORMAT_CMP_EQUAL)
 		bytes = sample_offset / 2;
@@ -442,13 +477,14 @@ static int au_trunc(struct ast_filestrea
 	if (ftruncate(fd, cur)) {
 		return -1;
 	}
-	return update_header(fs->f);
+	return update_header(fs);
 }
 
 static off_t au_tell(struct ast_filestream *fs)
 {
+	struct au_desc *desc = fs->_private;
 	off_t offset = ftello(fs->f);
-	return offset - AU_HEADER_SIZE;
+	return offset - desc->hdr_size;
 }
 
 static struct ast_format_def alaw_f = {
@@ -500,8 +536,17 @@ static struct ast_format_def au_f = {
 	.tell = au_tell,
 	.read = pcm_read,
 	.buf_size = BUF_SIZE + AST_FRIENDLY_OFFSET,	/* this many shorts */
+	.desc_size = sizeof(struct au_desc),
 };
 
+static int unload_module(void)
+{
+	return ast_format_def_unregister(pcm_f.name)
+		|| ast_format_def_unregister(alaw_f.name)
+		|| ast_format_def_unregister(au_f.name)
+		|| ast_format_def_unregister(g722_f.name);
+}
+
 static int load_module(void)
 {
 	int i;
@@ -519,19 +564,13 @@ static int load_module(void)
 	if ( ast_format_def_register(&pcm_f)
 		|| ast_format_def_register(&alaw_f)
 		|| ast_format_def_register(&au_f)
-		|| ast_format_def_register(&g722_f) )
-		return AST_MODULE_LOAD_FAILURE;
+		|| ast_format_def_register(&g722_f) ) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-static int unload_module(void)
-{
-	return ast_format_def_unregister(pcm_f.name)
-		|| ast_format_def_unregister(alaw_f.name)
-		|| ast_format_def_unregister(au_f.name)
-		|| ast_format_def_unregister(g722_f.name);
-}
-
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Raw/Sun uLaw/ALaw 8KHz (PCM,PCMA,AU), G.722 16Khz",
 	.support_level = AST_MODULE_SUPPORT_CORE,
 	.load = load_module,
diff -urpN asterisk-13.9.1/formats/format_siren14.c asterisk-13.17.0/formats/format_siren14.c
--- asterisk-13.9.1/formats/format_siren14.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_siren14.c	2017-07-12 13:12:08.000000000 +0200
@@ -47,8 +47,16 @@ static struct ast_frame *siren14read(str
 
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = BYTES_TO_SAMPLES(res);
diff -urpN asterisk-13.9.1/formats/format_siren7.c asterisk-13.17.0/formats/format_siren7.c
--- asterisk-13.9.1/formats/format_siren7.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_siren7.c	2017-07-12 13:12:08.000000000 +0200
@@ -47,8 +47,16 @@ static struct ast_frame *siren7read(stru
 
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);
 	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = BYTES_TO_SAMPLES(res);
diff -urpN asterisk-13.9.1/formats/format_sln.c asterisk-13.17.0/formats/format_sln.c
--- asterisk-13.9.1/formats/format_sln.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_sln.c	2017-07-12 13:12:08.000000000 +0200
@@ -40,9 +40,17 @@ static struct ast_frame *generic_read(st
 	/* Send a frame from the file to the appropriate channel */
 
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, buf_size);
-	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) < 1) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = res/2;
@@ -237,6 +245,19 @@ static struct ast_format_def *slin_list[
 	&slin192_f,
 };
 
+static int unload_module(void)
+{
+	int res = 0;
+	int i = 0;
+
+	for (i = 0; i < ARRAY_LEN(slin_list); i++) {
+		if (ast_format_def_unregister(slin_list[i]->name)) {
+			res = -1;
+		}
+	}
+	return res;
+}
+
 static int load_module(void)
 {
 	int i;
@@ -253,26 +274,14 @@ static int load_module(void)
 
 	for (i = 0; i < ARRAY_LEN(slin_list); i++) {
 		if (ast_format_def_register(slin_list[i])) {
-			return AST_MODULE_LOAD_FAILURE;
+			unload_module();
+			return AST_MODULE_LOAD_DECLINE;
 		}
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-static int unload_module(void)
-{
-	int res = 0;
-	int i = 0;
-
-	for (i = 0; i < ARRAY_LEN(slin_list); i++) {
-		if (ast_format_def_unregister(slin_list[i]->name)) {
-			res |= AST_MODULE_LOAD_FAILURE;
-		}
-	}
-	return res;
-}
-
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Raw Signed Linear Audio support (SLN) 8khz-192khz",
 	.support_level = AST_MODULE_SUPPORT_CORE,
 	.load = load_module,
diff -urpN asterisk-13.9.1/formats/format_vox.c asterisk-13.17.0/formats/format_vox.c
--- asterisk-13.9.1/formats/format_vox.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_vox.c	2017-07-12 13:12:08.000000000 +0200
@@ -46,9 +46,17 @@ static struct ast_frame *vox_read(struct
 
 	/* Send a frame from the file to the appropriate channel */
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, BUF_SIZE);
-	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) < 1) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	*whennext = s->fr.samples = res * 2;
@@ -139,7 +147,7 @@ static int load_module(void)
 {
 	vox_f.format = ast_format_adpcm;
 	if (ast_format_def_register(&vox_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/formats/format_wav.c asterisk-13.17.0/formats/format_wav.c
--- asterisk-13.9.1/formats/format_wav.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_wav.c	2017-07-12 13:12:08.000000000 +0200
@@ -82,9 +82,8 @@ struct wav_desc {	/* format-specific par
 
 static int check_header_fmt(FILE *f, int hsize, int hz)
 {
-	short format, chans, bysam, bisam;
-	int bysec;
-	int freq;
+	unsigned short format, chans, bysam, bisam;
+	unsigned int freq, bysec;
 	if (hsize < 16) {
 		ast_log(LOG_WARNING, "Unexpected header size %d\n", hsize);
 		return -1;
@@ -94,7 +93,7 @@ static int check_header_fmt(FILE *f, int
 		return -1;
 	}
 	if (ltohs(format) != 1) {
-		ast_log(LOG_WARNING, "Not a supported wav file format (%d). Only PCM encoded, 16 bit, mono, 8kHz files are supported with a lowercase '.wav' extension.\n", ltohs(format));
+		ast_log(LOG_WARNING, "Not a supported wav file format (%d). Only PCM encoded, 16 bit, mono, 8kHz/16kHz files are supported with a lowercase '.wav' extension.\n", ltohs(format));
 		return -1;
 	}
 	if (fread(&chans, 1, 2, f) != 2) {
@@ -109,10 +108,9 @@ static int check_header_fmt(FILE *f, int
 		ast_log(LOG_WARNING, "Read failed (freq)\n");
 		return -1;
 	}
-	if (((ltohl(freq) != 8000) && (ltohl(freq) != 16000)) ||
-		((ltohl(freq) == 8000) && (hz != 8000)) ||
-		((ltohl(freq) == 16000) && (hz != 16000))) {
-		ast_log(LOG_WARNING, "Unexpected frequency mismatch %d (expecting %d)\n", ltohl(freq),hz);
+	freq = ltohl(freq);
+	if ((freq != 8000 && freq != 16000) || freq != hz) {
+		ast_log(LOG_WARNING, "Unexpected frequency mismatch %d (expecting %d)\n", freq, hz);
 		return -1;
 	}
 	/* Ignore the byte frequency */
@@ -325,9 +323,15 @@ static int wav_open(struct ast_filestrea
 	/* We don't have any header to read or anything really, but
 	   if we did, it would go here.  We also might want to check
 	   and be sure it's a valid file.  */
-	struct wav_desc *tmp = (struct wav_desc *)s->_private;
-	if ((tmp->maxlen = check_header(s->f, ast_format_get_sample_rate(s->fmt->format))) < 0)
+	struct wav_desc *tmp = s->_private;
+	unsigned int sample_rate = ast_format_get_sample_rate(s->fmt->format);
+
+	tmp->maxlen = check_header(s->f, sample_rate);
+	if (tmp->maxlen < 0) {
 		return -1;
+	}
+
+	tmp->hz = sample_rate;
 	return 0;
 }
 
@@ -359,7 +363,7 @@ static void wav_close(struct ast_filestr
 
 	/* Pad to even length */
 	if (fs->bytes & 0x1) {
-		if (!fwrite(&zero, 1, 1, s->f)) {
+		if (fwrite(&zero, 1, 1, s->f) != 1) {
 			ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 		}
 	}
@@ -383,14 +387,23 @@ static struct ast_frame *wav_read(struct
 	here = ftello(s->f);
 	if (fs->maxlen - here < bytes)		/* truncate if necessary */
 		bytes = fs->maxlen - here;
-	if (bytes < 0)
-		bytes = 0;
+	if (bytes <= 0) {
+		return NULL;
+	}
 /* 	ast_debug(1, "here: %d, maxlen: %d, bytes: %d\n", here, s->maxlen, bytes); */
 	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, bytes);
-	
-	if ( (res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) <= 0 ) {
-		if (res)
-			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (feof(s->f)) {
+			if (res) {
+				ast_debug(3, "Incomplete frame data at end of %s file "
+						  "(expected %d bytes, read %d)\n",
+						  ast_format_get_name(s->fr.subclass.format), s->fr.datalen, res);
+			}
+		} else {
+			ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+					ast_format_get_name(s->fr.subclass.format), strerror(errno));
+		}
 		return NULL;
 	}
 	s->fr.datalen = res;
@@ -538,22 +551,24 @@ static struct ast_format_def wav_f = {
 	.desc_size = sizeof(struct wav_desc),
 };
 
+static int unload_module(void)
+{
+	return ast_format_def_unregister(wav_f.name)
+		|| ast_format_def_unregister(wav16_f.name);
+}
+
 static int load_module(void)
 {
 	wav_f.format = ast_format_slin;
 	wav16_f.format = ast_format_slin16;
 	if (ast_format_def_register(&wav_f)
-		|| ast_format_def_register(&wav16_f))
-		return AST_MODULE_LOAD_FAILURE;
+		|| ast_format_def_register(&wav16_f)) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-static int unload_module(void)
-{
-	return ast_format_def_unregister(wav_f.name)
-		|| ast_format_def_unregister(wav16_f.name);
-}
-
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Microsoft WAV/WAV16 format (8kHz/16kHz Signed Linear)",
 	.support_level = AST_MODULE_SUPPORT_CORE,
 	.load = load_module,
diff -urpN asterisk-13.9.1/formats/format_wav_gsm.c asterisk-13.17.0/formats/format_wav_gsm.c
--- asterisk-13.9.1/formats/format_wav_gsm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/formats/format_wav_gsm.c	2017-07-12 13:12:08.000000000 +0200
@@ -424,8 +424,16 @@ static struct ast_frame *wav_read(struct
 		int res;
 		
 		if ((res = fread(msdata, 1, MSGSM_FRAME_SIZE, s->f)) != MSGSM_FRAME_SIZE) {
-			if (res && (res != 1))
-				ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+			if (feof(s->f)) {
+				if (res) {
+					ast_debug(3, "Incomplete frame data at end of %s file "
+							  "(expected %d bytes, read %d)\n",
+							  ast_format_get_name(s->fr.subclass.format), MSGSM_FRAME_SIZE, res);
+				}
+			} else {
+				ast_log(LOG_ERROR, "Error while reading %s file: %s\n",
+						ast_format_get_name(s->fr.subclass.format), strerror(errno));
+			}
 			return NULL;
 		}
 		/* Convert from MS format to two real GSM frames */
@@ -513,7 +521,7 @@ static int wav_seek(struct ast_filestrea
 		int i;
 		fseek(fs->f, 0, SEEK_END);
 		for (i=0; i< (offset - max) / MSGSM_FRAME_SIZE; i++) {
-			if (!fwrite(msgsm_silence, 1, MSGSM_FRAME_SIZE, fs->f)) {
+			if (fwrite(msgsm_silence, 1, MSGSM_FRAME_SIZE, fs->f) != MSGSM_FRAME_SIZE) {
 				ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 			}
 		}
@@ -570,7 +578,7 @@ static int load_module(void)
 {
 	wav49_f.format = ast_format_gsm;
 	if (ast_format_def_register(&wav49_f))
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/funcs/func_cdr.c asterisk-13.17.0/funcs/func_cdr.c
--- asterisk-13.9.1/funcs/func_cdr.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_cdr.c	2017-07-12 13:12:08.000000000 +0200
@@ -223,9 +223,11 @@ STASIS_MESSAGE_TYPE_DEFN_LOCAL(cdr_prop_
 
 static struct timeval cdr_retrieve_time(struct ast_channel *chan, const char *time_name)
 {
-	struct timeval time;
+	struct timeval time = { 0 };
 	char *value = NULL;
 	char tempbuf[128];
+	long int tv_sec;
+	long int tv_usec;
 
 	if (ast_strlen_zero(ast_channel_name(chan))) {
 		/* Format request on a dummy channel */
@@ -234,7 +236,11 @@ static struct timeval cdr_retrieve_time(
 		ast_cdr_getvar(ast_channel_name(chan), time_name, tempbuf, sizeof(tempbuf));
 	}
 
-	if (sscanf(tempbuf, "%ld.%ld", &time.tv_sec, &time.tv_usec) != 2) {
+	/* time.tv_usec is suseconds_t, which could be int or long */
+	if (sscanf(tempbuf, "%ld.%ld", &tv_sec, &tv_usec) == 2) {
+		time.tv_sec = tv_sec;
+		time.tv_usec = tv_usec;
+	} else {
 		ast_log(AST_LOG_WARNING, "Failed to fully extract '%s' from CDR\n", time_name);
 	}
 
@@ -373,7 +379,7 @@ static void cdr_write_callback(void *dat
 			payload->cmd, payload->cmd);
 		return;
 	}
-	if (ast_strlen_zero(payload->value)) {
+	if (!payload->value) {
 		ast_log(AST_LOG_WARNING, "%s requires a value (%s(variable)=value)\n)",
 			payload->cmd, payload->cmd);
 		return;
@@ -645,7 +651,7 @@ static int load_module(void)
 	int res = 0;
 
 	if (!router) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	res |= STASIS_MESSAGE_TYPE_INIT(cdr_read_message_type);
@@ -661,7 +667,8 @@ static int load_module(void)
 	                                 cdr_read_callback, NULL);
 
 	if (res) {
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/funcs/func_channel.c asterisk-13.17.0/funcs/func_channel.c
--- asterisk-13.9.1/funcs/func_channel.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_channel.c	2017-07-12 13:12:08.000000000 +0200
@@ -229,207 +229,41 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<enum name="linkedid">
 						<para>R/O returns the linkedid if available, otherwise returns the uniqueid.</para>
 					</enum>
-				</enumlist>
-				<para><emphasis>chan_sip</emphasis> provides the following additional options:</para>
-				<enumlist>
-					<enum name="peerip">
-						<para>R/O Get the IP address of the peer.</para>
-					</enum>
-					<enum name="recvip">
-						<para>R/O Get the source IP address of the peer.</para>
-					</enum>
-					<enum name="recvport">
-						<para>R/O Get the source port of the peer.</para>
-					</enum>
-					<enum name="from">
-						<para>R/O Get the URI from the From: header.</para>
-					</enum>
-					<enum name="uri">
-						<para>R/O Get the URI from the Contact: header.</para>
-					</enum>
-					<enum name="useragent">
-						<para>R/O Get the useragent.</para>
-					</enum>
-					<enum name="peername">
-						<para>R/O Get the name of the peer.</para>
-					</enum>
-					<enum name="t38passthrough">
-						<para>R/O <literal>1</literal> if T38 is offered or enabled in this channel,
-						otherwise <literal>0</literal></para>
-					</enum>
-					<enum name="rtpqos">
-						<para>R/O Get QOS information about the RTP stream</para>
-						<para>    This option takes two additional arguments:</para>
-						<para>    Argument 1:</para>
-						<para>     <literal>audio</literal>             Get data about the audio stream</para>
-						<para>     <literal>video</literal>             Get data about the video stream</para>
-						<para>     <literal>text</literal>              Get data about the text stream</para>
-						<para>    Argument 2:</para>
-						<para>     <literal>local_ssrc</literal>        Local SSRC (stream ID)</para>
-						<para>     <literal>local_lostpackets</literal> Local lost packets</para>
-						<para>     <literal>local_jitter</literal>      Local calculated jitter</para>
-						<para>     <literal>local_maxjitter</literal>   Local calculated jitter (maximum)</para>
-						<para>     <literal>local_minjitter</literal>   Local calculated jitter (minimum)</para>
-						<para>     <literal>local_normdevjitter</literal>Local calculated jitter (normal deviation)</para>
-						<para>     <literal>local_stdevjitter</literal> Local calculated jitter (standard deviation)</para>
-						<para>     <literal>local_count</literal>       Number of received packets</para>
-						<para>     <literal>remote_ssrc</literal>       Remote SSRC (stream ID)</para>
-						<para>     <literal>remote_lostpackets</literal>Remote lost packets</para>
-						<para>     <literal>remote_jitter</literal>     Remote reported jitter</para>
-						<para>     <literal>remote_maxjitter</literal>  Remote calculated jitter (maximum)</para>
-						<para>     <literal>remote_minjitter</literal>  Remote calculated jitter (minimum)</para>
-						<para>     <literal>remote_normdevjitter</literal>Remote calculated jitter (normal deviation)</para>
-						<para>     <literal>remote_stdevjitter</literal>Remote calculated jitter (standard deviation)</para>
-						<para>     <literal>remote_count</literal>      Number of transmitted packets</para>
-						<para>     <literal>rtt</literal>               Round trip time</para>
-						<para>     <literal>maxrtt</literal>            Round trip time (maximum)</para>
-						<para>     <literal>minrtt</literal>            Round trip time (minimum)</para>
-						<para>     <literal>normdevrtt</literal>        Round trip time (normal deviation)</para>
-						<para>     <literal>stdevrtt</literal>          Round trip time (standard deviation)</para>
-						<para>     <literal>all</literal>               All statistics (in a form suited to logging,
-						but not for parsing)</para>
-					</enum>
-					<enum name="rtpdest">
-						<para>R/O Get remote RTP destination information.</para>
-						<para>   This option takes one additional argument:</para>
-						<para>    Argument 1:</para>
-						<para>     <literal>audio</literal>             Get audio destination</para>
-						<para>     <literal>video</literal>             Get video destination</para>
-						<para>     <literal>text</literal>              Get text destination</para>
-						<para>   Defaults to <literal>audio</literal> if unspecified.</para>
-					</enum>
-					<enum name="rtpsource">
-						<para>R/O Get source RTP destination information.</para>
-						<para>   This option takes one additional argument:</para>
-						<para>    Argument 1:</para>
-						<para>     <literal>audio</literal>             Get audio destination</para>
-						<para>     <literal>video</literal>             Get video destination</para>
-						<para>     <literal>text</literal>              Get text destination</para>
-						<para>   Defaults to <literal>audio</literal> if unspecified.</para>
-					</enum>
-				</enumlist>
-				<xi:include xpointer="xpointer(/docs/info[@name='PJSIPCHANNEL'])" />
-				<para><emphasis>chan_iax2</emphasis> provides the following additional options:</para>
-				<enumlist>
-					<enum name="osptoken">
-						<para>R/O Get the peer's osptoken.</para>
-					</enum>
-					<enum name="peerip">
-						<para>R/O Get the peer's ip address.</para>
-					</enum>
-					<enum name="peername">
-						<para>R/O Get the peer's username.</para>
-					</enum>
-					<enum name="secure_signaling">
-						<para>R/O Get the if the IAX channel is secured.</para>
-					</enum>
-					<enum name="secure_media">
-						<para>R/O Get the if the IAX channel is secured.</para>
-					</enum>
-				</enumlist>
-				<para><emphasis>chan_dahdi</emphasis> provides the following additional options:</para>
-				<enumlist>
-					<enum name="dahdi_channel">
-						<para>R/O DAHDI channel related to this channel.</para>
-					</enum>
-					<enum name="dahdi_span">
-						<para>R/O DAHDI span related to this channel.</para>
-					</enum>
-					<enum name="dahdi_type">
-						<para>R/O DAHDI channel type, one of:</para>
-						<enumlist>
-							<enum name="analog" />
-							<enum name="mfc/r2" />
-							<enum name="pri" />
-							<enum name="pseudo" />
-							<enum name="ss7" />
-						</enumlist>
-					</enum>
-					<enum name="keypad_digits">
-						<para>R/O PRI Keypad digits that came in with the SETUP message.</para>
-					</enum>
-					<enum name="reversecharge">
-						<para>R/O PRI Reverse Charging Indication, one of:</para>
-						<enumlist>
-							<enum name="-1"> <para>None</para></enum>
-							<enum name=" 1"> <para>Reverse Charging Requested</para></enum>
-						</enumlist>
-					</enum>
-					<enum name="no_media_path">
-						<para>R/O PRI Nonzero if the channel has no B channel.
-						The channel is either on hold or a call waiting call.</para>
-					</enum>
-					<enum name="buffers">
-						<para>W/O Change the channel's buffer policy (for the current call only)</para>
-						<para>This option takes two arguments:</para>
-						<para>	Number of buffers,</para>
-						<para>	Buffer policy being one of:</para>
-						<para>	    <literal>full</literal></para>
-						<para>	    <literal>immediate</literal></para>
-						<para>	    <literal>half</literal></para>
-					</enum>
-					<enum name="echocan_mode">
-						<para>W/O Change the configuration of the active echo
-						canceller on the channel (if any), for the current call
-						only.</para>
-						<para>Possible values are:</para>
-						<para>	<literal>on</literal>	Normal mode (the echo canceller is actually reinitalized)</para>
-						<para>	<literal>off</literal>	Disabled</para>
-						<para>	<literal>fax</literal>	FAX/data mode (NLP disabled if possible, otherwise
-							completely disabled)</para>
-						<para>	<literal>voice</literal>	Voice mode (returns from FAX mode, reverting the changes that were made)</para>
-					</enum>
-				</enumlist>
-				<para><emphasis>chan_ooh323</emphasis> provides the following additional options:</para>
-				<enumlist>
-					<enum name="faxdetect">
-						<para>R/W Fax Detect</para>
-						<para>Returns 0 or 1</para>
-						<para>Write yes or no</para>
-					</enum>
-					<enum name="t38support">
-						<para>R/W t38support</para>
-						<para>Returns 0 or 1</para>
-						<para>Write yes or no</para>
-					</enum>
-					<enum name="h323id_url">
-						<para>R/0 Returns caller URL</para>
- 					</enum>
-					<enum name="caller_h323id">
-						<para>R/0 Returns caller h323id</para>
-					</enum>
-					<enum name="caller_dialeddigits">
-						<para>R/0 Returns caller dialed digits</para>
-					</enum>
-					<enum name="caller_email">
-						<para>R/0 Returns caller email</para>
-					</enum>
-					<enum name="callee_email">
-						<para>R/0 Returns callee email</para>
-					</enum>
-					<enum name="callee_dialeddigits">
-						<para>R/0 Returns callee dialed digits</para>
-					</enum>
-					<enum name="caller_url">
-						<para>R/0 Returns caller URL</para>
-					</enum>
 					<enum name="max_forwards">
-						<para>R/W Get or set the maximum number of call forwards for this channel.
-
-						This number describes the number of times a call may be forwarded by this channel
-						before the call fails. "Forwards" in this case refers to redirects by phones as well
-						as calls to local channels.
-
-						Note that this has no relation to the SIP Max-Forwards header.
-						</para>
+						<para>R/W The maximum number of forwards allowed.</para>
+					</enum>
+					<enum name="callid">
+						<para>R/O Call identifier log tag associated with the channel
+						e.g., <literal>[C-00000000]</literal>.</para>
 					</enum>
 				</enumlist>
+				<xi:include xpointer="xpointer(/docs/info[@name='CHANNEL'])" />
 			</parameter>
 		</syntax>
 		<description>
 			<para>Gets/sets various pieces of information about the channel, additional <replaceable>item</replaceable> may
 			be available from the channel driver; see its documentation for details. Any <replaceable>item</replaceable>
 			requested that is not available on the current channel will return an empty string.</para>
+			<example title="Standard CHANNEL item examples">
+				; Push a hangup handler subroutine existing at dialplan
+				; location default,s,1 onto the current channel
+				same => n,Set(CHANNEL(hangup_handler_push)=default,s,1)
+
+				; Set the current tonezone to Germany (de)
+				same => n,Set(CHANNEL(tonezone)=de)
+
+				; Set the allowed maximum number of forwarding attempts
+				same => n,Set(CHANNEL(max_forwards)=10)
+
+				; If this channel is ejected from its next bridge, and if
+				; the channel is not hung up, begin executing dialplan at
+				; location default,after-bridge,1
+				same => n,Set(CHANNEL(after_bridge_goto)=default,after-bridge,1)
+
+				; Log the current state of the channel
+				same => n,Log(NOTICE, This channel is: ${CHANNEL(state)})
+			</example>
+			<xi:include xpointer="xpointer(/docs/info[@name='CHANNEL_EXAMPLES'])" />
 		</description>
 	</function>
  ***/
@@ -616,6 +450,17 @@ static int func_channel_read(struct ast_
 		ast_channel_lock(chan);
 		snprintf(buf, len, "%d", ast_max_forwards_get(chan));
 		ast_channel_unlock(chan);
+	} else if (!strcasecmp(data, "callid")) {
+		struct ast_callid *callid;
+
+		buf[0] = '\0';
+		ast_channel_lock(chan);
+		callid = ast_channel_callid(chan);
+		if (callid) {
+			ast_callid_strnprint(buf, len, callid);
+			ast_callid_unref(callid);
+		}
+		ast_channel_unlock(chan);
 	} else if (!ast_channel_tech(chan) || !ast_channel_tech(chan)->func_channel_read || ast_channel_tech(chan)->func_channel_read(chan, function, data, buf, len)) {
 		ast_log(LOG_WARNING, "Unknown or unavailable item requested: '%s'\n", data);
 		ret = -1;
diff -urpN asterisk-13.9.1/funcs/func_curl.c asterisk-13.17.0/funcs/func_curl.c
--- asterisk-13.9.1/funcs/func_curl.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_curl.c	2017-07-12 13:12:08.000000000 +0200
@@ -794,6 +794,7 @@ static struct ast_custom_function acf_cu
 	.write = acf_curlopt_write,
 };
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(vulnerable_url)
 {
 	const char *bad_urls [] = {
@@ -841,6 +842,7 @@ AST_TEST_DEFINE(vulnerable_url)
 
 	return res;
 }
+#endif
 
 static int unload_module(void)
 {
diff -urpN asterisk-13.9.1/funcs/func_devstate.c asterisk-13.17.0/funcs/func_devstate.c
--- asterisk-13.9.1/funcs/func_devstate.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_devstate.c	2017-07-12 13:12:08.000000000 +0200
@@ -341,7 +341,7 @@ static int load_module(void)
 		if (dev_name <= (const char *) 1)
 			continue;
 		ast_devstate_changed(ast_devstate_val(db_entry->data),
-			AST_DEVSTATE_CACHABLE, "Custom:%s\n", dev_name);
+			AST_DEVSTATE_CACHABLE, "Custom:%s", dev_name);
 	}
 	ast_db_freetree(db_tree);
 	db_tree = NULL;
diff -urpN asterisk-13.9.1/funcs/func_env.c asterisk-13.17.0/funcs/func_env.c
--- asterisk-13.9.1/funcs/func_env.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_env.c	2017-07-12 13:12:08.000000000 +0200
@@ -624,7 +624,7 @@ static int file_read(struct ast_channel
 				ast_log(LOG_ERROR, "Cannot seek to offset %" PRId64 ": %s\n", i, strerror(errno));
 			}
 			end = fread(fbuf, 1, sizeof(fbuf), ff);
-			for (pos = (end < sizeof(fbuf) ? fbuf + end - 1 : fbuf + sizeof(fbuf) - 1); pos > fbuf - 1; pos--) {
+			for (pos = (end < sizeof(fbuf) ? fbuf + end - 1 : fbuf + sizeof(fbuf) - 1); pos >= fbuf; pos--) {
 				LINE_COUNTER(pos, format, count);
 
 				if (length < 0 && count * -1 == length) {
@@ -1024,7 +1024,7 @@ static int file_write(struct ast_channel
 						fclose(ff);
 						return -1;
 					}
-					for (pos = fbuf + sizeof(fbuf) - 1; pos > fbuf - 1; pos--) {
+					for (pos = fbuf + sizeof(fbuf) - 1; pos >= fbuf; pos--) {
 						LINE_COUNTER(pos, newline_format, count);
 
 						if (length < 0 && count * -1 == length) {
diff -urpN asterisk-13.9.1/funcs/func_holdintercept.c asterisk-13.17.0/funcs/func_holdintercept.c
--- asterisk-13.9.1/funcs/func_holdintercept.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_holdintercept.c	2017-07-12 13:12:08.000000000 +0200
@@ -230,7 +230,7 @@ static int unload_module(void)
 /*! \internal \brief Load the module */
 static int load_module(void)
 {
-	return ast_custom_function_register(&hold_intercept_function) ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS;
+	return ast_custom_function_register(&hold_intercept_function) ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "Hold interception dialplan function");
diff -urpN asterisk-13.9.1/funcs/func_odbc.c asterisk-13.17.0/funcs/func_odbc.c
--- asterisk-13.9.1/funcs/func_odbc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_odbc.c	2017-07-12 13:12:08.000000000 +0200
@@ -101,6 +101,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 static char *config = "func_odbc.conf";
 
+#define DEFAULT_SINGLE_DB_CONNECTION 1
+
+static int single_db_connection;
+
+AST_RWLOCK_DEFINE_STATIC(single_db_connection_lock);
+
 enum odbc_option_flags {
 	OPT_ESCAPECOMMAS =	(1 << 0),
 	OPT_MULTIROW     =	(1 << 1),
@@ -221,6 +227,10 @@ static struct dsn *create_dsn(const char
 {
 	struct dsn *dsn;
 
+	if (!dsns) {
+		return NULL;
+	}
+
 	dsn = ao2_alloc(sizeof(*dsn) + strlen(name) + 1, dsn_destructor);
 	if (!dsn) {
 		return NULL;
@@ -296,6 +306,10 @@ static struct dsn *get_dsn(const char *n
 {
 	struct dsn *dsn;
 
+	if (!dsns) {
+		return NULL;
+	}
+
 	ao2_lock(dsns);
 	dsn = ao2_find(dsns, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
 	if (!dsn) {
@@ -332,21 +346,71 @@ static struct dsn *get_dsn(const char *n
 }
 
 /*!
- * \brief Unlock and unreference a DSN
+ * \brief Get a DB handle via a DSN or directly
  *
- * \param dsn The dsn to unlock and unreference
- * \return NULL
+ * If single db connection then get the DB handle via DSN
+ * else by requesting a connection directly
+ *
+ * \param dsn_name Name of the DSN as found in res_odbc.conf
+ * \param dsn The pointer to the DSN
+ * \retval NULL Unable to retrieve the DB handle
+ * \retval non-NULL The retrieved DB handle
  */
-static void *release_dsn(struct dsn *dsn)
+static struct odbc_obj *get_odbc_obj(const char *dsn_name, struct dsn **dsn)
 {
-	if (!dsn) {
-		return NULL;
+	struct odbc_obj *obj = NULL;
+
+	ast_rwlock_rdlock(&single_db_connection_lock);
+	if (single_db_connection) {
+		if (dsn) {
+			*dsn = get_dsn(dsn_name);
+			if (*dsn) {
+				obj = (*dsn)->connection;
+			}
+		}
+	} else {
+		obj = ast_odbc_request_obj(dsn_name, 0);
 	}
+	ast_rwlock_unlock(&single_db_connection_lock);
 
-	ao2_unlock(dsn);
-	ao2_ref(dsn, -1);
+	return obj;
+}
 
-	return NULL;
+/*!
+ * \brief Release an ODBC obj or a DSN
+ *
+ * If single db connection then unlock and unreference the DSN
+ * else release the ODBC obj
+ *
+ * \param obj The pointer to the ODBC obj to release
+ * \param dsn The pointer to the dsn to unlock and unreference
+ */
+static inline void release_obj_or_dsn(struct odbc_obj **obj, struct dsn **dsn)
+{
+	if (dsn && *dsn) {
+		/* If multiple connections are not enabled then the guarantee
+		 * of a single connection already exists and holding on to the
+		 * connection would prevent any other user from acquiring it
+		 * indefinitely.
+		 */
+		if (ast_odbc_get_max_connections((*dsn)->name) < 2) {
+			ast_odbc_release_obj((*dsn)->connection);
+			(*dsn)->connection = NULL;
+		}
+		ao2_unlock(*dsn);
+		ao2_ref(*dsn, -1);
+		*dsn = NULL;
+		/* Some callers may provide both an obj and dsn. To ensure that
+		 * the connection is not released twice we set it to NULL here if
+		 * present.
+		 */
+		if (obj) {
+			*obj = NULL;
+		}
+	} else if (obj && *obj) {
+		ast_odbc_release_obj(*obj);
+		*obj = NULL;
+	}
 }
 
 static AST_RWLIST_HEAD_STATIC(queries, acf_odbc_query);
@@ -568,19 +632,16 @@ static int acf_odbc_write(struct ast_cha
 			if ((obj = ast_odbc_retrieve_transaction_obj(chan, query->writehandle[dsn_num]))) {
 				transactional = 1;
 			} else {
-				dsn = get_dsn(query->writehandle[dsn_num]);
-				if (!dsn) {
-					continue;
-				}
-				obj = dsn->connection;
+				obj = get_odbc_obj(query->writehandle[dsn_num], &dsn);
 				transactional = 0;
 			}
 
 			if (obj && (stmt = ast_odbc_direct_execute(obj, generic_execute, ast_str_buffer(buf)))) {
 				break;
 			}
-
-			dsn = release_dsn(dsn);
+			if (!transactional) {
+				release_obj_or_dsn (&obj, &dsn);
+			}
 		}
 	}
 
@@ -593,25 +654,23 @@ static int acf_odbc_write(struct ast_cha
 			status = "SUCCESS";
 
 		} else if (query->sql_insert) {
-			dsn = release_dsn(dsn);
+			if (!transactional) {
+				release_obj_or_dsn (&obj, &dsn);
+			}
 
 			for (transactional = 0, dsn_num = 0; dsn_num < 5; dsn_num++) {
 				if (!ast_strlen_zero(query->writehandle[dsn_num])) {
 					if (transactional) {
 						/* This can only happen second time through or greater. */
 						ast_log(LOG_WARNING, "Transactions do not work well with multiple DSNs for 'writehandle'\n");
-					} else if (obj) {
-						dsn = release_dsn(dsn);
+					} else {
+						release_obj_or_dsn (&obj, &dsn);
 					}
 
 					if ((obj = ast_odbc_retrieve_transaction_obj(chan, query->writehandle[dsn_num]))) {
 						transactional = 1;
 					} else {
-						dsn = get_dsn(query->writehandle[dsn_num]);
-						if (!dsn) {
-							continue;
-						}
-						obj = dsn->connection;
+						obj = get_odbc_obj(query->writehandle[dsn_num], &dsn);
 						transactional = 0;
 					}
 					if (obj) {
@@ -641,7 +700,9 @@ static int acf_odbc_write(struct ast_cha
 		pbx_builtin_setvar_helper(chan, "ODBCSTATUS", status);
 	}
 
-	dsn = release_dsn(dsn);
+	if (!transactional) {
+		release_obj_or_dsn (&obj, &dsn);
+	}
 
 	if (!bogus_chan) {
 		ast_autoservice_stop(chan);
@@ -652,6 +713,7 @@ static int acf_odbc_write(struct ast_cha
 
 static int acf_odbc_read(struct ast_channel *chan, const char *cmd, char *s, char *buf, size_t len)
 {
+	struct odbc_obj *obj = NULL;
 	struct acf_odbc_query *query;
 	char varname[15], rowcount[12] = "-1";
 	struct ast_str *colnames = ast_str_thread_get(&colnames_buf, 16);
@@ -757,21 +819,21 @@ static int acf_odbc_read(struct ast_chan
 
 	for (dsn_num = 0; dsn_num < 5; dsn_num++) {
 		if (!ast_strlen_zero(query->readhandle[dsn_num])) {
-			dsn = get_dsn(query->readhandle[dsn_num]);
-			if (!dsn) {
+			obj = get_odbc_obj(query->readhandle[dsn_num], &dsn);
+			if (!obj) {
 				continue;
 			}
-			stmt = ast_odbc_direct_execute(dsn->connection, generic_execute, ast_str_buffer(sql));
+			stmt = ast_odbc_direct_execute(obj, generic_execute, ast_str_buffer(sql));
 		}
 		if (stmt) {
 			break;
 		}
-		dsn = release_dsn(dsn);
+		release_obj_or_dsn (&obj, &dsn);
 	}
 
 	if (!stmt) {
 		ast_log(LOG_ERROR, "Unable to execute query [%s]\n", ast_str_buffer(sql));
-		dsn = release_dsn(dsn);
+		release_obj_or_dsn (&obj, &dsn);
 		if (!bogus_chan) {
 			pbx_builtin_setvar_helper(chan, "ODBCROWS", rowcount);
 			ast_autoservice_stop(chan);
@@ -785,7 +847,7 @@ static int acf_odbc_read(struct ast_chan
 		ast_log(LOG_WARNING, "SQL Column Count error!\n[%s]\n\n", ast_str_buffer(sql));
 		SQLCloseCursor(stmt);
 		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
-		dsn = release_dsn(dsn);
+		release_obj_or_dsn (&obj, &dsn);
 		if (!bogus_chan) {
 			pbx_builtin_setvar_helper(chan, "ODBCROWS", rowcount);
 			ast_autoservice_stop(chan);
@@ -809,7 +871,7 @@ static int acf_odbc_read(struct ast_chan
 		}
 		SQLCloseCursor(stmt);
 		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-		dsn = release_dsn(dsn);
+		release_obj_or_dsn (&obj, &dsn);
 		if (!bogus_chan) {
 			pbx_builtin_setvar_helper(chan, "ODBCROWS", rowcount);
 			pbx_builtin_setvar_helper(chan, "ODBCSTATUS", status);
@@ -832,7 +894,7 @@ static int acf_odbc_read(struct ast_chan
 				odbc_datastore_free(resultset);
 				SQLCloseCursor(stmt);
 				SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-				dsn = release_dsn(dsn);
+				release_obj_or_dsn (&obj, &dsn);
 				if (!bogus_chan) {
 					pbx_builtin_setvar_helper(chan, "ODBCSTATUS", "MEMERROR");
 					ast_autoservice_stop(chan);
@@ -864,7 +926,7 @@ static int acf_odbc_read(struct ast_chan
 						odbc_datastore_free(resultset);
 						SQLCloseCursor(stmt);
 						SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-						dsn = release_dsn(dsn);
+						release_obj_or_dsn (&obj, &dsn);
 						if (!bogus_chan) {
 							pbx_builtin_setvar_helper(chan, "ODBCROWS", rowcount);
 							pbx_builtin_setvar_helper(chan, "ODBCSTATUS", "MEMERROR");
@@ -973,7 +1035,7 @@ end_acf_read:
 				odbc_datastore_free(resultset);
 				SQLCloseCursor(stmt);
 				SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-				dsn = release_dsn(dsn);
+				release_obj_or_dsn (&obj, &dsn);
 				pbx_builtin_setvar_helper(chan, "ODBCSTATUS", "MEMERROR");
 				ast_autoservice_stop(chan);
 				return -1;
@@ -986,7 +1048,7 @@ end_acf_read:
 	}
 	SQLCloseCursor(stmt);
 	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-	dsn = release_dsn(dsn);
+	release_obj_or_dsn (&obj, &dsn);
 	if (resultset && !multirow) {
 		/* Fetch the first resultset */
 		if (!acf_fetch(chan, "", buf, buf, len)) {
@@ -1357,7 +1419,8 @@ static char *cli_odbc_read(struct ast_cl
 			AST_RWLIST_UNLOCK(&queries);
 			return NULL;
 		} else if (a->pos == 4) {
-			return a->n == 0 ? ast_strdup("exec") : NULL;
+			static const char * const completions[] = { "exec", NULL };
+			return ast_cli_complete(a->word, completions, a->n);
 		} else {
 			return NULL;
 		}
@@ -1413,6 +1476,7 @@ static char *cli_odbc_read(struct ast_cl
 
 	if (a->argc == 5 && !strcmp(a->argv[4], "exec")) {
 		/* Execute the query */
+		struct odbc_obj *obj = NULL;
 		struct dsn *dsn = NULL;
 		int dsn_num, executed = 0;
 		SQLHSTMT stmt;
@@ -1432,14 +1496,14 @@ static char *cli_odbc_read(struct ast_cl
 			if (ast_strlen_zero(query->readhandle[dsn_num])) {
 				continue;
 			}
-			dsn = get_dsn(query->readhandle[dsn_num]);
-			if (!dsn) {
+			obj = get_odbc_obj(query->readhandle[dsn_num], &dsn);
+			if (!obj) {
 				continue;
 			}
 			ast_debug(1, "Found handle %s\n", query->readhandle[dsn_num]);
 
-			if (!(stmt = ast_odbc_direct_execute(dsn->connection, generic_execute, ast_str_buffer(sql)))) {
-				dsn = release_dsn(dsn);
+			if (!(stmt = ast_odbc_direct_execute(obj, generic_execute, ast_str_buffer(sql)))) {
+				release_obj_or_dsn (&obj, &dsn);
 				continue;
 			}
 
@@ -1450,7 +1514,7 @@ static char *cli_odbc_read(struct ast_cl
 				ast_cli(a->fd, "SQL Column Count error!\n[%s]\n\n", ast_str_buffer(sql));
 				SQLCloseCursor(stmt);
 				SQLFreeHandle (SQL_HANDLE_STMT, stmt);
-				dsn = release_dsn(dsn);
+				release_obj_or_dsn (&obj, &dsn);
 				AST_RWLIST_UNLOCK(&queries);
 				return CLI_SUCCESS;
 			}
@@ -1459,7 +1523,7 @@ static char *cli_odbc_read(struct ast_cl
 			if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
 				SQLCloseCursor(stmt);
 				SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-				dsn = release_dsn(dsn);
+				release_obj_or_dsn (&obj, &dsn);
 				if (res == SQL_NO_DATA) {
 					ast_cli(a->fd, "Returned %d rows.  Query executed on handle %d:%s [%s]\n", rows, dsn_num, query->readhandle[dsn_num], ast_str_buffer(sql));
 					break;
@@ -1488,7 +1552,7 @@ static char *cli_odbc_read(struct ast_cl
 						ast_cli(a->fd, "SQL Get Data error %d!\n[%s]\n\n", res, ast_str_buffer(sql));
 						SQLCloseCursor(stmt);
 						SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-						dsn = release_dsn(dsn);
+						release_obj_or_dsn (&obj, &dsn);
 						AST_RWLIST_UNLOCK(&queries);
 						return CLI_SUCCESS;
 					}
@@ -1506,11 +1570,11 @@ static char *cli_odbc_read(struct ast_cl
 			}
 			SQLCloseCursor(stmt);
 			SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-			dsn = release_dsn(dsn);
+			release_obj_or_dsn (&obj, &dsn);
 			ast_cli(a->fd, "Returned %d row%s.  Query executed on handle %d [%s]\n", rows, rows == 1 ? "" : "s", dsn_num, query->readhandle[dsn_num]);
 			break;
 		}
-		dsn = release_dsn(dsn);
+		release_obj_or_dsn (&obj, &dsn);
 
 		if (!executed) {
 			ast_cli(a->fd, "Failed to execute query. [%s]\n", ast_str_buffer(sql));
@@ -1562,7 +1626,8 @@ static char *cli_odbc_write(struct ast_c
 			AST_RWLIST_UNLOCK(&queries);
 			return NULL;
 		} else if (a->pos == 5) {
-			return a->n == 0 ? ast_strdup("exec") : NULL;
+			static const char * const completions[] = { "exec", NULL };
+			return ast_cli_complete(a->word, completions, a->n);
 		} else {
 			return NULL;
 		}
@@ -1633,7 +1698,8 @@ static char *cli_odbc_write(struct ast_c
 
 	if (a->argc == 6 && !strcmp(a->argv[5], "exec")) {
 		/* Execute the query */
-		struct dsn *dsn;
+		struct odbc_obj *obj = NULL;
+		struct dsn *dsn = NULL;
 		int dsn_num, executed = 0;
 		SQLHSTMT stmt;
 		SQLLEN rows = -1;
@@ -1642,19 +1708,19 @@ static char *cli_odbc_write(struct ast_c
 			if (ast_strlen_zero(query->writehandle[dsn_num])) {
 				continue;
 			}
-			dsn = get_dsn(query->writehandle[dsn_num]);
-			if (!dsn) {
+			obj = get_odbc_obj(query->writehandle[dsn_num], &dsn);
+			if (!obj) {
 				continue;
 			}
-			if (!(stmt = ast_odbc_direct_execute(dsn->connection, generic_execute, ast_str_buffer(sql)))) {
-				dsn = release_dsn(dsn);
+			if (!(stmt = ast_odbc_direct_execute(obj, generic_execute, ast_str_buffer(sql)))) {
+				release_obj_or_dsn (&obj, &dsn);
 				continue;
 			}
 
 			SQLRowCount(stmt, &rows);
 			SQLCloseCursor(stmt);
 			SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-			dsn = release_dsn(dsn);
+			release_obj_or_dsn (&obj, &dsn);
 			ast_cli(a->fd, "Affected %d rows.  Query executed on handle %d [%s]\n", (int)rows, dsn_num, query->writehandle[dsn_num]);
 			executed = 1;
 			break;
@@ -1680,31 +1746,48 @@ static int load_module(void)
 	int res = 0;
 	struct ast_config *cfg;
 	char *catg;
+	const char *s;
 	struct ast_flags config_flags = { 0 };
 
-	dsns = ao2_container_alloc(DSN_BUCKETS, dsn_hash, dsn_cmp);
-	if (!dsns) {
-		return AST_MODULE_LOAD_DECLINE;
-	}
-
 	res |= ast_custom_function_register(&fetch_function);
 	res |= ast_register_application_xml(app_odbcfinish, exec_odbcfinish);
-	AST_RWLIST_WRLOCK(&queries);
 
 	cfg = ast_config_load(config, config_flags);
 	if (!cfg || cfg == CONFIG_STATUS_FILEINVALID) {
 		ast_log(LOG_NOTICE, "Unable to load config for func_odbc: %s\n", config);
-		AST_RWLIST_UNLOCK(&queries);
-		ao2_ref(dsns, -1);
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
+	ast_rwlock_wrlock(&single_db_connection_lock);
+	if ((s = ast_variable_retrieve(cfg, "general", "single_db_connection"))) {
+		single_db_connection = ast_true(s);
+	} else {
+		single_db_connection = DEFAULT_SINGLE_DB_CONNECTION;
+	}
+
+	dsns = NULL;
+
+	if (single_db_connection) {
+		dsns = ao2_container_alloc(DSN_BUCKETS, dsn_hash, dsn_cmp);
+		if (!dsns) {
+			ast_log(LOG_ERROR, "Could not initialize DSN container\n");
+			ast_rwlock_unlock(&single_db_connection_lock);
+			return AST_MODULE_LOAD_DECLINE;
+		}
+	}
+	ast_rwlock_unlock(&single_db_connection_lock);
+
+	AST_RWLIST_WRLOCK(&queries);
 	for (catg = ast_category_browse(cfg, NULL);
 	     catg;
 	     catg = ast_category_browse(cfg, catg)) {
 		struct acf_odbc_query *query = NULL;
 		int err;
 
+		if (!strcasecmp(catg, "general")) {
+			continue;
+		}
+
 		if ((err = init_acf_query(cfg, catg, &query))) {
 			if (err == ENOMEM)
 				ast_log(LOG_ERROR, "Out of memory\n");
@@ -1750,7 +1833,9 @@ static int unload_module(void)
 
 	AST_RWLIST_UNLOCK(&queries);
 
-	ao2_ref(dsns, -1);
+	if (dsns) {
+		ao2_ref(dsns, -1);
+	}
 	return res;
 }
 
@@ -1760,12 +1845,36 @@ static int reload(void)
 	struct ast_config *cfg;
 	struct acf_odbc_query *oldquery;
 	char *catg;
+	const char *s;
 	struct ast_flags config_flags = { CONFIG_FLAG_FILEUNCHANGED };
 
 	cfg = ast_config_load(config, config_flags);
 	if (cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID)
 		return 0;
 
+	ast_rwlock_wrlock(&single_db_connection_lock);
+
+	if (dsns) {
+		ao2_ref(dsns, -1);
+		dsns = NULL;
+	}
+
+	if (cfg && (s = ast_variable_retrieve(cfg, "general", "single_db_connection"))) {
+		single_db_connection = ast_true(s);
+	} else {
+		single_db_connection = DEFAULT_SINGLE_DB_CONNECTION;
+	}
+
+	if (single_db_connection) {
+		dsns = ao2_container_alloc(DSN_BUCKETS, dsn_hash, dsn_cmp);
+		if (!dsns) {
+			ast_log(LOG_ERROR, "Could not initialize DSN container\n");
+			ast_rwlock_unlock(&single_db_connection_lock);
+			return 0;
+		}
+	}
+	ast_rwlock_unlock(&single_db_connection_lock);
+
 	AST_RWLIST_WRLOCK(&queries);
 
 	while (!AST_RWLIST_EMPTY(&queries)) {
@@ -1784,6 +1893,10 @@ static int reload(void)
 	     catg = ast_category_browse(cfg, catg)) {
 		struct acf_odbc_query *query = NULL;
 
+		if (!strcasecmp(catg, "general")) {
+			continue;
+		}
+
 		if (init_acf_query(cfg, catg, &query)) {
 			ast_log(LOG_ERROR, "Cannot initialize query %s\n", catg);
 		} else {
diff -urpN asterisk-13.9.1/funcs/func_periodic_hook.c asterisk-13.17.0/funcs/func_periodic_hook.c
--- asterisk-13.9.1/funcs/func_periodic_hook.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_periodic_hook.c	2017-07-12 13:12:08.000000000 +0200
@@ -183,8 +183,8 @@ static void *hook_launch_thread(void *da
 	};
 
 	ast_pbx_outgoing_exten("Local", NULL, full_exten_name, 60,
-			arg->context, arg->exten, 1, NULL, 0, NULL, NULL, &chan_name_var,
-			NULL, NULL, 1, NULL);
+			arg->context, arg->exten, 1, NULL, AST_OUTGOING_NO_WAIT,
+			NULL, NULL, &chan_name_var, NULL, NULL, 1, NULL);
 
 	hook_thread_arg_destroy(arg);
 
diff -urpN asterisk-13.9.1/funcs/func_strings.c asterisk-13.17.0/funcs/func_strings.c
--- asterisk-13.9.1/funcs/func_strings.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_strings.c	2017-07-12 13:12:08.000000000 +0200
@@ -619,7 +619,6 @@ static int listfilter(struct ast_channel
 	}
 	ast_str_substitute_variables(&orig_list, 0, chan, varsubst);
 	if (!ast_str_strlen(orig_list)) {
-		ast_log(LOG_ERROR, "List variable '%s' not found\n", args.listname);
 		if (chan) {
 			ast_channel_unlock(chan);
 		}
diff -urpN asterisk-13.9.1/funcs/func_talkdetect.c asterisk-13.17.0/funcs/func_talkdetect.c
--- asterisk-13.9.1/funcs/func_talkdetect.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/funcs/func_talkdetect.c	2017-07-12 13:12:08.000000000 +0200
@@ -399,7 +399,7 @@ static int load_module(void)
 
 	res |= ast_custom_function_register(&talk_detect_function);
 
-	return res ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS;
+	return res ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "Talk detection dialplan function");
diff -urpN asterisk-13.9.1/include/asterisk/_private.h asterisk-13.17.0/include/asterisk/_private.h
--- asterisk-13.9.1/include/asterisk/_private.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/_private.h	2017-07-12 13:12:08.000000000 +0200
@@ -16,6 +16,7 @@
 #define _ASTERISK__PRIVATE_H
 
 int load_modules(unsigned int);		/*!< Provided by loader.c */
+int modules_shutdown(void);		/*!< Provided by loader.c */
 int load_pbx(void);			/*!< Provided by pbx.c */
 int load_pbx_builtins(void);	/*!< Provided by pbx_builtins.c */
 int load_pbx_functions_cli(void);	/*!< Provided by pbx_functions.c */
@@ -29,7 +30,7 @@ void logger_queue_start(void);		/*!< Pro
 void clean_time_zones(void);			/*!< Provided by localtime.c */
 int ast_term_init(void);		/*!< Provided by term.c */
 int astdb_init(void);			/*!< Provided by db.c */
-void ast_channels_init(void);		/*!< Provided by channel.c */
+int ast_channels_init(void);		/*!< Provided by channel.c */
 void ast_builtins_init(void);		/*!< Provided by cli.c */
 int ast_cli_perms_init(int reload);	/*!< Provided by cli.c */
 int dnsmgr_init(void);			/*!< Provided by dnsmgr.c */
diff -urpN asterisk-13.9.1/include/asterisk/abstract_jb.h asterisk-13.17.0/include/asterisk/abstract_jb.h
--- asterisk-13.9.1/include/asterisk/abstract_jb.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/abstract_jb.h	2017-07-12 13:12:08.000000000 +0200
@@ -109,6 +109,8 @@ typedef int (*jb_remove_impl)(void *jb,
 typedef void (*jb_force_resynch_impl)(void *jb);
 /*! \brief Empty and reset jb */
 typedef void (*jb_empty_and_reset_impl)(void *jb);
+/*! \brief Check if late */
+typedef int (*jb_is_late_impl)(void *jb, long ts);
 
 
 /*!
@@ -127,6 +129,7 @@ struct ast_jb_impl
 	jb_remove_impl remove;
 	jb_force_resynch_impl force_resync;
 	jb_empty_and_reset_impl empty_and_reset;
+	jb_is_late_impl is_late;
 };
 
 /*!
diff -urpN asterisk-13.9.1/include/asterisk/alertpipe.h asterisk-13.17.0/include/asterisk/alertpipe.h
--- asterisk-13.9.1/include/asterisk/alertpipe.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/include/asterisk/alertpipe.h	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,159 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2017, Sean Bright
+ *
+ * Sean Bright <sean.bright@gmail.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+#ifndef ASTERISK_ALERTPIPE_H
+#define ASTERISK_ALERTPIPE_H
+
+#include "asterisk/utils.h"
+
+typedef enum {
+	AST_ALERT_READ_SUCCESS = 0,
+	AST_ALERT_NOT_READABLE,
+	AST_ALERT_READ_FAIL,
+	AST_ALERT_READ_FATAL,
+} ast_alert_status_t;
+
+/*!
+ * \brief Initialize an alert pipe
+ * \since 13.16.0
+ *
+ * \param p a two-element array to hold the alert pipe's file descriptors
+ *
+ * \return non-zero if a failure occurred, zero otherwise.
+ */
+int ast_alertpipe_init(int alert_pipe[2]);
+
+/*!
+ * \brief Close an alert pipe
+ * \since 13.16.0
+ *
+ * \param p a two-element containing the alert pipe's file descriptors
+ */
+void ast_alertpipe_close(int alert_pipe[2]);
+
+/*!
+ * \brief Read an event from an alert pipe
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ *
+ * \retval AST_ALERT_READ_SUCCESS on success
+ * \retval AST_ALERT_NOT_READABLE if the alert pipe is not readable
+ * \retval AST_ALERT_READ_FATAL if the alert pipe's file descriptors are in
+ *         blocking mode, or a read error occurs.
+ */
+ast_alert_status_t ast_alertpipe_read(int alert_pipe[2]);
+
+/*!
+ * \brief Write an event to an alert pipe
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ *
+ * \return see write(2)
+ */
+ssize_t ast_alertpipe_write(int alert_pipe[2]);
+
+/*!
+ * \brief Consume all alerts written to the alert pipe
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ *
+ * \retval AST_ALERT_READ_SUCCESS on success
+ * \retval AST_ALERT_NOT_READABLE if the alert pipe is not readable
+ * \retval AST_ALERT_READ_FATAL if the alert pipe's file descriptors are in
+ *         blocking mode, or a read error occurs.
+ */
+ast_alert_status_t ast_alertpipe_flush(int alert_pipe[2]);
+
+/*!
+ * \brief Sets the alert pipe file descriptors to default values
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ */
+AST_INLINE_API(
+void ast_alertpipe_clear(int alert_pipe[2]),
+{
+	alert_pipe[0] = alert_pipe[1] = -1;
+}
+)
+
+/*!
+ * \brief Determine if the alert pipe is readable
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ *
+ * \return non-zero if the alert pipe is readable, zero otherwise.
+ */
+AST_INLINE_API(
+int attribute_pure ast_alertpipe_readable(int alert_pipe[2]),
+{
+	return alert_pipe[0] > -1;
+}
+)
+
+/*!
+ * \brief Determine if the alert pipe is writable
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ *
+ * \return non-zero if the alert pipe is writable, zero otherwise.
+ */
+AST_INLINE_API(
+int attribute_pure ast_alertpipe_writable(int alert_pipe[2]),
+{
+	return alert_pipe[1] > -1;
+}
+)
+
+/*!
+ * \brief Get the alert pipe's read file descriptor
+ * \since 13.16.0
+ *
+ * \param p a two-element array containing the alert pipe's file descriptors
+ *
+ * \return -1 if the file descriptor is not initialized, a non-negative value
+ *            otherwise.
+ */
+AST_INLINE_API(
+int attribute_pure ast_alertpipe_readfd(int alert_pipe[2]),
+{
+	return alert_pipe[0];
+}
+)
+
+/*!
+ * \brief Swap the file descriptors from two alert pipes
+ * \since 13.16.0
+ *
+ * \param p1 a two-element array containing an alert pipe's file descriptors
+ * \param p2 a two-element array containing an alert pipe's file descriptors
+ */
+AST_INLINE_API(
+void ast_alertpipe_swap(int alert_pipe_1[2], int alert_pipe_2[2]),
+{
+	SWAP(alert_pipe_1[0], alert_pipe_2[0]);
+	SWAP(alert_pipe_1[1], alert_pipe_2[1]);
+}
+)
+
+#endif /* ASTERISK_ALERTPIPE_H */
diff -urpN asterisk-13.9.1/include/asterisk/ari.h asterisk-13.17.0/include/asterisk/ari.h
--- asterisk-13.9.1/include/asterisk/ari.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/ari.h	2017-07-12 13:12:08.000000000 +0200
@@ -59,7 +59,8 @@ struct ast_ari_response;
 typedef void (*stasis_rest_callback)(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response);
+	struct ast_variable *headers, struct ast_json *body,
+	struct ast_ari_response *response);
 
 /*!
  * \brief Handler for a single RESTful path segment.
@@ -134,7 +135,7 @@ int ast_ari_remove_handler(struct stasis
 void ast_ari_invoke(struct ast_tcptls_session_instance *ser,
 	const char *uri, enum ast_http_method method,
 	struct ast_variable *get_params, struct ast_variable *headers,
-	struct ast_ari_response *response);
+	struct ast_json *body, struct ast_ari_response *response);
 
 /*!
  * \internal
@@ -144,10 +145,11 @@ void ast_ari_invoke(struct ast_tcptls_se
  * for unit testing.
  *
  * \param uri Requested URI, relative to the docs path.
+ * \param prefix prefix that prefixes all http requests
  * \param headers HTTP headers.
  * \param[out] response RESTful HTTP response.
  */
-void ast_ari_get_docs(const char *uri, struct ast_variable *headers, struct ast_ari_response *response);
+void ast_ari_get_docs(const char *uri, const char *prefix, struct ast_variable *headers, struct ast_ari_response *response);
 
 /*! \brief Abstraction for reading/writing JSON to a WebSocket */
 struct ast_ari_websocket_session;
@@ -188,6 +190,25 @@ int ast_ari_websocket_session_write(stru
 	struct ast_json *message);
 
 /*!
+ * \brief Get the Session ID for an ARI WebSocket.
+ *
+ * \param session Session to query.
+ * \return Session ID.
+ * \return \c NULL on error.
+ */
+const char *ast_ari_websocket_session_id(
+	const struct ast_ari_websocket_session *session);
+
+/*!
+ * \brief Get the remote address from an ARI WebSocket.
+ *
+ * \param session Session to write to.
+ * \return ast_sockaddr (does not have to be freed)
+ */
+struct ast_sockaddr *ast_ari_websocket_session_get_remote_addr(
+	struct ast_ari_websocket_session *session);
+
+/*!
  * \brief The stock message to return when out of memory.
  *
  * The refcount is NOT bumped on this object, so ast_json_ref() if you want to
@@ -245,4 +266,14 @@ void ast_ari_response_created(struct ast
  */
 void ast_ari_response_alloc_failed(struct ast_ari_response *response);
 
+/*! \brief Determines whether the res_ari module is loaded */
+#define CHECK_ARI_MODULE_LOADED()				\
+	do {							\
+		if (!ast_module_check("res_ari.so")		\
+			|| !ast_ari_oom_json()) {	\
+			return AST_MODULE_LOAD_DECLINE;		\
+		}						\
+	} while(0)
+
+
 #endif /* _ASTERISK_ARI_H */
diff -urpN asterisk-13.9.1/include/asterisk/astobj2.h asterisk-13.17.0/include/asterisk/astobj2.h
--- asterisk-13.9.1/include/asterisk/astobj2.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/astobj2.h	2017-07-12 13:12:08.000000000 +0200
@@ -19,6 +19,7 @@
 
 #include "asterisk/compat.h"
 #include "asterisk/lock.h"
+#include "asterisk/inline_api.h"
 
 /*! \file
  * \ref AstObj2
@@ -638,6 +639,46 @@ int __ao2_trylock(void *a, enum ao2_lock
 void *ao2_object_get_lockaddr(void *obj);
 
 
+/*!
+ * \brief Increment reference count on an object and lock it
+ * \since 13.9.0
+ *
+ * \param[in] obj A pointer to the ao2 object
+ * \retval 0 The object is not an ao2 object or wasn't locked successfully
+ * \retval 1 The object's reference count was incremented and was locked
+ */
+AST_INLINE_API(
+int ao2_ref_and_lock(void *obj),
+{
+	ao2_ref(obj, +1);
+	if (ao2_lock(obj)) {
+		ao2_ref(obj, -1);
+		return 0;
+	}
+	return 1;
+}
+)
+
+/*!
+ * \brief Unlock an object and decrement its reference count
+ * \since 13.9.0
+ *
+ * \param[in] obj A pointer to the ao2 object
+ * \retval 0 The object is not an ao2 object or wasn't unlocked successfully
+ * \retval 1 The object was unlocked and it's reference count was decremented
+ */
+AST_INLINE_API(
+int ao2_unlock_and_unref(void *obj),
+{
+	if (ao2_unlock(obj)) {
+		return 0;
+	}
+	ao2_ref(obj, -1);
+
+	return 1;
+}
+)
+
 /*! Global ao2 object holder structure. */
 struct ao2_global_obj {
 	/*! Access lock to the held ao2 object. */
@@ -700,16 +741,16 @@ struct ao2_global_obj {
  */
 #ifdef REF_DEBUG
 #define ao2_t_global_obj_release(holder, tag)	\
-	__ao2_global_obj_release(&holder, (tag), __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
+	__ao2_global_obj_replace_unref(&holder, NULL, (tag), __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
 #define ao2_global_obj_release(holder)	\
-	__ao2_global_obj_release(&holder, "", __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
+	__ao2_global_obj_replace_unref(&holder, NULL, "", __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
 
 #else
 
 #define ao2_t_global_obj_release(holder, tag)	\
-	__ao2_global_obj_release(&holder, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
+	__ao2_global_obj_replace_unref(&holder, NULL, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
 #define ao2_global_obj_release(holder)	\
-	__ao2_global_obj_release(&holder, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
+	__ao2_global_obj_replace_unref(&holder, NULL, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, #holder)
 #endif
 
 void __ao2_global_obj_release(struct ao2_global_obj *holder, const char *tag, const char *file, int line, const char *func, const char *name);
@@ -1985,4 +2026,97 @@ void ao2_iterator_cleanup(struct ao2_ite
  */
 int ao2_iterator_count(struct ao2_iterator *iter);
 
+/*!
+ * \brief Creates a hash function for a structure string field.
+ * \param stype The structure type
+ * \param field The string field in the structure to hash
+ *
+ * AO2_STRING_FIELD_HASH_CB(mystruct, myfield) will produce a function
+ * named mystruct_hash_fn which hashes mystruct->myfield.
+ */
+#define AO2_STRING_FIELD_HASH_FN(stype, field) \
+static int stype ## _hash_fn(const void *obj, const int flags) \
+{ \
+	const struct stype *object = obj; \
+	const char *key; \
+	switch (flags & OBJ_SEARCH_MASK) { \
+	case OBJ_SEARCH_KEY: \
+		key = obj; \
+		break; \
+	case OBJ_SEARCH_OBJECT: \
+		key = object->field; \
+		break; \
+	default: \
+		ast_assert(0); \
+		return 0; \
+	} \
+	return ast_str_hash(key); \
+}
+
+/*!
+ * \brief Creates a compare function for a structure string field.
+ * \param stype The structure type
+ * \param field The string field in the structure to compare
+ *
+ * AO2_STRING_FIELD_CMP_FN(mystruct, myfield) will produce a function
+ * named mystruct_cmp_fn which compares mystruct->myfield.
+ */
+#define AO2_STRING_FIELD_CMP_FN(stype, field) \
+static int stype ## _cmp_fn(void *obj, void *arg, int flags) \
+{ \
+	const struct stype *object_left = obj, *object_right = arg; \
+	const char *right_key = arg; \
+	int cmp; \
+	switch (flags & OBJ_SEARCH_MASK) { \
+	case OBJ_SEARCH_OBJECT: \
+		right_key = object_right->field; \
+	case OBJ_SEARCH_KEY: \
+		cmp = strcmp(object_left->field, right_key); \
+		break; \
+	case OBJ_SEARCH_PARTIAL_KEY: \
+		cmp = strncmp(object_left->field, right_key, strlen(right_key)); \
+		break; \
+	default: \
+		cmp = 0; \
+		break; \
+	} \
+	if (cmp) { \
+		return 0; \
+	} \
+	return CMP_MATCH; \
+}
+
+/*!
+ * \brief Creates a sort function for a structure string field.
+ * \param stype The structure type
+ * \param field The string field in the structure to compare
+ *
+ * AO2_STRING_FIELD_SORT_FN(mystruct, myfield) will produce a function
+ * named mystruct_sort_fn which compares mystruct->myfield.
+ */
+#define AO2_STRING_FIELD_SORT_FN(stype, field) \
+static int stype ## _sort_fn(const void *obj, const void *arg, int flags) \
+{ \
+	const struct stype *object_left = obj; \
+	const struct stype *object_right = arg; \
+	const char *right_key = arg; \
+	int cmp; \
+\
+	switch (flags & OBJ_SEARCH_MASK) { \
+	case OBJ_SEARCH_OBJECT: \
+		right_key = object_right->field; \
+		/* Fall through */ \
+	case OBJ_SEARCH_KEY: \
+		cmp = strcmp(object_left->field, right_key); \
+		break; \
+	case OBJ_SEARCH_PARTIAL_KEY: \
+		cmp = strncmp(object_left->field, right_key, strlen(right_key)); \
+		break; \
+	default: \
+		cmp = 0; \
+		break; \
+	} \
+	return cmp; \
+}
+
 #endif /* _ASTERISK_ASTOBJ2_H */
diff -urpN asterisk-13.9.1/include/asterisk/autochan.h asterisk-13.17.0/include/asterisk/autochan.h
--- asterisk-13.9.1/include/asterisk/autochan.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/autochan.h	2017-07-12 13:12:08.000000000 +0200
@@ -32,6 +32,7 @@
 struct ast_autochan {
 	struct ast_channel *chan;
 	AST_LIST_ENTRY(ast_autochan) list;
+	ast_mutex_t lock;
 };
 
 /*! 
@@ -61,19 +62,24 @@ struct ast_autochan {
  * ast_autochan_channel_lock and ast_autochan_channel_unlock. An attempt to lock
  * the autochan->chan directly may result in it being changed after you've
  * retrieved the value of chan, but before you've had a chance to lock it.
- * First when chan is locked, the autochan structure is guaranteed to keep the
+ * While chan is locked, the autochan structure is guaranteed to keep the
  * same channel.
  */
 
+/*!
+ * \brief Lock the autochan's channel lock.
+ *
+ * \note We must do deadlock avoidance because the channel lock is
+ * superior to the autochan lock in locking order.
+ */
 #define ast_autochan_channel_lock(autochan) \
 	do { \
-		struct ast_channel *autochan_chan = autochan->chan; \
-		ast_channel_lock(autochan_chan); \
-		if (autochan->chan == autochan_chan) { \
-			break; \
+		ast_mutex_lock(&(autochan)->lock); \
+		while (ast_channel_trylock((autochan)->chan)) { \
+			DEADLOCK_AVOIDANCE(&(autochan)->lock); \
 		} \
-		ast_channel_unlock(autochan_chan); \
-	} while (1)
+		ast_mutex_unlock(&(autochan)->lock); \
+	} while (0)
 
 #define ast_autochan_channel_unlock(autochan) \
 	ast_channel_unlock(autochan->chan)
diff -urpN asterisk-13.9.1/include/asterisk/autoconfig.h.in asterisk-13.17.0/include/asterisk/autoconfig.h.in
--- asterisk-13.9.1/include/asterisk/autoconfig.h.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/autoconfig.h.in	2017-07-12 13:12:08.000000000 +0200
@@ -103,6 +103,9 @@
 /* Define to 1 if your GCC C compiler supports the 'may_alias' attribute. */
 #undef HAVE_ATTRIBUTE_may_alias
 
+/* Define to 1 if your GCC C compiler supports the 'noreturn' attribute. */
+#undef HAVE_ATTRIBUTE_noreturn
+
 /* Define to 1 if your GCC C compiler supports the 'pure' attribute. */
 #undef HAVE_ATTRIBUTE_pure
 
@@ -207,6 +210,10 @@
 /* Define to 1 if you have the `euidaccess' function. */
 #undef HAVE_EUIDACCESS
 
+/* Define to 1 if your system supports eventfd and the EFD_NONBLOCK and
+   EFD_SEMAPHORE flags. */
+#undef HAVE_EVENTFD
+
 /* Define to 1 if you have the `exp' function. */
 #undef HAVE_EXP
 
@@ -391,6 +398,9 @@
 /* Define if your system has the LIBEDIT libraries. */
 #undef HAVE_LIBEDIT
 
+/* Define if your system has the LIBEDIT_IS_UNICODE headers. */
+#undef HAVE_LIBEDIT_IS_UNICODE
+
 /* Define to 1 if you have the <libintl.h> header file. */
 #undef HAVE_LIBINTL_H
 
@@ -548,9 +558,6 @@
 /* Define to 1 if CRYPTO has the OpenSSL Elliptic Curve Support feature. */
 #undef HAVE_OPENSSL_EC
 
-/* Define if your system has SSL_CTX_set_ecdh_auto declared. */
-#undef HAVE_OPENSSL_ECDH_AUTO
-
 /* Define to 1 if CRYPTO has the OpenSSL SRTP Extension Support feature. */
 #undef HAVE_OPENSSL_SRTP
 
@@ -584,25 +591,47 @@
 /* Define if your system has PJPROJECT_BUNDLED */
 #undef HAVE_PJPROJECT_BUNDLED
 
-/* Define if your system has pjsip_dlg_create_uas_and_inc_lock declared. */
+/* Define to 1 if PJPROJECT has the pjsip_auth_clt_deinit support feature. */
+#undef HAVE_PJSIP_AUTH_CLT_DEINIT
+
+/* Define to 1 if PJPROJECT has the PJSIP Dialog Create UAS with Incremented
+   Lock feature. */
 #undef HAVE_PJSIP_DLG_CREATE_UAS_AND_INC_LOCK
 
-/* Define if your system has pjsip_endpt_set_ext_resolver declared. */
+/* Define to 1 if PJPROJECT has the PJSIP EVSUB Group Lock support feature. */
+#undef HAVE_PJSIP_EVSUB_GRP_LOCK
+
+/* Define to 1 if PJPROJECT has the PJSIP EVSUB Set UAS Timeout support
+   feature. */
+#undef HAVE_PJSIP_EVSUB_SET_UAS_TIMEOUT
+
+/* Define to 1 if PJPROJECT has the PJSIP External Resolver Support feature.
+   */
 #undef HAVE_PJSIP_EXTERNAL_RESOLVER
 
-/* Define if your system has pjsip_get_dest_info declared. */
+/* Define to 1 if PJPROJECT has the pjsip_get_dest_info support feature. */
 #undef HAVE_PJSIP_GET_DEST_INFO
 
+/* Define to 1 if PJPROJECT has the PJSIP INVITE Session Reference Count
+   support feature. */
+#undef HAVE_PJSIP_INV_SESSION_REF
+
 /* Define if your system has the PJSIP_REPLACE_MEDIA_STREAM headers. */
 #undef HAVE_PJSIP_REPLACE_MEDIA_STREAM
 
 /* Define if your system has the PJSIP_TLS_TRANSPORT_PROTO headers. */
 #undef HAVE_PJSIP_TLS_TRANSPORT_PROTO
 
-/* Define if your system has pj_ssl_cert_load_from_files2 declared. */
+/* Define to 1 if PJPROJECT has the pjsip_tsx_layer_find_tsx2 support feature.
+   */
+#undef HAVE_PJSIP_TSX_LAYER_FIND_TSX2
+
+/* Define to 1 if PJPROJECT has the pj_ssl_cert_load_from_files2 support
+   feature. */
 #undef HAVE_PJ_SSL_CERT_LOAD_FROM_FILES2
 
-/* Define if your system has pjsip_tsx_create_uac2 declared. */
+/* Define to 1 if PJPROJECT has the PJSIP Transaction Group Lock Support
+   feature. */
 #undef HAVE_PJ_TRANSACTION_GRP_LOCK
 
 /* Define to 1 if your system defines IP_PKTINFO. */
@@ -705,6 +734,9 @@
    */
 #undef HAVE_PTHREAD_MUTEX_RECURSIVE_NP
 
+/* Have PTHREAD_PRIO_INHERIT. */
+#undef HAVE_PTHREAD_PRIO_INHERIT
+
 /* Define if your system has the PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
    headers. */
 #undef HAVE_PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
@@ -731,6 +763,9 @@
 /* Define if your system has the PWLib libraries. */
 #undef HAVE_PWLIB
 
+/* Define if your system has the PYTHONDEV libraries. */
+#undef HAVE_PYTHONDEV
+
 /* Define to 1 if you have the Radius Client library. */
 #undef HAVE_RADIUS
 
@@ -773,6 +808,9 @@
 /* Define to 1 if you have the `roundl' function. */
 #undef HAVE_ROUNDL
 
+/* Define to 1 if rt has the Realtime functions feature. */
+#undef HAVE_RT
+
 /* Define if your system has the RTLD_NOLOAD headers. */
 #undef HAVE_RTLD_NOLOAD
 
@@ -833,6 +871,9 @@
 /* Define to 1 if SRTP has the SRTP Library Shutdown Function feature. */
 #undef HAVE_SRTP_SHUTDOWN
 
+/* Define to the version of the srtp library. */
+#undef HAVE_SRTP_VERSION
+
 /* Define to 1 if you have the ISDN SS7 library. */
 #undef HAVE_SS7
 
@@ -1000,6 +1041,9 @@
 /* Define to 1 if you have the <syslog.h> header file. */
 #undef HAVE_SYSLOG_H
 
+/* Define if your system has the SYSTEMD libraries. */
+#undef HAVE_SYSTEMD
+
 /* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
    */
 #undef HAVE_SYS_DIR_H
@@ -1205,9 +1249,21 @@
 /* Defined if libcurl supports HTTPS */
 #undef LIBCURL_PROTOCOL_HTTPS
 
+/* Defined if libcurl supports IMAP */
+#undef LIBCURL_PROTOCOL_IMAP
+
 /* Defined if libcurl supports LDAP */
 #undef LIBCURL_PROTOCOL_LDAP
 
+/* Defined if libcurl supports POP3 */
+#undef LIBCURL_PROTOCOL_POP3
+
+/* Defined if libcurl supports RTSP */
+#undef LIBCURL_PROTOCOL_RTSP
+
+/* Defined if libcurl supports SMTP */
+#undef LIBCURL_PROTOCOL_SMTP
+
 /* Defined if libcurl supports TELNET */
 #undef LIBCURL_PROTOCOL_TELNET
 
@@ -1246,9 +1302,6 @@
 /* Define if your system needs braces around PTHREAD_ONCE_INIT */
 #undef PTHREAD_ONCE_INIT_NEEDS_BRACES
 
-/* Define as the return type of signal handlers (`int' or `void'). */
-#undef RETSIGTYPE
-
 /* Define to the type of arg 1 for `select'. */
 #undef SELECT_TYPE_ARG1
 
diff -urpN asterisk-13.9.1/include/asterisk/bridge.h asterisk-13.17.0/include/asterisk/bridge.h
--- asterisk-13.9.1/include/asterisk/bridge.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/bridge.h	2017-07-12 13:12:08.000000000 +0200
@@ -903,6 +903,15 @@ int ast_bridge_is_video_src(struct ast_b
  */
 void ast_bridge_remove_video_src(struct ast_bridge *bridge, struct ast_channel *chan);
 
+/*!
+ * \brief Converts an enum representation of a bridge video mode to string
+ *
+ * \param video_mode The video mode
+ *
+ * \retval A string representation of \c video_mode
+ */
+const char *ast_bridge_video_mode_to_string(enum ast_bridge_video_mode_type video_mode);
+
 enum ast_transfer_result {
 	/*! The transfer completed successfully */
 	AST_BRIDGE_TRANSFER_SUCCESS,
diff -urpN asterisk-13.9.1/include/asterisk/bridge_channel.h asterisk-13.17.0/include/asterisk/bridge_channel.h
--- asterisk-13.9.1/include/asterisk/bridge_channel.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/bridge_channel.h	2017-07-12 13:12:08.000000000 +0200
@@ -145,6 +145,8 @@ struct ast_bridge_channel {
 	AST_LIST_ENTRY(ast_bridge_channel) entry;
 	/*! Queue of outgoing frames to the channel. */
 	AST_LIST_HEAD_NOLOCK(, ast_frame) wr_queue;
+	/*! Queue of deferred frames, queued onto channel when other party joins. */
+	AST_LIST_HEAD_NOLOCK(, ast_frame) deferred_queue;
 	/*! Pipe to alert thread when frames are put into the wr_queue. */
 	int alert_pipe[2];
 	/*!
diff -urpN asterisk-13.9.1/include/asterisk/bridge_channel_internal.h asterisk-13.17.0/include/asterisk/bridge_channel_internal.h
--- asterisk-13.9.1/include/asterisk/bridge_channel_internal.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/bridge_channel_internal.h	2017-07-12 13:12:08.000000000 +0200
@@ -98,6 +98,17 @@ void bridge_channel_settle_owed_events(s
 
 /*!
  * \internal
+ * \brief Queue any deferred frames on the channel.
+ * \since 13.17.0
+ *
+ * \param bridge_channel Channel that the deferred frames should be pulled from and queued to.
+ *
+ * \return Nothing
+ */
+void bridge_channel_queue_deferred_frames(struct ast_bridge_channel *bridge_channel);
+
+/*!
+ * \internal
  * \brief Push the bridge channel into its specified bridge.
  * \since 12.0.0
  *
diff -urpN asterisk-13.9.1/include/asterisk/bridge_technology.h asterisk-13.17.0/include/asterisk/bridge_technology.h
--- asterisk-13.9.1/include/asterisk/bridge_technology.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/bridge_technology.h	2017-07-12 13:12:08.000000000 +0200
@@ -107,6 +107,12 @@ struct ast_bridge_technology {
 	 * \retval -1 on failure
 	 *
 	 * \note On entry, bridge is already locked.
+	 *
+	 * \note The bridge technology must tollerate a failed to join channel
+	 * until it can be kicked from the bridge.
+	 *
+	 * \note A channel may be in a suspended state already when joining a bridge
+	 * technology. The technology must handle this case.
 	 */
 	int (*join)(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel);
 	/*!
@@ -150,6 +156,9 @@ struct ast_bridge_technology {
 	 * \retval -1 Frame needs to be deferred.
 	 *
 	 * \note On entry, bridge is already locked.
+	 *
+	 * \note Deferred frames will be automatically queued onto the channel when another
+	 * channel joins the bridge.
 	 */
 	int (*write)(struct ast_bridge *bridge, struct ast_bridge_channel *bridge_channel, struct ast_frame *frame);
 	/*!
diff -urpN asterisk-13.9.1/include/asterisk/cel.h asterisk-13.17.0/include/asterisk/cel.h
--- asterisk-13.9.1/include/asterisk/cel.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/cel.h	2017-07-12 13:12:08.000000000 +0200
@@ -87,29 +87,6 @@ enum ast_cel_event_type {
  */
 unsigned int ast_cel_check_enabled(void);
 
-/*! 
- * \brief Allocate a CEL record 
- *
- * \since 1.8
- *
- * \note The CEL record must be destroyed with ast_cel_destroy().
- *
- * \retval non-NULL an allocated ast_cel structure
- * \retval NULL error
- */
-struct ast_cel *ast_cel_alloc(void);
-
-/*! 
- * \brief Destroy a CEL record.
- *
- * \param cel the record to destroy
- *
- * \since 1.8
- *
- * \return nothing.
- */
-void ast_cel_destroy(struct ast_cel *cel);
-
 /*!
  * \brief Get the name of a CEL event type
  *
diff -urpN asterisk-13.9.1/include/asterisk/channel.h asterisk-13.17.0/include/asterisk/channel.h
--- asterisk-13.9.1/include/asterisk/channel.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/channel.h	2017-07-12 13:12:08.000000000 +0200
@@ -123,6 +123,7 @@ References:
 #ifndef _ASTERISK_CHANNEL_H
 #define _ASTERISK_CHANNEL_H
 
+#include "asterisk/alertpipe.h"
 #include "asterisk/abstract_jb.h"
 #include "asterisk/astobj2.h"
 #include "asterisk/poll-compat.h"
@@ -178,7 +179,6 @@ extern "C" {
 #include "asterisk/ccss.h"
 #include "asterisk/framehook.h"
 #include "asterisk/stasis.h"
-#include "asterisk/json.h"
 #include "asterisk/endpoints.h"
 
 #define DATASTORE_INHERIT_FOREVER	INT_MAX
@@ -2003,6 +2003,21 @@ int ast_prod(struct ast_channel *chan);
 int ast_set_read_format_path(struct ast_channel *chan, struct ast_format *raw_format, struct ast_format *core_format);
 
 /*!
+ * \brief Set specific write path on channel.
+ * \since 13.13.0
+ *
+ * \param chan Channel to setup write path.
+ * \param core_format What the core wants to write.
+ * \param raw_format Raw write format.
+ *
+ * \pre chan is locked
+ *
+ * \retval 0 on success.
+ * \retval -1 on error.
+ */
+int ast_set_write_format_path(struct ast_channel *chan, struct ast_format *core_format, struct ast_format *raw_format);
+
+/*!
  * \brief Sets read format on channel chan from capabilities
  * Set read format for channel to whichever component of "format" is best.
  * \param chan channel to change
@@ -2569,7 +2584,11 @@ static inline int ast_fdisset(struct pol
 	return 0;
 }
 
-/*! \brief Retrieves the current T38 state of a channel */
+/*!
+ * \brief Retrieves the current T38 state of a channel
+ *
+ * \note Absolutely _NO_ channel locks should be held before calling this function.
+ */
 static inline enum ast_t38_state ast_channel_get_t38_state(struct ast_channel *chan)
 {
 	enum ast_t38_state state = T38_STATE_UNAVAILABLE;
@@ -4202,14 +4221,9 @@ struct ast_namedgroups *ast_channel_name
 void ast_channel_named_pickupgroups_set(struct ast_channel *chan, struct ast_namedgroups *value);
 
 /* Alertpipe accessors--the "internal" functions for channel.c use only */
-typedef enum {
-	AST_ALERT_READ_SUCCESS = 0,
-	AST_ALERT_NOT_READABLE,
-	AST_ALERT_READ_FAIL,
-	AST_ALERT_READ_FATAL,
-} ast_alert_status_t;
 int ast_channel_alert_write(struct ast_channel *chan);
 int ast_channel_alert_writable(struct ast_channel *chan);
+ast_alert_status_t ast_channel_internal_alert_flush(struct ast_channel *chan);
 ast_alert_status_t ast_channel_internal_alert_read(struct ast_channel *chan);
 int ast_channel_internal_alert_readable(struct ast_channel *chan);
 void ast_channel_internal_alertpipe_clear(struct ast_channel *chan);
@@ -4316,6 +4330,31 @@ void ast_channel_dialed_causes_clear(con
 struct ast_flags *ast_channel_flags(struct ast_channel *chan);
 
 /*!
+ * \since 13.17.0
+ * \brief Set a flag on a channel
+ *
+ * \param chan The channel to set the flag on
+ * \param flag The flag to set
+ *
+ * \note This will lock the channel internally. If the channel is already
+ * locked it is still safe to call.
+ */
+
+void ast_channel_set_flag(struct ast_channel *chan, unsigned int flag);
+
+/*!
+ * \since 13.17.0
+ * \param Clear a flag on a channel
+ *
+ * \param chan The channel to clear the flag from
+ * \param flag The flag to clear
+ *
+ * \note This will lock the channel internally. If the channel is already
+ * locked it is still safe to call.
+ */
+void ast_channel_clear_flag(struct ast_channel *chan, unsigned int flag);
+
+/*!
  * \since 12.4.0
  * \brief Return whether or not any manager variables have been set
  *
@@ -4489,6 +4528,9 @@ struct ast_bridge_channel *ast_channel_g
  *
  * \note absolutely _NO_ channel locks should be held before calling this function.
  *
+ * \note The dialplan location on the returned channel is where the channel
+ * should be started in the dialplan if it is returned to it.
+ *
  * \param yankee The channel to gain control of
  * \retval NULL Could not gain control of the channel
  * \retval non-NULL The channel
@@ -4665,4 +4707,33 @@ int ast_channel_feature_hooks_append(str
  */
 int ast_channel_feature_hooks_replace(struct ast_channel *chan, struct ast_bridge_features *features);
 
+enum ast_channel_error {
+	/* Unable to determine what error occurred. */
+	AST_CHANNEL_ERROR_UNKNOWN,
+	/* Channel with this ID already exists */
+	AST_CHANNEL_ERROR_ID_EXISTS,
+};
+
+/*!
+ * \brief Get error code for latest channel operation.
+ */
+enum ast_channel_error ast_channel_errno(void);
+
+/*!
+ * \brief Am I currently running an intercept dialplan routine.
+ * \since 13.14.0
+ *
+ * \details
+ * A dialplan intercept routine is equivalent to an interrupt
+ * routine.  As such, the routine must be done quickly and you
+ * do not have access to the media stream.  These restrictions
+ * are necessary because the media stream is the responsibility
+ * of some other code and interfering with or delaying that
+ * processing is bad.
+ *
+ * \retval 0 Not in an intercept routine.
+ * \retval 1 In an intercept routine.
+ */
+int ast_channel_get_intercept_mode(void);
+
 #endif /* _ASTERISK_CHANNEL_H */
diff -urpN asterisk-13.9.1/include/asterisk/channel_internal.h asterisk-13.17.0/include/asterisk/channel_internal.h
--- asterisk-13.9.1/include/asterisk/channel_internal.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/channel_internal.h	2017-07-12 13:12:08.000000000 +0200
@@ -25,3 +25,5 @@ int ast_channel_internal_is_finalized(st
 void ast_channel_internal_cleanup(struct ast_channel *chan);
 int ast_channel_internal_setup_topics(struct ast_channel *chan);
 
+void ast_channel_internal_errno_set(enum ast_channel_error error);
+enum ast_channel_error ast_channel_internal_errno(void);
diff -urpN asterisk-13.9.1/include/asterisk/chanvars.h asterisk-13.17.0/include/asterisk/chanvars.h
--- asterisk-13.9.1/include/asterisk/chanvars.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/chanvars.h	2017-07-12 13:12:08.000000000 +0200
@@ -35,7 +35,7 @@ AST_LIST_HEAD_NOLOCK(varshead, ast_var_t
 
 struct varshead *ast_var_list_create(void);
 void ast_var_list_destroy(struct varshead *head);
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 struct ast_var_t *_ast_var_assign(const char *name, const char *value, const char *file, int lineno, const char *function);
 #define ast_var_assign(a,b)	_ast_var_assign(a,b,__FILE__,__LINE__,__PRETTY_FUNCTION__)
 #else
diff -urpN asterisk-13.9.1/include/asterisk/codec.h asterisk-13.17.0/include/asterisk/codec.h
--- asterisk-13.9.1/include/asterisk/codec.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/codec.h	2017-07-12 13:12:08.000000000 +0200
@@ -26,6 +26,9 @@
 #ifndef _AST_CODEC_H_
 #define _AST_CODEC_H_
 
+#define AST_SMOOTHER_FLAGS_PACK(x)   ((x) << 1)
+#define AST_SMOOTHER_FLAGS_UNPACK(x) ((x) >> 1)
+
 /*! \brief Types of media */
 enum ast_media_type {
 	AST_MEDIA_TYPE_UNKNOWN = 0,
diff -urpN asterisk-13.9.1/include/asterisk/compat.h asterisk-13.17.0/include/asterisk/compat.h
--- asterisk-13.9.1/include/asterisk/compat.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/compat.h	2017-07-12 13:12:08.000000000 +0200
@@ -68,7 +68,7 @@
 #endif
 
 #ifndef AST_POLL_COMPAT
-#include <sys/poll.h>
+#include <poll.h>
 #else
 #include "asterisk/poll-compat.h"
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/compiler.h asterisk-13.17.0/include/asterisk/compiler.h
--- asterisk-13.9.1/include/asterisk/compiler.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/compiler.h	2017-07-12 13:12:08.000000000 +0200
@@ -77,6 +77,12 @@
 #define attribute_may_alias
 #endif
 
+#ifdef HAVE_ATTRIBUTE_noreturn
+#define attribute_noreturn __attribute__((noreturn))
+#else
+#define attribute_noreturn
+#endif
+
 /* Some older version of GNU gcc (3.3.5 on OpenBSD 4.3 for example) dont like 'NULL' as sentinel */
 #define SENTINEL ((char *)NULL)
 
diff -urpN asterisk-13.9.1/include/asterisk/config.h asterisk-13.17.0/include/asterisk/config.h
--- asterisk-13.9.1/include/asterisk/config.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/config.h	2017-07-12 13:12:08.000000000 +0200
@@ -834,6 +834,18 @@ const char *ast_config_option(struct ast
 struct ast_category *ast_category_new(const char *name, const char *in_file, int lineno);
 
 /*!
+ * \brief Create a category that is not backed by a file
+ *
+ * \param name name of new category
+ */
+#define ast_category_new_dynamic(name) ast_category_new(name, "", -1)
+
+/*!
+ * \brief Create a nameless category that is not backed by a file
+ */
+#define ast_category_new_anonymous() ast_category_new_dynamic("")
+
+/*!
  * \brief Create a category making it a template
  *
  * \param name name of new template
@@ -907,7 +919,7 @@ void ast_category_destroy(struct ast_cat
 struct ast_variable *ast_category_detach_variables(struct ast_category *cat);
 void ast_category_rename(struct ast_category *cat, const char *name);
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 struct ast_variable *_ast_variable_new(const char *name, const char *value, const char *filename, const char *file, const char *function, int lineno);
 #define ast_variable_new(a, b, c) _ast_variable_new(a, b, c, __FILE__, __PRETTY_FUNCTION__, __LINE__)
 #else
diff -urpN asterisk-13.9.1/include/asterisk/config_options.h asterisk-13.17.0/include/asterisk/config_options.h
--- asterisk-13.9.1/include/asterisk/config_options.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/config_options.h	2017-07-12 13:12:08.000000000 +0200
@@ -445,6 +445,28 @@ enum aco_option_type {
 	 * {endcode}
 	 */
 	OPT_UINT_T,
+
+	/*! \brief Type for default option handler for bools (ast_true/ast_false)
+	 * \note aco_option_register flags:
+	 *   non-zero : process via ast_true
+	 *   0        : process via ast_false
+	 * aco_option_register varargs:
+	 *   FLDSET macro with the field of type int. It is important to note that the field
+	 *   cannot be a bitfield. If bitfields are required, they must be set via a custom handler.
+	 *
+	 * This is exactly the same as OPT_BOOL_T. The only difference is that when
+	 * translated to a string, OPT_BOOL_T becomes "true" or "false"; OPT_YESNO_T becomes
+	 * "yes" or "no".
+	 *
+	 * Example:
+	 * {code}
+	 * struct test_item {
+	 *     int enabled;
+	 * };
+	 * aco_option_register(&cfg_info, "enabled", ACO_EXACT, my_types, "no", OPT_YESNO_T, 1, FLDSET(struct test_item, enabled));
+	 * {endcode}
+	 */
+	OPT_YESNO_T,
 };
 
 /*! \brief A callback function for handling a particular option
diff -urpN asterisk-13.9.1/include/asterisk/core_local.h asterisk-13.17.0/include/asterisk/core_local.h
--- asterisk-13.9.1/include/asterisk/core_local.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/core_local.h	2017-07-12 13:12:08.000000000 +0200
@@ -45,6 +45,8 @@ struct stasis_message_type;
  * \brief Lock the "chan" and "owner" channels (and return them) on the base
  *        private structure as well as the base private structure itself.
  *
+ * \deprecated - *DO NOT USE* Please use ast_local_lock_all2 instead.
+ *
  * \note This also adds references to each of the above mentioned elements and
  *       also the underlying private local structure.
  * \note None of these locks should be held prior to calling this function.
@@ -60,9 +62,28 @@ void ast_local_lock_all(struct ast_chann
 			struct ast_channel **outowner);
 
 /*!
+ * \brief Add a reference to the local channel's private tech, lock the local channel's
+ *        private base, and add references and lock both sides of the local channel.
+ *
+ * \note None of these locks should be held prior to calling this function.
+ * \note To undo this process call ast_local_unlock_all2.
+ *
+ * \since 13.17.0, 14.6.0
+ *
+ * \param chan Must be a local channel
+ * \param tech_pvt [out] channel's private tech (ref and lock added)
+ * \param base_chan [out] One side of the local channel (ref and lock added)
+ * \param base_owner [out] Other side of the local channel (ref and lock added)
+ */
+void ast_local_lock_all2(struct ast_channel *chan, void **tech_pvt,
+	struct ast_channel **base_chan, struct ast_channel **base_owner);
+
+/*!
  * \brief Unlock the "chan" and "owner" channels on the base private structure
  *        as well as the base private structure itself.
  *
+ * \deprecated - *DO NOT USE* Please use ast_local_unlock_all2 instead.
+ *
  * \note This also removes references to each of the above mentioned elements and
  *       also the underlying private local structure.
  * \note This function should be used in conjunction with ast_local_lock_all.
@@ -74,6 +95,22 @@ void ast_local_lock_all(struct ast_chann
 void ast_local_unlock_all(struct ast_channel *chan);
 
 /*!
+ * \brief Remove a reference to the given local channel's private tech, unlock the given
+ *        local channel's private base, and remove references and unlock both sides of
+ *        given the local channel.
+ *
+ * \note This function should be used in conjunction with ast_local_lock_all2.
+ *
+ * \since 13.17.0, 14.6.0
+ *
+ * \param tech_pvt channel's private tech (ref and lock removed)
+ * \param base_chan One side of the local channel (ref and lock removed)
+ * \param base_owner Other side of the local channel (ref and lock removed)
+ */
+void ast_local_unlock_all2(void *tech_pvt, struct ast_channel *base_chan,
+	struct ast_channel *base_owner);
+
+/*!
  * \brief Get the other local channel in the pair.
  * \since 12.0.0
  *
diff -urpN asterisk-13.9.1/include/asterisk/event_defs.h asterisk-13.17.0/include/asterisk/event_defs.h
--- asterisk-13.9.1/include/asterisk/event_defs.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/event_defs.h	2017-07-12 13:12:08.000000000 +0200
@@ -58,8 +58,10 @@ enum ast_event_type {
 	AST_EVENT_ACL_CHANGE          = 0x0b,
 	/*! Send out a ping for debugging distributed events */
 	AST_EVENT_PING                = 0x0c,
+	/*! A cluster discovery message */
+	AST_EVENT_CLUSTER_DISCOVERY   = 0x0d,
 	/*! Number of event types.  This should be the last event type + 1 */
-	AST_EVENT_TOTAL               = 0x0d,
+	AST_EVENT_TOTAL               = 0x0e,
 };
 
 /*! \brief Event Information Element types */
@@ -302,8 +304,15 @@ enum ast_event_ie_type {
 	 * Payload type: UINT
 	 */
 	AST_EVENT_IE_CACHABLE            = 0x003d,
+
+	/*!
+	 * \brief Cluster node ID
+	 * Used by: Corosync
+	 * Payload type: UINT
+	 */
+	AST_EVENT_IE_NODE_ID             = 0x003e,
 	/*! \brief Must be the last IE value +1 */
-	AST_EVENT_IE_TOTAL               = 0x003e,
+	AST_EVENT_IE_TOTAL               = 0x003f,
 };
 
 /*!
diff -urpN asterisk-13.9.1/include/asterisk/features.h asterisk-13.17.0/include/asterisk/features.h
--- asterisk-13.9.1/include/asterisk/features.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/features.h	2017-07-12 13:12:08.000000000 +0200
@@ -51,6 +51,7 @@ int ast_bridge_call(struct ast_channel *
 /*!
  * \brief Bridge a call, and add additional flags to the bridge
  *
+ * \details
  * This does the same thing as \ref ast_bridge_call, except that once the bridge
  * is created, the provided flags are set on the bridge. The provided flags are
  * added to the bridge's flags; they will not clear any flags already set.
@@ -70,6 +71,7 @@ int ast_bridge_call_with_flags(struct as
  * \brief Add an arbitrary channel to a bridge
  * \since 12.0.0
  *
+ * \details
  * The channel that is being added to the bridge can be in any state: unbridged,
  * bridged, answered, unanswered, etc. The channel will be added asynchronously,
  * meaning that when this function returns once the channel has been added to
@@ -87,11 +89,16 @@ int ast_bridge_call_with_flags(struct as
  * \param features Features for this channel in the bridge
  * \param play_tone Indicates if a tone should be played to the channel
  * \param xfersound Sound that should be used to indicate transfer with play_tone
+ *
+ * \note The features parameter must be NULL or obtained by
+ * ast_bridge_features_new().  You must not dereference features
+ * after calling even if the call fails.
+ *
  * \retval 0 Success
  * \retval -1 Failure
  */
 int ast_bridge_add_channel(struct ast_bridge *bridge, struct ast_channel *chan,
-		struct ast_bridge_features *features, int play_tone, const char *xfersound);
+	struct ast_bridge_features *features, int play_tone, const char *xfersound);
 
 
 
diff -urpN asterisk-13.9.1/include/asterisk/file.h asterisk-13.17.0/include/asterisk/file.h
--- asterisk-13.9.1/include/asterisk/file.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/file.h	2017-07-12 13:12:08.000000000 +0200
@@ -138,6 +138,34 @@ int ast_filedelete(const char *filename,
 int ast_filecopy(const char *oldname, const char *newname, const char *fmt);
 
 /*!
+ * \brief Callback called for each file found when reading directories
+ * \param dir_name the name of the directory
+ * \param filename the name of the file
+ * \param obj user data object
+ * \return non-zero to stop reading, otherwise zero to continue
+ */
+typedef int (*ast_file_on_file)(const char *dir_name, const char *filename, void *obj);
+
+/*!
+ * \brief Recursively iterate through files and directories up to max_depth
+ * \param dir_name the name of the directory to search
+ * \param on_file callback called on each file
+ * \param obj user data object
+ * \param max_depth re-curse into sub-directories up to a given maximum (-1 = infinite)
+ * \return -1 or errno on failure, otherwise 0
+ */
+int ast_file_read_dirs(const char *dir_name, ast_file_on_file on_file, void *obj, int max_depth);
+
+/*!
+ * \brief Iterate over each file in a given directory
+ * \param dir_name the name of the directory to search
+ * \param on_file callback called on each file
+ * \param obj user data object
+ * \return -1 or errno on failure, otherwise 0
+ */
+#define ast_file_read_dir(dir_name, on_file, obj) ast_file_read_dirs(dir_name, on_file, obj, 1)
+
+/*!
  * \brief Waits for a stream to stop or digit to be pressed
  * \param c channel to waitstream on
  * \param breakon string of DTMF digits to break upon
diff -urpN asterisk-13.9.1/include/asterisk/format.h asterisk-13.17.0/include/asterisk/format.h
--- asterisk-13.9.1/include/asterisk/format.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/format.h	2017-07-12 13:12:08.000000000 +0200
@@ -338,6 +338,17 @@ const char *ast_format_get_codec_name(co
 int ast_format_can_be_smoothed(const struct ast_format *format);
 
 /*!
+ * \since 13.17.0
+ *
+ * \brief Get smoother flags for this format
+ *
+ * \param format The media format
+ *
+ * \return smoother flags for the provided format
+ */
+int ast_format_get_smoother_flags(const struct ast_format *format);
+
+/*!
  * \brief Get the media type of a format
  *
  * \param format The media format
diff -urpN asterisk-13.9.1/include/asterisk/format_cache.h asterisk-13.17.0/include/asterisk/format_cache.h
--- asterisk-13.9.1/include/asterisk/format_cache.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/format_cache.h	2017-07-12 13:12:08.000000000 +0200
@@ -224,6 +224,14 @@ extern struct ast_format *ast_format_t14
 extern struct ast_format *ast_format_none;
 
 /*!
+ * \brief Built-in SILK format.
+ */
+extern struct ast_format *ast_format_silk8;
+extern struct ast_format *ast_format_silk12;
+extern struct ast_format *ast_format_silk16;
+extern struct ast_format *ast_format_silk24;
+
+/*!
  * \brief Initialize format cache support within the core.
  *
  * \retval 0 success
diff -urpN asterisk-13.9.1/include/asterisk/frame.h asterisk-13.17.0/include/asterisk/frame.h
--- asterisk-13.9.1/include/asterisk/frame.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/frame.h	2017-07-12 13:12:08.000000000 +0200
@@ -133,6 +133,8 @@ enum ast_frame_type {
 enum {
 	/*! This frame contains valid timing information */
 	AST_FRFLAG_HAS_TIMING_INFO = (1 << 0),
+	/*! This frame has been requeued */
+	AST_FRFLAG_REQUEUED = (1 << 1),
 };
 
 struct ast_frame_subclass {
diff -urpN asterisk-13.9.1/include/asterisk/hashtab.h asterisk-13.17.0/include/asterisk/hashtab.h
--- asterisk-13.9.1/include/asterisk/hashtab.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/hashtab.h	2017-07-12 13:12:08.000000000 +0200
@@ -251,7 +251,7 @@ unsigned int ast_hashtab_hash_short(cons
  * \param hash a func ptr to do the hashing
  * \param do_locking use locks to guarantee safety of iterators/insertion/deletion -- real simpleminded right now
 */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab * _ast_hashtab_create(int initial_buckets,
 					int (*compare)(const void *a, const void *b),
 					int (*resize)(struct ast_hashtab *),
@@ -294,7 +294,7 @@ void ast_hashtab_destroy( struct ast_has
  * \retval 1 on success
  * \retval 0 if there's a problem
 */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int _ast_hashtab_insert_immediate(struct ast_hashtab *tab, const void *obj, const char *file, int lineno, const char *func);
 #define	ast_hashtab_insert_immediate(a,b)	_ast_hashtab_insert_immediate(a, b, __FILE__, __LINE__, __PRETTY_FUNCTION__)
 #else
@@ -311,7 +311,7 @@ int ast_hashtab_insert_immediate(struct
  * \retval 1 on success
  * \retval 0 if there's a problem
 */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int _ast_hashtab_insert_immediate_bucket(struct ast_hashtab *tab, const void *obj, unsigned int h, const char *file, int lineno, const char *func);
 #define	ast_hashtab_insert_immediate_bucket(a,b,c)	_ast_hashtab_insert_immediate_bucket(a, b, c, __FILE__, __LINE__, __PRETTY_FUNCTION__)
 #else
@@ -324,7 +324,7 @@ int ast_hashtab_insert_immediate_bucket(
  * \retval 1 on success
  * \retval  0 if there's a problem, or it's already there.
 */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int _ast_hashtab_insert_safe(struct ast_hashtab *tab, const void *obj, const char *file, int lineno, const char *func);
 #define	ast_hashtab_insert_safe(a,b)	_ast_hashtab_insert_safe(a,b,__FILE__, __LINE__, __PRETTY_FUNCTION__)
 #else
@@ -362,7 +362,7 @@ int ast_hashtab_size( struct ast_hashtab
 int ast_hashtab_capacity( struct ast_hashtab *tab);
 
 /*! \brief Return a copy of the hash table */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab *_ast_hashtab_dup(struct ast_hashtab *tab, void *(*obj_dup_func)(const void *obj), const char *file, int lineno, const char *func);
 #define	ast_hashtab_dup(a,b)	_ast_hashtab_dup(a,b,__FILE__,__LINE__,__PRETTY_FUNCTION__)
 #else
@@ -370,7 +370,7 @@ struct ast_hashtab *ast_hashtab_dup(stru
 #endif
 
 /*! \brief Gives an iterator to hastable */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab_iter *_ast_hashtab_start_traversal(struct ast_hashtab *tab, const char *file, int lineno, const char *func);
 #define	ast_hashtab_start_traversal(a)	_ast_hashtab_start_traversal(a,__FILE__,__LINE__,__PRETTY_FUNCTION__)
 #else
@@ -395,7 +395,7 @@ void *ast_hashtab_remove_this_object(str
 /* ------------------ */
 
 /*! \brief Gives an iterator to hastable */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab_iter *_ast_hashtab_start_write_traversal(struct ast_hashtab *tab, const char *file, int lineno, const char *func);
 #define	ast_hashtab_start_write_traversal(a)	_ast_hashtab_start_write_traversal(a,__FILE__,__LINE__,__PRETTY_FUNCTION__)
 #else
diff -urpN asterisk-13.9.1/include/asterisk/heap.h asterisk-13.17.0/include/asterisk/heap.h
--- asterisk-13.9.1/include/asterisk/heap.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/heap.h	2017-07-12 13:12:08.000000000 +0200
@@ -97,7 +97,7 @@ typedef int (*ast_heap_cmp_fn)(void *elm
  * \return An instance of a max heap
  * \since 1.6.1
  */
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 struct ast_heap *_ast_heap_create(unsigned int init_height, ast_heap_cmp_fn cmp_fn,
 		ssize_t index_offset, const char *file, int lineno, const char *func);
 #define	ast_heap_create(a,b,c)	_ast_heap_create(a,b,c,__FILE__,__LINE__,__PRETTY_FUNCTION__)
@@ -126,7 +126,7 @@ struct ast_heap *ast_heap_destroy(struct
  * \retval non-zero failure
  * \since 1.6.1
  */
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 int _ast_heap_push(struct ast_heap *h, void *elm, const char *file, int lineno, const char *func);
 #define	ast_heap_push(a,b)	_ast_heap_push(a,b,__FILE__,__LINE__,__PRETTY_FUNCTION__)
 #else
diff -urpN asterisk-13.9.1/include/asterisk/http.h asterisk-13.17.0/include/asterisk/http.h
--- asterisk-13.9.1/include/asterisk/http.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/http.h	2017-07-12 13:12:08.000000000 +0200
@@ -101,6 +101,7 @@ struct ast_http_uri {
 	AST_LIST_ENTRY(ast_http_uri) entry;
 	const char *description;
 	const char *uri;
+	const char *prefix;
 	ast_http_callback callback;
 	unsigned int has_subtree:1;
 	/*! Structure is malloc'd */
diff -urpN asterisk-13.9.1/include/asterisk/io.h asterisk-13.17.0/include/asterisk/io.h
--- asterisk-13.9.1/include/asterisk/io.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/io.h	2017-07-12 13:12:08.000000000 +0200
@@ -139,6 +139,16 @@ int ast_restore_tty(int fd, int oldstatu
 
 int ast_get_termcols(int fd);
 
+/*!
+ * \brief a wrapper for sd_notify(): notify systemd of any state changes.
+ * \param state a string that states the changes. See sd_notify(3).
+ * The wrapper does nothing if systemd ('s development headers) was not
+ * detected on the system.
+ * \returns >=0 on success, negative value on error.
+ */
+int ast_sd_notify(const char *state);
+
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/json.h asterisk-13.17.0/include/asterisk/json.h
--- asterisk-13.9.1/include/asterisk/json.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/json.h	2017-07-12 13:12:08.000000000 +0200
@@ -217,6 +217,41 @@ const char *ast_json_typename(enum ast_j
 /*!@{*/
 
 /*!
+ * \brief Check the string of the given length for UTF-8 format.
+ * \since 13.12.0
+ *
+ * \param str String to check.
+ * \param len Length of string to check.
+ *
+ * \retval 0 if not UTF-8 encoded or str is NULL.
+ * \retval 1 if UTF-8 encoded.
+ */
+int ast_json_utf8_check_len(const char *str, size_t len);
+
+/*!
+ * \brief Check the nul terminated string for UTF-8 format.
+ * \since 13.12.0
+ *
+ * \param str String to check.
+ *
+ * \retval 0 if not UTF-8 encoded or str is NULL.
+ * \retval 1 if UTF-8 encoded.
+ */
+int ast_json_utf8_check(const char *str);
+
+/*!
+ * \brief Check str for UTF-8 and replace with an empty string if fails the check.
+ *
+ * \note The convenience macro is normally used with ast_json_pack()
+ * or a function wrapper that calls ast_json_vpack().
+ */
+#define AST_JSON_UTF8_VALIDATE(str) (ast_json_utf8_check(str) ? (str) : "")
+
+/*!@}*/
+
+/*!@{*/
+
+/*!
  * \brief Get the JSON true value.
  * \since 12.0.0
  *
diff -urpN asterisk-13.9.1/include/asterisk/lock.h asterisk-13.17.0/include/asterisk/lock.h
--- asterisk-13.9.1/include/asterisk/lock.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/lock.h	2017-07-12 13:12:08.000000000 +0200
@@ -113,7 +113,7 @@ struct ast_lock_track {
 	int lineno[AST_MAX_REENTRANCY];
 	int reentrancy;
 	const char *func[AST_MAX_REENTRANCY];
-	pthread_t thread[AST_MAX_REENTRANCY];
+	pthread_t thread_id[AST_MAX_REENTRANCY];
 #ifdef HAVE_BKTR
 	struct ast_bt backtrace[AST_MAX_REENTRANCY];
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/logger.h asterisk-13.17.0/include/asterisk/logger.h
--- asterisk-13.9.1/include/asterisk/logger.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/logger.h	2017-07-12 13:12:08.000000000 +0200
@@ -518,6 +518,29 @@ int ast_verb_console_get(void);
  */
 void ast_verb_console_set(int verb_level);
 
+/*!
+ * \brief Test if logger is initialized
+ *
+ * \retval true if the logger is initialized
+ */
+int ast_is_logger_initialized(void);
+
+/*!
+ * \brief Set the maximum number of messages allowed in the processing queue
+ *
+ * \param queue_limit
+ *
+ * \return Nothing
+ */
+void ast_logger_set_queue_limit(int queue_limit);
+
+/*!
+ * \brief Get the maximum number of messages allowed in the processing queue
+ *
+ * \return Queue limit
+ */
+int ast_logger_get_queue_limit(void);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/manager.h asterisk-13.17.0/include/asterisk/manager.h
--- asterisk-13.9.1/include/asterisk/manager.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/manager.h	2017-07-12 13:12:08.000000000 +0200
@@ -54,7 +54,7 @@
 - \ref manager.c Main manager code file
  */
 
-#define AMI_VERSION                     "2.8.0"
+#define AMI_VERSION                     "2.10.0"
 #define DEFAULT_MANAGER_PORT 5038	/* Default port for Asterisk management via TCP */
 #define DEFAULT_MANAGER_TLS_PORT 5039	/* Default port for Asterisk management via TCP */
 
diff -urpN asterisk-13.9.1/include/asterisk/mod_format.h asterisk-13.17.0/include/asterisk/mod_format.h
--- asterisk-13.9.1/include/asterisk/mod_format.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/mod_format.h	2017-07-12 13:12:08.000000000 +0200
@@ -114,7 +114,11 @@ struct ast_filestream {
 	int lasttimeout;
 	struct ast_channel *owner;
 	FILE *f;
-	struct ast_frame fr;	/*!< frame produced by read, typically */
+	/*!
+	 * \brief frame produced by read, typically
+	 * \note This frame holds a fr.subclass.format ref.
+	 */
+	struct ast_frame fr;
 	char *buf;		/*!< buffer pointed to by ast_frame; */
 	void *_private;	/*!< pointer to private buffer */
 	const char *orig_chan_name;
diff -urpN asterisk-13.9.1/include/asterisk/module.h asterisk-13.17.0/include/asterisk/module.h
--- asterisk-13.9.1/include/asterisk/module.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/module.h	2017-07-12 13:12:08.000000000 +0200
@@ -228,13 +228,6 @@ int ast_loader_register(int (*updater)(v
  */
 int ast_loader_unregister(int (*updater)(void));
 
-/*!
- * \brief Run the unload() callback for all loaded modules
- *
- * This function should be called when Asterisk is shutting down gracefully.
- */
-void ast_module_shutdown(void);
-
 /*! 
  * \brief Match modules names for the Asterisk cli.
  * \param line Unused by this function, but this should be the line we are
@@ -310,8 +303,9 @@ struct ast_module_info {
 	enum ast_module_load_result (*load)(void);	/*!< register stuff etc. Optional. */
 	int (*reload)(void);			/*!< config etc. Optional. */
 	int (*unload)(void);			/*!< unload. called with the module locked */
-	int (*backup_globals)(void);		/*!< for embedded modules, backup global data */
-	void (*restore_globals)(void);		/*!< for embedded modules, restore global data */
+	int (*backup_globals)(void);		/*!< unused, left in place for ABI compat */
+	void (*restore_globals)(void);		/*!< unused, left in place for ABI compat */
+
 	const char *name;			/*!< name of the module for loader reference and CLI commands */
 	const char *description;		/*!< user friendly description of the module. */
 
@@ -440,70 +434,9 @@ void __ast_module_unref(struct ast_modul
    and populated at the end of the module's source file... */
 static const __attribute__((unused)) struct ast_module_info *ast_module_info;
 
-#if !defined(EMBEDDED_MODULE)
-#define __MODULE_INFO_SECTION
-#define __MODULE_INFO_GLOBALS
-#else
-/*
- * For embedded modules we need additional information to backup and
- * restore the global variables in the module itself, so we can unload
- * reload the module.
- * EMBEDDED_MODULE is defined as the module name, so the calls to make_var()
- * below will actually define different symbols for each module.
- */
-#define __MODULE_INFO_SECTION	__attribute__((section(".embed_module")))
-#define __MODULE_INFO_GLOBALS	.backup_globals = __backup_globals, .restore_globals = __restore_globals,
-
-#define make_var_sub(mod, type) __ ## mod ## _ ## type
-#define make_var(mod, type) make_var_sub(mod, type)
-
-extern void make_var(EMBEDDED_MODULE, bss_start);
-extern void make_var(EMBEDDED_MODULE, bss_end);
-extern void make_var(EMBEDDED_MODULE, data_start);
-extern void make_var(EMBEDDED_MODULE, data_end);
-
-static void * __attribute__((section(".embed_module"))) __global_backup;
-
-static int __backup_globals(void)
-{
-	size_t data_size = & make_var(EMBEDDED_MODULE, data_end) - & make_var(EMBEDDED_MODULE, data_start);
-
-	if (__global_backup)
-		return 0;
-
-	if (!data_size)
-		return 0;
-
-	if (!(__global_backup = ast_malloc(data_size)))
-		return -1;
-
-	memcpy(__global_backup, & make_var(EMBEDDED_MODULE, data_start), data_size);
-
-	return 0;
-}
-
-static void __restore_globals(void)
-{
-	size_t data_size = & make_var(EMBEDDED_MODULE, data_end) - & make_var(EMBEDDED_MODULE, data_start);
-	size_t bss_size = & make_var(EMBEDDED_MODULE, bss_end) - & make_var(EMBEDDED_MODULE, bss_start);
-
-	if (bss_size)
-		memset(& make_var(EMBEDDED_MODULE, bss_start), 0, bss_size);
-
-	if (!data_size || !__global_backup)
-		return;
-
-	memcpy(& make_var(EMBEDDED_MODULE, data_start), __global_backup, data_size);
-}
-#undef make_var
-#undef make_var_sub
-#endif /* EMBEDDED_MODULE */
-
 #define AST_MODULE_INFO(keystr, flags_to_set, desc, fields...)	\
 	static struct ast_module_info 				\
-		__MODULE_INFO_SECTION				\
 		__mod_info = {					\
-		__MODULE_INFO_GLOBALS				\
 		.name = AST_MODULE,				\
 		.flags = flags_to_set,				\
 		.description = desc,				\
diff -urpN asterisk-13.9.1/include/asterisk/multicast_rtp.h asterisk-13.17.0/include/asterisk/multicast_rtp.h
--- asterisk-13.9.1/include/asterisk/multicast_rtp.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/include/asterisk/multicast_rtp.h	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc.
+ *
+ * Mark Michelson <mmichelson@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+#ifndef MULTICAST_RTP_H_
+#define MULTICAST_RTP_H_
+struct ast_multicast_rtp_options;
+
+/*!
+ * \brief Create multicast RTP options.
+ *
+ * These are passed to the multicast RTP engine on its creation.
+ *
+ * \param type The type of multicast RTP, either "basic" or "linksys"
+ * \param options Miscellaneous options
+ * \retval NULL Failure
+ * \retval non-NULL success
+ */
+struct ast_multicast_rtp_options *ast_multicast_rtp_create_options(const char *type,
+	const char *options);
+
+/*!
+ * \brief Free multicast RTP options
+ *
+ * This function is NULL-tolerant
+ *
+ * \param mcast_options Options to free
+ */
+void ast_multicast_rtp_free_options(struct ast_multicast_rtp_options *mcast_options);
+
+/*!
+ * \brief Get format specified in multicast options
+ *
+ * Multicast options allow for a format to be selected.
+ * This function accesses the selected format and creates
+ * an ast_format structure for it.
+ *
+ * \param mcast_options The options where a codec was specified
+ * \retval NULL No format specified in the options
+ * \revval non-NULL The format to use for communication
+ */
+struct ast_format *ast_multicast_rtp_options_get_format(struct ast_multicast_rtp_options *mcast_options);
+
+#endif /* MULTICAST_RTP_H_ */
diff -urpN asterisk-13.9.1/include/asterisk/network.h asterisk-13.17.0/include/asterisk/network.h
--- asterisk-13.9.1/include/asterisk/network.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/network.h	2017-07-12 13:12:08.000000000 +0200
@@ -86,6 +86,11 @@ const char *ast_inet_ntoa(struct in_addr
 #endif
 #define inet_ntoa __dont__use__inet_ntoa__use__ast_inet_ntoa__instead__
 
+#ifdef getprotobyname
+#undef getprotobyname
+#endif
+#define getprotobyname __getprotobyname_is_not_threadsafe__do_not_use__
+
 /*! \brief Compares the source address and port of two sockaddr_in */
 static force_inline int inaddrcmp(const struct sockaddr_in *sin1, const struct sockaddr_in *sin2)
 {
diff -urpN asterisk-13.9.1/include/asterisk/options.h asterisk-13.17.0/include/asterisk/options.h
--- asterisk-13.9.1/include/asterisk/options.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/options.h	2017-07-12 13:12:08.000000000 +0200
@@ -132,6 +132,47 @@ enum ast_option_flags {
 #define ast_opt_lock_confdir		ast_test_flag(&ast_options, AST_OPT_FLAG_LOCK_CONFIG_DIR)
 #define ast_opt_generic_plc         ast_test_flag(&ast_options, AST_OPT_FLAG_GENERIC_PLC)
 
+/*! Maximum log level defined by PJPROJECT. */
+#define MAX_PJ_LOG_MAX_LEVEL		6
+/*!
+ * Normal PJPROJECT active log level used by Asterisk.
+ *
+ * These levels are usually mapped to Error and
+ * Warning Asterisk log levels which shouldn't
+ * normally be suppressed.
+ */
+#define DEFAULT_PJ_LOG_MAX_LEVEL	2
+
+/*!
+ * \brief Get maximum log level pjproject was compiled with.
+ *
+ * \details
+ * Determine the maximum log level the pjproject we are running
+ * with supports.
+ *
+ * When pjproject is initially loaded the default log level in
+ * effect is the maximum log level the library was compiled to
+ * generate.  We must save this value off somewhere before we
+ * change it to what we want to use as the default level.
+ *
+ * \note This must be done before calling pj_init() so the level
+ * we want to use as the default level is in effect while the
+ * library initializes.
+ */
+#define AST_PJPROJECT_INIT_LOG_LEVEL()							\
+	do {														\
+		if (ast_pjproject_max_log_level < 0) {					\
+			ast_pjproject_max_log_level = pj_log_get_level();	\
+		}														\
+		pj_log_set_level(ast_option_pjproject_log_level);		\
+	} while (0)
+
+/*! Current linked pjproject maximum logging level */
+extern int ast_pjproject_max_log_level;
+
+/*! Current pjproject logging level */
+extern int ast_option_pjproject_log_level;
+
 extern struct ast_flags ast_options;
 
 extern int option_verbose;
@@ -155,6 +196,8 @@ extern int dahdi_chan_name_len;
 
 extern int ast_language_is_prefix;
 
+extern unsigned int ast_option_rtpptdynamic;
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/opus.h asterisk-13.17.0/include/asterisk/opus.h
--- asterisk-13.9.1/include/asterisk/opus.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/opus.h	2017-07-12 13:12:08.000000000 +0200
@@ -18,24 +18,47 @@
 
 /*!
  * \file
- * \brief Opus Format Attributes (http://tools.ietf.org/html/draft-ietf-payload-rtp-opus)
+ * \brief Codec opus externals and format attributes
  *
- * \author Lorenzo Miniero <lorenzo@meetecho.com>
+ * RFC - https://tools.ietf.org/rfc/rfc7587.txt
  */
 #ifndef _AST_FORMAT_OPUS_H_
 #define _AST_FORMAT_OPUS_H_
 
-/*! Opus format attribute key value pairs, all are accessible through ast_format_get_value()*/
-enum opus_attr_keys {
-	OPUS_ATTR_KEY_MAX_BITRATE, /*! value is an int (6000-510000 in spec). */
-	OPUS_ATTR_KEY_MAX_PLAYRATE, /*! value is an int (8000-48000), maximum output rate the receiver can render. */
-	OPUS_ATTR_KEY_MINPTIME, /*! value is an int (3-120 in spec, 10-60 in format.c), decoder's minimum length of time in milliseconds. */
-	OPUS_ATTR_KEY_STEREO, /*! value is an int, 1 prefer receiving stereo, 0 prefer mono. */
-	OPUS_ATTR_KEY_CBR, /*! value is an int, 1 use constant bitrate, 0 use variable bitrate. */
-	OPUS_ATTR_KEY_FEC, /*! value is an int, 1 encode with FEC, 0 do not use FEC. */
-	OPUS_ATTR_KEY_DTX, /*! value is an int, 1 dtx is enabled, 0 dtx not enabled. */
-	OPUS_ATTR_KEY_SPROP_CAPTURE_RATE, /*! value is an int (8000-48000), likely input rate we're going to produce. */
-	OPUS_ATTR_KEY_SPROP_STEREO, /*! value is an int, 1 likely to send stereo, 0 likely to send mono. */
-};
+/*! \brief Maximum sampling rate an endpoint is capable of receiving */
+#define CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE "maxplaybackrate"
+/*! \brief An alias for maxplaybackrate (used in older versions) */
+#define CODEC_OPUS_ATTR_MAX_CODED_AUDIO_BANDWIDTH "maxcodedaudiobandwidth"
+/*! \brief Maximum sampling rate an endpoint is capable of sending */
+#define CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE "sprop-maxcapturerate"
+/*! \brief Maximum duration of packet (in milliseconds) */
+#define CODEC_OPUS_ATTR_MAX_PTIME "maxptime"
+/*! \brief Duration of packet (in milliseconds) */
+#define CODEC_OPUS_ATTR_PTIME "ptime"
+/*! \brief Maximum average received bit rate (in bits per second) */
+#define CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE "maxaveragebitrate"
+/*! \brief Decode stereo (1) vs mono (0) */
+#define CODEC_OPUS_ATTR_STEREO "stereo"
+/*! \brief Likeliness of sender producing stereo (1) vs mono (0) */
+#define CODEC_OPUS_ATTR_SPROP_STEREO "sprop-stereo"
+/*! \brief Decoder prefers a constant (1) vs variable (0) bitrate */
+#define CODEC_OPUS_ATTR_CBR "cbr"
+/*! \brief Use forward error correction (1) or not (0) */
+#define CODEC_OPUS_ATTR_FEC "useinbandfec"
+/*! \brief Use discontinuous transmission (1) or not (0) */
+#define CODEC_OPUS_ATTR_DTX "usedtx"
+/*! \brief Custom data object */
+#define CODEC_OPUS_ATTR_DATA "data"
+
+/*! \brief Default attribute values */
+#define CODEC_OPUS_DEFAULT_SAMPLE_RATE 48000
+#define CODEC_OPUS_DEFAULT_MAX_PLAYBACK_RATE 48000
+#define CODEC_OPUS_DEFAULT_MAX_PTIME 120
+#define CODEC_OPUS_DEFAULT_PTIME 20
+#define CODEC_OPUS_DEFAULT_BITRATE -1000 /* OPUS_AUTO */
+#define CODEC_OPUS_DEFAULT_CBR 0
+#define CODEC_OPUS_DEFAULT_FEC 0
+#define CODEC_OPUS_DEFAULT_DTX 0
+#define CODEC_OPUS_DEFAULT_STEREO 0
 
 #endif /* _AST_FORMAT_OPUS_H */
diff -urpN asterisk-13.9.1/include/asterisk/parking.h asterisk-13.17.0/include/asterisk/parking.h
--- asterisk-13.9.1/include/asterisk/parking.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/parking.h	2017-07-12 13:12:08.000000000 +0200
@@ -211,12 +211,19 @@ int ast_parking_is_exten_park(const char
  * \brief Park the bridge and/or callers that this channel is in
  *
  * \param parker The bridge_channel parking the bridge
- * \param exten Optional. The extension the channel or bridge was parked at if the
- * call succeeds.
+ * \param[out] exten Optional.  The parking exten to access the parking lot.
  * \param length Optional. If \c exten is specified, the size of the buffer.
  *
  * \note This is safe to be called outside of the \ref AstBridging Bridging API.
  *
+ * \note The exten parameter was intended to return the extension the channel or
+ * bridge was parked at if the call succeeds.  However, accessing that information
+ * is very difficult to do with the new asynchronous design.  That information may
+ * not be available anywhere by the time this function currently returns.
+ *
+ * Only, chan_skinny is known to call this function and use the exten parameter
+ * for the phone display.
+ *
  * \retval 0 on success
  * \retval non-zero on error
  */
diff -urpN asterisk-13.9.1/include/asterisk/pbx.h asterisk-13.17.0/include/asterisk/pbx.h
--- asterisk-13.9.1/include/asterisk/pbx.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/pbx.h	2017-07-12 13:12:08.000000000 +0200
@@ -1130,6 +1130,12 @@ int ast_async_goto(struct ast_channel *c
  */
 int ast_async_goto_by_name(const char *chan, const char *context, const char *exten, int priority);
 
+enum ast_pbx_outgoing_sync {
+	AST_OUTGOING_NO_WAIT = 0,       /*!< Don't wait for originated call to answer */
+	AST_OUTGOING_WAIT = 1,          /*!< Wait for originated call to answer */
+	AST_OUTGOING_WAIT_COMPLETE = 2, /*!< Wait for originated call to answer and hangup */
+};
+
 /*!
  * \brief Synchronously or asynchronously make an outbound call and send it to a
  * particular extension
@@ -1143,11 +1149,15 @@ int ast_async_goto_by_name(const char *c
  * \param priority The destination priority for the outbound channel
  * \param reason Optional.  If provided, the dialed status of the outgoing channel.
  *        Codes are AST_CONTROL_xxx values.  Valid only if synchronous is non-zero.
- * \param synchronous If zero then don't wait for anything.
- *        If one then block until the outbound channel answers or the call fails.
- *        If greater than one then wait for the call to complete or if the call doesn't
- *        answer and failed@context exists then run a channel named OutgoingSpoolFailed
- *        at failed@context.
+ * \param synchronous defined by the ast_pbx_outgoing_sync enum.
+ *        If \c AST_OUTGOING_NO_WAIT then don't wait for anything.
+ *        If \c AST_OUTGOING_WAIT then block until the outbound channel answers or
+ *        the call fails.
+ *        If \c AST_OUTGOING_WAIT_COMPLETE then wait for the call to complete or
+ *        fail.
+ *        If \c AST_OUTGOING_WAIT or \c AST_OUTGOING_WAIT_COMPLETE is specified,
+ *        the call doesn't answer, and \c failed@context exists then run a channel
+ *        named \c OutgoingSpoolFailed at \c failed@context.
  * \param cid_num The caller ID number to set on the outbound channel
  * \param cid_name The caller ID name to set on the outbound channel
  * \param vars Variables to set on the outbound channel
@@ -1181,9 +1191,12 @@ int ast_pbx_outgoing_exten(const char *t
  * \param appdata Data to pass to the application
  * \param reason Optional.  If provided, the dialed status of the outgoing channel.
  *        Codes are AST_CONTROL_xxx values.  Valid only if synchronous is non-zero.
- * \param synchronous If zero then don't wait for anything.
- *        If one then block until the outbound channel answers or the call fails.
- *        If greater than one then wait for the call to complete.
+ * \param synchronous defined by the ast_pbx_outgoing_sync enum.
+ *        If \c AST_OUTGOING_NO_WAIT then don't wait for anything.
+ *        If \c AST_OUTGOING_WAIT then block until the outbound channel answers or
+ *        the call fails.
+ *        If \c AST_OUTGOING_WAIT_COMPLETE then wait for the call to complete or
+ *        fail.
  * \param cid_num The caller ID number to set on the outbound channel
  * \param cid_name The caller ID name to set on the outbound channel
  * \param vars Variables to set on the outbound channel
@@ -1598,6 +1611,18 @@ void pbx_live_dangerously(int new_live_d
  */
 int ast_thread_inhibit_escalations(void);
 
+/*!
+ * \brief Swap the current thread escalation inhibit setting.
+ * \since 11.24.0
+ *
+ * \param inhibit New setting.  Non-zero to inhibit.
+ *
+ * \retval 1 if dangerous function execution was inhibited.
+ * \retval 0 if dangerous function execution was allowed.
+ * \retval -1 on error.
+ */
+int ast_thread_inhibit_escalations_swap(int inhibit);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/poll-compat.h asterisk-13.17.0/include/asterisk/poll-compat.h
--- asterisk-13.9.1/include/asterisk/poll-compat.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/poll-compat.h	2017-07-12 13:12:08.000000000 +0200
@@ -83,7 +83,7 @@
 
 #ifndef AST_POLL_COMPAT
 
-#include <sys/poll.h>
+#include <poll.h>
 
 #define ast_poll(a, b, c) poll(a, b, c)
 
diff -urpN asterisk-13.9.1/include/asterisk/res_fax.h asterisk-13.17.0/include/asterisk/res_fax.h
--- asterisk-13.9.1/include/asterisk/res_fax.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_fax.h	2017-07-12 13:12:08.000000000 +0200
@@ -20,16 +20,16 @@
 #ifndef _ASTERISK_RES_FAX_H
 #define _ASTERISK_RES_FAX_H
 
-#include <asterisk.h>
-#include <asterisk/lock.h>
-#include <asterisk/linkedlists.h>
-#include <asterisk/module.h>
-#include <asterisk/utils.h>
-#include <asterisk/options.h>
-#include <asterisk/frame.h>
-#include <asterisk/cli.h>
-#include <asterisk/stringfields.h>
-#include <asterisk/manager.h>
+#include "asterisk.h"
+#include "asterisk/lock.h"
+#include "asterisk/linkedlists.h"
+#include "asterisk/module.h"
+#include "asterisk/utils.h"
+#include "asterisk/options.h"
+#include "asterisk/frame.h"
+#include "asterisk/cli.h"
+#include "asterisk/stringfields.h"
+#include "asterisk/manager.h"
 
 /*! \brief capabilities for res_fax to locate a fax technology module */
 enum ast_fax_capabilities {
@@ -179,14 +179,16 @@ struct ast_fax_session_details {
 	unsigned int t38timeout;
 	/*! the id of the t.38 gateway framehook for this channel */
 	int gateway_id;
-	/*! the timeout for this gateway in seconds */
+	/*! The timeout for this gateway in ms */
 	int gateway_timeout;
 	/*! the id of the faxdetect framehook for this channel */
 	int faxdetect_id;
-	/*! The timeout for this fax detect in seconds */
+	/*! The timeout for this fax detect in ms */
 	int faxdetect_timeout;
 	/*! flags used for fax detection */
 	int faxdetect_flags;
+	/*! Non-zero if T.38 is negotiated */
+	int is_t38_negotiated;
 };
 
 struct ast_fax_tech;
diff -urpN asterisk-13.9.1/include/asterisk/res_hep.h asterisk-13.17.0/include/asterisk/res_hep.h
--- asterisk-13.9.1/include/asterisk/res_hep.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_hep.h	2017-07-12 13:12:08.000000000 +0200
@@ -49,6 +49,11 @@ enum hepv3_capture_type {
 	HEPV3_CAPTURE_TYPE_IAX    = 0x10,
 };
 
+enum hep_uuid_type {
+	HEP_UUID_TYPE_CALL_ID = 0,
+	HEP_UUID_TYPE_CHANNEL,
+};
+
 /*! \brief HEPv3 Capture Info */
 struct hepv3_capture_info {
 	/*! The source address of the packet */
@@ -67,6 +72,8 @@ struct hepv3_capture_info {
 	size_t len;
 	/*! If non-zero, the payload accompanying this capture info will be compressed */
 	unsigned int zipped:1;
+	/*! The IPPROTO_* protocol where we captured the packet */
+	int protocol_id;
 };
 
 /*!
@@ -104,6 +111,23 @@ struct hepv3_capture_info *hepv3_create_
  */
 int hepv3_send_packet(struct hepv3_capture_info *capture_info);
 
+/*!
+ * \brief Get the preferred UUID type
+ *
+ * \since 13.10.0
+ *
+ * \retval The type of UUID the packet should use
+ */
+enum hep_uuid_type hepv3_get_uuid_type(void);
+
+/*!
+ * \brief Return whether or not we're currently loaded and active
+ *
+ * \retval 0 The module is not loaded
+ * \retval 1 The module is loaded
+ */
+int hepv3_is_loaded(void);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
diff -urpN asterisk-13.9.1/include/asterisk/res_odbc.h asterisk-13.17.0/include/asterisk/res_odbc.h
--- asterisk-13.9.1/include/asterisk/res_odbc.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_odbc.h	2017-07-12 13:12:08.000000000 +0200
@@ -243,4 +243,9 @@ int ast_odbc_text2isolation(const char *
  */
 const char *ast_odbc_isolation2text(int iso);
 
+/*!
+ * \brief Return the current configured maximum number of connections for a class
+ */
+unsigned int ast_odbc_get_max_connections(const char *name);
+
 #endif /* _ASTERISK_RES_ODBC_H */
diff -urpN asterisk-13.9.1/include/asterisk/res_pjsip.h asterisk-13.17.0/include/asterisk/res_pjsip.h
--- asterisk-13.9.1/include/asterisk/res_pjsip.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_pjsip.h	2017-07-12 13:12:08.000000000 +0200
@@ -19,6 +19,13 @@
 #ifndef _RES_PJSIP_H
 #define _RES_PJSIP_H
 
+#include <pjsip.h>
+/* Needed for SUBSCRIBE, NOTIFY, and PUBLISH method definitions */
+#include <pjsip_simple.h>
+#include <pjsip/sip_transaction.h>
+#include <pj/timer.h>
+#include <pjlib.h>
+
 #include "asterisk/stringfields.h"
 /* Needed for struct ast_sockaddr */
 #include "asterisk/netsock2.h"
@@ -187,6 +194,8 @@ struct ast_sip_transport {
 	int write_timeout;
 	/*! Allow reload */
 	int allow_reload;
+	/*! Automatically send requests out the same transport requests have come in on */
+	int symmetric_transport;
 };
 
 #define SIP_SORCERY_DOMAIN_ALIAS_TYPE "domain_alias"
@@ -241,6 +250,16 @@ struct ast_sip_contact {
 	struct ast_sip_endpoint *endpoint;
 	/*! The name of the aor this contact belongs to */
 	char *aor;
+	/*! Asterisk Server name */
+	AST_STRING_FIELD_EXTENDED(reg_server);
+	/*! IP-address of the Via header in REGISTER request */
+	AST_STRING_FIELD_EXTENDED(via_addr);
+	/* Port of the Via header in REGISTER request */
+	int via_port;
+	/*! Content of the Call-ID header in REGISTER request */
+	AST_STRING_FIELD_EXTENDED(call_id);
+	/*! The name of the endpoint that added the contact */
+	AST_STRING_FIELD_EXTENDED(endpoint_name);
 };
 
 #define CONTACT_STATUS "contact_status"
@@ -276,6 +295,8 @@ struct ast_sip_contact_status {
 	char *aor;
 	/*! The original contact's URI */
 	char *uri;
+	/*! TRUE if the contact was refreshed. e.g., re-registered */
+	unsigned int refresh:1;
 };
 
 /*!
@@ -342,6 +363,8 @@ enum ast_sip_dtmf_mode {
 	AST_SIP_DTMF_INFO,
 	/*! Use SIP 4733 if supported by the other side or INBAND if not */
 	AST_SIP_DTMF_AUTO,
+	/*! Use SIP 4733 if supported by the other side or INFO DTMF (blech) if not */
+	AST_SIP_DTMF_AUTO_INFO,
 };
 
 /*!
@@ -389,7 +412,10 @@ AST_VECTOR(ast_sip_auth_vector, const ch
 enum ast_sip_endpoint_identifier_type {
 	/*! Identify based on user name in From header */
 	AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME = (1 << 0),
+	/*! Identify based on user name in Auth header first, then From header */
+	AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME = (1 << 1),
 };
+AST_VECTOR(ast_sip_identify_by_vector, enum ast_sip_endpoint_identifier_type);
 
 enum ast_sip_session_refresh_method {
 	/*! Use reinvite to negotiate direct media */
@@ -482,6 +508,8 @@ struct ast_sip_endpoint_subscription_con
 	unsigned int minexpiry;
 	/*! Message waiting configuration */
 	struct ast_sip_mwi_configuration mwi;
+	/* Context for SUBSCRIBE requests */
+	char context[AST_MAX_CONTEXT];
 };
 
 /*!
@@ -701,6 +729,8 @@ struct ast_sip_endpoint {
 	enum ast_sip_dtmf_mode dtmf;
 	/*! Method(s) by which the endpoint should be identified. */
 	enum ast_sip_endpoint_identifier_type ident_method;
+	/*! Order of the method(s) by which the endpoint should be identified. */
+	struct ast_sip_identify_by_vector ident_method_order;
 	/*! Boolean indicating if ringing should be sent as inband progress */
 	unsigned int inband_progress;
 	/*! Pointer to the persistent Asterisk endpoint */
@@ -719,7 +749,29 @@ struct ast_sip_endpoint {
 	unsigned int usereqphone;
 	/*! Do we send messages for connected line updates for unanswered incoming calls immediately to this endpoint? */
 	unsigned int rpid_immediate;
-};
+	/*! Access control list */
+	struct ast_acl_list *acl;
+	/*! Restrict what IPs are allowed in the Contact header (for registration) */
+	struct ast_acl_list *contact_acl;
+	/*! The number of seconds into call to disable fax detection.  (0 = disabled) */
+	unsigned int faxdetect_timeout;
+	/*! Override the user on the outgoing Contact header with this value. */
+	char *contact_user;
+	/*! Do we allow an asymmetric RTP codec? */
+	unsigned int asymmetric_rtp_codec;
+	/*! Use RTCP-MUX */
+	unsigned int rtcp_mux;
+	/*! Do we allow overlap dialling? */
+	unsigned int allow_overlap;
+	/*! Whether to notifies all the progress details on blind transfer */
+	unsigned int refer_blind_progress;
+	/*! Whether to notifies dialog-info 'early' on INUSE && RINGING state */
+	unsigned int notify_early_inuse_ringing;
+};
+
+/*! URI parameter for symmetric transport */
+#define AST_SIP_X_AST_TXP "x-ast-txp"
+#define AST_SIP_X_AST_TXP_LEN 9
 
 /*!
  * \brief Initialize an auth vector with the configured values.
@@ -823,6 +875,17 @@ struct ast_sip_endpoint_identifier {
 };
 
 /*!
+ * \brief Contact retrieval filtering flags
+ */
+enum ast_sip_contact_filter {
+	/*! \brief Default filter flags */
+	AST_SIP_CONTACT_FILTER_DEFAULT = 0,
+
+	/*! \brief Return only reachable or unknown contacts */
+	AST_SIP_CONTACT_FILTER_REACHABLE = (1 << 0),
+};
+
+/*!
  * \brief Register a SIP service in Asterisk.
  *
  * This is more-or-less a wrapper around pjsip_endpt_register_module().
@@ -961,6 +1024,16 @@ void ast_sip_unregister_endpoint_identif
 void *ast_sip_endpoint_alloc(const char *name);
 
 /*!
+ * \brief Change state of a persistent endpoint.
+ *
+ * \param endpoint The SIP endpoint name to change state.
+ * \param state The new state
+ * \retval 0 Success
+ * \retval -1 Endpoint not found
+ */
+int ast_sip_persistent_endpoint_update_state(const char *endpoint_name, enum ast_endpoint_state state);
+
+/*!
  * \brief Get a pointer to the PJSIP endpoint.
  *
  * This is useful when modules have specific information they need
@@ -998,6 +1071,18 @@ struct ast_sip_aor *ast_sip_location_ret
 struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact(const struct ast_sip_aor *aor);
 
 /*!
+ * \brief Retrieve the first bound contact for an AOR and filter based on flags
+ * \since 13.16.0
+ *
+ * \param aor Pointer to the AOR
+ * \param flags Filtering flags
+ * \retval NULL if no contacts available
+ * \retval non-NULL if contacts available
+ */
+struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact_filtered(const struct ast_sip_aor *aor,
+	unsigned int flags);
+
+/*!
  * \brief Retrieve all contacts currently available for an AOR
  *
  * \param aor Pointer to the AOR
@@ -1012,6 +1097,23 @@ struct ast_sip_contact *ast_sip_location
 struct ao2_container *ast_sip_location_retrieve_aor_contacts(const struct ast_sip_aor *aor);
 
 /*!
+ * \brief Retrieve all contacts currently available for an AOR and filter based on flags
+ * \since 13.16.0
+ *
+ * \param aor Pointer to the AOR
+ * \param flags Filtering flags
+ *
+ * \retval NULL if no contacts available
+ * \retval non-NULL if contacts available
+ *
+ * \warning
+ * Since this function prunes expired contacts before returning, it holds a named write
+ * lock on the aor.  If you already hold the lock, call ast_sip_location_retrieve_aor_contacts_nolock instead.
+ */
+struct ao2_container *ast_sip_location_retrieve_aor_contacts_filtered(const struct ast_sip_aor *aor,
+	unsigned int flags);
+
+/*!
  * \brief Retrieve all contacts currently available for an AOR without locking the AOR
  * \since 13.9.0
  *
@@ -1026,6 +1128,22 @@ struct ao2_container *ast_sip_location_r
 struct ao2_container *ast_sip_location_retrieve_aor_contacts_nolock(const struct ast_sip_aor *aor);
 
 /*!
+ * \brief Retrieve all contacts currently available for an AOR without locking the AOR and filter based on flags
+ * \since 13.16.0
+ *
+ * \param aor Pointer to the AOR
+ * \param flags Filtering flags
+ *
+ * \retval NULL if no contacts available
+ * \retval non-NULL if contacts available
+ *
+ * \warning
+ * This function should only be called if you already hold a named write lock on the aor.
+ */
+struct ao2_container *ast_sip_location_retrieve_aor_contacts_nolock_filtered(const struct ast_sip_aor *aor,
+	unsigned int flags);
+
+/*!
  * \brief Retrieve the first bound contact from a list of AORs
  *
  * \param aor_list A comma-separated list of AOR names
@@ -1054,6 +1172,18 @@ struct ao2_container *ast_sip_location_r
 	struct ast_sip_contact **contact);
 
 /*!
+ * \brief Retrieve the first bound contact AND the AOR chosen from a list of AORs and filter based on flags
+ * \since 13.16.0
+ *
+ * \param aor_list A comma-separated list of AOR names
+ * \param flags Filtering flags
+ * \param aor The chosen AOR
+ * \param contact The chosen contact
+ */
+void ast_sip_location_retrieve_contact_and_aor_from_list_filtered(const char *aor_list, unsigned int flags,
+	struct ast_sip_aor **aor, struct ast_sip_contact **contact);
+
+/*!
  * \brief Retrieve a named contact
  *
  * \param contact_name Name of the contact
@@ -1082,6 +1212,7 @@ struct ast_sip_contact *ast_sip_location
  */
 int ast_sip_location_add_contact(struct ast_sip_aor *aor, const char *uri,
 	struct timeval expiration_time, const char *path_info, const char *user_agent,
+	const char *via_addr, int via_port, const char *call_id,
 	struct ast_sip_endpoint *endpoint);
 
 /*!
@@ -1103,6 +1234,7 @@ int ast_sip_location_add_contact(struct
  */
 int ast_sip_location_add_contact_nolock(struct ast_sip_aor *aor, const char *uri,
 	struct timeval expiration_time, const char *path_info, const char *user_agent,
+	const char *via_addr, int via_port, const char *call_id,
 	struct ast_sip_endpoint *endpoint);
 
 /*!
@@ -1174,8 +1306,9 @@ struct ast_sip_auth *ast_sip_get_artific
  */
 struct ast_sip_endpoint *ast_sip_get_artificial_endpoint(void);
 
-/*!
- * \page Threading model for SIP
+/*! \defgroup pjsip_threading PJSIP Threading Model
+ * @{
+ * \page PJSIP PJSIP Threading Model
  *
  * There are three major types of threads that SIP will have to deal with:
  * \li Asterisk threads
@@ -1224,6 +1357,19 @@ struct ast_sip_endpoint *ast_sip_get_art
  * previous tasks pushed with the same serializer have completed. For more information
  * on serializers and the benefits they provide, see \ref ast_threadpool_serializer
  *
+ * \par Scheduler
+ *
+ * Some situations require that a task run periodically or at a future time.  Normally
+ * the ast_sched functionality would be used but ast_sched only uses 1 thread for all
+ * tasks and that thread isn't registered with PJLIB and therefore can't do any PJSIP
+ * related work.
+ *
+ * ast_sip_sched uses ast_sched only as a scheduled queue.  When a task is ready to run,
+ * it's pushed to a Serializer to be invoked asynchronously by a Servant.  This ensures
+ * that the task is executed in a PJLIB registered thread and allows the ast_sched thread
+ * to immediately continue processing the queue.  The Serializer used by ast_sip_sched
+ * is one of your choosing or a random one from the res_pjsip pool if you don't choose one.
+ *
  * \note
  *
  * Do not make assumptions about individual threads based on a corresponding serializer.
@@ -1232,6 +1378,8 @@ struct ast_sip_endpoint *ast_sip_get_art
  * tasks, even though they are all guaranteed to be executed in sequence.
  */
 
+typedef int (*ast_sip_task)(void *user_data);
+
 /*!
  * \brief Create a new serializer for SIP tasks
  *
@@ -1293,6 +1441,27 @@ struct ast_taskprocessor *ast_sip_create
 struct ast_taskprocessor *ast_sip_create_serializer_group_named(const char *name, struct ast_serializer_shutdown_group *shutdown_group);
 
 /*!
+ * \brief Determine the distributor serializer for the SIP message.
+ * \since 13.10.0
+ *
+ * \param rdata The incoming message.
+ *
+ * \retval Calculated distributor serializer on success.
+ * \retval NULL on error.
+ */
+struct ast_taskprocessor *ast_sip_get_distributor_serializer(pjsip_rx_data *rdata);
+
+/*!
+ * \brief Record the task's serializer name on the tdata structure.
+ * \since 13.15.0
+ *
+ * \param tdata The outgoing message.
+ *
+ * \retval PJ_SUCCESS.
+ */
+pj_status_t ast_sip_record_request_serializer(pjsip_tx_data *tdata);
+
+/*!
  * \brief Set a serializer on a SIP dialog so requests and responses are automatically serialized
  *
  * Passing a NULL serializer is a way to remove a serializer from a dialog.
@@ -1369,6 +1538,214 @@ int ast_sip_push_task_synchronous(struct
 int ast_sip_thread_is_servant(void);
 
 /*!
+ * \brief Task flags for the res_pjsip scheduler
+ *
+ * The default is AST_SIP_SCHED_TASK_FIXED
+ *                | AST_SIP_SCHED_TASK_DATA_NOT_AO2
+ *                | AST_SIP_SCHED_TASK_DATA_NO_CLEANUP
+ *                | AST_SIP_SCHED_TASK_PERIODIC
+ */
+enum ast_sip_scheduler_task_flags {
+	/*!
+	 * The defaults
+	 */
+	AST_SIP_SCHED_TASK_DEFAULTS = (0 << 0),
+
+	/*!
+	 * Run at a fixed interval.
+	 * Stop scheduling if the callback returns 0.
+	 * Any other value is ignored.
+	 */
+	AST_SIP_SCHED_TASK_FIXED = (0 << 0),
+	/*!
+	 * Run at a variable interval.
+	 * Stop scheduling if the callback returns 0.
+	 * Any other return value is used as the new interval.
+	 */
+	AST_SIP_SCHED_TASK_VARIABLE = (1 << 0),
+
+	/*!
+	 * The task data is not an AO2 object.
+	 */
+	AST_SIP_SCHED_TASK_DATA_NOT_AO2 = (0 << 1),
+	/*!
+	 * The task data is an AO2 object.
+	 * A reference count will be held by the scheduler until
+	 * after the task has run for the final time (if ever).
+	 */
+	AST_SIP_SCHED_TASK_DATA_AO2 = (1 << 1),
+
+	/*!
+	 * Don't take any cleanup action on the data
+	 */
+	AST_SIP_SCHED_TASK_DATA_NO_CLEANUP = (0 << 3),
+	/*!
+	 * If AST_SIP_SCHED_TASK_DATA_AO2 is set, decrement the reference count
+	 * otherwise call ast_free on it.
+	 */
+	AST_SIP_SCHED_TASK_DATA_FREE = ( 1 << 3 ),
+
+	/*! \brief AST_SIP_SCHED_TASK_PERIODIC
+	 * The task is scheduled at multiples of interval
+	 * \see Interval
+	 */
+	AST_SIP_SCHED_TASK_PERIODIC = (0 << 4),
+	/*! \brief AST_SIP_SCHED_TASK_DELAY
+	 * The next invocation of the task is at last finish + interval
+	 * \see Interval
+	 */
+	AST_SIP_SCHED_TASK_DELAY = (1 << 4),
+};
+
+/*!
+ * \brief Scheduler task data structure
+ */
+struct ast_sip_sched_task;
+
+/*!
+ * \brief Schedule a task to run in the res_pjsip thread pool
+ * \since 13.9.0
+ *
+ * \param serializer The serializer to use.  If NULL, don't use a serializer (see note below)
+ * \param interval The invocation interval in milliseconds (see note below)
+ * \param sip_task The task to invoke
+ * \param name An optional name to associate with the task
+ * \param task_data Optional data to pass to the task
+ * \param flags One of enum ast_sip_scheduler_task_type
+ *
+ * \returns Pointer to \ref ast_sip_sched_task ao2 object which must be dereferenced when done.
+ *
+ * \paragraph Serialization
+ *
+ * Specifying a serializer guarantees serialized execution but NOT specifying a serializer
+ * may still result in tasks being effectively serialized if the thread pool is busy.
+ * The point of the serializer BTW is not to prevent parallel executions of the SAME task.
+ * That happens automatically (see below).  It's to prevent the task from running at the same
+ * time as other work using the same serializer, whether or not it's being run by the scheduler.
+ *
+ * \paragraph Interval
+ *
+ * The interval is used to calculate the next time the task should run.  There are two models.
+ *
+ * \ref AST_SIP_SCHED_TASK_PERIODIC specifies that the invocations of the task occur at the
+ * specific interval.  That is, every \ref "interval" milliseconds, regardless of how long the task
+ * takes. If the task takes longer than \ref interval, it will be scheduled at the next available
+ * multiple of \ref interval.  For exmaple: If the task has an interval of 60 seconds and the task
+ * takes 70 seconds, the next invocation will happen at 120 seconds.
+ *
+ * \ref AST_SIP_SCHED_TASK_DELAY specifies that the next invocation of the task should start
+ * at \ref interval milliseconds after the current invocation has finished.
+ *
+ */
+struct ast_sip_sched_task *ast_sip_schedule_task(struct ast_taskprocessor *serializer,
+	int interval, ast_sip_task sip_task, char *name, void *task_data,
+	enum ast_sip_scheduler_task_flags flags);
+
+/*!
+ * \brief Cancels the next invocation of a task
+ * \since 13.9.0
+ *
+ * \param schtd The task structure pointer
+ * \retval 0 Success
+ * \retval -1 Failure
+ * \note Only cancels future invocations not the currently running invocation.
+ */
+int ast_sip_sched_task_cancel(struct ast_sip_sched_task *schtd);
+
+/*!
+ * \brief Cancels the next invocation of a task by name
+ * \since 13.9.0
+ *
+ * \param name The task name
+ * \retval 0 Success
+ * \retval -1 Failure
+ * \note Only cancels future invocations not the currently running invocation.
+ */
+int ast_sip_sched_task_cancel_by_name(const char *name);
+
+/*!
+ * \brief Gets the last start and end times of the task
+ * \since 13.9.0
+ *
+ * \param schtd The task structure pointer
+ * \param[out] when_queued Pointer to a timeval structure to contain the time when queued
+ * \param[out] last_start Pointer to a timeval structure to contain the time when last started
+ * \param[out] last_end Pointer to a timeval structure to contain the time when last ended
+ * \retval 0 Success
+ * \retval -1 Failure
+ * \note Any of the pointers can be NULL if you don't need them.
+ */
+int ast_sip_sched_task_get_times(struct ast_sip_sched_task *schtd,
+	struct timeval *when_queued, struct timeval *last_start, struct timeval *last_end);
+
+/*!
+ * \brief Gets the last start and end times of the task by name
+ * \since 13.9.0
+ *
+ * \param name The task name
+ * \param[out] when_queued Pointer to a timeval structure to contain the time when queued
+ * \param[out] last_start Pointer to a timeval structure to contain the time when last started
+ * \param[out] last_end Pointer to a timeval structure to contain the time when last ended
+ * \retval 0 Success
+ * \retval -1 Failure
+ * \note Any of the pointers can be NULL if you don't need them.
+ */
+int ast_sip_sched_task_get_times_by_name(const char *name,
+	struct timeval *when_queued, struct timeval *last_start, struct timeval *last_end);
+
+/*!
+ * \brief Gets the number of milliseconds until the next invocation
+ * \since 13.9.0
+ *
+ * \param schtd The task structure pointer
+ * \return The number of milliseconds until the next invocation or -1 if the task isn't scheduled
+ */
+int ast_sip_sched_task_get_next_run(struct ast_sip_sched_task *schtd);
+
+/*!
+ * \brief Gets the number of milliseconds until the next invocation
+ * \since 13.9.0
+ *
+ * \param name The task name
+ * \return The number of milliseconds until the next invocation or -1 if the task isn't scheduled
+ */
+int ast_sip_sched_task_get_next_run_by_name(const char *name);
+
+/*!
+ * \brief Checks if the task is currently running
+ * \since 13.9.0
+ *
+ * \param schtd The task structure pointer
+ * \retval 0 not running
+ * \retval 1 running
+ */
+int ast_sip_sched_is_task_running(struct ast_sip_sched_task *schtd);
+
+/*!
+ * \brief Checks if the task is currently running
+ * \since 13.9.0
+ *
+ * \param name The task name
+ * \retval 0 not running or not found
+ * \retval 1 running
+ */
+int ast_sip_sched_is_task_running_by_name(const char *name);
+
+/*!
+ * \brief Gets the task name
+ * \since 13.9.0
+ *
+ * \param schtd The task structure pointer
+ * \retval 0 success
+ * \retval 1 failure
+ */
+int ast_sip_sched_task_get_name(struct ast_sip_sched_task *schtd, char *name, size_t maxlen);
+
+/*!
+ *  @}
+ */
+
+/*!
  * \brief SIP body description
  *
  * This contains a type and subtype that will be added as
@@ -1407,6 +1784,26 @@ pjsip_dialog *ast_sip_create_dialog_uas(
 
 /*!
  * \brief General purpose method for creating an rdata structure using specific information
+ * \since 13.15.0
+ *
+ * \param rdata[out] The rdata structure that will be populated
+ * \param packet A SIP message
+ * \param src_name The source IP address of the message
+ * \param src_port The source port of the message
+ * \param transport_type The type of transport the message was received on
+ * \param local_name The local IP address the message was received on
+ * \param local_port The local port the message was received on
+ * \param contact_uri The contact URI of the message
+ *
+ * \retval 0 success
+ * \retval -1 failure
+ */
+int ast_sip_create_rdata_with_contact(pjsip_rx_data *rdata, char *packet,
+	const char *src_name, int src_port, char *transport_type, const char *local_name,
+	int local_port, const char *contact_uri);
+
+/*!
+ * \brief General purpose method for creating an rdata structure using specific information
  *
  * \param rdata[out] The rdata structure that will be populated
  * \param packet A SIP message
@@ -1419,8 +1816,8 @@ pjsip_dialog *ast_sip_create_dialog_uas(
  * \retval 0 success
  * \retval -1 failure
  */
-int ast_sip_create_rdata(pjsip_rx_data *rdata, char *packet, const char *src_name, int src_port, char *transport_type,
-	const char *local_name, int local_port);
+int ast_sip_create_rdata(pjsip_rx_data *rdata, char *packet, const char *src_name,
+	int src_port, char *transport_type, const char *local_name, int local_port);
 
 /*!
  * \brief General purpose method for creating a SIP request
@@ -2038,6 +2435,16 @@ int ast_sip_format_endpoint_ami(struct a
 				struct ast_sip_ami *ami, int *count);
 
 /*!
+ * \brief Formats the contact and sends over AMI.
+ *
+ * \param obj a pointer an ast_sip_contact_wrapper structure
+ * \param arg a pointer to an ast_sip_ami structure
+ * \param flags ignored
+ * \retval 0 Success, otherwise non-zero on error
+ */
+int ast_sip_format_contact_ami(void *obj, void *arg, int flags);
+
+/*!
  * \brief Format auth details for AMI.
  *
  * \param auths an auth array
@@ -2184,6 +2591,64 @@ int ast_sip_register_supplement(struct a
 void ast_sip_unregister_supplement(struct ast_sip_supplement *supplement);
 
 /*!
+ * \brief Retrieve the global MWI taskprocessor high water alert trigger level.
+ *
+ * \since 13.12.0
+ *
+ * \retval the system MWI taskprocessor high water alert trigger level
+ */
+unsigned int ast_sip_get_mwi_tps_queue_high(void);
+
+/*!
+ * \brief Retrieve the global MWI taskprocessor low water clear alert level.
+ *
+ * \since 13.12.0
+ *
+ * \retval the system MWI taskprocessor low water clear alert level
+ */
+int ast_sip_get_mwi_tps_queue_low(void);
+
+/*!
+ * \brief Retrieve the global setting 'disable sending unsolicited mwi on startup'.
+ * \since 13.12.0
+ *
+ * \retval non zero if disable.
+ */
+unsigned int ast_sip_get_mwi_disable_initial_unsolicited(void);
+
+/*!
+ * \brief Retrieve the global setting 'ignore_uri_user_options'.
+ * \since 13.12.0
+ *
+ * \retval non zero if ignore the user field options.
+ */
+unsigned int ast_sip_get_ignore_uri_user_options(void);
+
+/*!
+ * \brief Truncate the URI user field options string if enabled.
+ * \since 13.12.0
+ *
+ * \param str URI user field string to truncate if enabled
+ *
+ * \details
+ * We need to be able to handle URI's looking like
+ * "sip:1235557890;phone-context=national@x.x.x.x;user=phone"
+ *
+ * Where the URI user field is:
+ * "1235557890;phone-context=national"
+ *
+ * When truncated the string will become:
+ * "1235557890"
+ */
+#define AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(str)				\
+	do {														\
+		char *__semi = strchr((str), ';');						\
+		if (__semi && ast_sip_get_ignore_uri_user_options()) {	\
+			*__semi = '\0';										\
+		}														\
+	} while (0)
+
+/*!
  * \brief Retrieve the system debug setting (yes|no|host).
  *
  * \note returned string needs to be de-allocated by caller.
@@ -2223,6 +2688,18 @@ char *ast_sip_get_endpoint_identifier_or
 char *ast_sip_get_default_voicemail_extension(void);
 
 /*!
+ * \brief Retrieve the global default realm.
+ *
+ * This is the value placed in outbound challenges' realm if there
+ * is no better option (such as an auth-configured realm).
+ *
+ * \param[out] realm The default realm
+ * \param size The buffer size of realm
+ * \return nothing
+ */
+void ast_sip_get_default_realm(char *realm, size_t size);
+
+/*!
  * \brief Retrieve the global default from user.
  *
  * This is the value placed in outbound requests' From header if there
@@ -2258,6 +2735,13 @@ unsigned int ast_sip_get_keep_alive_inte
  */
 unsigned int ast_sip_get_contact_expiration_check_interval(void);
 
+/*!
+ * \brief Retrieve the system setting 'disable multi domain'.
+ * \since 13.9.0
+ *
+ * \retval non zero if disable multi domain.
+ */
+unsigned int ast_sip_get_disable_multi_domain(void);
 
 /*!
  * \brief Retrieve the system max initial qualify time.
@@ -2361,5 +2845,65 @@ int ast_sip_set_tpselector_from_transpor
 void ast_sip_modify_id_header(pj_pool_t *pool, pjsip_fromto_hdr *id_hdr,
 	const struct ast_party_id *id);
 
+/*!
+ * \brief Retrieve the unidentified request security event thresholds
+ * \since 13.8.0
+ *
+ * \param count The maximum number of unidentified requests per source ip to accumulate before emitting a security event
+ * \param period The period in seconds over which to accumulate unidentified requests
+ * \param prune_interval The interval in seconds at which expired entries will be pruned
+ */
+void ast_sip_get_unidentified_request_thresholds(unsigned int *count, unsigned int *period,
+	unsigned int *prune_interval);
+
+/*!
+ * \brief Get the transport name from an endpoint or request uri
+ * \since 13.15.0
+ *
+ * \param endpoint
+ * \param sip_uri
+ * \param buf Buffer to receive transport name
+ * \param buf_len Buffer length
+ *
+ * \retval 0 Success
+ * \retval -1 Failure
+ *
+ * \note
+ * If endpoint->transport is not NULL, it is returned in buf.
+ * Otherwise if sip_uri has an 'x-ast-txp' parameter AND the sip_uri host is
+ * an ip4 or ip6 address, its value is returned,
+ */
+int ast_sip_get_transport_name(const struct ast_sip_endpoint *endpoint,
+	pjsip_sip_uri *sip_uri, char *buf, size_t buf_len);
+
+/*!
+ * \brief Sets pjsip_tpselector from an endpoint or uri
+ * \since 13.15.0
+ *
+ * \param endpoint If endpoint->transport is set, it's used
+ * \param sip_uri If sip_uri contains a x-ast-txp parameter, it's used
+ * \param selector The selector to be populated
+ *
+ * \retval 0 success
+ * \retval -1 failure
+ */
+int ast_sip_set_tpselector_from_ep_or_uri(const struct ast_sip_endpoint *endpoint,
+	pjsip_sip_uri *sip_uri, pjsip_tpselector *selector);
+
+/*!
+ * \brief Set the transport on a dialog
+ * \since 13.15.0
+ *
+ * \param endpoint
+ * \param dlg
+ * \param selector (optional)
+ *
+ * \note
+ * This API calls ast_sip_get_transport_name(endpoint, dlg->target) and if the result is
+ * non-NULL, calls pjsip_dlg_set_transport.  If 'selector' is non-NULL, it is updated with
+ * the selector used.
+ */
+int ast_sip_dlg_set_transport(const struct ast_sip_endpoint *endpoint, pjsip_dialog *dlg,
+	pjsip_tpselector *selector);
 
 #endif /* _RES_PJSIP_H */
diff -urpN asterisk-13.9.1/include/asterisk/res_pjsip_presence_xml.h asterisk-13.17.0/include/asterisk/res_pjsip_presence_xml.h
--- asterisk-13.9.1/include/asterisk/res_pjsip_presence_xml.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_pjsip_presence_xml.h	2017-07-12 13:12:08.000000000 +0200
@@ -69,7 +69,8 @@ void ast_sip_sanitize_xml(const char *in
  * \param[out] local_state
  */
 void ast_sip_presence_exten_state_to_str(int state, char **statestring,
-		char **pidfstate, char **pidfnote, enum ast_sip_pidf_state *local_state);
+		char **pidfstate, char **pidfnote, enum ast_sip_pidf_state *local_state,
+		unsigned int notify_early_inuse_ringing);
 
 /*!
  * \brief Create XML attribute
diff -urpN asterisk-13.9.1/include/asterisk/res_pjsip_pubsub.h asterisk-13.17.0/include/asterisk/res_pjsip_pubsub.h
--- asterisk-13.9.1/include/asterisk/res_pjsip_pubsub.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_pjsip_pubsub.h	2017-07-12 13:12:08.000000000 +0200
@@ -214,9 +214,9 @@ enum ast_sip_subscription_notify_reason
 	AST_SIP_SUBSCRIPTION_NOTIFY_REASON_OTHER
 };
 
-/*! Type used for conveying mailbox state */
-#define AST_SIP_EXTEN_STATE_DATA "ast_sip_exten_state_data"
 /*! Type used for extension state/presence */
+#define AST_SIP_EXTEN_STATE_DATA "ast_sip_exten_state_data"
+/*! Type used for conveying mailbox state */
 #define AST_SIP_MESSAGE_ACCUMULATOR "ast_sip_message_accumulator"
 
 /*!
diff -urpN asterisk-13.9.1/include/asterisk/res_pjsip_session.h asterisk-13.17.0/include/asterisk/res_pjsip_session.h
--- asterisk-13.9.1/include/asterisk/res_pjsip_session.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/res_pjsip_session.h	2017-07-12 13:12:08.000000000 +0200
@@ -83,6 +83,8 @@ struct ast_sip_session_media {
 	int timeout_sched_id;
 	/*! \brief Stream is on hold */
 	unsigned int held:1;
+	/*! \brief Does remote support rtcp_mux */
+	unsigned int remote_rtcp_mux:1;
 	/*! \brief Stream type this session media handles */
 	char stream_type[1];
 };
@@ -137,7 +139,7 @@ struct ast_sip_session {
 	struct ast_party_id id;
 	/*! Requested capabilities */
 	struct ast_format_cap *req_caps;
-	/*! Optional DSP, used only for inband DTMF detection if configured */
+	/*! Optional DSP, used only for inband DTMF/Fax-CNG detection if configured */
 	struct ast_dsp *dsp;
 	/*! Whether the termination of the session should be deferred */
 	unsigned int defer_terminate:1;
@@ -151,6 +153,10 @@ struct ast_sip_session {
 	struct ast_sip_aor *aor;
 	/*! From header saved at invite creation */
 	pjsip_fromto_hdr *saved_from_hdr;
+	/*! Whether the end of the session should be deferred */
+	unsigned int defer_end:1;
+	/*! Session end (remote hangup) requested while termination deferred */
+	unsigned int ended_while_deferred:1;
 };
 
 typedef int (*ast_sip_session_request_creation_cb)(struct ast_sip_session *session, pjsip_tx_data *tdata);
@@ -406,9 +412,10 @@ struct ast_sip_channel_pvt *ast_sip_chan
  * \param endpoint The endpoint that this session communicates with
  * \param contact The contact associated with this session
  * \param inv_session The PJSIP INVITE session data
+ * \param rdata INVITE request received (NULL if for outgoing allocation)
  */
 struct ast_sip_session *ast_sip_session_alloc(struct ast_sip_endpoint *endpoint,
-	struct ast_sip_contact *contact, pjsip_inv_session *inv);
+	struct ast_sip_contact *contact, pjsip_inv_session *inv, pjsip_rx_data *rdata);
 
 /*!
  * \brief Request and wait for the session serializer to be suspended.
@@ -454,6 +461,10 @@ struct ast_sip_session *ast_sip_session_
  *
  * \param session The session to terminate
  * \param response The response code to use for termination if possible
+ *
+ * \warning Calling this function MAY cause the last session reference to be
+ * released and the session destructor to be called.  If you need to do something
+ * with session after this call, be sure to bump the ref count before calling terminate.
  */
 void ast_sip_session_terminate(struct ast_sip_session *session, int response);
 
@@ -475,6 +486,13 @@ int ast_sip_session_defer_termination(st
 void ast_sip_session_defer_termination_cancel(struct ast_sip_session *session);
 
 /*!
+ * \brief End the session if it had been previously deferred
+ *
+ * \param session The session to end if it had been deferred
+ */
+void ast_sip_session_end_if_deferred(struct ast_sip_session *session);
+
+/*!
  * \brief Register an SDP handler
  *
  * An SDP handler is responsible for parsing incoming SDP streams and ensuring that
diff -urpN asterisk-13.9.1/include/asterisk/rtp_engine.h asterisk-13.17.0/include/asterisk/rtp_engine.h
--- asterisk-13.9.1/include/asterisk/rtp_engine.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/rtp_engine.h	2017-07-12 13:12:08.000000000 +0200
@@ -84,6 +84,9 @@ extern "C" {
 /*! First dynamic RTP payload type */
 #define AST_RTP_PT_FIRST_DYNAMIC 96
 
+/*! Last reassignable RTP payload type */
+#define AST_RTP_PT_LAST_REASSIGN 63
+
 /*! Maximum number of generations */
 #define AST_RED_MAX_GENERATION 5
 
@@ -234,6 +237,15 @@ enum ast_rtp_instance_stat {
 	AST_RTP_INSTANCE_STAT_RXOCTETCOUNT,
 };
 
+enum ast_rtp_instance_rtcp {
+	/*! RTCP should not be sent/received */
+	AST_RTP_INSTANCE_RTCP_DISABLED = 0,
+	/*! RTCP should be sent/received based on standard port rules */
+	AST_RTP_INSTANCE_RTCP_STANDARD,
+	/*! RTCP should be sent/received on the same port as RTP */
+	AST_RTP_INSTANCE_RTCP_MUX,
+};
+
 /* Codes for RTP-specific data - not defined by our AST_FORMAT codes */
 /*! DTMF (RFC2833) */
 #define AST_RTP_DTMF                    (1 << 0)
@@ -366,7 +378,7 @@ struct ast_rtp_instance_stats {
 };
 
 #define AST_RTP_STAT_SET(current_stat, combined, placement, value) \
-if (stat == current_stat || stat == AST_RTP_INSTANCE_STAT_ALL || (combined >= 0 && combined == current_stat)) { \
+if (stat == current_stat || stat == AST_RTP_INSTANCE_STAT_ALL || (combined >= 0 && combined == stat)) { \
 placement = value; \
 if (stat == current_stat) { \
 return 0; \
@@ -374,7 +386,7 @@ return 0; \
 }
 
 #define AST_RTP_STAT_STRCPY(current_stat, combined, placement, value) \
-if (stat == current_stat || stat == AST_RTP_INSTANCE_STAT_ALL || (combined >= 0 && combined == current_stat)) { \
+if (stat == current_stat || stat == AST_RTP_INSTANCE_STAT_ALL || (combined >= 0 && combined == stat)) { \
 	ast_copy_string(placement, value, sizeof(placement)); \
 	if (stat == current_stat) { \
 		return 0; \
@@ -440,6 +452,8 @@ struct ast_rtp_engine_ice {
 	void (*turn_request)(struct ast_rtp_instance *instance, enum ast_rtp_ice_component_type component,
 		enum ast_transport transport, const char *server, unsigned int port,
 		const char *username, const char *password);
+	/*! Callback to alter the number of ICE components on a session */
+	void (*change_components)(struct ast_rtp_instance *instance, int num_components);
 };
 
 /*! \brief DTLS setup types */
@@ -610,12 +624,13 @@ struct ast_rtp_glue {
 	/*!
 	 * \brief Used to prevent two channels from remotely bridging audio rtp if the channel tech has a
 	 *        reason for prohibiting it based on qualities that need to be compared from both channels.
-	 * \note This function may be NULL for a given channel driver. This should be accounted for and if that is the case, function this is not used.
+	 * \note This function may be NULL for a given channel driver. This should be accounted for and if that is the case, this function is not used.
 	 */
 	int (*allow_rtp_remote)(struct ast_channel *chan1, struct ast_rtp_instance *instance);
 	/*!
 	 * \brief Callback for retrieving the RTP instance carrying video
 	 * \note This function increases the reference count on the returned RTP instance.
+	 * \note This function may be NULL for a given channel driver. This should be accounted for and if that is the case, this function is not used.
 	 */
 	enum ast_rtp_glue_result (*get_vrtp_info)(struct ast_channel *chan, struct ast_rtp_instance **instance);
 	/*!
@@ -628,11 +643,15 @@ struct ast_rtp_glue {
 	/*!
 	 * \brief Callback for retrieving the RTP instance carrying text
 	 * \note This function increases the reference count on the returned RTP instance.
+	 * \note This function may be NULL for a given channel driver. This should be accounted for and if that is the case, this function is not used.
 	 */
 	enum ast_rtp_glue_result (*get_trtp_info)(struct ast_channel *chan, struct ast_rtp_instance **instance);
 	/*! Callback for updating the destination that the remote side should send RTP to */
 	int (*update_peer)(struct ast_channel *chan, struct ast_rtp_instance *instance, struct ast_rtp_instance *vinstance, struct ast_rtp_instance *tinstance, const struct ast_format_cap *cap, int nat_active);
-	/*! Callback for retrieving codecs that the channel can do.  Result returned in result_cap. */
+	/*!
+	 * \brief Callback for retrieving codecs that the channel can do.  Result returned in result_cap.
+	 * \note This function may be NULL for a given channel driver. This should be accounted for and if that is the case, this function is not used.
+	 */
 	void (*get_codec)(struct ast_channel *chan, struct ast_format_cap *result_cap);
 	/*! Linked list information */
 	AST_RWLIST_ENTRY(ast_rtp_glue) entry;
diff -urpN asterisk-13.9.1/include/asterisk/smoother.h asterisk-13.17.0/include/asterisk/smoother.h
--- asterisk-13.9.1/include/asterisk/smoother.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/smoother.h	2017-07-12 13:12:08.000000000 +0200
@@ -33,6 +33,7 @@ extern "C" {
 
 #define AST_SMOOTHER_FLAG_G729		(1 << 0)
 #define AST_SMOOTHER_FLAG_BE		(1 << 1)
+#define AST_SMOOTHER_FLAG_FORCED	(1 << 2)
 
 /*! \name AST_Smoother
 */
diff -urpN asterisk-13.9.1/include/asterisk/sorcery.h asterisk-13.17.0/include/asterisk/sorcery.h
--- asterisk-13.9.1/include/asterisk/sorcery.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/sorcery.h	2017-07-12 13:12:08.000000000 +0200
@@ -692,6 +692,20 @@ int __ast_sorcery_object_register(struct
 	__ast_sorcery_object_register((sorcery), (type), 1, 1, (alloc), (transform), (apply))
 
 /*!
+ * \brief Set the high and low alert water marks of the sorcery object type.
+ * \since 13.10.0
+ *
+ * \param sorcery Pointer to a sorcery structure
+ * \param type Type of object
+ * \param low_water New queue low water mark. (-1 to set as 90% of high_water)
+ * \param high_water New queue high water mark.
+ *
+ * \retval 0 on success.
+ * \retval -1 on error (water marks not changed).
+ */
+int ast_sorcery_object_set_congestion_levels(struct ast_sorcery *sorcery, const char *type, long low_water, long high_water);
+
+/*!
  * \brief Set the copy handler for an object type
  *
  * \param sorcery Pointer to a sorcery structure
diff -urpN asterisk-13.9.1/include/asterisk/stasis.h asterisk-13.17.0/include/asterisk/stasis.h
--- asterisk-13.9.1/include/asterisk/stasis.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis.h	2017-07-12 13:12:08.000000000 +0200
@@ -416,14 +416,14 @@ const struct timeval *stasis_message_tim
  * May return \c NULL, to indicate no representation. The returned object should
  * be ast_json_unref()'ed.
  *
- * \param message Message to convert to JSON string.
+ * \param msg Message to convert to JSON string.
  * \param sanitize Snapshot sanitization callback.
  *
  * \return Newly allocated string with JSON message.
  * \return \c NULL on error.
  * \return \c NULL if JSON format is not supported.
  */
-struct ast_json *stasis_message_to_json(struct stasis_message *message, struct stasis_message_sanitizer *sanitize);
+struct ast_json *stasis_message_to_json(struct stasis_message *msg, struct stasis_message_sanitizer *sanitize);
 
 /*!
  * \brief Build the AMI representation of the message.
@@ -431,12 +431,21 @@ struct ast_json *stasis_message_to_json(
  * May return \c NULL, to indicate no representation. The returned object should
  * be ao2_cleanup()'ed.
  *
- * \param message Message to convert to AMI.
+ * \param msg Message to convert to AMI.
  * \return \c NULL on error.
  * \return \c NULL if AMI format is not supported.
  */
-struct ast_manager_event_blob *stasis_message_to_ami(
-	struct stasis_message *message);
+struct ast_manager_event_blob *stasis_message_to_ami(struct stasis_message *msg);
+
+/*!
+ * \brief Determine if the given message can be converted to AMI.
+ *
+ * \param msg Message to see if can be converted to AMI.
+ *
+ * \retval 0 Cannot be converted
+ * \retval non-zero Can be converted
+ */
+int stasis_message_can_be_ami(struct stasis_message *msg);
 
 /*!
  * \brief Build the \ref AstGenericEvents representation of the message.
@@ -444,12 +453,11 @@ struct ast_manager_event_blob *stasis_me
  * May return \c NULL, to indicate no representation. The returned object should
  * be disposed of via \ref ast_event_destroy.
  *
- * \param message Message to convert to AMI.
+ * \param msg Message to convert to AMI.
  * \return \c NULL on error.
  * \return \c NULL if AMI format is not supported.
  */
-struct ast_event *stasis_message_to_event(
-	struct stasis_message *message);
+struct ast_event *stasis_message_to_event(struct stasis_message *msg);
 
 /*! @} */
 
@@ -593,6 +601,20 @@ struct stasis_subscription *stasis_unsub
 	struct stasis_subscription *subscription);
 
 /*!
+ * \brief Set the high and low alert water marks of the stasis subscription.
+ * \since 13.10.0
+ *
+ * \param subscription Pointer to a stasis subscription
+ * \param low_water New queue low water mark. (-1 to set as 90% of high_water)
+ * \param high_water New queue high water mark.
+ *
+ * \retval 0 on success.
+ * \retval -1 on error (water marks not changed).
+ */
+int stasis_subscription_set_congestion_limits(struct stasis_subscription *subscription,
+	long low_water, long high_water);
+
+/*!
  * \brief Block until the last message is processed on a subscription.
  *
  * This function will not return until the \a subscription's callback for the
diff -urpN asterisk-13.9.1/include/asterisk/stasis_app.h asterisk-13.17.0/include/asterisk/stasis_app.h
--- asterisk-13.9.1/include/asterisk/stasis_app.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis_app.h	2017-07-12 13:12:08.000000000 +0200
@@ -51,7 +51,6 @@
  */
 
 #include "asterisk/channel.h"
-#include "asterisk/json.h"
 
 /*! @{ */
 
@@ -77,6 +76,16 @@ typedef void (*stasis_app_cb)(void *data
 struct ao2_container *stasis_app_get_all(void);
 
 /*!
+ * \brief Retrieve a handle to a Stasis application by its name
+ *
+ * \param name The name of the registered Stasis application
+ *
+ * \return \c stasis_app on success.
+ * \return \c NULL on error.
+ */
+struct stasis_app *stasis_app_get_by_name(const char *name);
+
+/*!
  * \brief Register a new Stasis application.
  *
  * If an application is already registered with the given name, the old
@@ -746,6 +755,15 @@ int stasis_app_bridge_playback_channel_a
 	struct stasis_app_control *control);
 
 /*!
+ * \brief remove channel from list of ARI playback channels for bridges.
+ *
+ * \param bridge_id The unique ID of the bridge the playback channel is in.
+ * \param control The app control structure for the playback channel
+ */
+void stasis_app_bridge_playback_channel_remove(char *bridge_id,
+	struct stasis_app_control *control);
+
+/*!
  * \brief Result codes used when adding/removing channels to/from bridges.
  */
 enum stasis_app_control_channel_result {
@@ -872,6 +890,55 @@ int stasis_app_channel_unreal_set_intern
  */
 int stasis_app_channel_set_internal(struct ast_channel *chan);
 
+/*!
+ * \brief Enable/disable request/response and event logging on an application
+ *
+ * \param app The app to debug
+ * \param debug If non-zero, enable debugging. If zero, disable.
+ */
+void stasis_app_set_debug(struct stasis_app *app, int debug);
+
+/*!
+ * \brief Enable/disable request/response and event logging on an application
+ *
+ * \param app_name The app name to debug
+ * \param debug If non-zero, enable debugging. If zero, disable.
+ */
+void stasis_app_set_debug_by_name(const char *app_name, int debug);
+
+/*!
+ * \brief Get debug status of an application
+ *
+ * \param app The app to check
+ * \return The debug flag for the app || the global debug flag
+ */
+int stasis_app_get_debug(struct stasis_app *app);
+
+/*!
+ * \brief Get debug status of an application
+ *
+ * \param app_name The app_name to check
+ * \return The debug flag for the app || the global debug flag
+ */
+int stasis_app_get_debug_by_name(const char *app_name);
+
+/*!
+ * \brief Enable/disable request/response and event logging on all applications
+ *
+ * \param debug If non-zero, enable debugging. If zero, disable.
+ */
+void stasis_app_set_global_debug(int debug);
+
+struct ast_cli_args;
+
+/*!
+ * \brief Dump properties of a \c stasis_app to the CLI
+ *
+ * \param app The application
+ * \param a The CLI arguments
+ */
+void stasis_app_to_cli(const struct stasis_app *app, struct ast_cli_args *a);
+
 /*! @} */
 
 #endif /* _ASTERISK_STASIS_APP_H */
diff -urpN asterisk-13.9.1/include/asterisk/stasis_bridges.h asterisk-13.17.0/include/asterisk/stasis_bridges.h
--- asterisk-13.9.1/include/asterisk/stasis_bridges.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis_bridges.h	2017-07-12 13:12:08.000000000 +0200
@@ -58,6 +58,10 @@ struct ast_bridge_snapshot {
 	unsigned int num_channels;
 	/*! Number of active channels in the bridge. */
 	unsigned int num_active;
+	/*! The video mode of the bridge */
+	enum ast_bridge_video_mode_type video_mode;
+	/*! Unique ID of the channel providing video, if one exists */
+	AST_STRING_FIELD_EXTENDED(video_source_id);
 };
 
 /*!
diff -urpN asterisk-13.9.1/include/asterisk/stasis_channels.h asterisk-13.17.0/include/asterisk/stasis_channels.h
--- asterisk-13.9.1/include/asterisk/stasis_channels.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis_channels.h	2017-07-12 13:12:08.000000000 +0200
@@ -22,7 +22,6 @@
 
 #include "asterisk/stringfields.h"
 #include "asterisk/stasis.h"
-#include "asterisk/json.h"
 #include "asterisk/channel.h"
 
 /*! \addtogroup StasisTopicsAndMessages
diff -urpN asterisk-13.9.1/include/asterisk/stasis_endpoints.h asterisk-13.17.0/include/asterisk/stasis_endpoints.h
--- asterisk-13.9.1/include/asterisk/stasis_endpoints.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis_endpoints.h	2017-07-12 13:12:08.000000000 +0200
@@ -28,7 +28,6 @@
  */
 
 #include "asterisk/endpoints.h"
-#include "asterisk/json.h"
 #include "asterisk/stasis.h"
 #include "asterisk/stasis_cache_pattern.h"
 #include "asterisk/stringfields.h"
diff -urpN asterisk-13.9.1/include/asterisk/stasis_message_router.h asterisk-13.17.0/include/asterisk/stasis_message_router.h
--- asterisk-13.9.1/include/asterisk/stasis_message_router.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis_message_router.h	2017-07-12 13:12:08.000000000 +0200
@@ -127,6 +127,20 @@ void stasis_message_router_publish_sync(
 	struct stasis_message *message);
 
 /*!
+ * \brief Set the high and low alert water marks of the stasis message router.
+ * \since 13.10.0
+ *
+ * \param router Pointer to a stasis message router
+ * \param low_water New queue low water mark. (-1 to set as 90% of high_water)
+ * \param high_water New queue high water mark.
+ *
+ * \retval 0 on success.
+ * \retval -1 on error (water marks not changed).
+ */
+int stasis_message_router_set_congestion_limits(struct stasis_message_router *router,
+	long low_water, long high_water);
+
+/*!
  * \brief Add a route to a message router.
  *
  * A particular \a message_type may have at most one route per \a router. If
diff -urpN asterisk-13.9.1/include/asterisk/stasis_system.h asterisk-13.17.0/include/asterisk/stasis_system.h
--- asterisk-13.9.1/include/asterisk/stasis_system.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/stasis_system.h	2017-07-12 13:12:08.000000000 +0200
@@ -19,7 +19,6 @@
 #ifndef _ASTERISK_STASIS_SYSTEM_H
 #define _ASTERISK_STASIS_SYSTEM_H
 
-#include "asterisk/json.h"
 #include "asterisk/stasis.h"
 
 /*!
@@ -122,6 +121,12 @@ struct stasis_message_type *ast_cc_failu
 struct stasis_message_type *ast_cc_monitorfailed_type(void);
 
 /*!
+ * \brief A \ref stasis_message_type for Cluster discovery
+ * \since 13.11.0
+ */
+struct stasis_message_type *ast_cluster_discovery_type(void);
+
+/*!
  * \brief Initialize the stasis system topic and message types
  * \retval 0 on success
  * \retval -1 on failure
diff -urpN asterisk-13.9.1/include/asterisk/strings.h asterisk-13.17.0/include/asterisk/strings.h
--- asterisk-13.9.1/include/asterisk/strings.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/strings.h	2017-07-12 13:12:08.000000000 +0200
@@ -26,6 +26,7 @@
 /* #define DEBUG_OPAQUE */
 
 #include <ctype.h>
+#include <limits.h>
 
 #include "asterisk/utils.h"
 #include "asterisk/threadstorage.h"
@@ -616,7 +617,7 @@ int ast_regex_string_to_regex_pattern(co
  * \note The result of this function is dynamically allocated memory, and must
  *       be free()'d after it is no longer needed.
  */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 #define	ast_str_create(a)	_ast_str_create(a,__FILE__,__LINE__,__PRETTY_FUNCTION__)
 AST_INLINE_API(
 struct ast_str * attribute_malloc _ast_str_create(size_t init_len,
@@ -688,7 +689,7 @@ void ast_str_trim_blanks(struct ast_str
 	if (!buf) {
 		return;
 	}
-	while (buf->__AST_STR_USED && buf->__AST_STR_STR[buf->__AST_STR_USED - 1] < 33) {
+	while (buf->__AST_STR_USED && ((unsigned char) buf->__AST_STR_STR[buf->__AST_STR_USED - 1]) < 33) {
 		buf->__AST_STR_STR[--(buf->__AST_STR_USED)] = '\0';
 	}
 }
@@ -771,7 +772,7 @@ char *ast_str_truncate(struct ast_str *b
 /*!
  * Make space in a new string (e.g. to read in data from a file)
  */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 AST_INLINE_API(
 int _ast_str_make_space(struct ast_str **buf, size_t new_len, const char *file, int lineno, const char *function),
 {
@@ -964,7 +965,7 @@ enum {
  *       through calling one of the other functions or macros defined in this
  *       file.
  */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int __attribute__((format(printf, 4, 0))) __ast_debug_str_helper(struct ast_str **buf, ssize_t max_len,
 							   int append, const char *fmt, va_list ap, const char *file, int lineno, const char *func);
 #define __ast_str_helper(a,b,c,d,e)	__ast_debug_str_helper(a,b,c,d,e,__FILE__,__LINE__,__PRETTY_FUNCTION__)
@@ -1174,6 +1175,19 @@ char *ast_tech_to_upper(char *dev_str),
 )
 
 /*!
+ * \brief Restrict hash value range
+ *
+ * \details
+ * Hash values used all over asterisk are expected to be non-negative
+ * (signed) int values.  This function restricts an unsigned int hash
+ * value to the positive half of the (signed) int values.
+ */
+static force_inline int attribute_pure ast_str_hash_restrict(unsigned int hash)
+{
+	return (int) (hash & (unsigned int) INT_MAX);
+}
+
+/*!
  * \brief Compute a hash value on a string
  *
  * This famous hash algorithm was written by Dan Bernstein and is
@@ -1183,20 +1197,21 @@ char *ast_tech_to_upper(char *dev_str),
  */
 static force_inline int attribute_pure ast_str_hash(const char *str)
 {
-	int hash = 5381;
+	unsigned int hash = 5381;
 
-	while (*str)
-		hash = hash * 33 ^ *str++;
+	while (*str) {
+		hash = hash * 33 ^ (unsigned char) *str++;
+	}
 
-	return abs(hash);
+	return ast_str_hash_restrict(hash);
 }
 
 /*!
  * \brief Compute a hash value on a string
  *
  * \param[in] str The string to add to the hash
- * \param[in] hash The hash value to add to
- * 
+ * \param[in] seed The hash value to start with
+ *
  * \details
  * This version of the function is for when you need to compute a
  * string hash of more than one string.
@@ -1206,12 +1221,15 @@ static force_inline int attribute_pure a
  *
  * \sa http://www.cse.yorku.ca/~oz/hash.html
  */
-static force_inline int ast_str_hash_add(const char *str, int hash)
+static force_inline int ast_str_hash_add(const char *str, int seed)
 {
-	while (*str)
-		hash = hash * 33 ^ *str++;
+	unsigned int hash = (unsigned int) seed;
+
+	while (*str) {
+		hash = hash * 33 ^ (unsigned char) *str++;
+	}
 
-	return abs(hash);
+	return ast_str_hash_restrict(hash);
 }
 
 /*!
@@ -1223,13 +1241,13 @@ static force_inline int ast_str_hash_add
  */
 static force_inline int attribute_pure ast_str_case_hash(const char *str)
 {
-	int hash = 5381;
+	unsigned int hash = 5381;
 
 	while (*str) {
-		hash = hash * 33 ^ tolower(*str++);
+		hash = hash * 33 ^ (unsigned char) tolower(*str++);
 	}
 
-	return abs(hash);
+	return ast_str_hash_restrict(hash);
 }
 
 /*!
diff -urpN asterisk-13.9.1/include/asterisk/taskprocessor.h asterisk-13.17.0/include/asterisk/taskprocessor.h
--- asterisk-13.9.1/include/asterisk/taskprocessor.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/taskprocessor.h	2017-07-12 13:12:08.000000000 +0200
@@ -59,6 +59,7 @@ struct ast_taskprocessor;
 /*! \brief Suggested maximum taskprocessor name length (less null terminator). */
 #define AST_TASKPROCESSOR_MAX_NAME	45
 
+/*! Default taskprocessor high water level alert trigger */
 #define AST_TASKPROCESSOR_HIGH_WATER_LEVEL 500
 
 /*!
@@ -241,6 +242,38 @@ int ast_taskprocessor_push_local(struct
 	int (*task_exe)(struct ast_taskprocessor_local *local), void *datap);
 
 /*!
+ * \brief Indicate the taskprocessor is suspended.
+ *
+ * \since 13.12.0
+ *
+ * \param tps Task processor.
+ * \retval 0 success
+ * \retval -1 failure
+ */
+int ast_taskprocessor_suspend(struct ast_taskprocessor *tps);
+
+/*!
+ * \brief Indicate the taskprocessor is unsuspended.
+ *
+ * \since 13.12.0
+ *
+ * \param tps Task processor.
+ * \retval 0 success
+ * \retval -1 failure
+ */
+int ast_taskprocessor_unsuspend(struct ast_taskprocessor *tps);
+
+/*!
+ * \brief Get the task processor suspend status
+ *
+ * \since 13.12.0
+ *
+ * \param tps Task processor.
+ * \retval non-zero if the task processor is suspended
+ */
+int ast_taskprocessor_is_suspended(struct ast_taskprocessor *tps);
+
+/*!
  * \brief Pop a task off the taskprocessor and execute it.
  *
  * \since 12.0.0
@@ -297,4 +330,26 @@ const char *ast_taskprocessor_name(struc
  */
 long ast_taskprocessor_size(struct ast_taskprocessor *tps);
 
+/*!
+ * \brief Get the current taskprocessor high water alert count.
+ * \since 13.10.0
+ *
+ * \retval 0 if no taskprocessors are in high water alert.
+ * \retval non-zero if some task processors are in high water alert.
+ */
+unsigned int ast_taskprocessor_alert_get(void);
+
+/*!
+ * \brief Set the high and low alert water marks of the given taskprocessor queue.
+ * \since 13.10.0
+ *
+ * \param tps Taskprocessor to update queue water marks.
+ * \param low_water New queue low water mark. (-1 to set as 90% of high_water)
+ * \param high_water New queue high water mark.
+ *
+ * \retval 0 on success.
+ * \retval -1 on error (water marks not changed).
+ */
+int ast_taskprocessor_alert_set_levels(struct ast_taskprocessor *tps, long low_water, long high_water);
+
 #endif /* __AST_TASKPROCESSOR_H__ */
diff -urpN asterisk-13.9.1/include/asterisk/tcptls.h asterisk-13.17.0/include/asterisk/tcptls.h
--- asterisk-13.9.1/include/asterisk/tcptls.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/tcptls.h	2017-07-12 13:12:08.000000000 +0200
@@ -65,6 +65,7 @@
 #ifdef DO_SSL
 #include <openssl/ssl.h>
 #include <openssl/err.h>
+#include <openssl/x509v3.h>
 #else
 /* declare dummy types so we can define a pointer to them */
 typedef struct {} SSL;
@@ -106,6 +107,9 @@ struct ast_tls_config {
 	char *capath;
 	struct ast_flags flags;
 	SSL_CTX *ssl_ctx;
+	char certhash[41];
+	char pvthash[41];
+	char cahash[41];
 };
 
 /*! \page AstTlsOverview TLS Implementation Overview
@@ -150,6 +154,7 @@ struct ast_tcptls_session_args {
 	void (*periodic_fn)(void *);/*!< something we may want to run before after select on the accept socket */
 	void *(*worker_fn)(void *); /*!< the function in charge of doing the actual work */
 	const char *name;
+	struct ast_tls_config *old_tls_cfg; /*!< copy of the SSL configuration to determine whether changes have been made */
 };
 
 struct ast_tcptls_stream;
diff -urpN asterisk-13.9.1/include/asterisk/test.h asterisk-13.17.0/include/asterisk/test.h
--- asterisk-13.9.1/include/asterisk/test.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/test.h	2017-07-12 13:12:08.000000000 +0200
@@ -241,6 +241,14 @@ struct ast_test_info {
 	 * \note The description must not end with a newline.
 	 */
 	const char *description;
+	/*!
+	 * \brief Only run if explicitly named
+	 *
+	 * \details
+	 * Run this test only if it's explicitly named on the command line.
+	 * Do NOT run it as part of an execute category or execute all command.
+	 */
+	unsigned int explicit_only;
 };
 
 #ifdef TEST_FRAMEWORK
diff -urpN asterisk-13.9.1/include/asterisk/translate.h asterisk-13.17.0/include/asterisk/translate.h
--- asterisk-13.9.1/include/asterisk/translate.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/translate.h	2017-07-12 13:12:08.000000000 +0200
@@ -208,7 +208,7 @@ struct ast_translator {
  */
 struct ast_trans_pvt {
 	struct ast_translator *t;
-	struct ast_frame f;         /*!< used in frameout */
+	struct ast_frame f;         /*!< used in frameout.  This frame holds a f.subclass.format ref. */
 	int samples;                /*!< samples available in outbuf */
 	/*! \brief actual space used in outbuf */
 	int datalen;
diff -urpN asterisk-13.9.1/include/asterisk/utils.h asterisk-13.17.0/include/asterisk/utils.h
--- asterisk-13.9.1/include/asterisk/utils.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/utils.h	2017-07-12 13:12:08.000000000 +0200
@@ -843,9 +843,16 @@ struct ast_http_digest {
  */
 int ast_parse_digest(const char *digest, struct ast_http_digest *d, int request, int pedantic);
 
+#ifdef DO_CRASH
+#define DO_CRASH_NORETURN attribute_noreturn
+#else
+#define DO_CRASH_NORETURN
+#endif
+
+void DO_CRASH_NORETURN __ast_assert_failed(int condition, const char *condition_str,
+	const char *file, int line, const char *function);
 
 #ifdef AST_DEVMODE
-void __ast_assert_failed(int condition, const char *condition_str, const char *file, int line, const char *function);
 #define ast_assert(a) _ast_assert(a, # a, __FILE__, __LINE__, __PRETTY_FUNCTION__)
 static void force_inline _ast_assert(int condition, const char *condition_str, const char *file, int line, const char *function)
 {
@@ -864,7 +871,7 @@ static void force_inline _ast_assert(int
  *
  * \return Nothing
  */
-void ast_do_crash(void);
+void DO_CRASH_NORETURN ast_do_crash(void);
 
 #include "asterisk/strings.h"
 
@@ -968,6 +975,14 @@ int ast_str_to_eid(struct ast_eid *eid,
 int ast_eid_cmp(const struct ast_eid *eid1, const struct ast_eid *eid2);
 
 /*!
+ * \brief Check if EID is empty
+ *
+ * \return 1 if the EID is empty, zero otherwise
+ * \since 13.12.0
+ */
+int ast_eid_is_empty(const struct ast_eid *eid);
+
+/*!
  * \brief Get current thread ID
  * \return the ID if platform is supported, else -1
  */
@@ -1112,4 +1127,13 @@ int ast_file_is_readable(const char *fil
  */
 int ast_compare_versions(const char *version1, const char *version2);
 
+/*
+ * \brief Test that an OS supports IPv6 Networking.
+ * \since 13.14.0
+ *
+ * \return True (non-zero) if the IPv6 supported.
+ * \return False (zero) if the OS doesn't support IPv6.
+ */
+int ast_check_ipv6(void);
+
 #endif /* _ASTERISK_UTILS_H */
diff -urpN asterisk-13.9.1/include/asterisk/vector.h asterisk-13.17.0/include/asterisk/vector.h
--- asterisk-13.9.1/include/asterisk/vector.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk/vector.h	2017-07-12 13:12:08.000000000 +0200
@@ -48,6 +48,9 @@
 		size_t current;			\
 	}
 
+/*! \brief Integer vector definition */
+AST_VECTOR(ast_vector_int, int);
+
 /*!
  * \brief Define a vector structure with a read/write lock
  *
@@ -172,9 +175,11 @@
 			typeof((vec)->elems) new_elems = ast_calloc(1,		\
 				new_max * sizeof(*new_elems));					\
 			if (new_elems) {									\
-				memcpy(new_elems, (vec)->elems,					\
-					(vec)->current * sizeof(*new_elems)); 		\
-				ast_free((vec)->elems);							\
+				if ((vec)->elems) {								\
+					memcpy(new_elems, (vec)->elems,				\
+						(vec)->current * sizeof(*new_elems)); 	\
+					ast_free((vec)->elems);						\
+				}												\
 				(vec)->elems = new_elems;						\
 				(vec)->max = new_max;							\
 			} else {											\
@@ -239,6 +244,29 @@
 })
 
 /*!
+ * \brief Default a vector up to size with the given value.
+ *
+ * \note If a size of 0 is given then all elements in the given vector are set.
+ * \note The vector will grow to the given size if needed.
+ *
+ * \param vec Vector to default.
+ * \param size The number of elements to default
+ * \param value The default value to set each element to
+ */
+#define AST_VECTOR_DEFAULT(vec, size, value) ({ \
+	int res = 0;							\
+	typeof((size)) __size = (size) ? (size) : AST_VECTOR_SIZE(vec);	\
+	size_t idx;							\
+	for (idx = 0; idx < __size; ++idx) {				\
+		res = AST_VECTOR_REPLACE(vec, idx, value);		\
+		if (res == -1) {					\
+			break;						\
+		}							\
+	}								\
+	res;								\
+})
+
+/*!
  * \brief Insert an element at a specific position in a vector, growing the vector if needed.
  *
  * \param vec Vector to insert into.
@@ -354,6 +382,32 @@
 	AST_VECTOR_REMOVE(vec, idx, 1)
 
 /*!
+ * \brief Remove all elements from a vector that matches the given comparison
+ *
+ * \param vec Vector to remove from.
+ * \param value Value to pass into comparator.
+ * \param cmp Comparator function/macros (called as \c cmp(elem, value))
+ * \param cleanup How to cleanup a removed element macro/function.
+ *
+ * \return the number of deleted elements.
+ */
+#define AST_VECTOR_REMOVE_ALL_CMP_UNORDERED(vec, value, cmp, cleanup) ({	\
+	int count = 0;							\
+	size_t idx;							\
+	typeof(value) __value = (value);				\
+	for (idx = 0; idx < (vec)->current; ) {				\
+		if (cmp((vec)->elems[idx], __value)) {			\
+			cleanup((vec)->elems[idx]);			\
+			AST_VECTOR_REMOVE_UNORDERED((vec), idx);	\
+			++count;					\
+		} else {						\
+			++idx;						\
+		}							\
+	}								\
+	count;								\
+})
+
+/*!
  * \brief Remove an element from a vector that matches the given comparison
  *
  * \param vec Vector to remove from.
@@ -380,6 +434,32 @@
 })
 
 /*!
+ * \brief Remove all elements from a vector that matches the given comparison while maintaining order
+ *
+ * \param vec Vector to remove from.
+ * \param value Value to pass into comparator.
+ * \param cmp Comparator function/macros (called as \c cmp(elem, value))
+ * \param cleanup How to cleanup a removed element macro/function.
+ *
+ * \return the number of deleted elements.
+ */
+#define AST_VECTOR_REMOVE_ALL_CMP_ORDERED(vec, value, cmp, cleanup) ({	\
+	int count = 0;							\
+	size_t idx;							\
+	typeof(value) __value = (value);				\
+	for (idx = 0; idx < (vec)->current; ) {				\
+		if (cmp((vec)->elems[idx], __value)) {			\
+			cleanup((vec)->elems[idx]);			\
+			AST_VECTOR_REMOVE_ORDERED((vec), idx);		\
+			++count;					\
+		} else {						\
+			++idx;						\
+		}							\
+	}								\
+	count;								\
+})
+
+/*!
  * \brief Remove an element from a vector that matches the given comparison while maintaining order
  *
  * \param vec Vector to remove from.
@@ -397,7 +477,7 @@
 	for (idx = 0; idx < (vec)->current; ++idx) {			\
 		if (cmp((vec)->elems[idx], __value)) {			\
 			cleanup((vec)->elems[idx]);			\
-			AST_VECTOR_REMOVE_ORDERED((vec), idx);	\
+			AST_VECTOR_REMOVE_ORDERED((vec), idx);		\
 			res = 0;					\
 			break;						\
 		}							\
@@ -499,6 +579,42 @@
 })
 
 /*!
+ * \brief Get the nth index from a vector that matches the given comparison
+ *
+ * \param vec Vector to get from.
+ * \param nth The nth index to find
+ * \param value Value to pass into comparator.
+ * \param cmp Comparator function/macros (called as \c cmp(elem, value))
+ *
+ * \return a pointer to the element that was found or NULL
+ */
+#define AST_VECTOR_GET_INDEX_NTH(vec, nth, value, cmp) ({ \
+	int res = -1; \
+	size_t idx; \
+	typeof(nth) __nth = (nth); \
+	typeof(value) __value = (value); \
+	for (idx = 0; idx < (vec)->current; ++idx) { \
+		if (cmp((vec)->elems[idx], __value) && !(--__nth)) {	\
+			res = (int)idx;					\
+			break; \
+		} \
+	} \
+	res; \
+})
+
+/*!
+ * \brief Get the 1st index from a vector that matches the given comparison
+ *
+ * \param vec Vector to get from.
+ * \param value Value to pass into comparator.
+ * \param cmp Comparator function/macros (called as \c cmp(elem, value))
+ *
+ * \return a pointer to the element that was found or NULL
+ */
+#define AST_VECTOR_GET_INDEX(vec, value, cmp) \
+	AST_VECTOR_GET_INDEX_NTH(vec, 1, value, cmp)
+
+/*!
  * \brief Get an element from a vector that matches the given comparison
  *
  * \param vec Vector to get from.
diff -urpN asterisk-13.9.1/include/asterisk.h asterisk-13.17.0/include/asterisk.h
--- asterisk-13.9.1/include/asterisk.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/asterisk.h	2017-07-12 13:12:08.000000000 +0200
@@ -36,6 +36,15 @@
 #define AST_FILE_MODE 0666
 #endif
 
+/* Make sure PATH_MAX is defined on platforms (HURD) that don't define it.
+ * Also be sure to handle the case of a path larger than PATH_MAX
+ * (err safely) in the code.
+ */
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
+
+
 #define DEFAULT_LANGUAGE "en"
 
 #define DEFAULT_SAMPLE_RATE 8000
@@ -308,9 +317,17 @@ struct ast_module;
 struct ast_variable;
 struct ast_str;
 struct ast_sched_context;
+struct ast_json;
 
 /* Some handy macros for turning a preprocessor token into (effectively) a quoted string */
 #define __stringify_1(x)	#x
 #define __stringify(x)		__stringify_1(x)
 
+/*!
+ * \brief Retrieve the PBX UUID
+ * \param pbx_uuid A buffer of at least AST_UUID_STR_LEN (36 + 1) size to receive the UUID
+ * \param length The buffer length
+ */
+int ast_pbx_uuid_get(char *pbx_uuid, int length);
+
 #endif /* _ASTERISK_H */
diff -urpN asterisk-13.9.1/include/jitterbuf.h asterisk-13.17.0/include/jitterbuf.h
--- asterisk-13.9.1/include/jitterbuf.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/include/jitterbuf.h	2017-07-12 13:12:08.000000000 +0200
@@ -166,6 +166,9 @@ enum jb_return_code jb_setconf(jitterbuf
 typedef void __attribute__((format(printf, 1, 2))) (*jb_output_function_t)(const char *fmt, ...);
 void jb_setoutput(jb_output_function_t err, jb_output_function_t warn, jb_output_function_t dbg);
 
+/*! \brief Checks if the given time stamp is late */
+int jb_is_late(jitterbuf *jb, long ts);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN asterisk-13.9.1/main/Makefile asterisk-13.17.0/main/Makefile
--- asterisk-13.9.1/main/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
--include $(ASTTOPDIR)/menuselect.makeopts $(ASTTOPDIR)/menuselect.makedeps $(ASTTOPDIR)/makeopts.embed_rules $(ASTTOPDIR)/makeopts
+-include $(ASTTOPDIR)/menuselect.makeopts $(ASTTOPDIR)/menuselect.makedeps $(ASTTOPDIR)/makeopts
 
 all: asterisk
 
@@ -44,11 +44,11 @@ AST_LIBS+=$(URIPARSER_LIB)
 AST_LIBS+=$(UUID_LIB)
 AST_LIBS+=$(CRYPT_LIB)
 AST_LIBS+=$(AST_CLANG_BLOCKS_LIBS)
+AST_LIBS+=$(RT_LIB)
+AST_LIBS+=$(SYSTEMD_LIB)
 
 ifneq ($(findstring $(OSARCH), linux-gnu uclinux linux-uclibc kfreebsd-gnu),)
-  ifneq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
   AST_LIBS+=-ldl
-  endif
   ifneq (x$(CAP_LIB),x)
     AST_LIBS+=$(CAP_LIB)
   endif
@@ -67,11 +67,7 @@ ifneq ($(findstring darwin,$(OSARCH)),)
   ASTLINK+=/usr/lib/bundle1.o
 else
 # These are used for all but Darwin
-  ifneq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
-    ASTLINK+=-Wl,--export-dynamic
-  else
-    ASTLINK+=${GC_LDFLAGS}
-  endif
+  ASTLINK+=-Wl,--export-dynamic
   ifneq ($(findstring BSD,$(OSARCH)),)
     LDFLAGS+=-L/usr/local/lib
   endif
@@ -170,9 +166,6 @@ endif
 
 stdtime/localtime.o: _ASTCFLAGS+=$(AST_NO_STRICT_OVERFLOW) -Wno-format-nonliteral
 
-AST_EMBED_LDSCRIPTS:=$(sort $(EMBED_LDSCRIPTS))
-AST_EMBED_LDFLAGS:=$(foreach dep,$(EMBED_LDFLAGS),$(value $(dep)))
-AST_EMBED_LIBS:=$(foreach dep,$(EMBED_LIBS),$(value $(dep)))
 OBJS:=$(sort $(OBJS))
 
 ifneq ($(findstring $(OSARCH), mingw32 cygwin ),)
@@ -203,7 +196,7 @@ ASTSSL_LDLIBS=-L. -lasteriskssl
 ifeq ($(findstring darwin,$(OSARCH)),) # not Darwin
 ASTSSL_LIB:=libasteriskssl.so
 
-$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTSSL_LIB)
+$(ASTSSL_LIB).$(ASTSSL_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTSSL_LIB).$(ASTSSL_SO_VERSION)
 $(ASTSSL_LIB).$(ASTSSL_SO_VERSION): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskssl\"
 $(ASTSSL_LIB).$(ASTSSL_SO_VERSION): LIBS+=$(ASTSSL_LIBS)
 ifeq ($(GNU_LD),1)
@@ -224,11 +217,7 @@ endif
 
 $(ASTSSL_LIB): $(ASTSSL_LIB).$(ASTSSL_SO_VERSION)
 	$(ECHO_PREFIX) echo "   [LN] $< -> $@"
-	$(CMD_PREFIX) if [ -x "$(LDCONFIG)" ] ; then \
-		$(LDCONFIG) $(LDCONFIG_FLAGS) . 2>/dev/null ;\
-	else \
-		$(LN) -sf $< $@ ;\
-	fi
+	$(LN) -sf $< $@ ;\
 
 else # Darwin
 ASTSSL_LIB:=libasteriskssl.dylib
@@ -255,6 +244,7 @@ ifeq ($(PJPROJECT_BUNDLED),yes)
 ASTPJ_SO_VERSION=2
 ASTPJ_LDLIBS=-L. -lasteriskpj
 
+PJDIR=$(ASTTOPDIR)/$(PJPROJECT_DIR)/source
 -include $(ASTTOPDIR)/$(PJPROJECT_DIR)/build.mak
 
 PJPROJECT_LDLIBS := \
@@ -280,15 +270,15 @@ ASTPJ_LIB:=libasteriskpj.so
 libasteriskpj.exports: $(ASTTOPDIR)/$(PJPROJECT_DIR)/pjproject.symbols
 	$(ECHO_PREFIX) echo "   [GENERATE] libasteriskpj.exports"
 ifeq ($(GNU_LD),1)
-	$(CMD_PREFIX) echo -e "{\n\tglobal:" > libasteriskpj.exports
-	$(CMD_PREFIX) sed -r -e "s/.*/\t\t$(LINKER_SYMBOL_PREFIX)&;/" $(ASTTOPDIR)/$(PJPROJECT_DIR)/pjproject.symbols >> libasteriskpj.exports
-	$(CMD_PREFIX) echo -e "\t\t$(LINKER_SYMBOL_PREFIX)ast_pj_init;\n" >> libasteriskpj.exports
-	$(CMD_PREFIX) echo -e "\tlocal:\n\t\t*;\n};" >> libasteriskpj.exports
+	$(CMD_PREFIX) echo -e "{\nglobal:" > libasteriskpj.exports
+	$(CMD_PREFIX) sed -r -e "s/.*/$(LINKER_SYMBOL_PREFIX)&;/" $(ASTTOPDIR)/$(PJPROJECT_DIR)/pjproject.symbols >> libasteriskpj.exports
+	$(CMD_PREFIX) echo -e "$(LINKER_SYMBOL_PREFIX)ast_pj_init;\n" >> libasteriskpj.exports
+	$(CMD_PREFIX) echo -e "local:\n*;\n};" >> libasteriskpj.exports
 endif
 
-$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTPJ_LIB) $(PJ_LDFLAGS)
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTLDFLAGS+=-Wl,-soname=$(ASTPJ_LIB).$(ASTPJ_SO_VERSION) $(PJ_LDFLAGS)
 $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskpj\" $(PJ_CFLAGS)
-$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): LIBS+=$(PJPROJECT_LDLIBS) -lssl -lcrypto -luuid -lm -lrt -lpthread
+$(ASTPJ_LIB).$(ASTPJ_SO_VERSION): LIBS+=$(PJPROJECT_LDLIBS) -lssl -lcrypto -luuid -lm -lpthread $(RT_LIB)
 ifeq ($(GNU_LD),1)
     $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): SO_SUPPRESS_SYMBOLS=-Wl,--version-script,libasteriskpj.exports,--warn-common
 endif
@@ -304,11 +294,7 @@ $(ASTPJ_LIB).$(ASTPJ_SO_VERSION): libast
 
 $(ASTPJ_LIB): $(ASTPJ_LIB).$(ASTPJ_SO_VERSION)
 	$(ECHO_PREFIX) echo "   [LN] $< -> $@"
-	$(CMD_PREFIX) if [ -x "$(LDCONFIG)" ] ; then \
-		$(LDCONFIG) $(LDCONFIG_FLAGS) . 2>/dev/null ;\
-	else \
-		$(LN) -sf $< $@ ;\
-	fi
+	$(LN) -sf $< $@ ;\
 
 else # Darwin
 ASTPJ_LIB:=libasteriskpj.dylib
@@ -317,7 +303,7 @@ ASTPJ_LIB:=libasteriskpj.dylib
 # /lib or /usr/lib
 $(ASTPJ_LIB): _ASTLDFLAGS+=-dynamiclib -install_name $(ASTLIBDIR)/$(ASTPJ_LIB) $(PJ_LDFLAGS)
 $(ASTPJ_LIB): _ASTCFLAGS+=-fPIC -DAST_MODULE=\"asteriskpj\" $(PJ_CFLAGS)
-$(ASTPJ_LIB): LIBS+=$(PJPROJECT_LIBS)  -lssl -lcrypto -luuid -lm -lrt -lpthread
+$(ASTPJ_LIB): LIBS+=$(PJPROJECT_LIBS)  -lssl -lcrypto -luuid -lm -lpthread $(RT_LIB)
 $(ASTPJ_LIB): SOLINK=$(DYLINK)
 
 # Special rules for building a shared library (not a dynamically loadable module)
@@ -330,10 +316,10 @@ endif
 
 tcptls.o: _ASTCFLAGS+=$(OPENSSL_INCLUDE)
 
-$(MAIN_TGT): $(OBJS) $(ASTSSL_LIB) $(ASTPJ_LIB) $(LIBEDIT_OBJ) $(AST_EMBED_LDSCRIPTS)
+$(MAIN_TGT): $(OBJS) $(ASTSSL_LIB) $(ASTPJ_LIB) $(LIBEDIT_OBJ)
 	@$(CC) -c -o buildinfo.o $(_ASTCFLAGS) buildinfo.c $(ASTCFLAGS)
-	$(ECHO_PREFIX) echo "   [LD] $(OBJS) $(LIBEDIT_OBJ) $(AST_EMBED_LDSCRIPTS) -> $@"
-	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(AST_EMBED_LDFLAGS) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) $(ASTSSL_LDLIBS) $(ASTPJ_LDLIBS) $(LIBEDIT_OBJ) $(AST_EMBED_LDSCRIPTS) buildinfo.o $(AST_LIBS) $(AST_EMBED_LIBS) $(GMIMELDFLAGS) $(LIBEDIT_LIB)
+	$(ECHO_PREFIX) echo "   [LD] $(OBJS) $(LIBEDIT_OBJ) -> $@"
+	$(CMD_PREFIX) $(CXX) $(STATIC_BUILD) -o $@ $(ASTLINK) $(_ASTLDFLAGS) $(ASTLDFLAGS) $(OBJS) $(ASTSSL_LDLIBS) $(ASTPJ_LDLIBS) $(LIBEDIT_OBJ) buildinfo.o $(AST_LIBS) $(GMIMELDFLAGS) $(LIBEDIT_LIB)
 
 ifeq ($(GNU_LD),1)
 $(MAIN_TGT): asterisk.exports
@@ -359,23 +345,13 @@ else # Darwin
 	$(INSTALL) -m 755 $(ASTPJ_LIB) "$(DESTDIR)$(ASTLIBDIR)/"
 endif
 endif
-ifneq ($(LDCONFIG),)
-	$(LDCONFIG) $(LDCONFIG_FLAGS) "$(DESTDIR)$(ASTLIBDIR)/"
-endif
 	$(LN) -sf asterisk "$(DESTDIR)$(ASTSBINDIR)/rasterisk"
 
 binuninstall:
 	rm -f "$(DESTDIR)$(ASTSBINDIR)/$(MAIN_TGT)"
 	rm -f "$(DESTDIR)$(ASTSBINDIR)/rasterisk"
-ifneq ($(ASTSSL_LIB).$(ASTSSL_SO_VERSION),.)
-	rm -f "$(DESTDIR)$(ASTLIBDIR)/$(ASTSSL_LIB).$(ASTSSL_SO_VERSION)"
-endif
-ifneq ($(ASTPJ_LIB).$(ASTPJ_SO_VERSION),.)
-	rm -f "$(DESTDIR)$(ASTLIBDIR)/$(ASTPJ_LIB).$(ASTPJ_SO_VERSION)"
-endif
-ifneq ($(LDCONFIG),)
-	$(LDCONFIG) $(LDCONFIG_FLAGS) "$(DESTDIR)$(ASTLIBDIR)/"
-endif
+	rm -f "$(DESTDIR)$(ASTLIBDIR)/libasterisk"* || :
+	test -n "$(_oldlibdir)" -a -d "$(_oldlibdir)" && rm -f "$(_oldlibdir)/libasterisk"* || :
 
 clean::
 	rm -f asterisk libasteriskssl.o
diff -urpN asterisk-13.9.1/main/abstract_jb.c asterisk-13.17.0/main/abstract_jb.c
--- asterisk-13.9.1/main/abstract_jb.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/abstract_jb.c	2017-07-12 13:12:08.000000000 +0200
@@ -67,6 +67,7 @@ static long jb_next_fixed(void *jb);
 static int jb_remove_fixed(void *jb, struct ast_frame **fout);
 static void jb_force_resynch_fixed(void *jb);
 static void jb_empty_and_reset_fixed(void *jb);
+static int jb_is_late_fixed(void *jb, long ts);
 /* adaptive */
 static void * jb_create_adaptive(struct ast_jb_conf *general_config);
 static void jb_destroy_adaptive(void *jb);
@@ -77,6 +78,7 @@ static long jb_next_adaptive(void *jb);
 static int jb_remove_adaptive(void *jb, struct ast_frame **fout);
 static void jb_force_resynch_adaptive(void *jb);
 static void jb_empty_and_reset_adaptive(void *jb);
+static int jb_is_late_adaptive(void *jb, long ts);
 
 /* Available jb implementations */
 static const struct ast_jb_impl avail_impl[] = {
@@ -92,6 +94,7 @@ static const struct ast_jb_impl avail_im
 		.remove = jb_remove_fixed,
 		.force_resync = jb_force_resynch_fixed,
 		.empty_and_reset = jb_empty_and_reset_fixed,
+		.is_late = jb_is_late_fixed,
 	},
 	{
 		.name = "adaptive",
@@ -105,6 +108,7 @@ static const struct ast_jb_impl avail_im
 		.remove = jb_remove_adaptive,
 		.force_resync = jb_force_resynch_adaptive,
 		.empty_and_reset = jb_empty_and_reset_adaptive,
+		.is_late = jb_is_late_adaptive,
 	}
 };
 
@@ -706,6 +710,11 @@ static void jb_empty_and_reset_fixed(voi
 	}
 }
 
+static int jb_is_late_fixed(void *jb, long ts)
+{
+	return fixed_jb_is_late(jb, ts);
+}
+
 /* adaptive */
 
 static void *jb_create_adaptive(struct ast_jb_conf *general_config)
@@ -812,6 +821,11 @@ const struct ast_jb_impl *ast_jb_get_imp
 	return NULL;
 }
 
+static int jb_is_late_adaptive(void *jb, long ts)
+{
+	return jb_is_late(jb, ts);
+}
+
 #define DEFAULT_TIMER_INTERVAL 20
 #define DEFAULT_SIZE  200
 #define DEFAULT_TARGET_EXTRA  40
@@ -895,7 +909,22 @@ static struct ast_frame *hook_event_cb(s
 		}
 	}
 
-	if (!frame) {
+	/*
+	 * If the frame has been requeued (for instance when the translate core returns
+	 * more than one frame) then if the frame is late we want to immediately return
+	 * it. Otherwise attempt to insert it into the jitterbuffer.
+	 *
+	 * If the frame is requeued and late then in all likely hood it's a frame that
+	 * that was previously retrieved from the jitterbuffer, passed to the translate
+	 * core, and then put back into the channel read queue. Even if it had not been
+	 * in the jitterbuffer prior to now it needs to be the next frame "out".
+	 *
+	 * However late arriving frames that have not been requeued (i.e. regular frames)
+	 * need to be passed to the jitterbuffer so they can be appropriately dropped. As
+	 * well any requeued frames that are not late should be put into the jitterbuffer.
+	 */
+	if (!frame || (ast_test_flag(frame, AST_FRFLAG_REQUEUED) &&
+		       framedata->jb_impl->is_late(framedata->jb_obj, frame->ts))) {
 		return frame;
 	}
 
diff -urpN asterisk-13.9.1/main/acl.c asterisk-13.17.0/main/acl.c
--- asterisk-13.9.1/main/acl.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/acl.c	2017-07-12 13:12:08.000000000 +0200
@@ -914,40 +914,48 @@ int ast_get_ip(struct ast_sockaddr *addr
 
 int ast_ouraddrfor(const struct ast_sockaddr *them, struct ast_sockaddr *us)
 {
+	/*
+	 * We must create the errno string before creating the address
+	 * string because it could wipe out errno on the error return
+	 * paths.
+	 */
+	const char *sock_err;
 	int port;
 	int s;
 
+	/* Preserve our original address port */
 	port = ast_sockaddr_port(us);
 
-	if ((s = socket(ast_sockaddr_is_ipv6(them) ? AF_INET6 : AF_INET,
-			SOCK_DGRAM, 0)) < 0) {
-		ast_log(LOG_ERROR, "Cannot create socket\n");
+	s = socket(ast_sockaddr_is_ipv6(them) ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
+	if (s < 0) {
+		sock_err = ast_strdupa(strerror(errno));
+		ast_log(LOG_ERROR, "Cannot create socket to %s: %s\n",
+			ast_sockaddr_stringify_addr(them), sock_err);
 		return -1;
 	}
 
 	if (ast_connect(s, them)) {
-		ast_log(LOG_WARNING, "Cannot connect\n");
+		sock_err = ast_strdupa(strerror(errno));
+		ast_log(LOG_WARNING, "Cannot connect to %s: %s\n",
+			ast_sockaddr_stringify_addr(them), sock_err);
 		close(s);
 		return -1;
 	}
 	if (ast_getsockname(s, us)) {
-
-		ast_log(LOG_WARNING, "Cannot get socket name\n");
+		sock_err = ast_strdupa(strerror(errno));
+		ast_log(LOG_WARNING, "Cannot get socket name for connection to %s: %s\n",
+			ast_sockaddr_stringify_addr(them), sock_err);
 		close(s);
 		return -1;
 	}
 	close(s);
 
-	{
-		const char *them_addr = ast_strdupa(ast_sockaddr_stringify_addr(them));
-		const char *us_addr = ast_strdupa(ast_sockaddr_stringify_addr(us));
-
-		ast_debug(3, "For destination '%s', our source address is '%s'.\n",
-				them_addr, us_addr);
-	}
-
 	ast_sockaddr_set_port(us, port);
 
+	ast_debug(3, "For destination '%s', our source address is '%s'.\n",
+		ast_strdupa(ast_sockaddr_stringify_addr(them)),
+		ast_strdupa(ast_sockaddr_stringify_addr(us)));
+
 	return 0;
 }
 
diff -urpN asterisk-13.9.1/main/alertpipe.c asterisk-13.17.0/main/alertpipe.c
--- asterisk-13.9.1/main/alertpipe.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/main/alertpipe.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,166 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2017, Sean Bright
+ *
+ * Sean Bright <sean.bright@gmail.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Alert Pipe API
+ *
+ * \author Sean Bright
+ */
+
+#include "asterisk.h"
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#ifdef HAVE_EVENTFD
+# include <sys/eventfd.h>
+#endif
+
+#include "asterisk/alertpipe.h"
+#include "asterisk/logger.h"
+
+int ast_alertpipe_init(int alert_pipe[2])
+{
+#ifdef HAVE_EVENTFD
+
+	int fd = eventfd(0, EFD_NONBLOCK | EFD_SEMAPHORE);
+	if (fd > -1) {
+		alert_pipe[0] = alert_pipe[1] = fd;
+		return 0;
+	}
+
+	ast_log(LOG_WARNING, "Failed to create alert pipe with eventfd(), falling back to pipe(): %s\n",
+		strerror(errno));
+	ast_alertpipe_clear(alert_pipe);
+
+#endif
+
+	if (pipe(alert_pipe)) {
+		ast_log(LOG_WARNING, "Failed to create alert pipe: %s\n", strerror(errno));
+		return -1;
+	} else {
+		int flags = fcntl(alert_pipe[0], F_GETFL);
+		if (fcntl(alert_pipe[0], F_SETFL, flags | O_NONBLOCK) < 0) {
+			ast_log(LOG_WARNING, "Failed to set non-blocking mode on alert pipe: %s\n",
+				strerror(errno));
+			ast_alertpipe_close(alert_pipe);
+			return -1;
+		}
+		flags = fcntl(alert_pipe[1], F_GETFL);
+		if (fcntl(alert_pipe[1], F_SETFL, flags | O_NONBLOCK) < 0) {
+			ast_log(LOG_WARNING, "Failed to set non-blocking mode on alert pipe: %s\n",
+				strerror(errno));
+			ast_alertpipe_close(alert_pipe);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+void ast_alertpipe_close(int alert_pipe[2])
+{
+#ifdef HAVE_EVENTFD
+
+	if (alert_pipe[0] == alert_pipe[1]) {
+		if (alert_pipe[0] > -1) {
+			close(alert_pipe[0]);
+			ast_alertpipe_clear(alert_pipe);
+		}
+		return;
+	}
+
+#endif
+
+	if (alert_pipe[0] > -1) {
+		close(alert_pipe[0]);
+	}
+	if (alert_pipe[1] > -1) {
+		close(alert_pipe[1]);
+	}
+	ast_alertpipe_clear(alert_pipe);
+}
+
+ast_alert_status_t ast_alertpipe_read(int alert_pipe[2])
+{
+	uint64_t tmp;
+
+	if (!ast_alertpipe_readable(alert_pipe)) {
+		return AST_ALERT_NOT_READABLE;
+	}
+
+	if (read(alert_pipe[0], &tmp, sizeof(tmp)) < 0) {
+		if (errno != EINTR && errno != EAGAIN) {
+			ast_log(LOG_WARNING, "read() failed: %s\n", strerror(errno));
+			return AST_ALERT_READ_FAIL;
+		}
+	}
+
+	return AST_ALERT_READ_SUCCESS;
+}
+
+ssize_t ast_alertpipe_write(int alert_pipe[2])
+{
+	uint64_t tmp = 1;
+
+	if (!ast_alertpipe_writable(alert_pipe)) {
+		errno = EBADF;
+		return 0;
+	}
+
+	/* preset errno in case returned size does not match */
+	errno = EPIPE;
+	return write(alert_pipe[1], &tmp, sizeof(tmp)) != sizeof(tmp);
+}
+
+ast_alert_status_t ast_alertpipe_flush(int alert_pipe[2])
+{
+	int bytes_read;
+	uint64_t tmp[16];
+
+	if (!ast_alertpipe_readable(alert_pipe)) {
+		return AST_ALERT_NOT_READABLE;
+	}
+
+	/* Read the alertpipe until it is exhausted. */
+	for (;;) {
+		bytes_read = read(alert_pipe[0], tmp, sizeof(tmp));
+		if (bytes_read < 0) {
+			if (errno == EINTR) {
+				continue;
+			}
+			if (errno == EAGAIN || errno == EWOULDBLOCK) {
+				/*
+				 * Would block so nothing left to read.
+				 * This is the normal loop exit.
+				 */
+				break;
+			}
+			ast_log(LOG_WARNING, "read() failed flushing alertpipe: %s\n",
+				strerror(errno));
+			return AST_ALERT_READ_FAIL;
+		}
+		if (!bytes_read) {
+			/* Read nothing so we are done */
+			break;
+		}
+	}
+
+	return AST_ALERT_READ_SUCCESS;
+}
diff -urpN asterisk-13.9.1/main/aoc.c asterisk-13.17.0/main/aoc.c
--- asterisk-13.9.1/main/aoc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/aoc.c	2017-07-12 13:12:08.000000000 +0200
@@ -85,6 +85,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</parameter>
 				<parameter name="SpecialCode" />
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">AOC-D</ref>
+				<ref type="managerEvent">AOC-E</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AOC-D">
@@ -138,6 +142,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<parameter name="NumberOf" />
 				<parameter name="TypeOf" />
 			</syntax>
+			<see-also>
+				<ref type="manager">AOCMessage</ref>
+				<ref type="managerEvent">AOC-S</ref>
+				<ref type="managerEvent">AOC-E</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AOC-E">
@@ -151,6 +160,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<parameter name="ID" />
 				<xi:include xpointer="xpointer(/docs/managerEvent[@name='AOC-D']/managerEventInstance/syntax/parameter)" />
 			</syntax>
+			<see-also>
+				<ref type="manager">AOCMessage</ref>
+				<ref type="managerEvent">AOC-S</ref>
+				<ref type="managerEvent">AOC-D</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 ***/
@@ -1642,8 +1656,10 @@ static struct ast_json *units_to_json(co
 static struct ast_json *currency_to_json(const char *name, int cost,
 					 enum ast_aoc_currency_multiplier mult)
 {
-	return ast_json_pack("{s:s, s:i, s:s}",	"Name", name,
-			     "Cost", cost, "Multiplier", aoc_multiplier_str(mult));
+	return ast_json_pack("{s:s, s:i, s:s}",
+		"Name", AST_JSON_UTF8_VALIDATE(name),
+		"Cost", cost,
+		"Multiplier", aoc_multiplier_str(mult));
 }
 
 static struct ast_json *charge_to_json(const struct ast_aoc_decoded *decoded)
@@ -1653,8 +1669,8 @@ static struct ast_json *charge_to_json(c
 
 	if (decoded->charge_type != AST_AOC_CHARGE_CURRENCY &&
 	    decoded->charge_type != AST_AOC_CHARGE_UNIT) {
-		return ast_json_pack("{s:s}", "Type",
-				     aoc_charge_type_str(decoded->charge_type));
+		return ast_json_pack("{s:s}",
+			"Type", aoc_charge_type_str(decoded->charge_type));
 	}
 
 	if (decoded->charge_type == AST_AOC_CHARGE_CURRENCY) {
@@ -1666,8 +1682,7 @@ static struct ast_json *charge_to_json(c
 		obj = units_to_json(decoded);
 	}
 
-	return ast_json_pack(
-		"{s:s, s:s, s:s, s:o}",
+	return ast_json_pack("{s:s, s:s, s:s, s:o}",
 		"Type", aoc_charge_type_str(decoded->charge_type),
 		"BillingID", aoc_billingid_str(decoded->billing_id),
 		"TotalType", aoc_type_of_totaling_str(decoded->total_type),
@@ -1678,13 +1693,11 @@ static struct ast_json *association_to_j
 {
 	switch (decoded->charging_association.charging_type) {
 	case AST_AOC_CHARGING_ASSOCIATION_NUMBER:
-		return ast_json_pack(
-			"{s:s, s:i}",
-			"Number", decoded->charging_association.charge.number.number,
+		return ast_json_pack("{s:s, s:i}",
+			"Number", AST_JSON_UTF8_VALIDATE(decoded->charging_association.charge.number.number),
 			"Plan", decoded->charging_association.charge.number.plan);
 	case AST_AOC_CHARGING_ASSOCIATION_ID:
-		return ast_json_pack(
-			"{s:i}", "ID", decoded->charging_association.charge.id);
+		return ast_json_pack("{s:i}", "ID", decoded->charging_association.charge.id);
 	case AST_AOC_CHARGING_ASSOCIATION_NA:
 	default:
 		return ast_json_null();
@@ -1726,22 +1739,22 @@ static struct ast_json *s_to_json(const
 				decoded->aoc_s_entries[i].rate.duration.amount,
 				decoded->aoc_s_entries[i].rate.duration.multiplier);
 
-			time = ast_json_pack(
-				"{s:i, s:s}",
+			time = ast_json_pack("{s:i, s:i}",
 				"Length", decoded->aoc_s_entries[i].rate.duration.time,
 				"Scale", decoded->aoc_s_entries[i].rate.duration.time_scale);
 
 			if (decoded->aoc_s_entries[i].rate.duration.granularity_time) {
-				granularity = ast_json_pack(
-					"{s:i, s:s}",
+				granularity = ast_json_pack("{s:i, s:i}",
 					"Length", decoded->aoc_s_entries[i].rate.duration.granularity_time,
 					"Scale", decoded->aoc_s_entries[i].rate.duration.granularity_time_scale);
 			}
 
-			type = ast_json_pack("{s:o, s:s, s:o, s:o}", "Currency", ast_json_ref(currency), "ChargingType",
-					     decoded->aoc_s_entries[i].rate.duration.charging_type ?
-					     "StepFunction" : "ContinuousCharging", "Time", ast_json_ref(time),
-					     "Granularity", granularity ? ast_json_ref(granularity) : ast_json_ref(ast_json_null()));
+			type = ast_json_pack("{s:o, s:s, s:o, s:o}",
+				"Currency", ast_json_ref(currency),
+				"ChargingType", decoded->aoc_s_entries[i].rate.duration.charging_type
+					? "StepFunction" : "ContinuousCharging",
+				"Time", ast_json_ref(time),
+				"Granularity", granularity ? ast_json_ref(granularity) : ast_json_null());
 
 			break;
 		}
@@ -1759,21 +1772,22 @@ static struct ast_json *s_to_json(const
 				decoded->aoc_s_entries[i].rate.volume.amount,
 				decoded->aoc_s_entries[i].rate.volume.multiplier);
 
-			type = ast_json_pack(
-				"{s:s, s:o}", "Unit", aoc_volume_unit_str(
+			type = ast_json_pack("{s:s, s:o}",
+				"Unit", aoc_volume_unit_str(
 					decoded->aoc_s_entries[i].rate.volume.volume_unit),
 				"Currency", ast_json_ref(currency));
 			break;
 		case AST_AOC_RATE_TYPE_SPECIAL_CODE:
-			type = ast_json_pack("{s:i}", "SpecialCode",
-					    decoded->aoc_s_entries[i].rate.special_code);
+			type = ast_json_pack("{s:i}",
+				"SpecialCode", decoded->aoc_s_entries[i].rate.special_code);
 			break;
 		default:
 			break;
 		}
 
-		rate = ast_json_pack("{s:s, s:o}", "Chargeable", charge_item,
-				     aoc_rate_type_str(decoded->aoc_s_entries[i].rate_type), ast_json_ref(type));
+		rate = ast_json_pack("{s:s, s:o}",
+			"Chargeable", charge_item,
+			aoc_rate_type_str(decoded->aoc_s_entries[i].rate_type), ast_json_ref(type));
 		if (ast_json_array_append(rates, rate)) {
 			break;
 		}
diff -urpN asterisk-13.9.1/main/app.c asterisk-13.17.0/main/app.c
--- asterisk-13.9.1/main/app.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/app.c	2017-07-12 13:12:08.000000000 +0200
@@ -1073,6 +1073,7 @@ static int control_streamfile(struct ast
 	int res;
 	long pause_restart_point = 0;
 	long offset = 0;
+	struct ast_silence_generator *silgen = NULL;
 
 	if (!file) {
 		return -1;
@@ -1161,6 +1162,10 @@ static int control_streamfile(struct ast
 
 		if ((suspend && strchr(suspend, res)) || res == AST_CONTROL_STREAM_SUSPEND) {
 			pause_restart_point = ast_tellstream(ast_channel_stream(chan));
+
+			if (ast_opt_transmit_silence) {
+				silgen = ast_channel_start_silence_generator(chan);
+			}
 			ast_test_suite_event_notify("PLAYBACK","Channel: %s\r\n"
 				"Control: %s\r\n",
 				ast_channel_name(chan),
@@ -1174,6 +1179,11 @@ static int control_streamfile(struct ast
 					break;
 				}
 			}
+			if (silgen) {
+				ast_channel_stop_silence_generator(chan, silgen);
+				silgen = NULL;
+			}
+
 			if ((suspend && (res == *suspend)) || res == AST_CONTROL_STREAM_SUSPEND) {
 				res = 0;
 				ast_test_suite_event_notify("PLAYBACK","Channel: %s\r\n"
@@ -1412,22 +1422,20 @@ static struct ast_frame *make_silence(co
 	size_t size;
 	size_t datalen;
 	size_t samples = 0;
-	struct ast_frame *next;
 
 	if (!orig) {
 		return NULL;
 	}
+	do {
+		if (ast_format_cmp(orig->subclass.format, ast_format_slin) == AST_FORMAT_CMP_NOT_EQUAL) {
+			ast_log(LOG_WARNING, "Attempting to silence non-slin frame\n");
+			return NULL;
+		}
 
-	if (ast_format_cmp(orig->subclass.format, ast_format_slin) == AST_FORMAT_CMP_NOT_EQUAL) {
-		ast_log(LOG_WARNING, "Attempting to silence non-slin frame\n");
-		return NULL;
-	}
-
-	for (next = AST_LIST_NEXT(orig, frame_list);
-		 orig;
-		 orig = next, next = orig ? AST_LIST_NEXT(orig, frame_list) : NULL) {
 		samples += orig->samples;
-	}
+
+		orig = AST_LIST_NEXT(orig, frame_list);
+	} while (orig);
 
 	ast_verb(4, "Silencing %zu samples\n", samples);
 
@@ -1445,7 +1453,7 @@ static struct ast_frame *make_silence(co
 	silence->samples = samples;
 	silence->datalen = datalen;
 
-	silence->subclass.format = ast_format_slin;
+	silence->subclass.format = ao2_bump(ast_format_slin);
 
 	return silence;
 }
@@ -1651,14 +1659,13 @@ static int __ast_play_and_record(struct
 					/* It's all good */
 					res = 0;
 				} else {
-					RAII_VAR(struct ast_frame *, silence, NULL, ast_frame_dtor);
+					struct ast_frame *silence = NULL;
 					struct ast_frame *orig = f;
 
 					if (muted) {
 						silence = make_silence(orig);
 						if (!silence) {
-							ast_log(LOG_WARNING,
-								"Error creating silence\n");
+							ast_log(LOG_WARNING, "Error creating silence\n");
 							break;
 						}
 						f = silence;
@@ -1669,6 +1676,7 @@ static int __ast_play_and_record(struct
 						}
 						res = ast_writestream(others[x], f);
 					}
+					ast_frame_dtor(silence);
 					f = orig;
 				}
 
diff -urpN asterisk-13.9.1/main/ast_expr2.c asterisk-13.17.0/main/ast_expr2.c
--- asterisk-13.9.1/main/ast_expr2.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/ast_expr2.c	2017-07-12 13:12:08.000000000 +0200
@@ -93,6 +93,7 @@
 
 #include "asterisk.h"
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <stdio.h>
 
@@ -3667,13 +3668,22 @@ op_tildetilde (struct val *a, struct val
 	/* strip double quotes from both -- */
 	strip_quotes(a);
 	strip_quotes(b);
-	
+
 	vs = malloc(strlen(a->u.s)+strlen(b->u.s)+1);
+	if (vs == NULL) {
+		ast_log(LOG_WARNING, "malloc() failed\n");
+		free_value(a);
+		free_value(b);
+		return NULL;
+	}
+
 	strcpy(vs,a->u.s);
 	strcat(vs,b->u.s);
 
 	v = make_str(vs);
 
+	free(vs);
+
 	/* free arguments */
 	free_value(a);
 	free_value(b);
diff -urpN asterisk-13.9.1/main/ast_expr2.y asterisk-13.17.0/main/ast_expr2.y
--- asterisk-13.9.1/main/ast_expr2.y	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/ast_expr2.y	2017-07-12 13:12:08.000000000 +0200
@@ -14,6 +14,7 @@
 
 #include "asterisk.h"
 
+#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <stdio.h>
 
@@ -1660,13 +1661,22 @@ op_tildetilde (struct val *a, struct val
 	/* strip double quotes from both -- */
 	strip_quotes(a);
 	strip_quotes(b);
-	
+
 	vs = malloc(strlen(a->u.s)+strlen(b->u.s)+1);
+	if (vs == NULL) {
+		ast_log(LOG_WARNING, "malloc() failed\n");
+		free_value(a);
+		free_value(b);
+		return NULL;
+	}
+
 	strcpy(vs,a->u.s);
 	strcat(vs,b->u.s);
 
 	v = make_str(vs);
 
+	free(vs);
+
 	/* free arguments */
 	free_value(a);
 	free_value(b);
diff -urpN asterisk-13.9.1/main/asterisk.c asterisk-13.17.0/main/asterisk.c
--- asterisk-13.9.1/main/asterisk.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/asterisk.c	2017-07-12 13:12:08.000000000 +0200
@@ -248,6 +248,8 @@ int daemon(int, int);  /* defined in lib
 #include "asterisk/endpoints.h"
 #include "asterisk/codec.h"
 #include "asterisk/format_cache.h"
+#include "asterisk/astdb.h"
+#include "asterisk/options.h"
 
 #include "../defaults.h"
 
@@ -323,6 +325,8 @@ int ast_verb_sys_level;
 
 int option_verbose;				/*!< Verbosity level */
 int option_debug;				/*!< Debug level */
+int ast_pjproject_max_log_level = -1;/* Default to -1 to know if we have read the level from pjproject yet. */
+int ast_option_pjproject_log_level;
 double ast_option_maxload;			/*!< Max load avg on system */
 int ast_option_maxcalls;			/*!< Max number of active calls */
 int ast_option_maxfiles;			/*!< Max number of open file handles (files, sockets) */
@@ -330,6 +334,7 @@ unsigned int option_dtmfminduration;		/*
 #if defined(HAVE_SYSINFO)
 long option_minmemfree;				/*!< Minimum amount of free system memory - stop accepting calls if free memory falls below this watermark */
 #endif
+unsigned int ast_option_rtpptdynamic;
 
 /*! @} */
 
@@ -606,6 +611,8 @@ static char *handle_show_settings(struct
 	char buf[BUFSIZ];
 	struct ast_tm tm;
 	char eid_str[128];
+	struct rlimit limits;
+	char pbx_uuid[AST_UUID_STR_LEN];
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -618,6 +625,7 @@ static char *handle_show_settings(struct
 	}
 
 	ast_eid_to_str(eid_str, sizeof(eid_str), &ast_eid_default);
+	ast_pbx_uuid_get(pbx_uuid, sizeof(pbx_uuid));
 
 	ast_cli(a->fd, "\nPBX Core settings\n");
 	ast_cli(a->fd, "-----------------\n");
@@ -627,10 +635,17 @@ static char *handle_show_settings(struct
 		ast_cli(a->fd, "  Maximum calls:               %d (Current %d)\n", ast_option_maxcalls, ast_active_channels());
 	else
 		ast_cli(a->fd, "  Maximum calls:               Not set\n");
-	if (ast_option_maxfiles)
-		ast_cli(a->fd, "  Maximum open file handles:   %d\n", ast_option_maxfiles);
-	else
-		ast_cli(a->fd, "  Maximum open file handles:   Not set\n");
+
+	if (getrlimit(RLIMIT_NOFILE, &limits)) {
+		ast_cli(a->fd, "  Maximum open file handles:   Error because of %s\n", strerror(errno));
+	} else if (limits.rlim_cur == RLIM_INFINITY) {
+		ast_cli(a->fd, "  Maximum open file handles:   Unlimited\n");
+	} else if (limits.rlim_cur < ast_option_maxfiles) {
+		ast_cli(a->fd, "  Maximum open file handles:   %d (is) %d (requested)\n", (int) limits.rlim_cur, ast_option_maxfiles);
+	} else {
+		ast_cli(a->fd, "  Maximum open file handles:   %d\n", (int) limits.rlim_cur);
+	}
+
 	ast_cli(a->fd, "  Root console verbosity:      %d\n", option_verbose);
 	ast_cli(a->fd, "  Current console verbosity:   %d\n", ast_verb_console_get());
 	ast_cli(a->fd, "  Debug level:                 %d\n", option_debug);
@@ -649,6 +664,7 @@ static char *handle_show_settings(struct
 	ast_cli(a->fd, "  System:                      %s/%s built by %s on %s %s\n", ast_build_os, ast_build_kernel, ast_build_user, ast_build_machine, ast_build_date);
 	ast_cli(a->fd, "  System name:                 %s\n", ast_config_AST_SYSTEM_NAME);
 	ast_cli(a->fd, "  Entity ID:                   %s\n", eid_str);
+	ast_cli(a->fd, "  PBX UUID:                    %s\n", pbx_uuid);
 	ast_cli(a->fd, "  Default language:            %s\n", ast_defaultlanguage);
 	ast_cli(a->fd, "  Language prefix:             %s\n", ast_language_is_prefix ? "Enabled" : "Disabled");
 	ast_cli(a->fd, "  User name and group:         %s/%s\n", ast_config_AST_RUN_USER, ast_config_AST_RUN_GROUP);
@@ -658,6 +674,19 @@ static char *handle_show_settings(struct
 	ast_cli(a->fd, "  Generic PLC:                 %s\n", ast_test_flag(&ast_options, AST_OPT_FLAG_GENERIC_PLC) ? "Enabled" : "Disabled");
 	ast_cli(a->fd, "  Min DTMF duration::          %u\n", option_dtmfminduration);
 
+	if (ast_option_rtpptdynamic == AST_RTP_PT_LAST_REASSIGN) {
+		ast_cli(a->fd, "  RTP dynamic payload types:   %u,%u-%u\n",
+		        ast_option_rtpptdynamic,
+		        AST_RTP_PT_FIRST_DYNAMIC, AST_RTP_MAX_PT - 1);
+	} else if (ast_option_rtpptdynamic < AST_RTP_PT_LAST_REASSIGN) {
+		ast_cli(a->fd, "  RTP dynamic payload types:   %u-%u,%u-%u\n",
+		        ast_option_rtpptdynamic, AST_RTP_PT_LAST_REASSIGN,
+		        AST_RTP_PT_FIRST_DYNAMIC, AST_RTP_MAX_PT - 1);
+	} else {
+		ast_cli(a->fd, "  RTP dynamic payload types:   %u-%u\n",
+		        AST_RTP_PT_FIRST_DYNAMIC, AST_RTP_MAX_PT - 1);
+	}
+
 	ast_cli(a->fd, "\n* Subsystems\n");
 	ast_cli(a->fd, "  -------------\n");
 	ast_cli(a->fd, "  Manager (AMI):               %s\n", check_manager_enabled() ? "Enabled" : "Disabled");
@@ -846,7 +875,7 @@ static char *handle_show_sysinfo(struct
 #if defined(HAVE_SYSINFO)
 	ast_cli(a->fd, "  Buffer RAM:                %" PRIu64 " KiB\n", ((uint64_t) sys_info.bufferram * sys_info.mem_unit) / 1024);
 #endif
-#if defined (HAVE_SYSCTL) || defined(HAVE_SWAPCTL)
+#if defined(HAVE_SWAPCTL) || defined(HAVE_SYSINFO)
 	ast_cli(a->fd, "  Total Swap Space:          %d KiB\n", totalswap);
 	ast_cli(a->fd, "  Free Swap Space:           %" PRIu64 " KiB\n\n", freeswap);
 #endif
@@ -1035,35 +1064,30 @@ static char *handle_clear_profile(struct
 static char *handle_show_version_files(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 #define FORMAT "%-25.25s %-40.40s\n"
+	static const char * const completions[] = { "like", NULL };
 	struct registered_file *iterator;
 	regex_t regexbuf;
 	int havepattern = 0;
 	int havename = 0;
 	int count_files = 0;
 	char *ret = NULL;
-	int matchlen, which = 0;
-	struct registered_file *find;
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "core show file version [like]";
+		e->command = "core show file version";
 		e->usage =
-			"Usage: core show file version [like <pattern>]\n"
+			"Usage: core show file version [<filename>|like <pattern>]\n"
 			"       Lists the files along with the Asterisk version.\n"
 			"       Optional regular expression pattern is used to filter the file list.\n";
 		return NULL;
 	case CLI_GENERATE:
-		matchlen = strlen(a->word);
-		if (a->pos != 3)
+		if (a->pos != 4) {
 			return NULL;
-		AST_RWLIST_RDLOCK(&registered_files);
-		AST_RWLIST_TRAVERSE(&registered_files, find, list) {
-			if (!strncasecmp(a->word, find->file, matchlen) && ++which > a->n) {
-				ret = ast_strdup(find->file);
-				break;
-			}
 		}
-		AST_RWLIST_UNLOCK(&registered_files);
+		ret = ast_cli_complete(a->word, completions, a->n);
+		if (!ret) {
+			ret = ast_complete_source_filename(a->word, a->n - 1);
+		}
 		return ret;
 	}
 
@@ -1078,6 +1102,9 @@ static char *handle_show_version_files(s
 			return CLI_SHOWUSAGE;
 		break;
 	case 5:
+		if (!strcasecmp(a->argv[4], "like")) {
+			return CLI_SHOWUSAGE;
+		}
 		havename = 1;
 		break;
 	case 4:
@@ -1115,6 +1142,11 @@ static char *handle_show_version_files(s
 
 #endif /* ! LOW_MEMORY */
 
+int ast_pbx_uuid_get(char *pbx_uuid, int length)
+{
+	return ast_db_get("pbx", "UUID", pbx_uuid, length);
+}
+
 static void publish_fully_booted(void)
 {
 	RAII_VAR(struct ast_json *, json_object, NULL, ast_json_unref);
@@ -1767,7 +1799,6 @@ static void _urg_handler(int num)
 
 static struct sigaction urg_handler = {
 	.sa_handler = _urg_handler,
-	.sa_flags = SA_RESTART,
 };
 
 static void _hup_handler(int num)
@@ -1846,6 +1877,66 @@ static void set_icon(char *text)
 		fprintf(stdout, "\033]1;%s\007", text);
 }
 
+/*! \brief Check whether we were set to high(er) priority. */
+static int has_priority(void)
+{
+	/* Neither of these calls should fail with these arguments. */
+#ifdef __linux__
+	/* For SCHED_OTHER, SCHED_BATCH and SCHED_IDLE, this will return
+	 * 0. For the realtime priorities SCHED_RR and SCHED_FIFO, it
+	 * will return something >= 1. */
+	return sched_getscheduler(0);
+#else
+	/* getpriority() can return a value in -20..19 (or even -INF..20)
+	 * where negative numbers are high priority. We don't bother
+	 * checking errno. If the query fails and it returns -1, we'll
+	 * assume that we're running at high prio; a safe assumption
+	 * that will enable the resource starvation monitor (canary)
+	 * just in case. */
+	return (getpriority(PRIO_PROCESS, 0) < 0);
+#endif
+}
+
+/*! \brief Set priority on all known threads. */
+static int set_priority_all(int pri)
+{
+#if !defined(__linux__)
+	/* The non-linux version updates the entire process prio. */
+	return ast_set_priority(pri);
+#elif defined(LOW_MEMORY)
+	ast_log(LOG_WARNING, "Unable to enumerate all threads to update priority\n");
+	return ast_set_priority(pri);
+#else
+	struct thread_list_t *cur;
+	struct sched_param sched;
+	char const *policy_str;
+	int policy;
+
+	memset(&sched, 0, sizeof(sched));
+	if (pri) {
+		policy = SCHED_RR;
+		policy_str = "realtime";
+		sched.sched_priority = 10;
+	} else {
+		policy = SCHED_OTHER;
+		policy_str = "regular";
+		sched.sched_priority = 0;
+	}
+	if (sched_setscheduler(getpid(), policy, &sched)) {
+		ast_log(LOG_WARNING, "Unable to set %s thread priority on main thread\n", policy_str);
+		return -1;
+	}
+	ast_verb(1, "Setting %s thread priority on all threads\n", policy_str);
+	AST_RWLIST_RDLOCK(&thread_list);
+	AST_RWLIST_TRAVERSE(&thread_list, cur, list) {
+		/* Don't care about the return value. It should work. */
+		sched_setscheduler(cur->lwp, policy, &sched);
+	}
+	AST_RWLIST_UNLOCK(&thread_list);
+	return 0;
+#endif
+}
+
 /*! \brief We set ourselves to a high priority, that we might pre-empt
  * everything else.  If your PBX has heavy activity on it, this is a
  * good thing.
@@ -2063,10 +2154,14 @@ static void really_quit(int num, shutdow
 	struct ast_json *json_object = NULL;
 	int run_cleanups = niceness >= SHUTDOWN_NICE;
 
-	if (run_cleanups) {
-		ast_module_shutdown();
+	if (run_cleanups && modules_shutdown()) {
+		ast_verb(0, "Some modules could not be unloaded, switching to fast shutdown\n");
+		run_cleanups = 0;
 	}
 
+	if (!restart) {
+		ast_sd_notify("STOPPING=1");
+	}
 	if (ast_opt_console || (ast_opt_remote && !ast_opt_exec)) {
 		ast_el_write_default_histfile();
 		if (consolethread == AST_PTHREADT_NULL || consolethread == pthread_self()) {
@@ -2738,7 +2833,11 @@ static void send_rasterisk_connect_comma
 	}
 }
 
+#ifdef HAVE_LIBEDIT_IS_UNICODE
+static int ast_el_read_char(EditLine *editline, wchar_t *cp)
+#else
 static int ast_el_read_char(EditLine *editline, char *cp)
+#endif
 {
 	int num_read = 0;
 	int lastpos = 0;
@@ -2768,10 +2867,16 @@ static int ast_el_read_char(EditLine *ed
 		}
 
 		if (!ast_opt_exec && fds[1].revents) {
-			num_read = read(STDIN_FILENO, cp, 1);
+			char c = '\0';
+			num_read = read(STDIN_FILENO, &c, 1);
 			if (num_read < 1) {
 				break;
 			} else {
+#ifdef 	HAVE_LIBEDIT_IS_UNICODE
+				*cp = btowc(c);
+#else
+				*cp = c;
+#endif
 				return (num_read);
 			}
 		}
@@ -2815,7 +2920,11 @@ static int ast_el_read_char(EditLine *ed
 			console_print(buf, 0);
 
 			if ((res < EL_BUF_SIZE - 1) && ((buf[res-1] == '\n') || (res >= 2 && buf[res-2] == '\n'))) {
+#ifdef 	HAVE_LIBEDIT_IS_UNICODE
+				*cp = btowc(CC_REFRESH);
+#else
 				*cp = CC_REFRESH;
+#endif
 				return(1);
 			} else {
 				lastpos = 1;
@@ -2823,7 +2932,12 @@ static int ast_el_read_char(EditLine *ed
 		}
 	}
 
+#ifdef 	HAVE_LIBEDIT_IS_UNICODE
+	*cp = btowc('\0');
+#else
 	*cp = '\0';
+#endif
+
 	return (0);
 }
 
@@ -3525,6 +3639,7 @@ static void ast_readconfig(void)
 
 	/* Set default value */
 	option_dtmfminduration = AST_MIN_DTMF_DURATION;
+	ast_option_rtpptdynamic = AST_RTP_PT_FIRST_DYNAMIC;
 
 	if (ast_opt_override_config) {
 		cfg = ast_config_load2(ast_config_AST_CONFIG_FILE, "" /* core, can't reload */, config_flags);
@@ -3674,6 +3789,12 @@ static void ast_readconfig(void)
 			if (sscanf(v->value, "%30u", &option_dtmfminduration) != 1) {
 				option_dtmfminduration = AST_MIN_DTMF_DURATION;
 			}
+		/* http://www.iana.org/assignments/rtp-parameters
+		 * RTP dynamic payload types start at 96 normally; extend down to 0 */
+		} else if (!strcasecmp(v->name, "rtp_pt_dynamic")) {
+			ast_parse_arg(v->value, PARSE_UINT32|PARSE_IN_RANGE|PARSE_DEFAULT,
+			              &ast_option_rtpptdynamic, AST_RTP_PT_FIRST_DYNAMIC,
+			              0, AST_RTP_PT_LAST_REASSIGN);
 		} else if (!strcasecmp(v->name, "maxcalls")) {
 			if ((sscanf(v->value, "%30d", &ast_option_maxcalls) != 1) || (ast_option_maxcalls < 0)) {
 				ast_option_maxcalls = 0;
@@ -3735,10 +3856,10 @@ static void ast_readconfig(void)
 		} else if (!strcasecmp(v->name, "entityid")) {
 			struct ast_eid tmp_eid;
 			if (!ast_str_to_eid(&tmp_eid, v->value)) {
-				ast_verbose("Successfully set global EID to '%s'\n", v->value);
 				ast_eid_default = tmp_eid;
-			} else
-				ast_verbose("Invalid Entity ID '%s' provided\n", v->value);
+			} else {
+				ast_log(LOG_WARNING, "Invalid Entity ID '%s' provided\n", v->value);
+			}
 		} else if (!strcasecmp(v->name, "lightbackground")) {
 			ast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_LIGHT_BACKGROUND);
 		} else if (!strcasecmp(v->name, "forceblackbackground")) {
@@ -3770,6 +3891,37 @@ static void ast_readconfig(void)
 	ast_config_destroy(cfg);
 }
 
+static void read_pjproject_startup_options(void)
+{
+	struct ast_config *cfg;
+	struct ast_variable *v;
+	struct ast_flags config_flags = { CONFIG_FLAG_NOCACHE | CONFIG_FLAG_NOREALTIME };
+
+	ast_option_pjproject_log_level = DEFAULT_PJ_LOG_MAX_LEVEL;
+
+	cfg = ast_config_load2("pjproject.conf", "" /* core, can't reload */, config_flags);
+	if (!cfg
+		|| cfg == CONFIG_STATUS_FILEUNCHANGED
+		|| cfg == CONFIG_STATUS_FILEINVALID) {
+		/* We'll have to use defaults */
+		return;
+	}
+
+	for (v = ast_variable_browse(cfg, "startup"); v; v = v->next) {
+		if (!strcasecmp(v->name, "log_level")) {
+			if (sscanf(v->value, "%30d", &ast_option_pjproject_log_level) != 1) {
+				ast_option_pjproject_log_level = DEFAULT_PJ_LOG_MAX_LEVEL;
+			} else if (ast_option_pjproject_log_level < 0) {
+				ast_option_pjproject_log_level = 0;
+			} else if (MAX_PJ_LOG_MAX_LEVEL < ast_option_pjproject_log_level) {
+				ast_option_pjproject_log_level = MAX_PJ_LOG_MAX_LEVEL;
+			}
+		}
+	}
+
+	ast_config_destroy(cfg);
+}
+
 static void *monitor_sig_flags(void *unused)
 {
 	for (;;) {
@@ -3815,7 +3967,7 @@ static void *canary_thread(void *unused)
 				"He's kicked the bucket.  He's shuffled off his mortal coil, "
 				"run down the curtain, and joined the bleeding choir invisible!!  "
 				"THIS is an EX-CANARY.  (Reducing priority)\n");
-			ast_set_priority(0);
+			set_priority_all(0);
 			pthread_exit(NULL);
 		}
 
@@ -3827,8 +3979,11 @@ static void *canary_thread(void *unused)
 /* Used by libc's atexit(3) function */
 static void canary_exit(void)
 {
-	if (canary_pid > 0)
+	if (canary_pid > 0) {
+		int status;
 		kill(canary_pid, SIGKILL);
+		waitpid(canary_pid, &status, 0);
+	}
 }
 
 /* Execute CLI commands on startup.  Run by main() thread. */
@@ -4290,13 +4445,26 @@ int main(int argc, char *argv[])
 	return 0;
 }
 
+static inline void check_init(int init_result, const char *name)
+{
+	if (init_result) {
+		if (ast_is_logger_initialized()) {
+			ast_log(LOG_ERROR, "%s initialization failed.  ASTERISK EXITING!\n%s", name, term_quit());
+		} else {
+			fprintf(stderr, "%s initialization failed.  ASTERISK EXITING!\n%s", name, term_quit());
+		}
+		ast_run_atexits(0);
+		exit(init_result == -2 ? 2 : 1);
+	}
+}
+
 static void asterisk_daemon(int isroot, const char *runuser, const char *rungroup)
 {
 	FILE *f;
 	sigset_t sigs;
 	int num;
 	char *buf;
-	int moduleresult;         /*!< Result from the module load subsystem */
+	char pbx_uuid[AST_UUID_STR_LEN];
 
 	/* This needs to remain as high up in the initial start up as possible.
 	 * daemon causes a fork to occur, which has all sorts of unintended
@@ -4326,8 +4494,16 @@ static void asterisk_daemon(int isroot,
 	__ast_mm_init_phase_1();
 #endif	/* defined(__AST_DEBUG_MALLOC) */
 
+	/* Check whether high prio was succesfully set by us or some
+	 * other incantation. */
+	if (has_priority()) {
+		ast_set_flag(&ast_options, AST_OPT_FLAG_HIGH_PRIORITY);
+	} else {
+		ast_clear_flag(&ast_options, AST_OPT_FLAG_HIGH_PRIORITY);
+	}
+
 	/* Spawning of astcanary must happen AFTER the call to daemon(3) */
-	if (isroot && ast_opt_high_priority) {
+	if (ast_opt_high_priority) {
 		snprintf(canary_filename, sizeof(canary_filename), "%s/alt.asterisk.canary.tweet.tweet.tweet", ast_config_AST_RUN_DIR);
 
 		/* Don't let the canary child kill Asterisk, if it dies immediately */
@@ -4386,15 +4562,8 @@ static void asterisk_daemon(int isroot,
 	register_config_cli();
 	read_config_maps();
 
-	if (astobj2_init()) {
-		printf("Failed: astobj2_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_named_locks_init()) {
-		printf("Failed: ast_named_locks_init\n%s", term_quit());
-		exit(1);
-	}
+	check_init(astobj2_init(), "AO2");
+	check_init(ast_named_locks_init(), "Named Locks");
 
 	if (ast_opt_console) {
 		if (el_hist == NULL || el == NULL)
@@ -4402,6 +4571,21 @@ static void asterisk_daemon(int isroot,
 		ast_el_read_default_histfile();
 	}
 
+#ifdef AST_XML_DOCS
+	/* Load XML documentation. */
+	ast_xmldoc_load_documentation();
+#endif
+
+	check_init(astdb_init(), "ASTdb");
+
+	ast_uuid_init();
+
+	if (ast_pbx_uuid_get(pbx_uuid, sizeof(pbx_uuid))) {
+		ast_uuid_generate_str(pbx_uuid, sizeof(pbx_uuid));
+		ast_db_put("pbx", "UUID", pbx_uuid);
+	}
+	ast_verb(0, "PBX UUID: %s\n", pbx_uuid);
+
 	ast_json_init();
 	ast_ulaw_init();
 	ast_alaw_init();
@@ -4409,92 +4593,27 @@ static void asterisk_daemon(int isroot,
 	callerid_init();
 	ast_builtins_init();
 
-	if (ast_utils_init()) {
-		printf("Failed: ast_utils_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_tps_init()) {
-		printf("Failed: ast_tps_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_fd_init()) {
-		printf("Failed: ast_fd_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_pbx_init()) {
-		printf("Failed: ast_pbx_init\n%s", term_quit());
-		exit(1);
-	}
-
+	check_init(ast_utils_init(), "Utilities");
+	check_init(ast_tps_init(), "Task Processor Core");
+	check_init(ast_fd_init(), "File Descriptor Debugging");
+	check_init(ast_pbx_init(), "ast_pbx_init");
 #ifdef TEST_FRAMEWORK
-	if (ast_test_init()) {
-		printf("Failed: ast_test_init\n%s", term_quit());
-		exit(1);
-	}
+	check_init(ast_test_init(), "Test Framework");
 #endif
-
-	if (ast_translate_init()) {
-		printf("Failed: ast_translate_init\n%s", term_quit());
-		exit(1);
-	}
+	check_init(ast_translate_init(), "Translator Core");
 
 	ast_aoc_cli_init();
-	ast_uuid_init();
-
-	if (ast_sorcery_init()) {
-		printf("Failed: ast_sorcery_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_codec_init()) {
-		printf("Failed: ast_codec_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_format_init()) {
-		printf("Failed: ast_format_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_format_cache_init()) {
-		printf("Failed: ast_format_cache_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_codec_builtin_init()) {
-		printf("Failed: ast_codec_builtin_init\n%s", term_quit());
-		exit(1);
-	}
 
-#ifdef AST_XML_DOCS
-	/* Load XML documentation. */
-	ast_xmldoc_load_documentation();
-#endif
-
-	aco_init();
-
-	if (ast_bucket_init()) {
-		printf("Failed: ast_bucket_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (stasis_init()) {
-		printf("Stasis initialization failed.\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_stasis_system_init()) {
-		printf("Stasis system-level information initialization failed.\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_endpoint_stasis_init()) {
-		printf("Endpoint initialization failed.\n%s", term_quit());
-		exit(1);
-	}
+	check_init(ast_sorcery_init(), "Sorcery");
+	check_init(ast_codec_init(), "Codecs");
+	check_init(ast_format_init(), "Formats");
+	check_init(ast_format_cache_init(), "Format Cache");
+	check_init(ast_codec_builtin_init(), "Built-in Codecs");
+	check_init(aco_init(), "Configuration Option Framework");
+	check_init(ast_bucket_init(), "Bucket API");
+	check_init(stasis_init(), "Stasis");
+	check_init(ast_stasis_system_init(), "Stasis system-level information");
+	check_init(ast_endpoint_stasis_init(), "Stasis Endpoint");
 
 	ast_makesocket();
 	/* GCC 4.9 gives a bogus "right-hand operand of comma expression has
@@ -4518,212 +4637,59 @@ static void asterisk_daemon(int isroot,
 	srand((unsigned int) getpid() + (unsigned int) time(NULL));
 	initstate((unsigned int) getpid() * 65536 + (unsigned int) time(NULL), randompool, sizeof(randompool));
 
-	if (init_logger()) {		/* Start logging subsystem */
-		printf("Failed: init_logger\n%s", term_quit());
-		exit(1);
-	}
+	check_init(init_logger(), "Logger");
 
 	threadstorage_init();
 
-	if (ast_rtp_engine_init()) {
-		printf("Failed: ast_rtp_engine_init\n%s", term_quit());
-		exit(1);
-	}
+	check_init(ast_rtp_engine_init(), "RTP Engine");
 
 	ast_autoservice_init();
 
-	if (ast_timing_init()) {
-		printf("Failed: ast_timing_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_ssl_init()) {
-		printf("Failed: ast_ssl_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_pj_init()) {
-		printf("Failed: ast_pj_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (app_init()) {
-		printf("App core initialization failed.\n%s", term_quit());
-		exit(1);
-	}
-
-	if (devstate_init()) {
-		printf("Device state core initialization failed.\n%s", term_quit());
-		exit(1);
-	}
-
-	if (astdb_init()) {
-		printf("Failed: astdb_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_msg_init()) {
-		printf("Failed: ast_msg_init\n%s", term_quit());
-		exit(1);
-	}
-
-	/* initialize the data retrieval API */
-	if (ast_data_init()) {
-		printf("Failed: ast_data_init\n%s", term_quit());
-		exit(1);
-	}
-
-	ast_channels_init();
-
-	if (ast_endpoint_init()) {
-		printf ("Failed: ast_endpoint_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_pickup_init()) {
-		printf("Failed: ast_pickup_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_bridging_init()) {
-		printf("Failed: ast_bridging_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_parking_stasis_init()) {
-		printf("Failed: ast_parking_stasis_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_device_state_engine_init()) {
-		printf("Failed: ast_device_state_engine_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_presence_state_engine_init()) {
-		printf("Failed: ast_presence_state_engine_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if ((moduleresult = load_modules(1))) {		/* Load modules, pre-load only */
-		printf("Failed: load_modules\n%s", term_quit());
-		exit(moduleresult == -2 ? 2 : 1);
-	}
-
-	if (ast_features_init()) {
-		printf("Failed: ast_features_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (dnsmgr_init()) {		/* Initialize the DNS manager */
-		printf("Failed: dnsmgr_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_security_stasis_init()) {		/* Initialize Security Stasis Topic and Events */
-		printf("Failed: ast_security_stasis_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_named_acl_init()) { /* Initialize the Named ACL system */
-		printf("Failed: ast_named_acl_init\n%s", term_quit());
-		exit(1);
-	}
+	check_init(ast_timing_init(), "Timing");
+	check_init(ast_ssl_init(), "SSL");
+	read_pjproject_startup_options();
+	check_init(ast_pj_init(), "Embedded PJProject");
+	check_init(app_init(), "App Core");
+	check_init(devstate_init(), "Device State Core");
+	check_init(ast_msg_init(), "Messaging API");
+	check_init(ast_data_init(), "Data Retrieval API");
+	check_init(ast_channels_init(), "Channel");
+	check_init(ast_endpoint_init(), "Endpoints");
+	check_init(ast_pickup_init(), "Call Pickup");
+	check_init(ast_bridging_init(), "Bridging");
+	check_init(ast_parking_stasis_init(), "Parking Core");
+	check_init(ast_device_state_engine_init(), "Device State Engine");
+	check_init(ast_presence_state_engine_init(), "Presence State Engine");
+	check_init(load_modules(1), "Module Preload");
+	check_init(ast_features_init(), "Call Features");
+	check_init(dnsmgr_init(), "DNS manager");
+	check_init(ast_security_stasis_init(), "Security Stasis Topic and Events");
+	check_init(ast_named_acl_init(), "Named ACL system");
 
 	ast_http_init();		/* Start the HTTP server, if needed */
 
-	if (ast_indications_init()) {
-		printf("Failed: ast_indications_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_cdr_engine_init()) {
-		printf("Failed: ast_cdr_engine_init\n%s", term_quit());
-		exit(1);
-	}
+	check_init(ast_indications_init(), "Indication Tone Handling");
+	check_init(ast_cdr_engine_init(), "CDR Engine");
 
 	ast_dsp_init();
 	ast_udptl_init();
 
-	if (ast_image_init()) {
-		printf("Failed: ast_image_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_file_init()) {
-		printf("Failed: ast_file_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx()) {
-		printf("Failed: load_pbx\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx_builtins()) {
-		printf("Failed: load_pbx_builtins\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx_functions_cli()) {
-		printf("Failed: load_pbx_functions_cli\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx_variables()) {
-		printf("Failed: load_pbx_variables\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx_switch()) {
-		printf("Failed: load_pbx_switch\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx_app()) {
-		printf("Failed: load_pbx_app\n%s", term_quit());
-		exit(1);
-	}
-
-	if (load_pbx_hangup_handler()) {
-		printf("Failed: load_pbx_hangup_handler\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_local_init()) {
-		printf("Failed: ast_local_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_cel_engine_init()) {
-		printf("Failed: ast_cel_engine_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (init_manager()) {
-		printf("Failed: init_manager\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_enum_init()) {
-		printf("Failed: ast_enum_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_cc_init()) {
-		printf("Failed: ast_cc_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if (ast_sounds_index_init()) {
-		printf("Failed: ast_sounds_index_init\n%s", term_quit());
-		exit(1);
-	}
-
-	if ((moduleresult = load_modules(0))) {		/* Load modules */
-		printf("%s", term_quit());
-		exit(moduleresult == -2 ? 2 : 1);
-	}
+	check_init(ast_image_init(), "Image");
+	check_init(ast_file_init(), "Generic File Format Support");
+	check_init(load_pbx(), "load_pbx");
+	check_init(load_pbx_builtins(), "Builtin PBX Applications");
+	check_init(load_pbx_functions_cli(), "PBX Functions Support");
+	check_init(load_pbx_variables(), "PBX Variables Support");
+	check_init(load_pbx_switch(), "PBX Switch Support");
+	check_init(load_pbx_app(), "PBX Application Support");
+	check_init(load_pbx_hangup_handler(), "PBX Hangup Handler Support");
+	check_init(ast_local_init(), "Local Proxy Channel Driver");
+	check_init(ast_cel_engine_init(), "CEL Engine");
+	check_init(init_manager(), "Asterisk Manager Interface");
+	check_init(ast_enum_init(), "ENUM Support");
+	check_init(ast_cc_init(), "Call Completion Supplementary Services");
+	check_init(ast_sounds_index_init(), "Sounds Indexer");
+	check_init(load_modules(0), "Module");
 
 	/* loads the cli_permissoins.conf file needed to implement cli restrictions. */
 	ast_cli_perms_init(0);
@@ -4757,6 +4723,7 @@ static void asterisk_daemon(int isroot,
 	ast_register_cleanup(main_atexit);
 
 	run_startup_commands();
+	ast_sd_notify("READY=1");
 
 	ast_verb(0, COLORIZE_FMT "\n", COLORIZE(COLOR_BRGREEN, 0, "Asterisk Ready."));
 
diff -urpN asterisk-13.9.1/main/asterisk.exports.in asterisk-13.17.0/main/asterisk.exports.in
--- asterisk-13.9.1/main/asterisk.exports.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/asterisk.exports.in	2017-07-12 13:12:08.000000000 +0200
@@ -49,6 +49,8 @@
 		LINKER_SYMBOL_PREFIXres_srtp;
 		LINKER_SYMBOL_PREFIXres_srtp_policy;
 		LINKER_SYMBOL_PREFIXsecure_call_info;
+		LINKER_SYMBOL_PREFIX__progname;
+		LINKER_SYMBOL_PREFIXenviron;
 		/*
 
 		If _IO_stdin_used is not exported, stdout/stderr may not get
diff -urpN asterisk-13.9.1/main/astfd.c asterisk-13.17.0/main/astfd.c
--- asterisk-13.9.1/main/astfd.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/astfd.c	2017-07-12 13:12:08.000000000 +0200
@@ -271,7 +271,7 @@ static char *handle_show_fd(struct ast_c
 	case CLI_GENERATE:
 		return NULL;
 	}
-	getrlimit(RLIMIT_FSIZE, &rl);
+	getrlimit(RLIMIT_NOFILE, &rl);
 	if (rl.rlim_cur == RLIM_INFINITY || rl.rlim_max == RLIM_INFINITY) {
 		ast_copy_string(line, "unlimited", sizeof(line));
 	} else {
diff -urpN asterisk-13.9.1/main/astmm.c asterisk-13.17.0/main/astmm.c
--- asterisk-13.9.1/main/astmm.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/astmm.c	2017-07-12 13:12:08.000000000 +0200
@@ -702,17 +702,12 @@ static char *handle_memory_atexit_list(s
 {
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "memory atexit list";
+		e->command = "memory atexit list {on|off}";
 		e->usage =
 			"Usage: memory atexit list {on|off}\n"
 			"       Enable dumping a list of still allocated memory segments at exit.\n";
 		return NULL;
 	case CLI_GENERATE:
-		if (a->pos == 3) {
-			const char * const options[] = { "off", "on", NULL };
-
-			return ast_cli_complete(a->word, options, a->n);
-		}
 		return NULL;
 	}
 
@@ -739,7 +734,7 @@ static char *handle_memory_atexit_summar
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "memory atexit summary";
+		e->command = "memory atexit summary {off|byline|byfunc|byfile}";
 		e->usage =
 			"Usage: memory atexit summary {off|byline|byfunc|byfile}\n"
 			"       Summary of still allocated memory segments at exit options.\n"
@@ -751,11 +746,6 @@ static char *handle_memory_atexit_summar
 			"       Note: byline, byfunc, and byfile are cumulative enables.\n";
 		return NULL;
 	case CLI_GENERATE:
-		if (a->pos == 3) {
-			const char * const options[] = { "off", "byline", "byfunc", "byfile", NULL };
-
-			return ast_cli_complete(a->word, options, a->n);
-		}
 		return NULL;
 	}
 
@@ -1054,7 +1044,7 @@ static char *handle_memory_backtrace(str
 {
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "memory backtrace";
+		e->command = "memory backtrace {on|off}";
 		e->usage =
 			"Usage: memory backtrace {on|off}\n"
 			"       Enable dumping an allocation backtrace with memory diagnostics.\n"
@@ -1062,11 +1052,6 @@ static char *handle_memory_backtrace(str
 			"       can be CPU intensive.\n";
 		return NULL;
 	case CLI_GENERATE:
-		if (a->pos == 2) {
-			const char * const options[] = { "off", "on", NULL };
-
-			return ast_cli_complete(a->word, options, a->n);
-		}
 		return NULL;
 	}
 
diff -urpN asterisk-13.9.1/main/astobj2.c asterisk-13.17.0/main/astobj2.c
--- asterisk-13.9.1/main/astobj2.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/astobj2.c	2017-07-12 13:12:08.000000000 +0200
@@ -52,8 +52,10 @@ static FILE *ref_log;
 struct __priv_data {
 	int ref_counter;
 	ao2_destructor_fn destructor_fn;
+#if defined(AO2_DEBUG)
 	/*! User data size for stats */
 	size_t data_size;
+#endif
 	/*! The ao2 object option flags */
 	uint32_t options;
 	/*! magic number.  This is used to verify that a pointer passed in is a
@@ -116,21 +118,17 @@ static struct astobj2 *INTERNAL_OBJ(void
 	struct astobj2 *p;
 
 	if (!user_data) {
-		ast_log(LOG_ERROR, "user_data is NULL\n");
+		__ast_assert_failed(0, "user_data is NULL", __FILE__, __LINE__, __PRETTY_FUNCTION__);
 		return NULL;
 	}
 
 	p = (struct astobj2 *) ((char *) user_data - sizeof(*p));
 	if (AO2_MAGIC != p->priv_data.magic) {
-		if (p->priv_data.magic) {
-			ast_log(LOG_ERROR, "bad magic number 0x%x for object %p\n",
-				p->priv_data.magic, user_data);
-		} else {
-			ast_log(LOG_ERROR,
-				"bad magic number for object %p. Object is likely destroyed.\n",
-				user_data);
-		}
-		ast_assert(0);
+		char bad_magic[100];
+
+		snprintf(bad_magic, sizeof(bad_magic), "bad magic number 0x%x for object %p",
+			p->priv_data.magic, user_data);
+		__ast_assert_failed(0, bad_magic, __FILE__, __LINE__, __PRETTY_FUNCTION__);
 		return NULL;
 	}
 
@@ -157,7 +155,6 @@ int __ao2_lock(void *user_data, enum ao2
 	int res = 0;
 
 	if (obj == NULL) {
-		ast_assert(0);
 		return -1;
 	}
 
@@ -216,7 +213,6 @@ int __ao2_unlock(void *user_data, const
 	int current_value;
 
 	if (obj == NULL) {
-		ast_assert(0);
 		return -1;
 	}
 
@@ -265,7 +261,6 @@ int __ao2_trylock(void *user_data, enum
 	int res = 0;
 
 	if (obj == NULL) {
-		ast_assert(0);
 		return -1;
 	}
 
@@ -385,7 +380,6 @@ void *ao2_object_get_lockaddr(void *user
 	struct astobj2_lock *obj_mutex;
 
 	if (obj == NULL) {
-		ast_assert(0);
 		return NULL;
 	}
 
@@ -409,7 +403,6 @@ static int internal_ao2_ref(void *user_d
 	int ret;
 
 	if (obj == NULL) {
-		ast_assert(0);
 		return -1;
 	}
 
@@ -428,6 +421,19 @@ static int internal_ao2_ref(void *user_d
 
 	if (0 < current_value) {
 		/* The object still lives. */
+#define EXCESSIVE_REF_COUNT		100000
+
+		if (EXCESSIVE_REF_COUNT <= current_value && ret < EXCESSIVE_REF_COUNT) {
+			char excessive_ref_buf[100];
+
+			/* We just reached or went over the excessive ref count trigger */
+			snprintf(excessive_ref_buf, sizeof(excessive_ref_buf),
+				"Excessive refcount %d reached on ao2 object %p",
+				current_value, user_data);
+			ast_log(__LOG_ERROR, file, line, func, "%s\n", excessive_ref_buf);
+
+			__ast_assert_failed(0, excessive_ref_buf, file, line, func);
+		}
 		return ret;
 	}
 
@@ -504,10 +510,6 @@ int __ao2_ref_debug(void *user_data, int
 		}
 	}
 
-	if (obj == NULL) {
-		ast_assert(0);
-	}
-
 	return old_refcount;
 }
 
@@ -583,11 +585,11 @@ static void *internal_ao2_alloc(size_t d
 	/* Initialize common ao2 values. */
 	obj->priv_data.ref_counter = 1;
 	obj->priv_data.destructor_fn = destructor_fn;	/* can be NULL */
-	obj->priv_data.data_size = data_size;
 	obj->priv_data.options = options;
 	obj->priv_data.magic = AO2_MAGIC;
 
 #ifdef AO2_DEBUG
+	obj->priv_data.data_size = data_size;
 	ast_atomic_fetchadd_int(&ao2.total_objects, 1);
 	ast_atomic_fetchadd_int(&ao2.total_mem, data_size);
 	ast_atomic_fetchadd_int(&ao2.total_refs, 1);
@@ -633,29 +635,7 @@ void *__ao2_alloc(size_t data_size, ao2_
 
 void __ao2_global_obj_release(struct ao2_global_obj *holder, const char *tag, const char *file, int line, const char *func, const char *name)
 {
-	if (!holder) {
-		/* For sanity */
-		ast_log(LOG_ERROR, "Must be called with a global object!\n");
-		ast_assert(0);
-		return;
-	}
-	if (__ast_rwlock_wrlock(file, line, func, &holder->lock, name)) {
-		/* Could not get the write lock. */
-		ast_assert(0);
-		return;
-	}
-
-	/* Release the held ao2 object. */
-	if (holder->obj) {
-		if (tag) {
-			__ao2_ref_debug(holder->obj, -1, tag, file, line, func);
-		} else {
-			__ao2_ref(holder->obj, -1);
-		}
-		holder->obj = NULL;
-	}
-
-	__ast_rwlock_unlock(file, line, func, &holder->lock, name);
+	__ao2_global_obj_replace_unref(holder, NULL, tag, file, line, func, name);
 }
 
 void *__ao2_global_obj_replace(struct ao2_global_obj *holder, void *obj, const char *tag, const char *file, int line, const char *func, const char *name)
diff -urpN asterisk-13.9.1/main/astobj2_container.c asterisk-13.17.0/main/astobj2_container.c
--- asterisk-13.9.1/main/astobj2_container.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/astobj2_container.c	2017-07-12 13:12:08.000000000 +0200
@@ -103,8 +103,11 @@ static int internal_ao2_link(struct ao2_
 	enum ao2_lock_req orig_lock;
 	struct ao2_container_node *node;
 
-	if (!is_ao2_object(obj_new) || !is_ao2_object(self)
-		|| !self->v_table || !self->v_table->new_node || !self->v_table->insert) {
+	if (!is_ao2_object(obj_new) || !is_ao2_object(self)) {
+		return 0;
+	}
+
+	if (!self->v_table || !self->v_table->new_node || !self->v_table->insert) {
 		/* Sanity checks. */
 		ast_assert(0);
 		return 0;
@@ -187,8 +190,6 @@ void *__ao2_unlink_debug(struct ao2_cont
 	const char *tag, const char *file, int line, const char *func)
 {
 	if (!is_ao2_object(user_data)) {
-		/* Sanity checks. */
-		ast_assert(0);
 		return NULL;
 	}
 
@@ -202,8 +203,6 @@ void *__ao2_unlink_debug(struct ao2_cont
 void *__ao2_unlink(struct ao2_container *c, void *user_data, int flags)
 {
 	if (!is_ao2_object(user_data)) {
-		/* Sanity checks. */
-		ast_assert(0);
 		return NULL;
 	}
 
@@ -268,7 +267,11 @@ static void *internal_ao2_traverse(struc
 	struct ao2_container *multi_container = NULL;
 	struct ao2_iterator *multi_iterator = NULL;
 
-	if (!is_ao2_object(self) || !self->v_table || !self->v_table->traverse_first
+	if (!is_ao2_object(self)) {
+		return NULL;
+	}
+
+	if (!self->v_table || !self->v_table->traverse_first
 		|| !self->v_table->traverse_next) {
 		/* Sanity checks. */
 		ast_assert(0);
@@ -512,7 +515,6 @@ void ao2_iterator_restart(struct ao2_ite
 {
 	if (!is_ao2_object(iter->c)) {
 		ast_log(LOG_ERROR, "Iterator container is not valid.\n");
-		ast_assert(0);
 		return;
 	}
 
@@ -577,7 +579,11 @@ static void *internal_ao2_iterator_next(
 	struct ao2_container_node *node;
 	void *ret;
 
-	if (!is_ao2_object(iter->c) || !iter->c->v_table || !iter->c->v_table->iterator_next) {
+	if (!is_ao2_object(iter->c)) {
+		return NULL;
+	}
+
+	if (!iter->c->v_table || !iter->c->v_table->iterator_next) {
 		/* Sanity checks. */
 		ast_assert(0);
 		return NULL;
@@ -748,7 +754,11 @@ struct ao2_container *__ao2_container_cl
 	int failed;
 
 	/* Create the clone container with the same properties as the original. */
-	if (!is_ao2_object(orig) || !orig->v_table || !orig->v_table->alloc_empty_clone) {
+	if (!is_ao2_object(orig)) {
+		return NULL;
+	}
+
+	if (!orig->v_table || !orig->v_table->alloc_empty_clone) {
 		/* Sanity checks. */
 		ast_assert(0);
 		return NULL;
@@ -779,7 +789,11 @@ struct ao2_container *__ao2_container_cl
 	int failed;
 
 	/* Create the clone container with the same properties as the original. */
-	if (!is_ao2_object(orig) || !orig->v_table || !orig->v_table->alloc_empty_clone_debug) {
+	if (!is_ao2_object(orig)) {
+		return NULL;
+	}
+
+	if (!orig->v_table || !orig->v_table->alloc_empty_clone_debug) {
 		/* Sanity checks. */
 		ast_assert(0);
 		return NULL;
diff -urpN asterisk-13.9.1/main/astobj2_hash.c asterisk-13.17.0/main/astobj2_hash.c
--- asterisk-13.9.1/main/astobj2_hash.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/astobj2_hash.c	2017-07-12 13:12:08.000000000 +0200
@@ -186,7 +186,9 @@ static void hash_ao2_node_destructor(voi
 		 * same node.
 		 */
 		my_container = (struct ao2_container_hash *) doomed->common.my_container;
-		ast_assert(is_ao2_object(my_container));
+#if defined(AST_DEVMODE)
+		is_ao2_object(my_container);
+#endif
 
 		__adjust_lock(my_container, AO2_LOCK_REQ_WRLOCK, 1);
 
@@ -298,7 +300,7 @@ static enum ao2_container_insert hash_ao
 					break;
 				case AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE:
 					SWAP(cur->common.obj, node->common.obj);
-					ao2_t_ref(node, -1, "Discard the new node.");
+					__ao2_ref(node, -1);
 					return AO2_CONTAINER_INSERT_NODE_OBJ_REPLACED;
 				}
 			}
@@ -331,7 +333,7 @@ static enum ao2_container_insert hash_ao
 					break;
 				case AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE:
 					SWAP(cur->common.obj, node->common.obj);
-					ao2_t_ref(node, -1, "Discard the new node.");
+					__ao2_ref(node, -1);
 					return AO2_CONTAINER_INSERT_NODE_OBJ_REPLACED;
 				}
 			}
diff -urpN asterisk-13.9.1/main/astobj2_rbtree.c asterisk-13.17.0/main/astobj2_rbtree.c
--- asterisk-13.9.1/main/astobj2_rbtree.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/astobj2_rbtree.c	2017-07-12 13:12:08.000000000 +0200
@@ -878,7 +878,9 @@ static void rb_ao2_node_destructor(void
 		 * same node.
 		 */
 		my_container = (struct ao2_container_rbtree *) doomed->common.my_container;
-		ast_assert(is_ao2_object(my_container));
+#if defined(AST_DEVMODE)
+		is_ao2_object(my_container);
+#endif
 
 		__adjust_lock(my_container, AO2_LOCK_REQ_WRLOCK, 1);
 
@@ -1267,7 +1269,7 @@ static enum ao2_container_insert rb_ao2_
 		break;
 	case AO2_CONTAINER_ALLOC_OPT_DUPS_REPLACE:
 		SWAP(cur->common.obj, node->common.obj);
-		ao2_t_ref(node, -1, "Don't need the new node.");
+		__ao2_ref(node, -1);
 		return AO2_CONTAINER_INSERT_NODE_OBJ_REPLACED;
 	}
 
diff -urpN asterisk-13.9.1/main/audiohook.c asterisk-13.17.0/main/audiohook.c
--- asterisk-13.9.1/main/audiohook.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/audiohook.c	2017-07-12 13:12:08.000000000 +0200
@@ -157,6 +157,11 @@ int ast_audiohook_destroy(struct ast_aud
 	return 0;
 }
 
+#define SHOULD_MUTE(hook, dir) \
+	((ast_test_flag(hook, AST_AUDIOHOOK_MUTE_READ) && (dir == AST_AUDIOHOOK_DIRECTION_READ)) || \
+	(ast_test_flag(hook, AST_AUDIOHOOK_MUTE_WRITE) && (dir == AST_AUDIOHOOK_DIRECTION_WRITE)) || \
+	(ast_test_flag(hook, AST_AUDIOHOOK_MUTE_READ | AST_AUDIOHOOK_MUTE_WRITE) == (AST_AUDIOHOOK_MUTE_READ | AST_AUDIOHOOK_MUTE_WRITE)))
+
 /*! \brief Writes a frame into the audiohook structure
  * \param audiohook Audiohook structure
  * \param direction Direction the audio frame came from
@@ -172,7 +177,6 @@ int ast_audiohook_write_frame(struct ast
 	int our_factory_ms;
 	int other_factory_samples;
 	int other_factory_ms;
-	int muteme = 0;
 
 	/* Update last feeding time to be current */
 	*rwtime = ast_tvnow();
@@ -182,7 +186,7 @@ int ast_audiohook_write_frame(struct ast
 	other_factory_samples = ast_slinfactory_available(other_factory);
 	other_factory_ms = other_factory_samples / (audiohook->hook_internal_samp_rate / 1000);
 
-	if (ast_test_flag(audiohook, AST_AUDIOHOOK_TRIGGER_SYNC) && other_factory_samples && (our_factory_ms - other_factory_ms > AST_AUDIOHOOK_SYNC_TOLERANCE)) {
+	if (ast_test_flag(audiohook, AST_AUDIOHOOK_TRIGGER_SYNC) && (our_factory_ms - other_factory_ms > AST_AUDIOHOOK_SYNC_TOLERANCE)) {
 		ast_debug(1, "Flushing audiohook %p so it remains in sync\n", audiohook);
 		ast_slinfactory_flush(factory);
 		ast_slinfactory_flush(other_factory);
@@ -194,17 +198,6 @@ int ast_audiohook_write_frame(struct ast
 		ast_slinfactory_flush(other_factory);
 	}
 
-	/* swap frame data for zeros if mute is required */
-	if ((ast_test_flag(audiohook, AST_AUDIOHOOK_MUTE_READ) && (direction == AST_AUDIOHOOK_DIRECTION_READ)) ||
-		(ast_test_flag(audiohook, AST_AUDIOHOOK_MUTE_WRITE) && (direction == AST_AUDIOHOOK_DIRECTION_WRITE)) ||
-		(ast_test_flag(audiohook, AST_AUDIOHOOK_MUTE_READ | AST_AUDIOHOOK_MUTE_WRITE) == (AST_AUDIOHOOK_MUTE_READ | AST_AUDIOHOOK_MUTE_WRITE))) {
-			muteme = 1;
-	}
-
-	if (muteme && frame->datalen > 0) {
-		ast_frame_clear(frame);
-	}
-
 	/* Write frame out to respective factory */
 	ast_slinfactory_feed(factory, frame);
 
@@ -243,8 +236,11 @@ static struct ast_frame *audiohook_read_
 		return NULL;
 	}
 
-	/* If a volume adjustment needs to be applied apply it */
-	if (vol) {
+	if (SHOULD_MUTE(audiohook, direction)) {
+		/* Swap frame data for zeros if mute is required */
+		ast_frame_clear(&frame);
+	} else if (vol) {
+		/* If a volume adjustment needs to be applied apply it */
 		ast_frame_adjust_volume(&frame, vol);
 	}
 
@@ -293,8 +289,12 @@ static struct ast_frame *audiohook_read_
 	if (usable_read) {
 		if (ast_slinfactory_read(&audiohook->read_factory, buf1, samples)) {
 			read_buf = buf1;
-			/* Adjust read volume if need be */
-			if (audiohook->options.read_volume) {
+
+			if ((ast_test_flag(audiohook, AST_AUDIOHOOK_MUTE_READ))) {
+				/* Clear the frame data if we are muting */
+				memset(buf1, 0, sizeof(buf1));
+			} else if (audiohook->options.read_volume) {
+				/* Adjust read volume if need be */
 				adjust_value = abs(audiohook->options.read_volume);
 				for (count = 0; count < samples; count++) {
 					if (audiohook->options.read_volume > 0) {
@@ -313,8 +313,12 @@ static struct ast_frame *audiohook_read_
 	if (usable_write) {
 		if (ast_slinfactory_read(&audiohook->write_factory, buf2, samples)) {
 			write_buf = buf2;
-			/* Adjust write volume if need be */
-			if (audiohook->options.write_volume) {
+
+			if ((ast_test_flag(audiohook, AST_AUDIOHOOK_MUTE_WRITE))) {
+				/* Clear the frame data if we are muting */
+				memset(buf2, 0, sizeof(buf2));
+			} else if (audiohook->options.write_volume) {
+				/* Adjust write volume if need be */
 				adjust_value = abs(audiohook->options.write_volume);
 				for (count = 0; count < samples; count++) {
 					if (audiohook->options.write_volume > 0) {
@@ -938,6 +942,15 @@ static struct ast_frame *audio_audiohook
 	if (!(middle_frame = audiohook_list_translate_to_slin(audiohook_list, direction, start_frame))) {
 		return frame;
 	}
+
+	/* If the translation resulted in an interpolated frame then immediately return as audiohooks
+	 * rely on actual media being present to do things.
+	 */
+	if (!middle_frame->data.ptr) {
+		ast_frfree(middle_frame);
+		return start_frame;
+	}
+
 	samples = middle_frame->samples;
 
 	/*
diff -urpN asterisk-13.9.1/main/autochan.c asterisk-13.17.0/main/autochan.c
--- asterisk-13.9.1/main/autochan.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/autochan.c	2017-07-12 13:12:08.000000000 +0200
@@ -48,15 +48,18 @@ struct ast_autochan *ast_autochan_setup(
 	if (!(autochan = ast_calloc(1, sizeof(*autochan)))) {
 		return NULL;
 	}
+	ast_mutex_init(&autochan->lock);
 
 	autochan->chan = ast_channel_ref(chan);
 
-	ast_channel_lock(autochan->chan); /* autochan is still private, no need for ast_autochan_channel_lock() */
+	ast_debug(1, "Created autochan %p to hold channel %s (%p)\n",
+		autochan, ast_channel_name(chan), chan);
+
+	/* autochan is still private, no need for ast_autochan_channel_lock() */
+	ast_channel_lock(autochan->chan);
 	AST_LIST_INSERT_TAIL(ast_channel_autochans(autochan->chan), autochan, list);
 	ast_channel_unlock(autochan->chan);
 
-	ast_debug(1, "Created autochan %p to hold channel %s (%p)\n", autochan, ast_channel_name(chan), chan);
-
 	return autochan;
 }
 
@@ -77,6 +80,8 @@ void ast_autochan_destroy(struct ast_aut
 
 	autochan->chan = ast_channel_unref(autochan->chan);
 
+	ast_mutex_destroy(&autochan->lock);
+
 	ast_free(autochan);
 }
 
@@ -86,13 +91,16 @@ void ast_autochan_new_channel(struct ast
 
 	AST_LIST_APPEND_LIST(ast_channel_autochans(new_chan), ast_channel_autochans(old_chan), list);
 
+	/* Deadlock avoidance is not needed since the channels are already locked. */
 	AST_LIST_TRAVERSE(ast_channel_autochans(new_chan), autochan, list) {
+		ast_mutex_lock(&autochan->lock);
 		if (autochan->chan == old_chan) {
-			autochan->chan = ast_channel_unref(old_chan);
 			autochan->chan = ast_channel_ref(new_chan);
+			ast_channel_unref(old_chan);
 
 			ast_debug(1, "Autochan %p used to hold channel %s (%p) but now holds channel %s (%p)\n",
 					autochan, ast_channel_name(old_chan), old_chan, ast_channel_name(new_chan), new_chan);
 		}
+		ast_mutex_unlock(&autochan->lock);
 	}
 }
diff -urpN asterisk-13.9.1/main/autoservice.c asterisk-13.17.0/main/autoservice.c
--- asterisk-13.9.1/main/autoservice.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/autoservice.c	2017-07-12 13:12:08.000000000 +0200
@@ -300,11 +300,11 @@ int ast_autoservice_stop(struct ast_chan
 		res = 0;
 	}
 
+	ast_channel_lock(chan);
 	if (!as->orig_end_dtmf_flag) {
 		ast_clear_flag(ast_channel_flags(chan), AST_FLAG_END_DTMF_ONLY);
 	}
 
-	ast_channel_lock(chan);
 	while ((f = AST_LIST_REMOVE_HEAD(&as->deferred_frames, frame_list))) {
 		if (!((1 << f->frametype) & as->ignore_frame_types)) {
 			ast_queue_frame_head(chan, f);
diff -urpN asterisk-13.9.1/main/bridge.c asterisk-13.17.0/main/bridge.c
--- asterisk-13.9.1/main/bridge.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/bridge.c	2017-07-12 13:12:08.000000000 +0200
@@ -38,6 +38,10 @@
 		<description>
 			<para>Returns detailed information about the available bridging technologies.</para>
 		</description>
+		<see-also>
+			<ref type="manager">BridgeTechnologySuspend</ref>
+			<ref type="manager">BridgeTechnologyUnsuspend</ref>
+		</see-also>
 	</manager>
 	<manager name="BridgeTechnologySuspend" language="en_US">
 		<synopsis>
@@ -52,6 +56,10 @@
 		<description>
 			<para>Marks a bridging technology as suspended, which prevents subsequently created bridges from using it.</para>
 		</description>
+		<see-also>
+			<ref type="manager">BridgeTechnologySuspend</ref>
+			<ref type="manager">BridgeTechnologyUnsuspend</ref>
+		</see-also>
 	</manager>
 	<manager name="BridgeTechnologyUnsuspend" language="en_US">
 		<synopsis>
@@ -66,6 +74,10 @@
 		<description>
 			<para>Clears a previously suspended bridging technology, which allows subsequently created bridges to use it.</para>
 		</description>
+		<see-also>
+			<ref type="manager">BridgeTechnologyList</ref>
+			<ref type="manager">BridgeTechnologySuspend</ref>
+		</see-also>
 	</manager>
 ***/
 
@@ -420,10 +432,12 @@ static void bridge_channel_complete_join
 		bridge->technology->name);
 	if (bridge->technology->join
 		&& bridge->technology->join(bridge, bridge_channel)) {
-		ast_debug(1, "Bridge %s: %p(%s) failed to join %s technology\n",
+		/* We cannot leave the channel partially in the bridge so we must kick it out */
+		ast_debug(1, "Bridge %s: %p(%s) failed to join %s technology (Kicking it out)\n",
 			bridge->uniqueid, bridge_channel, ast_channel_name(bridge_channel->chan),
 			bridge->technology->name);
 		bridge_channel->just_joined = 1;
+		ast_bridge_channel_leave_bridge(bridge_channel, BRIDGE_CHANNEL_STATE_END, 0);
 		return;
 	}
 
@@ -457,6 +471,7 @@ static void bridge_complete_join(struct
 	}
 
 	AST_LIST_TRAVERSE(&bridge->channels, bridge_channel, entry) {
+		bridge_channel_queue_deferred_frames(bridge_channel);
 		if (!bridge_channel->just_joined) {
 			continue;
 		}
@@ -2485,6 +2500,9 @@ int ast_bridge_add_channel(struct ast_br
 	if (chan_bridge) {
 		struct ast_bridge_channel *bridge_channel;
 
+		/* The channel is in a bridge so it is not getting any new features. */
+		ast_bridge_features_destroy(features);
+
 		ast_bridge_lock_both(bridge, chan_bridge);
 		bridge_channel = bridge_find_channel(chan_bridge, chan);
 
@@ -2507,9 +2525,6 @@ int ast_bridge_add_channel(struct ast_br
 		bridge_dissolve_check_stolen(chan_bridge, bridge_channel);
 		ast_bridge_unlock(chan_bridge);
 		ast_bridge_unlock(bridge);
-
-		/* The channel was in a bridge so it is not getting any new features. */
-		ast_bridge_features_destroy(features);
 	} else {
 		/* Slightly less easy case. We need to yank channel A from
 		 * where he currently is and impart him into our bridge.
@@ -2517,6 +2532,7 @@ int ast_bridge_add_channel(struct ast_br
 		yanked_chan = ast_channel_yank(chan);
 		if (!yanked_chan) {
 			ast_log(LOG_WARNING, "Could not gain control of channel %s\n", ast_channel_name(chan));
+			ast_bridge_features_destroy(features);
 			return -1;
 		}
 		if (ast_channel_state(yanked_chan) != AST_STATE_UP) {
@@ -3755,8 +3771,11 @@ void ast_bridge_set_single_src_video_mod
 	cleanup_video_mode(bridge);
 	bridge->softmix.video_mode.mode = AST_BRIDGE_VIDEO_MODE_SINGLE_SRC;
 	bridge->softmix.video_mode.mode_data.single_src_data.chan_vsrc = ast_channel_ref(video_src_chan);
-	ast_test_suite_event_notify("BRIDGE_VIDEO_MODE", "Message: video mode set to single source\r\nVideo Mode: %u\r\nVideo Channel: %s",
-		bridge->softmix.video_mode.mode, ast_channel_name(video_src_chan));
+	ast_verb(5, "Video source in bridge '%s' (%s) is now '%s' (%s)\n",
+		bridge->name, bridge->uniqueid,
+		ast_channel_name(video_src_chan),
+		ast_channel_uniqueid(video_src_chan));
+	ast_bridge_publish_state(bridge);
 	ast_indicate(video_src_chan, AST_CONTROL_VIDUPDATE);
 	ast_bridge_unlock(bridge);
 }
@@ -3766,8 +3785,6 @@ void ast_bridge_set_talker_src_video_mod
 	ast_bridge_lock(bridge);
 	cleanup_video_mode(bridge);
 	bridge->softmix.video_mode.mode = AST_BRIDGE_VIDEO_MODE_TALKER_SRC;
-	ast_test_suite_event_notify("BRIDGE_VIDEO_MODE", "Message: video mode set to talker source\r\nVideo Mode: %u",
-		bridge->softmix.video_mode.mode);
 	ast_bridge_unlock(bridge);
 }
 
@@ -3795,14 +3812,22 @@ void ast_bridge_update_talker_src_video_
 		}
 		data->chan_vsrc = ast_channel_ref(chan);
 		data->average_talking_energy = talker_energy;
-		ast_test_suite_event_notify("BRIDGE_VIDEO_SRC", "Message: video source updated\r\nVideo Channel: %s", ast_channel_name(data->chan_vsrc));
+		ast_verb(5, "Video source in bridge '%s' (%s) is now '%s' (%s)\n",
+			bridge->name, bridge->uniqueid,
+			ast_channel_name(data->chan_vsrc),
+			ast_channel_uniqueid(data->chan_vsrc));
+		ast_bridge_publish_state(bridge);
 		ast_indicate(data->chan_vsrc, AST_CONTROL_VIDUPDATE);
 	} else if ((data->average_talking_energy < talker_energy) && !is_keyframe) {
 		ast_indicate(chan, AST_CONTROL_VIDUPDATE);
 	} else if (!data->chan_vsrc && is_keyframe) {
 		data->chan_vsrc = ast_channel_ref(chan);
 		data->average_talking_energy = talker_energy;
-		ast_test_suite_event_notify("BRIDGE_VIDEO_SRC", "Message: video source updated\r\nVideo Channel: %s", ast_channel_name(data->chan_vsrc));
+		ast_verb(5, "Video source in bridge '%s' (%s) is now '%s' (%s)\n",
+			bridge->name, bridge->uniqueid,
+			ast_channel_name(data->chan_vsrc),
+			ast_channel_uniqueid(data->chan_vsrc));
+		ast_bridge_publish_state(bridge);
 		ast_indicate(chan, AST_CONTROL_VIDUPDATE);
 	} else if (!data->chan_old_vsrc && is_keyframe) {
 		data->chan_old_vsrc = ast_channel_ref(chan);
@@ -3893,6 +3918,19 @@ void ast_bridge_remove_video_src(struct
 	ast_bridge_unlock(bridge);
 }
 
+const char *ast_bridge_video_mode_to_string(enum ast_bridge_video_mode_type video_mode)
+{
+	switch (video_mode) {
+	case AST_BRIDGE_VIDEO_MODE_TALKER_SRC:
+		return "talker";
+	case AST_BRIDGE_VIDEO_MODE_SINGLE_SRC:
+		return "single";
+	case AST_BRIDGE_VIDEO_MODE_NONE:
+	default:
+		return "none";
+	}
+}
+
 static int channel_hash(const void *obj, int flags)
 {
 	const struct ast_channel *chan = obj;
@@ -4203,14 +4241,15 @@ static enum ast_transfer_result attended
 	BRIDGE_LOCK_ONE_OR_BOTH(bridge1, bridge2);
 
 	if (bridge2) {
+		void *tech;
 		struct ast_channel *locals[2];
 
 		/* Have to lock everything just in case a hangup comes in early */
-		ast_local_lock_all(local_chan, &locals[0], &locals[1]);
+		ast_local_lock_all2(local_chan, &tech, &locals[0], &locals[1]);
 		if (!locals[0] || !locals[1]) {
 			ast_log(LOG_ERROR, "Transfer failed probably due to an early hangup - "
 				"missing other half of '%s'\n", ast_channel_name(local_chan));
-			ast_local_unlock_all(local_chan);
+			ast_local_unlock_all2(tech, locals[0], locals[1]);
 			ao2_cleanup(local_chan);
 			return AST_BRIDGE_TRANSFER_FAIL;
 		}
@@ -4221,7 +4260,7 @@ static enum ast_transfer_result attended
 		}
 
 		ast_attended_transfer_message_add_link(transfer_msg, locals);
-		ast_local_unlock_all(local_chan);
+		ast_local_unlock_all2(tech, locals[0], locals[1]);
 	} else {
 		ast_attended_transfer_message_add_app(transfer_msg, app, local_chan);
 	}
@@ -4749,7 +4788,7 @@ enum ast_transfer_result ast_bridge_tran
 	res = AST_BRIDGE_TRANSFER_SUCCESS;
 
 end:
-	if (res == AST_BRIDGE_TRANSFER_SUCCESS && hangup_target) {
+	if ((res == AST_BRIDGE_TRANSFER_SUCCESS && hangup_target) || res == AST_BRIDGE_TRANSFER_FAIL) {
 		ast_softhangup(to_transfer_target, AST_SOFTHANGUP_DEV);
 	}
 
@@ -5133,12 +5172,6 @@ static char *complete_bridge_participant
 		return NULL;
 	}
 
-	if (!state) {
-		ao2_ref(bridge, -1);
-		return ast_strdup("all");
-	}
-	state--;
-
 	{
 		SCOPED_LOCK(bridge_lock, bridge, ast_bridge_lock, ast_bridge_unlock);
 
@@ -5160,6 +5193,8 @@ static char *complete_bridge_participant
 
 static char *handle_bridge_kick_channel(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
+	static const char * const completions[] = { "all", NULL };
+	char *complete;
 	struct ast_bridge *bridge;
 
 	switch (cmd) {
@@ -5176,7 +5211,11 @@ static char *handle_bridge_kick_channel(
 			return complete_bridge_live(a->word, a->n);
 		}
 		if (a->pos == 3) {
-			return complete_bridge_participant(a->argv[2], a->line, a->word, a->pos, a->n);
+			complete = ast_cli_complete(a->word, completions, a->n);
+			if (!complete) {
+				complete = complete_bridge_participant(a->argv[2], a->line, a->word, a->pos, a->n - 1);
+			}
+			return complete;
 		}
 		return NULL;
 	}
diff -urpN asterisk-13.9.1/main/bridge_after.c asterisk-13.17.0/main/bridge_after.c
--- asterisk-13.9.1/main/bridge_after.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/bridge_after.c	2017-07-12 13:12:08.000000000 +0200
@@ -484,7 +484,7 @@ int ast_bridge_setup_after_goto(struct a
 		}
 	} else if (!ast_check_hangup(chan)) {
 		/* Clear the outgoing flag */
-		ast_clear_flag(ast_channel_flags(chan), AST_FLAG_OUTGOING);
+		ast_channel_clear_flag(chan, AST_FLAG_OUTGOING);
 
 		if (after_bridge->specific) {
 			goto_failed = ast_explicit_goto(chan, after_bridge->context,
diff -urpN asterisk-13.9.1/main/bridge_basic.c asterisk-13.17.0/main/bridge_basic.c
--- asterisk-13.9.1/main/bridge_basic.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/bridge_basic.c	2017-07-12 13:12:08.000000000 +0200
@@ -3090,7 +3090,9 @@ static int attach_framehook(struct atten
 	ao2_ref(props, +1);
 	target_interface.data = props;
 
+	ast_channel_lock(channel);
 	props->target_framehook_id = ast_framehook_attach(channel, &target_interface);
+	ast_channel_unlock(channel);
 	if (props->target_framehook_id == -1) {
 		ao2_ref(props, -1);
 		return -1;
diff -urpN asterisk-13.9.1/main/bridge_channel.c asterisk-13.17.0/main/bridge_channel.c
--- asterisk-13.9.1/main/bridge_channel.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/bridge_channel.c	2017-07-12 13:12:08.000000000 +0200
@@ -37,6 +37,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include <signal.h>
 
 #include "asterisk/heap.h"
+#include "asterisk/alertpipe.h"
 #include "asterisk/astobj2.h"
 #include "asterisk/stringfields.h"
 #include "asterisk/app.h"
@@ -638,18 +639,21 @@ void ast_bridge_channel_kick(struct ast_
 static int bridge_channel_write_frame(struct ast_bridge_channel *bridge_channel, struct ast_frame *frame)
 {
 	const struct ast_control_t38_parameters *t38_parameters;
+	int deferred;
 
 	ast_assert(frame->frametype != AST_FRAME_BRIDGE_ACTION_SYNC);
 
 	ast_bridge_channel_lock_bridge(bridge_channel);
-/*
- * XXX need to implement a deferred write queue for when there
- * is no peer channel in the bridge (yet or it was kicked).
- *
- * The tech decides if a frame needs to be pushed back for deferral.
- * simple_bridge/native_bridge are likely the only techs that will do this.
- */
-	bridge_channel->bridge->technology->write(bridge_channel->bridge, bridge_channel, frame);
+
+	deferred = bridge_channel->bridge->technology->write(bridge_channel->bridge, bridge_channel, frame);
+	if (deferred) {
+		struct ast_frame *dup;
+
+		dup = ast_frdup(frame);
+		if (dup) {
+			AST_LIST_INSERT_HEAD(&bridge_channel->deferred_queue, dup, frame_list);
+		}
+	}
 
 	/* Remember any owed events to the bridge. */
 	switch (frame->frametype) {
@@ -753,6 +757,18 @@ void bridge_channel_settle_owed_events(s
 	}
 }
 
+void bridge_channel_queue_deferred_frames(struct ast_bridge_channel *bridge_channel)
+{
+	struct ast_frame *frame;
+
+	ast_channel_lock(bridge_channel->chan);
+	while ((frame = AST_LIST_REMOVE_HEAD(&bridge_channel->deferred_queue, frame_list))) {
+		ast_queue_frame_head(bridge_channel->chan, frame);
+		ast_frfree(frame);
+	}
+	ast_channel_unlock(bridge_channel->chan);
+}
+
 /*!
  * \internal
  * \brief Suspend a channel from a bridge.
@@ -956,7 +972,6 @@ static void bridge_frame_free(struct ast
 int ast_bridge_channel_queue_frame(struct ast_bridge_channel *bridge_channel, struct ast_frame *fr)
 {
 	struct ast_frame *dup;
-	char nudge = 0;
 
 	if (bridge_channel->suspended
 		/* Also defer DTMF frames. */
@@ -985,7 +1000,7 @@ int ast_bridge_channel_queue_frame(struc
 	}
 
 	AST_LIST_INSERT_TAIL(&bridge_channel->wr_queue, dup, frame_list);
-	if (write(bridge_channel->alert_pipe[1], &nudge, sizeof(nudge)) != sizeof(nudge)) {
+	if (ast_alertpipe_write(bridge_channel->alert_pipe)) {
 		ast_log(LOG_ERROR, "We couldn't write alert pipe for %p(%s)... something is VERY wrong\n",
 			bridge_channel, ast_channel_name(bridge_channel->chan));
 	}
@@ -1543,8 +1558,13 @@ static void testsuite_notify_feature_suc
 {
 #ifdef TEST_FRAMEWORK
 	char *feature = "unknown";
-	struct ast_featuremap_config *featuremap = ast_get_chan_featuremap_config(chan);
-	struct ast_features_xfer_config *xfer = ast_get_chan_features_xfer_config(chan);
+	struct ast_featuremap_config *featuremap;
+	struct ast_features_xfer_config *xfer;
+
+	ast_channel_lock(chan);
+	featuremap = ast_get_chan_featuremap_config(chan);
+	xfer = ast_get_chan_features_xfer_config(chan);
+	ast_channel_unlock(chan);
 
 	if (featuremap) {
 		if (!strcmp(dtmf, featuremap->blindxfer)) {
@@ -2087,7 +2107,7 @@ void bridge_channel_internal_pull(struct
 	    && (ast_channel_is_leaving_bridge(bridge_channel->chan)
 	        || bridge_channel->state == BRIDGE_CHANNEL_STATE_WAIT)) {
 		ast_debug(2, "Channel %s will survive this bridge; clearing outgoing (dialed) flag\n", ast_channel_name(bridge_channel->chan));
-		ast_clear_flag(ast_channel_flags(bridge_channel->chan), AST_FLAG_OUTGOING);
+		ast_channel_clear_flag(bridge_channel->chan, AST_FLAG_OUTGOING);
 	}
 
 	bridge->reconfigured = 1;
@@ -2162,9 +2182,10 @@ int bridge_channel_internal_push_full(st
 
 	ast_bridge_publish_enter(bridge, bridge_channel->chan, swap ? swap->chan : NULL);
 
-	/* Clear any BLINDTRANSFER and ATTENDEDTRANSFER since the transfer has completed. */
+	/* Clear any BLINDTRANSFER,ATTENDEDTRANSFER and FORWARDERNAME since the transfer has completed. */
 	pbx_builtin_setvar_helper(bridge_channel->chan, "BLINDTRANSFER", NULL);
 	pbx_builtin_setvar_helper(bridge_channel->chan, "ATTENDEDTRANSFER", NULL);
+	pbx_builtin_setvar_helper(bridge_channel->chan, "FORWARDERNAME", NULL);
 
 	/* Wake up the bridge channel thread to reevaluate any interval timers. */
 	ast_queue_frame(bridge_channel->chan, &ast_null_frame);
@@ -2253,25 +2274,6 @@ static void bridge_channel_handle_contro
 
 /*!
  * \internal
- * \param bridge_channel Channel to read wr_queue alert pipe.
- *
- * \return Nothing
- */
-static void bridge_channel_read_wr_queue_alert(struct ast_bridge_channel *bridge_channel)
-{
-	char nudge;
-
-	if (read(bridge_channel->alert_pipe[0], &nudge, sizeof(nudge)) < 0) {
-		if (errno != EINTR && errno != EAGAIN) {
-			ast_log(LOG_WARNING, "read() failed for alert pipe on %p(%s): %s\n",
-				bridge_channel, ast_channel_name(bridge_channel->chan),
-				strerror(errno));
-		}
-	}
-}
-
-/*!
- * \internal
  * \brief Handle bridge channel write frame to channel.
  * \since 12.0.0
  *
@@ -2292,7 +2294,7 @@ static void bridge_channel_handle_write(
 		/* No frame, flush the alert pipe of excess alerts. */
 		ast_log(LOG_WARNING, "Weird.  No frame from bridge for %s to process?\n",
 			ast_channel_name(bridge_channel->chan));
-		bridge_channel_read_wr_queue_alert(bridge_channel);
+		ast_alertpipe_read(bridge_channel->alert_pipe);
 		ast_bridge_channel_unlock(bridge_channel);
 		return;
 	}
@@ -2308,7 +2310,7 @@ static void bridge_channel_handle_write(
 				break;
 			}
 		}
-		bridge_channel_read_wr_queue_alert(bridge_channel);
+		ast_alertpipe_read(bridge_channel->alert_pipe);
 		AST_LIST_REMOVE_CURRENT(frame_list);
 		break;
 	}
@@ -2737,6 +2739,9 @@ int bridge_channel_internal_join(struct
 	bridge_channel_settle_owed_events(bridge_channel->bridge, bridge_channel);
 	bridge_reconfigured(bridge_channel->bridge, 1);
 
+	/* Remove ourselves if we are the video source */
+	ast_bridge_remove_video_src(bridge_channel->bridge, bridge_channel->chan);
+
 	ast_bridge_unlock(bridge_channel->bridge);
 
 	/* Must release any swap ref after unlocking the bridge. */
@@ -2843,62 +2848,6 @@ int bridge_channel_internal_allows_optim
 		&& AST_LIST_EMPTY(&bridge_channel->wr_queue);
 }
 
-/*!
- * \internal
- * \brief Close a pipe.
- * \since 12.0.0
- *
- * \param my_pipe What to close.
- *
- * \return Nothing
- */
-static void pipe_close(int *my_pipe)
-{
-	if (my_pipe[0] > -1) {
-		close(my_pipe[0]);
-		my_pipe[0] = -1;
-	}
-	if (my_pipe[1] > -1) {
-		close(my_pipe[1]);
-		my_pipe[1] = -1;
-	}
-}
-
-/*!
- * \internal
- * \brief Initialize a pipe as non-blocking.
- * \since 12.0.0
- *
- * \param my_pipe What to initialize.
- *
- * \retval 0 on success.
- * \retval -1 on error.
- */
-static int pipe_init_nonblock(int *my_pipe)
-{
-	int flags;
-
-	my_pipe[0] = -1;
-	my_pipe[1] = -1;
-	if (pipe(my_pipe)) {
-		ast_log(LOG_WARNING, "Can't create pipe! Try increasing max file descriptors with ulimit -n\n");
-		return -1;
-	}
-	flags = fcntl(my_pipe[0], F_GETFL);
-	if (fcntl(my_pipe[0], F_SETFL, flags | O_NONBLOCK) < 0) {
-		ast_log(LOG_WARNING, "Unable to set read pipe nonblocking! (%d: %s)\n",
-			errno, strerror(errno));
-		return -1;
-	}
-	flags = fcntl(my_pipe[1], F_GETFL);
-	if (fcntl(my_pipe[1], F_SETFL, flags | O_NONBLOCK) < 0) {
-		ast_log(LOG_WARNING, "Unable to set write pipe nonblocking! (%d: %s)\n",
-			errno, strerror(errno));
-		return -1;
-	}
-	return 0;
-}
-
 /* Destroy elements of the bridge channel structure and the bridge channel structure itself */
 static void bridge_channel_destroy(void *obj)
 {
@@ -2918,7 +2867,12 @@ static void bridge_channel_destroy(void
 	while ((fr = AST_LIST_REMOVE_HEAD(&bridge_channel->wr_queue, frame_list))) {
 		bridge_frame_free(fr);
 	}
-	pipe_close(bridge_channel->alert_pipe);
+	ast_alertpipe_close(bridge_channel->alert_pipe);
+
+	/* Flush any unhandled deferred_queue frames. */
+	while ((fr = AST_LIST_REMOVE_HEAD(&bridge_channel->deferred_queue, frame_list))) {
+		ast_frfree(fr);
+	}
 
 	ast_cond_destroy(&bridge_channel->cond);
 
@@ -2935,7 +2889,7 @@ struct ast_bridge_channel *bridge_channe
 		return NULL;
 	}
 	ast_cond_init(&bridge_channel->cond, NULL);
-	if (pipe_init_nonblock(bridge_channel->alert_pipe)) {
+	if (ast_alertpipe_init(bridge_channel->alert_pipe)) {
 		ao2_ref(bridge_channel, -1);
 		return NULL;
 	}
diff -urpN asterisk-13.9.1/main/ccss.c asterisk-13.17.0/main/ccss.c
--- asterisk-13.9.1/main/ccss.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/ccss.c	2017-07-12 13:12:08.000000000 +0200
@@ -4572,11 +4572,9 @@ static char *complete_core_id(const char
 
 static char *handle_cc_kill(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	static const char * const option[] = { "core", "all", NULL };
-
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "cc cancel";
+		e->command = "cc cancel [core|all]";
 		e->usage =
 			"Usage: cc cancel can be used in two ways.\n"
 			"       1. 'cc cancel core [core ID]' will cancel the CC transaction with\n"
@@ -4584,10 +4582,7 @@ static char *handle_cc_kill(struct ast_c
 			"       2. 'cc cancel all' will cancel all active CC transactions.\n";
 		return NULL;
 	case CLI_GENERATE:
-		if (a->pos == 2) {
-			return ast_cli_complete(a->word, option, a->n);
-		}
-		if (a->pos == 3) {
+		if (a->pos == 3 && !strcasecmp(a->argv[2], "core")) {
 			return complete_core_id(a->line, a->word, a->pos, a->n);
 		}
 		return NULL;
diff -urpN asterisk-13.9.1/main/cdr.c asterisk-13.17.0/main/cdr.c
--- asterisk-13.9.1/main/cdr.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/cdr.c	2017-07-12 13:12:08.000000000 +0200
@@ -71,6 +71,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/stasis_bridges.h"
 #include "asterisk/stasis_message_router.h"
 #include "asterisk/astobj2.h"
+#include "asterisk/taskprocessor.h"
 
 /*** DOCUMENTATION
 	<configInfo name="cdr" language="en_US">
@@ -694,6 +695,7 @@ struct cdr_object {
 	);
 	struct cdr_object *next;                /*!< The next CDR object in the chain */
 	struct cdr_object *last;                /*!< The last CDR object in the chain */
+	int is_root;                            /*!< True if this is the first CDR in the chain */
 };
 
 /*!
@@ -849,7 +851,22 @@ static void cdr_object_dtor(void *obj)
 	}
 	ast_string_field_free_memory(cdr);
 
-	ao2_cleanup(cdr->next);
+	/* CDR destruction used to work by calling ao2_cleanup(next) and
+	 * allowing the chain to destroy itself neatly. Unfortunately, for
+	 * really long chains, this can result in a stack overflow. So now
+	 * when the root CDR is destroyed, it is responsible for unreffing
+	 * all CDRs in the chain
+	 */
+	if (cdr->is_root) {
+		struct cdr_object *curr = cdr->next;
+		struct cdr_object *next;
+
+		while (curr) {
+			next = curr->next;
+			ao2_cleanup(curr);
+			curr = next;
+		}
+	}
 }
 
 /*!
@@ -2093,6 +2110,7 @@ static void handle_channel_cache_message
 		if (!cdr) {
 			return;
 		}
+		cdr->is_root = 1;
 		ao2_link(active_cdrs_by_channel, cdr);
 	}
 
@@ -3209,7 +3227,7 @@ static int cdr_object_update_party_b_use
 	struct party_b_userfield_update *info = arg;
 	struct cdr_object *it_cdr;
 	for (it_cdr = cdr; it_cdr; it_cdr = it_cdr->next) {
-		if (it_cdr->fn_table == &finalized_state_fn_table) {
+		if (it_cdr->fn_table == &finalized_state_fn_table && it_cdr->next != NULL) {
 			continue;
 		}
 		if (it_cdr->party_b.snapshot
@@ -3233,10 +3251,10 @@ void ast_cdr_setuserfield(const char *ch
 	if (cdr) {
 		ao2_lock(cdr);
 		for (it_cdr = cdr; it_cdr; it_cdr = it_cdr->next) {
-			if (it_cdr->fn_table == &finalized_state_fn_table) {
+			if (it_cdr->fn_table == &finalized_state_fn_table && it_cdr->next != NULL) {
 				continue;
 			}
-			strcpy(it_cdr->party_a.userfield, userfield);
+			ast_copy_string(it_cdr->party_a.userfield, userfield, AST_MAX_USER_FIELD);
 		}
 		ao2_unlock(cdr);
 	}
@@ -4184,6 +4202,8 @@ int ast_cdr_engine_init(void)
 	if (!stasis_router) {
 		return -1;
 	}
+	stasis_message_router_set_congestion_limits(stasis_router, -1,
+		10 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);
 
 	if (STASIS_MESSAGE_TYPE_INIT(cdr_sync_message_type)) {
 		return -1;
diff -urpN asterisk-13.9.1/main/cel.c asterisk-13.17.0/main/cel.c
--- asterisk-13.9.1/main/cel.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/cel.c	2017-07-12 13:12:08.000000000 +0200
@@ -59,6 +59,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/parking.h"
 #include "asterisk/pickup.h"
 #include "asterisk/core_local.h"
+#include "asterisk/taskprocessor.h"
 
 /*** DOCUMENTATION
 	<configInfo name="cel" language="en_US">
@@ -170,6 +171,13 @@ struct cel_linkedid {
 /*! Container of channel references to a linkedid for CEL purposes. */
 static AO2_GLOBAL_OBJ_STATIC(cel_linkedids);
 
+struct cel_dialstatus {
+	/*! Uniqueid of the channel */
+	char uniqueid[AST_MAX_UNIQUEID];
+	/*! The dial status */
+	char dialstatus[0];
+};
+
 /*! \brief Destructor for cel_config */
 static void cel_general_config_dtor(void *obj)
 {
@@ -372,20 +380,10 @@ static int cel_backend_cmp(void *obj, vo
 	return CMP_MATCH;
 }
 
-static const char *get_caller_uniqueid(struct ast_multi_channel_blob *blob)
-{
-	struct ast_channel_snapshot *caller = ast_multi_channel_blob_get_channel(blob, "caller");
-	if (!caller) {
-		return NULL;
-	}
-
-	return caller->uniqueid;
-}
-
 /*! \brief Hashing function for dialstatus container */
 static int dialstatus_hash(const void *obj, int flags)
 {
-	struct ast_multi_channel_blob *blob;
+	const struct cel_dialstatus *dialstatus;
 	const char *key;
 
 	switch (flags & OBJ_SEARCH_MASK) {
@@ -393,8 +391,8 @@ static int dialstatus_hash(const void *o
 		key = obj;
 		break;
 	case OBJ_SEARCH_OBJECT:
-		blob = (void *) obj;
-		key = get_caller_uniqueid(blob);
+		dialstatus = obj;
+		key = dialstatus->uniqueid;
 		break;
 	default:
 		/* Hash can only work on something with a full key. */
@@ -407,24 +405,24 @@ static int dialstatus_hash(const void *o
 /*! \brief Comparator function for dialstatus container */
 static int dialstatus_cmp(void *obj, void *arg, int flags)
 {
-	struct ast_multi_channel_blob *object_left = obj;
-	struct ast_multi_channel_blob *object_right = arg;
+	struct cel_dialstatus *object_left = obj;
+	struct cel_dialstatus *object_right = arg;
 	const char *right_key = arg;
 	int cmp;
 
 	switch (flags & OBJ_SEARCH_MASK) {
 	case OBJ_SEARCH_OBJECT:
-		right_key = get_caller_uniqueid(object_right);
+		right_key = object_right->uniqueid;
 		/* Fall through */
 	case OBJ_SEARCH_KEY:
-		cmp = strcmp(get_caller_uniqueid(object_left), right_key);
+		cmp = strcmp(object_left->uniqueid, right_key);
 		break;
 	case OBJ_SEARCH_PARTIAL_KEY:
 		/*
 		 * We could also use a partial key struct containing a length
 		 * so strlen() does not get called for every comparison instead.
 		 */
-		cmp = strncmp(get_caller_uniqueid(object_left), right_key, strlen(right_key));
+		cmp = strncmp(object_left->uniqueid, right_key, strlen(right_key));
 		break;
 	default:
 		/*
@@ -958,16 +956,16 @@ typedef void (*cel_channel_snapshot_moni
 	struct ast_channel_snapshot *old_snapshot,
 	struct ast_channel_snapshot *new_snapshot);
 
-static struct ast_multi_channel_blob *get_dialstatus_blob(const char *uniqueid)
+static struct cel_dialstatus *get_dialstatus(const char *uniqueid)
 {
 	struct ao2_container *dial_statuses = ao2_global_obj_ref(cel_dialstatus_store);
-	struct ast_multi_channel_blob *blob = NULL;
+	struct cel_dialstatus *dialstatus = NULL;
 
 	if (dial_statuses) {
-		blob = ao2_find(dial_statuses, uniqueid, OBJ_SEARCH_KEY | OBJ_UNLINK);
+		dialstatus = ao2_find(dial_statuses, uniqueid, OBJ_SEARCH_KEY | OBJ_UNLINK);
 		ao2_ref(dial_statuses, -1);
 	}
-	return blob;
+	return dialstatus;
 }
 
 static const char *get_blob_variable(struct ast_multi_channel_blob *blob, const char *varname)
@@ -1010,19 +1008,15 @@ static void cel_channel_state_change(
 
 	if (!was_hungup && is_hungup) {
 		struct ast_json *extra;
-		struct ast_multi_channel_blob *blob = get_dialstatus_blob(new_snapshot->uniqueid);
-		const char *dialstatus = "";
+		struct cel_dialstatus *dialstatus = get_dialstatus(new_snapshot->uniqueid);
 
-		if (blob && !ast_strlen_zero(get_blob_variable(blob, "dialstatus"))) {
-			dialstatus = get_blob_variable(blob, "dialstatus");
-		}
 		extra = ast_json_pack("{s: i, s: s, s: s}",
 			"hangupcause", new_snapshot->hangupcause,
 			"hangupsource", new_snapshot->hangupsource,
-			"dialstatus", dialstatus);
+			"dialstatus", dialstatus ? dialstatus->dialstatus : "");
 		cel_report_event(new_snapshot, AST_CEL_HANGUP, NULL, extra, NULL);
 		ast_json_unref(extra);
-		ao2_cleanup(blob);
+		ao2_cleanup(dialstatus);
 		return;
 	}
 
@@ -1243,10 +1237,10 @@ static void cel_parking_cb(
 
 	if (parked_payload->retriever) {
 		extra = ast_json_pack("{s: s, s: s}",
-			"reason", reason,
+			"reason", reason ?: "",
 			"retriever", parked_payload->retriever->name);
 	} else {
-		extra = ast_json_pack("{s: s}", "reason", reason);
+		extra = ast_json_pack("{s: s}", "reason", reason ?: "");
 	}
 
 	if (extra) {
@@ -1254,16 +1248,48 @@ static void cel_parking_cb(
 	}
 }
 
-static void save_dialstatus(struct ast_multi_channel_blob *blob)
+static void save_dialstatus(struct ast_multi_channel_blob *blob, struct ast_channel_snapshot *snapshot)
 {
 	struct ao2_container *dial_statuses = ao2_global_obj_ref(cel_dialstatus_store);
+	const char *dialstatus_string = get_blob_variable(blob, "dialstatus");
+	struct cel_dialstatus *dialstatus;
+	size_t dialstatus_string_len;
+
+	if (!dial_statuses || ast_strlen_zero(dialstatus_string)) {
+		ao2_cleanup(dial_statuses);
+		return;
+	}
 
-	ast_assert(blob != NULL);
+	dialstatus = ao2_find(dial_statuses, snapshot->uniqueid, OBJ_SEARCH_KEY);
+	if (dialstatus) {
+		if (!strcasecmp(dialstatus_string, "ANSWER") && strcasecmp(dialstatus->dialstatus, "ANSWER")) {
+			/* In the case of an answer after we already have a dial status we give
+			 * priority to the answer since the call was, well, answered. In the case of
+			 * failure dial status results we simply let the first failure be the status.
+			 */
+			ao2_unlink(dial_statuses, dialstatus);
+			ao2_ref(dialstatus, -1);
+		} else {
+			ao2_ref(dialstatus, -1);
+			ao2_ref(dial_statuses, -1);
+			return;
+		}
+	}
 
-	if (dial_statuses) {
-		ao2_link(dial_statuses, blob);
+	dialstatus_string_len = strlen(dialstatus_string) + 1;
+	dialstatus = ao2_alloc_options(sizeof(*dialstatus) + dialstatus_string_len, NULL,
+		AO2_ALLOC_OPT_LOCK_NOLOCK);
+	if (!dialstatus) {
 		ao2_ref(dial_statuses, -1);
+		return;
 	}
+
+	ast_copy_string(dialstatus->uniqueid, snapshot->uniqueid, sizeof(dialstatus->uniqueid));
+	ast_copy_string(dialstatus->dialstatus, dialstatus_string, dialstatus_string_len);
+
+	ao2_link(dial_statuses, dialstatus);
+	ao2_ref(dialstatus, -1);
+	ao2_ref(dial_statuses, -1);
 }
 
 static int is_valid_dialstatus(struct ast_multi_channel_blob *blob)
@@ -1299,32 +1325,25 @@ static void cel_dial_cb(void *data, stru
 	struct stasis_message *message)
 {
 	struct ast_multi_channel_blob *blob = stasis_message_data(message);
+	struct ast_channel_snapshot *snapshot;
 
-	if (cel_filter_channel_snapshot(ast_multi_channel_blob_get_channel(blob, "caller"))) {
-		return;
-	}
-
-	if (!get_caller_uniqueid(blob)) {
+	snapshot = ast_multi_channel_blob_get_channel(blob, "caller");
+	if (!snapshot || cel_filter_channel_snapshot(snapshot)) {
 		return;
 	}
 
 	if (!ast_strlen_zero(get_blob_variable(blob, "forward"))) {
-		struct ast_channel_snapshot *caller = ast_multi_channel_blob_get_channel(blob, "caller");
 		struct ast_json *extra;
 
-		if (!caller) {
-			return;
-		}
-
 		extra = ast_json_pack("{s: s}", "forward", get_blob_variable(blob, "forward"));
 		if (extra) {
-			cel_report_event(caller, AST_CEL_FORWARD, NULL, extra, NULL);
+			cel_report_event(snapshot, AST_CEL_FORWARD, NULL, extra, NULL);
 			ast_json_unref(extra);
 		}
 	}
 
 	if (is_valid_dialstatus(blob)) {
-		save_dialstatus(blob);
+		save_dialstatus(blob, snapshot);
 	}
 }
 
@@ -1575,6 +1594,8 @@ static int create_routes(void)
 	if (!cel_state_router) {
 		return -1;
 	}
+	stasis_message_router_set_congestion_limits(cel_state_router, -1,
+		6 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);
 
 	ret |= stasis_message_router_add(cel_state_router,
 		stasis_cache_update_type(),
diff -urpN asterisk-13.9.1/main/channel.c asterisk-13.17.0/main/channel.c
--- asterisk-13.9.1/main/channel.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/channel.c	2017-07-12 13:12:08.000000000 +0200
@@ -767,6 +767,27 @@ static const struct ast_channel_tech nul
 
 static void ast_channel_destructor(void *obj);
 static void ast_dummy_channel_destructor(void *obj);
+static int ast_channel_by_uniqueid_cb(void *obj, void *arg, void *data, int flags);
+
+static int does_id_conflict(const char *uniqueid)
+{
+	struct ast_channel *conflict;
+	int length = 0;
+
+	if (ast_strlen_zero(uniqueid)) {
+		return 0;
+	}
+
+	conflict = ast_channel_callback(ast_channel_by_uniqueid_cb, (char *) uniqueid, &length, OBJ_NOLOCK);
+	if (conflict) {
+		ast_log(LOG_ERROR, "Channel Unique ID '%s' already in use by channel %s(%p)\n",
+			uniqueid, ast_channel_name(conflict), conflict);
+		ast_channel_unref(conflict);
+		return 1;
+	}
+
+	return 0;
+}
 
 /*! \brief Create a new channel structure */
 static struct ast_channel * attribute_malloc __attribute__((format(printf, 15, 0)))
@@ -799,7 +820,12 @@ __ast_channel_alloc_ap(int needqueue, in
 	ast_channel_stage_snapshot(tmp);
 
 	if (!(nativeformats = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
-		/* format capabilities structure allocation failure */
+		/*
+		 * Aborting the channel creation.  We do not need to complete staging
+		 * the channel snapshot because the channel has not been finalized or
+		 * linked into the channels container yet.  Nobody else knows about
+		 * this channel nor will anybody ever know about it.
+		 */
 		return ast_channel_unref(tmp);
 	}
 	ast_format_cap_append(nativeformats, ast_format_none, 0);
@@ -825,6 +851,7 @@ __ast_channel_alloc_ap(int needqueue, in
 
 	if (!(schedctx = ast_sched_context_create())) {
 		ast_log(LOG_WARNING, "Channel allocation failed: Unable to create schedule context\n");
+		/* See earlier channel creation abort comment above. */
 		return ast_channel_unref(tmp);
 	}
 	ast_channel_sched_set(tmp, schedctx);
@@ -839,6 +866,7 @@ __ast_channel_alloc_ap(int needqueue, in
 		ast_channel_caller(tmp)->id.name.valid = 1;
 		ast_channel_caller(tmp)->id.name.str = ast_strdup(cid_name);
 		if (!ast_channel_caller(tmp)->id.name.str) {
+			/* See earlier channel creation abort comment above. */
 			return ast_channel_unref(tmp);
 		}
 	}
@@ -846,6 +874,7 @@ __ast_channel_alloc_ap(int needqueue, in
 		ast_channel_caller(tmp)->id.number.valid = 1;
 		ast_channel_caller(tmp)->id.number.str = ast_strdup(cid_num);
 		if (!ast_channel_caller(tmp)->id.number.str) {
+			/* See earlier channel creation abort comment above. */
 			return ast_channel_unref(tmp);
 		}
 	}
@@ -859,6 +888,7 @@ __ast_channel_alloc_ap(int needqueue, in
 	}
 
 	if (needqueue && ast_channel_internal_alertpipe_init(tmp)) {
+		/* See earlier channel creation abort comment above. */
 		return ast_channel_unref(tmp);
 	}
 
@@ -940,16 +970,27 @@ __ast_channel_alloc_ap(int needqueue, in
 		ast_channel_tech_set(tmp, &null_tech);
 	}
 
-	ast_channel_internal_finalize(tmp);
-
-	ast_atomic_fetchadd_int(&chancount, +1);
-
 	/* You might scream "locking inversion" at seeing this but it is actually perfectly fine.
 	 * Since the channel was just created nothing can know about it yet or even acquire it.
 	 */
 	ast_channel_lock(tmp);
 
-	ao2_link(channels, tmp);
+	ao2_lock(channels);
+
+	if (assignedids && (does_id_conflict(assignedids->uniqueid) || does_id_conflict(assignedids->uniqueid2))) {
+		ast_channel_internal_errno_set(AST_CHANNEL_ERROR_ID_EXISTS);
+		ao2_unlock(channels);
+		ast_channel_unlock(tmp);
+		/* See earlier channel creation abort comment above. */
+		return ast_channel_unref(tmp);
+	}
+
+	/* Finalize and link into the channels container. */
+	ast_channel_internal_finalize(tmp);
+	ast_atomic_fetchadd_int(&chancount, +1);
+	ao2_link_flags(channels, tmp, OBJ_NOLOCK);
+
+	ao2_unlock(channels);
 
 	if (endpoint) {
 		ast_endpoint_add_channel(endpoint, tmp);
@@ -960,6 +1001,9 @@ __ast_channel_alloc_ap(int needqueue, in
 	 * the world know of its existance
 	 */
 	ast_channel_stage_snapshot_done(tmp);
+
+	ast_debug(1, "Channel %p '%s' allocated\n", tmp, ast_channel_name(tmp));
+
 	return tmp;
 }
 
@@ -1109,6 +1153,9 @@ static int __ast_queue_frame(struct ast_
 				}
 				AST_LIST_REMOVE_CURRENT(frame_list);
 				ast_frfree(cur);
+
+				/* Read from the alert pipe for each flushed frame. */
+				ast_channel_internal_alert_read(chan);
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
@@ -1125,9 +1172,13 @@ static int __ast_queue_frame(struct ast_
 	}
 
 	if (ast_channel_alert_writable(chan)) {
-		if (ast_channel_alert_write(chan)) {
-			ast_log(LOG_WARNING, "Unable to write to alert pipe on %s (qlen = %u): %s!\n",
-				ast_channel_name(chan), queued_frames, strerror(errno));
+		/* Write to the alert pipe for each added frame */
+		while (new_frames--) {
+			if (ast_channel_alert_write(chan)) {
+				ast_log(LOG_WARNING, "Unable to write to alert pipe on %s (qlen = %u): %s!\n",
+					ast_channel_name(chan), queued_frames, strerror(errno));
+				break;
+			}
 		}
 	} else if (ast_channel_timingfd(chan) > -1) {
 		ast_timer_enable_continuous(ast_channel_timer(chan));
@@ -1248,8 +1299,10 @@ int ast_channel_defer_dtmf(struct ast_ch
 	int pre = 0;
 
 	if (chan) {
+		ast_channel_lock(chan);
 		pre = ast_test_flag(ast_channel_flags(chan), AST_FLAG_DEFER_DTMF);
 		ast_set_flag(ast_channel_flags(chan), AST_FLAG_DEFER_DTMF);
+		ast_channel_unlock(chan);
 	}
 	return pre;
 }
@@ -1257,8 +1310,9 @@ int ast_channel_defer_dtmf(struct ast_ch
 /*! \brief Unset defer DTMF flag on channel */
 void ast_channel_undefer_dtmf(struct ast_channel *chan)
 {
-	if (chan)
-		ast_clear_flag(ast_channel_flags(chan), AST_FLAG_DEFER_DTMF);
+	if (chan) {
+		ast_channel_clear_flag(chan, AST_FLAG_DEFER_DTMF);
+	}
 }
 
 struct ast_channel *ast_channel_callback(ao2_callback_data_fn *cb_fn, void *arg,
@@ -2176,6 +2230,8 @@ static void ast_channel_destructor(void
 	char device_name[AST_CHANNEL_NAME];
 	struct ast_callid *callid;
 
+	ast_debug(1, "Channel %p '%s' destroying\n", chan, ast_channel_name(chan));
+
 	/* Stop monitoring */
 	if (ast_channel_monitor(chan)) {
 		ast_channel_monitor(chan)->stop(chan, 0);
@@ -2621,6 +2677,9 @@ void ast_hangup(struct ast_channel *chan
 		return;
 	}
 
+	ast_debug(1, "Channel %p '%s' hanging up.  Refs: %d\n", chan, ast_channel_name(chan),
+		ao2_ref(chan, 0));
+
 	ast_autoservice_stop(chan);
 
 	ast_channel_lock(chan);
@@ -2680,7 +2739,6 @@ void ast_hangup(struct ast_channel *chan
 		ast_assert(ast_test_flag(ast_channel_flags(chan), AST_FLAG_BLOCKING) == 0);
 	}
 
-	ast_debug(1, "Hanging up channel '%s'\n", ast_channel_name(chan));
 	if (ast_channel_tech(chan)->hangup) {
 		ast_channel_tech(chan)->hangup(chan);
 	}
@@ -2692,10 +2750,28 @@ void ast_hangup(struct ast_channel *chan
 	ast_channel_unref(chan);
 }
 
+/*!
+ * \internal
+ * \brief Set channel answered time if not already set.
+ * \since 13.11.0
+ *
+ * \param chan Channel to set answered time.
+ *
+ * \return Nothing
+ */
+static void set_channel_answer_time(struct ast_channel *chan)
+{
+	if (ast_tvzero(ast_channel_answertime(chan))) {
+		struct timeval answertime;
+
+		answertime = ast_tvnow();
+		ast_channel_answertime_set(chan, &answertime);
+	}
+}
+
 int ast_raw_answer(struct ast_channel *chan)
 {
 	int res = 0;
-	struct timeval answertime;
 
 	ast_channel_lock(chan);
 
@@ -2711,8 +2787,11 @@ int ast_raw_answer(struct ast_channel *c
 		return -1;
 	}
 
-	answertime = ast_tvnow();
-	ast_channel_answertime_set(chan, &answertime);
+	/*
+	 * Mark when incoming channel answered so we can know how
+	 * long the channel has been up.
+	 */
+	set_channel_answer_time(chan);
 
 	ast_channel_unlock(chan);
 
@@ -3064,7 +3143,9 @@ struct ast_channel *ast_waitfor_nandfds(
 			fdmap[max].chan = x;  /* channel x is linked to this pfds */
 			max += ast_add_fd(&pfds[max], ast_channel_fd(c[x], y));
 		}
+		ast_channel_lock(c[x]);
 		CHECK_BLOCKING(c[x]);
+		ast_channel_unlock(c[x]);
 	}
 	/* Add the individual fds */
 	for (x = 0; x < nfds; x++) {
@@ -3091,7 +3172,9 @@ struct ast_channel *ast_waitfor_nandfds(
 		res = ast_poll(pfds, max, rms);
 	}
 	for (x = 0; x < n; x++) {
+		ast_channel_lock(c[x]);
 		ast_clear_flag(ast_channel_flags(c[x]), AST_FLAG_BLOCKING);
+		ast_channel_unlock(c[x]);
 	}
 	if (res < 0) { /* Simulate a timeout if we were interrupted */
 		if (errno != EINTR) {
@@ -3127,12 +3210,14 @@ struct ast_channel *ast_waitfor_nandfds(
 		}
 		if (fdmap[x].chan >= 0) {	/* this is a channel */
 			winner = c[fdmap[x].chan];	/* override previous winners */
+			ast_channel_lock(winner);
 			if (res & POLLPRI) {
 				ast_set_flag(ast_channel_flags(winner), AST_FLAG_EXCEPTION);
 			} else {
 				ast_clear_flag(ast_channel_flags(winner), AST_FLAG_EXCEPTION);
 			}
 			ast_channel_fdno_set(winner, fdmap[x].fdno);
+			ast_channel_unlock(winner);
 		} else {			/* this is an fd */
 			if (outfd) {
 				*outfd = pfds[x].fd;
@@ -3443,7 +3528,7 @@ int ast_waitfordigit_full(struct ast_cha
 		return -1;
 
 	/* Only look for the end of DTMF, don't bother with the beginning and don't emulate things */
-	ast_set_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+	ast_channel_set_flag(c, AST_FLAG_END_DTMF_ONLY);
 
 	/* Wait for a digit, no more than timeout_ms milliseconds total.
 	 * Or, wait indefinitely if timeout_ms is <0.
@@ -3462,18 +3547,22 @@ int ast_waitfordigit_full(struct ast_cha
 			if (errno == 0 || errno == EINTR)
 				continue;
 			ast_log(LOG_WARNING, "Wait failed (%s)\n", strerror(errno));
-			ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+			ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 			return -1;
 		} else if (outfd > -1) {
 			/* The FD we were watching has something waiting */
 			ast_log(LOG_WARNING, "The FD we were waiting for has something waiting. Waitfordigit returning numeric 1\n");
-			ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+			ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 			return 1;
 		} else if (rchan) {
 			int res;
 			struct ast_frame *f = ast_read(c);
-			if (!f)
+
+			if (!f) {
+				ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
+
 				return -1;
+			}
 
 			switch (f->frametype) {
 			case AST_FRAME_DTMF_BEGIN:
@@ -3481,13 +3570,13 @@ int ast_waitfordigit_full(struct ast_cha
 			case AST_FRAME_DTMF_END:
 				res = f->subclass.integer;
 				ast_frfree(f);
-				ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+				ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 				return res;
 			case AST_FRAME_CONTROL:
 				switch (f->subclass.integer) {
 				case AST_CONTROL_HANGUP:
 					ast_frfree(f);
-					ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+					ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 					return -1;
 				case AST_CONTROL_STREAM_STOP:
 				case AST_CONTROL_STREAM_SUSPEND:
@@ -3498,7 +3587,7 @@ int ast_waitfordigit_full(struct ast_cha
 					 * that perform stream control will handle this. */
 					res = f->subclass.integer;
 					ast_frfree(f);
-					ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+					ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 					return res;
 				case AST_CONTROL_PVT_CAUSE_CODE:
 				case AST_CONTROL_RINGING:
@@ -3533,7 +3622,7 @@ int ast_waitfordigit_full(struct ast_cha
 		}
 	}
 
-	ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+	ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 
 	return 0; /* Time is up */
 }
@@ -3893,6 +3982,7 @@ static struct ast_frame *__ast_read(stru
 		struct ast_frame *readq_tail = AST_LIST_LAST(ast_channel_readq(chan));
 		struct ast_control_read_action_payload *read_action_payload;
 		struct ast_party_connected_line connected;
+		int hooked = 0;
 
 		/* if the channel driver returned more than one frame, stuff the excess
 		   into the readq for the next ast_read call
@@ -3911,6 +4001,12 @@ static struct ast_frame *__ast_read(stru
 					ast_frfree(f);
 					f = &ast_null_frame;
 				} else {
+					/*
+					 * Mark when outgoing channel answered so we can know how
+					 * long the channel has been up.
+					 */
+					set_channel_answer_time(chan);
+
 					ast_setstate(chan, AST_STATE_UP);
 				}
 			} else if (f->subclass.integer == AST_CONTROL_READ_ACTION) {
@@ -4164,15 +4260,22 @@ static struct ast_frame *__ast_read(stru
 					break;
 				}
 			}
-			/* Send frame to audiohooks if present */
-			if (ast_channel_audiohooks(chan)) {
+			/*
+			 * Send frame to audiohooks if present, if frametype is linear, to preserve
+			 * functional compatibility with previous behavior. If not linear, hold off
+			 * until transcoding is done where we are more likely to have a linear frame
+			 */
+			if (ast_channel_audiohooks(chan) && ast_format_cache_is_slinear(f->subclass.format)) {
+				/* Place hooked after declaration */
 				struct ast_frame *old_frame = f;
+				hooked = 1;
 
 				f = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);
 				if (old_frame != f) {
 					ast_frfree(old_frame);
 				}
 			}
+
 			if (ast_channel_monitor(chan) && ast_channel_monitor(chan)->read_stream) {
 				/* XXX what does this do ? */
 #ifndef MONITOR_CONSTANT_DELAY
@@ -4215,6 +4318,16 @@ static struct ast_frame *__ast_read(stru
 				}
 			}
 
+			/* Second chance at hooking a linear frame, also the last chance */
+			if (ast_channel_audiohooks(chan) && !hooked) {
+				struct ast_frame *old_frame = f;
+
+				f = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_READ, f);
+				if (old_frame != f) {
+					ast_frfree(old_frame);
+				}
+			}
+
 			/*
 			 * It is possible for the translation process on the channel to have
 			 * produced multiple frames from the single input frame we passed it; if
@@ -4224,12 +4337,19 @@ static struct ast_frame *__ast_read(stru
 			 * at the end of the queue.
 			 */
 			if (AST_LIST_NEXT(f, frame_list)) {
+				struct ast_frame *cur, *multi_frame = AST_LIST_NEXT(f, frame_list);
+
+				/* Mark these frames as being re-queued */
+				for (cur = multi_frame; cur; cur = AST_LIST_NEXT(cur, frame_list)) {
+					ast_set_flag(cur, AST_FRFLAG_REQUEUED);
+				}
+
 				if (!readq_tail) {
-					ast_queue_frame_head(chan, AST_LIST_NEXT(f, frame_list));
+					ast_queue_frame_head(chan, multi_frame);
 				} else {
-					__ast_queue_frame(chan, AST_LIST_NEXT(f, frame_list), 0, readq_tail);
+					__ast_queue_frame(chan, multi_frame, 0, readq_tail);
 				}
-				ast_frfree(AST_LIST_NEXT(f, frame_list));
+				ast_frfree(multi_frame);
 				AST_LIST_NEXT(f, frame_list) = NULL;
 			}
 
@@ -4771,16 +4891,18 @@ int ast_sendtext(struct ast_channel *cha
 	if (ast_channel_tech(chan)->write_text && (ast_format_cap_has_type(ast_channel_nativeformats(chan), AST_MEDIA_TYPE_TEXT))) {
 		struct ast_frame f;
 
+		memset(&f, 0, sizeof(f));
 		f.frametype = AST_FRAME_TEXT;
 		f.src = "DIALPLAN";
 		f.mallocd = AST_MALLOCD_DATA;
 		f.datalen = strlen(text);
 		f.data.ptr = ast_strdup(text);
-		f.offset = 0;
-		f.seqno = 0;
-
 		f.subclass.format = ast_format_t140;
-		res = ast_channel_tech(chan)->write_text(chan, &f);
+
+		if (f.data.ptr) {
+			res = ast_channel_tech(chan)->write_text(chan, &f);
+			ast_frfree(&f);
+		}
 	} else if (ast_channel_tech(chan)->send_text) {
 		res = ast_channel_tech(chan)->send_text(chan, text);
 	}
@@ -5005,6 +5127,7 @@ int ast_write(struct ast_channel *chan,
 	int res = -1;
 	struct ast_frame *f = NULL;
 	int count = 0;
+	int hooked = 0;
 
 	/*Deadlock avoidance*/
 	while(ast_channel_trylock(chan)) {
@@ -5122,10 +5245,21 @@ int ast_write(struct ast_channel *chan,
 			apply_plc(chan, fr);
 		}
 
+		f = fr;
+
+		/*
+		 * Send frame to audiohooks if present, if frametype is linear (else, later as per
+		 * previous behavior)
+		 */
+		if (ast_channel_audiohooks(chan)) {
+			if (ast_format_cache_is_slinear(fr->subclass.format)) {
+				hooked = 1;
+				f = ast_audiohook_write_list(chan, ast_channel_audiohooks(chan), AST_AUDIOHOOK_DIRECTION_WRITE, fr);
+			}
+		}
+
 		/* If the frame is in the raw write format, then it's easy... just use the frame - otherwise we will have to translate */
-		if (ast_format_cmp(fr->subclass.format, ast_channel_rawwriteformat(chan)) == AST_FORMAT_CMP_EQUAL) {
-			f = fr;
-		} else {
+		if (ast_format_cmp(fr->subclass.format, ast_channel_rawwriteformat(chan)) != AST_FORMAT_CMP_EQUAL) {
 			if (ast_format_cmp(ast_channel_writeformat(chan), fr->subclass.format) != AST_FORMAT_CMP_EQUAL) {
 				struct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
 
@@ -5151,7 +5285,20 @@ int ast_write(struct ast_channel *chan,
 					break;
 				}
 			}
-			f = ast_channel_writetrans(chan) ? ast_translate(ast_channel_writetrans(chan), fr, 0) : fr;
+
+			if (ast_channel_writetrans(chan)) {
+				struct ast_frame *trans_frame = ast_translate(ast_channel_writetrans(chan), f, 0);
+
+				if (trans_frame != f && f != fr) {
+					/*
+					 * If translate gives us a new frame and so did the audio
+					 * hook then we need to free the one from the audio hook.
+					 */
+					ast_frfree(f);
+				}
+				f = trans_frame;
+			}
+
 		}
 
 		if (!f) {
@@ -5159,7 +5306,7 @@ int ast_write(struct ast_channel *chan,
 			break;
 		}
 
-		if (ast_channel_audiohooks(chan)) {
+		if (ast_channel_audiohooks(chan) && !hooked) {
 			struct ast_frame *prev = NULL, *new_frame, *cur, *dup;
 			int freeoldlist = 0;
 
@@ -5347,6 +5494,42 @@ int ast_set_read_format_path(struct ast_
 	return 0;
 }
 
+int ast_set_write_format_path(struct ast_channel *chan, struct ast_format *core_format, struct ast_format *raw_format)
+{
+	struct ast_trans_pvt *trans_old;
+	struct ast_trans_pvt *trans_new;
+
+	if (ast_format_cmp(ast_channel_rawwriteformat(chan), raw_format) == AST_FORMAT_CMP_EQUAL
+		&& ast_format_cmp(ast_channel_writeformat(chan), core_format) == AST_FORMAT_CMP_EQUAL) {
+		/* Nothing to setup */
+		return 0;
+	}
+
+	ast_debug(1, "Channel %s setting write format path: %s -> %s\n",
+		ast_channel_name(chan),
+		ast_format_get_name(core_format),
+		ast_format_get_name(raw_format));
+
+	/* Setup new translation path. */
+	if (ast_format_cmp(raw_format, core_format) != AST_FORMAT_CMP_EQUAL) {
+		trans_new = ast_translator_build_path(raw_format, core_format);
+		if (!trans_new) {
+			return -1;
+		}
+	} else {
+		/* No translation needed. */
+		trans_new = NULL;
+	}
+	trans_old = ast_channel_writetrans(chan);
+	if (trans_old) {
+		ast_translator_free_path(trans_old);
+	}
+	ast_channel_writetrans_set(chan, trans_new);
+	ast_channel_set_rawwriteformat(chan, raw_format);
+	ast_channel_set_writeformat(chan, core_format);
+	return 0;
+}
+
 struct set_format_access {
 	const char *direction;
 	struct ast_trans_pvt *(*get_trans)(const struct ast_channel *chan);
@@ -5663,6 +5846,7 @@ static void call_forward_inherit(struct
 struct ast_channel *ast_call_forward(struct ast_channel *caller, struct ast_channel *orig, int *timeout, struct ast_format_cap *cap, struct outgoing_helper *oh, int *outstate)
 {
 	char tmpchan[256];
+	char forwarder[AST_CHANNEL_NAME];
 	struct ast_channel *new_chan = NULL;
 	char *data, *type;
 	int cause = 0;
@@ -5670,6 +5854,7 @@ struct ast_channel *ast_call_forward(str
 
 	/* gather data and request the new forward channel */
 	ast_copy_string(tmpchan, ast_channel_call_forward(orig), sizeof(tmpchan));
+	ast_copy_string(forwarder, ast_channel_name(orig), sizeof(forwarder));
 	if ((data = strchr(tmpchan, '/'))) {
 		*data++ = '\0';
 		type = tmpchan;
@@ -5710,9 +5895,10 @@ struct ast_channel *ast_call_forward(str
 	} else if (caller) { /* no outgoing helper so use caller if available */
 		call_forward_inherit(new_chan, caller, orig);
 	}
-	ast_set_flag(ast_channel_flags(new_chan), AST_FLAG_ORIGINATED);
 
 	ast_channel_lock_both(orig, new_chan);
+	ast_channel_set_flag(new_chan, AST_FLAG_ORIGINATED);
+	pbx_builtin_setvar_helper(new_chan, "FORWARDERNAME", forwarder);
 	ast_party_connected_line_copy(ast_channel_connected(new_chan), ast_channel_connected(orig));
 	ast_party_redirecting_copy(ast_channel_redirecting(new_chan), ast_channel_redirecting(orig));
 	ast_channel_req_accountcodes(new_chan, orig, AST_CHANNEL_REQUESTOR_REPLACEMENT);
@@ -6064,7 +6250,7 @@ struct ast_channel *ast_request(const ch
 
 		if (set_security_requirements(requestor, c)) {
 			ast_log(LOG_WARNING, "Setting security requirements failed\n");
-			c = ast_channel_release(c);
+			ast_hangup(c);
 			*cause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;
 			return NULL;
 		}
@@ -7773,13 +7959,14 @@ static void channels_shutdown(void)
 	ast_channel_unregister(&surrogate_tech);
 }
 
-void ast_channels_init(void)
+int ast_channels_init(void)
 {
 	channels = ao2_container_alloc(NUM_CHANNEL_BUCKETS,
 			ast_channel_hash_cb, ast_channel_cmp_cb);
-	if (channels) {
-		ao2_container_register("channels", channels, prnt_channel_key);
+	if (!channels) {
+		return -1;
 	}
+	ao2_container_register("channels", channels, prnt_channel_key);
 
 	ast_channel_register(&surrogate_tech);
 
@@ -7793,6 +7980,7 @@ void ast_channels_init(void)
 
 	ast_register_cleanup(channels_shutdown);
 
+	return 0;
 }
 
 /*! \brief Print call group and pickup group ---*/
@@ -9023,7 +9211,7 @@ static int redirecting_reason_build_data
 
 	if (reason->str) {
 		length = strlen(reason->str);
-		if (datalen < pos + sizeof(data[0] * 2) + length) {
+		if (datalen < pos + (sizeof(data[0]) * 2) + length) {
 			ast_log(LOG_WARNING, "No space left for %s string\n", label);
 			return -1;
 		}
@@ -10078,6 +10266,36 @@ void ast_channel_queue_redirecting_updat
 	ast_queue_control_data(chan, AST_CONTROL_REDIRECTING, data, datalen);
 }
 
+/*!
+ * Storage to determine if the current thread is running an intercept dialplan routine.
+ */
+AST_THREADSTORAGE_RAW(in_intercept_routine);
+
+/*!
+ * \internal
+ * \brief Set the current intercept dialplan routine status mode.
+ * \since 13.14.0
+ *
+ * \param in_intercept_mode New intercept mode.  (Non-zero if in intercept mode)
+ *
+ * \return Nothing
+ */
+static void channel_set_intercept_mode(int in_intercept_mode)
+{
+	int status;
+
+	status = ast_threadstorage_set_ptr(&in_intercept_routine,
+		in_intercept_mode ? (void *) 1 : (void *) 0);
+	if (status) {
+		ast_log(LOG_ERROR, "Failed to set dialplan intercept mode\n");
+	}
+}
+
+int ast_channel_get_intercept_mode(void)
+{
+	return ast_threadstorage_get_ptr(&in_intercept_routine) ? 1 : 0;
+}
+
 int ast_channel_connected_line_macro(struct ast_channel *autoservice_chan, struct ast_channel *macro_chan, const void *connected_info, int is_caller, int is_frame)
 {
 	static int deprecation_warning = 0;
@@ -10113,7 +10331,9 @@ int ast_channel_connected_line_macro(str
 	}
 	ast_channel_unlock(macro_chan);
 
+	channel_set_intercept_mode(1);
 	retval = ast_app_run_macro(autoservice_chan, macro_chan, macro, macro_args);
+	channel_set_intercept_mode(0);
 	if (!retval) {
 		struct ast_party_connected_line saved_connected;
 
@@ -10163,7 +10383,9 @@ int ast_channel_redirecting_macro(struct
 	}
 	ast_channel_unlock(macro_chan);
 
+	channel_set_intercept_mode(1);
 	retval = ast_app_run_macro(autoservice_chan, macro_chan, macro, macro_args);
+	channel_set_intercept_mode(0);
 	if (!retval) {
 		struct ast_party_redirecting saved_redirecting;
 
@@ -10206,7 +10428,9 @@ int ast_channel_connected_line_sub(struc
 	}
 	ast_channel_unlock(sub_chan);
 
+	channel_set_intercept_mode(1);
 	retval = ast_app_run_sub(autoservice_chan, sub_chan, sub, sub_args, 0);
+	channel_set_intercept_mode(0);
 	if (!retval) {
 		struct ast_party_connected_line saved_connected;
 
@@ -10249,7 +10473,9 @@ int ast_channel_redirecting_sub(struct a
 	}
 	ast_channel_unlock(sub_chan);
 
+	channel_set_intercept_mode(1);
 	retval = ast_app_run_sub(autoservice_chan, sub_chan, sub, sub_args, 0);
+	channel_set_intercept_mode(0);
 	if (!retval) {
 		struct ast_party_redirecting saved_redirecting;
 
@@ -10438,6 +10664,7 @@ struct ast_channel *ast_channel_yank(str
 		char *context;
 		char *name;
 		int amaflags;
+		int priority;
 		struct ast_format *readformat;
 		struct ast_format *writeformat;
 	} my_vars = { 0, };
@@ -10448,6 +10675,16 @@ struct ast_channel *ast_channel_yank(str
 	my_vars.context = ast_strdupa(ast_channel_context(yankee));
 	my_vars.name = ast_strdupa(ast_channel_name(yankee));
 	my_vars.amaflags = ast_channel_amaflags(yankee);
+	my_vars.priority = ast_channel_priority(yankee);
+	/* The priority as returned by ast_channel_yank is where the channel
+	 * should go if the dialplan is executed on it. If the channel is
+	 * already executing dialplan then the priority currently set is
+	 * where it is currently. We increment it so it becomes where it should
+	 * execute.
+	 */
+	if (ast_test_flag(ast_channel_flags(yankee), AST_FLAG_IN_AUTOLOOP)) {
+		my_vars.priority++;
+	}
 	my_vars.writeformat = ao2_bump(ast_channel_writeformat(yankee));
 	my_vars.readformat = ao2_bump(ast_channel_readformat(yankee));
 	ast_channel_unlock(yankee);
@@ -10467,6 +10704,7 @@ struct ast_channel *ast_channel_yank(str
 	ast_channel_set_writeformat(yanked_chan, my_vars.writeformat);
 	ao2_cleanup(my_vars.readformat);
 	ao2_cleanup(my_vars.writeformat);
+	ast_channel_priority_set(yanked_chan, my_vars.priority);
 
 	ast_channel_unlock(yanked_chan);
 
@@ -10595,7 +10833,7 @@ static const struct ast_datastore_info *
 
 int ast_channel_suppress(struct ast_channel *chan, unsigned int direction, enum ast_frame_type frametype)
 {
-	RAII_VAR(struct suppress_data *, suppress, NULL, ao2_cleanup);
+	struct suppress_data *suppress;
 	const struct ast_datastore_info *datastore_info = NULL;
 	struct ast_datastore *datastore = NULL;
 	struct ast_framehook_interface interface = {
@@ -10631,6 +10869,7 @@ int ast_channel_suppress(struct ast_chan
 	if (framehook_id < 0) {
 		/* Hook attach failed.  Get rid of the evidence. */
 		ast_log(LOG_WARNING, "Failed to attach framehook while attempting to suppress a stream.\n");
+		ao2_ref(suppress, -1);
 		return -1;
 	}
 
@@ -10642,11 +10881,11 @@ int ast_channel_suppress(struct ast_chan
 	if (!(datastore = ast_datastore_alloc(datastore_info, NULL))) {
 		ast_log(LOG_WARNING, "Failed to allocate datastore while attempting to suppress a stream.\n");
 		ast_framehook_detach(chan, framehook_id);
+		ao2_ref(suppress, -1);
 		return -1;
 	}
 
-	/* and another ref for the datastore */
-	ao2_ref(suppress, +1);
+	/* the ref provided by the allocation is taken by the datastore */
 	datastore->data = suppress;
 
 	ast_channel_datastore_add(chan, datastore);
@@ -10775,3 +11014,23 @@ int ast_channel_feature_hooks_replace(st
 {
 	return channel_feature_hooks_set_full(chan, features, 1);
 }
+
+enum ast_channel_error ast_channel_errno(void)
+{
+	return ast_channel_internal_errno();
+}
+
+void ast_channel_set_flag(struct ast_channel *chan, unsigned int flag)
+{
+	ast_channel_lock(chan);
+	ast_set_flag(ast_channel_flags(chan), flag);
+	ast_channel_unlock(chan);
+}
+
+void ast_channel_clear_flag(struct ast_channel *chan, unsigned int flag)
+{
+	ast_channel_lock(chan);
+	ast_clear_flag(ast_channel_flags(chan), flag);
+	ast_channel_unlock(chan);
+}
+
diff -urpN asterisk-13.9.1/main/channel_internal_api.c asterisk-13.17.0/main/channel_internal_api.c
--- asterisk-13.9.1/main/channel_internal_api.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/channel_internal_api.c	2017-07-12 13:12:08.000000000 +0200
@@ -38,6 +38,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include <unistd.h>
 #include <fcntl.h>
 
+#include "asterisk/alertpipe.h"
 #include "asterisk/paths.h"
 #include "asterisk/channel.h"
 #include "asterisk/channel_internal.h"
@@ -1237,104 +1238,52 @@ void ast_channel_named_pickupgroups_set(
 /* Alertpipe functions */
 int ast_channel_alert_write(struct ast_channel *chan)
 {
-	char blah = 0x7F;
+	return ast_alertpipe_write(chan->alertpipe);
+}
 
-	if (!ast_channel_alert_writable(chan)) {
-		errno = EBADF;
-		return 0;
-	}
-	/* preset errno in case returned size does not match */
-	errno = EPIPE;
-	return write(chan->alertpipe[1], &blah, sizeof(blah)) != sizeof(blah);
+ast_alert_status_t ast_channel_internal_alert_flush(struct ast_channel *chan)
+{
+	return ast_alertpipe_flush(chan->alertpipe);
 }
 
 ast_alert_status_t ast_channel_internal_alert_read(struct ast_channel *chan)
 {
-	int flags;
-	char blah;
-
-	if (!ast_channel_internal_alert_readable(chan)) {
-		return AST_ALERT_NOT_READABLE;
-	}
-
-	flags = fcntl(chan->alertpipe[0], F_GETFL);
-	/* For some odd reason, the alertpipe occasionally loses nonblocking status,
-	 * which immediately causes a deadlock scenario.  Detect and prevent this. */
-	if ((flags & O_NONBLOCK) == 0) {
-		ast_log(LOG_ERROR, "Alertpipe on channel %s lost O_NONBLOCK?!!\n", ast_channel_name(chan));
-		if (fcntl(chan->alertpipe[0], F_SETFL, flags | O_NONBLOCK) < 0) {
-			ast_log(LOG_WARNING, "Unable to set alertpipe nonblocking! (%d: %s)\n", errno, strerror(errno));
-			return AST_ALERT_READ_FATAL;
-		}
-	}
-	if (read(chan->alertpipe[0], &blah, sizeof(blah)) < 0) {
-		if (errno != EINTR && errno != EAGAIN) {
-			ast_log(LOG_WARNING, "read() failed: %s\n", strerror(errno));
-			return AST_ALERT_READ_FAIL;
-		}
-	}
-
-	return AST_ALERT_READ_SUCCESS;
+	return ast_alertpipe_read(chan->alertpipe);
 }
 
 int ast_channel_alert_writable(struct ast_channel *chan)
 {
-	return chan->alertpipe[1] > -1;
+	return ast_alertpipe_writable(chan->alertpipe);
 }
 
 int ast_channel_internal_alert_readable(struct ast_channel *chan)
 {
-	return chan->alertpipe[0] > -1;
+	return ast_alertpipe_readable(chan->alertpipe);
 }
 
 void ast_channel_internal_alertpipe_clear(struct ast_channel *chan)
 {
-	chan->alertpipe[0] = chan->alertpipe[1] = -1;
+	ast_alertpipe_clear(chan->alertpipe);
 }
 
 void ast_channel_internal_alertpipe_close(struct ast_channel *chan)
 {
-	if (ast_channel_internal_alert_readable(chan)) {
-		close(chan->alertpipe[0]);
-		chan->alertpipe[0] = -1;
-	}
-	if (ast_channel_alert_writable(chan)) {
-		close(chan->alertpipe[1]);
-		chan->alertpipe[1] = -1;
-	}
+	ast_alertpipe_close(chan->alertpipe);
 }
 
 int ast_channel_internal_alertpipe_init(struct ast_channel *chan)
 {
-	if (pipe(chan->alertpipe)) {
-		ast_log(LOG_WARNING, "Channel allocation failed: Can't create alert pipe! Try increasing max file descriptors with ulimit -n\n");
-		return -1;
-	} else {
-		int flags = fcntl(chan->alertpipe[0], F_GETFL);
-		if (fcntl(chan->alertpipe[0], F_SETFL, flags | O_NONBLOCK) < 0) {
-			ast_log(LOG_WARNING, "Channel allocation failed: Unable to set alertpipe nonblocking! (%d: %s)\n", errno, strerror(errno));
-			return -1;
-		}
-		flags = fcntl(chan->alertpipe[1], F_GETFL);
-		if (fcntl(chan->alertpipe[1], F_SETFL, flags | O_NONBLOCK) < 0) {
-			ast_log(LOG_WARNING, "Channel allocation failed: Unable to set alertpipe nonblocking! (%d: %s)\n", errno, strerror(errno));
-			return -1;
-		}
-	}
-	return 0;
+	return ast_alertpipe_init(chan->alertpipe);
 }
 
 int ast_channel_internal_alert_readfd(struct ast_channel *chan)
 {
-	return chan->alertpipe[0];
+	return ast_alertpipe_readfd(chan->alertpipe);
 }
 
 void ast_channel_internal_alertpipe_swap(struct ast_channel *chan1, struct ast_channel *chan2)
 {
-	int i;
-	for (i = 0; i < ARRAY_LEN(chan1->alertpipe); i++) {
-		SWAP(chan1->alertpipe[i], chan2->alertpipe[i]);
-	}
+	ast_alertpipe_swap(chan1->alertpipe, chan2->alertpipe);
 }
 
 /* file descriptor array accessors */
@@ -1484,6 +1433,7 @@ static int pvt_cause_cmp_fn(void *obj, v
 struct ast_channel *__ast_channel_internal_alloc(void (*destructor)(void *obj), const struct ast_assigned_ids *assignedids, const struct ast_channel *requestor, const char *file, int line, const char *function)
 {
 	struct ast_channel *tmp;
+
 #if defined(REF_DEBUG)
 	tmp = __ao2_alloc_debug(sizeof(*tmp), destructor,
 		AO2_ALLOC_OPT_LOCK_MUTEX, "", file, line, function, 1);
@@ -1675,3 +1625,25 @@ int ast_channel_internal_setup_topics(st
 
 	return 0;
 }
+
+AST_THREADSTORAGE(channel_errno);
+
+void ast_channel_internal_errno_set(enum ast_channel_error error)
+{
+	enum ast_channel_error *error_code = ast_threadstorage_get(&channel_errno, sizeof(*error_code));
+	if (!error_code) {
+		return;
+	}
+
+	*error_code = error;
+}
+
+enum ast_channel_error ast_channel_internal_errno(void)
+{
+	enum ast_channel_error *error_code = ast_threadstorage_get(&channel_errno, sizeof(*error_code));
+	if (!error_code) {
+		return AST_CHANNEL_ERROR_UNKNOWN;
+	}
+
+	return *error_code;
+}
diff -urpN asterisk-13.9.1/main/chanvars.c asterisk-13.17.0/main/chanvars.c
--- asterisk-13.9.1/main/chanvars.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/chanvars.c	2017-07-12 13:12:08.000000000 +0200
@@ -35,7 +35,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/strings.h"
 #include "asterisk/utils.h"
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 struct ast_var_t *_ast_var_assign(const char *name, const char *value, const char *file, int lineno, const char *function)
 #else
 struct ast_var_t *ast_var_assign(const char *name, const char *value)
@@ -45,7 +45,7 @@ struct ast_var_t *ast_var_assign(const c
 	int name_len = strlen(name) + 1;
 	int value_len = strlen(value) + 1;
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 	if (!(var = __ast_calloc(sizeof(*var) + name_len + value_len, sizeof(char), file, lineno, function))) {
 #else
 	if (!(var = ast_calloc(sizeof(*var) + name_len + value_len, sizeof(char)))) {
diff -urpN asterisk-13.9.1/main/cli.c asterisk-13.17.0/main/cli.c
--- asterisk-13.9.1/main/cli.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/cli.c	2017-07-12 13:12:08.000000000 +0200
@@ -450,19 +450,11 @@ static char *handle_debug(struct ast_cli
 	case CLI_INIT:
 		e->command = "core set debug";
 		e->usage =
-#if !defined(LOW_MEMORY)
 			"Usage: core set debug [atleast] <level> [module]\n"
-#else
-			"Usage: core set debug [atleast] <level>\n"
-#endif
 			"       core set debug off\n"
 			"\n"
-#if !defined(LOW_MEMORY)
 			"       Sets level of debug messages to be displayed or\n"
 			"       sets a module name to display debug messages from.\n"
-#else
-			"       Sets level of debug messages to be displayed.\n"
-#endif
 			"       0 or off means no messages should be displayed.\n"
 			"       Equivalent to -d[d[...]] on startup\n";
 		return NULL;
@@ -490,13 +482,9 @@ static char *handle_debug(struct ast_cli
 			} else if (a->n == (22 - numbermatch) && a->pos == 3 && ast_strlen_zero(argv3)) {
 				return ast_strdup("atleast");
 			}
-#if !defined(LOW_MEMORY)
 		} else if ((a->pos == 4 && !atleast && strcasecmp(argv3, "off") && strcasecmp(argv3, "channel"))
 			|| (a->pos == 5 && atleast)) {
-			const char *pos = S_OR(a->argv[a->pos], "");
-
-			return ast_complete_source_filename(pos, a->n);
-#endif
+			return ast_module_helper(a->line, a->word, a->pos, a->n, a->pos, 0);
 		}
 		return NULL;
 	}
@@ -929,6 +917,7 @@ static char *handle_modlist(struct ast_c
 
 static char *handle_showcalls(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
+	static const char * const completions[] = { "seconds", NULL };
 	struct timeval curtime = ast_tvnow();
 	int showuptime, printsec;
 
@@ -936,7 +925,7 @@ static char *handle_showcalls(struct ast
 	case CLI_INIT:
 		e->command = "core show calls [uptime]";
 		e->usage =
-			"Usage: core show calls [uptime] [seconds]\n"
+			"Usage: core show calls [uptime [seconds]]\n"
 			"       Lists number of currently active calls and total number of calls\n"
 			"       processed through PBX since last restart. If 'uptime' is specified\n"
 			"       the system uptime is also displayed. If 'seconds' is specified in\n"
@@ -946,7 +935,7 @@ static char *handle_showcalls(struct ast
 	case CLI_GENERATE:
 		if (a->pos != e->args)
 			return NULL;
-		return a->n == 0  ? ast_strdup("seconds") : NULL;
+		return ast_cli_complete(a->word, completions, a->n);
 	}
 
 	/* regular handler */
@@ -1116,7 +1105,9 @@ static char *handle_chanlist(struct ast_
 
 static char *handle_softhangup(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	struct ast_channel *c=NULL;
+	struct ast_channel *c = NULL;
+	static const char * const completions[] = { "all", NULL };
+	char *complete;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1129,7 +1120,14 @@ static char *handle_softhangup(struct as
 			"       will see the hangup request.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return ast_complete_channels(a->line, a->word, a->pos, a->n, e->args);
+		if (a->pos != e->args) {
+			return NULL;
+		}
+		complete = ast_cli_complete(a->word, completions, a->n);
+		if (!complete) {
+			complete = ast_complete_channels(a->line, a->word, a->pos, a->n - 1, e->args);
+		}
+		return complete;
 	}
 
 	if (a->argc != 4) {
@@ -1441,6 +1439,8 @@ static int channel_set_debug(void *obj,
 static char *handle_core_set_debug_channel(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct ast_channel *c = NULL;
+	static const char * const completions_all[] = { "all", NULL };
+	static const char * const completions_off[] = { "off", NULL };
 	struct channel_set_debug_args args = {
 		.fd = a->fd,
 	};
@@ -1453,10 +1453,15 @@ static char *handle_core_set_debug_chann
 			"       Enables/disables debugging on all or on a specific channel.\n";
 		return NULL;
 	case CLI_GENERATE:
-		/* XXX remember to handle the optional "off" */
-		if (a->pos != e->args)
-			return NULL;
-		return a->n == 0 ? ast_strdup("all") : ast_complete_channels(a->line, a->word, a->pos, a->n - 1, e->args);
+		if (a->pos == 4) {
+			char *complete = ast_cli_complete(a->word, completions_all, a->n);
+			if (!complete) {
+				complete = ast_complete_channels(a->line, a->word, a->pos, a->n - 1, e->args);
+			}
+			return complete;
+		} else if (a->pos == 5) {
+			return ast_cli_complete(a->word, completions_off, a->n);
+		}
 	}
 
 	if (cmd == (CLI_HANDLER + 1000)) {
diff -urpN asterisk-13.9.1/main/codec.c asterisk-13.17.0/main/codec.c
--- asterisk-13.9.1/main/codec.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/codec.c	2017-07-12 13:12:08.000000000 +0200
@@ -49,6 +49,32 @@ static int codec_id = 1;
 /*! \brief Registered codecs */
 static struct ao2_container *codecs;
 
+/*!
+ * \internal
+ * \brief Internal codec structure
+ *
+ * External codecs won't know about the format_name field so the public
+ * ast_codec structure has to leave it out.  This structure will be used
+ * for the internal codecs.
+ *
+ */
+struct internal_ast_codec {
+	/*! \brief Public codec structure.  Must remain first. */
+	struct ast_codec external;
+	/*! \brief A format name for a default sane format using this codec */
+	const char *format_name;
+};
+
+/*!
+ * \internal
+ * \brief Internal function for registration with format name
+ *
+ * This function is only used by codec.c and codec_builtin.c and
+ * will be removed in Asterisk 14
+ */
+int __ast_codec_register_with_format(struct ast_codec *codec, const char *format_name,
+	struct ast_module *mod);
+
 static int codec_hash(const void *obj, int flags)
 {
 	const struct ast_codec *codec;
@@ -113,7 +139,7 @@ static int codec_cmp(void *obj, void *ar
 static char *show_codecs(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct ao2_iterator i;
-	struct ast_codec *codec;
+	struct internal_ast_codec *codec;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -135,8 +161,8 @@ static char *show_codecs(struct ast_cli_
 				"\tIt does not indicate anything about your configuration.\n");
 	}
 
-	ast_cli(a->fd, "%8s %5s %8s %s\n","ID","TYPE","NAME","DESCRIPTION");
-	ast_cli(a->fd, "-----------------------------------------------------------------------------------\n");
+	ast_cli(a->fd, "%8s %-5s %-12s %-16s %s\n","ID","TYPE","NAME","FORMAT","DESCRIPTION");
+	ast_cli(a->fd, "------------------------------------------------------------------------------------------------\n");
 
 	ao2_rdlock(codecs);
 	i = ao2_iterator_init(codecs, AO2_ITERATOR_DONTLOCK);
@@ -144,19 +170,19 @@ static char *show_codecs(struct ast_cli_
 	for (; (codec = ao2_iterator_next(&i)); ao2_ref(codec, -1)) {
 		if (a->argc == 4) {
 			if (!strcasecmp(a->argv[3], "audio")) {
-				if (codec->type != AST_MEDIA_TYPE_AUDIO) {
+				if (codec->external.type != AST_MEDIA_TYPE_AUDIO) {
 					continue;
 				}
 			} else if (!strcasecmp(a->argv[3], "video")) {
-				if (codec->type != AST_MEDIA_TYPE_VIDEO) {
+				if (codec->external.type != AST_MEDIA_TYPE_VIDEO) {
 					continue;
 				}
 			} else if (!strcasecmp(a->argv[3], "image")) {
-				if (codec->type != AST_MEDIA_TYPE_IMAGE) {
+				if (codec->external.type != AST_MEDIA_TYPE_IMAGE) {
 					continue;
 				}
 			} else if (!strcasecmp(a->argv[3], "text")) {
-				if (codec->type != AST_MEDIA_TYPE_TEXT) {
+				if (codec->external.type != AST_MEDIA_TYPE_TEXT) {
 					continue;
 				}
 			} else {
@@ -164,11 +190,12 @@ static char *show_codecs(struct ast_cli_
 			}
 		}
 
-		ast_cli(a->fd, "%8u %5s %8s (%s)\n",
-			codec->id,
-			ast_codec_media_type2str(codec->type),
-			codec->name,
-			codec->description);
+		ast_cli(a->fd, "%8u %-5s %-12s %-16s (%s)\n",
+			codec->external.id,
+			ast_codec_media_type2str(codec->external.type),
+			codec->external.name,
+			S_OR(codec->format_name, "no cached format"),
+			codec->external.description);
 	}
 
 	ao2_iterator_destroy(&i);
@@ -189,7 +216,7 @@ static int codec_id_cmp(void *obj, void
 static char *show_codec(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	int type_punned_codec;
-	struct ast_codec *codec;
+	struct internal_ast_codec *codec;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -216,7 +243,8 @@ static char *show_codec(struct ast_cli_e
 		return CLI_SUCCESS;
 	}
 
-	ast_cli(a->fd, "%11u %s\n", (unsigned int) codec->id, codec->description);
+	ast_cli(a->fd, "%11u %s (%s)\n", (unsigned int) codec->external.id, codec->external.description,
+		S_OR(codec->format_name, "no format"));
 
 	ao2_ref(codec, -1);
 
@@ -261,8 +289,13 @@ static void codec_dtor(void *obj)
 
 int __ast_codec_register(struct ast_codec *codec, struct ast_module *mod)
 {
+	return __ast_codec_register_with_format(codec, NULL, mod);
+}
+
+int __ast_codec_register_with_format(struct ast_codec *codec, const char *format_name, struct ast_module *mod)
+{
 	SCOPED_AO2WRLOCK(lock, codecs);
-	struct ast_codec *codec_new;
+	struct internal_ast_codec *codec_new;
 
 	/* Some types have specific requirements */
 	if (codec->type == AST_MEDIA_TYPE_UNKNOWN) {
@@ -291,8 +324,9 @@ int __ast_codec_register(struct ast_code
 			codec->name, ast_codec_media_type2str(codec->type), codec->sample_rate);
 		return -1;
 	}
-	*codec_new = *codec;
-	codec_new->id = codec_id++;
+	codec_new->external = *codec;
+	codec_new->format_name = format_name;
+	codec_new->external.id = codec_id++;
 
 	ao2_link_flags(codecs, codec_new, OBJ_NOLOCK);
 
@@ -300,7 +334,7 @@ int __ast_codec_register(struct ast_code
 	ast_module_shutdown_ref(mod);
 
 	ast_verb(2, "Registered '%s' codec '%s' at sample rate '%u' with id '%u'\n",
-		ast_codec_media_type2str(codec->type), codec->name, codec->sample_rate, codec_new->id);
+		ast_codec_media_type2str(codec->type), codec->name, codec->sample_rate, codec_new->external.id);
 
 	ao2_ref(codec_new, -1);
 
diff -urpN asterisk-13.9.1/main/codec_builtin.c asterisk-13.17.0/main/codec_builtin.c
--- asterisk-13.9.1/main/codec_builtin.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/codec_builtin.c	2017-07-12 13:12:08.000000000 +0200
@@ -37,6 +37,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/format.h"
 #include "asterisk/format_cache.h"
 #include "asterisk/frame.h"
+#include "asterisk/smoother.h"
+
+int __ast_codec_register_with_format(struct ast_codec *codec, const char *format_name,
+	struct ast_module *mod);
 
 enum frame_type {
 	TYPE_HIGH,     /* 0x0 */
@@ -261,7 +265,7 @@ static struct ast_codec slin8 = {
 	.minimum_bytes = 160,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin12 = {
@@ -275,7 +279,7 @@ static struct ast_codec slin12 = {
 	.minimum_bytes = 240,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin16 = {
@@ -289,7 +293,7 @@ static struct ast_codec slin16 = {
 	.minimum_bytes = 320,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin24 = {
@@ -303,7 +307,7 @@ static struct ast_codec slin24 = {
 	.minimum_bytes = 480,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin32 = {
@@ -317,7 +321,7 @@ static struct ast_codec slin32 = {
 	.minimum_bytes = 640,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin44 = {
@@ -331,7 +335,7 @@ static struct ast_codec slin44 = {
 	.minimum_bytes = 882,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin48 = {
@@ -345,7 +349,7 @@ static struct ast_codec slin48 = {
 	.minimum_bytes = 960,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin96 = {
@@ -359,7 +363,7 @@ static struct ast_codec slin96 = {
 	.minimum_bytes = 1920,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static struct ast_codec slin192 = {
@@ -373,7 +377,7 @@ static struct ast_codec slin192 = {
 	.minimum_bytes = 3840,
 	.samples_count = slin_samples,
 	.get_length = slin_length,
-	.smooth = 1,
+	.smooth = AST_SMOOTHER_FLAGS_PACK(AST_SMOOTHER_FLAG_BE | AST_SMOOTHER_FLAG_FORCED),
 };
 
 static int lpc10_samples(struct ast_frame *frame)
@@ -698,6 +702,21 @@ static struct ast_codec g719 = {
 	.get_length = g719_length,
 };
 
+static int opus_samples(struct ast_frame *frame)
+{
+	/*
+	 * XXX This is likely not at all what's intended from this
+	 * callback.  If you have codec_opus.so loaded then this
+	 * function is overridden anyway.  However, since opus is
+	 * variable bit rate and I cannot extract the calculation code
+	 * from the opus library, I am going to punt and assume 20ms
+	 * worth of samples.  In testing, this has worked just fine.
+	 * Pass through support doesn't seem to care about the value
+	 * returned anyway.
+	 */
+	return ast_format_get_sample_rate(frame->subclass.format) / 50;
+}
+
 static struct ast_codec opus = {
 	.name = "opus",
 	.description = "Opus Codec",
@@ -706,6 +725,7 @@ static struct ast_codec opus = {
 	.minimum_ms = 20,
 	.maximum_ms = 60,
 	.default_ms = 20,
+	.samples_count = opus_samples,
 	.minimum_bytes = 10,
 };
 
@@ -725,36 +745,42 @@ static struct ast_codec h261 = {
 	.name = "h261",
 	.description = "H.261 video",
 	.type = AST_MEDIA_TYPE_VIDEO,
+	.sample_rate = 1000,
 };
 
 static struct ast_codec h263 = {
 	.name = "h263",
 	.description = "H.263 video",
 	.type = AST_MEDIA_TYPE_VIDEO,
+	.sample_rate = 1000,
 };
 
 static struct ast_codec h263p = {
 	.name = "h263p",
 	.description = "H.263+ video",
 	.type = AST_MEDIA_TYPE_VIDEO,
+	.sample_rate = 1000,
 };
 
 static struct ast_codec h264 = {
 	.name = "h264",
 	.description = "H.264 video",
 	.type = AST_MEDIA_TYPE_VIDEO,
+	.sample_rate = 1000,
 };
 
 static struct ast_codec mpeg4 = {
 	.name = "mpeg4",
 	.description = "MPEG4 video",
 	.type = AST_MEDIA_TYPE_VIDEO,
+	.sample_rate = 1000,
 };
 
 static struct ast_codec vp8 = {
 	.name = "vp8",
 	.description = "VP8 video",
 	.type = AST_MEDIA_TYPE_VIDEO,
+	.sample_rate = 1000,
 };
 
 static struct ast_codec t140red = {
@@ -769,12 +795,71 @@ static struct ast_codec t140 = {
 	.type = AST_MEDIA_TYPE_TEXT,
 };
 
+static int silk_samples(struct ast_frame *frame)
+{
+	/* XXX This is likely not at all what's intended from this callback. However,
+	 * since SILK is variable bit rate, I have no idea how to take a frame of data
+	 * and determine the number of samples present. Instead, we base this on the
+	 * sample rate of the codec and the expected number of samples to receive in 20ms.
+	 * In testing, this has worked just fine.
+	 */
+	return ast_format_get_sample_rate(frame->subclass.format) / 50;
+}
+
+static struct ast_codec silk8 = {
+	.name = "silk",
+	.description = "SILK Codec (8 KHz)",
+	.type = AST_MEDIA_TYPE_AUDIO,
+	.sample_rate = 8000,
+	.minimum_ms = 20,
+	.maximum_ms = 100,
+	.default_ms = 20,
+	.minimum_bytes = 160,
+	.samples_count = silk_samples
+};
+
+static struct ast_codec silk12 = {
+	.name = "silk",
+	.description = "SILK Codec (12 KHz)",
+	.type = AST_MEDIA_TYPE_AUDIO,
+	.sample_rate = 12000,
+	.minimum_ms = 20,
+	.maximum_ms = 100,
+	.default_ms = 20,
+	.minimum_bytes = 240,
+	.samples_count = silk_samples
+};
+
+static struct ast_codec silk16 = {
+	.name = "silk",
+	.description = "SILK Codec (16 KHz)",
+	.type = AST_MEDIA_TYPE_AUDIO,
+	.sample_rate = 16000,
+	.minimum_ms = 20,
+	.maximum_ms = 100,
+	.default_ms = 20,
+	.minimum_bytes = 320,
+	.samples_count = silk_samples
+};
+
+static struct ast_codec silk24 = {
+	.name = "silk",
+	.description = "SILK Codec (24 KHz)",
+	.type = AST_MEDIA_TYPE_AUDIO,
+	.sample_rate = 24000,
+	.minimum_ms = 20,
+	.maximum_ms = 100,
+	.default_ms = 20,
+	.minimum_bytes = 480,
+	.samples_count = silk_samples
+};
+
 #define CODEC_REGISTER_AND_CACHE(codec) \
 	({ \
 		int __res_ ## __LINE__ = 0; \
 		struct ast_format *__fmt_ ## __LINE__; \
 		struct ast_codec *__codec_ ## __LINE__; \
-		res |= __ast_codec_register(&(codec), NULL); \
+		res |= __ast_codec_register_with_format(&(codec), (codec).name, NULL); \
 		__codec_ ## __LINE__ = ast_codec_get((codec).name, (codec).type, (codec).sample_rate); \
 		__fmt_ ## __LINE__ = __codec_ ## __LINE__ ? ast_format_create(__codec_ ## __LINE__) : NULL; \
 		res |= ast_format_cache_set(__fmt_ ## __LINE__); \
@@ -783,14 +868,14 @@ static struct ast_codec t140 = {
 		__res_ ## __LINE__; \
 	})
 
-#define CODEC_REGISTER_AND_CACHE_NAMED(format_name, codec) \
+#define CODEC_REGISTER_AND_CACHE_NAMED(fmt_name, codec) \
 	({ \
 		int __res_ ## __LINE__ = 0; \
 		struct ast_format *__fmt_ ## __LINE__; \
 		struct ast_codec *__codec_ ## __LINE__; \
-		res |= __ast_codec_register(&(codec), NULL); \
+		res |= __ast_codec_register_with_format(&(codec), fmt_name, NULL); \
 		__codec_ ## __LINE__ = ast_codec_get((codec).name, (codec).type, (codec).sample_rate); \
-		__fmt_ ## __LINE__ = ast_format_create_named((format_name), __codec_ ## __LINE__); \
+		__fmt_ ## __LINE__ = ast_format_create_named((fmt_name), __codec_ ## __LINE__); \
 		res |= ast_format_cache_set(__fmt_ ## __LINE__); \
 		ao2_ref(__fmt_ ## __LINE__, -1); \
 		ao2_ref(__codec_ ## __LINE__, -1); \
@@ -840,6 +925,10 @@ int ast_codec_builtin_init(void)
 	res |= CODEC_REGISTER_AND_CACHE(t140red);
 	res |= CODEC_REGISTER_AND_CACHE(t140);
 	res |= CODEC_REGISTER_AND_CACHE(none);
+	res |= CODEC_REGISTER_AND_CACHE_NAMED("silk8", silk8);
+	res |= CODEC_REGISTER_AND_CACHE_NAMED("silk12", silk12);
+	res |= CODEC_REGISTER_AND_CACHE_NAMED("silk16", silk16);
+	res |= CODEC_REGISTER_AND_CACHE_NAMED("silk24", silk24);
 
 	return res;
 }
diff -urpN asterisk-13.9.1/main/config.c asterisk-13.17.0/main/config.c
--- asterisk-13.9.1/main/config.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/config.c	2017-07-12 13:12:08.000000000 +0200
@@ -36,6 +36,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #include "asterisk/paths.h"	/* use ast_config_AST_CONFIG_DIR */
 #include "asterisk/network.h"	/* we do some sockaddr manipulation here */
+
+#include <string.h>
+#include <libgen.h>
 #include <time.h>
 #include <sys/stat.h>
 
@@ -280,7 +283,7 @@ struct ast_config_include {
 static void ast_variable_destroy(struct ast_variable *doomed);
 static void ast_includes_destroy(struct ast_config_include *incls);
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 struct ast_variable *_ast_variable_new(const char *name, const char *value, const char *filename, const char *file, const char *func, int lineno)
 #else
 struct ast_variable *ast_variable_new(const char *name, const char *value, const char *filename)
@@ -297,7 +300,7 @@ struct ast_variable *ast_variable_new(co
 	}
 
 	if (
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 		(variable = __ast_calloc(1, fn_len + name_len + val_len + sizeof(*variable), file, lineno, func))
 #else
 		(variable = ast_calloc(1, fn_len + name_len + val_len + sizeof(*variable)))
@@ -2512,6 +2515,25 @@ int ast_config_text_file_save(const char
 	return ast_config_text_file_save2(configfile, cfg, generator, CONFIG_SAVE_FLAG_PRESERVE_EFFECTIVE_CONTEXT);
 }
 
+static int is_writable(const char *fn)
+{
+	if (access(fn, F_OK)) {
+		char *dn = dirname(ast_strdupa(fn));
+
+		if (access(dn, R_OK | W_OK)) {
+			ast_log(LOG_ERROR, "Unable to write to directory %s (%s)\n", dn, strerror(errno));
+			return 0;
+		}
+	} else {
+		if (access(fn, R_OK | W_OK)) {
+			ast_log(LOG_ERROR, "Unable to write %s (%s)\n", fn, strerror(errno));
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
 int ast_config_text_file_save2(const char *configfile, const struct ast_config *cfg, const char *generator, uint32_t flags)
 {
 	FILE *f;
@@ -2534,20 +2556,20 @@ int ast_config_text_file_save2(const cha
 	for (incl = cfg->includes; incl; incl = incl->next) {
 		/* reset all the output flags in case this isn't our first time saving this data */
 		incl->output = 0;
-		/* now make sure we have write access */
+
 		if (!incl->exec) {
+			/* now make sure we have write access to the include file or its parent directory */
 			make_fn(fn, sizeof(fn), incl->included_file, configfile);
-			if (access(fn, R_OK | W_OK)) {
-				ast_log(LOG_ERROR, "Unable to write %s (%s)\n", fn, strerror(errno));
+			/* If the file itself doesn't exist, make sure we have write access to the directory */
+			if (!is_writable(fn)) {
 				return -1;
 			}
 		}
 	}
 
-	/* now make sure we have write access to the main config file */
+	/* now make sure we have write access to the main config file or its parent directory */
 	make_fn(fn, sizeof(fn), 0, configfile);
-	if (access(fn, R_OK | W_OK)) {
-		ast_log(LOG_ERROR, "Unable to write %s (%s)\n", fn, strerror(errno));
+	if (!is_writable(fn)) {
 		return -1;
 	}
 
diff -urpN asterisk-13.9.1/main/config_options.c asterisk-13.17.0/main/config_options.c
--- asterisk-13.9.1/main/config_options.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/config_options.c	2017-07-12 13:12:08.000000000 +0200
@@ -97,6 +97,7 @@ static char *aco_option_type_string[] =
 	"IP Address",		/* OPT_SOCKADDR_T, */
 	"String",			/* OPT_STRINGFIELD_T, */
 	"Unsigned Integer",	/* OPT_UINT_T, */
+	"Boolean",			/* OPT_YESNO_T, */
 };
 
 void *aco_pending_config(struct aco_info *info)
@@ -139,6 +140,10 @@ static aco_option_handler ast_config_opt
 	switch(type) {
 	case OPT_ACL_T: return acl_handler_fn;
 	case OPT_BOOL_T: return bool_handler_fn;
+	/* Reading from config files, BOOL and YESNO are handled exactly the
+	 * same. Their difference is in how they are rendered to users
+	 */
+	case OPT_YESNO_T: return bool_handler_fn;
 	case OPT_BOOLFLAG_T: return boolflag_handler_fn;
 	case OPT_CHAR_ARRAY_T: return chararray_handler_fn;
 	case OPT_CODEC_T: return codec_handler_fn;
@@ -198,8 +203,8 @@ static int link_option_to_types(struct a
 #ifdef AST_DEVMODE
 			opt->doc_unavailable = 1;
 #endif
-#endif
 		}
+#endif
 	}
 	/* The container(s) should hold the only ref to opt */
 	ao2_ref(opt, -1);
@@ -583,10 +588,13 @@ enum aco_process_status aco_process_ast_
 	};
 
 	ao2_cleanup(info->internal->pending);
+	info->internal->pending = NULL;
 	return ACO_PROCESS_OK;
 
 error:
 	ao2_cleanup(info->internal->pending);
+	info->internal->pending = NULL;
+
 	return ACO_PROCESS_ERROR;
 }
 
@@ -699,6 +707,8 @@ try_alias:
 
 end:
 	ao2_cleanup(info->internal->pending);
+	info->internal->pending = NULL;
+
 	return res;
 }
 int aco_process_var(struct aco_type *type, const char *cat, struct ast_variable *var, void *obj)
diff -urpN asterisk-13.9.1/main/core_local.c asterisk-13.17.0/main/core_local.c
--- asterisk-13.9.1/main/core_local.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/core_local.c	2017-07-12 13:12:08.000000000 +0200
@@ -235,17 +235,45 @@ struct local_pvt {
 	char exten[AST_MAX_EXTENSION];
 };
 
-void ast_local_lock_all(struct ast_channel *chan, struct ast_channel **outchan,
-			struct ast_channel **outowner)
+void ast_local_lock_all2(struct ast_channel *chan, void **tech_pvt,
+	struct ast_channel **base_chan, struct ast_channel **base_owner)
 {
 	struct local_pvt *p = ast_channel_tech_pvt(chan);
 
-	*outchan = NULL;
-	*outowner = NULL;
+	*tech_pvt = NULL;
+	*base_chan = NULL;
+	*base_owner = NULL;
 
 	if (p) {
-		ao2_ref(p, 1);
-		ast_unreal_lock_all(&p->base, outchan, outowner);
+		*tech_pvt = ao2_bump(p);
+		ast_unreal_lock_all(&p->base, base_chan, base_owner);
+	}
+}
+
+void ast_local_lock_all(struct ast_channel *chan, struct ast_channel **outchan,
+			struct ast_channel **outowner)
+{
+	void *tech_pvt;
+	ast_local_lock_all2(chan, &tech_pvt, outchan, outowner);
+}
+
+void ast_local_unlock_all2(void *tech_pvt, struct ast_channel *base_chan,
+	struct ast_channel *base_owner)
+{
+	if (base_chan) {
+		ast_channel_unlock(base_chan);
+		ast_channel_unref(base_chan);
+	}
+
+	if (base_owner) {
+		ast_channel_unlock(base_owner);
+		ast_channel_unref(base_owner);
+	}
+
+	if (tech_pvt) {
+		struct local_pvt *p = tech_pvt;
+		ao2_unlock(&p->base);
+		ao2_ref(tech_pvt, -1);
 	}
 }
 
@@ -259,19 +287,7 @@ void ast_local_unlock_all(struct ast_cha
 	}
 
 	base = &p->base;
-
-	if (base->owner) {
-		ast_channel_unlock(base->owner);
-		ast_channel_unref(base->owner);
-	}
-
-	if (base->chan) {
-		ast_channel_unlock(base->chan);
-		ast_channel_unref(base->chan);
-	}
-
-	ao2_unlock(base);
-	ao2_ref(p, -1);
+	ast_local_unlock_all2(p, base->chan, base->owner);
 }
 
 struct ast_channel *ast_local_get_peer(struct ast_channel *ast)
diff -urpN asterisk-13.9.1/main/core_unreal.c asterisk-13.17.0/main/core_unreal.c
--- asterisk-13.9.1/main/core_unreal.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/core_unreal.c	2017-07-12 13:12:08.000000000 +0200
@@ -808,7 +808,6 @@ int ast_unreal_channel_push_to_bridge(st
 	/* Impart the semi2 channel into the bridge */
 	if (ast_bridge_impart(bridge, chan, NULL, features,
 		AST_BRIDGE_IMPART_CHAN_INDEPENDENT)) {
-		ast_bridge_features_destroy(features);
 		ast_channel_unref(chan);
 		return -1;
 	}
diff -urpN asterisk-13.9.1/main/crypt.c asterisk-13.17.0/main/crypt.c
--- asterisk-13.9.1/main/crypt.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/crypt.c	2017-07-12 13:12:08.000000000 +0200
@@ -31,7 +31,7 @@
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
 #include <unistd.h>
-#if defined(HAVE_CRYPT_R)
+#if defined(HAVE_CRYPT_R) && !defined(__FreeBSD__)
 #include <crypt.h>
 #endif
 
diff -urpN asterisk-13.9.1/main/data.c asterisk-13.17.0/main/data.c
--- asterisk-13.9.1/main/data.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/data.c	2017-07-12 13:12:08.000000000 +0200
@@ -3145,6 +3145,10 @@ int ast_data_add_codecs(struct ast_data
 		return -1;
 	}
 
+	if (!cap) {
+		return 0;
+	}
+
 	count = ast_format_cap_count(cap);
 	for (i = 0; i < count; ++i) {
 		struct ast_format *fmt;
diff -urpN asterisk-13.9.1/main/dial.c asterisk-13.17.0/main/dial.c
--- asterisk-13.9.1/main/dial.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/dial.c	2017-07-12 13:12:08.000000000 +0200
@@ -411,16 +411,24 @@ int ast_dial_prerun(struct ast_dial *dia
 }
 
 /*! \brief Helper function that does the beginning dialing per-appended channel */
-static int begin_dial_channel(struct ast_dial_channel *channel, struct ast_channel *chan, int async, const char *predial_string)
+static int begin_dial_channel(struct ast_dial_channel *channel, struct ast_channel *chan, int async, const char *predial_string, struct ast_channel *forwarder_chan)
 {
 	char numsubst[AST_MAX_EXTENSION];
 	int res = 1;
+	char forwarder[AST_CHANNEL_NAME];
 
 	/* If no owner channel exists yet execute pre-run */
 	if (!channel->owner && begin_dial_prerun(channel, chan, NULL, predial_string)) {
 		return 0;
 	}
 
+	if (forwarder_chan) {
+		ast_copy_string(forwarder, ast_channel_name(forwarder_chan), sizeof(forwarder));
+		ast_channel_lock(channel->owner);
+		pbx_builtin_setvar_helper(channel->owner, "FORWARDERNAME", forwarder);
+		ast_channel_unlock(channel->owner);
+	}
+
 	/* Copy device string over */
 	ast_copy_string(numsubst, channel->device, sizeof(numsubst));
 
@@ -451,7 +459,7 @@ static int begin_dial(struct ast_dial *d
 	/* Iterate through channel list, requesting and calling each one */
 	AST_LIST_LOCK(&dial->channels);
 	AST_LIST_TRAVERSE(&dial->channels, channel, list) {
-		success += begin_dial_channel(channel, chan, async, predial_string);
+		success += begin_dial_channel(channel, chan, async, predial_string, NULL);
 	}
 	AST_LIST_UNLOCK(&dial->channels);
 
@@ -507,7 +515,7 @@ static int handle_call_forward(struct as
 	channel->owner = NULL;
 
 	/* Finally give it a go... send it out into the world */
-	begin_dial_channel(channel, chan, chan ? 0 : 1, predial_string);
+	begin_dial_channel(channel, chan, chan ? 0 : 1, predial_string, original);
 
 	ast_channel_publish_dial_forward(chan, original, channel->owner, NULL, "CANCEL",
 		ast_channel_call_forward(original));
diff -urpN asterisk-13.9.1/main/dsp.c asterisk-13.17.0/main/dsp.c
--- asterisk-13.9.1/main/dsp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/dsp.c	2017-07-12 13:12:08.000000000 +0200
@@ -68,6 +68,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/utils.h"
 #include "asterisk/options.h"
 #include "asterisk/config.h"
+#include "asterisk/test.h"
 
 /*! Number of goertzels for progress detect */
 enum gsamp_size {
@@ -171,8 +172,7 @@ enum gsamp_thresh {
  */
 
 #define DTMF_THRESHOLD		8.0e7
-#define FAX_THRESHOLD		8.0e7
-#define FAX_2ND_HARMONIC	2.0     /* 4dB */
+#define TONE_THRESHOLD		7.8e7
 
 #define DEF_DTMF_NORMAL_TWIST		6.31	 /* 8.0dB */
 #define DEF_RELAX_DTMF_NORMAL_TWIST	6.31	 /* 8.0dB */
@@ -187,8 +187,6 @@ enum gsamp_thresh {
 
 #define DTMF_RELATIVE_PEAK_ROW	6.3     /* 8dB */
 #define DTMF_RELATIVE_PEAK_COL	6.3     /* 8dB */
-#define DTMF_2ND_HARMONIC_ROW       (relax ? 1.7 : 2.5)     /* 4dB normal */
-#define DTMF_2ND_HARMONIC_COL	63.1    /* 18dB */
 #define DTMF_TO_TOTAL_ENERGY	42.0
 
 #define BELL_MF_THRESHOLD	1.6e9
@@ -203,7 +201,7 @@ enum gsamp_thresh {
  * followed by a 3 second silent (2100 Hz OFF) period.
  */
 #define FAX_TONE_CNG_FREQ	1100
-#define FAX_TONE_CNG_DURATION	500
+#define FAX_TONE_CNG_DURATION	500	/* ms */
 #define FAX_TONE_CNG_DB		16
 
 /* This signal may be sent by the Terminating FAX machine anywhere between
@@ -211,7 +209,7 @@ enum gsamp_thresh {
  * of a 2100 Hz tone that is from 2.6 to 4 seconds in duration.
 */
 #define FAX_TONE_CED_FREQ	2100
-#define FAX_TONE_CED_DURATION	2600
+#define FAX_TONE_CED_DURATION	2600	/* ms */
 #define FAX_TONE_CED_DB		16
 
 #define DEFAULT_SAMPLE_RATE		8000
@@ -241,9 +239,13 @@ static const int DEFAULT_SILENCE_THRESHO
 #define CONFIG_FILE_NAME "dsp.conf"
 
 typedef struct {
+	/*! The previous previous sample calculation (No binary point just plain int) */
 	int v2;
+	/*! The previous sample calculation (No binary point just plain int) */
 	int v3;
+	/*! v2 and v3 power of two exponent to keep value in int range */
 	int chunky;
+	/*! 15 bit fixed point goertzel coefficient = 2 * cos(2 * pi * freq / sample_rate) */
 	int fac;
 } goertzel_state_t;
 
@@ -329,12 +331,22 @@ static inline void goertzel_sample(goert
 {
 	int v1;
 
+	/*
+	 * Shift previous values so
+	 * v1 is previous previous value
+	 * v2 is previous value
+	 * until the new v3 is calculated.
+	 */
 	v1 = s->v2;
 	s->v2 = s->v3;
 
+	/* Discard the binary fraction introduced by s->fac */
 	s->v3 = (s->fac * s->v2) >> 15;
+	/* Scale sample to match previous values */
 	s->v3 = s->v3 - v1 + (sample >> s->chunky);
-	if (abs(s->v3) > 32768) {
+
+	if (abs(s->v3) > (1 << 15)) {
+		/* The result is now too large so increase the chunky power. */
 		s->chunky++;
 		s->v3 = s->v3 >> 1;
 		s->v2 = s->v2 >> 1;
@@ -344,21 +356,26 @@ static inline void goertzel_sample(goert
 static inline float goertzel_result(goertzel_state_t *s)
 {
 	goertzel_result_t r;
+
 	r.value = (s->v3 * s->v3) + (s->v2 * s->v2);
 	r.value -= ((s->v2 * s->v3) >> 15) * s->fac;
+	/*
+	 * We have to double the exponent because we multiplied the
+	 * previous sample calculation values together.
+	 */
 	r.power = s->chunky * 2;
 	return (float)r.value * (float)(1 << r.power);
 }
 
 static inline void goertzel_init(goertzel_state_t *s, float freq, unsigned int sample_rate)
 {
-	s->v2 = s->v3 = s->chunky = 0.0;
+	s->v2 = s->v3 = s->chunky = 0;
 	s->fac = (int)(32768.0 * 2.0 * cos(2.0 * M_PI * freq / sample_rate));
 }
 
 static inline void goertzel_reset(goertzel_state_t *s)
 {
-	s->v2 = s->v3 = s->chunky = 0.0;
+	s->v2 = s->v3 = s->chunky = 0;
 }
 
 typedef struct {
@@ -581,10 +598,11 @@ static int tone_detect(struct ast_dsp *d
 		tone_energy *= 2.0;
 		s->energy *= s->block_size;
 
-		ast_debug(10, "tone %d, Ew=%.2E, Et=%.2E, s/n=%10.2f\n", s->freq, tone_energy, s->energy, tone_energy / (s->energy - tone_energy));
+		ast_debug(10, "%d Hz tone %2d Ew=%.4E, Et=%.4E, s/n=%10.2f\n", s->freq, s->hit_count, tone_energy, s->energy, tone_energy / (s->energy - tone_energy));
 		hit = 0;
-		if (tone_energy > s->energy * s->threshold) {
-			ast_debug(10, "Hit! count=%d\n", s->hit_count);
+		if (TONE_THRESHOLD <= tone_energy
+			&& tone_energy > s->energy * s->threshold) {
+			ast_debug(10, "%d Hz tone Hit! %2d Ew=%.4E, Et=%.4E, s/n=%10.2f\n", s->freq, s->hit_count, tone_energy, s->energy, tone_energy / (s->energy - tone_energy));
 			hit = 1;
 		}
 
@@ -603,7 +621,7 @@ static int tone_detect(struct ast_dsp *d
 		}
 
 		if (s->hit_count == s->hits_required) {
-			ast_debug(1, "%d Hz done detected\n", s->freq);
+			ast_debug(1, "%d Hz tone detected\n", s->freq);
 			res = 1;
 		}
 
@@ -716,6 +734,10 @@ static int dtmf_detect(struct ast_dsp *d
 				best_col = i;
 			}
 		}
+		ast_debug(10, "DTMF best '%c' Erow=%.4E Ecol=%.4E Erc=%.4E Et=%.4E\n",
+			dtmf_positions[(best_row << 2) + best_col],
+			row_energy[best_row], col_energy[best_col],
+			row_energy[best_row] + col_energy[best_col], s->td.dtmf.energy);
 		hit = 0;
 		/* Basic signal level test and the twist test */
 		if (row_energy[best_row] >= DTMF_THRESHOLD &&
@@ -736,6 +758,7 @@ static int dtmf_detect(struct ast_dsp *d
 			    (row_energy[best_row] + col_energy[best_col]) > DTMF_TO_TOTAL_ENERGY * s->td.dtmf.energy) {
 				/* Got a hit */
 				hit = dtmf_positions[(best_row << 2) + best_col];
+				ast_debug(10, "DTMF hit '%c'\n", hit);
 			}
 		}
 
@@ -1622,7 +1645,7 @@ done:
 		for (x = 0; x < len; x++) {
 			odata[x] = AST_LIN2MU((unsigned short) shortdata[x]);
 		}
-	} else if (ast_format_cmp(af->subclass.format, ast_format_ulaw) == AST_FORMAT_CMP_EQUAL) {
+	} else if (ast_format_cmp(af->subclass.format, ast_format_alaw) == AST_FORMAT_CMP_EQUAL) {
 		for (x = 0; x < len; x++) {
 			odata[x] = AST_LIN2A((unsigned short) shortdata[x]);
 		}
@@ -1929,9 +1952,460 @@ int ast_dsp_get_threshold_from_settings(
 	return thresholds[which];
 }
 
+#ifdef TEST_FRAMEWORK
+static void test_tone_sample_gen(short *slin_buf, int samples, int rate, int freq, short amplitude)
+{
+	int idx;
+	double sample_step = 2.0 * M_PI * freq / rate;/* radians per step */
+
+	for (idx = 0; idx < samples; ++idx) {
+		slin_buf[idx] = amplitude * sin(sample_step * idx);
+	}
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+static void test_tone_sample_gen_add(short *slin_buf, int samples, int rate, int freq, short amplitude)
+{
+	int idx;
+	double sample_step = 2.0 * M_PI * freq / rate;/* radians per step */
+
+	for (idx = 0; idx < samples; ++idx) {
+		slin_buf[idx] += amplitude * sin(sample_step * idx);
+	}
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+static void test_dual_sample_gen(short *slin_buf, int samples, int rate, int f1, short a1, int f2, short a2)
+{
+	test_tone_sample_gen(slin_buf, samples, rate, f1, a1);
+	test_tone_sample_gen_add(slin_buf, samples, rate, f2, a2);
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+#define TONE_AMPLITUDE_MAX	0x7fff	/* Max signed linear amplitude */
+#define TONE_AMPLITUDE_MIN	80		/* Min signed linear amplitude detectable */
+
+static int test_tone_amplitude_sweep(struct ast_test *test, struct ast_dsp *dsp, tone_detect_state_t *tone_state)
+{
+	short slin_buf[tone_state->block_size];
+	int result;
+	int idx;
+	struct {
+		short amp_val;
+		int detect;
+	} amp_tests[] = {
+		{ .amp_val = TONE_AMPLITUDE_MAX,	.detect = 1, },
+		{ .amp_val = 10000,					.detect = 1, },
+		{ .amp_val = 1000,					.detect = 1, },
+		{ .amp_val = 100,					.detect = 1, },
+		{ .amp_val = TONE_AMPLITUDE_MIN,	.detect = 1, },
+		{ .amp_val = 75,					.detect = 0, },
+		{ .amp_val = 10,					.detect = 0, },
+		{ .amp_val = 1,						.detect = 0, },
+	};
+
+	result = 0;
+
+	for (idx = 0; idx < ARRAY_LEN(amp_tests); ++idx) {
+		int detected;
+		int duration;
+
+		ast_debug(1, "Test %d Hz at amplitude %d\n",
+			tone_state->freq, amp_tests[idx].amp_val);
+		test_tone_sample_gen(slin_buf, tone_state->block_size, DEFAULT_SAMPLE_RATE,
+			tone_state->freq, amp_tests[idx].amp_val);
+
+		detected = 0;
+		for (duration = 0; !detected && duration < tone_state->hits_required + 3; ++duration) {
+			detected = tone_detect(dsp, tone_state, slin_buf, tone_state->block_size) ? 1 : 0;
+		}
+		if (amp_tests[idx].detect != detected) {
+			/*
+			 * Both messages are needed.  ast_debug for when figuring out
+			 * what went wrong and the test update for normal output before
+			 * you start debugging.  The different logging methods are not
+			 * synchronized.
+			 */
+			ast_debug(1,
+				"Test %d Hz at amplitude %d failed.  Detected: %s\n",
+				tone_state->freq, amp_tests[idx].amp_val,
+				detected ? "yes" : "no");
+			ast_test_status_update(test,
+				"Test %d Hz at amplitude %d failed.  Detected: %s\n",
+				tone_state->freq, amp_tests[idx].amp_val,
+				detected ? "yes" : "no");
+			result = -1;
+		}
+		tone_state->hit_count = 0;
+	}
+
+	return result;
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+static int test_dtmf_amplitude_sweep(struct ast_test *test, struct ast_dsp *dsp, int digit_index)
+{
+	short slin_buf[DTMF_GSIZE];
+	int result;
+	int row;
+	int column;
+	int idx;
+	struct {
+		short amp_val;
+		int digit;
+	} amp_tests[] = {
+		/*
+		 * XXX Since there is no current DTMF level detection issue.  This test
+		 * just checks the current detection levels.
+		 */
+		{ .amp_val = TONE_AMPLITUDE_MAX/2,	.digit = dtmf_positions[digit_index], },
+		{ .amp_val = 10000,					.digit = dtmf_positions[digit_index], },
+		{ .amp_val = 1000,					.digit = dtmf_positions[digit_index], },
+		{ .amp_val = 500,					.digit = dtmf_positions[digit_index], },
+		{ .amp_val = 250,					.digit = dtmf_positions[digit_index], },
+		{ .amp_val = 200,					.digit = dtmf_positions[digit_index], },
+		{ .amp_val = 180,					.digit = dtmf_positions[digit_index], },
+		/* Various digits detect and not detect in this range */
+		{ .amp_val = 170,					.digit = 0, },
+		{ .amp_val = 100,					.digit = 0, },
+		/*
+		 * Amplitudes below TONE_AMPLITUDE_MIN start having questionable detection
+		 * over quantization and background noise.
+		 */
+		{ .amp_val = TONE_AMPLITUDE_MIN,	.digit = 0, },
+		{ .amp_val = 75,					.digit = 0, },
+		{ .amp_val = 10,					.digit = 0, },
+		{ .amp_val = 1,						.digit = 0, },
+	};
+
+	row = (digit_index >> 2) & 0x03;
+	column = digit_index & 0x03;
+
+	result = 0;
+
+	for (idx = 0; idx < ARRAY_LEN(amp_tests); ++idx) {
+		int digit;
+		int duration;
+
+		ast_debug(1, "Test '%c' at amplitude %d\n",
+			dtmf_positions[digit_index], amp_tests[idx].amp_val);
+		test_dual_sample_gen(slin_buf, ARRAY_LEN(slin_buf), DEFAULT_SAMPLE_RATE,
+			(int) dtmf_row[row], amp_tests[idx].amp_val,
+			(int) dtmf_col[column], amp_tests[idx].amp_val);
+
+		digit = 0;
+		for (duration = 0; !digit && duration < 3; ++duration) {
+			digit = dtmf_detect(dsp, &dsp->digit_state, slin_buf, ARRAY_LEN(slin_buf),
+				0, 0);
+		}
+		if (amp_tests[idx].digit != digit) {
+			/*
+			 * Both messages are needed.  ast_debug for when figuring out
+			 * what went wrong and the test update for normal output before
+			 * you start debugging.  The different logging methods are not
+			 * synchronized.
+			 */
+			ast_debug(1,
+				"Test '%c' at amplitude %d failed.  Detected Digit: '%c'\n",
+				dtmf_positions[digit_index], amp_tests[idx].amp_val,
+				digit ?: ' ');
+			ast_test_status_update(test,
+				"Test '%c' at amplitude %d failed.  Detected Digit: '%c'\n",
+				dtmf_positions[digit_index], amp_tests[idx].amp_val,
+				digit ?: ' ');
+			result = -1;
+		}
+		ast_dsp_digitreset(dsp);
+	}
+
+	return result;
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+static int test_dtmf_twist_sweep(struct ast_test *test, struct ast_dsp *dsp, int digit_index)
+{
+	short slin_buf[DTMF_GSIZE];
+	int result;
+	int row;
+	int column;
+	int idx;
+	struct {
+		short amp_row;
+		short amp_col;
+		int digit;
+	} twist_tests[] = {
+		/*
+		 * XXX Since there is no current DTMF twist detection issue.  This test
+		 * just checks the current detection levels.
+		 *
+		 * Normal twist has the column higher than the row amplitude.
+		 * Reverse twist is the other way.
+		 */
+		{ .amp_row = 1000 + 1800, .amp_col = 1000 +    0, .digit = 0, },
+		{ .amp_row = 1000 + 1700, .amp_col = 1000 +    0, .digit = 0, },
+		/* Various digits detect and not detect in this range */
+		{ .amp_row = 1000 + 1400, .amp_col = 1000 +    0, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 + 1300, .amp_col = 1000 +    0, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 + 1200, .amp_col = 1000 +    0, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 + 1100, .amp_col = 1000 +    0, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 + 1000, .amp_col = 1000 +    0, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +  100, .amp_col = 1000 +    0, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  100, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  200, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  300, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  400, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  500, .digit = dtmf_positions[digit_index], },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  550, .digit = dtmf_positions[digit_index], },
+		/* Various digits detect and not detect in this range */
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  650, .digit = 0, },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  700, .digit = 0, },
+		{ .amp_row = 1000 +    0, .amp_col = 1000 +  800, .digit = 0, },
+	};
+	float save_normal_twist;
+	float save_reverse_twist;
+
+	save_normal_twist = dtmf_normal_twist;
+	save_reverse_twist = dtmf_reverse_twist;
+	dtmf_normal_twist = DEF_DTMF_NORMAL_TWIST;
+	dtmf_reverse_twist = DEF_DTMF_REVERSE_TWIST;
+
+	row = (digit_index >> 2) & 0x03;
+	column = digit_index & 0x03;
+
+	result = 0;
+
+	for (idx = 0; idx < ARRAY_LEN(twist_tests); ++idx) {
+		int digit;
+		int duration;
+
+		ast_debug(1, "Test '%c' twist row %d col %d amplitudes\n",
+			dtmf_positions[digit_index],
+			twist_tests[idx].amp_row, twist_tests[idx].amp_col);
+		test_dual_sample_gen(slin_buf, ARRAY_LEN(slin_buf), DEFAULT_SAMPLE_RATE,
+			(int) dtmf_row[row], twist_tests[idx].amp_row,
+			(int) dtmf_col[column], twist_tests[idx].amp_col);
+
+		digit = 0;
+		for (duration = 0; !digit && duration < 3; ++duration) {
+			digit = dtmf_detect(dsp, &dsp->digit_state, slin_buf, ARRAY_LEN(slin_buf),
+				0, 0);
+		}
+		if (twist_tests[idx].digit != digit) {
+			/*
+			 * Both messages are needed.  ast_debug for when figuring out
+			 * what went wrong and the test update for normal output before
+			 * you start debugging.  The different logging methods are not
+			 * synchronized.
+			 */
+			ast_debug(1,
+				"Test '%c' twist row %d col %d amplitudes failed.  Detected Digit: '%c'\n",
+				dtmf_positions[digit_index],
+				twist_tests[idx].amp_row, twist_tests[idx].amp_col,
+				digit ?: ' ');
+			ast_test_status_update(test,
+				"Test '%c' twist row %d col %d amplitudes failed.  Detected Digit: '%c'\n",
+				dtmf_positions[digit_index],
+				twist_tests[idx].amp_row, twist_tests[idx].amp_col,
+				digit ?: ' ');
+			result = -1;
+		}
+		ast_dsp_digitreset(dsp);
+	}
+
+	dtmf_normal_twist = save_normal_twist;
+	dtmf_reverse_twist = save_reverse_twist;
+
+	return result;
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+static int test_tone_freq_sweep(struct ast_test *test, struct ast_dsp *dsp, tone_detect_state_t *tone_state, short amplitude)
+{
+	short slin_buf[tone_state->block_size];
+	int result;
+	int freq;
+	int lower_freq;
+	int upper_freq;
+
+	/* Calculate detection frequency range */
+	lower_freq = tone_state->freq - 4;
+	upper_freq = tone_state->freq + 4;
+
+	result = 0;
+
+	/* Sweep frequencies loop. */
+	for (freq = 100; freq <= 3500; freq += 1) {
+		int detected;
+		int duration;
+		int expect_detection;
+
+		if (freq == tone_state->freq) {
+			/* This case is done by the amplitude sweep. */
+			continue;
+		}
+
+		expect_detection = (lower_freq <= freq && freq <= upper_freq) ? 1 : 0;
+
+		ast_debug(1, "Test %d Hz detection given %d Hz tone at amplitude %d.  Range:%d-%d Expect detect: %s\n",
+			tone_state->freq, freq, amplitude, lower_freq, upper_freq,
+			expect_detection ? "yes" : "no");
+		test_tone_sample_gen(slin_buf, tone_state->block_size, DEFAULT_SAMPLE_RATE, freq,
+			amplitude);
+
+		detected = 0;
+		for (duration = 0; !detected && duration < tone_state->hits_required + 3; ++duration) {
+			detected = tone_detect(dsp, tone_state, slin_buf, tone_state->block_size) ? 1 : 0;
+		}
+		if (expect_detection != detected) {
+			/*
+			 * Both messages are needed.  ast_debug for when figuring out
+			 * what went wrong and the test update for normal output before
+			 * you start debugging.  The different logging methods are not
+			 * synchronized.
+			 */
+			ast_debug(1,
+				"Test %d Hz detection given %d Hz tone at amplitude %d failed.  Range:%d-%d Detected: %s\n",
+				tone_state->freq, freq, amplitude, lower_freq, upper_freq,
+				detected ? "yes" : "no");
+			ast_test_status_update(test,
+				"Test %d Hz detection given %d Hz tone at amplitude %d failed.  Range:%d-%d Detected: %s\n",
+				tone_state->freq, freq, amplitude, lower_freq, upper_freq,
+				detected ? "yes" : "no");
+			result = -1;
+		}
+		tone_state->hit_count = 0;
+	}
+
+	return result;
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+AST_TEST_DEFINE(test_dsp_fax_detect)
+{
+	struct ast_dsp *dsp;
+	enum ast_test_result_state result;
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = "fax";
+		info->category = "/main/dsp/";
+		info->summary = "DSP fax tone detect unit test";
+		info->description =
+			"Tests fax tone detection code.";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	dsp = ast_dsp_new();
+	if (!dsp) {
+		return AST_TEST_FAIL;
+	}
+
+	result = AST_TEST_PASS;
+
+	/* Test CNG tone amplitude detection */
+	if (test_tone_amplitude_sweep(test, dsp, &dsp->cng_tone_state)) {
+		result = AST_TEST_FAIL;
+	}
+
+	/* Test CED tone amplitude detection */
+	if (test_tone_amplitude_sweep(test, dsp, &dsp->ced_tone_state)) {
+		result = AST_TEST_FAIL;
+	}
+
+	/* Test CNG tone frequency detection */
+	if (test_tone_freq_sweep(test, dsp, &dsp->cng_tone_state, TONE_AMPLITUDE_MAX)) {
+		result = AST_TEST_FAIL;
+	}
+	if (test_tone_freq_sweep(test, dsp, &dsp->cng_tone_state, TONE_AMPLITUDE_MIN)) {
+		result = AST_TEST_FAIL;
+	}
+
+	/* Test CED tone frequency detection */
+	if (test_tone_freq_sweep(test, dsp, &dsp->ced_tone_state, TONE_AMPLITUDE_MAX)) {
+		result = AST_TEST_FAIL;
+	}
+	if (test_tone_freq_sweep(test, dsp, &dsp->ced_tone_state, TONE_AMPLITUDE_MIN)) {
+		result = AST_TEST_FAIL;
+	}
+
+	ast_dsp_free(dsp);
+	return result;
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+AST_TEST_DEFINE(test_dsp_dtmf_detect)
+{
+	int idx;
+	struct ast_dsp *dsp;
+	enum ast_test_result_state result;
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = "dtmf";
+		info->category = "/main/dsp/";
+		info->summary = "DSP DTMF detect unit test";
+		info->description =
+			"Tests DTMF detection code.";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	dsp = ast_dsp_new();
+	if (!dsp) {
+		return AST_TEST_FAIL;
+	}
+
+	result = AST_TEST_PASS;
+
+	for (idx = 0; dtmf_positions[idx]; ++idx) {
+		if (test_dtmf_amplitude_sweep(test, dsp, idx)) {
+			result = AST_TEST_FAIL;
+		}
+	}
+
+	for (idx = 0; dtmf_positions[idx]; ++idx) {
+		if (test_dtmf_twist_sweep(test, dsp, idx)) {
+			result = AST_TEST_FAIL;
+		}
+	}
+
+	ast_dsp_free(dsp);
+	return result;
+}
+#endif
+
+#ifdef TEST_FRAMEWORK
+static void test_dsp_shutdown(void)
+{
+	AST_TEST_UNREGISTER(test_dsp_fax_detect);
+	AST_TEST_UNREGISTER(test_dsp_dtmf_detect);
+}
+#endif
+
 int ast_dsp_init(void)
 {
-	return _dsp_init(0);
+	int res = _dsp_init(0);
+
+#ifdef TEST_FRAMEWORK
+	if (!res) {
+		AST_TEST_REGISTER(test_dsp_fax_detect);
+		AST_TEST_REGISTER(test_dsp_dtmf_detect);
+
+		ast_register_cleanup(test_dsp_shutdown);
+	}
+#endif
+	return res;
 }
 
 int ast_dsp_reload(void)
diff -urpN asterisk-13.9.1/main/editline/Makefile.in asterisk-13.17.0/main/editline/Makefile.in
--- asterisk-13.9.1/main/editline/Makefile.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/editline/Makefile.in	2017-07-12 13:12:08.000000000 +0200
@@ -187,7 +187,7 @@ distclean : clean
 #
 
 $(LIB_A) : $(BGCSRCS:.c=.o_a) $(CCSRCS:.c=.o_a)
-	$(AR) cru $@ $?
+	$(AR) cr $@ $?
 	$(RANLIB) $@
 
 $(LIB_S) : $(BGCSRCS:.c=.o_s) $(CCSRCS:.c=.o_s)
diff -urpN asterisk-13.9.1/main/features.c asterisk-13.17.0/main/features.c
--- asterisk-13.9.1/main/features.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/features.c	2017-07-12 13:12:08.000000000 +0200
@@ -64,7 +64,6 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/cli.h"
 #include "asterisk/manager.h"
 #include "asterisk/utils.h"
-#include "asterisk/adsi.h"
 #include "asterisk/devicestate.h"
 #include "asterisk/audiohook.h"
 #include "asterisk/global_datastores.h"
@@ -203,6 +202,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</variable>
 			</variablelist>
 		</description>
+		<see-also>
+			<ref type="manager">Bridge</ref>
+			<ref type="managerEvent">BridgeCreate</ref>
+			<ref type="managerEvent">BridgeEnter</ref>
+		</see-also>
 	</application>
 	<manager name="Bridge" language="en_US">
 		<synopsis>
@@ -229,6 +233,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Bridge together two channels already in the PBX.</para>
 		</description>
+		<see-also>
+			<ref type="application">Bridge</ref>
+			<ref type="managerEvent">BridgeCreate</ref>
+			<ref type="managerEvent">BridgeEnter</ref>
+			<ref type="manager">BridgeDestroy</ref>
+			<ref type="manager">BridgeInfo</ref>
+			<ref type="manager">BridgeKick</ref>
+			<ref type="manager">BridgeList</ref>
+		</see-also>
 	</manager>
  ***/
 
@@ -767,12 +780,12 @@ static int action_bridge(struct mansessi
 		astman_send_error(s, m, buf);
 		return 0;
 	}
-	xfer_cfg_a = ast_get_chan_features_xfer_config(chana);
 	ast_channel_lock(chana);
+	xfer_cfg_a = ast_get_chan_features_xfer_config(chana);
 	chana_exten = ast_strdupa(ast_channel_exten(chana));
 	chana_context = ast_strdupa(ast_channel_context(chana));
 	chana_priority = ast_channel_priority(chana);
-	if (!ast_test_flag(ast_channel_flags(chana), AST_FLAG_IN_AUTOLOOP)) {
+	if (ast_test_flag(ast_channel_flags(chana), AST_FLAG_IN_AUTOLOOP)) {
 		chana_priority++;
 	}
 	ast_channel_unlock(chana);
@@ -783,12 +796,12 @@ static int action_bridge(struct mansessi
 		astman_send_error(s, m, buf);
 		return 0;
 	}
-	xfer_cfg_b = ast_get_chan_features_xfer_config(chanb);
 	ast_channel_lock(chanb);
+	xfer_cfg_b = ast_get_chan_features_xfer_config(chanb);
 	chanb_exten = ast_strdupa(ast_channel_exten(chanb));
 	chanb_context = ast_strdupa(ast_channel_context(chanb));
 	chanb_priority = ast_channel_priority(chanb);
-	if (!ast_test_flag(ast_channel_flags(chanb), AST_FLAG_IN_AUTOLOOP)) {
+	if (ast_test_flag(ast_channel_flags(chanb), AST_FLAG_IN_AUTOLOOP)) {
 		chanb_priority++;
 	}
 	ast_channel_unlock(chanb);
@@ -799,7 +812,7 @@ static int action_bridge(struct mansessi
 		return 0;
 	}
 
-	ast_bridge_set_after_go_on(chana, chana_context, chana_exten, chana_priority, NULL);
+	ast_bridge_set_after_goto(chana, chana_context, chana_exten, chana_priority);
 	if (ast_bridge_add_channel(bridge, chana, NULL, playtone & PLAYTONE_CHANNEL1, xfer_cfg_a ? xfer_cfg_a->xfersound : NULL)) {
 		snprintf(buf, sizeof(buf), "Unable to add Channel1 to bridge: %s", ast_channel_name(chana));
 		astman_send_error(s, m, buf);
@@ -807,7 +820,7 @@ static int action_bridge(struct mansessi
 		return 0;
 	}
 
-	ast_bridge_set_after_go_on(chanb, chanb_context, chanb_exten, chanb_priority, NULL);
+	ast_bridge_set_after_goto(chanb, chanb_context, chanb_exten, chanb_priority);
 	if (ast_bridge_add_channel(bridge, chanb, NULL, playtone & PLAYTONE_CHANNEL2, xfer_cfg_b ? xfer_cfg_b->xfersound : NULL)) {
 		snprintf(buf, sizeof(buf), "Unable to add Channel2 to bridge: %s", ast_channel_name(chanb));
 		astman_send_error(s, m, buf);
@@ -1098,13 +1111,14 @@ static int bridge_exec(struct ast_channe
 		goto done;
 	}
 
+	ast_channel_lock(current_dest_chan);
 	xfer_cfg = ast_get_chan_features_xfer_config(current_dest_chan);
+	ast_channel_unlock(current_dest_chan);
 	bridge_add_failed = ast_bridge_add_channel(bridge, current_dest_chan, peer_features,
 		ast_test_flag(&opts, BRIDGE_OPT_PLAYTONE),
 		xfer_cfg ? xfer_cfg->xfersound : NULL);
 	ao2_cleanup(xfer_cfg);
 	if (bridge_add_failed) {
-		ast_bridge_features_destroy(peer_features);
 		ast_bridge_features_cleanup(&chan_features);
 		ast_bridge_destroy(bridge, 0);
 		goto done;
diff -urpN asterisk-13.9.1/main/features_config.c asterisk-13.17.0/main/features_config.c
--- asterisk-13.9.1/main/features_config.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/features_config.c	2017-07-12 13:12:08.000000000 +0200
@@ -1949,8 +1949,6 @@ static char *handle_feature_show(struct
 		ao2_callback(cfg->featuregroups, 0, print_featuregroups, a);
 	}
 
-	ast_cli(a->fd, "\n");
-
 	return CLI_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/main/file.c asterisk-13.17.0/main/file.c
--- asterisk-13.9.1/main/file.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/file.c	2017-07-12 13:12:08.000000000 +0200
@@ -799,7 +799,7 @@ struct ast_filestream *ast_openvstream(s
 	/* As above, but for video. But here we don't have translators
 	 * so we must enforce a format.
 	 */
-	struct ast_format_cap *tmp_cap;
+	struct ast_format_cap *nativeformats, *tmp_cap;
 	char *buf;
 	int buflen;
 	int i, fd;
@@ -810,16 +810,23 @@ struct ast_filestream *ast_openvstream(s
 	buflen = strlen(preflang) + strlen(filename) + 4;
 	buf = ast_alloca(buflen);
 
+	ast_channel_lock(chan);
+	nativeformats = ao2_bump(ast_channel_nativeformats(chan));
+	ast_channel_unlock(chan);
+
 	/* is the channel capable of video without translation ?*/
-	if (!ast_format_cap_has_type(ast_channel_nativeformats(chan), AST_MEDIA_TYPE_VIDEO)) {
+	if (!ast_format_cap_has_type(nativeformats, AST_MEDIA_TYPE_VIDEO)) {
+		ao2_cleanup(nativeformats);
 		return NULL;
 	}
 	if (!(tmp_cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
+		ao2_cleanup(nativeformats);
 		return NULL;
 	}
 	/* Video is supported, so see what video formats exist for this file */
 	if (!fileexists_core(filename, NULL, preflang, buf, buflen, tmp_cap)) {
 		ao2_ref(tmp_cap, -1);
+		ao2_cleanup(nativeformats);
 		return NULL;
 	}
 
@@ -828,7 +835,7 @@ struct ast_filestream *ast_openvstream(s
 		struct ast_format *format = ast_format_cap_get_format(tmp_cap, i);
 
 		if ((ast_format_get_type(format) != AST_MEDIA_TYPE_VIDEO) ||
-			!ast_format_cap_iscompatible(ast_channel_nativeformats(chan), tmp_cap)) {
+			!ast_format_cap_iscompatible(nativeformats, tmp_cap)) {
 			ao2_ref(format, -1);
 			continue;
 		}
@@ -837,12 +844,14 @@ struct ast_filestream *ast_openvstream(s
 		if (fd >= 0) {
 			ao2_ref(format, -1);
 			ao2_ref(tmp_cap, -1);
+			ao2_cleanup(nativeformats);
 			return ast_channel_vstream(chan);
 		}
 		ast_log(LOG_WARNING, "File %s has video but couldn't be opened\n", filename);
 		ao2_ref(format, -1);
 	}
 	ao2_ref(tmp_cap, -1);
+	ao2_cleanup(nativeformats);
 
 	return NULL;
 }
@@ -1086,6 +1095,143 @@ int ast_filecopy(const char *filename, c
 	return filehelper(filename, filename2, fmt, ACTION_COPY);
 }
 
+static int __ast_file_read_dirs(const char *path, ast_file_on_file on_file,
+				void *obj, int max_depth)
+{
+	DIR *dir;
+	struct dirent *entry;
+	int res;
+
+	if (!(dir = opendir(path))) {
+		ast_log(LOG_ERROR, "Error opening directory - %s: %s\n",
+			path, strerror(errno));
+		return -1;
+	}
+
+	--max_depth;
+
+	res = 0;
+
+	while ((entry = readdir(dir)) != NULL && !errno) {
+		int is_file = 0;
+		int is_dir = 0;
+		RAII_VAR(char *, full_path, NULL, ast_free);
+
+		if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) {
+			continue;
+		}
+
+/*
+ * If the dirent structure has a d_type use it to determine if we are dealing with
+ * a file or directory. Unfortunately if it doesn't have it, or if the type is
+ * unknown, or a link then we'll need to use the stat function instead.
+ */
+#ifdef _DIRENT_HAVE_D_TYPE
+		if (entry->d_type != DT_UNKNOWN && entry->d_type != DT_LNK) {
+			is_file = entry->d_type == DT_REG;
+			is_dir = entry->d_type == DT_DIR;
+		} else
+#endif
+		{
+			struct stat statbuf;
+
+			/*
+			 * Don't use alloca or we risk blowing out the stack if recursing
+			 * into subdirectories.
+			 */
+			full_path = ast_malloc(strlen(path) + strlen(entry->d_name) + 2);
+			if (!full_path) {
+				return -1;
+			}
+			sprintf(full_path, "%s/%s", path, entry->d_name);
+
+			if (stat(full_path, &statbuf)) {
+				ast_log(LOG_ERROR, "Error reading path stats - %s: %s\n",
+					full_path, strerror(errno));
+				/*
+				 * Output an error, but keep going. It could just be
+				 * a broken link and other files could be fine.
+				 */
+				continue;
+			}
+
+			is_file = S_ISREG(statbuf.st_mode);
+			is_dir = S_ISDIR(statbuf.st_mode);
+		}
+
+		if (is_file) {
+			/* If the handler returns non-zero then stop */
+			if ((res = on_file(path, entry->d_name, obj))) {
+				break;
+			}
+			/* Otherwise move on to next item in directory */
+			continue;
+		}
+
+		if (!is_dir) {
+			ast_debug(5, "Skipping %s: not a regular file or directory\n", full_path);
+			continue;
+		}
+
+		/* Only re-curse into sub-directories if not at the max depth */
+		if (max_depth != 0) {
+			if (!full_path) {
+				/* Don't use alloca.  See note above. */
+				full_path = ast_malloc(strlen(path) + strlen(entry->d_name) + 2);
+				if (!full_path) {
+					return -1;
+				}
+				sprintf(full_path, "%s/%s", path, entry->d_name);
+			}
+
+			if ((res = __ast_file_read_dirs(full_path, on_file, obj, max_depth))) {
+				break;
+			}
+		}
+	}
+
+	closedir(dir);
+
+	if (!res && errno) {
+		ast_log(LOG_ERROR, "Error while reading directories - %s: %s\n",
+			path, strerror(errno));
+		res = -1;
+	}
+
+	return res;
+}
+
+#if !defined(__GLIBC__)
+/*!
+ * \brief Lock to hold when iterating over directories.
+ *
+ * Currently, 'readdir' is not required to be thread-safe. In most modern implementations
+ * it should be safe to make concurrent calls into 'readdir' that specify different directory
+ * streams (glibc would be one of these). However, since it is potentially unsafe for some
+ * implementations we'll use our own locking in order to achieve synchronization for those.
+ */
+AST_MUTEX_DEFINE_STATIC(read_dirs_lock);
+#endif
+
+int ast_file_read_dirs(const char *dir_name, ast_file_on_file on_file, void *obj, int max_depth)
+{
+	int res;
+
+	errno = 0;
+
+#if !defined(__GLIBC__)
+	ast_mutex_lock(&read_dirs_lock);
+#endif
+
+	res = __ast_file_read_dirs(dir_name, on_file, obj, max_depth);
+
+#if !defined(__GLIBC__)
+	ast_mutex_unlock(&read_dirs_lock);
+#endif
+
+	return res;
+}
+
 int ast_streamfile(struct ast_channel *chan, const char *filename, const char *preflang)
 {
 	struct ast_filestream *fs;
@@ -1097,8 +1243,10 @@ int ast_streamfile(struct ast_channel *c
 	fs = ast_openstream(chan, filename, preflang);
 	if (!fs) {
 		struct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
+		ast_channel_lock(chan);
 		ast_log(LOG_WARNING, "Unable to open %s (format %s): %s\n",
 			filename, ast_format_cap_get_names(ast_channel_nativeformats(chan), &codec_buf), strerror(errno));
+		ast_channel_unlock(chan);
 		return -1;
 	}
 
@@ -1133,7 +1281,12 @@ int ast_streamfile(struct ast_channel *c
 	res = ast_playstream(fs);
 	if (!res && vfs)
 		res = ast_playstream(vfs);
-	ast_verb(3, "<%s> Playing '%s.%s' (language '%s')\n", ast_channel_name(chan), filename, ast_format_get_name(ast_channel_writeformat(chan)), preflang ? preflang : "default");
+
+	if (VERBOSITY_ATLEAST(3)) {
+		ast_channel_lock(chan);
+		ast_verb(3, "<%s> Playing '%s.%s' (language '%s')\n", ast_channel_name(chan), filename, ast_format_get_name(ast_channel_writeformat(chan)), preflang ? preflang : "default");
+		ast_channel_unlock(chan);
+	}
 
 	return res;
 }
@@ -1392,7 +1545,7 @@ static int waitstream_core(struct ast_ch
 		reverse = "";
 
 	/* Switch the channel to end DTMF frame only. waitstream_core doesn't care about the start of DTMF. */
-	ast_set_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+	ast_channel_set_flag(c, AST_FLAG_END_DTMF_ONLY);
 
 	if (ast_test_flag(ast_channel_flags(c), AST_FLAG_MASQ_NOSTREAM))
 		orig_chan_name = ast_strdupa(ast_channel_name(c));
@@ -1424,7 +1577,7 @@ static int waitstream_core(struct ast_ch
 			res = ast_waitfor(c, ms);
 			if (res < 0) {
 				ast_log(LOG_WARNING, "Select failed (%s)\n", strerror(errno));
-				ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+				ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 				return res;
 			}
 		} else {
@@ -1435,11 +1588,11 @@ static int waitstream_core(struct ast_ch
 				if (errno == EINTR)
 					continue;
 				ast_log(LOG_WARNING, "Wait failed (%s)\n", strerror(errno));
-				ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+				ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 				return -1;
 			} else if (outfd > -1) { /* this requires cmdfd set */
 				/* The FD we were watching has something waiting */
-				ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+				ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 				return 1;
 			}
 			/* if rchan is set, it is 'c' */
@@ -1448,7 +1601,7 @@ static int waitstream_core(struct ast_ch
 		if (res > 0) {
 			struct ast_frame *fr = ast_read(c);
 			if (!fr) {
-				ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+				ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 				return -1;
 			}
 			switch (fr->frametype) {
@@ -1459,7 +1612,7 @@ static int waitstream_core(struct ast_ch
 						S_COR(ast_channel_caller(c)->id.number.valid, ast_channel_caller(c)->id.number.str, NULL))) {
 						res = fr->subclass.integer;
 						ast_frfree(fr);
-						ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+						ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 						return res;
 					}
 				} else {
@@ -1475,7 +1628,7 @@ static int waitstream_core(struct ast_ch
 							"Break");
 
 						ast_frfree(fr);
-						ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+						ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 						return res;
 					}
 				}
@@ -1492,7 +1645,7 @@ static int waitstream_core(struct ast_ch
 						"Break");
 					res = fr->subclass.integer;
 					ast_frfree(fr);
-					ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+					ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 					return res;
 				case AST_CONTROL_STREAM_REVERSE:
 					if (!skip_ms) {
@@ -1510,7 +1663,7 @@ static int waitstream_core(struct ast_ch
 				case AST_CONTROL_BUSY:
 				case AST_CONTROL_CONGESTION:
 					ast_frfree(fr);
-					ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+					ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 					return -1;
 				case AST_CONTROL_RINGING:
 				case AST_CONTROL_ANSWER:
@@ -1547,7 +1700,7 @@ static int waitstream_core(struct ast_ch
 		ast_sched_runq(ast_channel_sched(c));
 	}
 
-	ast_clear_flag(ast_channel_flags(c), AST_FLAG_END_DTMF_ONLY);
+	ast_channel_clear_flag(c, AST_FLAG_END_DTMF_ONLY);
 
 	return (err || ast_channel_softhangup_internal_flag(c)) ? -1 : 0;
 }
diff -urpN asterisk-13.9.1/main/fixedjitterbuf.c asterisk-13.17.0/main/fixedjitterbuf.c
--- asterisk-13.9.1/main/fixedjitterbuf.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/fixedjitterbuf.c	2017-07-12 13:12:08.000000000 +0200
@@ -196,7 +196,6 @@ int fixed_jb_put_first(struct fixed_jb *
 	return fixed_jb_put(jb, data, ms, ts, now);
 }
 
-
 int fixed_jb_put(struct fixed_jb *jb, void *data, long ms, long ts, long now)
 {
 	struct fixed_jb_frame *frame, *next, *newframe;
@@ -349,3 +348,8 @@ int fixed_jb_remove(struct fixed_jb *jb,
 
 	return FIXED_JB_OK;
 }
+
+int fixed_jb_is_late(struct fixed_jb *jb, long ts)
+{
+	return jb->rxcore + jb->delay + ts < jb->next_delivery;
+}
diff -urpN asterisk-13.9.1/main/fixedjitterbuf.h asterisk-13.17.0/main/fixedjitterbuf.h
--- asterisk-13.9.1/main/fixedjitterbuf.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/fixedjitterbuf.h	2017-07-12 13:12:08.000000000 +0200
@@ -85,6 +85,9 @@ int fixed_jb_remove(struct fixed_jb *jb,
 
 void fixed_jb_set_force_resynch(struct fixed_jb *jb);
 
+/*! \brief Checks if the given time stamp is late */
+int fixed_jb_is_late(struct fixed_jb *jb, long ts);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
diff -urpN asterisk-13.9.1/main/format.c asterisk-13.17.0/main/format.c
--- asterisk-13.9.1/main/format.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/format.c	2017-07-12 13:12:08.000000000 +0200
@@ -377,7 +377,13 @@ const char *ast_format_get_codec_name(co
 
 int ast_format_can_be_smoothed(const struct ast_format *format)
 {
-	return format->codec->smooth;
+	/* Coalesce to 1 if non-zero */
+	return format->codec->smooth ? 1 : 0;
+}
+
+int ast_format_get_smoother_flags(const struct ast_format *format)
+{
+	return AST_SMOOTHER_FLAGS_UNPACK(format->codec->smooth);
 }
 
 enum ast_media_type ast_format_get_type(const struct ast_format *format)
diff -urpN asterisk-13.9.1/main/format_cache.c asterisk-13.17.0/main/format_cache.c
--- asterisk-13.9.1/main/format_cache.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/format_cache.c	2017-07-12 13:12:08.000000000 +0200
@@ -232,6 +232,14 @@ struct ast_format *ast_format_t140_red;
  */
 struct ast_format *ast_format_none;
 
+/*!
+ * \brief Built-in "silk" format
+ */
+struct ast_format *ast_format_silk8;
+struct ast_format *ast_format_silk12;
+struct ast_format *ast_format_silk16;
+struct ast_format *ast_format_silk24;
+
 /*! \brief Number of buckets to use for the media format cache (should be prime for performance reasons) */
 #define CACHE_BUCKETS 53
 
@@ -331,6 +339,10 @@ static void format_cache_shutdown(void)
 	ao2_replace(ast_format_t140_red, NULL);
 	ao2_replace(ast_format_t140, NULL);
 	ao2_replace(ast_format_none, NULL);
+	ao2_replace(ast_format_silk8, NULL);
+	ao2_replace(ast_format_silk12, NULL);
+	ao2_replace(ast_format_silk16, NULL);
+	ao2_replace(ast_format_silk24, NULL);
 }
 
 int ast_format_cache_init(void)
@@ -426,6 +438,14 @@ static void set_cached_format(const char
 		ao2_replace(ast_format_t140, format);
 	} else if (!strcmp(name, "none")) {
 		ao2_replace(ast_format_none, format);
+	} else if (!strcmp(name, "silk8")) {
+		ao2_replace(ast_format_silk8, format);
+	} else if (!strcmp(name, "silk12")) {
+		ao2_replace(ast_format_silk12, format);
+	} else if (!strcmp(name, "silk16")) {
+		ao2_replace(ast_format_silk16, format);
+	} else if (!strcmp(name, "silk24")) {
+		ao2_replace(ast_format_silk24, format);
 	}
 }
 
diff -urpN asterisk-13.9.1/main/format_cap.c asterisk-13.17.0/main/format_cap.c
--- asterisk-13.9.1/main/format_cap.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/format_cap.c	2017-07-12 13:12:08.000000000 +0200
@@ -361,7 +361,7 @@ int ast_format_cap_update_by_allow_disal
 	parse = ast_strdupa(list);
 
 	/* If the list is being fed to us as a result of ast_format_cap_get_names,
-	 * strip off the paranthesis and immediately apply the inverse of the
+	 * strip off the parenthesis and immediately apply the inverse of the
 	 * allowing option
 	 */
 	if (parse[0] == '(' && parse[strlen(parse) - 1] == ')') {
@@ -737,7 +737,7 @@ const char *ast_format_cap_get_names(str
 
 	ast_str_set(buf, 0, "(");
 
-	if (!AST_VECTOR_SIZE(&cap->preference_order)) {
+	if (!cap || !AST_VECTOR_SIZE(&cap->preference_order)) {
 		ast_str_append(buf, 0, "nothing)");
 		return ast_str_buffer(*buf);
 	}
diff -urpN asterisk-13.9.1/main/format_compatibility.c asterisk-13.17.0/main/format_compatibility.c
--- asterisk-13.9.1/main/format_compatibility.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/format_compatibility.c	2017-07-12 13:12:08.000000000 +0200
@@ -264,10 +264,10 @@ struct ast_format *ast_format_compatibil
 
 	/*! T.140 RED Text format RFC 4103 */
 	case AST_FORMAT_T140_RED:
-		return ast_format_t140;
+		return ast_format_t140_red;
 	/*! T.140 Text format - ITU T.140, RFC 4103 */
 	case AST_FORMAT_T140:
-		return ast_format_t140_red;
+		return ast_format_t140;
 	}
 	return NULL;
 }
diff -urpN asterisk-13.9.1/main/frame.c asterisk-13.17.0/main/frame.c
--- asterisk-13.9.1/main/frame.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/frame.c	2017-07-12 13:12:08.000000000 +0200
@@ -84,9 +84,9 @@ static struct ast_frame *ast_frame_heade
 	if ((frames = ast_threadstorage_get(&frame_cache, sizeof(*frames)))) {
 		if ((f = AST_LIST_REMOVE_HEAD(&frames->list, frame_list))) {
 			size_t mallocd_len = f->mallocd_hdr_len;
+
 			memset(f, 0, sizeof(*f));
 			f->mallocd_hdr_len = mallocd_len;
-			f->mallocd = AST_MALLOCD_HDR;
 			frames->size--;
 			return f;
 		}
@@ -141,12 +141,12 @@ static void __frame_free(struct ast_fram
 #endif
 
 	if (fr->mallocd & AST_MALLOCD_DATA) {
-		if (fr->data.ptr)
+		if (fr->data.ptr) {
 			ast_free(fr->data.ptr - fr->offset);
+		}
 	}
 	if (fr->mallocd & AST_MALLOCD_SRC) {
-		if (fr->src)
-			ast_free((void *) fr->src);
+		ast_free((void *) fr->src);
 	}
 	if (fr->mallocd & AST_MALLOCD_HDR) {
 		if ((fr->frametype == AST_FRAME_VOICE) || (fr->frametype == AST_FRAME_VIDEO) ||
@@ -208,14 +208,14 @@ struct ast_frame *ast_frisolate(struct a
 			return NULL;
 		}
 		out->frametype = fr->frametype;
+		out->subclass = fr->subclass;
 		if ((fr->frametype == AST_FRAME_VOICE) || (fr->frametype == AST_FRAME_VIDEO) ||
 			(fr->frametype == AST_FRAME_IMAGE)) {
-			out->subclass.format = ao2_bump(fr->subclass.format);
-		} else {
-			memcpy(&out->subclass, &fr->subclass, sizeof(out->subclass));
+			ao2_bump(out->subclass.format);
 		}
 		out->datalen = fr->datalen;
 		out->samples = fr->samples;
+		out->mallocd = AST_MALLOCD_HDR;
 		out->offset = fr->offset;
 		/* Copy the timing data */
 		ast_copy_flags(out, fr, AST_FLAGS_ALL);
@@ -228,47 +228,64 @@ struct ast_frame *ast_frisolate(struct a
 		out = fr;
 	}
 
-	if (!(fr->mallocd & AST_MALLOCD_SRC) && fr->src) {
-		if (!(out->src = ast_strdup(fr->src))) {
-			if (out != fr) {
-				ast_free(out);
+	if (fr->src) {
+		/* The original frame has a source string */
+		if (!(fr->mallocd & AST_MALLOCD_SRC)) {
+			/*
+			 * The original frame has a non-malloced source string.
+			 *
+			 * Duplicate the string and put it into the isolated frame
+			 * which may also be the original frame.
+			 */
+			newdata = ast_strdup(fr->src);
+			if (!newdata) {
+				if (out != fr) {
+					ast_frame_free(out, 0);
+				}
+				return NULL;
 			}
-			return NULL;
+			out->src = newdata;
+			out->mallocd |= AST_MALLOCD_SRC;
+		} else if (out != fr) {
+			/* Steal the source string from the original frame. */
+			out->src = fr->src;
+			fr->src = NULL;
+			fr->mallocd &= ~AST_MALLOCD_SRC;
+			out->mallocd |= AST_MALLOCD_SRC;
 		}
-	} else {
-		out->src = fr->src;
-		fr->src = NULL;
-		fr->mallocd &= ~AST_MALLOCD_SRC;
 	}
 
 	if (!(fr->mallocd & AST_MALLOCD_DATA))  {
+		/* The original frame has a non-malloced data buffer. */
 		if (!fr->datalen) {
+			/* Actually it's just an int so we can simply copy it. */
 			out->data.uint32 = fr->data.uint32;
-			out->mallocd = AST_MALLOCD_HDR | AST_MALLOCD_SRC;
 			return out;
 		}
-		if (!(newdata = ast_malloc(fr->datalen + AST_FRIENDLY_OFFSET))) {
-			if (out->src != fr->src) {
-				ast_free((void *) out->src);
-			}
+		/*
+		 * Duplicate the data buffer and put it into the isolated frame
+		 * which may also be the original frame.
+		 */
+		newdata = ast_malloc(fr->datalen + AST_FRIENDLY_OFFSET);
+		if (!newdata) {
 			if (out != fr) {
-				ast_free(out);
+				ast_frame_free(out, 0);
 			}
 			return NULL;
 		}
 		newdata += AST_FRIENDLY_OFFSET;
 		out->offset = AST_FRIENDLY_OFFSET;
-		out->datalen = fr->datalen;
 		memcpy(newdata, fr->data.ptr, fr->datalen);
 		out->data.ptr = newdata;
-	} else {
+		out->mallocd |= AST_MALLOCD_DATA;
+	} else if (out != fr) {
+		/* Steal the data buffer from the original frame. */
 		out->data = fr->data;
 		memset(&fr->data, 0, sizeof(fr->data));
 		fr->mallocd &= ~AST_MALLOCD_DATA;
+		out->mallocd |= AST_MALLOCD_DATA;
 	}
 
-	out->mallocd = AST_MALLOCD_HDR | AST_MALLOCD_SRC | AST_MALLOCD_DATA;
-
 	return out;
 }
 
diff -urpN asterisk-13.9.1/main/hashtab.c asterisk-13.17.0/main/hashtab.c
--- asterisk-13.9.1/main/hashtab.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/hashtab.c	2017-07-12 13:12:08.000000000 +0200
@@ -43,7 +43,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/hashtab.h"
 
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 static void _ast_hashtab_resize(struct ast_hashtab *tab, const char *file, int lineno, const char *func);
 #define ast_hashtab_resize(a)	_ast_hashtab_resize(a,__FILE__, __LINE__, __PRETTY_FUNCTION__)
 #else
@@ -218,7 +218,7 @@ unsigned int ast_hashtab_hash_short(cons
 }
 
 struct ast_hashtab *
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 _ast_hashtab_create
 #else
 ast_hashtab_create
@@ -229,14 +229,14 @@ ast_hashtab_create
 	int (*newsize)(struct ast_hashtab *tab),
 	unsigned int (*hash)(const void *obj),
 	int do_locking
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 	, const char *file, int lineno, const char *function
 #endif
 )
 {
 	struct ast_hashtab *ht;
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 	if (!(ht = __ast_calloc(1, sizeof(*ht), file, lineno, function)))
 #else
 	if (!(ht = ast_calloc(1, sizeof(*ht))))
@@ -246,7 +246,7 @@ ast_hashtab_create
 	while (!ast_is_prime(initial_buckets)) /* make sure this is prime */
 		initial_buckets++;
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 	if (!(ht->array = __ast_calloc(initial_buckets, sizeof(*(ht->array)), file, lineno, function))) {
 #else
 	if (!(ht->array = ast_calloc(initial_buckets, sizeof(*(ht->array))))) {
@@ -274,7 +274,7 @@ ast_hashtab_create
 	return ht;
 }
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab *_ast_hashtab_dup(struct ast_hashtab *tab, void *(*obj_dup_func)(const void *obj), const char *file, int lineno, const char *func)
 #else
 struct ast_hashtab *ast_hashtab_dup(struct ast_hashtab *tab, void *(*obj_dup_func)(const void *obj))
@@ -287,7 +287,7 @@ struct ast_hashtab *ast_hashtab_dup(stru
 		return NULL;
 
 	if (!(ht->array =
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 		__ast_calloc(tab->hash_tab_size, sizeof(*(ht->array)), file, lineno, func)
 #else
 		ast_calloc(tab->hash_tab_size, sizeof(*(ht->array)))
@@ -315,7 +315,7 @@ struct ast_hashtab *ast_hashtab_dup(stru
 		while (b) {
 			void *newobj = (*obj_dup_func)(b->object);
 			if (newobj)
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 				_ast_hashtab_insert_immediate_bucket(ht, newobj, i, file, lineno, func);
 #else
 				ast_hashtab_insert_immediate_bucket(ht, newobj, i);
@@ -426,7 +426,7 @@ void ast_hashtab_destroy(struct ast_hash
 	}
 }
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int _ast_hashtab_insert_immediate(struct ast_hashtab *tab, const void *obj, const char *file, int lineno, const char *func)
 #else
 int ast_hashtab_insert_immediate(struct ast_hashtab *tab, const void *obj)
@@ -443,7 +443,7 @@ int ast_hashtab_insert_immediate(struct
 
 	h = (*tab->hash)(obj) % tab->hash_tab_size;
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 	res = _ast_hashtab_insert_immediate_bucket(tab, obj, h, file, lineno, func);
 #else
 	res = ast_hashtab_insert_immediate_bucket(tab, obj, h);
@@ -455,7 +455,7 @@ int ast_hashtab_insert_immediate(struct
 	return res;
 }
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int _ast_hashtab_insert_immediate_bucket(struct ast_hashtab *tab, const void *obj, unsigned int h, const char *file, int lineno, const char *func)
 #else
 int ast_hashtab_insert_immediate_bucket(struct ast_hashtab *tab, const void *obj, unsigned int h)
@@ -474,7 +474,7 @@ int ast_hashtab_insert_immediate_bucket(
 		tab->largest_bucket_size = c + 1;
 
 	if (!(b =
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 			__ast_calloc(1, sizeof(*b), file, lineno, func)
 #else
 			ast_calloc(1, sizeof(*b))
@@ -497,7 +497,7 @@ int ast_hashtab_insert_immediate_bucket(
 	return 1;
 }
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int _ast_hashtab_insert_safe(struct ast_hashtab *tab, const void *obj, const char *file, int lineno, const char *func)
 #else
 int ast_hashtab_insert_safe(struct ast_hashtab *tab, const void *obj)
@@ -513,7 +513,7 @@ int ast_hashtab_insert_safe(struct ast_h
 		ast_rwlock_wrlock(&tab->lock);
 
 	if (!ast_hashtab_lookup_bucket(tab, obj, &bucket)) {
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 		int ret2 = _ast_hashtab_insert_immediate_bucket(tab, obj, bucket, file, lineno, func);
 #else
 		int ret2 = ast_hashtab_insert_immediate_bucket(tab, obj, bucket);
@@ -636,7 +636,7 @@ int ast_hashtab_capacity( struct ast_has
 /* the insert operation calls this, and is wrlock'd when it does. */
 /* if you want to call it, you should set the wrlock yourself */
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 static void _ast_hashtab_resize(struct ast_hashtab *tab, const char *file, int lineno, const char *func)
 #else
 static void ast_hashtab_resize(struct ast_hashtab *tab)
@@ -659,7 +659,7 @@ static void ast_hashtab_resize(struct as
 	}
 	free(tab->array);
 	if (!(tab->array =
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 		__ast_calloc(newsize, sizeof(*(tab->array)), file, lineno, func)
 #else
 		ast_calloc(newsize, sizeof(*(tab->array)))
@@ -690,7 +690,7 @@ static void ast_hashtab_resize(struct as
 	}
 }
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab_iter *_ast_hashtab_start_traversal(struct ast_hashtab *tab, const char *file, int lineno, const char *func)
 #else
 struct ast_hashtab_iter *ast_hashtab_start_traversal(struct ast_hashtab *tab)
@@ -700,7 +700,7 @@ struct ast_hashtab_iter *ast_hashtab_sta
 	struct ast_hashtab_iter *it;
 
 	if (!(it =
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 			__ast_calloc(1, sizeof(*it), file, lineno, func)
 #else
 			ast_calloc(1, sizeof(*it))
@@ -717,7 +717,7 @@ struct ast_hashtab_iter *ast_hashtab_sta
 }
 
 /* use this function to get a write lock */
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 struct ast_hashtab_iter *_ast_hashtab_start_write_traversal(struct ast_hashtab *tab, const char *file, int lineno, const char *func)
 #else
 struct ast_hashtab_iter *ast_hashtab_start_write_traversal(struct ast_hashtab *tab)
@@ -727,7 +727,7 @@ struct ast_hashtab_iter *ast_hashtab_sta
 	struct ast_hashtab_iter *it;
 
 	if (!(it =
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 			__ast_calloc(1, sizeof(*it), file, lineno, func)
 #else
 			ast_calloc(1, sizeof(*it))
diff -urpN asterisk-13.9.1/main/heap.c asterisk-13.17.0/main/heap.c
--- asterisk-13.9.1/main/heap.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/heap.c	2017-07-12 13:12:08.000000000 +0200
@@ -111,7 +111,7 @@ int ast_heap_verify(struct ast_heap *h)
 	return 0;
 }
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 struct ast_heap *_ast_heap_create(unsigned int init_height, ast_heap_cmp_fn cmp_fn,
 		ssize_t index_offset, const char *file, int lineno, const char *func)
 #else
@@ -131,7 +131,7 @@ struct ast_heap *ast_heap_create(unsigne
 	}
 
 	if (!(h =
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 			__ast_calloc(1, sizeof(*h), file, lineno, func)
 #else
 			ast_calloc(1, sizeof(*h))
@@ -145,7 +145,7 @@ struct ast_heap *ast_heap_create(unsigne
 	h->avail_len = (1 << init_height) - 1;
 
 	if (!(h->heap =
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 			__ast_calloc(1, h->avail_len * sizeof(void *), file, lineno, func)
 #else
 			ast_calloc(1, h->avail_len * sizeof(void *))
@@ -176,7 +176,7 @@ struct ast_heap *ast_heap_destroy(struct
  * \brief Add a row of additional storage for the heap.
  */
 static int grow_heap(struct ast_heap *h
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 , const char *file, int lineno, const char *func
 #endif
 )
@@ -184,7 +184,7 @@ static int grow_heap(struct ast_heap *h
 	void **new_heap;
 	size_t new_len = h->avail_len * 2 + 1;
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 	new_heap = __ast_realloc(h->heap, new_len * sizeof(void *), file, lineno, func);
 #else
 	new_heap = ast_realloc(h->heap, new_len * sizeof(void *));
@@ -244,14 +244,14 @@ static int bubble_up(struct ast_heap *h,
 	return i;
 }
 
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 int _ast_heap_push(struct ast_heap *h, void *elm, const char *file, int lineno, const char *func)
 #else
 int ast_heap_push(struct ast_heap *h, void *elm)
 #endif
 {
 	if (h->cur_len == h->avail_len && grow_heap(h
-#ifdef MALLOC_DEBUG
+#ifdef __AST_DEBUG_MALLOC
 		, file, lineno, func
 #endif
 		)) {
diff -urpN asterisk-13.9.1/main/http.c asterisk-13.17.0/main/http.c
--- asterisk-13.9.1/main/http.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/http.c	2017-07-12 13:12:08.000000000 +0200
@@ -526,6 +526,10 @@ void ast_http_send(struct ast_tcptls_ses
 	/* send content */
 	if (method != AST_HTTP_HEAD || status_code >= 400) {
 		if (out && ast_str_strlen(out)) {
+			/*
+			 * NOTE: Because ser->f is a non-standard FILE *, fwrite() will probably not
+			 * behave exactly as documented.
+			 */
 			if (fwrite(ast_str_buffer(out), ast_str_strlen(out), 1, ser->f) != 1) {
 				ast_log(LOG_ERROR, "fwrite() failed: %s\n", strerror(errno));
 				close_connection = 1;
@@ -537,6 +541,10 @@ void ast_http_send(struct ast_tcptls_ses
 			int len;
 
 			while ((len = read(fd, buf, sizeof(buf))) > 0) {
+				/*
+				 * NOTE: Because ser->f is a non-standard FILE *, fwrite() will probably not
+				 * behave exactly as documented.
+				 */
 				if (fwrite(buf, len, 1, ser->f) != 1) {
 					ast_log(LOG_WARNING, "fwrite() failed: %s\n", strerror(errno));
 					close_connection = 1;
@@ -671,6 +679,8 @@ int ast_http_uri_link(struct ast_http_ur
 
 	AST_RWLIST_WRLOCK(&uris);
 
+	urih->prefix = prefix;
+
 	if ( AST_RWLIST_EMPTY(&uris) || strlen(AST_RWLIST_FIRST(&uris)->uri) <= len ) {
 		AST_RWLIST_INSERT_HEAD(&uris, urih, entry);
 		AST_RWLIST_UNLOCK(&uris);
@@ -921,6 +931,11 @@ static int http_body_read_contents(struc
 {
 	int res;
 
+	/*
+	 * NOTE: Because ser->f is a non-standard FILE *, fread() does not behave as
+	 * documented.
+	 */
+
 	/* Stay in fread until get all the expected data or timeout. */
 	res = fread(buf, length, 1, ser->f);
 	if (res < 1) {
@@ -948,6 +963,11 @@ static int http_body_discard_contents(st
 	int res;
 	char buf[MAX_HTTP_LINE_LENGTH];/* Discard buffer */
 
+	/*
+	 * NOTE: Because ser->f is a non-standard FILE *, fread() does not behave as
+	 * documented.
+	 */
+
 	/* Stay in fread until get all the expected data or timeout. */
 	while (sizeof(buf) < length) {
 		res = fread(buf, sizeof(buf), 1, ser->f);
@@ -1064,6 +1084,11 @@ static int http_body_check_chunk_sync(st
 	int res;
 	char chunk_sync[2];
 
+	/*
+	 * NOTE: Because ser->f is a non-standard FILE *, fread() does not behave as
+	 * documented.
+	 */
+
 	/* Stay in fread until get the expected CRLF or timeout. */
 	res = fread(chunk_sync, sizeof(chunk_sync), 1, ser->f);
 	if (res < 1) {
@@ -1913,8 +1938,7 @@ static int httpd_process_request(struct
 static void *httpd_helper_thread(void *data)
 {
 	struct ast_tcptls_session_instance *ser = data;
-	struct protoent *p;
-	int flags;
+	int flags = 1;
 	int timeout;
 
 	if (!ser || !ser->f) {
@@ -1934,17 +1958,8 @@ static void *httpd_helper_thread(void *d
 	 * This is necessary to prevent delays (caused by buffering) as we
 	 * write to the socket in bits and pieces.
 	 */
-	p = getprotobyname("tcp");
-	if (p) {
-		int arg = 1;
-
-		if (setsockopt(ser->fd, p->p_proto, TCP_NODELAY, (char *) &arg, sizeof(arg) ) < 0) {
-			ast_log(LOG_WARNING, "Failed to set TCP_NODELAY on HTTP connection: %s\n", strerror(errno));
-			ast_log(LOG_WARNING, "Some HTTP requests may be slow to respond.\n");
-		}
-	} else {
-		ast_log(LOG_WARNING, "Failed to set TCP_NODELAY on HTTP connection, getprotobyname(\"tcp\") failed\n");
-		ast_log(LOG_WARNING, "Some HTTP requests may be slow to respond.\n");
+	if (setsockopt(ser->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &flags, sizeof(flags)) < 0) {
+		ast_log(LOG_WARNING, "Failed to set TCP_NODELAY on HTTP connection: %s\n", strerror(errno));
 	}
 
 	/* make sure socket is non-blocking */
@@ -2092,22 +2107,20 @@ static int __ast_http_load(int reload)
 	http_tls_was_enabled = (reload && http_tls_cfg.enabled);
 
 	http_tls_cfg.enabled = 0;
-	if (http_tls_cfg.certfile) {
-		ast_free(http_tls_cfg.certfile);
-	}
+
+	ast_free(http_tls_cfg.certfile);
 	http_tls_cfg.certfile = ast_strdup(AST_CERTFILE);
 
-	if (http_tls_cfg.pvtfile) {
-		ast_free(http_tls_cfg.pvtfile);
-	}
+	ast_free(http_tls_cfg.capath);
+	http_tls_cfg.capath = ast_strdup("");
+
+	ast_free(http_tls_cfg.pvtfile);
 	http_tls_cfg.pvtfile = ast_strdup("");
 
 	/* Apply modern intermediate settings according to the Mozilla OpSec team as of July 30th, 2015 but disable TLSv1 */
 	ast_set_flag(&http_tls_cfg.flags, AST_SSL_DISABLE_TLSV1 | AST_SSL_SERVER_CIPHER_ORDER);
 
-	if (http_tls_cfg.cipher) {
-		ast_free(http_tls_cfg.cipher);
-	}
+	ast_free(http_tls_cfg.cipher);
 	http_tls_cfg.cipher = ast_strdup("ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA");
 
 	AST_RWLIST_WRLOCK(&uri_redirects);
@@ -2220,7 +2233,7 @@ static int __ast_http_load(int reload)
 		 * the non-TLS bindaddress here.
 		 */
 		if (ast_sockaddr_isnull(&https_desc.local_address) && http_desc.accept_fd != -1) {
-			ast_sockaddr_copy(&https_desc.local_address, &https_desc.local_address);
+			ast_sockaddr_copy(&https_desc.local_address, &http_desc.local_address);
 			/* Of course, we can't use the same port though.
 			 * Since no bind address was specified, we just use the
 			 * default TLS port
@@ -2321,6 +2334,7 @@ static void http_shutdown(void)
 		ast_tcptls_server_stop(&https_desc);
 	}
 	ast_free(http_tls_cfg.certfile);
+	ast_free(http_tls_cfg.capath);
 	ast_free(http_tls_cfg.pvtfile);
 	ast_free(http_tls_cfg.cipher);
 
diff -urpN asterisk-13.9.1/main/io.c asterisk-13.17.0/main/io.c
--- asterisk-13.9.1/main/io.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/io.c	2017-07-12 13:12:08.000000000 +0200
@@ -36,6 +36,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #include "asterisk/io.h"
 #include "asterisk/utils.h"
+#ifdef HAVE_SYSTEMD
+#include <systemd/sd-daemon.h>
+#endif
 
 #ifdef DEBUG_IO
 #define DEBUG DEBUG_M
@@ -384,3 +387,10 @@ int ast_get_termcols(int fd)
 	return cols;
 }
 
+int ast_sd_notify(const char *state) {
+#ifdef HAVE_SYSTEMD
+	return sd_notify(0, state);
+#else
+	return 0;
+#endif
+}
diff -urpN asterisk-13.9.1/main/jitterbuf.c asterisk-13.17.0/main/jitterbuf.c
--- asterisk-13.9.1/main/jitterbuf.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/jitterbuf.c	2017-07-12 13:12:08.000000000 +0200
@@ -845,4 +845,7 @@ enum jb_return_code jb_setconf(jitterbuf
 	return JB_OK;
 }
 
-
+int jb_is_late(jitterbuf *jb, long ts)
+{
+	return ts + jb->info.current < jb->info.next_voice_ts;
+}
diff -urpN asterisk-13.9.1/main/json.c asterisk-13.17.0/main/json.c
--- asterisk-13.9.1/main/json.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/json.c	2017-07-12 13:12:08.000000000 +0200
@@ -269,6 +269,127 @@ const char *ast_json_typename(enum ast_j
 	return "?";
 }
 
+/* Ported from libjansson utf.c:utf8_check_first() */
+static size_t json_utf8_check_first(char byte)
+{
+	unsigned char ch = (unsigned char) byte;
+
+	if (ch < 0x80) {
+		return 1;
+	}
+
+	if (0x80 <= ch && ch <= 0xBF) {
+		/* second, third or fourth byte of a multi-byte
+		   sequence, i.e. a "continuation byte" */
+		return 0;
+	} else if (ch == 0xC0 || ch == 0xC1) {
+		/* overlong encoding of an ASCII byte */
+		return 0;
+	} else if (0xC2 <= ch && ch <= 0xDF) {
+		/* 2-byte sequence */
+		return 2;
+	} else if (0xE0 <= ch && ch <= 0xEF) {
+		/* 3-byte sequence */
+		return 3;
+	} else if (0xF0 <= ch && ch <= 0xF4) {
+		/* 4-byte sequence */
+		return 4;
+	} else { /* ch >= 0xF5 */
+		/* Restricted (start of 4-, 5- or 6-byte sequence) or invalid
+		   UTF-8 */
+		return 0;
+	}
+}
+
+/* Ported from libjansson utf.c:utf8_check_full() */
+static size_t json_utf8_check_full(const char *str, size_t len)
+{
+	size_t pos;
+	int32_t value;
+	unsigned char ch = (unsigned char) str[0];
+
+	if (len == 2) {
+		value = ch & 0x1F;
+	} else if (len == 3) {
+		value = ch & 0xF;
+	} else if (len == 4) {
+		value = ch & 0x7;
+	} else {
+		return 0;
+	}
+
+	for (pos = 1; pos < len; ++pos) {
+		ch = (unsigned char) str[pos];
+		if (ch < 0x80 || ch > 0xBF) {
+			/* not a continuation byte */
+			return 0;
+		}
+
+		value = (value << 6) + (ch & 0x3F);
+	}
+
+	if (value > 0x10FFFF) {
+		/* not in Unicode range */
+		return 0;
+	} else if (0xD800 <= value && value <= 0xDFFF) {
+		/* invalid code point (UTF-16 surrogate halves) */
+		return 0;
+	} else if ((len == 2 && value < 0x80)
+		|| (len == 3 && value < 0x800)
+		|| (len == 4 && value < 0x10000)) {
+		/* overlong encoding */
+		return 0;
+	}
+
+	return 1;
+}
+
+int ast_json_utf8_check_len(const char *str, size_t len)
+{
+	size_t pos;
+	size_t count;
+	int res = 1;
+
+	if (!str) {
+		return 0;
+	}
+
+	/*
+	 * Since the json library does not make the check function
+	 * public we recreate/copy the function in our interface
+	 * module.
+	 *
+	 * Loop ported from libjansson utf.c:utf8_check_string()
+	 */
+	for (pos = 0; pos < len; pos += count) {
+		count = json_utf8_check_first(str[pos]);
+		if (count == 0) {
+			res = 0;
+			break;
+		} else if (count > 1) {
+			if (count > len - pos) {
+				/* UTF-8 needs more than we have left in the string. */
+				res = 0;
+				break;
+			}
+
+			if (!json_utf8_check_full(&str[pos], count)) {
+				res = 0;
+				break;
+			}
+		}
+	}
+
+	if (!res) {
+		ast_debug(1, "String '%.*s' is not UTF-8 for json conversion\n", (int) len, str);
+	}
+	return res;
+}
+
+int ast_json_utf8_check(const char *str)
+{
+	return str ? ast_json_utf8_check_len(str, strlen(str)) : 0;
+}
 
 struct ast_json *ast_json_true(void)
 {
@@ -721,16 +842,16 @@ struct ast_json *ast_json_deep_copy(cons
 struct ast_json *ast_json_name_number(const char *name, const char *number)
 {
 	return ast_json_pack("{s: s, s: s}",
-			     "name", name,
-			     "number", number);
+		"name", AST_JSON_UTF8_VALIDATE(name),
+		"number", AST_JSON_UTF8_VALIDATE(number));
 }
 
 struct ast_json *ast_json_dialplan_cep(const char *context, const char *exten, int priority)
 {
 	return ast_json_pack("{s: o, s: o, s: o}",
-			     "context", context ? ast_json_string_create(context) : ast_json_null(),
-			     "exten", exten ? ast_json_string_create(exten) : ast_json_null(),
-			     "priority", priority != -1 ? ast_json_integer_create(priority) : ast_json_null());
+		"context", context ? ast_json_string_create(context) : ast_json_null(),
+		"exten", exten ? ast_json_string_create(exten) : ast_json_null(),
+		"priority", priority != -1 ? ast_json_integer_create(priority) : ast_json_null());
 }
 
 struct ast_json *ast_json_timeval(const struct timeval tv, const char *zone)
@@ -821,7 +942,7 @@ static struct ast_json *json_party_numbe
 		return NULL;
 	}
 	return ast_json_pack("{s: s, s: i, s: i, s: s}",
-		"number", number->str,
+		"number", AST_JSON_UTF8_VALIDATE(number->str),
 		"plan", number->plan,
 		"presentation", number->presentation,
 		"presentation_txt", ast_describe_caller_presentation(number->presentation));
@@ -833,7 +954,7 @@ static struct ast_json *json_party_name(
 		return NULL;
 	}
 	return ast_json_pack("{s: s, s: s, s: i, s: s}",
-		"name", name->str,
+		"name", AST_JSON_UTF8_VALIDATE(name->str),
 		"character_set", ast_party_name_charset_describe(name->char_set),
 		"presentation", name->presentation,
 		"presentation_txt", ast_describe_caller_presentation(name->presentation));
@@ -845,7 +966,7 @@ static struct ast_json *json_party_subad
 		return NULL;
 	}
 	return ast_json_pack("{s: s, s: i, s: b}",
-		"subaddress", subaddress->str,
+		"subaddress", AST_JSON_UTF8_VALIDATE(subaddress->str),
 		"type", subaddress->type,
 		"odd", subaddress->odd_even_indicator);
 }
@@ -865,17 +986,20 @@ struct ast_json *ast_json_party_id(struc
 	}
 
 	/* Party number */
-	if (party->number.valid && ast_json_object_set(json_party_id, "number", json_party_number(&party->number))) {
+	if (party->number.valid
+		&& ast_json_object_set(json_party_id, "number", json_party_number(&party->number))) {
 		return NULL;
 	}
 
 	/* Party name */
-	if (party->name.valid && ast_json_object_set(json_party_id, "name", json_party_name(&party->name))) {
+	if (party->name.valid
+		&& ast_json_object_set(json_party_id, "name", json_party_name(&party->name))) {
 		return NULL;
 	}
 
 	/* Party subaddress */
-	if (party->subaddress.valid && ast_json_object_set(json_party_id, "subaddress", json_party_subaddress(&party->subaddress))) {
+	if (party->subaddress.valid
+		&& ast_json_object_set(json_party_id, "subaddress", json_party_subaddress(&party->subaddress))) {
 		return NULL;
 	}
 
diff -urpN asterisk-13.9.1/main/libasteriskpj.c asterisk-13.17.0/main/libasteriskpj.c
--- asterisk-13.9.1/main/libasteriskpj.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/libasteriskpj.c	2017-07-12 13:12:08.000000000 +0200
@@ -37,6 +37,7 @@ ASTERISK_REGISTER_FILE()
 #include <pjlib.h>
 #endif
 
+#include "asterisk/options.h"
 #include "asterisk/_private.h" /* ast_pj_init() */
 
 /*!
@@ -46,6 +47,7 @@ ASTERISK_REGISTER_FILE()
 int ast_pj_init(void)
 {
 #ifdef HAVE_PJPROJECT_BUNDLED
+	AST_PJPROJECT_INIT_LOG_LEVEL();
 	pj_init();
 #endif
 	return 0;
diff -urpN asterisk-13.9.1/main/libasteriskssl.c asterisk-13.17.0/main/libasteriskssl.c
--- asterisk-13.9.1/main/libasteriskssl.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/libasteriskssl.c	2017-07-12 13:12:08.000000000 +0200
@@ -67,13 +67,14 @@ static void ssl_lock(int mode, int n, co
 		return;
 	}
 
-	if (mode & CRYPTO_LOCK) {
+	if (mode & 0x1) {
 		ast_mutex_lock(&ssl_locks[n]);
 	} else {
 		ast_mutex_unlock(&ssl_locks[n]);
 	}
 }
 
+#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
 int SSL_library_init(void)
 {
 #if defined(AST_DEVMODE)
@@ -115,16 +116,20 @@ void ERR_free_strings(void)
 {
 	/* we can't allow this to be called, ever */
 }
+#endif /* !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L */
 
 #endif /* HAVE_OPENSSL */
 
 /*!
  * \internal
  * \brief Common OpenSSL initialization for all of Asterisk.
+ *
+ * Not needed for OpenSSL versions >= 1.1.0
  */
 int ast_ssl_init(void)
 {
-#ifdef HAVE_OPENSSL
+#if defined(HAVE_OPENSSL) && defined(OPENSSL_VERSION_NUMBER) && \
+	(OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
 	unsigned int i;
 	int (*real_SSL_library_init)(void);
 	void (*real_CRYPTO_set_id_callback)(unsigned long (*)(void));
@@ -189,7 +194,7 @@ int ast_ssl_init(void)
 
 	startup_complete = 1;
 
-#endif /* HAVE_OPENSSL */
+#endif /* HAVE_OPENSSL and its version < 1.1 */
 	return 0;
 }
 
diff -urpN asterisk-13.9.1/main/loader.c asterisk-13.17.0/main/loader.c
--- asterisk-13.9.1/main/loader.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/loader.c	2017-07-12 13:12:08.000000000 +0200
@@ -111,10 +111,6 @@ static const unsigned char expected_key[
 
 static char buildopt_sum[33] = AST_BUILDOPT_SUM;
 
-static unsigned int embedding = 1; /* we always start out by registering embedded modules,
-				      since they are here before we dlopen() any
-				   */
-
 /*!
  * \brief Internal flag to indicate all modules have been initially loaded.
  */
@@ -150,14 +146,6 @@ const char *ast_module_name(const struct
 	return mod->info->name;
 }
 
-/*
- * module_list is cleared by its constructor possibly after
- * we start accumulating embedded modules, so we need to
- * use another list (without the lock) to accumulate them.
- * Then we update the main list when embedding is done.
- */
-static struct module_list embedded_module_list;
-
 struct loadupdate {
 	int (*updater)(void);
 	AST_LIST_ENTRY(loadupdate) entry;
@@ -186,15 +174,7 @@ static struct ast_module *resource_being
 
 void ast_module_register(const struct ast_module_info *info)
 {
-	struct ast_module *mod;
-
-	if (embedding) {
-		if (!(mod = ast_calloc(1, sizeof(*mod) + strlen(info->name) + 1)))
-			return;
-		strcpy(mod->resource, info->name);
-	} else {
-		mod = resource_being_loaded;
-	}
+	struct ast_module *mod = resource_being_loaded;
 
 	ast_debug(5, "Registering module %s\n", info->name);
 
@@ -210,18 +190,14 @@ void ast_module_register(const struct as
 	   might be unsafe to use the list lock at that point... so
 	   let's avoid it altogether
 	*/
-	if (embedding) {
-		AST_DLLIST_INSERT_TAIL(&embedded_module_list, mod, entry);
-	} else {
-		AST_DLLIST_LOCK(&module_list);
-		/* it is paramount that the new entry be placed at the tail of
-		   the list, otherwise the code that uses dlopen() to load
-		   dynamic modules won't be able to find out if the module it
-		   just opened was registered or failed to load
-		*/
-		AST_DLLIST_INSERT_TAIL(&module_list, mod, entry);
-		AST_DLLIST_UNLOCK(&module_list);
-	}
+	AST_DLLIST_LOCK(&module_list);
+	/* it is paramount that the new entry be placed at the tail of
+	   the list, otherwise the code that uses dlopen() to load
+	   dynamic modules won't be able to find out if the module it
+	   just opened was registered or failed to load
+	*/
+	AST_DLLIST_INSERT_TAIL(&module_list, mod, entry);
+	AST_DLLIST_UNLOCK(&module_list);
 
 	/* give the module a copy of its own handle, for later use in registrations and the like */
 	*((struct ast_module **) &(info->self)) = mod;
@@ -437,8 +413,6 @@ static struct ast_module *find_resource(
 	return cur;
 }
 
-#ifdef LOADABLE_MODULES
-
 /*!
  * \brief dlclose(), with failure logging.
  */
@@ -611,9 +585,7 @@ static struct ast_module *load_dynamic_m
 	return AST_DLLIST_LAST(&module_list);
 }
 
-#endif
-
-void ast_module_shutdown(void)
+int modules_shutdown(void)
 {
 	struct ast_module *mod;
 	int somethingchanged = 1, final = 0;
@@ -663,7 +635,10 @@ void ast_module_shutdown(void)
 		}
 	} while (somethingchanged && !final);
 
+	final = AST_DLLIST_EMPTY(&module_list);
 	AST_DLLIST_UNLOCK(&module_list);
+
+	return !final;
 }
 
 int ast_unload_resource(const char *resource_name, enum ast_module_unload_mode force)
@@ -726,18 +701,11 @@ int ast_unload_resource(const char *reso
 
 	AST_DLLIST_UNLOCK(&module_list);
 
-	if (!error && !mod->lib && mod->info && mod->info->restore_globals)
-		mod->info->restore_globals();
-
-#ifdef LOADABLE_MODULES
 	if (!error) {
 		unload_dynamic_module(mod);
 		ast_test_suite_event_notify("MODULE_UNLOAD", "Message: %s", resource_name);
-	}
-#endif
-
-	if (!error)
 		ast_update_use_count();
+	}
 
 	return res;
 }
@@ -897,6 +865,7 @@ enum ast_module_reload_result ast_module
 		res = AST_MODULE_RELOAD_IN_PROGRESS;
 		goto module_reload_exit;
 	}
+	ast_sd_notify("RELOAD=1");
 	ast_lastreloadtime = ast_tvnow();
 
 	if (ast_opt_lock_confdir) {
@@ -910,9 +879,8 @@ enum ast_module_reload_result ast_module
 		}
 		if (res != AST_LOCK_SUCCESS) {
 			ast_log(AST_LOG_WARNING, "Cannot grab lock on %s\n", ast_config_AST_CONFIG_DIR);
-			ast_mutex_unlock(&reloadlock);
 			res = AST_MODULE_RELOAD_ERROR;
-			goto module_reload_exit;
+			goto module_reload_done;
 		}
 	}
 
@@ -929,8 +897,7 @@ enum ast_module_reload_result ast_module
 		if (ast_opt_lock_confdir) {
 			ast_unlock_path(ast_config_AST_CONFIG_DIR);
 		}
-		ast_mutex_unlock(&reloadlock);
-		goto module_reload_exit;
+		goto module_reload_done;
 	}
 
 	AST_DLLIST_LOCK(&module_list);
@@ -972,7 +939,9 @@ enum ast_module_reload_result ast_module
 	if (ast_opt_lock_confdir) {
 		ast_unlock_path(ast_config_AST_CONFIG_DIR);
 	}
+module_reload_done:
 	ast_mutex_unlock(&reloadlock);
+	ast_sd_notify("READY=1");
 
 module_reload_exit:
 	publish_reload_message(name, res);
@@ -1076,7 +1045,6 @@ static enum ast_module_load_result load_
 		if (global_symbols_only && !ast_test_flag(mod->info, AST_MODFLAG_GLOBAL_SYMBOLS))
 			return AST_MODULE_LOAD_SKIP;
 	} else {
-#ifdef LOADABLE_MODULES
 		mod = load_dynamic_module(resource_name, global_symbols_only, suppress_logging, resource_heap);
 		if (mod == MODULE_LOCAL_ONLY) {
 				return AST_MODULE_LOAD_SKIP;
@@ -1087,22 +1055,11 @@ static enum ast_module_load_result load_
 			}
 			return required ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_DECLINE;
 		}
-#else
-		ast_log(LOG_WARNING, "Module support is not available. Module '%s' could not be loaded.\n", resource_name);
-		return required ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_DECLINE;
-#endif
 	}
 
 	if (inspect_module(mod)) {
 		ast_log(LOG_WARNING, "Module '%s' could not be loaded.\n", resource_name);
-#ifdef LOADABLE_MODULES
 		unload_dynamic_module(mod);
-#endif
-		return required ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_DECLINE;
-	}
-
-	if (!mod->lib && mod->info->backup_globals && mod->info->backup_globals()) {
-		ast_log(LOG_WARNING, "Module '%s' was unable to backup its global data.\n", resource_name);
 		return required ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -1294,6 +1251,7 @@ static int load_resource_list(struct loa
 		case AST_MODULE_LOAD_DECLINE:
 			break;
 		case AST_MODULE_LOAD_FAILURE:
+			ast_log(LOG_ERROR, "*** Failed to load module %s\n", mod->resource);
 			res = -1;
 			goto done;
 		case AST_MODULE_LOAD_SKIP:
@@ -1320,7 +1278,6 @@ done:
 int load_modules(unsigned int preload_only)
 {
 	struct ast_config *cfg;
-	struct ast_module *mod;
 	struct load_order_entry *order;
 	struct ast_variable *v;
 	unsigned int load_count;
@@ -1328,14 +1285,8 @@ int load_modules(unsigned int preload_on
 	int res = 0;
 	struct ast_flags config_flags = { 0 };
 	int modulecount = 0;
-
-#ifdef LOADABLE_MODULES
 	struct dirent *dirent;
 	DIR *dir;
-#endif
-
-	/* all embedded modules have registered themselves by now */
-	embedding = 0;
 
 	ast_verb(1, "Asterisk Dynamic Loader Starting:\n");
 
@@ -1343,12 +1294,6 @@ int load_modules(unsigned int preload_on
 
 	AST_DLLIST_LOCK(&module_list);
 
-	if (embedded_module_list.first) {
-		module_list.first = embedded_module_list.first;
-		module_list.last = embedded_module_list.last;
-		embedded_module_list.first = NULL;
-	}
-
 	cfg = ast_config_load2(AST_MODULE_CONFIG, "" /* core, can't reload */, config_flags);
 	if (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEINVALID) {
 		ast_log(LOG_WARNING, "No '%s' found, no modules will be loaded.\n", AST_MODULE_CONFIG);
@@ -1370,19 +1315,6 @@ int load_modules(unsigned int preload_on
 
 	/* check if 'autoload' is on */
 	if (!preload_only && ast_true(ast_variable_retrieve(cfg, "modules", "autoload"))) {
-		/* if so, first add all the embedded modules that are not already running to the load order */
-		AST_DLLIST_TRAVERSE(&module_list, mod, entry) {
-			/* if it's not embedded, skip it */
-			if (mod->lib)
-				continue;
-
-			if (mod->flags.running)
-				continue;
-
-			add_to_load_order(mod->resource, &load_order, 0);
-		}
-
-#ifdef LOADABLE_MODULES
 		/* if we are allowed to load dynamic modules, scan the directory for
 		   for all available modules and add them as well */
 		if ((dir = opendir(ast_config_AST_MODULE_DIR))) {
@@ -1411,7 +1343,6 @@ int load_modules(unsigned int preload_on
 				ast_log(LOG_WARNING, "Unable to open modules directory '%s'.\n",
 					ast_config_AST_MODULE_DIR);
 		}
-#endif
 	}
 
 	/* now scan the config for any modules we are prohibited from loading and
diff -urpN asterisk-13.9.1/main/lock.c asterisk-13.17.0/main/lock.c
--- asterisk-13.9.1/main/lock.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/lock.c	2017-07-12 13:12:08.000000000 +0200
@@ -218,7 +218,7 @@ lt_cleanup:
 		lt->lineno[0] = lineno;
 		lt->func[0] = func;
 		lt->reentrancy = 0;
-		lt->thread[0] = 0;
+		lt->thread_id[0] = 0;
 #ifdef HAVE_BKTR
 		memset(&lt->backtrace[0], 0, sizeof(lt->backtrace[0]));
 #endif
@@ -322,7 +322,7 @@ int __ast_pthread_mutex_lock(const char
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = lineno;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		} else {
 			__ast_mutex_logger("%s line %d (%s): '%s' really deep reentrancy!\n",
@@ -402,7 +402,7 @@ int __ast_pthread_mutex_trylock(const ch
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = lineno;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		} else {
 			__ast_mutex_logger("%s line %d (%s): '%s' really deep reentrancy!\n",
@@ -445,7 +445,7 @@ int __ast_pthread_mutex_unlock(const cha
 
 	if (lt) {
 		ast_reentrancy_lock(lt);
-		if (lt->reentrancy && (lt->thread[ROFFSET] != pthread_self())) {
+		if (lt->reentrancy && (lt->thread_id[ROFFSET] != pthread_self())) {
 			__ast_mutex_logger("%s line %d (%s): attempted unlock mutex '%s' without owning it!\n",
 					   filename, lineno, func, mutex_name);
 			__ast_mutex_logger("%s line %d (%s): '%s' was locked here.\n",
@@ -466,7 +466,7 @@ int __ast_pthread_mutex_unlock(const cha
 			lt->file[lt->reentrancy] = NULL;
 			lt->lineno[lt->reentrancy] = 0;
 			lt->func[lt->reentrancy] = NULL;
-			lt->thread[lt->reentrancy] = 0;
+			lt->thread_id[lt->reentrancy] = 0;
 		}
 
 #ifdef HAVE_BKTR
@@ -536,7 +536,7 @@ static void restore_lock_tracking(struct
 	memcpy(lt->lineno, lt_saved->lineno, sizeof(lt->lineno));
 	lt->reentrancy = lt_saved->reentrancy;
 	memcpy(lt->func, lt_saved->func, sizeof(lt->func));
-	memcpy(lt->thread, lt_saved->thread, sizeof(lt->thread));
+	memcpy(lt->thread_id, lt_saved->thread_id, sizeof(lt->thread_id));
 #ifdef HAVE_BKTR
 	memcpy(lt->backtrace, lt_saved->backtrace, sizeof(lt->backtrace));
 #endif
@@ -571,7 +571,7 @@ int __ast_cond_wait(const char *filename
 
 	if (lt) {
 		ast_reentrancy_lock(lt);
-		if (lt->reentrancy && (lt->thread[ROFFSET] != pthread_self())) {
+		if (lt->reentrancy && (lt->thread_id[ROFFSET] != pthread_self())) {
 			__ast_mutex_logger("%s line %d (%s): attempted wait using mutex '%s' without owning it!\n",
 					   filename, lineno, func, mutex_name);
 			__ast_mutex_logger("%s line %d (%s): '%s' was locked here.\n",
@@ -639,7 +639,7 @@ int __ast_cond_timedwait(const char *fil
 
 	if (lt) {
 		ast_reentrancy_lock(lt);
-		if (lt->reentrancy && (lt->thread[ROFFSET] != pthread_self())) {
+		if (lt->reentrancy && (lt->thread_id[ROFFSET] != pthread_self())) {
 			__ast_mutex_logger("%s line %d (%s): attempted wait using mutex '%s' without owning it!\n",
 					   filename, lineno, func, mutex_name);
 			__ast_mutex_logger("%s line %d (%s): '%s' was locked here.\n",
@@ -747,7 +747,7 @@ lt_cleanup:
 		lt->lineno[0] = lineno;
 		lt->func[0] = func;
 		lt->reentrancy = 0;
-		lt->thread[0] = 0;
+		lt->thread_id[0] = 0;
 #ifdef HAVE_BKTR
 		memset(&lt->backtrace[0], 0, sizeof(lt->backtrace[0]));
 #endif
@@ -790,13 +790,13 @@ int __ast_rwlock_unlock(const char *file
 			int i;
 			pthread_t self = pthread_self();
 			for (i = lt->reentrancy - 1; i >= 0; --i) {
-				if (lt->thread[i] == self) {
+				if (lt->thread_id[i] == self) {
 					lock_found = 1;
 					if (i != lt->reentrancy - 1) {
 						lt->file[i] = lt->file[lt->reentrancy - 1];
 						lt->lineno[i] = lt->lineno[lt->reentrancy - 1];
 						lt->func[i] = lt->func[lt->reentrancy - 1];
-						lt->thread[i] = lt->thread[lt->reentrancy - 1];
+						lt->thread_id[i] = lt->thread_id[lt->reentrancy - 1];
 					}
 #ifdef HAVE_BKTR
 					bt = &lt->backtrace[i];
@@ -804,7 +804,7 @@ int __ast_rwlock_unlock(const char *file
 					lt->file[lt->reentrancy - 1] = NULL;
 					lt->lineno[lt->reentrancy - 1] = 0;
 					lt->func[lt->reentrancy - 1] = NULL;
-					lt->thread[lt->reentrancy - 1] = AST_PTHREADT_NULL;
+					lt->thread_id[lt->reentrancy - 1] = AST_PTHREADT_NULL;
 					break;
 				}
 			}
@@ -918,7 +918,7 @@ int __ast_rwlock_rdlock(const char *file
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = line;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		}
 		ast_reentrancy_unlock(lt);
@@ -1027,7 +1027,7 @@ int __ast_rwlock_wrlock(const char *file
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = line;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		}
 		ast_reentrancy_unlock(lt);
@@ -1120,7 +1120,7 @@ int __ast_rwlock_timedrdlock(const char
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = line;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		}
 		ast_reentrancy_unlock(lt);
@@ -1213,7 +1213,7 @@ int __ast_rwlock_timedwrlock(const char
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = line;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		}
 		ast_reentrancy_unlock(lt);
@@ -1288,7 +1288,7 @@ int __ast_rwlock_tryrdlock(const char *f
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = line;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		}
 		ast_reentrancy_unlock(lt);
@@ -1347,7 +1347,7 @@ int __ast_rwlock_trywrlock(const char *f
 			lt->file[lt->reentrancy] = filename;
 			lt->lineno[lt->reentrancy] = line;
 			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
+			lt->thread_id[lt->reentrancy] = pthread_self();
 			lt->reentrancy++;
 		}
 		ast_reentrancy_unlock(lt);
diff -urpN asterisk-13.9.1/main/logger.c asterisk-13.17.0/main/logger.c
--- asterisk-13.9.1/main/logger.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/logger.c	2017-07-12 13:12:08.000000000 +0200
@@ -86,6 +86,11 @@ static volatile int next_unique_callid;
 static int display_callids;
 static void unique_callid_cleanup(void *data);
 
+static int logger_queue_size;
+static int logger_queue_limit = 1000;
+static int logger_messages_discarded;
+static unsigned int high_water_alert;
+
 struct ast_callid {
 	int call_identifier; /* Numerical value of the call displayed in the logs */
 };
@@ -168,6 +173,7 @@ static void logmsg_free(struct logmsg *m
 	if (msg->callid) {
 		ast_callid_unref(msg->callid);
 	}
+	ast_string_field_free_memory(msg);
 	ast_free(msg);
 }
 
@@ -388,6 +394,7 @@ static struct logchannel *make_logchanne
 		}
 
 		chan->type = LOGTYPE_SYSLOG;
+		openlog("asterisk", LOG_PID, chan->facility);
 	} else {
 		if (!(chan->fileptr = fopen(chan->filename, "a"))) {
 			/* Can't do real logging here since we're called with a lock
@@ -469,7 +476,7 @@ static int init_logger_chain(int locked,
 			return -1;
 		}
 		chan->type = LOGTYPE_CONSOLE;
-		chan->logmask = __LOG_WARNING | __LOG_NOTICE | __LOG_ERROR;
+		chan->logmask = (1 << __LOG_WARNING) | (1 << __LOG_NOTICE) | (1 << __LOG_ERROR);
 
 		if (!locked) {
 			AST_RWLIST_WRLOCK(&logchannels);
@@ -530,6 +537,16 @@ static int init_logger_chain(int locked,
 			fprintf(stderr, "rotatetimestamp option has been deprecated.  Please use rotatestrategy instead.\n");
 		}
 	}
+	if ((s = ast_variable_retrieve(cfg, "general", "logger_queue_limit"))) {
+		if (sscanf(s, "%30d", &logger_queue_limit) != 1) {
+			fprintf(stderr, "logger_queue_limit has an invalid value.  Leaving at default of %d.\n",
+				logger_queue_limit);
+		}
+		if (logger_queue_limit < 10) {
+			fprintf(stderr, "logger_queue_limit must be >= 10. Setting to 10.\n");
+			logger_queue_limit = 10;
+		}
+	}
 
 	if (!locked) {
 		AST_RWLIST_WRLOCK(&logchannels);
@@ -1115,6 +1132,7 @@ static char *handle_logger_show_channels
 	case CLI_GENERATE:
 		return NULL;
 	}
+	ast_cli(a->fd, "Logger queue limit: %d\n\n", logger_queue_limit);
 	ast_cli(a->fd, FORMATL, "Channel", "Type", "Status");
 	ast_cli(a->fd, "Configuration\n");
 	ast_cli(a->fd, FORMATL, "-------", "----", "------");
@@ -1484,6 +1502,79 @@ static void logger_print_normal(struct l
 	return;
 }
 
+static struct logmsg * __attribute__((format(printf, 6, 0))) format_log_message_ap(int level,
+	const char *file, int line, const char *function, struct ast_callid *callid,
+	const char *fmt, va_list ap)
+{
+	struct logmsg *logmsg = NULL;
+	struct ast_str *buf = NULL;
+	struct ast_tm tm;
+	struct timeval now = ast_tvnow();
+	int res = 0;
+	char datestring[256];
+
+	if (!(buf = ast_str_thread_get(&log_buf, LOG_BUF_INIT_SIZE))) {
+		return NULL;
+	}
+
+	/* Build string */
+	res = ast_str_set_va(&buf, BUFSIZ, fmt, ap);
+
+	/* If the build failed, then abort and free this structure */
+	if (res == AST_DYNSTR_BUILD_FAILED) {
+		return NULL;
+	}
+
+	/* Create a new logging message */
+	if (!(logmsg = ast_calloc_with_stringfields(1, struct logmsg, res + 128))) {
+		return NULL;
+	}
+
+	/* Copy string over */
+	ast_string_field_set(logmsg, message, ast_str_buffer(buf));
+
+	/* Set type */
+	if (level == __LOG_VERBOSE) {
+		logmsg->type = LOGMSG_VERBOSE;
+	} else {
+		logmsg->type = LOGMSG_NORMAL;
+	}
+
+	if (display_callids && callid) {
+		logmsg->callid = ast_callid_ref(callid);
+		/* callid will be unreffed at logmsg destruction */
+	}
+
+	/* Create our date/time */
+	ast_localtime(&now, &tm, NULL);
+	ast_strftime(datestring, sizeof(datestring), dateformat, &tm);
+	ast_string_field_set(logmsg, date, datestring);
+
+	/* Copy over data */
+	logmsg->level = level;
+	logmsg->line = line;
+	ast_string_field_set(logmsg, level_name, levels[level]);
+	ast_string_field_set(logmsg, file, file);
+	ast_string_field_set(logmsg, function, function);
+	logmsg->lwp = ast_get_tid();
+
+	return logmsg;
+}
+
+static struct logmsg * __attribute__((format(printf, 6, 0))) format_log_message(int level,
+	const char *file, int line, const char *function, struct ast_callid *callid,
+	const char *fmt, ...)
+{
+	struct logmsg *logmsg;
+	va_list ap;
+
+	va_start(ap, fmt);
+	logmsg = format_log_message_ap(level, file, line, function, callid, fmt, ap);
+	va_end(ap);
+
+	return logmsg;
+}
+
 /*! \brief Actual logging thread */
 static void *logger_thread(void *data)
 {
@@ -1500,8 +1591,21 @@ static void *logger_thread(void *data)
 				ast_cond_wait(&logcond, &logmsgs.lock);
 			}
 		}
+
+		if (high_water_alert) {
+			msg = format_log_message(__LOG_WARNING, "logger", 0, "***", NULL,
+				"Logging resumed.  %d message%s discarded.\n",
+				logger_messages_discarded, logger_messages_discarded == 1 ? "" : "s");
+			if (msg) {
+				AST_LIST_INSERT_TAIL(&logmsgs, msg, list);
+			}
+			high_water_alert = 0;
+			logger_messages_discarded = 0;
+		}
+
 		next = AST_LIST_FIRST(&logmsgs);
 		AST_LIST_HEAD_INIT_NOLOCK(&logmsgs);
+		logger_queue_size = 0;
 		AST_LIST_UNLOCK(&logmsgs);
 
 		/* Otherwise go through and process each message in the order added */
@@ -1552,6 +1656,11 @@ static void logger_queue_init(void)
 	}
 }
 
+int ast_is_logger_initialized(void)
+{
+	return logger_initialized;
+}
+
 /*!
  * \brief Start the ast_queue_log() logger.
  *
@@ -1822,75 +1931,36 @@ static void unique_callid_cleanup(void *
 /*!
  * \brief send log messages to syslog and/or the console
  */
-static void __attribute__((format(printf, 6, 0))) ast_log_full(int level, const char *file, int line, const char *function, struct ast_callid *callid, const char *fmt, va_list ap)
+static void __attribute__((format(printf, 6, 0))) ast_log_full(int level, const char *file,
+	int line, const char *function, struct ast_callid *callid, const char *fmt, va_list ap)
 {
 	struct logmsg *logmsg = NULL;
-	struct ast_str *buf = NULL;
-	struct ast_tm tm;
-	struct timeval now = ast_tvnow();
-	int res = 0;
-	char datestring[256];
 
-	if (!(buf = ast_str_thread_get(&log_buf, LOG_BUF_INIT_SIZE)))
+	/* Ignore anything that never gets logged anywhere */
+	if (level != __LOG_VERBOSE && !(global_logmask & (1 << level))) {
 		return;
+	}
 
-	if (level != __LOG_VERBOSE && AST_RWLIST_EMPTY(&logchannels)) {
-		/*
-		 * we don't have the logger chain configured yet,
-		 * so just log to stdout
-		 */
-		int result;
-		result = ast_str_set_va(&buf, BUFSIZ, fmt, ap); /* XXX BUFSIZ ? */
-		if (result != AST_DYNSTR_BUILD_FAILED) {
-			term_filter_escapes(ast_str_buffer(buf));
-			fputs(ast_str_buffer(buf), stdout);
+	AST_LIST_LOCK(&logmsgs);
+	if (logger_queue_size >= logger_queue_limit && !close_logger_thread) {
+		logger_messages_discarded++;
+		if (!high_water_alert && !close_logger_thread) {
+			logmsg = format_log_message(__LOG_WARNING, "logger", 0, "***", NULL,
+				"Log queue threshold (%d) exceeded.  Discarding new messages.\n", logger_queue_limit);
+			AST_LIST_INSERT_TAIL(&logmsgs, logmsg, list);
+			high_water_alert = 1;
+			ast_cond_signal(&logcond);
 		}
+		AST_LIST_UNLOCK(&logmsgs);
 		return;
 	}
+	AST_LIST_UNLOCK(&logmsgs);
 
-	/* Ignore anything that never gets logged anywhere */
-	if (level != __LOG_VERBOSE && !(global_logmask & (1 << level)))
-		return;
-
-	/* Build string */
-	res = ast_str_set_va(&buf, BUFSIZ, fmt, ap);
-
-	/* If the build failed, then abort and free this structure */
-	if (res == AST_DYNSTR_BUILD_FAILED)
-		return;
-
-	/* Create a new logging message */
-	if (!(logmsg = ast_calloc_with_stringfields(1, struct logmsg, res + 128)))
+	logmsg = format_log_message_ap(level, file, line, function, callid, fmt, ap);
+	if (!logmsg) {
 		return;
-
-	/* Copy string over */
-	ast_string_field_set(logmsg, message, ast_str_buffer(buf));
-
-	/* Set type */
-	if (level == __LOG_VERBOSE) {
-		logmsg->type = LOGMSG_VERBOSE;
-	} else {
-		logmsg->type = LOGMSG_NORMAL;
 	}
 
-	if (display_callids && callid) {
-		logmsg->callid = ast_callid_ref(callid);
-		/* callid will be unreffed at logmsg destruction */
-	}
-
-	/* Create our date/time */
-	ast_localtime(&now, &tm, NULL);
-	ast_strftime(datestring, sizeof(datestring), dateformat, &tm);
-	ast_string_field_set(logmsg, date, datestring);
-
-	/* Copy over data */
-	logmsg->level = level;
-	logmsg->line = line;
-	ast_string_field_set(logmsg, level_name, levels[level]);
-	ast_string_field_set(logmsg, file, file);
-	ast_string_field_set(logmsg, function, function);
-	logmsg->lwp = ast_get_tid();
-
 	/* If the logger thread is active, append it to the tail end of the list - otherwise skip that step */
 	if (logthread != AST_PTHREADT_NULL) {
 		AST_LIST_LOCK(&logmsgs);
@@ -1899,6 +1969,7 @@ static void __attribute__((format(printf
 			logmsg_free(logmsg);
 		} else {
 			AST_LIST_INSERT_TAIL(&logmsgs, logmsg, list);
+			logger_queue_size++;
 			ast_cond_signal(&logcond);
 		}
 		AST_LIST_UNLOCK(&logmsgs);
@@ -2368,3 +2439,12 @@ const char *ast_logger_get_dateformat(vo
 	return dateformat;
 }
 
+void ast_logger_set_queue_limit(int queue_limit)
+{
+	logger_queue_limit = queue_limit;
+}
+
+int ast_logger_get_queue_limit(void)
+{
+	return logger_queue_limit;
+}
diff -urpN asterisk-13.9.1/main/manager.c asterisk-13.17.0/main/manager.c
--- asterisk-13.9.1/main/manager.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/manager.c	2017-07-12 13:12:08.000000000 +0200
@@ -100,6 +100,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/rtp_engine.h"
 #include "asterisk/format_cache.h"
 #include "asterisk/translate.h"
+#include "asterisk/taskprocessor.h"
 
 /*** DOCUMENTATION
 	<manager name="Ping" language="en_US">
@@ -148,6 +149,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Logoff the current manager session.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Login</ref>
+		</see-also>
 	</manager>
 	<manager name="Login" language="en_US">
 		<synopsis>
@@ -167,6 +171,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Login Manager.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Logoff</ref>
+		</see-also>
 	</manager>
 	<manager name="Challenge" language="en_US">
 		<synopsis>
@@ -320,6 +327,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<para>If a channel name is not provided then the variable is considered global.</para>
 			</note>
 		</description>
+		<see-also>
+			<ref type="manager">Getvar</ref>
+		</see-also>
 	</manager>
 	<manager name="Getvar" language="en_US">
 		<synopsis>
@@ -340,6 +350,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<para>If a channel name is not provided then the variable is considered global.</para>
 			</note>
 		</description>
+		<see-also>
+			<ref type="manager">Setvar</ref>
+		</see-also>
 	</manager>
 	<manager name="GetConfig" language="en_US">
 		<synopsis>
@@ -372,6 +385,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			In the case where a category name is non-unique, a filter may be specified
 			to match only categories with matching variable values.</para>
 		</description>
+		<see-also>
+			<ref type="manager">GetConfigJSON</ref>
+			<ref type="manager">UpdateConfig</ref>
+			<ref type="manager">CreateConfig</ref>
+			<ref type="manager">ListCategories</ref>
+		</see-also>
 	</manager>
 	<manager name="GetConfigJSON" language="en_US">
 		<synopsis>
@@ -396,6 +415,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			In the case where a category name is non-unique, a filter may be specified
 			to match only categories with matching variable values.</para>
 		</description>
+		<see-also>
+			<ref type="manager">GetConfig</ref>
+			<ref type="manager">UpdateConfig</ref>
+			<ref type="manager">CreateConfig</ref>
+			<ref type="manager">ListCategories</ref>
+		</see-also>
 	</manager>
 	<manager name="UpdateConfig" language="en_US">
 		<synopsis>
@@ -487,6 +512,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>This action will modify, create, or delete configuration elements
 			in Asterisk configuration files.</para>
 		</description>
+		<see-also>
+			<ref type="manager">GetConfig</ref>
+			<ref type="manager">GetConfigJSON</ref>
+			<ref type="manager">CreateConfig</ref>
+			<ref type="manager">ListCategories</ref>
+		</see-also>
 	</manager>
 	<manager name="CreateConfig" language="en_US">
 		<synopsis>
@@ -503,6 +534,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			directory. This action is intended to be used before an UpdateConfig
 			action.</para>
 		</description>
+		<see-also>
+			<ref type="manager">GetConfig</ref>
+			<ref type="manager">GetConfigJSON</ref>
+			<ref type="manager">UpdateConfig</ref>
+			<ref type="manager">ListCategories</ref>
+		</see-also>
 	</manager>
 	<manager name="ListCategories" language="en_US">
 		<synopsis>
@@ -517,6 +554,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>This action will dump the categories in a given file.</para>
 		</description>
+		<see-also>
+			<ref type="manager">GetConfig</ref>
+			<ref type="manager">GetConfigJSON</ref>
+			<ref type="manager">UpdateConfig</ref>
+			<ref type="manager">CreateConfig</ref>
+		</see-also>
 	</manager>
 	<manager name="Redirect" language="en_US">
 		<synopsis>
@@ -552,6 +595,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Redirect (transfer) a call.</para>
 		</description>
+		<see-also>
+			<ref type="manager">BlindTransfer</ref>
+		</see-also>
 	</manager>
 	<manager name="Atxfer" language="en_US">
 		<synopsis>
@@ -572,6 +618,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Attended transfer.</para>
 		</description>
+		<see-also>
+			<ref type="managerEvent">AttendedTransfer</ref>
+		</see-also>
 	</manager>
 	<manager name="Originate" language="en_US">
 		<synopsis>
@@ -696,6 +745,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Will return an <literal>Extension Status</literal> message. The response will include
 			the hint for the extension and the status.</para>
 		</description>
+		<see-also>
+			<ref type="managerEvent">ExtensionStatus</ref>
+		</see-also>
 	</manager>
 	<manager name="PresenceState" language="en_US">
 		<synopsis>
@@ -712,6 +764,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Will return a <literal>Presence State</literal> message. The response will include the
 			presence state and, if set, a presence subtype and custom message.</para>
 		</description>
+		<see-also>
+			<ref type="managerEvent">PresenceStatus</ref>
+		</see-also>
 	</manager>
 	<manager name="AbsoluteTimeout" language="en_US">
 		<synopsis>
@@ -749,6 +804,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Waiting: <literal>0</literal> if messages waiting, <literal>1</literal>
 			if no messages waiting.</para>
 		</description>
+		<see-also>
+			<ref type="manager">MailboxCount</ref>
+		</see-also>
 	</manager>
 	<manager name="MailboxCount" language="en_US">
 		<synopsis>
@@ -769,6 +827,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>NewMessages: <replaceable>count</replaceable></para>
 			<para>OldMessages: <replaceable>count</replaceable></para>
 		</description>
+		<see-also>
+			<ref type="manager">MailboxStatus</ref>
+		</see-also>
 	</manager>
 	<manager name="ListCommands" language="en_US">
 		<synopsis>
@@ -818,6 +879,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Send an event to manager sessions.</para>
 		</description>
+		<see-also>
+			<ref type="managerEvent">UserEvent</ref>
+			<ref type="application">UserEvent</ref>
+		</see-also>
 	</manager>
 	<manager name="WaitEvent" language="en_US">
 		<synopsis>
@@ -870,6 +935,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Send a reload event.</para>
 		</description>
+		<see-also>
+			<ref type="manager">ModuleLoad</ref>
+		</see-also>
 	</manager>
 	<managerEvent language="en_US" name="CoreShowChannel">
 		<managerEventInstance class="EVENT_FLAG_CALL">
@@ -982,6 +1050,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Loads, unloads or reloads an Asterisk module in a running system.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Reload</ref>
+			<ref type="manager">ModuleCheck</ref>
+		</see-also>
 	</manager>
 	<manager name="ModuleCheck" language="en_US">
 		<synopsis>
@@ -997,6 +1069,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Checks if Asterisk module is loaded. Will return Success/Failure.
 			For success returns, the module revision number is included.</para>
 		</description>
+		<see-also>
+			<ref type="manager">ModuleLoad</ref>
+		</see-also>
 	</manager>
 	<manager name="AOCMessage" language="en_US">
 		<synopsis>
@@ -1103,6 +1178,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Generates an AOC-D or AOC-E message on a channel.</para>
 		</description>
+		<see-also>
+			<ref type="managerEvent">AOC-D</ref>
+			<ref type="managerEvent">AOC-E</ref>
+		</see-also>
 	</manager>
 	<function name="AMI_CLIENT" language="en_US">
 		<synopsis>
@@ -1162,6 +1241,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			this command can be used to create filters that may bypass
 			filters defined in manager.conf</para>
 		</description>
+		<see-also>
+			<ref type="manager">FilterList</ref>
+		</see-also>
 	</manager>
 	<manager name="FilterList" language="en_US">
 		<synopsis>
@@ -1171,6 +1253,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>The filters displayed are for the current session.  Only those filters defined in
                         manager.conf will be present upon starting a new session.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Filter</ref>
+		</see-also>
 	</manager>
 	<manager name="BlindTransfer" language="en_US">
 		<synopsis>
@@ -1189,6 +1274,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</description>
 		<see-also>
 			<ref type="manager">Redirect</ref>
+			<ref type="managerEvent">BlindTransfer</ref>
 		</see-also>
 	</manager>
 	<managerEvent name="ExtensionStatus" language="en_US">
@@ -1266,6 +1352,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					</enumlist>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="manager">ExtensionState</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent name="PresenceStatus" language="en_US">
@@ -1279,6 +1368,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<parameter name="Subtype" />
 				<parameter name="Message" />
 			</syntax>
+			<see-also>
+				<ref type="manager">PresenceState</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
  ***/
@@ -1541,6 +1633,17 @@ static AST_RWLIST_HEAD_STATIC(manager_ho
 /*! \brief A container of event documentation nodes */
 static AO2_GLOBAL_OBJ_STATIC(event_docs);
 
+static int __attribute__((format(printf, 9, 0))) __manager_event_sessions(
+	struct ao2_container *sessions,
+	int category,
+	const char *event,
+	int chancount,
+	struct ast_channel **chans,
+	const char *file,
+	int line,
+	const char *func,
+	const char *fmt,
+	...);
 static enum add_filter_result manager_add_filter(const char *filter_pattern, struct ao2_container *whitefilters, struct ao2_container *blackfilters);
 
 static int match_filter(struct mansession *s, char *eventdata);
@@ -1679,37 +1782,75 @@ struct ast_str *ast_manager_str_from_jso
 	return res;
 }
 
+#define manager_event_sessions(sessions, category, event, contents , ...)	\
+	__manager_event_sessions(sessions, category, event, 0, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__, contents , ## __VA_ARGS__)
+
+#define any_manager_listeners(sessions)	\
+	((sessions && ao2_container_count(sessions)) || !AST_RWLIST_EMPTY(&manager_hooks))
+
 static void manager_default_msg_cb(void *data, struct stasis_subscription *sub,
 				    struct stasis_message *message)
 {
-	RAII_VAR(struct ast_manager_event_blob *, ev, NULL, ao2_cleanup);
+	struct ao2_container *sessions;
+	struct ast_manager_event_blob *ev;
 
-	ev = stasis_message_to_ami(message);
+	if (!stasis_message_can_be_ami(message)) {
+		/* Not an AMI message; disregard */
+		return;
+	}
 
-	if (ev == NULL) {
-		/* Not and AMI message; disregard */
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (!any_manager_listeners(sessions)) {
+		/* Nobody is listening */
+		ao2_cleanup(sessions);
 		return;
 	}
 
-	manager_event(ev->event_flags, ev->manager_event, "%s",
-		ev->extra_fields);
+	ev = stasis_message_to_ami(message);
+	if (!ev) {
+		/* Conversion failure */
+		ao2_cleanup(sessions);
+		return;
+	}
+
+	manager_event_sessions(sessions, ev->event_flags, ev->manager_event,
+		"%s", ev->extra_fields);
+	ao2_ref(ev, -1);
+	ao2_cleanup(sessions);
 }
 
 static void manager_generic_msg_cb(void *data, struct stasis_subscription *sub,
 				    struct stasis_message *message)
 {
-	struct ast_json_payload *payload = stasis_message_data(message);
-	int class_type = ast_json_integer_get(ast_json_object_get(payload->json, "class_type"));
-	const char *type = ast_json_string_get(ast_json_object_get(payload->json, "type"));
-	struct ast_json *event = ast_json_object_get(payload->json, "event");
-	RAII_VAR(struct ast_str *, event_buffer, NULL, ast_free);
+	struct ast_json_payload *payload;
+	int class_type;
+	const char *type;
+	struct ast_json *event;
+	struct ast_str *event_buffer;
+	struct ao2_container *sessions;
+
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (!any_manager_listeners(sessions)) {
+		/* Nobody is listening */
+		ao2_cleanup(sessions);
+		return;
+	}
+
+	payload = stasis_message_data(message);
+	class_type = ast_json_integer_get(ast_json_object_get(payload->json, "class_type"));
+	type = ast_json_string_get(ast_json_object_get(payload->json, "type"));
+	event = ast_json_object_get(payload->json, "event");
 
 	event_buffer = ast_manager_str_from_json_object(event, NULL);
 	if (!event_buffer) {
 		ast_log(AST_LOG_WARNING, "Error while creating payload for event %s\n", type);
+		ao2_cleanup(sessions);
 		return;
 	}
-	manager_event(class_type, type, "%s", ast_str_buffer(event_buffer));
+	manager_event_sessions(sessions, class_type, type,
+		"%s", ast_str_buffer(event_buffer));
+	ast_free(event_buffer);
+	ao2_cleanup(sessions);
 }
 
 void ast_manager_publish_event(const char *type, int class_type, struct ast_json *obj)
@@ -4678,14 +4819,10 @@ static int action_redirect(struct manses
 
 	/* Release the bridge wait. */
 	if (chan1_wait) {
-		ast_channel_lock(chan);
-		ast_clear_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
-		ast_channel_unlock(chan);
+		ast_channel_clear_flag(chan, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
 	}
 	if (chan2_wait) {
-		ast_channel_lock(chan2);
-		ast_clear_flag(ast_channel_flags(chan2), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
-		ast_channel_unlock(chan2);
+		ast_channel_clear_flag(chan2, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
 	}
 
 	chan2 = ast_channel_unref(chan2);
@@ -4698,7 +4835,7 @@ static int action_blind_transfer(struct
 	const char *name = astman_get_header(m, "Channel");
 	const char *exten = astman_get_header(m, "Exten");
 	const char *context = astman_get_header(m, "Context");
-	RAII_VAR(struct ast_channel *, chan, NULL, ao2_cleanup);
+	struct ast_channel *chan;
 
 	if (ast_strlen_zero(name)) {
 		astman_send_error(s, m, "No channel specified");
@@ -4735,6 +4872,7 @@ static int action_blind_transfer(struct
 		break;
 	}
 
+	ast_channel_unref(chan);
 	return 0;
 }
 
@@ -4954,13 +5092,15 @@ static void *fast_originate(void *data)
 
 	if (!ast_strlen_zero(in->app)) {
 		res = ast_pbx_outgoing_app(in->tech, in->cap, in->data,
-			in->timeout, in->app, in->appdata, &reason, 1,
+			in->timeout, in->app, in->appdata, &reason,
+			AST_OUTGOING_WAIT,
 			S_OR(in->cid_num, NULL),
 			S_OR(in->cid_name, NULL),
 			in->vars, in->account, &chan, &assignedids);
 	} else {
 		res = ast_pbx_outgoing_exten(in->tech, in->cap, in->data,
-			in->timeout, in->context, in->exten, in->priority, &reason, 1,
+			in->timeout, in->context, in->exten, in->priority, &reason,
+			AST_OUTGOING_WAIT,
 			S_OR(in->cid_num, NULL),
 			S_OR(in->cid_name, NULL),
 			in->vars, in->account, &chan, in->early_media, &assignedids);
@@ -5431,11 +5571,16 @@ static int action_originate(struct manse
 			}
 		}
 	} else if (!ast_strlen_zero(app)) {
-		res = ast_pbx_outgoing_app(tech, cap, data, to, app, appdata, &reason, 1, l, n, vars, account, NULL, assignedids.uniqueid ? &assignedids : NULL);
+		res = ast_pbx_outgoing_app(tech, cap, data, to, app, appdata, &reason,
+				AST_OUTGOING_WAIT, l, n, vars, account, NULL,
+				assignedids.uniqueid ? &assignedids : NULL);
 		ast_variables_destroy(vars);
 	} else {
 		if (exten && context && pi) {
-			res = ast_pbx_outgoing_exten(tech, cap, data, to, context, exten, pi, &reason, 1, l, n, vars, account, NULL, bridge_early, assignedids.uniqueid ? &assignedids : NULL);
+			res = ast_pbx_outgoing_exten(tech, cap, data, to,
+					context, exten, pi, &reason, AST_OUTGOING_WAIT,
+					l, n, vars, account, NULL, bridge_early,
+					assignedids.uniqueid ? &assignedids : NULL);
 			ast_variables_destroy(vars);
 		} else {
 			astman_send_error(s, m, "Originate with 'Exten' requires 'Context' and 'Priority'");
@@ -5497,8 +5642,9 @@ static int action_extensionstate(struct
 {
 	const char *exten = astman_get_header(m, "Exten");
 	const char *context = astman_get_header(m, "Context");
-	char hint[256] = "";
+	char hint[256];
 	int status;
+
 	if (ast_strlen_zero(exten)) {
 		astman_send_error(s, m, "Extension not specified");
 		return 0;
@@ -5507,16 +5653,18 @@ static int action_extensionstate(struct
 		context = "default";
 	}
 	status = ast_extension_state(NULL, context, exten);
-	ast_get_hint(hint, sizeof(hint) - 1, NULL, 0, NULL, context, exten);
+	hint[0] = '\0';
+	ast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);
 	astman_start_ack(s, m);
-	astman_append(s,   "Message: Extension Status\r\n"
-			   "Exten: %s\r\n"
-			   "Context: %s\r\n"
-			   "Hint: %s\r\n"
-			   "Status: %d\r\n"
-		           "StatusText: %s\r\n\r\n",
-		      exten, context, hint, status,
-		      ast_extension_state2str(status));
+	astman_append(s, "Message: Extension Status\r\n"
+		"Exten: %s\r\n"
+		"Context: %s\r\n"
+		"Hint: %s\r\n"
+		"Status: %d\r\n"
+		"StatusText: %s\r\n"
+		"\r\n",
+		exten, context, hint, status,
+		ast_extension_state2str(status));
 	return 0;
 }
 
@@ -5713,7 +5861,11 @@ static int match_filter(struct mansessio
 {
 	int result = 0;
 
-	ast_debug(3, "Examining AMI event:\n%s\n", eventdata);
+	if (manager_debug) {
+		ast_verbose("<-- Examining AMI event: -->\n%s\n", eventdata);
+	} else {
+		ast_debug(3, "Examining AMI event:\n%s\n", eventdata);
+	}
 	if (!ao2_container_count(s->session->whitefilters) && !ao2_container_count(s->session->blackfilters)) {
 		return 1; /* no filtering means match all */
 	} else if (ao2_container_count(s->session->whitefilters) && !ao2_container_count(s->session->blackfilters)) {
@@ -5907,7 +6059,7 @@ static int action_coreshowchannels(struc
 	const char *actionid = astman_get_header(m, "ActionID");
 	char idText[256];
 	int numchans = 0;
-	RAII_VAR(struct ao2_container *, channels, NULL, ao2_cleanup);
+	struct ao2_container *channels;
 	struct ao2_iterator it_chans;
 	struct stasis_message *msg;
 
@@ -5917,7 +6069,8 @@ static int action_coreshowchannels(struc
 		idText[0] = '\0';
 	}
 
-	if (!(channels = stasis_cache_dump(ast_channel_cache_by_name(), ast_channel_snapshot_type()))) {
+	channels = stasis_cache_dump(ast_channel_cache_by_name(), ast_channel_snapshot_type());
+	if (!channels) {
 		astman_send_error(s, m, "Could not get cached channels");
 		return 0;
 	}
@@ -5969,6 +6122,7 @@ static int action_coreshowchannels(struc
 	astman_send_list_complete_start(s, m, "CoreShowChannelsComplete", numchans);
 	astman_send_list_complete_end(s);
 
+	ao2_ref(channels, -1);
 	return 0;
 }
 
@@ -6300,6 +6454,12 @@ static int get_input(struct mansession *
 	}
 
 	ao2_lock(s->session);
+	/*
+	 * It is worth noting here that you can all but ignore fread()'s documentation
+	 * for the purposes of this call. The FILE * we are working with here was created
+	 * as a result of a call to fopencookie() (or equivalent) in tcptls.c, and as such
+	 * the behavior of fread() is not as documented. Frankly, I think this is gross.
+	 */
 	res = fread(src + s->session->inlen, 1, maxlen - s->session->inlen, s->session->f);
 	if (res < 1) {
 		res = -1;	/* error return */
@@ -6433,10 +6593,9 @@ static void *session_do(void *data)
 	struct mansession s = {
 		.tcptls_session = data,
 	};
-	int flags;
+	int flags = 1;
 	int res;
 	struct ast_sockaddr ser_remote_address_tmp;
-	struct protoent *p;
 
 	if (ast_atomic_fetchadd_int(&unauth_sessions, +1) >= authlimit) {
 		fclose(ser->f);
@@ -6456,14 +6615,8 @@ static void *session_do(void *data)
 	/* here we set TCP_NODELAY on the socket to disable Nagle's algorithm.
 	 * This is necessary to prevent delays (caused by buffering) as we
 	 * write to the socket in bits and pieces. */
-	p = getprotobyname("tcp");
-	if (p) {
-		int arg = 1;
-		if( setsockopt(ser->fd, p->p_proto, TCP_NODELAY, (char *)&arg, sizeof(arg) ) < 0 ) {
-			ast_log(LOG_WARNING, "Failed to set manager tcp connection to TCP_NODELAY mode: %s\nSome manager actions may be slow to respond.\n", strerror(errno));
-		}
-	} else {
-		ast_log(LOG_WARNING, "Failed to set manager tcp connection to TCP_NODELAY, getprotobyname(\"tcp\") failed\nSome manager actions may be slow to respond.\n");
+	if (setsockopt(ser->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &flags, sizeof(flags)) < 0) {
+		ast_log(LOG_WARNING, "Failed to set TCP_NODELAY on manager connection: %s\n", strerror(errno));
 	}
 
 	/* make sure socket is non-blocking */
@@ -6597,11 +6750,10 @@ static int append_event(const char *str,
 
 static void append_channel_vars(struct ast_str **pbuf, struct ast_channel *chan)
 {
-	RAII_VAR(struct varshead *, vars, NULL, ao2_cleanup);
+	struct varshead *vars;
 	struct ast_var_t *var;
 
 	vars = ast_channel_get_manager_vars(chan);
-
 	if (!vars) {
 		return;
 	}
@@ -6609,62 +6761,67 @@ static void append_channel_vars(struct a
 	AST_LIST_TRAVERSE(vars, var, entries) {
 		ast_str_append(pbuf, 0, "ChanVariable(%s): %s=%s\r\n", ast_channel_name(chan), var->name, var->value);
 	}
+	ao2_ref(vars, -1);
 }
 
 /* XXX see if can be moved inside the function */
 AST_THREADSTORAGE(manager_event_buf);
 #define MANAGER_EVENT_BUF_INITSIZE   256
 
-int __ast_manager_event_multichan(int category, const char *event, int chancount,
-	struct ast_channel **chans, const char *file, int line, const char *func,
-	const char *fmt, ...)
+static int __attribute__((format(printf, 9, 0))) __manager_event_sessions_va(
+	struct ao2_container *sessions,
+	int category,
+	const char *event,
+	int chancount,
+	struct ast_channel **chans,
+	const char *file,
+	int line,
+	const char *func,
+	const char *fmt,
+	va_list ap)
 {
-	RAII_VAR(struct ao2_container *, sessions, ao2_global_obj_ref(mgr_sessions), ao2_cleanup);
-	struct mansession_session *session;
-	struct manager_custom_hook *hook;
 	struct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);
 	const char *cat_str;
-	va_list ap;
 	struct timeval now;
 	struct ast_str *buf;
 	int i;
 
-	if (!(sessions && ao2_container_count(sessions)) && AST_RWLIST_EMPTY(&manager_hooks)) {
-		return 0;
-	}
-
-	if (!(buf = ast_str_thread_get(&manager_event_buf, MANAGER_EVENT_BUF_INITSIZE))) {
+	buf = ast_str_thread_get(&manager_event_buf, MANAGER_EVENT_BUF_INITSIZE);
+	if (!buf) {
 		return -1;
 	}
 
 	cat_str = authority_to_str(category, &auth);
 	ast_str_set(&buf, 0,
-			"Event: %s\r\nPrivilege: %s\r\n",
-			 event, cat_str);
+		"Event: %s\r\n"
+		"Privilege: %s\r\n",
+		event, cat_str);
 
 	if (timestampevents) {
 		now = ast_tvnow();
 		ast_str_append(&buf, 0,
-				"Timestamp: %ld.%06lu\r\n",
-				 (long)now.tv_sec, (unsigned long) now.tv_usec);
+			"Timestamp: %ld.%06lu\r\n",
+			(long)now.tv_sec, (unsigned long) now.tv_usec);
 	}
 	if (manager_debug) {
 		static int seq;
+
 		ast_str_append(&buf, 0,
-				"SequenceNumber: %d\r\n",
-				 ast_atomic_fetchadd_int(&seq, 1));
+			"SequenceNumber: %d\r\n",
+			ast_atomic_fetchadd_int(&seq, 1));
 		ast_str_append(&buf, 0,
-				"File: %s\r\nLine: %d\r\nFunc: %s\r\n", file, line, func);
+			"File: %s\r\n"
+			"Line: %d\r\n"
+			"Func: %s\r\n",
+			file, line, func);
 	}
 	if (!ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {
 		ast_str_append(&buf, 0,
-				"SystemName: %s\r\n",
-				 ast_config_AST_SYSTEM_NAME);
+			"SystemName: %s\r\n",
+			ast_config_AST_SYSTEM_NAME);
 	}
 
-	va_start(ap, fmt);
 	ast_str_append_va(&buf, 0, fmt, ap);
-	va_end(ap);
 	for (i = 0; i < chancount; i++) {
 		append_channel_vars(&buf, chans[i]);
 	}
@@ -6675,9 +6832,11 @@ int __ast_manager_event_multichan(int ca
 
 	/* Wake up any sleeping sessions */
 	if (sessions) {
-		struct ao2_iterator i;
-		i = ao2_iterator_init(sessions, 0);
-		while ((session = ao2_iterator_next(&i))) {
+		struct ao2_iterator iter;
+		struct mansession_session *session;
+
+		iter = ao2_iterator_init(sessions, 0);
+		while ((session = ao2_iterator_next(&iter))) {
 			ao2_lock(session);
 			if (session->waiting_thread != AST_PTHREADT_NULL) {
 				pthread_kill(session->waiting_thread, SIGURG);
@@ -6692,10 +6851,12 @@ int __ast_manager_event_multichan(int ca
 			ao2_unlock(session);
 			unref_mansession(session);
 		}
-		ao2_iterator_destroy(&i);
+		ao2_iterator_destroy(&iter);
 	}
 
 	if (category != EVENT_FLAG_SHUTDOWN && !AST_RWLIST_EMPTY(&manager_hooks)) {
+		struct manager_custom_hook *hook;
+
 		AST_RWLIST_RDLOCK(&manager_hooks);
 		AST_RWLIST_TRAVERSE(&manager_hooks, hook, list) {
 			hook->helper(category, event, ast_str_buffer(buf));
@@ -6706,6 +6867,50 @@ int __ast_manager_event_multichan(int ca
 	return 0;
 }
 
+static int __attribute__((format(printf, 9, 0))) __manager_event_sessions(
+	struct ao2_container *sessions,
+	int category,
+	const char *event,
+	int chancount,
+	struct ast_channel **chans,
+	const char *file,
+	int line,
+	const char *func,
+	const char *fmt,
+	...)
+{
+	va_list ap;
+	int res;
+
+	va_start(ap, fmt);
+	res = __manager_event_sessions_va(sessions, category, event, chancount, chans,
+		file, line, func, fmt, ap);
+	va_end(ap);
+	return res;
+}
+
+int __ast_manager_event_multichan(int category, const char *event, int chancount,
+	struct ast_channel **chans, const char *file, int line, const char *func,
+	const char *fmt, ...)
+{
+	struct ao2_container *sessions = ao2_global_obj_ref(mgr_sessions);
+	va_list ap;
+	int res;
+
+	if (!any_manager_listeners(sessions)) {
+		/* Nobody is listening */
+		ao2_cleanup(sessions);
+		return 0;
+	}
+
+	va_start(ap, fmt);
+	res = __manager_event_sessions_va(sessions, category, event, chancount, chans,
+		file, line, func, fmt, ap);
+	va_end(ap);
+	ao2_cleanup(sessions);
+	return res;
+}
+
 /*! \brief
  * support functions to register/unregister AMI action handlers,
  */
@@ -6744,6 +6949,7 @@ static int manager_state_cb(char *contex
 	/* Notify managers of change */
 	char hint[512];
 
+	hint[0] = '\0';
 	ast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);
 
 	switch(info->reason) {
@@ -8513,6 +8719,10 @@ static void manager_shutdown(void)
 	ami_tls_cfg.pvtfile = NULL;
 	ast_free(ami_tls_cfg.cipher);
 	ami_tls_cfg.cipher = NULL;
+	ast_free(ami_tls_cfg.cafile);
+	ami_tls_cfg.cafile = NULL;
+	ast_free(ami_tls_cfg.capath);
+	ami_tls_cfg.capath = NULL;
 
 	ao2_global_obj_release(mgr_sessions);
 
@@ -8546,6 +8756,8 @@ static int manager_subscriptions_init(vo
 	if (!stasis_router) {
 		return -1;
 	}
+	stasis_message_router_set_congestion_limits(stasis_router, -1,
+		6 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);
 
 	res |= stasis_message_router_set_default(stasis_router,
 		manager_default_msg_cb, NULL);
@@ -8611,6 +8823,10 @@ static void manager_set_defaults(void)
 	ami_tls_cfg.pvtfile = ast_strdup("");
 	ast_free(ami_tls_cfg.cipher);
 	ami_tls_cfg.cipher = ast_strdup("");
+	ast_free(ami_tls_cfg.cafile);
+	ami_tls_cfg.cafile = ast_strdup("");
+	ast_free(ami_tls_cfg.capath);
+	ami_tls_cfg.capath = ast_strdup("");
 }
 
 static int __init_manager(int reload, int by_external_config)
@@ -9184,6 +9400,7 @@ int ast_str_append_event_header(struct a
 static void manager_event_blob_dtor(void *obj)
 {
 	struct ast_manager_event_blob *ev = obj;
+
 	ast_string_field_free_memory(ev);
 }
 
@@ -9195,18 +9412,19 @@ ast_manager_event_blob_create(
 	const char *extra_fields_fmt,
 	...)
 {
-	RAII_VAR(struct ast_manager_event_blob *, ev, NULL, ao2_cleanup);
+	struct ast_manager_event_blob *ev;
 	va_list argp;
 
 	ast_assert(extra_fields_fmt != NULL);
 	ast_assert(manager_event != NULL);
 
-	ev = ao2_alloc(sizeof(*ev), manager_event_blob_dtor);
+	ev = ao2_alloc_options(sizeof(*ev), manager_event_blob_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);
 	if (!ev) {
 		return NULL;
 	}
 
 	if (ast_string_field_init(ev, 20)) {
+		ao2_ref(ev, -1);
 		return NULL;
 	}
 
@@ -9214,10 +9432,8 @@ ast_manager_event_blob_create(
 	ev->event_flags = event_flags;
 
 	va_start(argp, extra_fields_fmt);
-	ast_string_field_ptr_build_va(ev, &ev->extra_fields, extra_fields_fmt,
-				      argp);
+	ast_string_field_ptr_build_va(ev, &ev->extra_fields, extra_fields_fmt, argp);
 	va_end(argp);
 
-	ao2_ref(ev, +1);
 	return ev;
 }
diff -urpN asterisk-13.9.1/main/manager_bridges.c asterisk-13.17.0/main/manager_bridges.c
--- asterisk-13.9.1/main/manager_bridges.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/manager_bridges.c	2017-07-12 13:12:08.000000000 +0200
@@ -42,6 +42,11 @@ static struct stasis_message_router *bri
 			<syntax>
 				<bridge_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">BridgeDestroy</ref>
+				<ref type="managerEvent">BridgeEnter</ref>
+				<ref type="managerEvent">BridgeLeave</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="BridgeDestroy">
@@ -50,6 +55,11 @@ static struct stasis_message_router *bri
 			<syntax>
 				<bridge_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">BridgeCreate</ref>
+				<ref type="managerEvent">BridgeEnter</ref>
+				<ref type="managerEvent">BridgeLeave</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="BridgeEnter">
@@ -62,6 +72,11 @@ static struct stasis_message_router *bri
 					<para>The uniqueid of the channel being swapped out of the bridge</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">BridgeCreate</ref>
+				<ref type="managerEvent">BridgeDestroy</ref>
+				<ref type="managerEvent">BridgeLeave</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="BridgeLeave">
@@ -71,6 +86,26 @@ static struct stasis_message_router *bri
 				<bridge_snapshot/>
 				<channel_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">BridgeCreate</ref>
+				<ref type="managerEvent">BridgeDestroy</ref>
+				<ref type="managerEvent">BridgeEnter</ref>
+			</see-also>
+		</managerEventInstance>
+	</managerEvent>
+	<managerEvent language="en_US" name="BridgeVideoSourceUpdate">
+		<managerEventInstance class="EVENT_FLAG_CALL">
+			<synopsis>Raised when the channel that is the source of video in a bridge changes.</synopsis>
+			<syntax>
+				<bridge_snapshot/>
+				<parameter name="BridgePreviousVideoSource">
+					<para>The unique ID of the channel that was the video source.</para>
+				</parameter>
+			</syntax>
+			<see-also>
+				<ref type="managerEvent">BridgeCreate</ref>
+				<ref type="managerEvent">BridgeDestroy</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<manager name="BridgeList" language="en_US">
@@ -86,6 +121,12 @@ static struct stasis_message_router *bri
 		<description>
 			<para>Returns a list of bridges, optionally filtering on a bridge type.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Bridge</ref>
+			<ref type="manager">BridgeDestroy</ref>
+			<ref type="manager">BridgeInfo</ref>
+			<ref type="manager">BridgeKick</ref>
+		</see-also>
 	</manager>
 	<manager name="BridgeInfo" language="en_US">
 		<synopsis>
@@ -100,6 +141,12 @@ static struct stasis_message_router *bri
 		<description>
 			<para>Returns detailed information about a bridge and the channels in it.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Bridge</ref>
+			<ref type="manager">BridgeDestroy</ref>
+			<ref type="manager">BridgeKick</ref>
+			<ref type="manager">BridgeList</ref>
+		</see-also>
 		<responses>
 			<list-elements>
 				<managerEvent language="en_US" name="BridgeInfoChannel">
@@ -134,6 +181,13 @@ static struct stasis_message_router *bri
 		<description>
 			<para>Deletes the bridge, causing channels to continue or hang up.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Bridge</ref>
+			<ref type="manager">BridgeInfo</ref>
+			<ref type="manager">BridgeKick</ref>
+			<ref type="manager">BridgeList</ref>
+			<ref type="managerEvent">BridgeDestroy</ref>
+		</see-also>
 	</manager>
 	<manager name="BridgeKick" language="en_US">
 		<synopsis>
@@ -153,6 +207,13 @@ static struct stasis_message_router *bri
 		<description>
 			<para>The channel is removed from the bridge.</para>
 		</description>
+		<see-also>
+			<ref type="manager">Bridge</ref>
+			<ref type="manager">BridgeDestroy</ref>
+			<ref type="manager">BridgeInfo</ref>
+			<ref type="manager">BridgeList</ref>
+			<ref type="managerEvent">BridgeLeave</ref>
+		</see-also>
 	</manager>
  ***/
 
@@ -178,18 +239,30 @@ struct ast_str *ast_manager_build_bridge
 		"%sBridgeTechnology: %s\r\n"
 		"%sBridgeCreator: %s\r\n"
 		"%sBridgeName: %s\r\n"
-		"%sBridgeNumChannels: %u\r\n",
+		"%sBridgeNumChannels: %u\r\n"
+		"%sBridgeVideoSourceMode: %s\r\n",
 		prefix, snapshot->uniqueid,
 		prefix, snapshot->subclass,
 		prefix, snapshot->technology,
 		prefix, ast_strlen_zero(snapshot->creator) ? "<unknown>": snapshot->creator,
 		prefix, ast_strlen_zero(snapshot->name) ? "<unknown>": snapshot->name,
-		prefix, snapshot->num_channels);
+		prefix, snapshot->num_channels,
+		prefix, ast_bridge_video_mode_to_string(snapshot->video_mode));
 	if (!res) {
 		ast_free(out);
 		return NULL;
 	}
 
+	if (snapshot->video_mode != AST_BRIDGE_VIDEO_MODE_NONE
+		&& !ast_strlen_zero(snapshot->video_source_id)) {
+		res = ast_str_append(&out, 0, "%sBridgeVideoSource: %s\r\n",
+			prefix, snapshot->video_source_id);
+		if (!res) {
+			ast_free(out);
+			return NULL;
+		}
+	}
+
 	return out;
 }
 
@@ -217,6 +290,25 @@ static struct ast_manager_event_blob *br
 		EVENT_FLAG_CALL, "BridgeCreate", NO_EXTRA_FIELDS);
 }
 
+/* \brief Handle video source updates */
+static struct ast_manager_event_blob *bridge_video_update(
+	struct ast_bridge_snapshot *old_snapshot,
+	struct ast_bridge_snapshot *new_snapshot)
+{
+	if (!new_snapshot || !old_snapshot) {
+		return NULL;
+	}
+
+	if (!strcmp(old_snapshot->video_source_id, new_snapshot->video_source_id)) {
+		return NULL;
+	}
+
+	return ast_manager_event_blob_create(
+		EVENT_FLAG_CALL, "BridgeVideoSourceUpdate",
+		"BridgePreviousVideoSource: %s\r\n",
+		old_snapshot->video_source_id);
+}
+
 /*! \brief Handle bridge destruction */
 static struct ast_manager_event_blob *bridge_destroy(
 	struct ast_bridge_snapshot *old_snapshot,
@@ -230,9 +322,9 @@ static struct ast_manager_event_blob *br
 		EVENT_FLAG_CALL, "BridgeDestroy", NO_EXTRA_FIELDS);
 }
 
-
 bridge_snapshot_monitor bridge_monitors[] = {
 	bridge_create,
+	bridge_video_update,
 	bridge_destroy,
 };
 
diff -urpN asterisk-13.9.1/main/manager_channels.c asterisk-13.17.0/main/manager_channels.c
--- asterisk-13.9.1/main/manager_channels.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/manager_channels.c	2017-07-12 13:12:08.000000000 +0200
@@ -44,6 +44,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<syntax>
 				<channel_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">Newstate</ref>
+				<ref type="managerEvent">Hangup</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="Newstate">
@@ -52,6 +56,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<syntax>
 				<channel_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">Newchannel</ref>
+				<ref type="managerEvent">Hangup</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="Hangup">
@@ -66,6 +74,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>A description of why the channel was hung up.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">Newchannel</ref>
+				<ref type="managerEvent">SoftHangupRequest</ref>
+				<ref type="managerEvent">HangupRequest</ref>
+				<ref type="managerEvent">Newstate</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="HangupRequest">
@@ -75,6 +89,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<channel_snapshot/>
 				<xi:include xpointer="xpointer(/docs/managerEvent[@name='Hangup']/managerEventInstance/syntax/parameter[@name='Cause'])" />
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">SoftHangupRequest</ref>
+				<ref type="managerEvent">Hangup</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="SoftHangupRequest">
@@ -84,6 +102,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<channel_snapshot/>
 				<xi:include xpointer="xpointer(/docs/managerEvent[@name='Hangup']/managerEventInstance/syntax/parameter[@name='Cause'])" />
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">HangupRequest</ref>
+				<ref type="managerEvent">Hangup</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="NewExten">
@@ -114,6 +136,20 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>A description of the Caller ID presentation.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="function">CALLERID</ref>
+			</see-also>
+		</managerEventInstance>
+	</managerEvent>
+	<managerEvent language="en_US" name="NewConnectedLine">
+		<managerEventInstance class="EVENT_FLAG_CALL">
+			<synopsis>Raised when a channel's connected line information is changed.</synopsis>
+			<syntax>
+				<channel_snapshot/>
+			</syntax>
+			<see-also>
+				<ref type="function">CONNECTEDLINE</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="NewAccountCode">
@@ -125,6 +161,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>The channel's previous account code</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="function">CHANNEL</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="DialBegin">
@@ -139,6 +178,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			</syntax>
 			<see-also>
 				<ref type="application">Dial</ref>
+				<ref type="application">Originate</ref>
+				<ref type="manager">Originate</ref>
+				<ref type="managerEvent">DialEnd</ref>
 			</see-also>
 		</managerEventInstance>
 	</managerEvent>
@@ -192,6 +234,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			</syntax>
 			<see-also>
 				<ref type="application">Dial</ref>
+				<ref type="application">Originate</ref>
+				<ref type="manager">Originate</ref>
+				<ref type="managerEvent">DialBegin</ref>
 			</see-also>
 		</managerEventInstance>
 	</managerEvent>
@@ -204,6 +249,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>The suggested MusicClass, if provided.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">Unhold</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="Unhold">
@@ -212,6 +260,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<syntax>
 				<channel_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">Hold</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="ChanSpyStart">
@@ -222,7 +273,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<channel_snapshot prefix="Spyee"/>
 			</syntax>
 			<see-also>
-				<ref type="application">ChanSpyStop</ref>
+				<ref type="managerEvent">ChanSpyStop</ref>
+				<ref type="application">ChanSpy</ref>
 			</see-also>
 		</managerEventInstance>
 	</managerEvent>
@@ -234,7 +286,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<channel_snapshot prefix="Spyee"/>
 			</syntax>
 			<see-also>
-				<ref type="application">ChanSpyStart</ref>
+				<ref type="managerEvent">ChanSpyStart</ref>
+				<ref type="application">ChanSpy</ref>
 			</see-also>
 		</managerEventInstance>
 	</managerEvent>
@@ -247,6 +300,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>Hangup handler parameter string passed to the Gosub application.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="function">CHANNEL</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="HangupHandlerPop">
@@ -353,6 +409,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			</syntax>
 			<see-also>
 				<ref type="managerEvent">MusicOnHoldStop</ref>
+				<ref type="application">StartMusicOnHold</ref>
 				<ref type="application">MusicOnHold</ref>
 			</see-also>
 		</managerEventInstance>
@@ -697,28 +754,33 @@ static void channel_hangup_request_cb(vo
 	struct stasis_message *message)
 {
 	struct ast_channel_blob *obj = stasis_message_data(message);
-	RAII_VAR(struct ast_str *, extra, NULL, ast_free);
-	RAII_VAR(struct ast_str *, channel_event_string, NULL, ast_free);
+	struct ast_str *extra;
+	struct ast_str *channel_event_string;
 	struct ast_json *cause;
 	int is_soft;
 	char *manager_event = "HangupRequest";
 
+	if (!obj->snapshot) {
+		/* No snapshot?  Likely an earlier allocation failure creating it. */
+		return;
+	}
+
 	extra = ast_str_create(20);
 	if (!extra) {
 		return;
 	}
 
 	channel_event_string = ast_manager_build_channel_state_string(obj->snapshot);
-
 	if (!channel_event_string) {
+		ast_free(extra);
 		return;
 	}
 
 	cause = ast_json_object_get(obj->blob, "cause");
 	if (cause) {
 		ast_str_append(&extra, 0,
-			       "Cause: %jd\r\n",
-			       ast_json_integer_get(cause));
+			"Cause: %jd\r\n",
+			ast_json_integer_get(cause));
 	}
 
 	is_soft = ast_json_is_true(ast_json_object_get(obj->blob, "soft"));
@@ -727,9 +789,12 @@ static void channel_hangup_request_cb(vo
 	}
 
 	manager_event(EVENT_FLAG_CALL, manager_event,
-		      "%s%s",
-		      ast_str_buffer(channel_event_string),
-		      ast_str_buffer(extra));
+		"%s%s",
+		ast_str_buffer(channel_event_string),
+		ast_str_buffer(extra));
+
+	ast_free(channel_event_string);
+	ast_free(extra);
 }
 
 static void channel_chanspy_stop_cb(void *data, struct stasis_subscription *sub,
@@ -821,6 +886,9 @@ static void channel_dtmf_begin_cb(void *
 						</enumlist>
 					</parameter>
 				</syntax>
+				<see-also>
+					<ref type="managerEvent">DTMFEnd</ref>
+				</see-also>
 		</managerEventInstance>
 	***/
 	manager_event(EVENT_FLAG_DTMF, "DTMFBegin",
@@ -867,6 +935,9 @@ static void channel_dtmf_end_cb(void *da
 						</enumlist>
 					</parameter>
 				</syntax>
+				<see-also>
+					<ref type="managerEvent">DTMFBegin</ref>
+				</see-also>
 		</managerEventInstance>
 	***/
 	manager_event(EVENT_FLAG_DTMF, "DTMFEnd",
diff -urpN asterisk-13.9.1/main/message.c asterisk-13.17.0/main/message.c
--- asterisk-13.9.1/main/message.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/message.c	2017-07-12 13:12:08.000000000 +0200
@@ -123,16 +123,14 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<syntax>
 			<parameter name="to" required="true">
 				<para>A To URI for the message.</para>
-				<xi:include xpointer="xpointer(/docs/info[@name='PJSIPMessageToInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='SIPMessageToInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='XMPPMessageToInfo'])" />
+				<xi:include xpointer="xpointer(/docs/info[@name='MessageToInfo'])" />
 			</parameter>
 			<parameter name="from" required="false">
 				<para>A From URI for the message if needed for the
-				message technology being used to send this message.</para>
-				<xi:include xpointer="xpointer(/docs/info[@name='PJSIPMessageFromInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='SIPMessageFromInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='XMPPMessageFromInfo'])" />
+				message technology being used to send this message. This can be a
+				SIP(S) URI, such as <literal>Alice &lt;sip:alice@atlanta.com&gt;</literal>,
+				a string in the format <literal>alice@atlanta.com</literal>, or simply
+				a username such as <literal>alice</literal>.</para>
 			</parameter>
 		</syntax>
 		<description>
@@ -168,16 +166,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
 			<parameter name="To" required="true">
 				<para>The URI the message is to be sent to.</para>
-				<xi:include xpointer="xpointer(/docs/info[@name='PJSIPMessageToInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='SIPMessageToInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='XMPPMessageToInfo'])" />
+				<xi:include xpointer="xpointer(/docs/info[@name='MessageToInfo'])" />
 			</parameter>
 			<parameter name="From">
 				<para>A From URI for the message if needed for the
 				message technology being used to send this message.</para>
-				<xi:include xpointer="xpointer(/docs/info[@name='PJSIPMessageFromInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='SIPMessageFromInfo'])" />
-				<xi:include xpointer="xpointer(/docs/info[@name='XMPPMessageFromInfo'])" />
+				<xi:include xpointer="xpointer(/docs/info[@name='MessageFromInfo'])" />
 			</parameter>
 			<parameter name="Body">
 				<para>The message body text.  This must not contain any newlines as that
@@ -785,11 +779,20 @@ static void chan_cleanup(struct ast_chan
 	if (msg_ds) {
 		ast_channel_datastore_add(chan, msg_ds);
 	}
+
 	/*
 	 * Clear softhangup flags.
 	 */
 	ast_channel_clear_softhangup(chan, AST_SOFTHANGUP_ALL);
 
+	/*
+	 * Flush the alert pipe in case we miscounted somewhere when
+	 * messing with frames on the read queue, we had to flush the
+	 * read queue above, or we had an "Exceptionally long queue
+	 * length" event.
+	 */
+	ast_channel_internal_alert_flush(chan);
+
 	ast_channel_unlock(chan);
 }
 
diff -urpN asterisk-13.9.1/main/named_locks.c asterisk-13.17.0/main/named_locks.c
--- asterisk-13.9.1/main/named_locks.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/named_locks.c	2017-07-12 13:12:08.000000000 +0200
@@ -87,8 +87,8 @@ static void named_locks_shutdown(void)
 
 int ast_named_locks_init(void)
 {
-	named_locks = ao2_container_alloc_hash(0, 0, NAMED_LOCKS_BUCKETS, named_locks_hash, NULL,
-		named_locks_cmp);
+	named_locks = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0,
+		NAMED_LOCKS_BUCKETS, named_locks_hash, NULL, named_locks_cmp);
 	if (!named_locks) {
 		return -1;
 	}
diff -urpN asterisk-13.9.1/main/netsock.c asterisk-13.17.0/main/netsock.c
--- asterisk-13.9.1/main/netsock.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/netsock.c	2017-07-12 13:12:08.000000000 +0200
@@ -33,7 +33,7 @@
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
-#ifndef __linux__
+#if !defined (__linux__) && !defined (__GNU__)
 #if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__Darwin__) || defined(__GLIBC__)
 #include <net/if_dl.h>
 #endif
diff -urpN asterisk-13.9.1/main/netsock2.c asterisk-13.17.0/main/netsock2.c
--- asterisk-13.9.1/main/netsock2.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/netsock2.c	2017-07-12 13:12:08.000000000 +0200
@@ -433,11 +433,16 @@ int ast_sockaddr_cmp_addr(const struct a
 
 uint16_t _ast_sockaddr_port(const struct ast_sockaddr *addr, const char *file, int line, const char *func)
 {
-	if (addr->ss.ss_family == AF_INET &&
-	    addr->len == sizeof(struct sockaddr_in)) {
+	/*
+	 * Test addr->len first to be tolerant of an ast_sockaddr_setnull()
+	 * addr.  In that case addr->len might be the only value initialized.
+	 */
+	if (addr->len == sizeof(struct sockaddr_in)
+		&& addr->ss.ss_family == AF_INET) {
 		return ntohs(((struct sockaddr_in *)&addr->ss)->sin_port);
-	} else if (addr->ss.ss_family == AF_INET6 &&
-		 addr->len == sizeof(struct sockaddr_in6)) {
+	}
+	if (addr->len == sizeof(struct sockaddr_in6)
+		&& addr->ss.ss_family == AF_INET6) {
 		return ntohs(((struct sockaddr_in6 *)&addr->ss)->sin6_port);
 	}
 	if (option_debug >= 1) {
@@ -448,11 +453,15 @@ uint16_t _ast_sockaddr_port(const struct
 
 void _ast_sockaddr_set_port(struct ast_sockaddr *addr, uint16_t port, const char *file, int line, const char *func)
 {
-	if (addr->ss.ss_family == AF_INET &&
-	    addr->len == sizeof(struct sockaddr_in)) {
+	/*
+	 * Test addr->len first to be tolerant of an ast_sockaddr_setnull()
+	 * addr.  In that case addr->len might be the only value initialized.
+	 */
+	if (addr->len == sizeof(struct sockaddr_in)
+		&& addr->ss.ss_family == AF_INET) {
 		((struct sockaddr_in *)&addr->ss)->sin_port = htons(port);
-	} else if (addr->ss.ss_family == AF_INET6 &&
-		 addr->len == sizeof(struct sockaddr_in6)) {
+	} else if (addr->len == sizeof(struct sockaddr_in6)
+		&& addr->ss.ss_family == AF_INET6) {
 		((struct sockaddr_in6 *)&addr->ss)->sin6_port = htons(port);
 	} else if (option_debug >= 1) {
 		ast_log(__LOG_DEBUG, file, line, func,
diff -urpN asterisk-13.9.1/main/pbx.c asterisk-13.17.0/main/pbx.c
--- asterisk-13.9.1/main/pbx.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/pbx.c	2017-07-12 13:12:08.000000000 +0200
@@ -237,9 +237,11 @@ AST_THREADSTORAGE(extensionstate_buf);
 	priority.
 */
 struct ast_exten {
-	char *exten;			/*!< Extension name */
+	char *exten;			/*!< Clean Extension id */
+	char *name;			/*!< Extension name (may include '-' eye candy) */
 	int matchcid;			/*!< Match caller id ? */
 	const char *cidmatch;		/*!< Caller id to match for this extension */
+	const char *cidmatch_display;	/*!< Caller id to match (display version) */
 	int priority;			/*!< Priority */
 	const char *label;		/*!< Label */
 	struct ast_context *parent;	/*!< The context this extension belongs to  */
@@ -614,6 +616,7 @@ static int ast_add_extension2_lockopt(st
 static struct ast_context *find_context_locked(const char *context);
 static struct ast_context *find_context(const char *context);
 static void get_device_state_causing_channels(struct ao2_container *c);
+static unsigned int ext_strncpy(char *dst, const char *src, size_t dst_size, int nofluff);
 
 /*!
  * \internal
@@ -838,9 +841,13 @@ int check_contexts(char *file, int line
 				e2 = ast_hashtab_lookup(c1->root_table, &ex);
 				if (!e2) {
 					if (e1->matchcid == AST_EXT_MATCHCID_ON) {
-						ast_log(LOG_NOTICE,"Called from: %s:%d: The %s context records the exten %s (CID match: %s) but it is not in its root_table\n", file, line, c2->name, dummy_name, e1->cidmatch );
+						ast_log(LOG_NOTICE, "Called from: %s:%d: The %s context records "
+							"the exten %s (CID match: %s) but it is not in its root_table\n",
+							file, line, c2->name, dummy_name, e1->cidmatch_display);
 					} else {
-						ast_log(LOG_NOTICE,"Called from: %s:%d: The %s context records the exten %s but it is not in its root_table\n", file, line, c2->name, dummy_name );
+						ast_log(LOG_NOTICE, "Called from: %s:%d: The %s context records "
+							"the exten %s but it is not in its root_table\n",
+							file, line, c2->name, dummy_name);
 					}
 					check_contexts_trouble();
 				}
@@ -1081,11 +1088,11 @@ static void cli_match_char_tree(struct m
 	if (strlen(node->x) > 1) {
 		ast_cli(fd, "%s[%s]:%c:%c:%d:%s%s%s\n", prefix, node->x, node->is_pattern ? 'Y' : 'N',
 			node->deleted ? 'D' : '-', node->specificity, node->exten? "EXTEN:" : "",
-			node->exten ? node->exten->exten : "", extenstr);
+			node->exten ? node->exten->name : "", extenstr);
 	} else {
 		ast_cli(fd, "%s%s:%c:%c:%d:%s%s%s\n", prefix, node->x, node->is_pattern ? 'Y' : 'N',
 			node->deleted ? 'D' : '-', node->specificity, node->exten? "EXTEN:" : "",
-			node->exten ? node->exten->exten : "", extenstr);
+			node->exten ? node->exten->name : "", extenstr);
 	}
 
 	ast_str_set(&my_prefix, 0, "%s+       ", prefix);
@@ -1200,7 +1207,7 @@ static void new_find_extension(const cha
 										return;                                                                                          \
 									}                                                                                                    \
 								} else {                                                                                                 \
-									ast_debug(4, "returning an exact match-- first found-- %s\n", p->exten->exten);                       \
+									ast_debug(4, "returning an exact match-- first found-- %s\n", p->exten->name);                       \
 									return; /* the first match, by definition, will be the best, because of the sorted tree */           \
 								}                                                                                                        \
 							}                                                                                                            \
@@ -1213,13 +1220,13 @@ static void new_find_extension(const cha
 						if (*(str + 1) || p->next_char->x[0] == '!') {                                                         \
 							new_find_extension(str + 1, score, p->next_char, length + 1, spec + p->specificity, callerid, label, action); \
 							if (score->exten)  {                                                                             \
-						        ast_debug(4 ,"returning an exact match-- %s\n", score->exten->exten);                         \
+						        ast_debug(4 ,"returning an exact match-- %s\n", score->exten->name);                         \
 								return; /* the first match is all we need */                                                 \
 							}												                                                 \
 						} else {                                                                                             \
 							new_find_extension("/", score, p->next_char, length + 1, spec + p->specificity, callerid, label, action);	 \
 							if (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {      \
-						        ast_debug(4,"returning a (can/more) match--- %s\n", score->exten ? score->exten->exten :     \
+						        ast_debug(4,"returning a (can/more) match--- %s\n", score->exten ? score->exten->name :      \
 		                               "NULL");                                                                        \
 								return; /* the first match is all we need */                                                 \
 							}												                                                 \
@@ -1257,14 +1264,17 @@ static void new_find_extension(const cha
 				if (p->exten && *str2 != '/') {
 					update_scoreboard(score, length + i, spec + (i * p->specificity), p->exten, '.', callerid, p->deleted, p);
 					if (score->exten) {
-						ast_debug(4,"return because scoreboard has a match with '/'--- %s\n", score->exten->exten);
+						ast_debug(4, "return because scoreboard has a match with '/'--- %s\n",
+							score->exten->name);
 						return; /* the first match is all we need */
 					}
 				}
 				if (p->next_char && p->next_char->x[0] == '/' && p->next_char->x[1] == 0) {
 					new_find_extension("/", score, p->next_char, length + i, spec+(p->specificity*i), callerid, label, action);
 					if (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {
-						ast_debug(4, "return because scoreboard has exact match OR CANMATCH/MATCHMORE & canmatch set--- %s\n", score->exten ? score->exten->exten : "NULL");
+						ast_debug(4, "return because scoreboard has exact match OR "
+							"CANMATCH/MATCHMORE & canmatch set--- %s\n",
+							score->exten ? score->exten->name : "NULL");
 						return; /* the first match is all we need */
 					}
 				}
@@ -1279,14 +1289,17 @@ static void new_find_extension(const cha
 				if (p->exten && *str2 != '/') {
 					update_scoreboard(score, length + 1, spec + (p->specificity * i), p->exten, '!', callerid, p->deleted, p);
 					if (score->exten) {
-						ast_debug(4, "return because scoreboard has a '!' match--- %s\n", score->exten->exten);
+						ast_debug(4, "return because scoreboard has a '!' match--- %s\n",
+							score->exten->name);
 						return; /* the first match is all we need */
 					}
 				}
 				if (p->next_char && p->next_char->x[0] == '/' && p->next_char->x[1] == 0) {
 					new_find_extension("/", score, p->next_char, length + i, spec + (p->specificity * i), callerid, label, action);
 					if (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {
-						ast_debug(4, "return because scoreboard has exact match OR CANMATCH/MATCHMORE & canmatch set with '/' and '!'--- %s\n", score->exten ? score->exten->exten : "NULL");
+						ast_debug(4, "return because scoreboard has exact match OR "
+							"CANMATCH/MATCHMORE & canmatch set with '/' and '!'--- %s\n",
+							score->exten ? score->exten->name : "NULL");
 						return; /* the first match is all we need */
 					}
 				}
@@ -1295,7 +1308,9 @@ static void new_find_extension(const cha
 				if (p->next_char && callerid && *callerid) {
 					new_find_extension(callerid, score, p->next_char, length + 1, spec, callerid, label, action);
 					if (score->exten || ((action == E_CANMATCH || action == E_MATCHMORE) && score->canmatch)) {
-						ast_debug(4, "return because scoreboard has exact match OR CANMATCH/MATCHMORE & canmatch set with '/'--- %s\n", score->exten ? score->exten->exten : "NULL");
+						ast_debug(4, "return because scoreboard has exact match OR "
+							"CANMATCH/MATCHMORE & canmatch set with '/'--- %s\n",
+							score->exten ? score->exten->name : "NULL");
 						return; /* the first match is all we need */
 					}
 				}
@@ -1648,7 +1663,7 @@ static struct match_char *add_exten_to_p
 				}
 				if (m2->exten) {
 					ast_log(LOG_WARNING, "Found duplicate exten. Had %s found %s\n",
-						m2->deleted ? "(deleted/invalid)" : m2->exten->exten, e1->exten);
+						m2->deleted ? "(deleted/invalid)" : m2->exten->name, e1->name);
 				}
 				m2->exten = e1;
 				m2->deleted = 0;
@@ -1674,7 +1689,7 @@ static struct match_char *add_exten_to_p
 			if (!pat_node[idx_next].buf[0]) {
 				if (m2 && m2->exten) {
 					ast_log(LOG_WARNING, "Found duplicate exten. Had %s found %s\n",
-						m2->deleted ? "(deleted/invalid)" : m2->exten->exten, e1->exten);
+						m2->deleted ? "(deleted/invalid)" : m2->exten->name, e1->name);
 				}
 				m1->deleted = 0;
 				m1->exten = e1;
@@ -2081,6 +2096,41 @@ static int ext_cmp(const char *left, con
 	return ext_cmp_pattern(left + 1, right + 1);
 }
 
+static int ext_fluff_count(const char *exten)
+{
+	int fluff = 0;
+
+	if (*exten != '_') {
+		/* not a pattern, simple check. */
+		while (*exten) {
+			if (*exten == '-') {
+				fluff++;
+			}
+			exten++;
+		}
+
+		return fluff;
+	}
+
+	/* do pattern check */
+	while (*exten) {
+		if (*exten == '-') {
+			fluff++;
+		} else if (*exten == '[') {
+			/* skip set, dashes here matter. */
+			exten = strchr(exten, ']');
+
+			if (!exten) {
+				/* we'll end up warning about this later, don't spam logs */
+				return fluff;
+			}
+		}
+		exten++;
+	}
+
+	return fluff;
+}
+
 int ast_extension_cmp(const char *a, const char *b)
 {
 	int cmp;
@@ -3871,7 +3921,6 @@ static int ast_add_hint(struct ast_exten
 			hint_new->last_presence_state = presence_state;
 			hint_new->last_presence_subtype = subtype;
 			hint_new->last_presence_message = message;
-			message = subtype = NULL;
 		}
 	}
 
@@ -4208,8 +4257,10 @@ static enum ast_pbx_result __ast_pbx_run
 	ast_channel_pbx(c)->rtimeoutms = 10000;
 	ast_channel_pbx(c)->dtimeoutms = 5000;
 
+	ast_channel_lock(c);
 	autoloopflag = ast_test_flag(ast_channel_flags(c), AST_FLAG_IN_AUTOLOOP);	/* save value to restore at the end */
 	ast_set_flag(ast_channel_flags(c), AST_FLAG_IN_AUTOLOOP);
+	ast_channel_unlock(c);
 
 	if (ast_strlen_zero(ast_channel_exten(c))) {
 		/* If not successful fall back to 's' - but only if there is no given exten  */
@@ -4454,8 +4505,10 @@ static enum ast_pbx_result __ast_pbx_run
 		ast_pbx_hangup_handler_run(c);
 	}
 
+	ast_channel_lock(c);
 	ast_set2_flag(ast_channel_flags(c), autoloopflag, AST_FLAG_IN_AUTOLOOP);
 	ast_clear_flag(ast_channel_flags(c), AST_FLAG_BRIDGE_HANGUP_RUN); /* from one round to the next, make sure this gets cleared */
+	ast_channel_unlock(c);
 	pbx_destroy(ast_channel_pbx(c));
 	ast_channel_pbx_set(c, NULL);
 
@@ -4682,6 +4735,13 @@ static struct ast_context *find_context_
 	return c;
 }
 
+/*! \brief Free an ast_include and associated data. */
+static void include_free(struct ast_include *include)
+{
+	ast_destroy_timing(&(include->timing));
+	ast_free(include);
+}
+
 /*!
  * \brief Remove included contexts.
  * This function locks contexts list by &conlist, search for the right context
@@ -4729,8 +4789,7 @@ int ast_context_remove_include2(struct a
 			else
 				con->includes = i->next;
 			/* free include and return */
-			ast_destroy_timing(&(i->timing));
-			ast_free(i);
+			include_free(i);
 			ret = 0;
 			break;
 		}
@@ -4836,6 +4895,7 @@ int ast_context_remove_extension_calleri
 	struct ast_exten *peer;
 	struct ast_exten ex, *exten2, *exten3;
 	char dummy_name[1024];
+	char dummy_cid[1024];
 	struct ast_exten *previous_peer = NULL;
 	struct ast_exten *next_peer = NULL;
 	int found = 0;
@@ -4851,9 +4911,14 @@ int ast_context_remove_extension_calleri
 #endif
 	/* find this particular extension */
 	ex.exten = dummy_name;
+	ext_strncpy(dummy_name, extension, sizeof(dummy_name), 1);
 	ex.matchcid = matchcallerid;
-	ex.cidmatch = callerid;
-	ast_copy_string(dummy_name, extension, sizeof(dummy_name));
+	if (callerid) {
+		ex.cidmatch = dummy_cid;
+		ext_strncpy(dummy_cid, callerid, sizeof(dummy_cid), 1);
+	} else {
+		ex.cidmatch = NULL;
+	}
 	exten = ast_hashtab_lookup(con->root_table, &ex);
 	if (exten) {
 		if (priority == 0) {
@@ -4876,13 +4941,19 @@ int ast_context_remove_extension_calleri
 			if (exten2) {
 				if (exten2->label) { /* if this exten has a label, remove that, too */
 					exten3 = ast_hashtab_remove_this_object(exten->peer_label_table,exten2);
-					if (!exten3)
-						ast_log(LOG_ERROR,"Did not remove this priority label (%d/%s) from the peer_label_table of context %s, extension %s!\n", priority, exten2->label, con->name, exten2->exten);
+					if (!exten3) {
+						ast_log(LOG_ERROR, "Did not remove this priority label (%d/%s) "
+							"from the peer_label_table of context %s, extension %s!\n",
+							priority, exten2->label, con->name, exten2->name);
+					}
 				}
 
 				exten3 = ast_hashtab_remove_this_object(exten->peer_table, exten2);
-				if (!exten3)
-					ast_log(LOG_ERROR,"Did not remove this priority (%d) from the peer_table of context %s, extension %s!\n", priority, con->name, exten2->exten);
+				if (!exten3) {
+					ast_log(LOG_ERROR, "Did not remove this priority (%d) from the "
+						"peer_table of context %s, extension %s!\n",
+						priority, con->name, exten2->name);
+				}
 				if (exten2 == exten && exten2->peer) {
 					exten2 = ast_hashtab_remove_this_object(con->root_table, exten);
 					ast_hashtab_insert_immediate(con->root_table, exten2->peer);
@@ -4891,8 +4962,11 @@ int ast_context_remove_extension_calleri
 					/* well, if the last priority of an exten is to be removed,
 					   then, the extension is removed, too! */
 					exten3 = ast_hashtab_remove_this_object(con->root_table, exten);
-					if (!exten3)
-						ast_log(LOG_ERROR,"Did not remove this exten (%s) from the context root_table (%s) (priority %d)\n", exten->exten, con->name, priority);
+					if (!exten3) {
+						ast_log(LOG_ERROR, "Did not remove this exten (%s) from the "
+							"context root_table (%s) (priority %d)\n",
+							exten->name, con->name, priority);
+					}
 					if (con->pattern_tree) {
 						struct match_char *x = add_exten_to_pattern_tree(con, exten, 1);
 						if (x->exten) { /* this test for safety purposes */
@@ -4903,7 +4977,7 @@ int ast_context_remove_extension_calleri
 				}
 			} else {
 				ast_log(LOG_ERROR,"Could not find priority %d of exten %s in context %s!\n",
-						priority, exten->exten, con->name);
+						priority, exten->name, con->name);
 			}
 		}
 	} else {
@@ -4920,10 +4994,12 @@ int ast_context_remove_extension_calleri
 
 	/* scan the extension list to find first matching extension-registrar */
 	for (exten = con->root; exten; prev_exten = exten, exten = exten->next) {
-		if (!strcmp(exten->exten, extension) &&
-			(!registrar || !strcmp(exten->registrar, registrar)) &&
-			(!matchcallerid || (!ast_strlen_zero(callerid) && !ast_strlen_zero(exten->cidmatch) && !strcmp(exten->cidmatch, callerid)) || (ast_strlen_zero(callerid) && ast_strlen_zero(exten->cidmatch))))
+		if (!strcmp(exten->exten, ex.exten) &&
+			(!matchcallerid ||
+				(!ast_strlen_zero(ex.cidmatch) && !ast_strlen_zero(exten->cidmatch) && !strcmp(exten->cidmatch, ex.cidmatch)) ||
+				(ast_strlen_zero(ex.cidmatch) && ast_strlen_zero(exten->cidmatch)))) {
 			break;
+		}
 	}
 	if (!exten) {
 		/* we can't find right extension */
@@ -4934,8 +5010,8 @@ int ast_context_remove_extension_calleri
 
 	/* scan the priority list to remove extension with exten->priority == priority */
 	for (peer = exten, next_peer = exten->peer ? exten->peer : exten->next;
-		 peer && !strcmp(peer->exten, extension) &&
-			(!callerid || (!matchcallerid && !peer->matchcid) || (matchcallerid && peer->matchcid && !strcmp(peer->cidmatch, callerid))) ;
+		 peer && !strcmp(peer->exten, ex.exten) &&
+			(!callerid || (!matchcallerid && !peer->matchcid) || (matchcallerid && peer->matchcid && !strcmp(peer->cidmatch, ex.cidmatch))) ;
 			peer = next_peer, next_peer = next_peer ? (next_peer->peer ? next_peer->peer : next_peer->next) : NULL) {
 
 		if ((priority == 0 || peer->priority == priority) &&
@@ -5672,7 +5748,8 @@ static void manager_dpsendack(struct man
 static int manager_show_dialplan_helper(struct mansession *s, const struct message *m,
 					const char *actionidtext, const char *context,
 					const char *exten, struct dialplan_counters *dpc,
-					struct ast_include *rinclude)
+					struct ast_include *rinclude,
+					int includecount, const char *includes[])
 {
 	struct ast_context *c;
 	int res = 0, old_total_exten = dpc->total_exten;
@@ -5754,7 +5831,24 @@ static int manager_show_dialplan_helper(
 		while ( (i = ast_walk_context_includes(c, i)) ) {
 			if (exten) {
 				/* Check all includes for the requested extension */
-				manager_show_dialplan_helper(s, m, actionidtext, ast_get_include_name(i), exten, dpc, i);
+				if (includecount >= AST_PBX_MAX_STACK) {
+					ast_log(LOG_WARNING, "Maximum include depth exceeded!\n");
+				} else {
+					int dupe = 0;
+					int x;
+					for (x = 0; x < includecount; x++) {
+						if (!strcasecmp(includes[x], ast_get_include_name(i))) {
+							dupe++;
+							break;
+						}
+					}
+					if (!dupe) {
+						includes[includecount] = ast_get_include_name(i);
+						manager_show_dialplan_helper(s, m, actionidtext, ast_get_include_name(i), exten, dpc, i, includecount + 1, includes);
+					} else {
+						ast_log(LOG_WARNING, "Avoiding circular include of %s within %s\n", ast_get_include_name(i), context);
+					}
+				}
 			} else {
 				if (!dpc->total_items++)
 					manager_dpsendack(s, m);
@@ -5809,6 +5903,7 @@ static int manager_show_dialplan(struct
 {
 	const char *exten, *context;
 	const char *id = astman_get_header(m, "ActionID");
+	const char *incstack[AST_PBX_MAX_STACK];
 	char idtext[256];
 
 	/* Variables used for different counters */
@@ -5824,7 +5919,7 @@ static int manager_show_dialplan(struct
 	exten = astman_get_header(m, "Extension");
 	context = astman_get_header(m, "Context");
 
-	manager_show_dialplan_helper(s, m, idtext, context, exten, &counters, NULL);
+	manager_show_dialplan_helper(s, m, idtext, context, exten, &counters, NULL, 0, incstack);
 
 	if (!ast_strlen_zero(context) && !counters.context_existence) {
 		char errorbuf[BUFSIZ];
@@ -6164,11 +6259,11 @@ static void context_merge(struct ast_con
 
 				dupdstr = ast_strdup(prio_item->data);
 
-				res1 = ast_add_extension2(new, 0, prio_item->exten, prio_item->priority, prio_item->label,
+				res1 = ast_add_extension2(new, 0, prio_item->name, prio_item->priority, prio_item->label,
 										  prio_item->matchcid ? prio_item->cidmatch : NULL, prio_item->app, dupdstr, ast_free_ptr, prio_item->registrar);
 				if (!res1 && new_exten_item && new_prio_item){
 					ast_verb(3,"Dropping old dialplan item %s/%s/%d [%s(%s)] (registrar=%s) due to conflict with new dialplan\n",
-							context->name, prio_item->exten, prio_item->priority, prio_item->app, (char*)prio_item->data, prio_item->registrar);
+							context->name, prio_item->name, prio_item->priority, prio_item->app, (char*)prio_item->data, prio_item->registrar);
 				} else {
 					/* we do NOT pass the priority data from the old to the new -- we pass a copy of it, so no changes to the current dialplan take place,
 					 and no double frees take place, either! */
@@ -6481,8 +6576,7 @@ int ast_context_add_include2(struct ast_
 	/* ... go to last include and check if context is already included too... */
 	for (i = con->includes; i; i = i->next) {
 		if (!strcasecmp(i->name, new_include->name)) {
-			ast_destroy_timing(&(new_include->timing));
-			ast_free(new_include);
+			include_free(new_include);
 			ast_unlock_context(con);
 			errno = EEXIST;
 			return -1;
@@ -6817,29 +6911,51 @@ int ast_async_goto_by_name(const char *c
 	return res;
 }
 
-/*! \brief copy a string skipping whitespace */
-static int ext_strncpy(char *dst, const char *src, int len)
+/*!
+ * \internal
+ * \brief Copy a string skipping whitespace and optionally dashes.
+ *
+ * \param dst Destination buffer to copy src string.
+ * \param src Null terminated string to copy.
+ * \param dst_size Number of bytes in the dst buffer.
+ * \param nofluf Nonzero if '-' chars are not copied.
+ *
+ * \return Number of bytes written to dst including null terminator.
+ */
+static unsigned int ext_strncpy(char *dst, const char *src, size_t dst_size, int nofluff)
 {
-	int count = 0;
-	int insquares = 0;
+	unsigned int count;
+	unsigned int insquares;
+	unsigned int is_pattern;
 
-	while (*src && (count < len - 1)) {
+	if (!dst_size--) {
+		/* There really is no dst buffer */
+		return 0;
+	}
+
+	count = 0;
+	insquares = 0;
+	is_pattern = *src == '_';
+	while (*src && count < dst_size) {
 		if (*src == '[') {
-			insquares = 1;
+			if (is_pattern) {
+				insquares = 1;
+			}
 		} else if (*src == ']') {
 			insquares = 0;
 		} else if (*src == ' ' && !insquares) {
-			src++;
+			++src;
+			continue;
+		} else if (*src == '-' && !insquares && nofluff) {
+			++src;
 			continue;
 		}
-		*dst = *src;
-		dst++;
-		src++;
-		count++;
+		*dst++ = *src++;
+		++count;
 	}
 	*dst = '\0';
 
-	return count;
+	return count + 1;
 }
 
 /*!
@@ -6856,14 +6972,14 @@ static int add_priority(struct ast_conte
 
 	for (ep = NULL; e ; ep = e, e = e->peer) {
 		if (e->label && tmp->label && e->priority != tmp->priority && !strcmp(e->label, tmp->label)) {
-			if (strcmp(e->exten, tmp->exten)) {
+			if (strcmp(e->name, tmp->name)) {
 				ast_log(LOG_WARNING,
 					"Extension '%s' priority %d in '%s', label '%s' already in use at aliased extension '%s' priority %d\n",
-					tmp->exten, tmp->priority, con->name, tmp->label, e->exten, e->priority);
+					tmp->name, tmp->priority, con->name, tmp->label, e->name, e->priority);
 			} else {
 				ast_log(LOG_WARNING,
 					"Extension '%s' priority %d in '%s', label '%s' already in use at priority %d\n",
-					tmp->exten, tmp->priority, con->name, tmp->label, e->priority);
+					tmp->name, tmp->priority, con->name, tmp->label, e->priority);
 			}
 			repeated_label = 1;
 		}
@@ -6889,14 +7005,14 @@ static int add_priority(struct ast_conte
 		/* Can't have something exactly the same.  Is this a
 		   replacement?  If so, replace, otherwise, bonk. */
 		if (!replace) {
-			if (strcmp(e->exten, tmp->exten)) {
+			if (strcmp(e->name, tmp->name)) {
 				ast_log(LOG_WARNING,
 					"Unable to register extension '%s' priority %d in '%s', already in use by aliased extension '%s'\n",
-					tmp->exten, tmp->priority, con->name, e->exten);
+					tmp->name, tmp->priority, con->name, e->name);
 			} else {
 				ast_log(LOG_WARNING,
 					"Unable to register extension '%s' priority %d in '%s', already in use\n",
-					tmp->exten, tmp->priority, con->name);
+					tmp->name, tmp->priority, con->name);
 			}
 
 			return -1;
@@ -7081,6 +7197,8 @@ static int ast_add_extension2_lockopt(st
 	char expand_buf[VAR_BUF_SIZE];
 	struct ast_exten dummy_exten = {0};
 	char dummy_name[1024];
+	int exten_fluff;
+	int callerid_fluff;
 
 	if (ast_strlen_zero(extension)) {
 		ast_log(LOG_ERROR,"You have to be kidding-- add exten '' to context %s? Figure out a name and call me back. Action ignored.\n",
@@ -7090,28 +7208,51 @@ static int ast_add_extension2_lockopt(st
 
 	/* If we are adding a hint evalulate in variables and global variables */
 	if (priority == PRIORITY_HINT && strstr(application, "${") && extension[0] != '_') {
+		int inhibited;
 		struct ast_channel *c = ast_dummy_channel_alloc();
 
 		if (c) {
 			ast_channel_exten_set(c, extension);
 			ast_channel_context_set(c, con->name);
 		}
+
+		/*
+		 * We can allow dangerous functions when adding a hint since
+		 * altering dialplan is itself a privileged activity.  Otherwise,
+		 * we could never execute dangerous functions.
+		 */
+		inhibited = ast_thread_inhibit_escalations_swap(0);
 		pbx_substitute_variables_helper(c, application, expand_buf, sizeof(expand_buf));
+		if (0 < inhibited) {
+			ast_thread_inhibit_escalations();
+		}
+
 		application = expand_buf;
 		if (c) {
 			ast_channel_unref(c);
 		}
 	}
 
+	exten_fluff = ext_fluff_count(extension);
+	callerid_fluff = callerid ? ext_fluff_count(callerid) : 0;
+
 	length = sizeof(struct ast_exten);
 	length += strlen(extension) + 1;
+	if (exten_fluff) {
+		length += strlen(extension) + 1 - exten_fluff;
+	}
 	length += strlen(application) + 1;
-	if (label)
+	if (label) {
 		length += strlen(label) + 1;
-	if (callerid)
+	}
+	if (callerid) {
 		length += strlen(callerid) + 1;
-	else
+		if (callerid_fluff) {
+			length += strlen(callerid) + 1 - callerid_fluff;
+		}
+	} else {
 		length ++;	/* just the '\0' */
+	}
 
 	/* Be optimistic:  Build the extension structure first */
 	if (!(tmp = ast_calloc(1, length)))
@@ -7127,14 +7268,25 @@ static int ast_add_extension2_lockopt(st
 		strcpy(p, label);
 		p += strlen(label) + 1;
 	}
-	tmp->exten = p;
-	p += ext_strncpy(p, extension, strlen(extension) + 1) + 1;
+	tmp->name = p;
+	p += ext_strncpy(p, extension, strlen(extension) + 1, 0);
+	if (exten_fluff) {
+		tmp->exten = p;
+		p += ext_strncpy(p, extension, strlen(extension) + 1 - exten_fluff, 1);
+	} else {
+		/* no fluff, we don't need a copy. */
+		tmp->exten = tmp->name;
+	}
 	tmp->priority = priority;
-	tmp->cidmatch = p;	/* but use p for assignments below */
+	tmp->cidmatch_display = tmp->cidmatch = p;	/* but use p for assignments below */
 
 	/* Blank callerid and NULL callerid are two SEPARATE things.  Do NOT confuse the two!!! */
 	if (callerid) {
-		p += ext_strncpy(p, callerid, strlen(callerid) + 1) + 1;
+		p += ext_strncpy(p, callerid, strlen(callerid) + 1, 0);
+		if (callerid_fluff) {
+			tmp->cidmatch = p;
+			p += ext_strncpy(p, callerid, strlen(callerid) + 1 - callerid_fluff, 1);
+		}
 		tmp->matchcid = AST_EXT_MATCHCID_ON;
 	} else {
 		*p++ = '\0';
@@ -7153,7 +7305,7 @@ static int ast_add_extension2_lockopt(st
 
 	if (con->pattern_tree) { /* usually, on initial load, the pattern_tree isn't formed until the first find_exten; so if we are adding
 								an extension, and the trie exists, then we need to incrementally add this pattern to it. */
-		ast_copy_string(dummy_name, extension, sizeof(dummy_name));
+		ext_strncpy(dummy_name, tmp->exten, sizeof(dummy_name), 1);
 		dummy_exten.exten = dummy_name;
 		dummy_exten.matchcid = AST_EXT_MATCHCID_OFF;
 		dummy_exten.cidmatch = 0;
@@ -7271,19 +7423,19 @@ static int ast_add_extension2_lockopt(st
 	if (option_debug) {
 		if (tmp->matchcid == AST_EXT_MATCHCID_ON) {
 			ast_debug(1, "Added extension '%s' priority %d (CID match '%s') to %s (%p)\n",
-					  tmp->exten, tmp->priority, tmp->cidmatch, con->name, con);
+					  tmp->name, tmp->priority, tmp->cidmatch_display, con->name, con);
 		} else {
 			ast_debug(1, "Added extension '%s' priority %d to %s (%p)\n",
-					  tmp->exten, tmp->priority, con->name, con);
+					  tmp->name, tmp->priority, con->name, con);
 		}
 	}
 
 	if (tmp->matchcid == AST_EXT_MATCHCID_ON) {
 		ast_verb(3, "Added extension '%s' priority %d (CID match '%s') to %s\n",
-				 tmp->exten, tmp->priority, tmp->cidmatch, con->name);
+				 tmp->name, tmp->priority, tmp->cidmatch_display, con->name);
 	} else {
 		ast_verb(3, "Added extension '%s' priority %d to %s\n",
-				 tmp->exten, tmp->priority, con->name);
+				 tmp->name, tmp->priority, con->name);
 	}
 
 	return 0;
@@ -7309,8 +7461,8 @@ struct pbx_outgoing {
 	int dial_res;
 	/*! \brief Set when dialing is completed */
 	unsigned int dialed:1;
-	/*! \brief Set when execution is completed */
-	unsigned int executed:1;
+	/*! \brief Set if we've spawned a thread to do our work */
+	unsigned int in_separate_thread:1;
 };
 
 /*! \brief Destructor for outgoing structure */
@@ -7333,13 +7485,19 @@ static void *pbx_outgoing_exec(void *dat
 	RAII_VAR(struct pbx_outgoing *, outgoing, data, ao2_cleanup);
 	enum ast_dial_result res;
 
-	/* Notify anyone interested that dialing is complete */
 	res = ast_dial_run(outgoing->dial, NULL, 0);
-	ao2_lock(outgoing);
-	outgoing->dial_res = res;
-	outgoing->dialed = 1;
-	ast_cond_signal(&outgoing->cond);
-	ao2_unlock(outgoing);
+
+	if (outgoing->in_separate_thread) {
+		/* Notify anyone interested that dialing is complete */
+		ao2_lock(outgoing);
+		outgoing->dial_res = res;
+		outgoing->dialed = 1;
+		ast_cond_signal(&outgoing->cond);
+		ao2_unlock(outgoing);
+	} else {
+		/* We still need the dial result, but we don't need to lock */
+		outgoing->dial_res = res;
+	}
 
 	/* If the outgoing leg was not answered we can immediately return and go no further */
 	if (res != AST_DIAL_RESULT_ANSWERED) {
@@ -7379,12 +7537,6 @@ static void *pbx_outgoing_exec(void *dat
 		}
 	}
 
-	/* Notify anyone else again that may be interested that execution is complete */
-	ao2_lock(outgoing);
-	outgoing->executed = 1;
-	ast_cond_signal(&outgoing->cond);
-	ao2_unlock(outgoing);
-
 	return NULL;
 }
 
@@ -7564,34 +7716,42 @@ static int pbx_outgoing_attempt(const ch
 		}
 	}
 
+	/* This extra reference is dereferenced by pbx_outgoing_exec */
 	ao2_ref(outgoing, +1);
-	if (ast_pthread_create_detached(&thread, NULL, pbx_outgoing_exec, outgoing)) {
-		ast_log(LOG_WARNING, "Unable to spawn dialing thread for '%s/%s'\n", type, addr);
-		ao2_ref(outgoing, -1);
-		if (locked_channel) {
-			if (!synchronous) {
-				ast_channel_unlock(dialed);
+
+	if (synchronous == AST_OUTGOING_WAIT_COMPLETE) {
+		/*
+		 * Because we are waiting until this is complete anyway, there is no
+		 * sense in creating another thread that we will just need to wait
+		 * for, so instead we commandeer the current thread.
+		 */
+		pbx_outgoing_exec(outgoing);
+	} else {
+		outgoing->in_separate_thread = 1;
+
+		if (ast_pthread_create_detached(&thread, NULL, pbx_outgoing_exec, outgoing)) {
+			ast_log(LOG_WARNING, "Unable to spawn dialing thread for '%s/%s'\n", type, addr);
+			ao2_ref(outgoing, -1);
+			if (locked_channel) {
+				if (!synchronous) {
+					ast_channel_unlock(dialed);
+				}
+				ast_channel_unref(dialed);
 			}
-			ast_channel_unref(dialed);
+			return -1;
 		}
-		return -1;
-	}
 
-	if (synchronous) {
-		ao2_lock(outgoing);
-		/* Wait for dialing to complete */
-		while (!outgoing->dialed) {
-			ast_cond_wait(&outgoing->cond, ao2_object_get_lockaddr(outgoing));
-		}
-		if (1 < synchronous
-			&& outgoing->dial_res == AST_DIAL_RESULT_ANSWERED) {
-			/* Wait for execution to complete */
-			while (!outgoing->executed) {
+		if (synchronous) {
+			ao2_lock(outgoing);
+			/* Wait for dialing to complete */
+			while (!outgoing->dialed) {
 				ast_cond_wait(&outgoing->cond, ao2_object_get_lockaddr(outgoing));
 			}
+			ao2_unlock(outgoing);
 		}
-		ao2_unlock(outgoing);
+	}
 
+	if (synchronous) {
 		/* Determine the outcome of the dialing attempt up to it being answered. */
 		if (reason) {
 			*reason = pbx_dial_reason(outgoing->dial_res,
@@ -7638,7 +7798,7 @@ int ast_pbx_outgoing_exten(const char *t
 		early_media, assignedids);
 
 	if (res < 0 /* Call failed to get connected for some reason. */
-		&& 1 < synchronous
+		&& 0 < synchronous
 		&& ast_exists_extension(NULL, context, "failed", 1, NULL)) {
 		struct ast_channel *failed;
 
@@ -7706,7 +7866,7 @@ static void __ast_internal_context_destr
 	for (tmpi = tmp->includes; tmpi; ) { /* Free includes */
 		struct ast_include *tmpil = tmpi;
 		tmpi = tmpi->next;
-		ast_free(tmpil);
+		include_free(tmpil);
 	}
 	for (ipi = tmp->ignorepats; ipi; ) { /* Free ignorepats */
 		struct ast_ignorepat *ipl = ipi;
@@ -7800,12 +7960,12 @@ void __ast_context_destroy(struct ast_co
 					if (pi) {
 						pi->next = i->next;
 						/* free include */
-						ast_free(i);
+						include_free(i);
 						continue; /* don't change pi */
 					} else {
 						tmp->includes = i->next;
 						/* free include */
-						ast_free(i);
+						include_free(i);
 						continue; /* don't change pi */
 					}
 				}
@@ -7842,7 +8002,7 @@ void __ast_context_destroy(struct ast_co
 							continue;
 						}
 						ast_verb(3, "Remove %s/%s/%d, registrar=%s; con=%s(%p); con->root=%p\n",
-								 tmp->name, prio_item->exten, prio_item->priority, registrar, con? con->name : "<nil>", con, con? con->root_table: NULL);
+								 tmp->name, prio_item->name, prio_item->priority, registrar, con? con->name : "<nil>", con, con? con->root_table: NULL);
 						ast_copy_string(extension, prio_item->exten, sizeof(extension));
 						if (prio_item->cidmatch) {
 							ast_copy_string(cidmatch, prio_item->cidmatch, sizeof(cidmatch));
@@ -8242,7 +8402,7 @@ struct ast_context *ast_get_extension_co
 
 const char *ast_get_extension_name(struct ast_exten *exten)
 {
-	return exten ? exten->exten : NULL;
+	return exten ? exten->name : NULL;
 }
 
 const char *ast_get_extension_label(struct ast_exten *exten)
@@ -8295,7 +8455,7 @@ int ast_get_extension_matchcid(struct as
 
 const char *ast_get_extension_cidmatch(struct ast_exten *e)
 {
-	return e ? e->cidmatch : NULL;
+	return e ? e->cidmatch_display : NULL;
 }
 
 const char *ast_get_extension_app(struct ast_exten *e)
diff -urpN asterisk-13.9.1/main/pbx_app.c asterisk-13.17.0/main/pbx_app.c
--- asterisk-13.9.1/main/pbx_app.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/pbx_app.c	2017-07-12 13:12:08.000000000 +0200
@@ -315,7 +315,6 @@ static char *handle_show_applications(st
 	int like = 0, describing = 0;
 	int total_match = 0;    /* Number of matches in like clause */
 	int total_apps = 0;     /* Number of apps registered */
-	static const char * const choices[] = { "like", "describing", NULL };
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -327,7 +326,7 @@ static char *handle_show_applications(st
 			"       If 'describing', <text> will be a substring of the description\n";
 		return NULL;
 	case CLI_GENERATE:
-		return (a->pos != 3) ? NULL : ast_cli_complete(a->word, choices, a->n);
+		return NULL;
 	}
 
 	AST_RWLIST_RDLOCK(&apps);
@@ -397,6 +396,11 @@ int ast_unregister_application(const cha
 	struct ast_app *cur;
 	int cmp;
 
+	/* Anticipate need for conlock in unreference_cached_app(), in order to avoid
+	 * possible deadlock with pbx_extension_helper()/pbx_findapp()
+	 */
+	ast_rdlock_contexts();
+
 	AST_RWLIST_WRLOCK(&apps);
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&apps, cur, list) {
 		cmp = strcasecmp(app, cur->name);
@@ -419,6 +423,8 @@ int ast_unregister_application(const cha
 	AST_RWLIST_TRAVERSE_SAFE_END;
 	AST_RWLIST_UNLOCK(&apps);
 
+	ast_unlock_contexts();
+
 	return cur ? 0 : -1;
 }
 
diff -urpN asterisk-13.9.1/main/pbx_builtins.c asterisk-13.17.0/main/pbx_builtins.c
--- asterisk-13.9.1/main/pbx_builtins.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/pbx_builtins.c	2017-07-12 13:12:08.000000000 +0200
@@ -1113,6 +1113,13 @@ static int pbx_builtin_background(struct
 		}
 	}
 
+	/* If ast_waitstream didn't give us back a digit, there is nothing else to do */
+	if (res <= 0) {
+		goto done;
+	}
+
+	exten[0] = res;
+
 	/*
 	 * If the single digit DTMF is an extension in the specified context, then
 	 * go there and signal no DTMF.  Otherwise, we should exit with that DTMF.
@@ -1132,7 +1139,6 @@ static int pbx_builtin_background(struct
 	 * be returned (see #16434).
 	 */
 	if (!ast_test_flag(ast_channel_flags(chan), AST_FLAG_DISABLE_WORKAROUNDS)
-		&& (exten[0] = res)
 		&& ast_canmatch_extension(chan, args.context, exten, 1,
 			S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL))
 		&& !ast_matchmore_extension(chan, args.context, exten, 1,
diff -urpN asterisk-13.9.1/main/pbx_functions.c asterisk-13.17.0/main/pbx_functions.c
--- asterisk-13.9.1/main/pbx_functions.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/pbx_functions.c	2017-07-12 13:12:08.000000000 +0200
@@ -482,7 +482,6 @@ int ast_thread_inhibit_escalations(void)
 
 	thread_inhibit_escalations = ast_threadstorage_get(
 		&thread_inhibit_escalations_tl, sizeof(*thread_inhibit_escalations));
-
 	if (thread_inhibit_escalations == NULL) {
 		ast_log(LOG_ERROR, "Error inhibiting privilege escalations for current thread\n");
 		return -1;
@@ -492,6 +491,23 @@ int ast_thread_inhibit_escalations(void)
 	return 0;
 }
 
+int ast_thread_inhibit_escalations_swap(int inhibit)
+{
+	int *thread_inhibit_escalations;
+	int orig;
+
+	thread_inhibit_escalations = ast_threadstorage_get(
+		&thread_inhibit_escalations_tl, sizeof(*thread_inhibit_escalations));
+	if (thread_inhibit_escalations == NULL) {
+		ast_log(LOG_ERROR, "Error swapping privilege escalations inhibit for current thread\n");
+		return -1;
+	}
+
+	orig = *thread_inhibit_escalations;
+	*thread_inhibit_escalations = !!inhibit;
+	return orig;
+}
+
 /*!
  * \brief Indicates whether the current thread inhibits the execution of
  * dangerous functions.
@@ -505,7 +521,6 @@ static int thread_inhibits_escalations(v
 
 	thread_inhibit_escalations = ast_threadstorage_get(
 		&thread_inhibit_escalations_tl, sizeof(*thread_inhibit_escalations));
-
 	if (thread_inhibit_escalations == NULL) {
 		ast_log(LOG_ERROR, "Error checking thread's ability to run dangerous functions\n");
 		/* On error, assume that we are inhibiting */
diff -urpN asterisk-13.9.1/main/pbx_hangup_handler.c asterisk-13.17.0/main/pbx_hangup_handler.c
--- asterisk-13.9.1/main/pbx_hangup_handler.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/pbx_hangup_handler.c	2017-07-12 13:12:08.000000000 +0200
@@ -260,7 +260,7 @@ static char *handle_show_hangup_all(stru
 			"       Show hangup handlers for all channels.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return ast_complete_channels(a->line, a->word, a->pos, a->n, e->args);
+		return NULL;
 	}
 
 	if (a->argc < 4) {
diff -urpN asterisk-13.9.1/main/presencestate.c asterisk-13.17.0/main/presencestate.c
--- asterisk-13.9.1/main/presencestate.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/presencestate.c	2017-07-12 13:12:08.000000000 +0200
@@ -151,6 +151,9 @@ static enum ast_presence_state ast_prese
 	char *label = ast_strdupa(presence_provider);
 	int res = AST_PRESENCE_INVALID;
 
+	*subtype = NULL;
+	*message = NULL;
+
 	if (check_cache) {
 		res = presence_state_cached(presence_provider, subtype, message);
 		if (res != AST_PRESENCE_INVALID) {
diff -urpN asterisk-13.9.1/main/rtp_engine.c asterisk-13.17.0/main/rtp_engine.c
--- asterisk-13.9.1/main/rtp_engine.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/rtp_engine.c	2017-07-12 13:12:08.000000000 +0200
@@ -102,6 +102,9 @@
 					and sending this report.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">RTCPReceived</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="RTCPReceived">
@@ -131,6 +134,9 @@
 				<xi:include xpointer="xpointer(/docs/managerEvent[@name='RTCPSent']/managerEventInstance/syntax/parameter[@name='SentOctets'])" />
 				<xi:include xpointer="xpointer(/docs/managerEvent[@name='RTCPSent']/managerEventInstance/syntax/parameter[contains(@name, 'ReportX')])" />
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">RTCPSent</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
  ***/
@@ -139,23 +145,36 @@
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
-#include <math.h>
-
-#include "asterisk/channel.h"
-#include "asterisk/frame.h"
-#include "asterisk/module.h"
-#include "asterisk/rtp_engine.h"
+#include <math.h>                       /* for sqrt, MAX */
+#include <sched.h>                      /* for sched_yield */
+#include <sys/time.h>                   /* for timeval */
+#include <time.h>                       /* for time_t */
+
+#include "asterisk/_private.h"          /* for ast_rtp_engine_init prototype */
+#include "asterisk/astobj2.h"           /* for ao2_cleanup, ao2_ref, etc */
+#include "asterisk/channel.h"           /* for ast_channel_name, etc */
+#include "asterisk/codec.h"             /* for ast_codec_media_type2str, etc */
+#include "asterisk/format.h"            /* for ast_format_cmp, etc */
+#include "asterisk/format_cache.h"      /* for ast_format_adpcm, etc */
+#include "asterisk/format_cap.h"        /* for ast_format_cap_alloc, etc */
+#include "asterisk/json.h"              /* for ast_json_ref, etc */
+#include "asterisk/linkedlists.h"       /* for ast_rtp_engine::<anonymous>, etc */
+#include "asterisk/lock.h"              /* for ast_rwlock_unlock, etc */
+#include "asterisk/logger.h"            /* for ast_log, ast_debug, etc */
 #include "asterisk/manager.h"
-#include "asterisk/options.h"
-#include "asterisk/astobj2.h"
-#include "asterisk/pbx.h"
-#include "asterisk/translate.h"
-#include "asterisk/netsock2.h"
-#include "asterisk/_private.h"
-#include "asterisk/framehook.h"
-#include "asterisk/stasis.h"
-#include "asterisk/json.h"
-#include "asterisk/stasis_channels.h"
+#include "asterisk/module.h"            /* for ast_module_unref, etc */
+#include "asterisk/netsock2.h"          /* for ast_sockaddr_copy, etc */
+#include "asterisk/options.h"           /* for ast_option_rtpptdynamic */
+#include "asterisk/pbx.h"               /* for pbx_builtin_setvar_helper */
+#include "asterisk/res_srtp.h"          /* for ast_srtp_res */
+#include "asterisk/rtp_engine.h"        /* for ast_rtp_codecs, etc */
+#include "asterisk/stasis.h"            /* for stasis_message_data, etc */
+#include "asterisk/stasis_channels.h"   /* for ast_channel_stage_snapshot, etc */
+#include "asterisk/strings.h"           /* for ast_str_append, etc */
+#include "asterisk/time.h"              /* for ast_tvdiff_ms, ast_tvnow */
+#include "asterisk/translate.h"         /* for ast_translate_available_formats */
+#include "asterisk/utils.h"             /* for ast_free, ast_strdup, etc */
+#include "asterisk/vector.h"            /* for AST_VECTOR_GET, etc */
 
 struct ast_srtp_res *res_srtp = NULL;
 struct ast_srtp_policy_res *res_srtp_policy = NULL;
@@ -357,9 +376,14 @@ static void instance_destructor(void *ob
 	struct ast_rtp_instance *instance = obj;
 
 	/* Pass us off to the engine to destroy */
-	if (instance->data && instance->engine->destroy(instance)) {
-		ast_debug(1, "Engine '%s' failed to destroy RTP instance '%p'\n", instance->engine->name, instance);
-		return;
+	if (instance->data) {
+		/*
+		 * Lock in case the RTP engine has other threads that
+		 * need synchronization with the destruction.
+		 */
+		ao2_lock(instance);
+		instance->engine->destroy(instance);
+		ao2_unlock(instance);
 	}
 
 	if (instance->srtp) {
@@ -434,12 +458,20 @@ struct ast_rtp_instance *ast_rtp_instanc
 
 	ast_debug(1, "Using engine '%s' for RTP instance '%p'\n", engine->name, instance);
 
-	/* And pass it off to the engine to setup */
+	/*
+	 * And pass it off to the engine to setup
+	 *
+	 * Lock in case the RTP engine has other threads that
+	 * need synchronization with the construction.
+	 */
+	ao2_lock(instance);
 	if (instance->engine->new(instance, sched, &address, data)) {
 		ast_debug(1, "Engine '%s' failed to setup RTP instance '%p'\n", engine->name, instance);
+		ao2_unlock(instance);
 		ao2_ref(instance, -1);
 		return NULL;
 	}
+	ao2_unlock(instance);
 
 	ast_debug(1, "RTP instance '%p' is setup and ready to go\n", instance);
 
@@ -468,31 +500,48 @@ void *ast_rtp_instance_get_data(struct a
 
 int ast_rtp_instance_write(struct ast_rtp_instance *instance, struct ast_frame *frame)
 {
-	return instance->engine->write(instance, frame);
+	int res;
+
+	ao2_lock(instance);
+	res = instance->engine->write(instance, frame);
+	ao2_unlock(instance);
+	return res;
 }
 
 struct ast_frame *ast_rtp_instance_read(struct ast_rtp_instance *instance, int rtcp)
 {
-	return instance->engine->read(instance, rtcp);
+	struct ast_frame *frame;
+
+	ao2_lock(instance);
+	frame = instance->engine->read(instance, rtcp);
+	ao2_unlock(instance);
+	return frame;
 }
 
 int ast_rtp_instance_set_local_address(struct ast_rtp_instance *instance,
 		const struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
 	ast_sockaddr_copy(&instance->local_address, address);
+	ao2_unlock(instance);
 	return 0;
 }
 
-int ast_rtp_instance_set_incoming_source_address(struct ast_rtp_instance *instance,
-						 const struct ast_sockaddr *address)
+static void rtp_instance_set_incoming_source_address_nolock(struct ast_rtp_instance *instance,
+	const struct ast_sockaddr *address)
 {
 	ast_sockaddr_copy(&instance->incoming_source_address, address);
-
-	/* moo */
-
 	if (instance->engine->remote_address_set) {
 		instance->engine->remote_address_set(instance, &instance->incoming_source_address);
 	}
+}
+
+int ast_rtp_instance_set_incoming_source_address(struct ast_rtp_instance *instance,
+	const struct ast_sockaddr *address)
+{
+	ao2_lock(instance);
+	rtp_instance_set_incoming_source_address_nolock(instance, address);
+	ao2_unlock(instance);
 
 	return 0;
 }
@@ -500,18 +549,26 @@ int ast_rtp_instance_set_incoming_source
 int ast_rtp_instance_set_requested_target_address(struct ast_rtp_instance *instance,
 						  const struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
+
 	ast_sockaddr_copy(&instance->requested_target_address, address);
+	rtp_instance_set_incoming_source_address_nolock(instance, address);
+
+	ao2_unlock(instance);
 
-	return ast_rtp_instance_set_incoming_source_address(instance, address);
+	return 0;
 }
 
 int ast_rtp_instance_get_and_cmp_local_address(struct ast_rtp_instance *instance,
 		struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
 	if (ast_sockaddr_cmp(address, &instance->local_address) != 0) {
 		ast_sockaddr_copy(address, &instance->local_address);
+		ao2_unlock(instance);
 		return 1;
 	}
+	ao2_unlock(instance);
 
 	return 0;
 }
@@ -519,16 +576,21 @@ int ast_rtp_instance_get_and_cmp_local_a
 void ast_rtp_instance_get_local_address(struct ast_rtp_instance *instance,
 		struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
 	ast_sockaddr_copy(address, &instance->local_address);
+	ao2_unlock(instance);
 }
 
 int ast_rtp_instance_get_and_cmp_requested_target_address(struct ast_rtp_instance *instance,
 		struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
 	if (ast_sockaddr_cmp(address, &instance->requested_target_address) != 0) {
 		ast_sockaddr_copy(address, &instance->requested_target_address);
+		ao2_unlock(instance);
 		return 1;
 	}
+	ao2_unlock(instance);
 
 	return 0;
 }
@@ -536,43 +598,63 @@ int ast_rtp_instance_get_and_cmp_request
 void ast_rtp_instance_get_incoming_source_address(struct ast_rtp_instance *instance,
 						  struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
 	ast_sockaddr_copy(address, &instance->incoming_source_address);
+	ao2_unlock(instance);
 }
 
 void ast_rtp_instance_get_requested_target_address(struct ast_rtp_instance *instance,
 						   struct ast_sockaddr *address)
 {
+	ao2_lock(instance);
 	ast_sockaddr_copy(address, &instance->requested_target_address);
+	ao2_unlock(instance);
 }
 
 void ast_rtp_instance_set_extended_prop(struct ast_rtp_instance *instance, int property, void *value)
 {
 	if (instance->engine->extended_prop_set) {
+		ao2_lock(instance);
 		instance->engine->extended_prop_set(instance, property, value);
+		ao2_unlock(instance);
 	}
 }
 
 void *ast_rtp_instance_get_extended_prop(struct ast_rtp_instance *instance, int property)
 {
+	void *prop;
+
 	if (instance->engine->extended_prop_get) {
-		return instance->engine->extended_prop_get(instance, property);
+		ao2_lock(instance);
+		prop = instance->engine->extended_prop_get(instance, property);
+		ao2_unlock(instance);
+	} else {
+		prop = NULL;
 	}
 
-	return NULL;
+	return prop;
 }
 
 void ast_rtp_instance_set_prop(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value)
 {
+	ao2_lock(instance);
 	instance->properties[property] = value;
 
 	if (instance->engine->prop_set) {
 		instance->engine->prop_set(instance, property, value);
 	}
+	ao2_unlock(instance);
 }
 
 int ast_rtp_instance_get_prop(struct ast_rtp_instance *instance, enum ast_rtp_property property)
 {
-	return instance->properties[property];
+	int prop;
+
+	ao2_lock(instance);
+	prop = instance->properties[property];
+	ao2_unlock(instance);
+
+	return prop;
 }
 
 struct ast_rtp_codecs *ast_rtp_instance_get_codecs(struct ast_rtp_instance *instance)
@@ -613,9 +695,12 @@ void ast_rtp_codecs_payloads_clear(struc
 
 	if (instance && instance->engine && instance->engine->payload_set) {
 		int i;
+
+		ao2_lock(instance);
 		for (i = 0; i < AST_RTP_MAX_PT; i++) {
 			instance->engine->payload_set(instance, i, 0, NULL, 0);
 		}
+		ao2_unlock(instance);
 	}
 }
 
@@ -623,9 +708,15 @@ void ast_rtp_codecs_payloads_copy(struct
 {
 	int i;
 
-	ast_rwlock_rdlock(&src->codecs_lock);
 	ast_rwlock_wrlock(&dest->codecs_lock);
 
+	/* Deadlock avoidance because of held write lock. */
+	while (ast_rwlock_tryrdlock(&src->codecs_lock)) {
+		ast_rwlock_unlock(&dest->codecs_lock);
+		sched_yield();
+		ast_rwlock_wrlock(&dest->codecs_lock);
+	}
+
 	for (i = 0; i < AST_VECTOR_SIZE(&src->payloads); i++) {
 		struct ast_rtp_payload_type *type;
 
@@ -641,12 +732,14 @@ void ast_rtp_codecs_payloads_copy(struct
 		AST_VECTOR_REPLACE(&dest->payloads, i, type);
 
 		if (instance && instance->engine && instance->engine->payload_set) {
+			ao2_lock(instance);
 			instance->engine->payload_set(instance, i, type->asterisk_format, type->format, type->rtp_code);
+			ao2_unlock(instance);
 		}
 	}
 	dest->framing = src->framing;
-	ast_rwlock_unlock(&dest->codecs_lock);
 	ast_rwlock_unlock(&src->codecs_lock);
+	ast_rwlock_unlock(&dest->codecs_lock);
 }
 
 void ast_rtp_codecs_payloads_set_m_type(struct ast_rtp_codecs *codecs, struct ast_rtp_instance *instance, int payload)
@@ -677,7 +770,9 @@ void ast_rtp_codecs_payloads_set_m_type(
 	AST_VECTOR_REPLACE(&codecs->payloads, payload, new_type);
 
 	if (instance && instance->engine && instance->engine->payload_set) {
+		ao2_lock(instance);
 		instance->engine->payload_set(instance, payload, new_type->asterisk_format, new_type->format, new_type->rtp_code);
+		ao2_unlock(instance);
 	}
 
 	ast_rwlock_unlock(&codecs->codecs_lock);
@@ -737,6 +832,7 @@ int ast_rtp_codecs_payloads_set_rtpmap_t
 		} else {
 			new_type->format = t->payload_type.format;
 		}
+
 		if (new_type->format) {
 			/* SDP parsing automatically increases the reference count */
 			new_type->format = ast_format_parse_sdp_fmtp(new_type->format, "");
@@ -744,7 +840,9 @@ int ast_rtp_codecs_payloads_set_rtpmap_t
 		AST_VECTOR_REPLACE(&codecs->payloads, pt, new_type);
 
 		if (instance && instance->engine && instance->engine->payload_set) {
+			ao2_lock(instance);
 			instance->engine->payload_set(instance, pt, new_type->asterisk_format, new_type->format, new_type->rtp_code);
+			ao2_unlock(instance);
 		}
 
 		break;
@@ -778,7 +876,9 @@ void ast_rtp_codecs_payloads_unset(struc
 	}
 
 	if (instance && instance->engine && instance->engine->payload_set) {
+		ao2_lock(instance);
 		instance->engine->payload_set(instance, payload, 0, NULL, 0);
+		ao2_unlock(instance);
 	}
 
 	ast_rwlock_unlock(&codecs->codecs_lock);
@@ -1057,57 +1157,127 @@ char *ast_rtp_lookup_mime_multiple2(stru
 
 int ast_rtp_instance_dtmf_begin(struct ast_rtp_instance *instance, char digit)
 {
-	return instance->engine->dtmf_begin ? instance->engine->dtmf_begin(instance, digit) : -1;
+	int res;
+
+	if (instance->engine->dtmf_begin) {
+		ao2_lock(instance);
+		res = instance->engine->dtmf_begin(instance, digit);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 int ast_rtp_instance_dtmf_end(struct ast_rtp_instance *instance, char digit)
 {
-	return instance->engine->dtmf_end ? instance->engine->dtmf_end(instance, digit) : -1;
+	int res;
+
+	if (instance->engine->dtmf_end) {
+		ao2_lock(instance);
+		res = instance->engine->dtmf_end(instance, digit);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
+
 int ast_rtp_instance_dtmf_end_with_duration(struct ast_rtp_instance *instance, char digit, unsigned int duration)
 {
-	return instance->engine->dtmf_end_with_duration ? instance->engine->dtmf_end_with_duration(instance, digit, duration) : -1;
+	int res;
+
+	if (instance->engine->dtmf_end_with_duration) {
+		ao2_lock(instance);
+		res = instance->engine->dtmf_end_with_duration(instance, digit, duration);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 int ast_rtp_instance_dtmf_mode_set(struct ast_rtp_instance *instance, enum ast_rtp_dtmf_mode dtmf_mode)
 {
-	return (!instance->engine->dtmf_mode_set || instance->engine->dtmf_mode_set(instance, dtmf_mode)) ? -1 : 0;
+	int res;
+
+	if (instance->engine->dtmf_mode_set) {
+		ao2_lock(instance);
+		res = instance->engine->dtmf_mode_set(instance, dtmf_mode);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 enum ast_rtp_dtmf_mode ast_rtp_instance_dtmf_mode_get(struct ast_rtp_instance *instance)
 {
-	return instance->engine->dtmf_mode_get ? instance->engine->dtmf_mode_get(instance) : 0;
+	int res;
+
+	if (instance->engine->dtmf_mode_get) {
+		ao2_lock(instance);
+		res = instance->engine->dtmf_mode_get(instance);
+		ao2_unlock(instance);
+	} else {
+		res = 0;
+	}
+	return res;
 }
 
 void ast_rtp_instance_update_source(struct ast_rtp_instance *instance)
 {
 	if (instance->engine->update_source) {
+		ao2_lock(instance);
 		instance->engine->update_source(instance);
+		ao2_unlock(instance);
 	}
 }
 
 void ast_rtp_instance_change_source(struct ast_rtp_instance *instance)
 {
 	if (instance->engine->change_source) {
+		ao2_lock(instance);
 		instance->engine->change_source(instance);
+		ao2_unlock(instance);
 	}
 }
 
 int ast_rtp_instance_set_qos(struct ast_rtp_instance *instance, int tos, int cos, const char *desc)
 {
-	return instance->engine->qos ? instance->engine->qos(instance, tos, cos, desc) : -1;
+	int res;
+
+	if (instance->engine->qos) {
+		ao2_lock(instance);
+		res = instance->engine->qos(instance, tos, cos, desc);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 void ast_rtp_instance_stop(struct ast_rtp_instance *instance)
 {
 	if (instance->engine->stop) {
+		ao2_lock(instance);
 		instance->engine->stop(instance);
+		ao2_unlock(instance);
 	}
 }
 
 int ast_rtp_instance_fd(struct ast_rtp_instance *instance, int rtcp)
 {
-	return instance->engine->fd ? instance->engine->fd(instance, rtcp) : -1;
+	int res;
+
+	if (instance->engine->fd) {
+		ao2_lock(instance);
+		res = instance->engine->fd(instance, rtcp);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 struct ast_rtp_glue *ast_rtp_instance_get_glue(const char *type)
@@ -1140,12 +1310,19 @@ static void unref_instance_cond(struct a
 
 struct ast_rtp_instance *ast_rtp_instance_get_bridged(struct ast_rtp_instance *instance)
 {
-	return instance->bridged;
+	struct ast_rtp_instance *bridged;
+
+	ao2_lock(instance);
+	bridged = instance->bridged;
+	ao2_unlock(instance);
+	return bridged;
 }
 
 void ast_rtp_instance_set_bridged(struct ast_rtp_instance *instance, struct ast_rtp_instance *bridged)
 {
+	ao2_lock(instance);
 	instance->bridged = bridged;
+	ao2_unlock(instance);
 }
 
 void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c_dst, struct ast_channel *c_src)
@@ -1317,17 +1494,44 @@ done:
 
 int ast_rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations)
 {
-	return instance->engine->red_init ? instance->engine->red_init(instance, buffer_time, payloads, generations) : -1;
+	int res;
+
+	if (instance->engine->red_init) {
+		ao2_lock(instance);
+		res = instance->engine->red_init(instance, buffer_time, payloads, generations);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 int ast_rtp_red_buffer(struct ast_rtp_instance *instance, struct ast_frame *frame)
 {
-	return instance->engine->red_buffer ? instance->engine->red_buffer(instance, frame) : -1;
+	int res;
+
+	if (instance->engine->red_buffer) {
+		ao2_lock(instance);
+		res = instance->engine->red_buffer(instance, frame);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 int ast_rtp_instance_get_stats(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat)
 {
-	return instance->engine->get_stat ? instance->engine->get_stat(instance, stats, stat) : -1;
+	int res;
+
+	if (instance->engine->get_stat) {
+		ao2_lock(instance);
+		res = instance->engine->get_stat(instance, stats, stat);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 char *ast_rtp_instance_get_quality(struct ast_rtp_instance *instance, enum ast_rtp_instance_stat_field field, char *buf, size_t size)
@@ -1374,16 +1578,16 @@ void ast_rtp_instance_set_stats_vars(str
 {
 	char quality_buf[AST_MAX_USER_FIELD];
 	char *quality;
-	struct ast_channel *bridge = ast_channel_bridge_peer(chan);
+	struct ast_channel *bridge;
 
-	ast_channel_lock(chan);
-	ast_channel_stage_snapshot(chan);
-	ast_channel_unlock(chan);
+	bridge = ast_channel_bridge_peer(chan);
 	if (bridge) {
-		ast_channel_lock(bridge);
+		ast_channel_lock_both(chan, bridge);
 		ast_channel_stage_snapshot(bridge);
-		ast_channel_unlock(bridge);
+	} else {
+		ast_channel_lock(chan);
 	}
+	ast_channel_stage_snapshot(chan);
 
 	quality = ast_rtp_instance_get_quality(instance, AST_RTP_INSTANCE_STAT_FIELD_QUALITY,
 		quality_buf, sizeof(quality_buf));
@@ -1421,11 +1625,9 @@ void ast_rtp_instance_set_stats_vars(str
 		}
 	}
 
-	ast_channel_lock(chan);
 	ast_channel_stage_snapshot_done(chan);
 	ast_channel_unlock(chan);
 	if (bridge) {
-		ast_channel_lock(bridge);
 		ast_channel_stage_snapshot_done(bridge);
 		ast_channel_unlock(bridge);
 		ast_channel_unref(bridge);
@@ -1434,14 +1636,33 @@ void ast_rtp_instance_set_stats_vars(str
 
 int ast_rtp_instance_set_read_format(struct ast_rtp_instance *instance, struct ast_format *format)
 {
-	return instance->engine->set_read_format ? instance->engine->set_read_format(instance, format) : -1;
+	int res;
+
+	if (instance->engine->set_read_format) {
+		ao2_lock(instance);
+		res = instance->engine->set_read_format(instance, format);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
 int ast_rtp_instance_set_write_format(struct ast_rtp_instance *instance, struct ast_format *format)
 {
-	return instance->engine->set_write_format ? instance->engine->set_write_format(instance, format) : -1;
+	int res;
+
+	if (instance->engine->set_read_format) {
+		ao2_lock(instance);
+		res = instance->engine->set_write_format(instance, format);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
+	}
+	return res;
 }
 
+/* XXX Nothing calls this */
 int ast_rtp_instance_make_compatible(struct ast_channel *chan, struct ast_rtp_instance *instance, struct ast_channel *peer)
 {
 	struct ast_rtp_glue *glue;
@@ -1472,6 +1693,10 @@ int ast_rtp_instance_make_compatible(str
 		return -1;
 	}
 
+	/*
+	 * XXX Good thing nothing calls this function because we would need
+	 * deadlock avoidance to get the two instance locks.
+	 */
 	res = instance->engine->make_compatible(chan, instance, peer, peer_instance);
 
 	ast_channel_unlock(peer);
@@ -1485,7 +1710,9 @@ int ast_rtp_instance_make_compatible(str
 void ast_rtp_instance_available_formats(struct ast_rtp_instance *instance, struct ast_format_cap *to_endpoint, struct ast_format_cap *to_asterisk, struct ast_format_cap *result)
 {
 	if (instance->engine->available_formats) {
+		ao2_lock(instance);
 		instance->engine->available_formats(instance, to_endpoint, to_asterisk, result);
+		ao2_unlock(instance);
 		if (ast_format_cap_count(result)) {
 			return;
 		}
@@ -1496,7 +1723,16 @@ void ast_rtp_instance_available_formats(
 
 int ast_rtp_instance_activate(struct ast_rtp_instance *instance)
 {
-	return instance->engine->activate ? instance->engine->activate(instance) : 0;
+	int res;
+
+	if (instance->engine->activate) {
+		ao2_lock(instance);
+		res = instance->engine->activate(instance);
+		ao2_unlock(instance);
+	} else {
+		res = 0;
+	}
+	return res;
 }
 
 void ast_rtp_instance_stun_request(struct ast_rtp_instance *instance,
@@ -1602,29 +1838,250 @@ struct ast_srtp *ast_rtp_instance_get_sr
 {
 	if (rtcp && instance->rtcp_srtp) {
 		return instance->rtcp_srtp;
-	}
-	else {
+	} else {
 		return instance->srtp;
 	}
 }
 
 int ast_rtp_instance_sendcng(struct ast_rtp_instance *instance, int level)
 {
+	int res;
+
 	if (instance->engine->sendcng) {
-		return instance->engine->sendcng(instance, level);
+		ao2_lock(instance);
+		res = instance->engine->sendcng(instance, level);
+		ao2_unlock(instance);
+	} else {
+		res = -1;
 	}
+	return res;
+}
+
+static void rtp_ice_wrap_set_authentication(struct ast_rtp_instance *instance, const char *ufrag, const char *password)
+{
+	ao2_lock(instance);
+	instance->engine->ice->set_authentication(instance, ufrag, password);
+	ao2_unlock(instance);
+}
+
+static void rtp_ice_wrap_add_remote_candidate(struct ast_rtp_instance *instance, const struct ast_rtp_engine_ice_candidate *candidate)
+{
+	ao2_lock(instance);
+	instance->engine->ice->add_remote_candidate(instance, candidate);
+	ao2_unlock(instance);
+}
+
+static void rtp_ice_wrap_start(struct ast_rtp_instance *instance)
+{
+	ao2_lock(instance);
+	instance->engine->ice->start(instance);
+	ao2_unlock(instance);
+}
+
+static void rtp_ice_wrap_stop(struct ast_rtp_instance *instance)
+{
+	ao2_lock(instance);
+	instance->engine->ice->stop(instance);
+	ao2_unlock(instance);
+}
+
+static const char *rtp_ice_wrap_get_ufrag(struct ast_rtp_instance *instance)
+{
+	const char *ufrag;
+
+	ao2_lock(instance);
+	ufrag = instance->engine->ice->get_ufrag(instance);
+	ao2_unlock(instance);
+	return ufrag;
+}
+
+static const char *rtp_ice_wrap_get_password(struct ast_rtp_instance *instance)
+{
+	const char *password;
 
-	return -1;
+	ao2_lock(instance);
+	password = instance->engine->ice->get_password(instance);
+	ao2_unlock(instance);
+	return password;
 }
 
+static struct ao2_container *rtp_ice_wrap_get_local_candidates(struct ast_rtp_instance *instance)
+{
+	struct ao2_container *local_candidates;
+
+	ao2_lock(instance);
+	local_candidates = instance->engine->ice->get_local_candidates(instance);
+	ao2_unlock(instance);
+	return local_candidates;
+}
+
+static void rtp_ice_wrap_ice_lite(struct ast_rtp_instance *instance)
+{
+	ao2_lock(instance);
+	instance->engine->ice->ice_lite(instance);
+	ao2_unlock(instance);
+}
+
+static void rtp_ice_wrap_set_role(struct ast_rtp_instance *instance,
+	enum ast_rtp_ice_role role)
+{
+	ao2_lock(instance);
+	instance->engine->ice->set_role(instance, role);
+	ao2_unlock(instance);
+}
+
+static void rtp_ice_wrap_turn_request(struct ast_rtp_instance *instance,
+	enum ast_rtp_ice_component_type component, enum ast_transport transport,
+	const char *server, unsigned int port, const char *username, const char *password)
+{
+	ao2_lock(instance);
+	instance->engine->ice->turn_request(instance, component, transport, server, port,
+		username, password);
+	ao2_unlock(instance);
+}
+
+static void rtp_ice_wrap_change_components(struct ast_rtp_instance *instance,
+	int num_components)
+{
+	ao2_lock(instance);
+	instance->engine->ice->change_components(instance, num_components);
+	ao2_unlock(instance);
+}
+
+static struct ast_rtp_engine_ice rtp_ice_wrappers = {
+	.set_authentication = rtp_ice_wrap_set_authentication,
+	.add_remote_candidate = rtp_ice_wrap_add_remote_candidate,
+	.start = rtp_ice_wrap_start,
+	.stop = rtp_ice_wrap_stop,
+	.get_ufrag = rtp_ice_wrap_get_ufrag,
+	.get_password = rtp_ice_wrap_get_password,
+	.get_local_candidates = rtp_ice_wrap_get_local_candidates,
+	.ice_lite = rtp_ice_wrap_ice_lite,
+	.set_role = rtp_ice_wrap_set_role,
+	.turn_request = rtp_ice_wrap_turn_request,
+	.change_components = rtp_ice_wrap_change_components,
+};
+
 struct ast_rtp_engine_ice *ast_rtp_instance_get_ice(struct ast_rtp_instance *instance)
 {
-	return instance->engine->ice;
+	if (instance->engine->ice) {
+		return &rtp_ice_wrappers;
+	}
+	/* ICE not available */
+	return NULL;
+}
+
+static int rtp_dtls_wrap_set_configuration(struct ast_rtp_instance *instance,
+	const struct ast_rtp_dtls_cfg *dtls_cfg)
+{
+	int set_configuration;
+
+	ao2_lock(instance);
+	set_configuration = instance->engine->dtls->set_configuration(instance, dtls_cfg);
+	ao2_unlock(instance);
+	return set_configuration;
 }
 
+static int rtp_dtls_wrap_active(struct ast_rtp_instance *instance)
+{
+	int active;
+
+	ao2_lock(instance);
+	active = instance->engine->dtls->active(instance);
+	ao2_unlock(instance);
+	return active;
+}
+
+static void rtp_dtls_wrap_stop(struct ast_rtp_instance *instance)
+{
+	ao2_lock(instance);
+	instance->engine->dtls->stop(instance);
+	ao2_unlock(instance);
+}
+
+static void rtp_dtls_wrap_reset(struct ast_rtp_instance *instance)
+{
+	ao2_lock(instance);
+	instance->engine->dtls->reset(instance);
+	ao2_unlock(instance);
+}
+
+static enum ast_rtp_dtls_connection rtp_dtls_wrap_get_connection(struct ast_rtp_instance *instance)
+{
+	enum ast_rtp_dtls_connection get_connection;
+
+	ao2_lock(instance);
+	get_connection = instance->engine->dtls->get_connection(instance);
+	ao2_unlock(instance);
+	return get_connection;
+}
+
+static enum ast_rtp_dtls_setup rtp_dtls_wrap_get_setup(struct ast_rtp_instance *instance)
+{
+	enum ast_rtp_dtls_setup get_setup;
+
+	ao2_lock(instance);
+	get_setup = instance->engine->dtls->get_setup(instance);
+	ao2_unlock(instance);
+	return get_setup;
+}
+
+static void rtp_dtls_wrap_set_setup(struct ast_rtp_instance *instance,
+	enum ast_rtp_dtls_setup setup)
+{
+	ao2_lock(instance);
+	instance->engine->dtls->set_setup(instance, setup);
+	ao2_unlock(instance);
+}
+
+static void rtp_dtls_wrap_set_fingerprint(struct ast_rtp_instance *instance,
+	enum ast_rtp_dtls_hash hash, const char *fingerprint)
+{
+	ao2_lock(instance);
+	instance->engine->dtls->set_fingerprint(instance, hash, fingerprint);
+	ao2_unlock(instance);
+}
+
+static enum ast_rtp_dtls_hash rtp_dtls_wrap_get_fingerprint_hash(struct ast_rtp_instance *instance)
+{
+	enum ast_rtp_dtls_hash get_fingerprint_hash;
+
+	ao2_lock(instance);
+	get_fingerprint_hash = instance->engine->dtls->get_fingerprint_hash(instance);
+	ao2_unlock(instance);
+	return get_fingerprint_hash;
+}
+
+static const char *rtp_dtls_wrap_get_fingerprint(struct ast_rtp_instance *instance)
+{
+	const char *get_fingerprint;
+
+	ao2_lock(instance);
+	get_fingerprint = instance->engine->dtls->get_fingerprint(instance);
+	ao2_unlock(instance);
+	return get_fingerprint;
+}
+
+static struct ast_rtp_engine_dtls rtp_dtls_wrappers = {
+	.set_configuration = rtp_dtls_wrap_set_configuration,
+	.active = rtp_dtls_wrap_active,
+	.stop = rtp_dtls_wrap_stop,
+	.reset = rtp_dtls_wrap_reset,
+	.get_connection = rtp_dtls_wrap_get_connection,
+	.get_setup = rtp_dtls_wrap_get_setup,
+	.set_setup = rtp_dtls_wrap_set_setup,
+	.set_fingerprint = rtp_dtls_wrap_set_fingerprint,
+	.get_fingerprint_hash = rtp_dtls_wrap_get_fingerprint_hash,
+	.get_fingerprint = rtp_dtls_wrap_get_fingerprint,
+};
+
 struct ast_rtp_engine_dtls *ast_rtp_instance_get_dtls(struct ast_rtp_instance *instance)
 {
-	return instance->engine->dtls;
+	if (instance->engine->dtls) {
+		return &rtp_dtls_wrappers;
+	}
+	/* DTLS not available */
+	return NULL;
 }
 
 int ast_rtp_dtls_cfg_parse(struct ast_rtp_dtls_cfg *dtls_cfg, const char *name, const char *value)
@@ -1773,7 +2230,11 @@ static void add_static_payload(int map,
 	int x;
 	struct ast_rtp_payload_type *type;
 
-	ast_assert(map < ARRAY_LEN(static_RTP_PT));
+	/*
+	 * ARRAY_LEN's result is cast to an int so 'map' is not autocast to a size_t,
+	 * which if negative would cause an assertion.
+	 */
+	ast_assert(map < (int)ARRAY_LEN(static_RTP_PT));
 
 	ast_rwlock_wrlock(&static_RTP_PT_lock);
 	if (map < 0) {
@@ -1784,6 +2245,49 @@ static void add_static_payload(int map,
 				break;
 			}
 		}
+
+		/* http://www.iana.org/assignments/rtp-parameters
+		 * RFC 3551, Section 3: "[...] applications which need to define more
+		 * than 32 dynamic payload types MAY bind codes below 96, in which case
+		 * it is RECOMMENDED that unassigned payload type numbers be used
+		 * first". Updated by RFC 5761, Section 4: "[...] values in the range
+		 * 64-95 MUST NOT be used [to avoid conflicts with RTCP]". Summaries:
+		 * https://tools.ietf.org/html/draft-roach-mmusic-unified-plan#section-3.2.1.2
+		 * https://tools.ietf.org/html/draft-wu-avtcore-dynamic-pt-usage#section-3
+		 */
+		if (map < 0) {
+			for (x = MAX(ast_option_rtpptdynamic, 35); x <= AST_RTP_PT_LAST_REASSIGN; ++x) {
+				if (!static_RTP_PT[x]) {
+					map = x;
+					break;
+				}
+			}
+		}
+		/* Yet, reusing mappings below 35 is not supported in Asterisk because
+		 * when Compact Headers are activated, no rtpmap is send for those below
+		 * 35. If you want to use 35 and below
+		 * A) do not use Compact Headers,
+		 * B) remove that code in chan_sip/res_pjsip, or
+		 * C) add a flag that this RTP Payload Type got reassigned dynamically
+		 *    and requires a rtpmap even with Compact Headers enabled.
+		 */
+		if (map < 0) {
+			for (x = MAX(ast_option_rtpptdynamic, 20); x < 35; ++x) {
+				if (!static_RTP_PT[x]) {
+					map = x;
+					break;
+				}
+			}
+		}
+		if (map < 0) {
+			for (x = MAX(ast_option_rtpptdynamic, 0); x < 20; ++x) {
+				if (!static_RTP_PT[x]) {
+					map = x;
+					break;
+				}
+			}
+		}
+
 		if (map < 0) {
 			if (format) {
 				ast_log(LOG_WARNING, "No Dynamic RTP mapping available for format %s\n",
@@ -1815,14 +2319,10 @@ static void add_static_payload(int map,
 
 int ast_rtp_engine_load_format(struct ast_format *format)
 {
-	char *codec_name = ast_strdupa(ast_format_get_name(format));
-
-	codec_name = ast_str_to_upper(codec_name);
-
 	set_next_mime_type(format,
 		0,
 		ast_codec_media_type2str(ast_format_get_type(format)),
-		codec_name,
+		ast_format_get_codec_name(format),
 		ast_format_get_sample_rate(format));
 	add_static_payload(-1, format, 0);
 
@@ -1924,7 +2424,7 @@ static struct ast_manager_event_blob *rt
 	if (type == AST_RTP_RTCP_SR) {
 		ast_str_append(&packet_string, 0, "SentNTP: %lu.%06lu\r\n",
 			(unsigned long)payload->report->sender_information.ntp_timestamp.tv_sec,
-			(unsigned long)payload->report->sender_information.ntp_timestamp.tv_usec * 4096);
+			(unsigned long)payload->report->sender_information.ntp_timestamp.tv_usec);
 		ast_str_append(&packet_string, 0, "SentRTP: %u\r\n",
 				payload->report->sender_information.rtp_timestamp);
 		ast_str_append(&packet_string, 0, "SentPackets: %u\r\n",
diff -urpN asterisk-13.9.1/main/say.c asterisk-13.17.0/main/say.c
--- asterisk-13.9.1/main/say.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/say.c	2017-07-12 13:12:08.000000000 +0200
@@ -993,7 +993,7 @@ static int ast_say_number_full_de(struct
 
 /*! \brief  ast_say_number_full_en_GB: British syntax
  New files:
-  - In addition to American English, the following sounds are required:  "and"
+  - In addition to American English, the following sounds are required:  "vm-and"
  */
 static int ast_say_number_full_en_GB(struct ast_channel *chan, int num, const char *ints, const char *language, int audiofd, int ctrlfd)
 {
@@ -1016,7 +1016,7 @@ static int ast_say_number_full_en_GB(str
 			ast_copy_string(fn, "digits/hundred", sizeof(fn));
 			playh = 0;
 		} else if (playa) {
-			ast_copy_string(fn, "digits/and", sizeof(fn));
+			ast_copy_string(fn, "vm-and", sizeof(fn));
 			playa = 0;
 		} else if (num < 20) {
 			snprintf(fn, sizeof(fn), "digits/%d", num);
@@ -5201,13 +5201,14 @@ int ast_say_date_with_format_it(struct a
 			case 'I':
 			case 'l':
 				/* 12-Hour */
-				if (tm.tm_hour == 0)
+				if (tm.tm_hour == 0) {
 					ast_copy_string(nextmsg, "digits/12", sizeof(nextmsg));
-				else if (tm.tm_hour > 12)
+				} else if (tm.tm_hour > 12) {
 					snprintf(nextmsg, sizeof(nextmsg), "digits/%d", tm.tm_hour - 12);
-				else
+				} else {
 					snprintf(nextmsg, sizeof(nextmsg), "digits/%d", tm.tm_hour);
-					res = wait_file(chan, ints, nextmsg, lang);
+				}
+				res = wait_file(chan, ints, nextmsg, lang);
 				break;
 			case 'H':
 			case 'k':
@@ -5227,11 +5228,12 @@ int ast_say_date_with_format_it(struct a
 			case 'P':
 			case 'p':
 				/* AM/PM */
-				if (tm.tm_hour > 11)
+				if (tm.tm_hour > 11) {
 					ast_copy_string(nextmsg, "digits/p-m", sizeof(nextmsg));
-				else
+				} else {
 					ast_copy_string(nextmsg, "digits/a-m", sizeof(nextmsg));
-					res = wait_file(chan, ints, nextmsg, lang);
+				}
+				res = wait_file(chan, ints, nextmsg, lang);
 				break;
 			case 'Q':
 				/* Shorthand for "Today", "Yesterday", or ABdY */
@@ -7948,9 +7950,9 @@ int ast_say_date_with_format_ja(struct a
                      /* NOTE:  if you add more options here, please try to be consistent with strftime(3) */
                      case '\'':
                              /* Literal name of a sound file */
-                             sndoffset=0;
-                             for (sndoffset=0 ; (format[++offset] != '\'') && (sndoffset < 256) ; sndoffset++)
+                             for (sndoffset = 0 ; (format[++offset] != '\'') && (sndoffset < sizeof(sndfile) - 1) ; sndoffset++) {
                                      sndfile[sndoffset] = format[offset];
+                             }
                              sndfile[sndoffset] = '\0';
                              res = wait_file(chan,ints,sndfile,lang);
                              break;
diff -urpN asterisk-13.9.1/main/sdp_srtp.c asterisk-13.17.0/main/sdp_srtp.c
--- asterisk-13.9.1/main/sdp_srtp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/sdp_srtp.c	2017-07-12 13:12:08.000000000 +0200
@@ -238,8 +238,8 @@ int ast_sdp_crypto_process(struct ast_rt
 		return -1;
 	}
 
-	/* RFC4568 9.1 - tag is 1-9 digits, greater than zero */
-	if (sscanf(tag, "%30d", &crypto->tag) != 1 || crypto->tag <= 0 || crypto->tag > 999999999) {
+	/* RFC4568 9.1 - tag is 1-9 digits */
+	if (sscanf(tag, "%30d", &crypto->tag) != 1 || crypto->tag < 0 || crypto->tag > 999999999) {
 		ast_log(LOG_WARNING, "Unacceptable a=crypto tag: %s\n", tag);
 		return -1;
 	}
diff -urpN asterisk-13.9.1/main/sorcery.c asterisk-13.17.0/main/sorcery.c
--- asterisk-13.9.1/main/sorcery.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/sorcery.c	2017-07-12 13:12:08.000000000 +0200
@@ -290,6 +290,12 @@ static int bool_handler_fn(const void *o
 	return !(*buf = ast_strdup(*field ? "true" : "false")) ? -1 : 0;
 }
 
+static int yesno_handler_fn(const void *obj, const intptr_t *args, char **buf)
+{
+	unsigned int *field = (unsigned int *)(obj + args[0]);
+	return !(*buf = ast_strdup(*field ? "yes" : "no")) ? -1 : 0;
+}
+
 static int sockaddr_handler_fn(const void *obj, const intptr_t *args, char **buf)
 {
 	struct ast_sockaddr *field = (struct ast_sockaddr *)(obj + args[0]);
@@ -313,6 +319,7 @@ static sorcery_field_handler sorcery_fie
 {
 	switch(type) {
 	case OPT_BOOL_T: return bool_handler_fn;
+	case OPT_YESNO_T: return yesno_handler_fn;
 	case OPT_CHAR_ARRAY_T: return chararray_handler_fn;
 	case OPT_CODEC_T: return codec_handler_fn;
 	case OPT_DOUBLE_T: return double_handler_fn;
@@ -498,13 +505,15 @@ int ast_sorcery_init(void)
 	};
 	ast_assert(wizards == NULL);
 
-	if (!(threadpool = ast_threadpool_create("Sorcery", NULL, &options))) {
-		threadpool = NULL;
+	threadpool = ast_threadpool_create("Sorcery", NULL, &options);
+	if (!threadpool) {
 		return -1;
 	}
 
-	if (!(wizards = ao2_container_alloc(WIZARD_BUCKETS, sorcery_wizard_hash, sorcery_wizard_cmp))) {
-		ast_threadpool_shutdown(threadpool);
+	wizards = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0, WIZARD_BUCKETS,
+		sorcery_wizard_hash, NULL, sorcery_wizard_cmp);
+	if (!wizards) {
+		sorcery_cleanup();
 		return -1;
 	}
 
@@ -514,8 +523,8 @@ int ast_sorcery_init(void)
 		return -1;
 	}
 
-	instances = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_RWLOCK, INSTANCE_BUCKETS,
-		sorcery_instance_hash, sorcery_instance_cmp);
+	instances = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_RWLOCK, 0, INSTANCE_BUCKETS,
+		sorcery_instance_hash, NULL, sorcery_instance_cmp);
 	if (!instances) {
 		sorcery_cleanup();
 		return -1;
@@ -596,7 +605,7 @@ static int sorcery_generic_observer_remo
 {
 	const struct sorcery_global_observer *observer = obj;
 
-	return (observer->callbacks == arg) ? CMP_MATCH | CMP_STOP : 0;
+	return (observer->callbacks == arg) ? CMP_MATCH : 0;
 }
 
 int ast_sorcery_global_observer_add(const struct ast_sorcery_global_observer *callbacks)
@@ -832,23 +841,30 @@ static struct ast_sorcery_object_type *s
 		return NULL;
 	}
 
-	if (!(object_type->fields = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, OBJECT_FIELD_BUCKETS,
-					object_type_field_hash, object_type_field_cmp))) {
+	object_type->fields = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_NOLOCK, 0,
+		OBJECT_FIELD_BUCKETS, object_type_field_hash, NULL, object_type_field_cmp);
+	if (!object_type->fields) {
 		ao2_ref(object_type, -1);
 		return NULL;
 	}
 
-	if (!(object_type->observers = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_RWLOCK, 1, NULL, NULL))) {
+	object_type->observers = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_RWLOCK, 0,
+		NULL, NULL);
+	if (!object_type->observers) {
 		ao2_ref(object_type, -1);
 		return NULL;
 	}
 
-	if (!(object_type->info = ast_calloc(1, sizeof(*object_type->info) + 2 * sizeof(object_type->info->files[0])))) {
+	object_type->info = ast_calloc(1,
+		sizeof(*object_type->info) + 2 * sizeof(object_type->info->files[0]));
+	if (!object_type->info) {
 		ao2_ref(object_type, -1);
 		return NULL;
 	}
 
-	if (!(object_type->file = ast_calloc(1, sizeof(*object_type->file) + 2 * sizeof(object_type->file->types[0])))) {
+	object_type->file = ast_calloc(1,
+		sizeof(*object_type->file) + 2 * sizeof(object_type->file->types[0]));
+	if (!object_type->file) {
 		ao2_ref(object_type, -1);
 		return NULL;
 	}
@@ -1161,6 +1177,20 @@ int __ast_sorcery_object_register(struct
 	return 0;
 }
 
+int ast_sorcery_object_set_congestion_levels(struct ast_sorcery *sorcery, const char *type, long low_water, long high_water)
+{
+	struct ast_sorcery_object_type *object_type;
+	int res = -1;
+
+	object_type = ao2_find(sorcery->types, type, OBJ_SEARCH_KEY);
+	if (object_type) {
+		res = ast_taskprocessor_alert_set_levels(object_type->serializer,
+			low_water, high_water);
+		ao2_ref(object_type, -1);
+	}
+	return res;
+}
+
 void ast_sorcery_object_set_copy_handler(struct ast_sorcery *sorcery, const char *type, sorcery_copy_handler copy)
 {
 	RAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, type, OBJ_KEY), ao2_cleanup);
@@ -1319,8 +1349,10 @@ static void sorcery_observer_invocation_
 /*! \brief Allocator function for observer invocation */
 static struct sorcery_observer_invocation *sorcery_observer_invocation_alloc(struct ast_sorcery_object_type *object_type, void *object)
 {
-	struct sorcery_observer_invocation *invocation = ao2_alloc(sizeof(*invocation), sorcery_observer_invocation_destroy);
+	struct sorcery_observer_invocation *invocation;
 
+	invocation = ao2_alloc_options(sizeof(*invocation),
+		sorcery_observer_invocation_destroy, AO2_ALLOC_OPT_LOCK_NOLOCK);
 	if (!invocation) {
 		return NULL;
 	}
@@ -1826,12 +1858,17 @@ static int sorcery_cache_create(void *ob
 
 void *ast_sorcery_retrieve_by_id(const struct ast_sorcery *sorcery, const char *type, const char *id)
 {
-	RAII_VAR(struct ast_sorcery_object_type *, object_type, ao2_find(sorcery->types, type, OBJ_KEY), ao2_cleanup);
+	struct ast_sorcery_object_type *object_type;
 	void *object = NULL;
 	int i;
 	unsigned int cached = 0;
 
-	if (!object_type || ast_strlen_zero(id)) {
+	if (ast_strlen_zero(id)) {
+		return NULL;
+	}
+
+	object_type = ao2_find(sorcery->types, type, OBJ_SEARCH_KEY);
+	if (!object_type) {
 		return NULL;
 	}
 
@@ -1859,6 +1896,7 @@ void *ast_sorcery_retrieve_by_id(const s
 	}
 	AST_VECTOR_RW_UNLOCK(&object_type->wizards);
 
+	ao2_ref(object_type, -1);
 	return object;
 }
 
@@ -1944,11 +1982,8 @@ struct ao2_container *ast_sorcery_retrie
 }
 
 /*! \brief Internal function which returns if the wizard has created the object */
-static int sorcery_wizard_create(void *obj, void *arg, int flags)
+static int sorcery_wizard_create(const struct ast_sorcery_object_wizard *object_wizard, const struct sorcery_details *details)
 {
-	const struct ast_sorcery_object_wizard *object_wizard = obj;
-	const struct sorcery_details *details = arg;
-
 	if (!object_wizard->wizard->callbacks.create) {
 		ast_debug(5, "Sorcery wizard '%s' does not support creation\n", object_wizard->wizard->callbacks.name);
 		return 0;
@@ -2003,7 +2038,8 @@ int ast_sorcery_create(const struct ast_
 	AST_VECTOR_RW_RDLOCK(&object_type->wizards);
 	for (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {
 		found_wizard = AST_VECTOR_GET(&object_type->wizards, i);
-		if (!found_wizard->caching && sorcery_wizard_create(found_wizard, &sdetails, 0) == CMP_MATCH) {
+		if (!found_wizard->caching
+			&& sorcery_wizard_create(found_wizard, &sdetails) == CMP_MATCH) {
 			object_wizard = found_wizard;
 		}
 	}
@@ -2012,14 +2048,14 @@ int ast_sorcery_create(const struct ast_
 		for (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {
 			found_wizard = AST_VECTOR_GET(&object_type->wizards, i);
 			if (found_wizard->caching) {
-				sorcery_wizard_create(found_wizard, &sdetails, 0);
+				sorcery_wizard_create(found_wizard, &sdetails);
 			}
 		}
 
 		if (ao2_container_count(object_type->observers)) {
-			struct sorcery_observer_invocation *invocation = sorcery_observer_invocation_alloc(
-				object_type, object);
+			struct sorcery_observer_invocation *invocation;
 
+			invocation = sorcery_observer_invocation_alloc(object_type, object);
 			if (invocation
 				&& ast_taskprocessor_push(object_type->serializer, sorcery_observers_notify_create,
 					invocation)) {
@@ -2057,11 +2093,8 @@ static int sorcery_observers_notify_upda
 }
 
 /*! \brief Internal function which returns if a wizard has updated the object */
-static int sorcery_wizard_update(void *obj, void *arg, int flags)
+static int sorcery_wizard_update(const struct ast_sorcery_object_wizard *object_wizard, const struct sorcery_details *details)
 {
-	const struct ast_sorcery_object_wizard *object_wizard = obj;
-	const struct sorcery_details *details = arg;
-
 	if (!object_wizard->wizard->callbacks.update) {
 		ast_debug(5, "Sorcery wizard '%s' does not support updating\n", object_wizard->wizard->callbacks.name);
 		return 0;
@@ -2093,7 +2126,8 @@ int ast_sorcery_update(const struct ast_
 	AST_VECTOR_RW_RDLOCK(&object_type->wizards);
 	for (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {
 		found_wizard = AST_VECTOR_GET(&object_type->wizards, i);
-		if (!found_wizard->caching && sorcery_wizard_update(found_wizard, &sdetails, 0) == CMP_MATCH) {
+		if (!found_wizard->caching
+			&& sorcery_wizard_update(found_wizard, &sdetails) == CMP_MATCH) {
 			object_wizard = found_wizard;
 		}
 	}
@@ -2102,14 +2136,14 @@ int ast_sorcery_update(const struct ast_
 		for (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {
 			found_wizard = AST_VECTOR_GET(&object_type->wizards, i);
 			if (found_wizard->caching) {
-				sorcery_wizard_update(found_wizard, &sdetails, 0);
+				sorcery_wizard_update(found_wizard, &sdetails);
 			}
 		}
 
 		if (ao2_container_count(object_type->observers)) {
-			struct sorcery_observer_invocation *invocation = sorcery_observer_invocation_alloc(
-				object_type, object);
+			struct sorcery_observer_invocation *invocation;
 
+			invocation = sorcery_observer_invocation_alloc(object_type, object);
 			if (invocation
 				&& ast_taskprocessor_push(object_type->serializer, sorcery_observers_notify_update,
 					invocation)) {
@@ -2147,11 +2181,8 @@ static int sorcery_observers_notify_dele
 }
 
 /*! \brief Internal function which returns if a wizard has deleted the object */
-static int sorcery_wizard_delete(void *obj, void *arg, int flags)
+static int sorcery_wizard_delete(const struct ast_sorcery_object_wizard *object_wizard, const struct sorcery_details *details)
 {
-	const struct ast_sorcery_object_wizard *object_wizard = obj;
-	const struct sorcery_details *details = arg;
-
 	if (!object_wizard->wizard->callbacks.delete) {
 		ast_debug(5, "Sorcery wizard '%s' does not support deletion\n", object_wizard->wizard->callbacks.name);
 		return 0;
@@ -2183,7 +2214,8 @@ int ast_sorcery_delete(const struct ast_
 	AST_VECTOR_RW_RDLOCK(&object_type->wizards);
 	for (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {
 		found_wizard = AST_VECTOR_GET(&object_type->wizards, i);
-		if (!found_wizard->caching && sorcery_wizard_delete(found_wizard, &sdetails, 0) == CMP_MATCH) {
+		if (!found_wizard->caching
+			&& sorcery_wizard_delete(found_wizard, &sdetails) == CMP_MATCH) {
 			object_wizard = found_wizard;
 		}
 	}
@@ -2192,14 +2224,14 @@ int ast_sorcery_delete(const struct ast_
 		for (i = 0; i < AST_VECTOR_SIZE(&object_type->wizards); i++) {
 			found_wizard = AST_VECTOR_GET(&object_type->wizards, i);
 			if (found_wizard->caching) {
-				sorcery_wizard_delete(found_wizard, &sdetails, 0);
+				sorcery_wizard_delete(found_wizard, &sdetails);
 			}
 		}
 
 		if (ao2_container_count(object_type->observers)) {
-			struct sorcery_observer_invocation *invocation = sorcery_observer_invocation_alloc(
-				object_type, object);
+			struct sorcery_observer_invocation *invocation;
 
+			invocation = sorcery_observer_invocation_alloc(object_type, object);
 			if (invocation
 				&& ast_taskprocessor_push(object_type->serializer, sorcery_observers_notify_delete,
 					invocation)) {
@@ -2308,7 +2340,7 @@ static int sorcery_observer_remove(void
 {
 	const struct ast_sorcery_object_type_observer *observer = obj;
 
-	return (observer->callbacks == arg) ? CMP_MATCH | CMP_STOP : 0;
+	return (observer->callbacks == arg) ? CMP_MATCH : 0;
 }
 
 void ast_sorcery_observer_remove(const struct ast_sorcery *sorcery, const char *type, const struct ast_sorcery_observer *callbacks)
@@ -2330,18 +2362,20 @@ void ast_sorcery_observer_remove(const s
 
 int ast_sorcery_object_id_sort(const void *obj, const void *arg, int flags)
 {
+	const void *object_left = obj;
+	const void *object_right = arg;
 	const char *right_key = arg;
 	int cmp;
 
 	switch (flags & OBJ_SEARCH_MASK) {
 	case OBJ_SEARCH_OBJECT:
-		right_key = ast_sorcery_object_get_id(arg);
+		right_key = ast_sorcery_object_get_id(object_right);
 		/* Fall through */
 	case OBJ_SEARCH_KEY:
-		cmp = strcmp(ast_sorcery_object_get_id(obj), right_key);
+		cmp = strcmp(ast_sorcery_object_get_id(object_left), right_key);
 		break;
 	case OBJ_SEARCH_PARTIAL_KEY:
-		cmp = strncmp(ast_sorcery_object_get_id(obj), right_key, strlen(right_key));
+		cmp = strncmp(ast_sorcery_object_get_id(object_left), right_key, strlen(right_key));
 		break;
 	default:
 		cmp = 0;
@@ -2352,37 +2386,32 @@ int ast_sorcery_object_id_sort(const voi
 
 int ast_sorcery_object_id_compare(void *obj, void *arg, int flags)
 {
-	const char *right_key = arg;
-	int cmp = 0;
+	int cmp;
+
+	cmp = ast_sorcery_object_id_sort(obj, arg, flags);
+	if (cmp) {
+		return 0;
+	}
+	return CMP_MATCH;
+}
+
+int ast_sorcery_object_id_hash(const void *obj, int flags)
+{
+	const char *key;
 
 	switch (flags & OBJ_SEARCH_MASK) {
-	case OBJ_SEARCH_OBJECT:
-		right_key = ast_sorcery_object_get_id(arg);
-		/* Fall through */
 	case OBJ_SEARCH_KEY:
-		if (strcmp(ast_sorcery_object_get_id(obj), right_key) == 0) {
-			cmp = CMP_MATCH | CMP_STOP;
-		}
+		key = obj;
 		break;
-	case OBJ_SEARCH_PARTIAL_KEY:
-		if (strncmp(ast_sorcery_object_get_id(obj), right_key, strlen(right_key)) == 0) {
-			cmp = CMP_MATCH;
-		}
+	case OBJ_SEARCH_OBJECT:
+		key = ast_sorcery_object_get_id(obj);
 		break;
 	default:
-		cmp = 0;
-		break;
-	}
-	return cmp;
-}
-
-int ast_sorcery_object_id_hash(const void *obj, int flags) {
-	if (flags & OBJ_SEARCH_OBJECT) {
-		return ast_str_hash(ast_sorcery_object_get_id(obj));
-	} else if (flags & OBJ_SEARCH_KEY) {
-		return ast_str_hash(obj);
+		/* Hash can only work on something with a full key. */
+		ast_assert(0);
+		return 0;
 	}
-	return -1;
+	return ast_str_hash(key);
 }
 
 struct ast_sorcery_object_type *ast_sorcery_get_object_type(const struct ast_sorcery *sorcery,
@@ -2399,7 +2428,7 @@ static int is_registered_cb(void *obj, v
 
 	if (object_field->name_regex
 		&& !regexec(object_field->name_regex, name, 0, NULL, 0)) {
-		rc = CMP_MATCH | CMP_STOP;
+		rc = CMP_MATCH;
 	}
 
 	return rc;
diff -urpN asterisk-13.9.1/main/srv.c asterisk-13.17.0/main/srv.c
--- asterisk-13.9.1/main/srv.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/srv.c	2017-07-12 13:12:08.000000000 +0200
@@ -211,7 +211,8 @@ int ast_srv_lookup(struct srv_context **
 		}
 		AST_LIST_HEAD_INIT_NOLOCK(&(*context)->entries);
 
-		if ((ast_search_dns(*context, service, C_IN, T_SRV, srv_callback)) < 0) {
+		if (((ast_search_dns(*context, service, C_IN, T_SRV, srv_callback)) < 1) ||
+			AST_LIST_EMPTY(&(*context)->entries)) {
 			ast_free(*context);
 			*context = NULL;
 			return -1;
diff -urpN asterisk-13.9.1/main/stasis.c asterisk-13.17.0/main/stasis.c
--- asterisk-13.9.1/main/stasis.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis.c	2017-07-12 13:12:08.000000000 +0200
@@ -59,6 +59,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			</description>
 			<see-also>
 				<ref type="application">UserEvent</ref>
+				<ref type="managerEvent">UserEvent</ref>
 			</see-also>
 		</managerEventInstance>
 	</managerEvent>
@@ -564,6 +565,18 @@ struct stasis_subscription *stasis_unsub
 	return NULL;
 }
 
+int stasis_subscription_set_congestion_limits(struct stasis_subscription *subscription,
+	long low_water, long high_water)
+{
+	int res = -1;
+
+	if (subscription) {
+		res = ast_taskprocessor_alert_set_levels(subscription->mailbox,
+			low_water, high_water);
+	}
+	return res;
+}
+
 void stasis_subscription_join(struct stasis_subscription *subscription)
 {
 	if (subscription) {
diff -urpN asterisk-13.9.1/main/stasis_bridges.c asterisk-13.17.0/main/stasis_bridges.c
--- asterisk-13.9.1/main/stasis_bridges.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis_bridges.c	2017-07-12 13:12:08.000000000 +0200
@@ -79,6 +79,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>Destination extension for the blind transfer.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="manager">BlindTransfer</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AttendedTransfer">
@@ -131,6 +134,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<para>	<replaceable>SecondTransfererChannel</replaceable>: Alice's channel in the bridge with Bob.</para>
 				<para>	<replaceable>SecondBridgeUniqueid</replaceable>: The bridge between Alice and Bob.</para>
 			</description>
+			<see-also>
+				<ref type="manager">AtxFer</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
  ***/
@@ -234,7 +240,13 @@ struct ast_bridge_snapshot *ast_bridge_s
 
 	snapshot = ao2_alloc_options(sizeof(*snapshot), bridge_snapshot_dtor,
 		AO2_ALLOC_OPT_LOCK_NOLOCK);
-	if (!snapshot || ast_string_field_init(snapshot, 128)) {
+	if (!snapshot) {
+		return NULL;
+	}
+
+	if (ast_string_field_init(snapshot, 128)
+		|| ast_string_field_init_extended(snapshot, video_source_id)) {
+		ao2_ref(snapshot, -1);
 		return NULL;
 	}
 
@@ -260,6 +272,16 @@ struct ast_bridge_snapshot *ast_bridge_s
 	snapshot->capabilities = bridge->technology->capabilities;
 	snapshot->num_channels = bridge->num_channels;
 	snapshot->num_active = bridge->num_active;
+	snapshot->video_mode = bridge->softmix.video_mode.mode;
+	if (snapshot->video_mode == AST_BRIDGE_VIDEO_MODE_SINGLE_SRC
+		&& bridge->softmix.video_mode.mode_data.single_src_data.chan_vsrc) {
+		ast_string_field_set(snapshot, video_source_id,
+			ast_channel_uniqueid(bridge->softmix.video_mode.mode_data.single_src_data.chan_vsrc));
+	} else if (snapshot->video_mode == AST_BRIDGE_VIDEO_MODE_TALKER_SRC
+		&& bridge->softmix.video_mode.mode_data.talker_src_data.chan_vsrc) {
+		ast_string_field_set(snapshot, video_source_id,
+			ast_channel_uniqueid(bridge->softmix.video_mode.mode_data.talker_src_data.chan_vsrc));
+	}
 
 	ao2_ref(snapshot, +1);
 	return snapshot;
@@ -573,18 +595,25 @@ struct ast_json *ast_bridge_snapshot_to_
 		return NULL;
 	}
 
-	json_bridge = ast_json_pack("{s: s, s: s, s: s, s: s, s: s, s: s, s: o}",
+	json_bridge = ast_json_pack("{s: s, s: s, s: s, s: s, s: s, s: s, s: o, s: s}",
 		"id", snapshot->uniqueid,
 		"technology", snapshot->technology,
 		"bridge_type", capability2str(snapshot->capabilities),
 		"bridge_class", snapshot->subclass,
 		"creator", snapshot->creator,
 		"name", snapshot->name,
-		"channels", json_channels);
+		"channels", json_channels,
+		"video_mode", ast_bridge_video_mode_to_string(snapshot->video_mode));
 	if (!json_bridge) {
 		return NULL;
 	}
 
+	if (snapshot->video_mode != AST_BRIDGE_VIDEO_MODE_NONE
+		&& !ast_strlen_zero(snapshot->video_source_id)) {
+		ast_json_object_set(json_bridge, "video_source_id",
+			ast_json_string_create(snapshot->video_source_id));
+	}
+
 	return ast_json_ref(json_bridge);
 }
 
diff -urpN asterisk-13.9.1/main/stasis_cache.c asterisk-13.17.0/main/stasis_cache.c
--- asterisk-13.9.1/main/stasis_cache.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis_cache.c	2017-07-12 13:12:08.000000000 +0200
@@ -842,7 +842,7 @@ static void caching_topic_exec(void *dat
 			}
 			ao2_cleanup(update);
 		} else {
-			ast_log(LOG_ERROR,
+			ast_debug(1,
 				"Attempting to remove an item from the %s cache that isn't there: %s %s\n",
 				stasis_topic_name(caching_topic->topic),
 				stasis_message_type_name(msg_type), msg_id);
diff -urpN asterisk-13.9.1/main/stasis_endpoints.c asterisk-13.17.0/main/stasis_endpoints.c
--- asterisk-13.9.1/main/stasis_endpoints.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis_endpoints.c	2017-07-12 13:12:08.000000000 +0200
@@ -86,6 +86,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 						<enum name="Reachable"/>
 						<enum name="Created"/>
 						<enum name="Removed"/>
+						<enum name="Updated"/>
 					</enumlist>
 				</parameter>
 				<parameter name="AOR">
@@ -97,6 +98,18 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				<parameter name="RoundtripUsec">
 					<para>The RTT measured during the last qualify.</para>
 				</parameter>
+				<parameter name="UserAgent">
+					<para>Content of the User-Agent header in REGISTER request</para>
+				</parameter>
+				<parameter name="RegExpire">
+					<para>Absolute time that this contact is no longer valid after</para>
+				</parameter>
+				<parameter name="ViaAddress">
+					<para>IP address:port of the last Via header in REGISTER request</para>
+				</parameter>
+				<parameter name="CallID">
+					<para>Content of the Call-ID header in REGISTER request</para>
+				</parameter>
 			</syntax>
 		</managerEventInstance>
 	</managerEvent>
@@ -240,6 +253,7 @@ static struct ast_json *contactstatus_to
 	struct ast_endpoint_blob *obj = stasis_message_data(msg);
 	struct ast_json *json_endpoint;
 	struct ast_json *json_final;
+	const char *rtt;
 	const struct timeval *tv = stasis_message_timestamp(msg);
 
 	json_endpoint = ast_endpoint_snapshot_to_json(obj->snapshot, NULL);
@@ -247,15 +261,30 @@ static struct ast_json *contactstatus_to
 		return NULL;
 	}
 
-	json_final = ast_json_pack("{s: s, s: o, s: o, s: { s: s, s: s, s: s, s: s } } ",
-		"type", "ContactStatusChange",
-		"timestamp", ast_json_timeval(*tv, NULL),
-		"endpoint", json_endpoint,
-		"contact_info",
-		"uri", ast_json_string_get(ast_json_object_get(obj->blob, "uri")),
-		"contact_status", ast_json_string_get(ast_json_object_get(obj->blob, "contact_status")),
-		"aor", ast_json_string_get(ast_json_object_get(obj->blob, "aor")),
-		"roundtrip_usec", ast_json_string_get(ast_json_object_get(obj->blob, "roundtrip_usec")));
+	/* The roundtrip time is optional. */
+	rtt = ast_json_string_get(ast_json_object_get(obj->blob, "roundtrip_usec"));
+	if (!ast_strlen_zero(rtt)) {
+		json_final = ast_json_pack("{s: s, s: o, s: o, s: { s: s, s: s, s: s, s: s } } ",
+			"type", "ContactStatusChange",
+			"timestamp", ast_json_timeval(*tv, NULL),
+			"endpoint", json_endpoint,
+			"contact_info",
+			"uri", ast_json_string_get(ast_json_object_get(obj->blob, "uri")),
+			"contact_status", ast_json_string_get(ast_json_object_get(obj->blob,
+				"contact_status")),
+			"aor", ast_json_string_get(ast_json_object_get(obj->blob, "aor")),
+			"roundtrip_usec", rtt);
+	} else {
+		json_final = ast_json_pack("{s: s, s: o, s: o, s: { s: s, s: s, s: s } } ",
+			"type", "ContactStatusChange",
+			"timestamp", ast_json_timeval(*tv, NULL),
+			"endpoint", json_endpoint,
+			"contact_info",
+			"uri", ast_json_string_get(ast_json_object_get(obj->blob, "uri")),
+			"contact_status", ast_json_string_get(ast_json_object_get(obj->blob,
+				"contact_status")),
+			"aor", ast_json_string_get(ast_json_object_get(obj->blob, "aor")));
+	}
 	if (!json_final) {
 		ast_json_unref(json_endpoint);
 	}
diff -urpN asterisk-13.9.1/main/stasis_message.c asterisk-13.17.0/main/stasis_message.c
--- asterisk-13.9.1/main/stasis_message.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis_message.c	2017-07-12 13:12:08.000000000 +0200
@@ -170,17 +170,17 @@ const struct timeval *stasis_message_tim
 	return &msg->timestamp;
 }
 
-#define INVOKE_VIRTUAL(fn, ...)				\
-	({						\
-		if (msg == NULL) {			\
-			return NULL;			\
-		}					\
-		ast_assert(msg->type != NULL);		\
+#define INVOKE_VIRTUAL(fn, ...)					\
+	({											\
+		if (!msg) {								\
+			return NULL;						\
+		}										\
+		ast_assert(msg->type != NULL);			\
 		ast_assert(msg->type->vtable != NULL);	\
-		if (msg->type->vtable->fn == NULL) {	\
-			return NULL;			\
-		}					\
-		msg->type->vtable->fn(__VA_ARGS__);	\
+		if (!msg->type->vtable->fn) {			\
+			return NULL;						\
+		}										\
+		msg->type->vtable->fn(__VA_ARGS__);		\
 	})
 
 struct ast_manager_event_blob *stasis_message_to_ami(struct stasis_message *msg)
@@ -199,3 +199,18 @@ struct ast_event *stasis_message_to_even
 {
 	return INVOKE_VIRTUAL(to_event, msg);
 }
+
+#define HAS_VIRTUAL(fn, msg)					\
+	({											\
+		if (!msg) {								\
+			return 0;							\
+		}										\
+		ast_assert(msg->type != NULL);			\
+		ast_assert(msg->type->vtable != NULL);	\
+		!!msg->type->vtable->fn;				\
+	})
+
+int stasis_message_can_be_ami(struct stasis_message *msg)
+{
+	return HAS_VIRTUAL(to_ami, msg);
+}
diff -urpN asterisk-13.9.1/main/stasis_message_router.c asterisk-13.17.0/main/stasis_message_router.c
--- asterisk-13.9.1/main/stasis_message_router.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis_message_router.c	2017-07-12 13:12:08.000000000 +0200
@@ -289,6 +289,18 @@ void stasis_message_router_publish_sync(
 	ao2_cleanup(router);
 }
 
+int stasis_message_router_set_congestion_limits(struct stasis_message_router *router,
+	long low_water, long high_water)
+{
+	int res = -1;
+
+	if (router) {
+		res = stasis_subscription_set_congestion_limits(router->subscription,
+			low_water, high_water);
+	}
+	return res;
+}
+
 int stasis_message_router_add(struct stasis_message_router *router,
 	struct stasis_message_type *message_type,
 	stasis_subscription_cb callback, void *data)
diff -urpN asterisk-13.9.1/main/stasis_system.c asterisk-13.17.0/main/stasis_system.c
--- asterisk-13.9.1/main/stasis_system.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stasis_system.c	2017-07-12 13:12:08.000000000 +0200
@@ -115,6 +115,7 @@ STASIS_MESSAGE_TYPE_DEFN(ast_cc_failure_
 STASIS_MESSAGE_TYPE_DEFN(ast_cc_monitorfailed_type,
 	.to_ami = cc_monitorfailed_to_ami,
 	);
+STASIS_MESSAGE_TYPE_DEFN(ast_cluster_discovery_type);
 
 void ast_system_publish_registry(const char *channeltype, const char *username, const char *domain, const char *status, const char *cause)
 {
@@ -362,6 +363,7 @@ static void stasis_system_cleanup(void)
 	STASIS_MESSAGE_TYPE_CLEANUP(ast_cc_recallcomplete_type);
 	STASIS_MESSAGE_TYPE_CLEANUP(ast_cc_failure_type);
 	STASIS_MESSAGE_TYPE_CLEANUP(ast_cc_monitorfailed_type);
+	STASIS_MESSAGE_TYPE_CLEANUP(ast_cluster_discovery_type);
 }
 
 /*! \brief Initialize the system level items for \ref stasis */
@@ -422,5 +424,9 @@ int ast_stasis_system_init(void)
 		return -1;
 	}
 
+	if (STASIS_MESSAGE_TYPE_INIT(ast_cluster_discovery_type) != 0) {
+		return -1;
+	}
+
 	return 0;
 }
diff -urpN asterisk-13.9.1/main/stdtime/localtime.c asterisk-13.17.0/main/stdtime/localtime.c
--- asterisk-13.9.1/main/stdtime/localtime.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stdtime/localtime.c	2017-07-12 13:12:08.000000000 +0200
@@ -1849,13 +1849,14 @@ void ast_get_dst_info(const time_t * con
 		*dst_enabled = 0;
 		/* Find where I can get gmtoff */
 		i = 0;
-		while (sp->ttis[i].tt_isdst)
+		while (sp->ttis[i].tt_isdst) {
 			if (++i >= sp->typecnt) {
-			i = 0;
-			break;
+				i = 0;
+				break;
 			}
-			*gmt_off = sp->ttis[i].tt_gmtoff;
-			return;
+		}
+		*gmt_off = sp->ttis[i].tt_gmtoff;
+		return;
 	}
 
 	for (i = 1; i < sp->timecnt; ++i) {
diff -urpN asterisk-13.9.1/main/strings.c asterisk-13.17.0/main/strings.c
--- asterisk-13.9.1/main/strings.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/strings.c	2017-07-12 13:12:08.000000000 +0200
@@ -53,7 +53,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
  *	ast_str_append_va(...)
  */
 
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 int __ast_debug_str_helper(struct ast_str **buf, ssize_t max_len,
 	int append, const char *fmt, va_list ap, const char *file, int lineno, const char *function)
 #else
@@ -112,7 +112,7 @@ int __ast_str_helper(struct ast_str **bu
 		}
 
 		if (
-#if (defined(MALLOC_DEBUG) && !defined(STANDALONE))
+#ifdef __AST_DEBUG_MALLOC
 			_ast_str_make_space(buf, need, file, lineno, function)
 #else
 			ast_str_make_space(buf, need)
@@ -186,15 +186,32 @@ static int str_hash(const void *obj, con
 	return ast_str_hash(obj);
 }
 
+static int str_sort(const void *lhs, const void *rhs, int flags)
+{
+	if ((flags & OBJ_SEARCH_MASK) == OBJ_SEARCH_PARTIAL_KEY) {
+		return strncmp(lhs, rhs, strlen(rhs));
+	} else {
+		return strcmp(lhs, rhs);
+	}
+}
+
 static int str_cmp(void *lhs, void *rhs, int flags)
 {
-	return strcmp(lhs, rhs) ? 0 : CMP_MATCH;
+	int cmp = 0;
+
+	if ((flags & OBJ_SEARCH_MASK) == OBJ_SEARCH_PARTIAL_KEY) {
+		cmp = strncmp(lhs, rhs, strlen(rhs));
+	} else {
+		cmp = strcmp(lhs, rhs);
+	}
+
+	return cmp ? 0 : CMP_MATCH;
 }
 
 //struct ao2_container *ast_str_container_alloc_options(enum ao2_container_opts opts, int buckets)
 struct ao2_container *ast_str_container_alloc_options(enum ao2_alloc_opts opts, int buckets)
 {
-	return ao2_container_alloc_options(opts, buckets, str_hash, str_cmp);
+	return ao2_container_alloc_hash(opts, 0, buckets, str_hash, str_sort, str_cmp);
 }
 
 int ast_str_container_add(struct ao2_container *str_container, const char *add)
diff -urpN asterisk-13.9.1/main/stun.c asterisk-13.17.0/main/stun.c
--- asterisk-13.9.1/main/stun.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/stun.c	2017-07-12 13:12:08.000000000 +0200
@@ -413,6 +413,7 @@ int ast_stun_request(int s, struct socka
 		/* send request, possibly wait for reply */
 		struct sockaddr_in src;
 		socklen_t srclen;
+		struct timeval start;
 
 		/* Send STUN message. */
 		res = stun_send(s, dst, req);
@@ -426,12 +427,20 @@ int ast_stun_request(int s, struct socka
 			break;
 		}
 
+		start = ast_tvnow();
 try_again:
 		/* Wait for response. */
 		{
 			struct pollfd pfds = { .fd = s, .events = POLLIN };
+			int ms;
 
-			res = ast_poll(&pfds, 1, 3000);
+			ms = ast_remaining_ms(start, 3000);
+			if (ms <= 0) {
+				/* No response, timeout */
+				res = 1;
+				continue;
+			}
+			res = ast_poll(&pfds, 1, ms);
 			if (res < 0) {
 				/* Error */
 				continue;
diff -urpN asterisk-13.9.1/main/taskprocessor.c asterisk-13.17.0/main/taskprocessor.c
--- asterisk-13.9.1/main/taskprocessor.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/taskprocessor.c	2017-07-12 13:12:08.000000000 +0200
@@ -76,6 +76,10 @@ struct ast_taskprocessor {
 	void *local_data;
 	/*! \brief Taskprocessor current queue size */
 	long tps_queue_size;
+	/*! \brief Taskprocessor low water clear alert level */
+	long tps_queue_low;
+	/*! \brief Taskprocessor high water alert trigger level */
+	long tps_queue_high;
 	/*! \brief Taskprocessor queue */
 	AST_LIST_HEAD_NOLOCK(tps_queue, tps_task) tps_queue;
 	struct ast_taskprocessor_listener *listener;
@@ -85,6 +89,10 @@ struct ast_taskprocessor {
 	unsigned int executing:1;
 	/*! Indicates that a high water warning has been issued on this task processor */
 	unsigned int high_water_warned:1;
+	/*! Indicates that a high water alert is active on this taskprocessor */
+	unsigned int high_water_alert:1;
+	/*! Indicates if the taskprocessor is currently suspended */
+	unsigned int suspended:1;
 };
 
 /*!
@@ -121,15 +129,9 @@ static int tps_hash_cb(const void *obj,
 /*! \brief The astobj2 compare callback for taskprocessors */
 static int tps_cmp_cb(void *obj, void *arg, int flags);
 
-/*! \brief Destroy the taskprocessor when its refcount reaches zero */
-static void tps_taskprocessor_destroy(void *tps);
-
 /*! \brief CLI <example>taskprocessor ping &lt;blah&gt;</example> handler function */
 static int tps_ping_handler(void *datap);
 
-/*! \brief Remove the front task off the taskprocessor queue */
-static struct tps_task *tps_taskprocessor_pop(struct ast_taskprocessor *tps);
-
 static char *cli_tps_ping(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
 static char *cli_tps_report(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a);
 
@@ -472,8 +474,8 @@ static char *cli_tps_report(struct ast_c
 	struct ao2_container *sorted_tps;
 	struct ast_taskprocessor *tps;
 	struct ao2_iterator iter;
-#define FMT_HEADERS		"%-45s %10s %10s %10s\n"
-#define FMT_FIELDS		"%-45s %10lu %10lu %10lu\n"
+#define FMT_HEADERS		"%-45s %10s %10s %10s %10s %10s\n"
+#define FMT_FIELDS		"%-45s %10lu %10lu %10lu %10lu %10lu\n"
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -498,7 +500,7 @@ static char *cli_tps_report(struct ast_c
 		return CLI_FAILURE;
 	}
 
-	ast_cli(a->fd, "\n" FMT_HEADERS, "Processor", "Processed", "In Queue", "Max Depth");
+	ast_cli(a->fd, "\n" FMT_HEADERS, "Processor", "Processed", "In Queue", "Max Depth", "Low water", "High water");
 	tcount = 0;
 	iter = ao2_iterator_init(sorted_tps, AO2_ITERATOR_UNLINK);
 	while ((tps = ao2_iterator_next(&iter))) {
@@ -511,7 +513,8 @@ static char *cli_tps_report(struct ast_c
 			maxqsize = 0;
 			processed = 0;
 		}
-		ast_cli(a->fd, FMT_FIELDS, name, processed, qsize, maxqsize);
+		ast_cli(a->fd, FMT_FIELDS, name, processed, qsize, maxqsize,
+			tps->tps_queue_low, tps->tps_queue_high);
 		ast_taskprocessor_unreference(tps);
 		++tcount;
 	}
@@ -539,28 +542,106 @@ static int tps_cmp_cb(void *obj, void *a
 	return !strcasecmp(lhs->name, rhsname) ? CMP_MATCH | CMP_STOP : 0;
 }
 
+/*! Count of the number of taskprocessors in high water alert. */
+static unsigned int tps_alert_count;
+
+/*! Access protection for tps_alert_count */
+AST_RWLOCK_DEFINE_STATIC(tps_alert_lock);
+
+/*!
+ * \internal
+ * \brief Add a delta to tps_alert_count with protection.
+ * \since 13.10.0
+ *
+ * \param tps Taskprocessor updating queue water mark alert trigger.
+ * \param delta The amount to add to tps_alert_count.
+ *
+ * \return Nothing
+ */
+static void tps_alert_add(struct ast_taskprocessor *tps, int delta)
+{
+	unsigned int old;
+
+	ast_rwlock_wrlock(&tps_alert_lock);
+	old = tps_alert_count;
+	tps_alert_count += delta;
+	if (DEBUG_ATLEAST(3)
+		/* and tps_alert_count becomes zero or non-zero */
+		&& !old != !tps_alert_count) {
+		ast_log(LOG_DEBUG, "Taskprocessor '%s' %s the high water alert.\n",
+			tps->name, tps_alert_count ? "triggered" : "cleared");
+	}
+	ast_rwlock_unlock(&tps_alert_lock);
+}
+
+unsigned int ast_taskprocessor_alert_get(void)
+{
+	unsigned int count;
+
+	ast_rwlock_rdlock(&tps_alert_lock);
+	count = tps_alert_count;
+	ast_rwlock_unlock(&tps_alert_lock);
+
+	return count;
+}
+
+int ast_taskprocessor_alert_set_levels(struct ast_taskprocessor *tps, long low_water, long high_water)
+{
+	if (!tps || high_water < 0 || high_water < low_water) {
+		return -1;
+	}
+
+	if (low_water < 0) {
+		/* Set low water level to 90% of high water level */
+		low_water = (high_water * 9) / 10;
+	}
+
+	ao2_lock(tps);
+
+	tps->tps_queue_low = low_water;
+	tps->tps_queue_high = high_water;
+
+	if (tps->high_water_alert) {
+		if (!tps->tps_queue_size || tps->tps_queue_size < low_water) {
+			/* Update water mark alert immediately */
+			tps->high_water_alert = 0;
+			tps_alert_add(tps, -1);
+		}
+	} else {
+		if (high_water < tps->tps_queue_size) {
+			/* Update water mark alert immediately */
+			tps->high_water_alert = 1;
+			tps_alert_add(tps, +1);
+		}
+	}
+
+	ao2_unlock(tps);
+
+	return 0;
+}
+
 /* destroy the taskprocessor */
-static void tps_taskprocessor_destroy(void *tps)
+static void tps_taskprocessor_dtor(void *tps)
 {
 	struct ast_taskprocessor *t = tps;
 	struct tps_task *task;
 
-	if (!tps) {
-		ast_log(LOG_ERROR, "missing taskprocessor\n");
-		return;
+	while ((task = AST_LIST_REMOVE_HEAD(&t->tps_queue, list))) {
+		tps_task_free(task);
+	}
+	t->tps_queue_size = 0;
+
+	if (t->high_water_alert) {
+		t->high_water_alert = 0;
+		tps_alert_add(t, -1);
 	}
-	ast_debug(1, "destroying taskprocessor '%s'\n", t->name);
-	/* free it */
+
 	ast_free(t->stats);
 	t->stats = NULL;
 	ast_free((char *) t->name);
-	if (t->listener) {
-		ao2_ref(t->listener, -1);
-		t->listener = NULL;
-	}
-	while ((task = AST_LIST_REMOVE_HEAD(&t->tps_queue, list))) {
-		tps_task_free(task);
-	}
+	t->name = NULL;
+	ao2_cleanup(t->listener);
+	t->listener = NULL;
 }
 
 /* pop the front task and return it */
@@ -569,7 +650,11 @@ static struct tps_task *tps_taskprocesso
 	struct tps_task *task;
 
 	if ((task = AST_LIST_REMOVE_HEAD(&tps->tps_queue, list))) {
-		tps->tps_queue_size--;
+		--tps->tps_queue_size;
+		if (tps->high_water_alert && tps->tps_queue_size <= tps->tps_queue_low) {
+			tps->high_water_alert = 0;
+			tps_alert_add(tps, -1);
+		}
 	}
 	return task;
 }
@@ -648,19 +733,22 @@ static void *default_listener_pvt_alloc(
 
 static struct ast_taskprocessor *__allocate_taskprocessor(const char *name, struct ast_taskprocessor_listener *listener)
 {
-	RAII_VAR(struct ast_taskprocessor *, p,
-			ao2_alloc(sizeof(*p), tps_taskprocessor_destroy), ao2_cleanup);
+	struct ast_taskprocessor *p;
 
+	p = ao2_alloc(sizeof(*p), tps_taskprocessor_dtor);
 	if (!p) {
 		ast_log(LOG_WARNING, "failed to create taskprocessor '%s'\n", name);
 		return NULL;
 	}
 
-	if (!(p->stats = ast_calloc(1, sizeof(*p->stats)))) {
-		ast_log(LOG_WARNING, "failed to create taskprocessor stats for '%s'\n", name);
-		return NULL;
-	}
-	if (!(p->name = ast_strdup(name))) {
+	/* Set default congestion water level alert triggers. */
+	p->tps_queue_low = (AST_TASKPROCESSOR_HIGH_WATER_LEVEL * 9) / 10;
+	p->tps_queue_high = AST_TASKPROCESSOR_HIGH_WATER_LEVEL;
+
+	p->stats = ast_calloc(1, sizeof(*p->stats));
+	p->name = ast_strdup(name);
+	if (!p->stats || !p->name) {
+		ao2_ref(p, -1);
 		return NULL;
 	}
 
@@ -675,22 +763,18 @@ static struct ast_taskprocessor *__alloc
 	if (!(ao2_link(tps_singletons, p))) {
 		ast_log(LOG_ERROR, "Failed to add taskprocessor '%s' to container\n", p->name);
 		listener->tps = NULL;
-		ao2_ref(p, -1);
+		ao2_ref(p, -2);
 		return NULL;
 	}
 
 	if (p->listener->callbacks->start(p->listener)) {
-		ast_log(LOG_ERROR, "Unable to start taskprocessor listener for taskprocessor %s\n", p->name);
+		ast_log(LOG_ERROR, "Unable to start taskprocessor listener for taskprocessor %s\n",
+			p->name);
 		ast_taskprocessor_unreference(p);
 		return NULL;
 	}
 
-	/* RAII_VAR will decrement the refcount at the end of the function.
-	 * Since we want to pass back a reference to p, we bump the refcount
-	 */
-	ao2_ref(p, +1);
 	return p;
-
 }
 
 /* Provide a reference to a taskprocessor.  Create the taskprocessor if necessary, but don't
@@ -799,10 +883,14 @@ static int taskprocessor_push(struct ast
 	AST_LIST_INSERT_TAIL(&tps->tps_queue, t, list);
 	previous_size = tps->tps_queue_size++;
 
-	if (previous_size >= AST_TASKPROCESSOR_HIGH_WATER_LEVEL && !tps->high_water_warned) {
-		ast_log(LOG_WARNING, "The '%s' task processor queue reached %d scheduled tasks.\n",
-			tps->name, previous_size);
-		tps->high_water_warned = 1;
+	if (tps->tps_queue_high <= tps->tps_queue_size) {
+		if (!tps->high_water_alert) {
+			ast_log(LOG_WARNING, "The '%s' task processor queue reached %ld scheduled tasks%s.\n",
+				tps->name, tps->tps_queue_size, tps->high_water_warned ? " again" : "");
+			tps->high_water_warned = 1;
+			tps->high_water_alert = 1;
+			tps_alert_add(tps, +1);
+		}
 	}
 
 	/* The currently executing task counts as still in queue */
@@ -822,6 +910,33 @@ int ast_taskprocessor_push_local(struct
 	return taskprocessor_push(tps, tps_task_alloc_local(task_exe, datap));
 }
 
+int ast_taskprocessor_suspend(struct ast_taskprocessor *tps)
+{
+	if (tps) {
+		ao2_lock(tps);
+		tps->suspended = 1;
+		ao2_unlock(tps);
+		return 0;
+	}
+	return -1;
+}
+
+int ast_taskprocessor_unsuspend(struct ast_taskprocessor *tps)
+{
+	if (tps) {
+		ao2_lock(tps);
+		tps->suspended = 0;
+		ao2_unlock(tps);
+		return 0;
+	}
+	return -1;
+}
+
+int ast_taskprocessor_is_suspended(struct ast_taskprocessor *tps)
+{
+	return tps ? tps->suspended : -1;
+}
+
 int ast_taskprocessor_execute(struct ast_taskprocessor *tps)
 {
 	struct ast_taskprocessor_local local;
diff -urpN asterisk-13.9.1/main/tcptls.c asterisk-13.17.0/main/tcptls.c
--- asterisk-13.9.1/main/tcptls.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/tcptls.c	2017-07-12 13:12:08.000000000 +0200
@@ -39,6 +39,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #include <signal.h>
 #include <sys/signal.h>
+#include <sys/stat.h>
 
 #include "asterisk/compat.h"
 #include "asterisk/tcptls.h"
@@ -49,6 +50,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/manager.h"
 #include "asterisk/astobj2.h"
 #include "asterisk/pbx.h"
+#include "asterisk/app.h"
 
 /*! ao2 object used for the FILE stream fopencookie()/funopen() cookie. */
 struct ast_tcptls_stream {
@@ -81,6 +83,39 @@ struct ast_tcptls_stream {
 	int exclusive_input;
 };
 
+#if defined(DO_SSL)
+AST_THREADSTORAGE(err2str_threadbuf);
+#define ERR2STR_BUFSIZE   128
+
+static const char *ssl_error_to_string(int sslerr, int ret)
+{
+	switch (sslerr) {
+	case SSL_ERROR_SSL:
+		return "Internal SSL error";
+	case SSL_ERROR_SYSCALL:
+		if (!ret) {
+			return "System call EOF";
+		} else if (ret == -1) {
+			char *buf;
+
+			buf = ast_threadstorage_get(&err2str_threadbuf, ERR2STR_BUFSIZE);
+			if (!buf) {
+				return "Unknown";
+			}
+
+			snprintf(buf, ERR2STR_BUFSIZE, "Underlying BIO error: %s", strerror(errno));
+			return buf;
+		} else {
+			return "System call other";
+		}
+	default:
+		break;
+	}
+
+	return "Unknown";
+}
+#endif
+
 void ast_tcptls_stream_set_timeout_disable(struct ast_tcptls_stream *stream)
 {
 	ast_assert(stream != NULL);
@@ -149,12 +184,17 @@ static HOOK_T tcptls_stream_read(void *c
 #if defined(DO_SSL)
 	if (stream->ssl) {
 		for (;;) {
+			int sslerr;
+			char err[256];
+
 			res = SSL_read(stream->ssl, buf, size);
 			if (0 < res) {
 				/* We read some payload data. */
 				return res;
 			}
-			switch (SSL_get_error(stream->ssl, res)) {
+
+			sslerr = SSL_get_error(stream->ssl, res);
+			switch (sslerr) {
 			case SSL_ERROR_ZERO_RETURN:
 				/* Report EOF for a shutdown */
 				ast_debug(1, "TLS clean shutdown alert reading data\n");
@@ -202,7 +242,8 @@ static HOOK_T tcptls_stream_read(void *c
 				break;
 			default:
 				/* Report EOF for an undecoded SSL or transport error. */
-				ast_debug(1, "TLS transport or SSL error reading data\n");
+				ast_debug(1, "TLS transport or SSL error reading data: %s, %s\n", ERR_error_string(sslerr, err),
+					ssl_error_to_string(sslerr, res));
 				return 0;
 			}
 			if (!ms) {
@@ -277,6 +318,9 @@ static HOOK_T tcptls_stream_write(void *
 		written = 0;
 		remaining = size;
 		for (;;) {
+			int sslerr;
+			char err[256];
+
 			res = SSL_write(stream->ssl, buf + written, remaining);
 			if (res == remaining) {
 				/* Everything was written. */
@@ -288,7 +332,8 @@ static HOOK_T tcptls_stream_write(void *
 				remaining -= res;
 				continue;
 			}
-			switch (SSL_get_error(stream->ssl, res)) {
+			sslerr = SSL_get_error(stream->ssl, res);
+			switch (sslerr) {
 			case SSL_ERROR_ZERO_RETURN:
 				ast_debug(1, "TLS clean shutdown alert writing data\n");
 				if (written) {
@@ -317,7 +362,8 @@ static HOOK_T tcptls_stream_write(void *
 				break;
 			default:
 				/* Undecoded SSL or transport error. */
-				ast_debug(1, "TLS transport or SSL error writing data\n");
+				ast_debug(1, "TLS transport or SSL error writing data: %s, %s\n", ERR_error_string(sslerr, err),
+					ssl_error_to_string(sslerr, res));
 				if (written) {
 					/* Report partial write. */
 					return written;
@@ -394,17 +440,26 @@ static int tcptls_stream_close(void *coo
 			 */
 			res = SSL_shutdown(stream->ssl);
 			if (res < 0) {
-				ast_log(LOG_ERROR, "SSL_shutdown() failed: %d\n",
-					SSL_get_error(stream->ssl, res));
+				int sslerr = SSL_get_error(stream->ssl, res);
+				char err[256];
+
+				ast_log(LOG_ERROR, "SSL_shutdown() failed: %s, %s\n",
+					ERR_error_string(sslerr, err), ssl_error_to_string(sslerr, res));
 			}
 
+#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
+			if (!SSL_is_server(stream->ssl)) {
+#else
 			if (!stream->ssl->server) {
+#endif
 				/* For client threads, ensure that the error stack is cleared */
-#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
+#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10000000L
 				ERR_remove_thread_state(NULL);
 #else
 				ERR_remove_state(0);
-#endif	/* OPENSSL_VERSION_NUMBER >= 0x10000000L */
+#endif	/* openssl == 1.0 */
+#endif  /* openssl < 1.1 */
 			}
 
 			SSL_free(stream->ssl);
@@ -555,6 +610,35 @@ static void session_instance_destructor(
 	ao2_cleanup(i->private_data);
 }
 
+#ifdef DO_SSL
+static int check_tcptls_cert_name(ASN1_STRING *cert_str, const char *hostname, const char *desc)
+{
+	unsigned char *str;
+	int ret;
+
+	ret = ASN1_STRING_to_UTF8(&str, cert_str);
+	if (ret < 0 || !str) {
+		return -1;
+	}
+
+	if (strlen((char *) str) != ret) {
+		ast_log(LOG_WARNING, "Invalid certificate %s length (contains NULL bytes?)\n", desc);
+
+		ret = -1;
+	} else if (!strcasecmp(hostname, (char *) str)) {
+		ret = 0;
+	} else {
+		ret = -1;
+	}
+
+	ast_debug(3, "SSL %s compare s1='%s' s2='%s'\n", desc, hostname, str);
+	OPENSSL_free(str);
+
+	return ret;
+}
+
+#endif
+
 /*! \brief
 * creates a FILE * from the fd passed by the accept thread.
 * This operation is potentially expensive (certificate verification),
@@ -568,7 +652,6 @@ static void *handle_tcptls_connection(vo
 #ifdef DO_SSL
 	int (*ssl_setup)(SSL *) = (tcptls_session->client) ? SSL_connect : SSL_accept;
 	int ret;
-	char err[256];
 #endif
 
 	/* TCP/TLS connections are associated with external protocols, and
@@ -606,7 +689,11 @@ static void *handle_tcptls_connection(vo
 	else if ( (tcptls_session->ssl = SSL_new(tcptls_session->parent->tls_cfg->ssl_ctx)) ) {
 		SSL_set_fd(tcptls_session->ssl, tcptls_session->fd);
 		if ((ret = ssl_setup(tcptls_session->ssl)) <= 0) {
-			ast_log(LOG_ERROR, "Problem setting up ssl connection: %s\n", ERR_error_string(ERR_get_error(), err));
+			char err[256];
+			int sslerr = SSL_get_error(tcptls_session->ssl, ret);
+
+			ast_log(LOG_ERROR, "Problem setting up ssl connection: %s, %s\n", ERR_error_string(sslerr, err),
+				ssl_error_to_string(sslerr, ret));
 		} else if ((tcptls_session->f = tcptls_stream_fopen(tcptls_session->stream_cookie,
 			tcptls_session->ssl, tcptls_session->fd, -1))) {
 			if ((tcptls_session->client && !ast_test_flag(&tcptls_session->parent->tls_cfg->flags, AST_SSL_DONT_VERIFY_SERVER))
@@ -631,8 +718,8 @@ static void *handle_tcptls_connection(vo
 				}
 				if (!ast_test_flag(&tcptls_session->parent->tls_cfg->flags, AST_SSL_IGNORE_COMMON_NAME)) {
 					ASN1_STRING *str;
-					unsigned char *str2;
 					X509_NAME *name = X509_get_subject_name(peer);
+					STACK_OF(GENERAL_NAME) *alt_names;
 					int pos = -1;
 					int found = 0;
 
@@ -643,25 +730,36 @@ static void *handle_tcptls_connection(vo
 						if (pos < 0) {
 							break;
 						}
+
 						str = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name, pos));
-						ret = ASN1_STRING_to_UTF8(&str2, str);
-						if (ret < 0) {
-							continue;
+						if (!check_tcptls_cert_name(str, tcptls_session->parent->hostname, "common name")) {
+							found = 1;
+							break;
 						}
+					}
 
-						if (str2) {
-							if (strlen((char *) str2) != ret) {
-								ast_log(LOG_WARNING, "Invalid certificate common name length (contains NULL bytes?)\n");
-							} else if (!strcasecmp(tcptls_session->parent->hostname, (char *) str2)) {
-								found = 1;
+					if (!found) {
+						alt_names = X509_get_ext_d2i(peer, NID_subject_alt_name, NULL, NULL);
+						if (alt_names != NULL) {
+							int alt_names_count = sk_GENERAL_NAME_num(alt_names);
+
+							for (pos = 0; pos < alt_names_count; pos++) {
+								const GENERAL_NAME *alt_name = sk_GENERAL_NAME_value(alt_names, pos);
+
+								if (alt_name->type != GEN_DNS) {
+									continue;
+								}
+
+								if (!check_tcptls_cert_name(alt_name->d.dNSName, tcptls_session->parent->hostname, "alt name")) {
+									found = 1;
+									break;
+								}
 							}
-							ast_debug(3, "SSL Common Name compare s1='%s' s2='%s'\n", tcptls_session->parent->hostname, str2);
-							OPENSSL_free(str2);
-						}
-						if (found) {
-							break;
+
+							sk_GENERAL_NAME_pop_free(alt_names, GENERAL_NAME_free);
 						}
 					}
+
 					if (!found) {
 						ast_log(LOG_ERROR, "Certificate common name did not match (%s)\n", tcptls_session->parent->hostname);
 						X509_free(peer);
@@ -714,26 +812,37 @@ void *ast_tcptls_server_root(void *data)
 		}
 		i = ast_wait_for_input(desc->accept_fd, desc->poll_timeout);
 		if (i <= 0) {
+			/* Prevent tight loop from hogging CPU */
+			usleep(1);
 			continue;
 		}
 		fd = ast_accept(desc->accept_fd, &addr);
 		if (fd < 0) {
-			if ((errno != EAGAIN) && (errno != EWOULDBLOCK) && (errno != EINTR) && (errno != ECONNABORTED)) {
-				ast_log(LOG_ERROR, "Accept failed: %s\n", strerror(errno));
-				break;
+			if (errno != EAGAIN
+				&& errno != EWOULDBLOCK
+				&& errno != EINTR
+				&& errno != ECONNABORTED) {
+				ast_log(LOG_ERROR, "TCP/TLS accept failed: %s\n", strerror(errno));
+				if (errno != EMFILE) {
+					break;
+				}
 			}
+			/* Prevent tight loop from hogging CPU */
+			usleep(1);
 			continue;
 		}
 		tcptls_session = ao2_alloc(sizeof(*tcptls_session), session_instance_destructor);
 		if (!tcptls_session) {
-			ast_log(LOG_WARNING, "No memory for new session: %s\n", strerror(errno));
-			if (close(fd)) {
-				ast_log(LOG_ERROR, "close() failed: %s\n", strerror(errno));
-			}
+			close(fd);
 			continue;
 		}
 
 		tcptls_session->overflow_buf = ast_str_create(128);
+		if (!tcptls_session->overflow_buf) {
+			ao2_ref(tcptls_session, -1);
+			close(fd);
+			continue;
+		}
 		flags = fcntl(fd, F_GETFL);
 		fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);
 		tcptls_session->fd = fd;
@@ -744,11 +853,21 @@ void *ast_tcptls_server_root(void *data)
 
 		/* This thread is now the only place that controls the single ref to tcptls_session */
 		if (ast_pthread_create_detached_background(&launched, NULL, handle_tcptls_connection, tcptls_session)) {
-			ast_log(LOG_ERROR, "Unable to launch helper thread: %s\n", strerror(errno));
+			ast_log(LOG_ERROR, "TCP/TLS unable to launch helper thread: %s\n",
+				strerror(errno));
 			ast_tcptls_close_session_file(tcptls_session);
 			ao2_ref(tcptls_session, -1);
 		}
 	}
+
+	ast_log(LOG_ERROR, "TCP/TLS listener thread ended abnormally\n");
+
+	/* Close the listener socket so Asterisk doesn't appear dead. */
+	fd = desc->accept_fd;
+	desc->accept_fd = -1;
+	if (0 <= fd) {
+		close(fd);
+	}
 	return NULL;
 }
 
@@ -774,7 +893,7 @@ static int __ssl_setup(struct ast_tls_co
 	}
 
 	if (client) {
-#ifndef OPENSSL_NO_SSL2
+#if !defined(OPENSSL_NO_SSL2) && (OPENSSL_VERSION_NUMBER < 0x10100000L)
 		if (ast_test_flag(&cfg->flags, AST_SSL_SSLV2_CLIENT)) {
 			ast_log(LOG_WARNING, "Usage of SSLv2 is discouraged due to known vulnerabilities. Please use 'tlsv1' or leave the TLS method unspecified!\n");
 			cfg->ssl_ctx = SSL_CTX_new(SSLv2_client_method());
@@ -786,12 +905,16 @@ static int __ssl_setup(struct ast_tls_co
 			cfg->ssl_ctx = SSL_CTX_new(SSLv3_client_method());
 		} else
 #endif
+#if defined(OPENSSL_VERSION_NUMBER) && (OPENSSL_VERSION_NUMBER  >= 0x10100000L)
+		cfg->ssl_ctx = SSL_CTX_new(TLS_client_method());
+#else
 		if (ast_test_flag(&cfg->flags, AST_SSL_TLSV1_CLIENT)) {
 			cfg->ssl_ctx = SSL_CTX_new(TLSv1_client_method());
 		} else {
 			disable_ssl = 1;
 			cfg->ssl_ctx = SSL_CTX_new(SSLv23_client_method());
 		}
+#endif
 	} else {
 		disable_ssl = 1;
 		cfg->ssl_ctx = SSL_CTX_new(SSLv23_server_method());
@@ -1008,11 +1131,15 @@ struct ast_tcptls_session_instance *ast_
 		}
 	}
 
-	if (!(tcptls_session = ao2_alloc(sizeof(*tcptls_session), session_instance_destructor))) {
+	tcptls_session = ao2_alloc(sizeof(*tcptls_session), session_instance_destructor);
+	if (!tcptls_session) {
 		goto error;
 	}
 
 	tcptls_session->overflow_buf = ast_str_create(128);
+	if (!tcptls_session->overflow_buf) {
+		goto error;
+	}
 	tcptls_session->client = 1;
 	tcptls_session->fd = desc->accept_fd;
 	tcptls_session->parent = desc;
@@ -1027,9 +1154,7 @@ struct ast_tcptls_session_instance *ast_
 error:
 	close(desc->accept_fd);
 	desc->accept_fd = -1;
-	if (tcptls_session) {
-		ao2_ref(tcptls_session, -1);
-	}
+	ao2_cleanup(tcptls_session);
 	return NULL;
 }
 
@@ -1037,9 +1162,64 @@ void ast_tcptls_server_start(struct ast_
 {
 	int flags;
 	int x = 1;
+	int tls_changed = 0;
+
+	if (desc->tls_cfg) {
+		char hash[41];
+		char *str = NULL;
+		struct stat st;
+
+		/* Store the hashes of the TLS certificate etc. */
+		if (stat(desc->tls_cfg->certfile, &st) || NULL == (str = ast_read_textfile(desc->tls_cfg->certfile))) {
+			memset(hash, 0, 41);
+		} else {
+			ast_sha1_hash(hash, str);
+		}
+		ast_free(str);
+		str = NULL;
+		memcpy(desc->tls_cfg->certhash, hash, 41);
+		if (stat(desc->tls_cfg->pvtfile, &st) || NULL == (str = ast_read_textfile(desc->tls_cfg->pvtfile))) {
+			memset(hash, 0, 41);
+		} else {
+			ast_sha1_hash(hash, str);
+		}
+		ast_free(str);
+		str = NULL;
+		memcpy(desc->tls_cfg->pvthash, hash, 41);
+		if (stat(desc->tls_cfg->cafile, &st) || NULL == (str = ast_read_textfile(desc->tls_cfg->cafile))) {
+			memset(hash, 0, 41);
+		} else {
+			ast_sha1_hash(hash, str);
+		}
+		ast_free(str);
+		str = NULL;
+		memcpy(desc->tls_cfg->cahash, hash, 41);
+
+		/* Check whether TLS configuration has changed */
+		if (!desc->old_tls_cfg) { /* No previous configuration */
+			tls_changed = 1;
+			desc->old_tls_cfg = ast_calloc(1, sizeof(*desc->old_tls_cfg));
+		} else if (memcmp(desc->tls_cfg->certhash, desc->old_tls_cfg->certhash, 41)) {
+			tls_changed = 1;
+		} else if (memcmp(desc->tls_cfg->pvthash, desc->old_tls_cfg->pvthash, 41)) {
+			tls_changed = 1;
+		} else if (strcmp(desc->tls_cfg->cipher, desc->old_tls_cfg->cipher)) {
+			tls_changed = 1;
+		} else if (memcmp(desc->tls_cfg->cahash, desc->old_tls_cfg->cahash, 41)) {
+			tls_changed = 1;
+		} else if (strcmp(desc->tls_cfg->capath, desc->old_tls_cfg->capath)) {
+			tls_changed = 1;
+		} else if (memcmp(&desc->tls_cfg->flags, &desc->old_tls_cfg->flags, sizeof(desc->tls_cfg->flags))) {
+			tls_changed = 1;
+		}
+
+		if (tls_changed) {
+			ast_debug(1, "Changed parameters for %s found\n", desc->name);
+		}
+	}
 
 	/* Do nothing if nothing has changed */
-	if (!ast_sockaddr_cmp(&desc->old_address, &desc->local_address)) {
+	if (!tls_changed && !ast_sockaddr_cmp(&desc->old_address, &desc->local_address)) {
 		ast_debug(1, "Nothing changed in %s\n", desc->name);
 		return;
 	}
@@ -1095,6 +1275,22 @@ void ast_tcptls_server_start(struct ast_
 
 	/* Set current info */
 	ast_sockaddr_copy(&desc->old_address, &desc->local_address);
+	if (desc->old_tls_cfg) {
+		ast_free(desc->old_tls_cfg->certfile);
+		ast_free(desc->old_tls_cfg->pvtfile);
+		ast_free(desc->old_tls_cfg->cipher);
+		ast_free(desc->old_tls_cfg->cafile);
+		ast_free(desc->old_tls_cfg->capath);
+		desc->old_tls_cfg->certfile = ast_strdup(desc->tls_cfg->certfile);
+		desc->old_tls_cfg->pvtfile = ast_strdup(desc->tls_cfg->pvtfile);
+		desc->old_tls_cfg->cipher = ast_strdup(desc->tls_cfg->cipher);
+		desc->old_tls_cfg->cafile = ast_strdup(desc->tls_cfg->cafile);
+		desc->old_tls_cfg->capath = ast_strdup(desc->tls_cfg->capath);
+		memcpy(desc->old_tls_cfg->certhash, desc->tls_cfg->certhash, 41);
+		memcpy(desc->old_tls_cfg->pvthash, desc->tls_cfg->pvthash, 41);
+		memcpy(desc->old_tls_cfg->cahash, desc->tls_cfg->cahash, 41);
+		memcpy(&desc->old_tls_cfg->flags, &desc->tls_cfg->flags, sizeof(desc->old_tls_cfg->flags));
+	}
 
 	return;
 
@@ -1140,6 +1336,17 @@ void ast_tcptls_server_stop(struct ast_t
 		close(desc->accept_fd);
 	}
 	desc->accept_fd = -1;
+
+	if (desc->old_tls_cfg) {
+		ast_free(desc->old_tls_cfg->certfile);
+		ast_free(desc->old_tls_cfg->pvtfile);
+		ast_free(desc->old_tls_cfg->cipher);
+		ast_free(desc->old_tls_cfg->cafile);
+		ast_free(desc->old_tls_cfg->capath);
+		ast_free(desc->old_tls_cfg);
+		desc->old_tls_cfg = NULL;
+	}
+
 	ast_debug(2, "Stopped server :: %s\n", desc->name);
 }
 
diff -urpN asterisk-13.9.1/main/test.c asterisk-13.17.0/main/test.c
--- asterisk-13.9.1/main/test.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/test.c	2017-07-12 13:12:08.000000000 +0200
@@ -346,7 +346,7 @@ static int test_execute_multiple(const c
 		execute = 0;
 		switch (mode) {
 		case TEST_CATEGORY:
-			if (!test_cat_cmp(test->info.category, category)) {
+			if (!test_cat_cmp(test->info.category, category) && !test->info.explicit_only) {
 				execute = 1;
 			}
 			break;
@@ -356,7 +356,7 @@ static int test_execute_multiple(const c
 			}
 			break;
 		case TEST_ALL:
-			execute = 1;
+			execute = !test->info.explicit_only;
 		}
 
 		if (execute) {
diff -urpN asterisk-13.9.1/main/threadpool.c asterisk-13.17.0/main/threadpool.c
--- asterisk-13.9.1/main/threadpool.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/threadpool.c	2017-07-12 13:12:08.000000000 +0200
@@ -1012,6 +1012,7 @@ static void worker_thread_destroy(void *
 static void *worker_start(void *arg)
 {
 	struct worker_thread *worker = arg;
+	enum worker_state saved_state;
 
 	if (worker->options.thread_start) {
 		worker->options.thread_start();
@@ -1027,6 +1028,7 @@ static void *worker_start(void *arg)
 		}
 		threadpool_active_thread_idle(worker->pool, worker);
 	}
+	saved_state = worker->state;
 	ast_mutex_unlock(&worker->lock);
 
 	/* Reaching this portion means the thread is
@@ -1037,7 +1039,7 @@ static void *worker_start(void *arg)
 	 * that the thread can be removed from the
 	 * list of zombie threads.
 	 */
-	if (worker->state == ZOMBIE) {
+	if (saved_state == ZOMBIE) {
 		threadpool_zombie_thread_dead(worker->pool, worker);
 	}
 
@@ -1382,10 +1384,12 @@ struct ast_taskprocessor *ast_threadpool
 		ao2_ref(ser, -1);
 		return NULL;
 	}
-	/* ser ref transferred to listener */
 
 	tps = ast_taskprocessor_create_with_listener(name, listener);
-	if (tps && shutdown_group) {
+	if (!tps) {
+		/* ser ref transferred to listener but not cleaned without tps */
+		ao2_ref(ser, -1);
+	} else if (shutdown_group) {
 		serializer_shutdown_group_inc(shutdown_group);
 	}
 
diff -urpN asterisk-13.9.1/main/translate.c asterisk-13.17.0/main/translate.c
--- asterisk-13.9.1/main/translate.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/translate.c	2017-07-12 13:12:08.000000000 +0200
@@ -444,8 +444,14 @@ struct ast_frame *ast_trans_frameout(str
 	}
 	if (datalen) {
 		f->datalen = datalen;
+		f->data.ptr = pvt->outbuf.c;
 	} else {
 		f->datalen = pvt->datalen;
+		if (!f->datalen) {
+			f->data.ptr = NULL;
+		} else {
+			f->data.ptr = pvt->outbuf.c;
+		}
 		pvt->datalen = 0;
 	}
 
@@ -494,7 +500,7 @@ struct ast_trans_pvt *ast_translator_bui
 			AST_RWLIST_UNLOCK(&translators);
 			return NULL;
 		}
-		if ((t->dst_codec.sample_rate == ast_format_get_sample_rate(dst)) && (t->dst_codec.type == ast_format_get_type(dst)) && (!strcmp(t->dst_codec.name, ast_format_get_name(dst)))) {
+		if ((t->dst_codec.sample_rate == ast_format_get_sample_rate(dst)) && (t->dst_codec.type == ast_format_get_type(dst))) {
 			explicit_dst = dst;
 		}
 		if (!(cur = newpvt(t, explicit_dst))) {
diff -urpN asterisk-13.9.1/main/udptl.c asterisk-13.17.0/main/udptl.c
--- asterisk-13.9.1/main/udptl.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/udptl.c	2017-07-12 13:12:08.000000000 +0200
@@ -769,6 +769,18 @@ struct ast_frame *ast_udptl_read(struct
 		return &ast_null_frame;
 	}
 
+	/*
+	 * If early media isn't turned on for the channel driver, it's going to
+	 * drop this frame.  By that time though, udptl has already incremented
+	 * the expected sequence number so if the CPE re-sends, the second frame
+	 * will be dropped as a dup even though the first frame never went through.
+	 * So we drop the frame here if the channel isn't up. 'tag' is set by the
+	 * channel drivers on T38_ENABLED or T38_PEER_REINVITE.
+	 */
+	if (udptl->tag == NULL) {
+		return &ast_null_frame;
+	}
+
 	if (udptl->nat) {
 		/* Send to whoever sent to us */
 		if (ast_sockaddr_cmp(&udptl->them, &addr)) {
diff -urpN asterisk-13.9.1/main/utils.c asterisk-13.17.0/main/utils.c
--- asterisk-13.9.1/main/utils.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/main/utils.c	2017-07-12 13:12:08.000000000 +0200
@@ -69,6 +69,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #define AST_API_MODULE
 #include "asterisk/config.h"
 
+#define AST_API_MODULE
+#include "asterisk/alertpipe.h"
+
 static char base64[64];
 static char b2a[256];
 
@@ -1453,7 +1456,9 @@ int ast_careful_fwrite(FILE *f, int fd,
 
 		if (ferror(f) && errno != EINTR && errno != EAGAIN) {
 			/* fatal error from fwrite() */
-			if (!feof(f)) {
+			if (errno == EPIPE) {
+				ast_debug(1, "fwrite() failed due to reading end being closed: EPIPE\n");
+			} else if (!feof(f)) {
 				/* Don't spam the logs if it was just that the connection is closed. */
 				ast_log(LOG_ERROR, "fwrite() returned error: %s\n", strerror(errno));
 			}
@@ -1486,8 +1491,12 @@ int ast_careful_fwrite(FILE *f, int fd,
 			continue;
 		}
 		if (errno && !feof(f)) {
-			/* Don't spam the logs if it was just that the connection is closed. */
-			ast_log(LOG_ERROR, "fflush() returned error: %s\n", strerror(errno));
+			if (errno == EPIPE) {
+				ast_debug(1, "fflush() failed due to reading end being closed: EPIPE\n");
+			} else {
+				/* Don't spam the logs if it was just that the connection is closed. */
+				ast_log(LOG_ERROR, "fflush() returned error: %s\n", strerror(errno));
+			}
 		}
 		n = -1;
 		break;
@@ -2425,7 +2434,19 @@ char *ast_utils_which(const char *binary
 	return NULL;
 }
 
-void ast_do_crash(void)
+int ast_check_ipv6(void)
+{
+	int udp6_socket = socket(AF_INET6, SOCK_DGRAM, 0);
+
+	if (udp6_socket < 0) {
+		return 0;
+	}
+
+	close(udp6_socket);
+	return 1;
+}
+
+void DO_CRASH_NORETURN ast_do_crash(void)
 {
 #if defined(DO_CRASH)
 	abort();
@@ -2437,17 +2458,16 @@ void ast_do_crash(void)
 #endif	/* defined(DO_CRASH) */
 }
 
-#if defined(AST_DEVMODE)
-void __ast_assert_failed(int condition, const char *condition_str, const char *file, int line, const char *function)
+void DO_CRASH_NORETURN __ast_assert_failed(int condition, const char *condition_str, const char *file, int line, const char *function)
 {
 	/*
 	 * Attempt to put it into the logger, but hope that at least
 	 * someone saw the message on stderr ...
 	 */
-	ast_log(__LOG_ERROR, file, line, function, "FRACK!, Failed assertion %s (%d)\n",
-		condition_str, condition);
 	fprintf(stderr, "FRACK!, Failed assertion %s (%d) at line %d in %s of %s\n",
 		condition_str, condition, line, function, file);
+	ast_log(__LOG_ERROR, file, line, function, "FRACK!, Failed assertion %s (%d)\n",
+		condition_str, condition);
 
 	/* Generate a backtrace for the assert */
 	ast_log_backtrace();
@@ -2460,7 +2480,6 @@ void __ast_assert_failed(int condition,
 	usleep(1);
 	ast_do_crash();
 }
-#endif	/* defined(AST_DEVMODE) */
 
 char *ast_eid_to_str(char *s, int maxlen, struct ast_eid *eid)
 {
@@ -2480,72 +2499,226 @@ char *ast_eid_to_str(char *s, int maxlen
 	return os;
 }
 
+#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__Darwin__)
+#include <ifaddrs.h>
+#include <net/if_dl.h>
+
 void ast_set_default_eid(struct ast_eid *eid)
 {
-#if defined(SIOCGIFHWADDR) && defined(HAVE_STRUCT_IFREQ_IFR_IFRU_IFRU_HWADDR)
-	int s, x = 0;
+	struct ifaddrs *ifap, *ifaphead;
+	int rtnerr;
+	const struct sockaddr_dl *sdl;
+	int alen;
+	caddr_t ap;
 	char eid_str[20];
-	struct ifreq ifr;
-	static const unsigned int MAXIF = 10;
+	unsigned char empty_mac[6] = {0, 0, 0, 0, 0, 0};
+	unsigned char full_mac[6]  = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 
-	s = socket(AF_INET, SOCK_STREAM, 0);
-	if (s < 0) {
+	rtnerr = getifaddrs(&ifaphead);
+	if (rtnerr) {
+		ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+			"You will have to set it manually.\n");
 		return;
 	}
-	for (x = 0; x < MAXIF; x++) {
-		static const char *prefixes[] = { "eth", "em" };
-		unsigned int i;
 
-		for (i = 0; i < ARRAY_LEN(prefixes); i++) {
-			memset(&ifr, 0, sizeof(ifr));
-			snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s%d", prefixes[i], x);
-			if (!ioctl(s, SIOCGIFHWADDR, &ifr)) {
-				break;
-			}
+	if (!ifaphead) {
+		ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+			"You will have to set it manually.\n");
+		return;
+	}
+
+	for (ifap = ifaphead; ifap; ifap = ifap->ifa_next) {
+		if (ifap->ifa_addr->sa_family != AF_LINK) {
+			continue;
 		}
 
-		if (i == ARRAY_LEN(prefixes)) {
-			/* Try pciX#[1..N] */
-			for (i = 0; i < MAXIF; i++) {
-				memset(&ifr, 0, sizeof(ifr));
-				snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "pci%d#%u", x, i);
-				if (!ioctl(s, SIOCGIFHWADDR, &ifr)) {
-					break;
-				}
-			}
-			if (i == MAXIF) {
-				continue;
-			}
+		sdl = (const struct sockaddr_dl *) ifap->ifa_addr;
+		ap = ((caddr_t) ((sdl)->sdl_data + (sdl)->sdl_nlen));
+		alen = sdl->sdl_alen;
+		if (alen != 6 || !(memcmp(ap, &empty_mac, 6) && memcmp(ap, &full_mac, 6))) {
+			continue;
 		}
 
-		memcpy(eid, ((unsigned char *)&ifr.ifr_hwaddr) + 2, sizeof(*eid));
-		ast_debug(1, "Seeding global EID '%s' from '%s' using 'siocgifhwaddr'\n", ast_eid_to_str(eid_str, sizeof(eid_str), eid), ifr.ifr_name);
+		memcpy(eid, ap, sizeof(*eid));
+		ast_debug(1, "Seeding global EID '%s'\n",
+				ast_eid_to_str(eid_str, sizeof(eid_str), eid));
+		freeifaddrs(ifaphead);
+		return;
+	}
+
+	ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+		"You will have to set it manually.\n");
+	freeifaddrs(ifaphead);
+
+	return;
+}
+
+#elif defined(SOLARIS)
+#include <sys/sockio.h>
+#include <net/if_arp.h>
+
+void ast_set_default_eid(struct ast_eid *eid)
+{
+	int s;
+	int x;
+	int res = 0;
+	struct lifreq *ifr = NULL;
+	struct lifnum ifn;
+	struct lifconf ifc;
+	struct arpreq ar;
+	struct sockaddr_in *sa, *sa2;
+	char *buf = NULL;
+	char eid_str[20];
+	int bufsz;
+	unsigned char empty_mac[6] = {0, 0, 0, 0, 0, 0};
+	unsigned char full_mac[6]  = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+	s = socket(AF_INET, SOCK_STREAM, 0);
+	if (s <= 0) {
+		ast_log(LOG_WARNING, "Unable to open a socket for seeding global EID. "
+			" You will have to set it manually.\n");
+		return;
+	}
+
+	/* Get a count of interfaces on the machine */
+	ifn.lifn_family = AF_UNSPEC;
+	ifn.lifn_flags = 0;
+	ifn.lifn_count = 0;
+	if (ioctl(s, SIOCGLIFNUM, &ifn) < 0) {
+		ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+			" You will have to set it manually.\n");
 		close(s);
 		return;
 	}
+
+	bufsz = ifn.lifn_count * sizeof(struct lifreq);
+	if (!(buf = ast_malloc(bufsz))) {
+		ast_log(LOG_WARNING, "Unable to allocate memory for seeding global EID. "
+			"You will have to set it manually.\n");
+		close(s);
+		return;
+	}
+	memset(buf, 0, bufsz);
+
+	/* Get a list of interfaces on the machine */
+	ifc.lifc_len = bufsz;
+	ifc.lifc_buf = buf;
+	ifc.lifc_family = AF_UNSPEC;
+	ifc.lifc_flags = 0;
+	if (ioctl(s, SIOCGLIFCONF, &ifc) < 0) {
+		ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+			"You will have to set it manually.\n");
+		ast_free(buf);
+		close(s);
+		return;
+	}
+
+	for (ifr = (struct lifreq *)buf, x = 0; x < ifn.lifn_count; ifr++, x++) {
+		unsigned char *p;
+
+		sa = (struct sockaddr_in *)&(ifr->lifr_addr);
+		sa2 = (struct sockaddr_in *)&(ar.arp_pa);
+		*sa2 = *sa;
+
+		if(ioctl(s, SIOCGARP, &ar) >= 0) {
+			p = (unsigned char *)&(ar.arp_ha.sa_data);
+			if (!(memcmp(p, &empty_mac, 6) && memcmp(p, &full_mac, 6))) {
+				continue;
+			}
+
+			memcpy(eid, p, sizeof(*eid));
+			ast_debug(1, "Seeding global EID '%s'\n",
+				ast_eid_to_str(eid_str, sizeof(eid_str), eid));
+			ast_free(buf);
+			close(s);
+			return;
+		}
+	}
+
+	ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+		"You will have to set it manually.\n");
+	ast_free(buf);
 	close(s);
+
+	return;
+}
+
 #else
-#if defined(ifa_broadaddr) && !defined(SOLARIS)
+void ast_set_default_eid(struct ast_eid *eid)
+{
+	int s;
+	int i;
+	struct ifreq *ifr;
+	struct ifreq *ifrp;
+	struct ifconf ifc;
+	char *buf = NULL;
 	char eid_str[20];
-	struct ifaddrs *ifap;
+	int bufsz, num_interfaces;
+	unsigned char empty_mac[6] = {0, 0, 0, 0, 0, 0};
+	unsigned char full_mac[6]  = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+	s = socket(AF_INET, SOCK_STREAM, 0);
+	if (s <= 0) {
+		ast_log(LOG_WARNING, "Unable to open socket for seeding global EID. "
+			"You will have to set it manually.\n");
+		return;
+	}
+
+	ifc.ifc_len = 0;
+	ifc.ifc_buf = NULL;
+	if (ioctl(s, SIOCGIFCONF, &ifc) || ifc.ifc_len <= 0) {
+		ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+			"You will have to set it manually.\n");
+		close(s);
+		return;
+	}
+	bufsz = ifc.ifc_len;
+
+	if (!(buf = ast_malloc(bufsz))) {
+		ast_log(LOG_WARNING, "Unable to allocate memory for seeding global EID. "
+			"You will have to set it manually.\n");
+		close(s);
+		return;
+	}
+
+	ifc.ifc_buf = buf;
+	if (ioctl(s, SIOCGIFCONF, &ifc) < 0) {
+		ast_log(LOG_WARNING, "Unable to retrieve ethernet interfaces for seeding global EID. "
+			"You will have to set it manually.\n");
+		ast_free(buf);
+		close(s);
+		return;
+	}
+
+	ifrp = ifc.ifc_req;
+	num_interfaces = ifc.ifc_len / sizeof(*ifr);
+
+	for (i = 0; i < num_interfaces; i++) {
+		ifr = &ifrp[i];
+		if (!ioctl(s, SIOCGIFHWADDR, ifr)) {
+			unsigned char *hwaddr = (unsigned char *) ifr->ifr_hwaddr.sa_data;
 
-	if (getifaddrs(&ifap) == 0) {
-		struct ifaddrs *p;
-		for (p = ifap; p; p = p->ifa_next) {
-			if ((p->ifa_addr->sa_family == AF_LINK) && !(p->ifa_flags & IFF_LOOPBACK) && (p->ifa_flags & IFF_RUNNING)) {
-				struct sockaddr_dl* sdp = (struct sockaddr_dl*) p->ifa_addr;
-				memcpy(&(eid->eid), sdp->sdl_data + sdp->sdl_nlen, 6);
-				ast_debug(1, "Seeding global EID '%s' from '%s' using 'getifaddrs'\n", ast_eid_to_str(eid_str, sizeof(eid_str), eid), p->ifa_name);
-				freeifaddrs(ifap);
-				return;
+			if (!(memcmp(hwaddr, &empty_mac, 6) && memcmp(hwaddr, &full_mac, 6))) {
+				continue;
 			}
+
+			memcpy(eid, hwaddr, sizeof(*eid));
+			ast_debug(1, "Seeding global EID '%s' from '%s' using 'siocgifhwaddr'\n",
+				ast_eid_to_str(eid_str, sizeof(eid_str), eid), ifr->ifr_name);
+			ast_free(buf);
+			close(s);
+			return;
 		}
-		freeifaddrs(ifap);
 	}
-#endif
-#endif
-	ast_debug(1, "No ethernet interface found for seeding global EID. You will have to set it manually.\n");
+
+	ast_log(LOG_WARNING, "No ethernet interface found for seeding global EID. "
+		"You will have to set it manually.\n");
+	ast_free(buf);
+	close(s);
+
+	return;
 }
+#endif /* LINUX */
 
 int ast_str_to_eid(struct ast_eid *eid, const char *s)
 {
@@ -2569,6 +2742,14 @@ int ast_eid_cmp(const struct ast_eid *ei
 	return memcmp(eid1, eid2, sizeof(*eid1));
 }
 
+int ast_eid_is_empty(const struct ast_eid *eid)
+{
+	struct ast_eid empty_eid;
+
+	memset(&empty_eid, 0, sizeof(empty_eid));
+	return memcmp(eid, &empty_eid, sizeof(empty_eid)) ? 0 : 1;
+}
+
 int ast_file_is_readable(const char *filename)
 {
 #if defined(HAVE_EACCESS) || defined(HAVE_EUIDACCESS)
diff -urpN asterisk-13.9.1/makeopts.in asterisk-13.17.0/makeopts.in
--- asterisk-13.9.1/makeopts.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/makeopts.in	2017-07-12 13:12:08.000000000 +0200
@@ -27,18 +27,27 @@ STRIP=@STRIP@
 WGET=@WGET@
 FETCH=@FETCH@
 DOWNLOAD=@DOWNLOAD@
+DOWNLOAD_TO_STDOUT=@DOWNLOAD_TO_STDOUT@
+DOWNLOAD_TIMEOUT=@DOWNLOAD_TIMEOUT@
 SOUNDS_CACHE_DIR=@SOUNDS_CACHE_DIR@
+EXTERNALS_CACHE_DIR=@EXTERNALS_CACHE_DIR@
 RUBBER=@RUBBER@
 CATDVI=@CATDVI@
 KPATHSEA=@KPATHSEA@
 XMLLINT=@XMLLINT@
 XMLSTARLET=@XMLSTARLET@
+BASH=@BASH@
 MD5=@MD5@
 SHA1SUM=@SHA1SUM@
 OPENSSL=@OPENSSL@
 LDCONFIG=@LDCONFIG@
 GIT=@GIT@
 ALEMBIC=@ALEMBIC@
+TAR=@TAR@
+PATCH=@PATCH@
+SED=@SED@
+NM=@NM@
+CAT=@CAT@
 
 BUILD_PLATFORM=@BUILD_PLATFORM@
 BUILD_CPU=@BUILD_CPU@
@@ -53,8 +62,7 @@ HOST_OS=@HOST_OS@
 OSARCH=@OSARCH@
 OSREV=@PBX_OSREV@
 
-GC_CFLAGS=@GC_CFLAGS@
-GC_LDFLAGS=@GC_LDFLAGS@
+BIND8_CFLAGS=@BIND8_CFLAGS@
 
 PTHREAD_CFLAGS=@PTHREAD_CFLAGS@
 PTHREAD_LIBS=@PTHREAD_LIBS@
@@ -243,12 +251,21 @@ PORTAUDIO_LIB=@PORTAUDIO_LIB@
 PRI_INCLUDE=@PRI_INCLUDE@
 PRI_LIB=@PRI_LIB@
 
+PYTHONDEV_INCLUDE=@PYTHONDEV_INCLUDE@
+PYTHONDEV_LIB=@PYTHONDEV_LIB@
+
 RESAMPLE_INCLUDE=@RESAMPLE_INCLUDE@
 RESAMPLE_LIB=@RESAMPLE_LIB@
 
+RT_LIB=@RT_LIB@
+
 SS7_INCLUDE=@SS7_INCLUDE@
 SS7_LIB=@SS7_LIB@
 
+HAVE_SYSTEMD=@PBX_SYSTEMD@
+SYSTEMD_INCLUDE=@SYSTEMD_INCLUDE@
+SYSTEMD_LIB=@SYSTEMD_LIB@
+
 OPENR2_INCLUDE=@OPENR2_INCLUDE@
 OPENR2_LIB=@OPENR2_LIB@
 
diff -urpN asterisk-13.9.1/menuselect/aclocal.m4 asterisk-13.17.0/menuselect/aclocal.m4
--- asterisk-13.9.1/menuselect/aclocal.m4	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/aclocal.m4	2017-07-12 13:12:08.000000000 +0200
@@ -1,6 +1,6 @@
-# generated automatically by aclocal 1.14.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.15 -*- Autoconf -*-
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2014 Free Software Foundation, Inc.
 
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -12,8 +12,285 @@
 # PARTICULAR PURPOSE.
 
 m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
+dnl pkg.m4 - Macros to locate and utilise pkg-config.   -*- Autoconf -*-
+dnl serial 11 (pkg-config-0.29)
+dnl
+dnl Copyright © 2004 Scott James Remnant <scott@netsplit.com>.
+dnl Copyright © 2012-2015 Dan Nicholson <dbn.lists@gmail.com>
+dnl
+dnl This program is free software; you can redistribute it and/or modify
+dnl it under the terms of the GNU General Public License as published by
+dnl the Free Software Foundation; either version 2 of the License, or
+dnl (at your option) any later version.
+dnl
+dnl This program is distributed in the hope that it will be useful, but
+dnl WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+dnl General Public License for more details.
+dnl
+dnl You should have received a copy of the GNU General Public License
+dnl along with this program; if not, write to the Free Software
+dnl Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+dnl 02111-1307, USA.
+dnl
+dnl As a special exception to the GNU General Public License, if you
+dnl distribute this file as part of a program that contains a
+dnl configuration script generated by Autoconf, you may include it under
+dnl the same distribution terms that you use for the rest of that
+dnl program.
+
+dnl PKG_PREREQ(MIN-VERSION)
+dnl -----------------------
+dnl Since: 0.29
+dnl
+dnl Verify that the version of the pkg-config macros are at least
+dnl MIN-VERSION. Unlike PKG_PROG_PKG_CONFIG, which checks the user's
+dnl installed version of pkg-config, this checks the developer's version
+dnl of pkg.m4 when generating configure.
+dnl
+dnl To ensure that this macro is defined, also add:
+dnl m4_ifndef([PKG_PREREQ],
+dnl     [m4_fatal([must install pkg-config 0.29 or later before running autoconf/autogen])])
+dnl
+dnl See the "Since" comment for each macro you use to see what version
+dnl of the macros you require.
+m4_defun([PKG_PREREQ],
+[m4_define([PKG_MACROS_VERSION], [0.29])
+m4_if(m4_version_compare(PKG_MACROS_VERSION, [$1]), -1,
+    [m4_fatal([pkg.m4 version $1 or higher is required but ]PKG_MACROS_VERSION[ found])])
+])dnl PKG_PREREQ
+
+dnl PKG_PROG_PKG_CONFIG([MIN-VERSION])
+dnl ----------------------------------
+dnl Since: 0.16
+dnl
+dnl Search for the pkg-config tool and set the PKG_CONFIG variable to
+dnl first found in the path. Checks that the version of pkg-config found
+dnl is at least MIN-VERSION. If MIN-VERSION is not specified, 0.9.0 is
+dnl used since that's the first version where most current features of
+dnl pkg-config existed.
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])
+m4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])
+AC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])
+AC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+fi[]dnl
+])dnl PKG_PROG_PKG_CONFIG
+
+dnl PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+dnl -------------------------------------------------------------------
+dnl Since: 0.18
+dnl
+dnl Check to see whether a particular set of modules exists. Similar to
+dnl PKG_CHECK_MODULES(), but does not set variables or print errors.
+dnl
+dnl Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+dnl only at the first occurence in configure.ac, so if the first place
+dnl it's called might be skipped (such as if it is within an "if", you
+dnl have to call PKG_CHECK_EXISTS manually
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_default([$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+dnl _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+dnl ---------------------------------------------
+dnl Internal wrapper calling pkg-config via PKG_CONFIG and setting
+dnl pkg_failed based on the result.
+m4_define([_PKG_CONFIG],
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes ],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
+fi[]dnl
+])dnl _PKG_CONFIG
+
+dnl _PKG_SHORT_ERRORS_SUPPORTED
+dnl ---------------------------
+dnl Internal check to see if pkg-config supports short errors.
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])dnl _PKG_SHORT_ERRORS_SUPPORTED
+
+
+dnl PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+dnl   [ACTION-IF-NOT-FOUND])
+dnl --------------------------------------------------------------
+dnl Since: 0.4.0
+dnl
+dnl Note that if there is a possibility the first call to
+dnl PKG_CHECK_MODULES might not happen, you should be sure to include an
+dnl explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $1])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+   	AC_MSG_RESULT([no])
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
+        else 
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	m4_default([$4], [AC_MSG_ERROR(
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT])[]dnl
+        ])
+elif test $pkg_failed = untried; then
+     	AC_MSG_RESULT([no])
+	m4_default([$4], [AC_MSG_FAILURE(
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl
+        ])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	$3
+fi[]dnl
+])dnl PKG_CHECK_MODULES
+
+
+dnl PKG_CHECK_MODULES_STATIC(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+dnl   [ACTION-IF-NOT-FOUND])
+dnl ---------------------------------------------------------------------
+dnl Since: 0.29
+dnl
+dnl Checks for existence of MODULES and gathers its build flags with
+dnl static libraries enabled. Sets VARIABLE-PREFIX_CFLAGS from --cflags
+dnl and VARIABLE-PREFIX_LIBS from --libs.
+dnl
+dnl Note that if there is a possibility the first call to
+dnl PKG_CHECK_MODULES_STATIC might not happen, you should be sure to
+dnl include an explicit call to PKG_PROG_PKG_CONFIG in your
+dnl configure.ac.
+AC_DEFUN([PKG_CHECK_MODULES_STATIC],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+_save_PKG_CONFIG=$PKG_CONFIG
+PKG_CONFIG="$PKG_CONFIG --static"
+PKG_CHECK_MODULES($@)
+PKG_CONFIG=$_save_PKG_CONFIG[]dnl
+])dnl PKG_CHECK_MODULES_STATIC
+
+
+dnl PKG_INSTALLDIR([DIRECTORY])
+dnl -------------------------
+dnl Since: 0.27
+dnl
+dnl Substitutes the variable pkgconfigdir as the location where a module
+dnl should install pkg-config .pc files. By default the directory is
+dnl $libdir/pkgconfig, but the default can be changed by passing
+dnl DIRECTORY. The user can override through the --with-pkgconfigdir
+dnl parameter.
+AC_DEFUN([PKG_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${libdir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([pkgconfigdir],
+    [AS_HELP_STRING([--with-pkgconfigdir], pkg_description)],,
+    [with_pkgconfigdir=]pkg_default)
+AC_SUBST([pkgconfigdir], [$with_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+])dnl PKG_INSTALLDIR
+
+
+dnl PKG_NOARCH_INSTALLDIR([DIRECTORY])
+dnl --------------------------------
+dnl Since: 0.27
+dnl
+dnl Substitutes the variable noarch_pkgconfigdir as the location where a
+dnl module should install arch-independent pkg-config .pc files. By
+dnl default the directory is $datadir/pkgconfig, but the default can be
+dnl changed by passing DIRECTORY. The user can override through the
+dnl --with-noarch-pkgconfigdir parameter.
+AC_DEFUN([PKG_NOARCH_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${datadir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config arch-independent installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([noarch-pkgconfigdir],
+    [AS_HELP_STRING([--with-noarch-pkgconfigdir], pkg_description)],,
+    [with_noarch_pkgconfigdir=]pkg_default)
+AC_SUBST([noarch_pkgconfigdir], [$with_noarch_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+])dnl PKG_NOARCH_INSTALLDIR
+
+
+dnl PKG_CHECK_VAR(VARIABLE, MODULE, CONFIG-VARIABLE,
+dnl [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+dnl -------------------------------------------
+dnl Since: 0.28
+dnl
+dnl Retrieves the value of the pkg-config variable for the given module.
+AC_DEFUN([PKG_CHECK_VAR],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl
+
+_PKG_CONFIG([$1], [variable="][$3]["], [$2])
+AS_VAR_COPY([$1], [pkg_cv_][$1])
+
+AS_VAR_IF([$1], [""], [$5], [$4])dnl
+])dnl PKG_CHECK_VAR
+
 m4_include([../autoconf/ast_check_gnu_make.m4])
 m4_include([../autoconf/ast_ext_lib.m4])
 m4_include([../autoconf/ast_ext_tool_check.m4])
 m4_include([../autoconf/ast_gcc_attribute.m4])
+m4_include([../autoconf/ast_pkgconfig.m4])
 m4_include([../autoconf/ast_prog_sed.m4])
diff -urpN asterisk-13.9.1/menuselect/configure asterisk-13.17.0/menuselect/configure
--- asterisk-13.9.1/menuselect/configure	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/configure	2017-07-12 13:12:08.000000000 +0200
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.ac Revision: 418850 .
+# From configure.ac Revision.
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.69.
 #
@@ -628,7 +628,11 @@ LIBOBJS
 GTK2_LIB
 GTK2_INCLUDE
 PBX_GTK2
-PKGCONFIG
+GTK2_LIBS
+GTK2_CFLAGS
+PKG_CONFIG_LIBDIR
+PKG_CONFIG_PATH
+PKG_CONFIG
 CONFIG_LIBXML2
 SED
 PBX_LIBXML2
@@ -725,7 +729,12 @@ CFLAGS
 LDFLAGS
 LIBS
 CPPFLAGS
-CPP'
+CPP
+PKG_CONFIG
+PKG_CONFIG_PATH
+PKG_CONFIG_LIBDIR
+GTK2_CFLAGS
+GTK2_LIBS'
 
 
 # Initialize some variables set by options.
@@ -1356,6 +1365,13 @@ Some influential environment variables:
   CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
+  PKG_CONFIG  path to pkg-config utility
+  PKG_CONFIG_PATH
+              directories to add to pkg-config's search path
+  PKG_CONFIG_LIBDIR
+              path overriding pkg-config's built-in search path
+  GTK2_CFLAGS C compiler flags for GTK2, overriding pkg-config
+  GTK2_LIBS   linker flags for GTK2, overriding pkg-config
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -4752,26 +4768,35 @@ if test "${PBX_LIBXML2}" != 1; then
   as_fn_error $? "Could not find required 'Libxml2' development package" "$LINENO" 5
 fi
 
-PBX_GTK2=0
-if test -n "$ac_tool_prefix"; then
+
+
+
+
+
+
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
 set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_PKGCONFIG+:} false; then :
+if ${ac_cv_path_PKG_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$PKGCONFIG"; then
-  ac_cv_prog_PKGCONFIG="$PKGCONFIG" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+  case $PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_PKGCONFIG="${ac_tool_prefix}pkg-config"
+    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -4779,12 +4804,13 @@ done
   done
 IFS=$as_save_IFS
 
+  ;;
+esac
 fi
-fi
-PKGCONFIG=$ac_cv_prog_PKGCONFIG
-if test -n "$PKGCONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKGCONFIG" >&5
-$as_echo "$PKGCONFIG" >&6; }
+PKG_CONFIG=$ac_cv_path_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+$as_echo "$PKG_CONFIG" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
@@ -4792,26 +4818,28 @@ fi
 
 
 fi
-if test -z "$ac_cv_prog_PKGCONFIG"; then
-  ac_ct_PKGCONFIG=$PKGCONFIG
+if test -z "$ac_cv_path_PKG_CONFIG"; then
+  ac_pt_PKG_CONFIG=$PKG_CONFIG
   # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_PKGCONFIG+:} false; then :
+if ${ac_cv_path_ac_pt_PKG_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_PKGCONFIG"; then
-  ac_cv_prog_ac_ct_PKGCONFIG="$ac_ct_PKGCONFIG" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+  case $ac_pt_PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_ac_pt_PKG_CONFIG="$ac_pt_PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_PKGCONFIG="pkg-config"
+    ac_cv_path_ac_pt_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -4819,19 +4847,20 @@ done
   done
 IFS=$as_save_IFS
 
+  ;;
+esac
 fi
-fi
-ac_ct_PKGCONFIG=$ac_cv_prog_ac_ct_PKGCONFIG
-if test -n "$ac_ct_PKGCONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_PKGCONFIG" >&5
-$as_echo "$ac_ct_PKGCONFIG" >&6; }
+ac_pt_PKG_CONFIG=$ac_cv_path_ac_pt_PKG_CONFIG
+if test -n "$ac_pt_PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_pt_PKG_CONFIG" >&5
+$as_echo "$ac_pt_PKG_CONFIG" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_PKGCONFIG" = x; then
-    PKGCONFIG="No"
+  if test "x$ac_pt_PKG_CONFIG" = x; then
+    PKG_CONFIG=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -4839,20 +4868,114 @@ yes:)
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    PKGCONFIG=$ac_ct_PKGCONFIG
+    PKG_CONFIG=$ac_pt_PKG_CONFIG
   fi
 else
-  PKGCONFIG="$ac_cv_prog_PKGCONFIG"
+  PKG_CONFIG="$ac_cv_path_PKG_CONFIG"
 fi
 
-if test ! "x${PKGCONFIG}" = xNo; then
-   GTK2_INCLUDE=$(${PKGCONFIG} gtk+-2.0 --cflags 2>/dev/null)
-   GTK2_LIB=$(${PKGCONFIG} gtk+-2.0 --libs)
-   PBX_GTK2=1
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=0.9.0
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking pkg-config is at least version $_pkg_min_version" >&5
+$as_echo_n "checking pkg-config is at least version $_pkg_min_version... " >&6; }
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		PKG_CONFIG=""
+	fi
+fi
+
+   if test "x${PBX_GTK2}" != "x1" -a "${USE_GTK2}" != "no"; then
+
+pkg_failed=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GTK2" >&5
+$as_echo_n "checking for GTK2... " >&6; }
+
+if test -n "$GTK2_CFLAGS"; then
+    pkg_cv_GTK2_CFLAGS="$GTK2_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gtk+-2.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "gtk+-2.0") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_GTK2_CFLAGS=`$PKG_CONFIG --cflags "gtk+-2.0" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+if test -n "$GTK2_LIBS"; then
+    pkg_cv_GTK2_LIBS="$GTK2_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gtk+-2.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "gtk+-2.0") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_GTK2_LIBS=`$PKG_CONFIG --libs "gtk+-2.0" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+
+
+
+if test $pkg_failed = yes; then
+   	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi
+        if test $_pkg_short_errors_supported = yes; then
+	        GTK2_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "gtk+-2.0" 2>&1`
+        else
+	        GTK2_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "gtk+-2.0" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$GTK2_PKG_ERRORS" >&5
+
+
+            PBX_GTK2=0
+
+
+elif test $pkg_failed = untried; then
+     	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+            PBX_GTK2=0
+
+
+else
+	GTK2_CFLAGS=$pkg_cv_GTK2_CFLAGS
+	GTK2_LIBS=$pkg_cv_GTK2_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+            PBX_GTK2=1
+            GTK2_INCLUDE="$GTK2_CFLAGS"
+            GTK2_LIB="$GTK2_LIBS"
 
 $as_echo "#define HAVE_GTK2 1" >>confdefs.h
 
+
 fi
+   fi
+
 
 
 
diff -urpN asterisk-13.9.1/menuselect/configure.ac asterisk-13.17.0/menuselect/configure.ac
--- asterisk-13.9.1/menuselect/configure.ac	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/configure.ac	2017-07-12 13:12:08.000000000 +0200
@@ -134,14 +134,7 @@ if test "${PBX_LIBXML2}" != 1; then
   AC_MSG_ERROR([Could not find required 'Libxml2' development package])
 fi
 
-PBX_GTK2=0
-AC_CHECK_TOOL(PKGCONFIG, pkg-config, No)
-if test ! "x${PKGCONFIG}" = xNo; then
-   GTK2_INCLUDE=$(${PKGCONFIG} gtk+-2.0 --cflags 2>/dev/null)
-   GTK2_LIB=$(${PKGCONFIG} gtk+-2.0 --libs)   
-   PBX_GTK2=1
-   AC_DEFINE([HAVE_GTK2], 1, [Define if your system has the GTK2 libraries.])
-fi
+AST_PKG_CONFIG_CHECK([GTK2], [gtk+-2.0])
 AC_SUBST(PBX_GTK2)
 AC_SUBST(GTK2_INCLUDE)
 AC_SUBST(GTK2_LIB)
diff -urpN asterisk-13.9.1/menuselect/menuselect.c asterisk-13.17.0/menuselect/menuselect.c
--- asterisk-13.9.1/menuselect/menuselect.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/menuselect.c	2017-07-12 13:12:08.000000000 +0200
@@ -103,18 +103,6 @@ struct dep_file {
 };
 AST_LIST_HEAD_NOLOCK_STATIC(deps_file, dep_file);
 
-#if !defined(ast_strdupa) && defined(__GNUC__)
-#define ast_strdupa(s)                                                    \
-	(__extension__                                                    \
-	({                                                                \
-		const char *__old = (s);                                  \
-		size_t __len = strlen(__old) + 1;                         \
-		char *__new = __builtin_alloca(__len);                    \
-		memcpy (__new, __old, __len);                             \
-		__new;                                                    \
-	}))
-#endif
-
 /*! \brief return a pointer to the first non-whitespace character */
 static inline char *skip_blanks(char *str)
 {
@@ -246,6 +234,14 @@ static enum support_level_values string_
 		return SUPPORT_DEPRECATED;
 	}
 
+	if (!strcasecmp(support_level, "external")) {
+		return SUPPORT_EXTERNAL;
+	}
+
+	if (!strcasecmp(support_level, "option")) {
+		return SUPPORT_OPTION;
+	}
+
 	return SUPPORT_UNSPECIFIED;
 }
 
@@ -259,6 +255,10 @@ static const char *support_level_to_stri
 		return "Extended";
 	case SUPPORT_DEPRECATED:
 		return "Deprecated";
+	case SUPPORT_EXTERNAL:
+		return "External";
+	case SUPPORT_OPTION:
+		return "Module Options";
 	default:
 		return "Unspecified";
 	}
@@ -392,6 +392,11 @@ static int process_xml_use_node(xmlNode
 	return process_xml_ref_node(node, mem, &mem->uses);
 }
 
+static int process_xml_member_data_node(xmlNode *node, struct member *mem)
+{
+	return 0;
+}
+
 static int process_xml_unknown_node(xmlNode *node, struct member *mem)
 {
 	fprintf(stderr, "Encountered unknown node: %s\n", node->name);
@@ -410,6 +415,7 @@ static const struct {
 	{ "depend",         process_xml_depend_node         },
 	{ "conflict",       process_xml_conflict_node       },
 	{ "use",            process_xml_use_node            },
+	{ "member_data",    process_xml_member_data_node    },
 };
 
 static node_handler lookup_node_handler(xmlNode *node)
@@ -461,7 +467,7 @@ static int process_xml_member_node(xmlNo
 		process_process_xml_category_child_node(cur, mem);
 	}
 
-	if (!cat->positive_output) {
+	if (!cat->positive_output && strcasecmp(mem->support_level, "option")) {
 		mem->enabled = 1;
 		if (!mem->defaultenabled || strcasecmp(mem->defaultenabled, "no")) {
 			mem->was_enabled = 1;
diff -urpN asterisk-13.9.1/menuselect/menuselect.h asterisk-13.17.0/menuselect/menuselect.h
--- asterisk-13.9.1/menuselect/menuselect.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/menuselect.h	2017-07-12 13:12:08.000000000 +0200
@@ -70,6 +70,8 @@ struct member {
 	const char *touch_on_change;
 	const char *support_level;
 	const char *replacement;
+	/*! member_data is just an opaque, member-specific string */
+	const char *member_data;
 	/*! This module is currently selected */
 	unsigned int enabled:1;
 	/*! This module was enabled when the config was loaded */
@@ -105,7 +107,9 @@ enum support_level_values {
 	SUPPORT_EXTENDED = 1,
 	SUPPORT_DEPRECATED = 2,
 	SUPPORT_UNSPECIFIED = 3,
-	SUPPORT_COUNT = 4, /* Keep this item at the end of the list. Tracks total number of support levels. */
+	SUPPORT_EXTERNAL = 4,
+	SUPPORT_OPTION = 5,
+	SUPPORT_COUNT = 6, /* Keep this item at the end of the list. Tracks total number of support levels. */
 };
 
 AST_LIST_HEAD_NOLOCK(support_level_bucket, member);
@@ -161,4 +165,16 @@ static inline int strlen_zero(const char
 	return (!s || (*s == '\0'));
 }
 
+#if !defined(ast_strdupa) && defined(__GNUC__)
+#define ast_strdupa(s)                                                    \
+	(__extension__                                                    \
+	({                                                                \
+		const char *__old = (s);                                  \
+		size_t __len = strlen(__old) + 1;                         \
+		char *__new = __builtin_alloca(__len);                    \
+		memcpy (__new, __old, __len);                             \
+		__new;                                                    \
+	}))
+#endif
+
 #endif /* MENUSELECT_H */
diff -urpN asterisk-13.9.1/menuselect/menuselect_curses.c asterisk-13.17.0/menuselect/menuselect_curses.c
--- asterisk-13.9.1/menuselect/menuselect_curses.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/menuselect_curses.c	2017-07-12 13:12:08.000000000 +0200
@@ -194,46 +194,49 @@ static void display_mem_info(WINDOW *men
 	int start_x = (max_x / 2 - MEMBER_INFO_LEFT_ADJ);
 	int maxlen = (max_x - start_x);
 
-	wmove(menu, end - start_y + 1, start_x);
+	wmove(menu, end - start_y + 1, 0);
 	wclrtoeol(menu);
-	wmove(menu, end - start_y + 2, start_x);
+	wmove(menu, end - start_y + 2, 0);
 	wclrtoeol(menu);
-	wmove(menu, end - start_y + 3, start_x);
+	wmove(menu, end - start_y + 3, 0);
 	wclrtoeol(menu);
-	wmove(menu, end - start_y + 4, start_x);
+	wmove(menu, end - start_y + 4, 0);
 	wclrtoeol(menu);
-	wmove(menu, end - start_y + 5, start_x);
+	wmove(menu, end - start_y + 5, 0);
 	wclrtoeol(menu);
-	wmove(menu, end - start_y + 6, start_x);
+	wmove(menu, end - start_y + 6, 0);
+	wclrtoeol(menu);
+	wmove(menu, end - start_y + 7, 0);
 	wclrtoeol(menu);
 
 	if (mem->displayname) {
-		int name_len = strlen(mem->displayname);
+		char buf[maxlen + 1];
+		char *displayname = ast_strdupa(mem->displayname);
+		char *word;
+		int current_line = 1;
+		int new_line = 1;
 
+		buf[0] = '\0';
 		wmove(menu, end - start_y + 1, start_x);
-		if (name_len >  maxlen) {
-			char *last_space;
-			char *line_1 = strdup(mem->displayname);
-
-			if (line_1) {
-				line_1[maxlen] = '\0';
-				last_space = strrchr(line_1, ' ');
-				if (last_space) {
-					*last_space = '\0';
-				}
-				waddstr(menu, line_1);
-				wmove(menu, end - start_y + 2, start_x);
-				waddstr(menu, &mem->displayname[last_space - line_1]);
-				free(line_1);
-			} else {
-				waddstr(menu, (char *) mem->displayname);
+
+		while ((word = strsep(&displayname, " "))) {
+			if ((strlen(buf) + strlen(word) + 1) > maxlen) {
+				waddstr(menu, buf);
+				current_line++;
+				wmove(menu, end - start_y + current_line, start_x);
+				buf[0] = '\0';
+				new_line = 1;
 			}
-		} else {
-			waddstr(menu, (char *) mem->displayname);
+			sprintf(buf, "%s%*.*s%s", buf, new_line ? 0 : 1, new_line ? 0 : 1, " ", word);
+			new_line = 0;
+		}
+		if (strlen(buf)) {
+			waddstr(menu, buf);
 		}
 	}
+
 	if (!AST_LIST_EMPTY(&mem->deps)) {
-		wmove(menu, end - start_y + 3, start_x);
+		wmove(menu, end - start_y + 4, start_x);
 		strcpy(buf, "Depends on: ");
 		AST_LIST_TRAVERSE(&mem->deps, dep, list) {
 			strncat(buf, dep->displayname, sizeof(buf) - strlen(buf) - 1);
@@ -244,7 +247,7 @@ static void display_mem_info(WINDOW *men
 		waddstr(menu, buf);
 	}
 	if (!AST_LIST_EMPTY(&mem->uses)) {
-		wmove(menu, end - start_y + 4, start_x);
+		wmove(menu, end - start_y + 5, start_x);
 		strcpy(buf, "Can use: ");
 		AST_LIST_TRAVERSE(&mem->uses, use, list) {
 			strncat(buf, use->displayname, sizeof(buf) - strlen(buf) - 1);
@@ -255,7 +258,7 @@ static void display_mem_info(WINDOW *men
 		waddstr(menu, buf);
 	}
 	if (!AST_LIST_EMPTY(&mem->conflicts)) {
-		wmove(menu, end - start_y + 5, start_x);
+		wmove(menu, end - start_y + 6, start_x);
 		strcpy(buf, "Conflicts with: ");
 		AST_LIST_TRAVERSE(&mem->conflicts, con, list) {
 			strncat(buf, con->displayname, sizeof(buf) - strlen(buf) - 1);
@@ -268,7 +271,7 @@ static void display_mem_info(WINDOW *men
 
 	if (!mem->is_separator) { /* Separators lack support levels */
 		{ /* support level */
-			wmove(menu, end - start_y + 6, start_x);
+			wmove(menu, end - start_y + 7, start_x);
 			snprintf(buf, sizeof(buf), "Support Level: %s", mem->support_level);
 			if (mem->replacement && *mem->replacement) {
 				char buf2[64];
diff -urpN asterisk-13.9.1/menuselect/menuselect_gtk.c asterisk-13.17.0/menuselect/menuselect_gtk.c
--- asterisk-13.9.1/menuselect/menuselect_gtk.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/menuselect_gtk.c	2017-07-12 13:12:08.000000000 +0200
@@ -16,6 +16,8 @@ enum {
 	COLUMN_USES,
 	/*! Conflicts */
 	COLUMN_CNFS,
+	/*! Description */
+	COLUMN_DESC,
 	/*! Number of columns, must be the last element in the enum */
 	NUM_COLUMNS,
 };
@@ -254,7 +256,8 @@ int run_menu(void)
 		G_TYPE_BOOLEAN,  /* COLUMN_SELECTED */
 		G_TYPE_STRING,   /* COLUMN_DEPS */
 		G_TYPE_STRING,   /* COLUMN_USES */
-		G_TYPE_STRING);  /* COLUMN_CNFS */
+		G_TYPE_STRING,  /* COLUMN_CNFS */
+		G_TYPE_STRING);  /* COLUMN_DESC */
 
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		GtkTreeIter iter, iter2;
@@ -307,6 +310,7 @@ int run_menu(void)
 				COLUMN_DEPS, dep_buf,
 				COLUMN_USES, use_buf,
 				COLUMN_CNFS, cnf_buf,
+				COLUMN_DESC, mem->displayname,
 				-1);
 		}
 	}
@@ -344,6 +348,11 @@ int run_menu(void)
 				renderer, "text", COLUMN_CNFS, NULL);
 	gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);
 	
+	renderer = gtk_cell_renderer_text_new();
+	column = gtk_tree_view_column_new_with_attributes("Description",
+				renderer, "text", COLUMN_DESC, NULL);
+	gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);
+
 	g_signal_connect(tree, "row-activated", (GCallback) row_activated_handler, store);
 
 	gtk_container_add(GTK_CONTAINER(s_window), GTK_WIDGET(tree));
diff -urpN asterisk-13.9.1/menuselect/menuselect_newt.c asterisk-13.17.0/menuselect/menuselect_newt.c
--- asterisk-13.9.1/menuselect/menuselect_newt.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/menuselect/menuselect_newt.c	2017-07-12 13:12:08.000000000 +0200
@@ -326,7 +326,7 @@ int run_menu(void)
 	newtFormAddComponent(form, subOptions);
 	newtComponentAddCallback(subOptions, category_menu_callback, NULL);
 
-	memberNameTextbox       = newtTextbox(2, y - 13, x - 10, 1, 0);
+	memberNameTextbox       = newtTextbox(2, y - 13, x - 10, 2, NEWT_FLAG_WRAP);
 	dependsLabel            = newtLabel(2, y - 11, "    Depends on:");
 	usesLabel               = newtLabel(2, y - 10, "       Can use:");
 	conflictsLabel          = newtLabel(2, y - 9,  "Conflicts with:");
diff -urpN asterisk-13.9.1/pbx/Makefile asterisk-13.17.0/pbx/Makefile
--- asterisk-13.9.1/pbx/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/pbx/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -31,5 +31,5 @@ dundi-parser.o: _ASTCFLAGS+=-I.
 
 pbx_gtkconsole.o: _ASTCFLAGS+=-Wno-strict-prototypes
 
-$(if $(filter pbx_dundi,$(EMBEDDED_MODS)),modules.link,pbx_dundi.so): dundi-parser.o
+pbx_dundi.so: dundi-parser.o
 dundi-parser.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,pbx_dundi)
diff -urpN asterisk-13.9.1/pbx/pbx_dundi.c asterisk-13.17.0/pbx/pbx_dundi.c
--- asterisk-13.9.1/pbx/pbx_dundi.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/pbx/pbx_dundi.c	2017-07-12 13:12:08.000000000 +0200
@@ -994,9 +994,9 @@ static int dundi_prop_precache(struct du
 					sizeof(trans->parent->dr[trans->parent->respcount].tech));
 				trans->parent->respcount++;
 				ast_clear_flag_nonstd(trans->parent->hmd, DUNDI_HINT_DONT_ASK);
-			} else if (trans->parent->dr[z].weight > ies->answers[x]->weight) {
+			} else if (trans->parent->dr[z].weight > ntohs(ies->answers[x]->weight)) {
 				/* Update weight if appropriate */
-				trans->parent->dr[z].weight = ies->answers[x]->weight;
+				trans->parent->dr[z].weight = ntohs(ies->answers[x]->weight);
 			}
 		} else
 			ast_log(LOG_NOTICE, "Dropping excessive answers in precache for %s@%s\n",
@@ -1764,9 +1764,9 @@ static int handle_command_response(struc
 									sizeof(trans->parent->dr[trans->parent->respcount].tech));
 								trans->parent->respcount++;
 								ast_clear_flag_nonstd(trans->parent->hmd, DUNDI_HINT_DONT_ASK);
-							} else if (trans->parent->dr[z].weight > ies.answers[x]->weight) {
+							} else if (trans->parent->dr[z].weight > ntohs(ies.answers[x]->weight)) {
 								/* Update weight if appropriate */
-								trans->parent->dr[z].weight = ies.answers[x]->weight;
+								trans->parent->dr[z].weight = ntohs(ies.answers[x]->weight);
 							}
 						} else
 							ast_log(LOG_NOTICE, "Dropping excessive answers to request for %s@%s\n",
@@ -4847,6 +4847,9 @@ static int set_config(char *config_file,
 		ast_log(LOG_WARNING, "Unable to get host name!\n");
 	AST_LIST_LOCK(&peers);
 
+	if (ast_eid_is_empty(&ast_eid_default)) {
+		ast_log(LOG_WARNING, "Entity ID is not set.\n");
+	}
 	memcpy(&global_eid, &ast_eid_default, sizeof(global_eid));
 
 	global_storehistory = 0;
diff -urpN asterisk-13.9.1/pbx/pbx_realtime.c asterisk-13.17.0/pbx/pbx_realtime.c
--- asterisk-13.9.1/pbx/pbx_realtime.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/pbx/pbx_realtime.c	2017-07-12 13:12:08.000000000 +0200
@@ -143,6 +143,13 @@ static void *cleanup(void *unused)
 	return NULL;
 }
 
+static int extension_length_comparator(struct ast_category *p, struct ast_category *q)
+{
+	const char *extenp = S_OR(ast_variable_find(p, "exten"), "");
+	const char *extenq = S_OR(ast_variable_find(q, "exten"), "");
+
+	return strlen(extenp) - strlen(extenq);
+}
 
 /* Realtime switch looks up extensions in the supplied realtime table.
 
@@ -191,25 +198,29 @@ static struct ast_variable *realtime_swi
 	if (!var && !ast_test_flag(&flags, OPTION_PATTERNS_DISABLED)) {
 		cfg = ast_load_realtime_multientry(table, "exten LIKE", "\\_%", "context", context, "priority", pri, SENTINEL);	
 		if (cfg) {
-			char *cat = ast_category_browse(cfg, NULL);
+			char *cat = NULL;
+
+			/* Sort so that longer patterns are checked first */
+			ast_config_sort_categories(cfg, 1, extension_length_comparator);
+
+			while ((cat = ast_category_browse(cfg, cat))) {
+				const char *realtime_exten = ast_variable_retrieve(cfg, cat, "exten");
 
-			while(cat) {
 				switch(mode) {
 				case MODE_MATCHMORE:
-					match = ast_extension_close(cat, exten, 1);
+					match = ast_extension_close(realtime_exten, exten, 1);
 					break;
 				case MODE_CANMATCH:
-					match = ast_extension_close(cat, exten, 0);
+					match = ast_extension_close(realtime_exten, exten, 0);
 					break;
 				case MODE_MATCH:
 				default:
-					match = ast_extension_match(cat, exten);
+					match = ast_extension_match(realtime_exten, exten);
 				}
 				if (match) {
 					var = ast_category_detach_variables(ast_category_get(cfg, cat, NULL));
 					break;
 				}
-				cat = ast_category_browse(cfg, cat);
 			}
 			ast_config_destroy(cfg);
 		}
diff -urpN asterisk-13.9.1/pbx/pbx_spool.c asterisk-13.17.0/pbx/pbx_spool.c
--- asterisk-13.9.1/pbx/pbx_spool.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/pbx/pbx_spool.c	2017-07-12 13:12:08.000000000 +0200
@@ -163,139 +163,171 @@ static struct outgoing *new_outgoing(con
 	return o;
 }
 
-static int apply_outgoing(struct outgoing *o, FILE *f)
+static void parse_line(char *line, unsigned int lineno, struct outgoing *o)
 {
-	char buf[256];
-	char *c, *c2;
-	int lineno = 0;
-	struct ast_variable *var, *last = o->vars;
+	char *c;
 
-	while (last && last->next) {
-		last = last->next;
+	/* Trim comments */
+	c = line;
+	while ((c = strchr(c, '#'))) {
+		if ((c == line) || (*(c-1) == ' ') || (*(c-1) == '\t')) {
+			*c = '\0';
+			break;
+		}
+		c++;
 	}
 
-	while(fgets(buf, sizeof(buf), f)) {
-		lineno++;
-		/* Trim comments */
-		c = buf;
-		while ((c = strchr(c, '#'))) {
-			if ((c == buf) || (*(c-1) == ' ') || (*(c-1) == '\t'))
-				*c = '\0';
-			else
-				c++;
-		}
-
-		c = buf;
-		while ((c = strchr(c, ';'))) {
-			if ((c > buf) && (c[-1] == '\\')) {
-				memmove(c - 1, c, strlen(c) + 1);
-				c++;
-			} else {
-				*c = '\0';
-				break;
-			}
+	c = line;
+	while ((c = strchr(c, ';'))) {
+		if ((c > line) && (c[-1] == '\\')) {
+			memmove(c - 1, c, strlen(c) + 1);
+		} else {
+			*c = '\0';
+			break;
 		}
+	}
 
-		/* Trim trailing white space */
-		ast_trim_blanks(buf);
-		if (ast_strlen_zero(buf)) {
-			continue;
-		}
-		c = strchr(buf, ':');
-		if (!c) {
-			ast_log(LOG_NOTICE, "Syntax error at line %d of %s\n", lineno, o->fn);
-			continue;
-		}
-		*c = '\0';
-		c = ast_skip_blanks(c + 1);
+	/* Trim trailing white space */
+	ast_trim_blanks(line);
+	if (ast_strlen_zero(line)) {
+		return;
+	}
+	c = strchr(line, ':');
+	if (!c) {
+		ast_log(LOG_NOTICE, "Syntax error at line %d of %s\n", lineno, o->fn);
+		return;
+	}
+	*c = '\0';
+	c = ast_skip_blanks(c + 1);
 #if 0
-		printf("'%s' is '%s' at line %d\n", buf, c, lineno);
+	printf("'%s' is '%s' at line %d\n", line, c, lineno);
 #endif
-		if (!strcasecmp(buf, "channel")) {
-			if ((c2 = strchr(c, '/'))) {
-				*c2 = '\0';
-				c2++;
-				ast_string_field_set(o, tech, c);
-				ast_string_field_set(o, dest, c2);
-			} else {
-				ast_log(LOG_NOTICE, "Channel should be in form Tech/Dest at line %d of %s\n", lineno, o->fn);
-			}
-		} else if (!strcasecmp(buf, "callerid")) {
-			char cid_name[80] = {0}, cid_num[80] = {0};
-			ast_callerid_split(c, cid_name, sizeof(cid_name), cid_num, sizeof(cid_num));
-			ast_string_field_set(o, cid_num, cid_num);
-			ast_string_field_set(o, cid_name, cid_name);
-		} else if (!strcasecmp(buf, "application")) {
-			ast_string_field_set(o, app, c);
-		} else if (!strcasecmp(buf, "data")) {
-			ast_string_field_set(o, data, c);
-		} else if (!strcasecmp(buf, "maxretries")) {
-			if (sscanf(c, "%30d", &o->maxretries) != 1) {
-				ast_log(LOG_WARNING, "Invalid max retries at line %d of %s\n", lineno, o->fn);
-				o->maxretries = 0;
-			}
-		} else if (!strcasecmp(buf, "codecs")) {
-			ast_format_cap_update_by_allow_disallow(o->capabilities, c, 1);
-		} else if (!strcasecmp(buf, "context")) {
-			ast_string_field_set(o, context, c);
-		} else if (!strcasecmp(buf, "extension")) {
-			ast_string_field_set(o, exten, c);
-		} else if (!strcasecmp(buf, "priority")) {
-			if ((sscanf(c, "%30d", &o->priority) != 1) || (o->priority < 1)) {
-				ast_log(LOG_WARNING, "Invalid priority at line %d of %s\n", lineno, o->fn);
-				o->priority = 1;
-			}
-		} else if (!strcasecmp(buf, "retrytime")) {
-			if ((sscanf(c, "%30d", &o->retrytime) != 1) || (o->retrytime < 1)) {
-				ast_log(LOG_WARNING, "Invalid retrytime at line %d of %s\n", lineno, o->fn);
-				o->retrytime = 300;
-			}
-		} else if (!strcasecmp(buf, "waittime")) {
-			if ((sscanf(c, "%30d", &o->waittime) != 1) || (o->waittime < 1)) {
-				ast_log(LOG_WARNING, "Invalid waittime at line %d of %s\n", lineno, o->fn);
-				o->waittime = 45;
-			}
-		} else if (!strcasecmp(buf, "retry")) {
-			o->retries++;
-		} else if (!strcasecmp(buf, "startretry")) {
-			if (sscanf(c, "%30ld", &o->callingpid) != 1) {
-				ast_log(LOG_WARNING, "Unable to retrieve calling PID!\n");
-				o->callingpid = 0;
-			}
-		} else if (!strcasecmp(buf, "endretry") || !strcasecmp(buf, "abortretry")) {
+	if (!strcasecmp(line, "channel")) {
+		char *c2;
+		if ((c2 = strchr(c, '/'))) {
+			*c2 = '\0';
+			c2++;
+			ast_string_field_set(o, tech, c);
+			ast_string_field_set(o, dest, c2);
+		} else {
+			ast_log(LOG_NOTICE, "Channel should be in form Tech/Dest at line %d of %s\n", lineno, o->fn);
+		}
+	} else if (!strcasecmp(line, "callerid")) {
+		char cid_name[80] = {0}, cid_num[80] = {0};
+		ast_callerid_split(c, cid_name, sizeof(cid_name), cid_num, sizeof(cid_num));
+		ast_string_field_set(o, cid_num, cid_num);
+		ast_string_field_set(o, cid_name, cid_name);
+	} else if (!strcasecmp(line, "application")) {
+		ast_string_field_set(o, app, c);
+	} else if (!strcasecmp(line, "data")) {
+		ast_string_field_set(o, data, c);
+	} else if (!strcasecmp(line, "maxretries")) {
+		if (sscanf(c, "%30d", &o->maxretries) != 1) {
+			ast_log(LOG_WARNING, "Invalid max retries at line %d of %s\n", lineno, o->fn);
+			o->maxretries = 0;
+		}
+	} else if (!strcasecmp(line, "codecs")) {
+		ast_format_cap_update_by_allow_disallow(o->capabilities, c, 1);
+	} else if (!strcasecmp(line, "context")) {
+		ast_string_field_set(o, context, c);
+	} else if (!strcasecmp(line, "extension")) {
+		ast_string_field_set(o, exten, c);
+	} else if (!strcasecmp(line, "priority")) {
+		if ((sscanf(c, "%30d", &o->priority) != 1) || (o->priority < 1)) {
+			ast_log(LOG_WARNING, "Invalid priority at line %d of %s\n", lineno, o->fn);
+			o->priority = 1;
+		}
+	} else if (!strcasecmp(line, "retrytime")) {
+		if ((sscanf(c, "%30d", &o->retrytime) != 1) || (o->retrytime < 1)) {
+			ast_log(LOG_WARNING, "Invalid retrytime at line %d of %s\n", lineno, o->fn);
+			o->retrytime = 300;
+		}
+	} else if (!strcasecmp(line, "waittime")) {
+		if ((sscanf(c, "%30d", &o->waittime) != 1) || (o->waittime < 1)) {
+			ast_log(LOG_WARNING, "Invalid waittime at line %d of %s\n", lineno, o->fn);
+			o->waittime = 45;
+		}
+	} else if (!strcasecmp(line, "retry")) {
+		o->retries++;
+	} else if (!strcasecmp(line, "startretry")) {
+		if (sscanf(c, "%30ld", &o->callingpid) != 1) {
+			ast_log(LOG_WARNING, "Unable to retrieve calling PID!\n");
 			o->callingpid = 0;
-			o->retries++;
-		} else if (!strcasecmp(buf, "delayedretry")) {
-		} else if (!strcasecmp(buf, "setvar") || !strcasecmp(buf, "set")) {
-			c2 = c;
-			strsep(&c2, "=");
-			if (c2) {
-				var = ast_variable_new(c, c2, o->fn);
-				if (var) {
-					/* Always insert at the end, because some people want to treat the spool file as a script */
-					if (last) {
-						last->next = var;
-					} else {
-						o->vars = var;
-					}
-					last = var;
+		}
+	} else if (!strcasecmp(line, "endretry") || !strcasecmp(line, "abortretry")) {
+		o->callingpid = 0;
+		o->retries++;
+	} else if (!strcasecmp(line, "delayedretry")) {
+	} else if (!strcasecmp(line, "setvar") || !strcasecmp(line, "set")) {
+		char *c2 = c;
+
+		strsep(&c2, "=");
+		if (c2) {
+			struct ast_variable *var = ast_variable_new(c, c2, o->fn);
+
+			if (var) {
+				/*
+				 * Always insert at the end, because some people
+				 * want to treat the spool file as a script
+				 */
+				struct ast_variable **tail = &o->vars;
+
+				while (*tail) {
+					tail = &(*tail)->next;
 				}
-			} else
-				ast_log(LOG_WARNING, "Malformed \"%s\" argument.  Should be \"%s: variable=value\"\n", buf, buf);
-		} else if (!strcasecmp(buf, "account")) {
-			ast_string_field_set(o, account, c);
-		} else if (!strcasecmp(buf, "alwaysdelete")) {
-			ast_set2_flag(&o->options, ast_true(c), SPOOL_FLAG_ALWAYS_DELETE);
-		} else if (!strcasecmp(buf, "archive")) {
-			ast_set2_flag(&o->options, ast_true(c), SPOOL_FLAG_ARCHIVE);
-		} else if (!strcasecmp(buf, "early_media")) {
-			ast_set2_flag(&o->options, ast_true(c), SPOOL_FLAG_EARLY_MEDIA);
+				*tail = var;
+			}
 		} else {
-			ast_log(LOG_WARNING, "Unknown keyword '%s' at line %d of %s\n", buf, lineno, o->fn);
+			ast_log(LOG_WARNING, "Malformed \"%s\" argument.  Should be \"%s: variable=value\"\n", line, line);
+		}
+	} else if (!strcasecmp(line, "account")) {
+		ast_string_field_set(o, account, c);
+	} else if (!strcasecmp(line, "alwaysdelete")) {
+		ast_set2_flag(&o->options, ast_true(c), SPOOL_FLAG_ALWAYS_DELETE);
+	} else if (!strcasecmp(line, "archive")) {
+		ast_set2_flag(&o->options, ast_true(c), SPOOL_FLAG_ARCHIVE);
+	} else if (!strcasecmp(line, "early_media")) {
+		ast_set2_flag(&o->options, ast_true(c), SPOOL_FLAG_EARLY_MEDIA);
+	} else {
+		ast_log(LOG_WARNING, "Unknown keyword '%s' at line %d of %s\n", line, lineno, o->fn);
+	}
+}
+
+#define LINE_BUFFER_SIZE 1024
+
+static int apply_outgoing(struct outgoing *o, FILE *f)
+{
+	char buf[LINE_BUFFER_SIZE];
+	unsigned int lineno = 0;
+
+	while (fgets(buf, sizeof(buf), f)) {
+		size_t len = strlen(buf);
+
+		lineno++;
+
+		if (buf[len - 1] == '\n' || feof(f)) {
+			/* We have a line, parse it */
+			parse_line(buf, lineno, o);
+			continue;
+		}
+
+		/* Crazy long line, skip it */
+		ast_log(LOG_WARNING, "Skipping extremely long line at line %d of %s\n", lineno, o->fn);
+
+		/* Consume the rest of the problematic line */
+		while (fgets(buf, sizeof(buf), f)) {
+			len = strlen(buf);
+			if (buf[len - 1] == '\n' || feof(f)) {
+				break;
+			}
 		}
 	}
-	if (ast_strlen_zero(o->tech) || ast_strlen_zero(o->dest) || (ast_strlen_zero(o->app) && ast_strlen_zero(o->exten))) {
-		ast_log(LOG_WARNING, "At least one of app or extension must be specified, along with tech and dest in file %s\n", o->fn);
+
+	if (ast_strlen_zero(o->tech)
+		|| ast_strlen_zero(o->dest)
+		|| (ast_strlen_zero(o->app) && ast_strlen_zero(o->exten))) {
+		ast_log(LOG_WARNING, "At least one of app or extension must be specified, "
+			"along with tech and dest in file %s\n", o->fn);
 		return -1;
 	}
 	return 0;
@@ -399,15 +431,17 @@ static void *attempt_thread(void *data)
 	int res, reason;
 	if (!ast_strlen_zero(o->app)) {
 		ast_verb(3, "Attempting call on %s/%s for application %s(%s) (Retry %d)\n", o->tech, o->dest, o->app, o->data, o->retries);
-		res = ast_pbx_outgoing_app(o->tech, o->capabilities, o->dest, o->waittime * 1000,
-			o->app, o->data, &reason, 2 /* wait to finish */, o->cid_num, o->cid_name,
+		res = ast_pbx_outgoing_app(o->tech, o->capabilities, o->dest,
+			o->waittime * 1000, o->app, o->data, &reason,
+			AST_OUTGOING_WAIT_COMPLETE, o->cid_num, o->cid_name,
 			o->vars, o->account, NULL, NULL);
 	} else {
 		ast_verb(3, "Attempting call on %s/%s for %s@%s:%d (Retry %d)\n", o->tech, o->dest, o->exten, o->context,o->priority, o->retries);
 		res = ast_pbx_outgoing_exten(o->tech, o->capabilities, o->dest,
 			o->waittime * 1000, o->context, o->exten, o->priority, &reason,
-			2 /* wait to finish */, o->cid_num, o->cid_name, o->vars, o->account, NULL,
-			ast_test_flag(&o->options, SPOOL_FLAG_EARLY_MEDIA), NULL);
+			AST_OUTGOING_WAIT_COMPLETE, o->cid_num, o->cid_name,
+			o->vars, o->account, NULL, ast_test_flag(&o->options, SPOOL_FLAG_EARLY_MEDIA),
+			NULL);
 	}
 	if (res) {
 		ast_log(LOG_NOTICE, "Call failed to go through, reason (%d) %s\n", reason, ast_channel_reason2str(reason));
diff -urpN asterisk-13.9.1/res/Makefile asterisk-13.17.0/res/Makefile
--- asterisk-13.9.1/res/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -37,19 +37,19 @@ ael/ael.tab.o: _ASTCFLAGS+=-I. -Iael -DY
 		_ASTCFLAGS+=-Wno-parentheses-equality
 	endif
 
-$(if $(filter res_ais,$(EMBEDDED_MODS)),modules.link,res_ais.so): ais/clm.o ais/evt.o
+res_ais.so: ais/clm.o ais/evt.o
 ais/clm.o ais/evt.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,res_ais)
 
-$(if $(filter res_snmp,$(EMBEDDED_MODS)),modules.link,res_snmp.so): snmp/agent.o
+res_snmp.so: snmp/agent.o
 snmp/agent.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,res_snmp)
 
-$(if $(filter res_ael_share,$(EMBEDDED_MODS)),modules.link,res_ael_share.so): ael/ael_lex.o ael/ael.tab.o ael/pval.o
+res_ael_share.so: ael/ael_lex.o ael/ael.tab.o ael/pval.o
 ael/ael_lex.o ael/ael.tab.o ael/pval.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,res_ael_share)
 
-$(if $(filter res_pjsip,$(EMBEDDED_MODS)),modules.link,res_pjsip.so): $(subst .c,.o,$(wildcard res_pjsip/*.c))
+res_pjsip.so: $(subst .c,.o,$(wildcard res_pjsip/*.c))
 $(subst .c,.o,$(wildcard res_pjsip/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,res_pjsip)
 
-$(if $(filter res_stasis,$(EMBEDDED_MODS)),modules.link,res_stasis.so): $(subst .c,.o,$(wildcard stasis/*.c))
+res_stasis.so: $(subst .c,.o,$(wildcard stasis/*.c))
 $(subst .c,.o,$(wildcard stasis/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,res_stasis)
 
 ifneq ($(findstring REBUILD_PARSERS,$(MENUSELECT_CFLAGS)),)
@@ -83,7 +83,7 @@ clean::
 	rm -f stasis_recording/*.[oi] stasis_recording/*.gcda stasis_recording/*.gcno
 	rm -f ari/*.[oi] ari/*.gcda ari/*.gcno
 
-$(if $(filter res_parking,$(EMBEDDED_MODS)),modules.link,res_parking.so): $(subst .c,.o,$(wildcard parking/*.c))
+res_parking.so: $(subst .c,.o,$(wildcard parking/*.c))
 $(subst .c,.o,$(wildcard parking/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,res_parking)
 
 res_ari.so: ari/cli.o ari/config.o ari/ari_websockets.o
diff -urpN asterisk-13.9.1/res/ael/pval.c asterisk-13.17.0/res/ael/pval.c
--- asterisk-13.9.1/res/ael/pval.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ael/pval.c	2017-07-12 13:12:08.000000000 +0200
@@ -3355,9 +3355,9 @@ static int gen_prios(struct ael_extensio
 #ifdef OLD_RAND_ACTION
 	struct ael_priority *rand_test, *rand_end, *rand_skip;
 #endif
-	char *buf1;
-	char *buf2;
-	char *new_label;
+	RAII_VAR(char *, buf1, NULL, free);
+	RAII_VAR(char *, buf2, NULL, free);
+	RAII_VAR(char *, new_label, NULL, free);
 	char *strp, *strp2;
 	int default_exists;
 	int local_control_statement_count;
@@ -4191,9 +4191,6 @@ static int gen_prios(struct ael_extensio
 			break;
 		}
 	}
-	free(buf1);
-	free(buf2);
-	free(new_label);
 	return 0;
 }
 
@@ -5052,7 +5049,10 @@ int  pvalCheckType( pval *p, char *funcn
 pval *pvalCreateNode( pvaltype type )
 {
 	pval *p = calloc(1,sizeof(pval)); /* why, oh why, don't I use ast_calloc? Way, way, way too messy if I do! */
-	p->type = type;                   /* remember, this can be used externally or internally to asterisk */
+					  /* remember, this can be used externally or internally to asterisk */
+	if (p) {
+		p->type = type;
+	}
 	return p;
 }
 
@@ -5413,14 +5413,30 @@ void pvalIncludesAddInclude( pval *p, co
 
 void pvalIncludesAddIncludeWithTimeConstraints( pval *p, const char *include, char *hour_range, char *dom_range, char *dow_range, char *month_range )
 {
-	pval *hr = pvalCreateNode(PV_WORD);
-	pval *dom = pvalCreateNode(PV_WORD);
-	pval *dow = pvalCreateNode(PV_WORD);
-	pval *mon = pvalCreateNode(PV_WORD);
-	pval *s = pvalCreateNode(PV_WORD);
-	
-	if (!pvalCheckType(p, "pvalIncludeAddIncludeWithTimeConstraints", PV_INCLUDES))
+	pval *hr;
+	pval *dom;
+	pval *dow;
+	pval *mon;
+	pval *s;
+
+	if (!pvalCheckType(p, "pvalIncludeAddIncludeWithTimeConstraints", PV_INCLUDES)) {
 		return;
+	}
+
+	hr = pvalCreateNode(PV_WORD);
+	dom = pvalCreateNode(PV_WORD);
+	dow = pvalCreateNode(PV_WORD);
+	mon = pvalCreateNode(PV_WORD);
+	s = pvalCreateNode(PV_WORD);
+
+	if (!hr || !dom || !dow || !mon || !s) {
+		destroy_pval(hr);
+		destroy_pval(dom);
+		destroy_pval(dow);
+		destroy_pval(mon);
+		destroy_pval(s);
+		return;
+	}
 
 	s->u1.str = (char *)include;
 	p->u1.list = linku1(p->u1.list, s);
@@ -5667,12 +5683,28 @@ char* pvalIfGetCondition( pval *p )
 
 void pvalIfTimeSetCondition( pval *p, char *hour_range, char *dow_range, char *dom_range, char *mon_range )  /* time range format: 24-hour format begin-end|dow range|dom range|month range */
 {
-	pval *hr = pvalCreateNode(PV_WORD);
-	pval *dow = pvalCreateNode(PV_WORD);
-	pval *dom = pvalCreateNode(PV_WORD);
-	pval *mon = pvalCreateNode(PV_WORD);
-	if (!pvalCheckType(p, "pvalIfTimeSetCondition", PV_IFTIME))
+	pval *hr;
+	pval *dow;
+	pval *dom;
+	pval *mon;
+
+	if (!pvalCheckType(p, "pvalIfTimeSetCondition", PV_IFTIME)) {
+		return;
+	}
+
+	hr = pvalCreateNode(PV_WORD);
+	dow = pvalCreateNode(PV_WORD);
+	dom = pvalCreateNode(PV_WORD);
+	mon = pvalCreateNode(PV_WORD);
+
+	if (!hr || !dom || !dow || !mon) {
+		destroy_pval(hr);
+		destroy_pval(dom);
+		destroy_pval(dow);
+		destroy_pval(mon);
 		return;
+	}
+
 	pvalWordSetString(hr, hour_range);
 	pvalWordSetString(dow, dow_range);
 	pvalWordSetString(dom, dom_range);
diff -urpN asterisk-13.9.1/res/ari/ari_model_validators.c asterisk-13.17.0/res/ari/ari_model_validators.c
--- asterisk-13.9.1/res/ari/ari_model_validators.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/ari_model_validators.c	2017-07-12 13:12:08.000000000 +0200
@@ -1360,6 +1360,24 @@ int ast_ari_validate_bridge(struct ast_j
 				res = 0;
 			}
 		} else
+		if (strcmp("video_mode", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI Bridge field video_mode failed validation\n");
+				res = 0;
+			}
+		} else
+		if (strcmp("video_source_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI Bridge field video_source_id failed validation\n");
+				res = 0;
+			}
+		} else
 		{
 			ast_log(LOG_ERROR,
 				"ARI Bridge has undocumented field %s\n",
@@ -1932,6 +1950,15 @@ int ast_ari_validate_application_replace
 	int has_application = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ApplicationReplaced field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2000,6 +2027,15 @@ int ast_ari_validate_bridge_attended_tra
 	int has_transferer_second_leg = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeAttendedTransfer field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2242,6 +2278,15 @@ int ast_ari_validate_bridge_blind_transf
 	int has_result = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeBlindTransfer field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2408,6 +2453,15 @@ int ast_ari_validate_bridge_created(stru
 	int has_bridge = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeCreated field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2487,6 +2541,15 @@ int ast_ari_validate_bridge_destroyed(st
 	int has_bridge = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeDestroyed field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2567,6 +2630,15 @@ int ast_ari_validate_bridge_merged(struc
 	int has_bridge_from = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeMerged field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2652,6 +2724,103 @@ ari_validator ast_ari_validate_bridge_me
 	return ast_ari_validate_bridge_merged;
 }
 
+int ast_ari_validate_bridge_video_source_changed(struct ast_json *json)
+{
+	int res = 1;
+	struct ast_json_iter *iter;
+	int has_type = 0;
+	int has_application = 0;
+	int has_bridge = 0;
+
+	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
+		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			has_type = 1;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged field type failed validation\n");
+				res = 0;
+			}
+		} else
+		if (strcmp("application", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			has_application = 1;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged field application failed validation\n");
+				res = 0;
+			}
+		} else
+		if (strcmp("timestamp", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_date(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged field timestamp failed validation\n");
+				res = 0;
+			}
+		} else
+		if (strcmp("bridge", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			has_bridge = 1;
+			prop_is_valid = ast_ari_validate_bridge(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged field bridge failed validation\n");
+				res = 0;
+			}
+		} else
+		if (strcmp("old_video_source_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged field old_video_source_id failed validation\n");
+				res = 0;
+			}
+		} else
+		{
+			ast_log(LOG_ERROR,
+				"ARI BridgeVideoSourceChanged has undocumented field %s\n",
+				ast_json_object_iter_key(iter));
+			res = 0;
+		}
+	}
+
+	if (!has_type) {
+		ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged missing required field type\n");
+		res = 0;
+	}
+
+	if (!has_application) {
+		ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged missing required field application\n");
+		res = 0;
+	}
+
+	if (!has_bridge) {
+		ast_log(LOG_ERROR, "ARI BridgeVideoSourceChanged missing required field bridge\n");
+		res = 0;
+	}
+
+	return res;
+}
+
+ari_validator ast_ari_validate_bridge_video_source_changed_fn(void)
+{
+	return ast_ari_validate_bridge_video_source_changed;
+}
+
 int ast_ari_validate_channel_caller_id(struct ast_json *json)
 {
 	int res = 1;
@@ -2663,6 +2832,15 @@ int ast_ari_validate_channel_caller_id(s
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelCallerId field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2772,6 +2950,15 @@ int ast_ari_validate_channel_connected_l
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelConnectedLine field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2851,6 +3038,15 @@ int ast_ari_validate_channel_created(str
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelCreated field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -2932,6 +3128,15 @@ int ast_ari_validate_channel_destroyed(s
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelDestroyed field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3043,6 +3248,15 @@ int ast_ari_validate_channel_dialplan(st
 	int has_dialplan_app_data = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelDialplan field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3154,6 +3368,15 @@ int ast_ari_validate_channel_dtmf_receiv
 	int has_duration_ms = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelDtmfReceived field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3263,6 +3486,15 @@ int ast_ari_validate_channel_entered_bri
 	int has_bridge = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelEnteredBridge field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3351,6 +3583,15 @@ int ast_ari_validate_channel_hangup_requ
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelHangupRequest field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3448,6 +3689,15 @@ int ast_ari_validate_channel_hold(struct
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelHold field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3537,6 +3787,15 @@ int ast_ari_validate_channel_left_bridge
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelLeftBridge field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3631,6 +3890,15 @@ int ast_ari_validate_channel_state_chang
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelStateChange field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3711,6 +3979,15 @@ int ast_ari_validate_channel_talking_fin
 	int has_duration = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelTalkingFinished field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3805,6 +4082,15 @@ int ast_ari_validate_channel_talking_sta
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelTalkingStarted field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3884,6 +4170,15 @@ int ast_ari_validate_channel_unhold(stru
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelUnhold field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -3964,6 +4259,15 @@ int ast_ari_validate_channel_userevent(s
 	int has_userevent = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelUserevent field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4086,6 +4390,15 @@ int ast_ari_validate_channel_varset(stru
 	int has_variable = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ChannelVarset field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4269,6 +4582,15 @@ int ast_ari_validate_contact_status_chan
 	int has_endpoint = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI ContactStatusChange field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4363,6 +4685,15 @@ int ast_ari_validate_device_state_change
 	int has_device_state = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI DeviceStateChanged field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4443,6 +4774,15 @@ int ast_ari_validate_dial(struct ast_jso
 	int has_peer = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI Dial field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4573,6 +4913,15 @@ int ast_ari_validate_endpoint_state_chan
 	int has_endpoint = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI EndpointStateChange field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4678,6 +5027,9 @@ int ast_ari_validate_event(struct ast_js
 	if (strcmp("BridgeMerged", discriminator) == 0) {
 		return ast_ari_validate_bridge_merged(json);
 	} else
+	if (strcmp("BridgeVideoSourceChanged", discriminator) == 0) {
+		return ast_ari_validate_bridge_video_source_changed(json);
+	} else
 	if (strcmp("ChannelCallerId", discriminator) == 0) {
 		return ast_ari_validate_channel_caller_id(json);
 	} else
@@ -4772,6 +5124,15 @@ int ast_ari_validate_event(struct ast_js
 	}
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI Event field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -4861,6 +5222,9 @@ int ast_ari_validate_message(struct ast_
 	if (strcmp("BridgeMerged", discriminator) == 0) {
 		return ast_ari_validate_bridge_merged(json);
 	} else
+	if (strcmp("BridgeVideoSourceChanged", discriminator) == 0) {
+		return ast_ari_validate_bridge_video_source_changed(json);
+	} else
 	if (strcmp("ChannelCallerId", discriminator) == 0) {
 		return ast_ari_validate_channel_caller_id(json);
 	} else
@@ -4961,6 +5325,15 @@ int ast_ari_validate_message(struct ast_
 	}
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI Message field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5000,6 +5373,15 @@ int ast_ari_validate_missing_params(stru
 	int has_params = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI MissingParams field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5131,6 +5513,15 @@ int ast_ari_validate_peer_status_change(
 	int has_peer = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI PeerStatusChange field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5225,6 +5616,15 @@ int ast_ari_validate_playback_finished(s
 	int has_playback = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI PlaybackFinished field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5304,6 +5704,15 @@ int ast_ari_validate_playback_started(st
 	int has_playback = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI PlaybackStarted field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5383,6 +5792,15 @@ int ast_ari_validate_recording_failed(st
 	int has_recording = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI RecordingFailed field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5462,6 +5880,15 @@ int ast_ari_validate_recording_finished(
 	int has_recording = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI RecordingFinished field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5541,6 +5968,15 @@ int ast_ari_validate_recording_started(s
 	int has_recording = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI RecordingStarted field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5620,6 +6056,15 @@ int ast_ari_validate_stasis_end(struct a
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI StasisEnd field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5700,6 +6145,15 @@ int ast_ari_validate_stasis_start(struct
 	int has_channel = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI StasisStart field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
@@ -5804,6 +6258,15 @@ int ast_ari_validate_text_message_receiv
 	int has_message = 0;
 
 	for (iter = ast_json_object_iter(json); iter; iter = ast_json_object_iter_next(json, iter)) {
+		if (strcmp("asterisk_id", ast_json_object_iter_key(iter)) == 0) {
+			int prop_is_valid;
+			prop_is_valid = ast_ari_validate_string(
+				ast_json_object_iter_value(iter));
+			if (!prop_is_valid) {
+				ast_log(LOG_ERROR, "ARI TextMessageReceived field asterisk_id failed validation\n");
+				res = 0;
+			}
+		} else
 		if (strcmp("type", ast_json_object_iter_key(iter)) == 0) {
 			int prop_is_valid;
 			has_type = 1;
diff -urpN asterisk-13.9.1/res/ari/ari_model_validators.h asterisk-13.17.0/res/ari/ari_model_validators.h
--- asterisk-13.9.1/res/ari/ari_model_validators.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/ari_model_validators.h	2017-07-12 13:12:08.000000000 +0200
@@ -717,6 +717,24 @@ int ast_ari_validate_bridge_merged(struc
 ari_validator ast_ari_validate_bridge_merged_fn(void);
 
 /*!
+ * \brief Validator for BridgeVideoSourceChanged.
+ *
+ * Notification that the source of video in a bridge has changed.
+ *
+ * \param json JSON object to validate.
+ * \returns True (non-zero) if valid.
+ * \returns False (zero) if invalid.
+ */
+int ast_ari_validate_bridge_video_source_changed(struct ast_json *json);
+
+/*!
+ * \brief Function pointer to ast_ari_validate_bridge_video_source_changed().
+ *
+ * See \ref ast_ari_model_validators.h for more details.
+ */
+ari_validator ast_ari_validate_bridge_video_source_changed_fn(void);
+
+/*!
  * \brief Validator for ChannelCallerId.
  *
  * Channel changed Caller ID.
@@ -1434,6 +1452,8 @@ ari_validator ast_ari_validate_applicati
  * - id: string (required)
  * - name: string (required)
  * - technology: string (required)
+ * - video_mode: string
+ * - video_source_id: string
  * LiveRecording
  * - cause: string
  * - duration: int
@@ -1467,10 +1487,12 @@ ari_validator ast_ari_validate_applicati
  * - new_messages: int (required)
  * - old_messages: int (required)
  * ApplicationReplaced
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * BridgeAttendedTransfer
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1491,6 +1513,7 @@ ari_validator ast_ari_validate_applicati
  * - transferer_second_leg: Channel (required)
  * - transferer_second_leg_bridge: Bridge
  * BridgeBlindTransfer
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1503,22 +1526,33 @@ ari_validator ast_ari_validate_applicati
  * - result: string (required)
  * - transferee: Channel
  * BridgeCreated
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - bridge: Bridge (required)
  * BridgeDestroyed
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - bridge: Bridge (required)
  * BridgeMerged
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - bridge: Bridge (required)
  * - bridge_from: Bridge (required)
+ * BridgeVideoSourceChanged
+ * - asterisk_id: string
+ * - type: string (required)
+ * - application: string (required)
+ * - timestamp: Date
+ * - bridge: Bridge (required)
+ * - old_video_source_id: string
  * ChannelCallerId
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1526,16 +1560,19 @@ ari_validator ast_ari_validate_applicati
  * - caller_presentation_txt: string (required)
  * - channel: Channel (required)
  * ChannelConnectedLine
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * ChannelCreated
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * ChannelDestroyed
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1543,6 +1580,7 @@ ari_validator ast_ari_validate_applicati
  * - cause_txt: string (required)
  * - channel: Channel (required)
  * ChannelDialplan
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1550,6 +1588,7 @@ ari_validator ast_ari_validate_applicati
  * - dialplan_app: string (required)
  * - dialplan_app_data: string (required)
  * ChannelDtmfReceived
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1557,12 +1596,14 @@ ari_validator ast_ari_validate_applicati
  * - digit: string (required)
  * - duration_ms: int (required)
  * ChannelEnteredBridge
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - bridge: Bridge (required)
  * - channel: Channel
  * ChannelHangupRequest
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1570,39 +1611,46 @@ ari_validator ast_ari_validate_applicati
  * - channel: Channel (required)
  * - soft: boolean
  * ChannelHold
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * - musicclass: string
  * ChannelLeftBridge
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - bridge: Bridge (required)
  * - channel: Channel (required)
  * ChannelStateChange
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * ChannelTalkingFinished
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * - duration: int (required)
  * ChannelTalkingStarted
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * ChannelUnhold
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * ChannelUserevent
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1612,6 +1660,7 @@ ari_validator ast_ari_validate_applicati
  * - eventname: string (required)
  * - userevent: object (required)
  * ChannelVarset
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1624,17 +1673,20 @@ ari_validator ast_ari_validate_applicati
  * - roundtrip_usec: string
  * - uri: string (required)
  * ContactStatusChange
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - contact_info: ContactInfo (required)
  * - endpoint: Endpoint (required)
  * DeviceStateChanged
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - device_state: DeviceState (required)
  * Dial
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1645,17 +1697,21 @@ ari_validator ast_ari_validate_applicati
  * - forwarded: Channel
  * - peer: Channel (required)
  * EndpointStateChange
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - endpoint: Endpoint (required)
  * Event
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * Message
+ * - asterisk_id: string
  * - type: string (required)
  * MissingParams
+ * - asterisk_id: string
  * - type: string (required)
  * - params: List[string] (required)
  * Peer
@@ -1665,42 +1721,50 @@ ari_validator ast_ari_validate_applicati
  * - port: string
  * - time: string
  * PeerStatusChange
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - endpoint: Endpoint (required)
  * - peer: Peer (required)
  * PlaybackFinished
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - playback: Playback (required)
  * PlaybackStarted
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - playback: Playback (required)
  * RecordingFailed
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - recording: LiveRecording (required)
  * RecordingFinished
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - recording: LiveRecording (required)
  * RecordingStarted
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - recording: LiveRecording (required)
  * StasisEnd
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
  * - channel: Channel (required)
  * StasisStart
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
@@ -1708,6 +1772,7 @@ ari_validator ast_ari_validate_applicati
  * - channel: Channel (required)
  * - replace_channel: Channel
  * TextMessageReceived
+ * - asterisk_id: string
  * - type: string (required)
  * - application: string (required)
  * - timestamp: Date
diff -urpN asterisk-13.9.1/res/ari/ari_websockets.c asterisk-13.17.0/res/ari/ari_websockets.c
--- asterisk-13.9.1/res/ari/ari_websockets.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/ari_websockets.c	2017-07-12 13:12:08.000000000 +0200
@@ -23,6 +23,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/ari.h"
 #include "asterisk/astobj2.h"
 #include "asterisk/http_websocket.h"
+#include "asterisk/stasis_app.h"
 #include "internal.h"
 
 /*! \file
@@ -139,6 +140,7 @@ struct ast_json *ast_ari_websocket_sessi
 				ast_log(LOG_WARNING,
 					"WebSocket input failed to parse\n");
 			}
+
 			break;
 		default:
 			/* Ignore all other message types */
@@ -174,14 +176,20 @@ int ast_ari_websocket_session_write(stru
 		return -1;
 	}
 
-	ast_debug(3, "Examining ARI event (length %u): \n%s\n", (unsigned int) strlen(str), str);
 	if (ast_websocket_write_string(session->ws_session, str)) {
-		ast_log(LOG_NOTICE, "Problem occurred during websocket write, websocket closed\n");
+		ast_log(LOG_NOTICE, "Problem occurred during websocket write to %s, websocket closed\n",
+			ast_sockaddr_stringify(ast_ari_websocket_session_get_remote_addr(session)));
 		return -1;
 	}
 	return 0;
 }
 
+struct ast_sockaddr *ast_ari_websocket_session_get_remote_addr(
+	struct ast_ari_websocket_session *session)
+{
+	return ast_websocket_remote_address(session->ws_session);
+}
+
 void ari_handle_websocket(struct ast_websocket_server *ws_server,
 	struct ast_tcptls_session_instance *ser, const char *uri,
 	enum ast_http_method method, struct ast_variable *get_params,
diff -urpN asterisk-13.9.1/res/ari/cli.c asterisk-13.17.0/res/ari/cli.c
--- asterisk-13.9.1/res/ari/cli.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/cli.c	2017-07-12 13:12:08.000000000 +0200
@@ -28,6 +28,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #include "asterisk/astobj2.h"
 #include "asterisk/cli.h"
+#include "asterisk/stasis_app.h"
 #include "internal.h"
 
 static char *ari_show(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -251,11 +252,185 @@ static char *ari_mkpasswd(struct ast_cli
 	return CLI_SUCCESS;
 }
 
+static char *ari_show_apps(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	struct ao2_container *apps;
+	struct ao2_iterator it_apps;
+	char *app;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "ari show apps";
+		e->usage =
+			"Usage: ari show apps\n"
+			"       Lists all registered applications.\n"
+			;
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	default:
+		break;
+	}
+
+	if (a->argc != 3) {
+		return CLI_SHOWUSAGE;
+	}
+
+	apps = stasis_app_get_all();
+	if (!apps) {
+		ast_cli(a->fd, "Unable to retrieve registered applications!\n");
+		return CLI_FAILURE;
+	}
+
+	ast_cli(a->fd, "Application Name         \n");
+	ast_cli(a->fd, "=========================\n");
+	it_apps = ao2_iterator_init(apps, 0);
+	while ((app = ao2_iterator_next(&it_apps))) {
+		ast_cli(a->fd, "%-25.25s\n", app);
+		ao2_ref(app, -1);
+	}
+
+	ao2_iterator_destroy(&it_apps);
+	ao2_ref(apps, -1);
+
+	return CLI_SUCCESS;
+}
+
+struct app_complete {
+	/*! Nth app to search for */
+	int state;
+	/*! Which app currently on */
+	int which;
+};
+
+static int complete_ari_app_search(void *obj, void *arg, void *data, int flags)
+{
+	struct app_complete *search = data;
+
+	if (++search->which > search->state) {
+		return CMP_MATCH;
+	}
+	return 0;
+}
+
+static char *complete_ari_app(struct ast_cli_args *a, int include_all)
+{
+	RAII_VAR(struct ao2_container *, apps, stasis_app_get_all(), ao2_cleanup);
+	RAII_VAR(char *, app, NULL, ao2_cleanup);
+
+	struct app_complete search = {
+		.state = a->n,
+	};
+
+	if (a->pos != 3) {
+		return NULL;
+	}
+
+	if (!apps) {
+		ast_cli(a->fd, "Error getting ARI applications\n");
+		return CLI_FAILURE;
+	}
+
+	if (include_all && ast_strlen_zero(a->word)) {
+		ast_str_container_add(apps, " all");
+	}
+
+	app = ao2_callback_data(apps,
+		ast_strlen_zero(a->word) ? 0 : OBJ_SEARCH_PARTIAL_KEY,
+		complete_ari_app_search, (char*)a->word, &search);
+
+	return app ? ast_strdup(app) : NULL;
+}
+
+static char *ari_show_app(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	void *app;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "ari show app";
+		e->usage =
+			"Usage: ari show app <application>\n"
+			"       Provide detailed information about a registered application.\n"
+			;
+		return NULL;
+	case CLI_GENERATE:
+		return complete_ari_app(a, 0);
+	default:
+		break;
+	}
+
+	if (a->argc != 4) {
+		return CLI_SHOWUSAGE;
+	}
+
+	app = stasis_app_get_by_name(a->argv[3]);
+	if (!app) {
+		return CLI_FAILURE;
+	}
+
+	stasis_app_to_cli(app, a);
+
+	ao2_ref(app, -1);
+
+	return CLI_SUCCESS;
+}
+
+static char *ari_set_debug(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	void *app;
+	int debug;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "ari set debug";
+		e->usage =
+			"Usage: ari set debug <application|all> <on|off>\n"
+			"       Enable or disable debugging on a specific application.\n"
+			;
+		return NULL;
+	case CLI_GENERATE:
+		return complete_ari_app(a, 1);
+	default:
+		break;
+	}
+
+	if (a->argc != 5) {
+		return CLI_SHOWUSAGE;
+	}
+
+	debug = !strcmp(a->argv[4], "on");
+
+	if (!strcmp(a->argv[3], "all")) {
+		stasis_app_set_global_debug(debug);
+		ast_cli(a->fd, "Debugging on all applications %s\n",
+			debug ? "enabled" : "disabled");
+		return CLI_SUCCESS;
+	}
+
+	app = stasis_app_get_by_name(a->argv[3]);
+	if (!app) {
+		return CLI_FAILURE;
+	}
+
+	stasis_app_set_debug(app, debug);
+	ast_cli(a->fd, "Debugging on '%s' %s\n",
+		stasis_app_name(app),
+		debug ? "enabled" : "disabled");
+
+	ao2_ref(app, -1);
+
+	return CLI_SUCCESS;
+}
+
 static struct ast_cli_entry cli_ari[] = {
 	AST_CLI_DEFINE(ari_show, "Show ARI settings"),
 	AST_CLI_DEFINE(ari_show_users, "List ARI users"),
 	AST_CLI_DEFINE(ari_show_user, "List single ARI user"),
 	AST_CLI_DEFINE(ari_mkpasswd, "Encrypts a password"),
+	AST_CLI_DEFINE(ari_show_apps, "List registered ARI applications"),
+	AST_CLI_DEFINE(ari_show_app, "Display details of a registered ARI application"),
+	AST_CLI_DEFINE(ari_set_debug, "Enable/disable debugging of an ARI application"),
 };
 
 int ast_ari_cli_register(void) {
diff -urpN asterisk-13.9.1/res/ari/resource_bridges.c asterisk-13.17.0/res/ari/resource_bridges.c
--- asterisk-13.9.1/res/ari/resource_bridges.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/resource_bridges.c	2017-07-12 13:12:08.000000000 +0200
@@ -37,6 +37,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/stasis.h"
 #include "asterisk/stasis_bridges.h"
 #include "asterisk/stasis_app.h"
+#include "asterisk/stasis_app_impl.h"
 #include "asterisk/stasis_app_playback.h"
 #include "asterisk/stasis_app_recording.h"
 #include "asterisk/stasis_channels.h"
@@ -278,6 +279,7 @@ struct bridge_channel_control_thread_dat
 	struct ast_channel *bridge_channel;
 	struct stasis_app_control *control;
 	struct stasis_forward *forward;
+	char bridge_id[0];
 };
 
 static void *bridge_channel_control_thread(void *data)
@@ -286,6 +288,7 @@ static void *bridge_channel_control_thre
 	struct ast_channel *bridge_channel = thread_data->bridge_channel;
 	struct stasis_app_control *control = thread_data->control;
 	struct stasis_forward *forward = thread_data->forward;
+	char *bridge_id = ast_strdupa(thread_data->bridge_id);
 
 	RAII_VAR(struct ast_callid *, callid, ast_channel_callid(bridge_channel), ast_callid_cleanup);
 
@@ -299,6 +302,7 @@ static void *bridge_channel_control_thre
 	stasis_app_control_execute_until_exhausted(bridge_channel, control);
 	stasis_app_control_flush_queue(control);
 
+	stasis_app_bridge_playback_channel_remove(bridge_id, control);
 	stasis_forward_cancel(forward);
 	ao2_cleanup(control);
 	ast_hangup(bridge_channel);
@@ -381,7 +385,7 @@ static int ari_bridges_play_helper(const
 		return -1;
 	}
 
-	if (ast_asprintf(playback_url, "/playback/%s",
+	if (ast_asprintf(playback_url, "/playbacks/%s",
 			stasis_app_playback_get_id(playback)) == -1) {
 		playback_url = NULL;
 		ast_ari_response_alloc_failed(response);
@@ -464,8 +468,9 @@ static void ari_bridges_play_new(const c
 	}
 
 	/* Give play_channel and control reference to the thread data */
-	thread_data = ast_calloc(1, sizeof(*thread_data));
+	thread_data = ast_malloc(sizeof(*thread_data) + strlen(bridge->uniqueid) + 1);
 	if (!thread_data) {
+		stasis_app_bridge_playback_channel_remove((char *)bridge->uniqueid, control);
 		ast_ari_response_alloc_failed(response);
 		return;
 	}
@@ -473,8 +478,11 @@ static void ari_bridges_play_new(const c
 	thread_data->bridge_channel = play_channel;
 	thread_data->control = control;
 	thread_data->forward = channel_forward;
+	/* Safe */
+	strcpy(thread_data->bridge_id, bridge->uniqueid);
 
 	if (ast_pthread_create_detached(&threadid, NULL, bridge_channel_control_thread, thread_data)) {
+		stasis_app_bridge_playback_channel_remove((char *)bridge->uniqueid, control);
 		ast_ari_response_alloc_failed(response);
 		ast_free(thread_data);
 		return;
@@ -991,3 +999,68 @@ void ast_ari_bridges_create_with_id(stru
 	ast_ari_response_ok(response,
 		ast_bridge_snapshot_to_json(snapshot, stasis_app_get_sanitizer()));
 }
+
+static int bridge_set_video_source_cb(struct stasis_app_control *control,
+	struct ast_channel *chan, void *data)
+{
+	struct ast_bridge *bridge = data;
+
+	ast_bridge_lock(bridge);
+	ast_bridge_set_single_src_video_mode(bridge, chan);
+	ast_bridge_unlock(bridge);
+
+	return 0;
+}
+
+void ast_ari_bridges_set_video_source(struct ast_variable *headers,
+	struct ast_ari_bridges_set_video_source_args *args, struct ast_ari_response *response)
+{
+	struct ast_bridge *bridge;
+	struct stasis_app_control *control;
+
+	bridge = find_bridge(response, args->bridge_id);
+	if (!bridge) {
+		return;
+	}
+
+	control = find_channel_control(response, args->channel_id);
+	if (!control) {
+		ao2_ref(bridge, -1);
+		return;
+	}
+
+	if (stasis_app_get_bridge(control) != bridge) {
+		ast_ari_response_error(response, 422,
+			"Unprocessable Entity",
+			"Channel not in this bridge");
+		ao2_ref(bridge, -1);
+		ao2_ref(control, -1);
+		return;
+	}
+
+	stasis_app_send_command(control, bridge_set_video_source_cb,
+		ao2_bump(bridge), __ao2_cleanup);
+
+	ao2_ref(bridge, -1);
+	ao2_ref(control, -1);
+
+	ast_ari_response_no_content(response);
+}
+
+void ast_ari_bridges_clear_video_source(struct ast_variable *headers,
+	struct ast_ari_bridges_clear_video_source_args *args, struct ast_ari_response *response)
+{
+	struct ast_bridge *bridge;
+
+	bridge = find_bridge(response, args->bridge_id);
+	if (!bridge) {
+		return;
+	}
+
+	ast_bridge_lock(bridge);
+	ast_bridge_set_talker_src_video_mode(bridge);
+	ast_bridge_unlock(bridge);
+
+	ao2_ref(bridge, -1);
+	ast_ari_response_no_content(response);
+}
diff -urpN asterisk-13.9.1/res/ari/resource_bridges.h asterisk-13.17.0/res/ari/resource_bridges.h
--- asterisk-13.9.1/res/ari/resource_bridges.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/resource_bridges.h	2017-07-12 13:12:08.000000000 +0200
@@ -200,6 +200,34 @@ int ast_ari_bridges_remove_channel_parse
  * \param[out] response HTTP response
  */
 void ast_ari_bridges_remove_channel(struct ast_variable *headers, struct ast_ari_bridges_remove_channel_args *args, struct ast_ari_response *response);
+/*! Argument struct for ast_ari_bridges_set_video_source() */
+struct ast_ari_bridges_set_video_source_args {
+	/*! Bridge's id */
+	const char *bridge_id;
+	/*! Channel's id */
+	const char *channel_id;
+};
+/*!
+ * \brief Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.
+ *
+ * \param headers HTTP headers
+ * \param args Swagger parameters
+ * \param[out] response HTTP response
+ */
+void ast_ari_bridges_set_video_source(struct ast_variable *headers, struct ast_ari_bridges_set_video_source_args *args, struct ast_ari_response *response);
+/*! Argument struct for ast_ari_bridges_clear_video_source() */
+struct ast_ari_bridges_clear_video_source_args {
+	/*! Bridge's id */
+	const char *bridge_id;
+};
+/*!
+ * \brief Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.
+ *
+ * \param headers HTTP headers
+ * \param args Swagger parameters
+ * \param[out] response HTTP response
+ */
+void ast_ari_bridges_clear_video_source(struct ast_variable *headers, struct ast_ari_bridges_clear_video_source_args *args, struct ast_ari_response *response);
 /*! Argument struct for ast_ari_bridges_start_moh() */
 struct ast_ari_bridges_start_moh_args {
 	/*! Bridge's id */
diff -urpN asterisk-13.9.1/res/ari/resource_channels.c asterisk-13.17.0/res/ari/resource_channels.c
--- asterisk-13.9.1/res/ari/resource_channels.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/resource_channels.c	2017-07-12 13:12:08.000000000 +0200
@@ -524,7 +524,7 @@ static void ari_channels_handle_play(
 		return;
 	}
 
-	if (ast_asprintf(&playback_url, "/playback/%s",
+	if (ast_asprintf(&playback_url, "/playbacks/%s",
 			stasis_app_playback_get_id(playback)) == -1) {
 		playback_url = NULL;
 		ast_ari_response_error(
@@ -912,6 +912,7 @@ static void ari_channels_handle_originat
 	const char *args_channel_id,
 	const char *args_other_channel_id,
 	const char *args_originator,
+	const char *args_formats,
 	struct ast_ari_response *response)
 {
 	char *dialtech;
@@ -930,6 +931,7 @@ static void ari_channels_handle_originat
 	};
 	struct ari_origination *origination;
 	pthread_t thread;
+	struct ast_format_cap *format_cap = NULL;
 
 	if ((assignedids.uniqueid && AST_MAX_PUBLIC_UNIQUEID < strlen(assignedids.uniqueid))
 		|| (assignedids.uniqueid2 && AST_MAX_PUBLIC_UNIQUEID < strlen(assignedids.uniqueid2))) {
@@ -944,6 +946,12 @@ static void ari_channels_handle_originat
 		return;
 	}
 
+	if (!ast_strlen_zero(args_originator) && !ast_strlen_zero(args_formats)) {
+		ast_ari_response_error(response, 400, "Bad Request",
+			"Originator and formats can't both be specified");
+		return;
+	}
+
 	dialtech = ast_strdupa(args_endpoint);
 	if ((stuff = strchr(dialtech, '/'))) {
 		*stuff++ = '\0';
@@ -1066,8 +1074,47 @@ static void ari_channels_handle_originat
 		}
 	}
 
-	if (ast_dial_prerun(dial, other, NULL)) {
-		ast_ari_response_alloc_failed(response);
+	if (!ast_strlen_zero(args_formats)) {
+		char *format_name;
+		char *formats_copy = ast_strdupa(args_formats);
+
+		if (!(format_cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT))) {
+			ast_ari_response_alloc_failed(response);
+			ast_dial_destroy(dial);
+			ast_free(origination);
+			ast_channel_cleanup(other);
+			return;
+		}
+
+		while ((format_name = ast_strip(strsep(&formats_copy, ",")))) {
+			struct ast_format *fmt = ast_format_cache_get(format_name);
+
+			if (!fmt || ast_format_cap_append(format_cap, fmt, 0)) {
+				if (!fmt) {
+					ast_ari_response_error(
+						response, 400, "Bad Request",
+						"Provided format (%s) was not found", format_name);
+				} else {
+					ast_ari_response_alloc_failed(response);
+				}
+				ast_dial_destroy(dial);
+				ast_free(origination);
+				ast_channel_cleanup(other);
+				ao2_ref(format_cap, -1);
+				ao2_cleanup(fmt);
+				return;
+			}
+			ao2_ref(fmt, -1);
+		}
+	}
+
+	if (ast_dial_prerun(dial, other, format_cap)) {
+		if (ast_channel_errno() == AST_CHANNEL_ERROR_ID_EXISTS) {
+			ast_ari_response_error(response, 409, "Conflict",
+				"Channel with given unique ID already exists");
+		} else {
+			ast_ari_response_alloc_failed(response);
+		}
 		ast_dial_destroy(dial);
 		ast_free(origination);
 		ast_channel_cleanup(other);
@@ -1075,6 +1122,7 @@ static void ari_channels_handle_originat
 	}
 
 	ast_channel_cleanup(other);
+	ao2_cleanup(format_cap);
 
 	chan = ast_dial_get_channel(dial, 0);
 	if (!chan) {
@@ -1215,6 +1263,7 @@ void ast_ari_channels_originate_with_id(
 		args->channel_id,
 		args->other_channel_id,
 		args->originator,
+		args->formats,
 		response);
 	ast_variables_destroy(variables);
 }
@@ -1251,6 +1300,7 @@ void ast_ari_channels_originate(struct a
 		args->channel_id,
 		args->other_channel_id,
 		args->originator,
+		args->formats,
 		response);
 	ast_variables_destroy(variables);
 }
diff -urpN asterisk-13.9.1/res/ari/resource_channels.h asterisk-13.17.0/res/ari/resource_channels.h
--- asterisk-13.9.1/res/ari/resource_channels.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/resource_channels.h	2017-07-12 13:12:08.000000000 +0200
@@ -78,6 +78,8 @@ struct ast_ari_channels_originate_args {
 	const char *other_channel_id;
 	/*! The unique id of the channel which is originating this one. */
 	const char *originator;
+	/*! The format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs". */
+	const char *formats;
 };
 /*!
  * \brief Body parsing function for /channels.
@@ -141,6 +143,8 @@ struct ast_ari_channels_originate_with_i
 	const char *other_channel_id;
 	/*! The unique id of the channel which is originating this one. */
 	const char *originator;
+	/*! The format name capability list to use if originator is not specified. Ex. "ulaw,slin16".  Format names can be found with "core show codecs". */
+	const char *formats;
 };
 /*!
  * \brief Body parsing function for /channels/{channelId}.
diff -urpN asterisk-13.9.1/res/ari/resource_events.c asterisk-13.17.0/res/ari/resource_events.c
--- asterisk-13.9.1/res/ari/resource_events.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/ari/resource_events.c	2017-07-12 13:12:08.000000000 +0200
@@ -139,6 +139,15 @@ static void app_handler(void *data, cons
 
 	ao2_lock(session);
 	if (session->ws_session) {
+		if (stasis_app_get_debug_by_name(app_name)) {
+			char *str = ast_json_dump_string_format(message, ast_ari_json_format());
+
+			ast_verbose("<--- Sending ARI event to %s --->\n%s\n",
+				ast_sockaddr_stringify(ast_ari_websocket_session_get_remote_addr(session->ws_session)),
+				str);
+			ast_json_free(str);
+		}
+
 		ast_ari_websocket_session_write(session->ws_session, message);
 	}
 	ao2_unlock(session);
diff -urpN asterisk-13.9.1/res/res.xml asterisk-13.17.0/res/res.xml
--- asterisk-13.9.1/res/res.xml	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res.xml	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,13 @@
+<member name="res_digium_phone" displayname="Download the Digium Phone Module for Asterisk.  See http://downloads.digium.com/pub/telephony/res_digium_phone/README.">
+	<support_level>external</support_level>
+	<depend>xmlstarlet</depend>
+	<depend>bash</depend>
+	<defaultenabled>no</defaultenabled>
+	<member_data>
+		<downloader>
+			<variants>
+				<variant tag="bundled" condition='[[ "$PJPROJECT_BUNDLED" = "yes" ]]'/>
+			</variants>
+		</downloader>
+	</member_data>
+</member>
diff -urpN asterisk-13.9.1/res/res_agi.c asterisk-13.17.0/res/res_agi.c
--- asterisk-13.9.1/res/res_agi.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_agi.c	2017-07-12 13:12:08.000000000 +0200
@@ -22,7 +22,6 @@
  *
  * \author Mark Spencer <markster@digium.com>
  *
- * \todo Convert the rest of the AGI commands over to XML documentation
  */
 
 /*** MODULEINFO
@@ -85,6 +84,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</description>
 		<see-also>
 			<ref type="agi">hangup</ref>
+			<ref type="application">AGI</ref>
 		</see-also>
 	</agi>
 	<agi name="asyncagi break" language="en_US">
@@ -98,6 +98,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</description>
 		<see-also>
 			<ref type="agi">hangup</ref>
+			<ref type="application">AGI</ref>
 		</see-also>
 	</agi>
 	<agi name="channel status" language="en_US">
@@ -138,6 +139,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</enum>
 			</enumlist>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="control stream file" language="en_US">
 		<synopsis>
@@ -188,6 +192,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 				</variable>
 			</variablelist>
 		</description>
+		<see-also>
+			<ref type="agi">get option</ref>
+			<ref type="agi">control stream file</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="database del" language="en_US">
 		<synopsis>
@@ -203,6 +212,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Returns <literal>1</literal> if successful, <literal>0</literal>
 			otherwise.</para>
 		</description>
+		<see-also>
+			<ref type="agi">database get</ref>
+			<ref type="agi">database put</ref>
+			<ref type="agi">database deltree</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="database deltree" language="en_US">
 		<synopsis>
@@ -217,6 +232,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			within a <replaceable>family</replaceable> in the Asterisk database.</para>
 			<para>Returns <literal>1</literal> if successful, <literal>0</literal> otherwise.</para>
 		</description>
+		<see-also>
+			<ref type="agi">database get</ref>
+			<ref type="agi">database put</ref>
+			<ref type="agi">database del</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="database get" language="en_US">
 		<synopsis>
@@ -234,6 +255,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			in parenthesis.</para>
 			<para>Example return code: 200 result=1 (testvariable)</para>
 		</description>
+		<see-also>
+			<ref type="agi">database put</ref>
+			<ref type="agi">database del</ref>
+			<ref type="agi">database deltree</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="database put" language="en_US">
 		<synopsis>
@@ -250,6 +277,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<replaceable>value</replaceable>.</para>
 			<para>Returns <literal>1</literal> if successful, <literal>0</literal> otherwise.</para>
 		</description>
+		<see-also>
+			<ref type="agi">database get</ref>
+			<ref type="agi">database del</ref>
+			<ref type="agi">database deltree</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="exec" language="en_US">
 		<synopsis>
@@ -265,6 +298,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Returns whatever the <replaceable>application</replaceable> returns, or
 			<literal>-2</literal> on failure to find <replaceable>application</replaceable>.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="get data" language="en_US">
 		<synopsis>
@@ -279,6 +315,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Stream the given <replaceable>file</replaceable>, and receive DTMF data.</para>
 			<para>Returns the digits received from the channel at the other end.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="get full variable" language="en_US">
 		<synopsis>
@@ -295,6 +334,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			variables, unlike GET VARIABLE.</para>
 			<para>Example return code: 200 result=1 (testvariable)</para>
 		</description>
+		<see-also>
+			<ref type="agi">get variable</ref>
+			<ref type="agi">set variable</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="get option" language="en_US">
 		<synopsis>
@@ -310,6 +354,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</description>
 		<see-also>
 			<ref type="agi">stream file</ref>
+			<ref type="agi">control stream file</ref>
+			<ref type="application">AGI</ref>
 		</see-also>
 	</agi>
 	<agi name="get variable" language="en_US">
@@ -325,6 +371,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			the variable in parentheses.</para>
 			<para>Example return code: 200 result=1 (testvariable)</para>
 		</description>
+		<see-also>
+			<ref type="agi">get full variable</ref>
+			<ref type="agi">set variable</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="hangup" language="en_US">
 		<synopsis>
@@ -337,6 +388,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Hangs up the specified channel. If no channel name is given, hangs
 			up the current channel</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="noop" language="en_US">
 		<synopsis>
@@ -346,6 +400,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Does nothing.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="receive char" language="en_US">
 		<synopsis>
@@ -363,6 +420,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			if one is received, or <literal>0</literal> if the channel does not support
 			text reception. Returns <literal>-1</literal> only on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">receive text</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="receive text" language="en_US">
 		<synopsis>
@@ -379,19 +440,45 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			do not support the reception of text. Returns <literal>-1</literal> for failure
 			or <literal>1</literal> for success, and the string in parenthesis.</para>
 		</description>
+		<see-also>
+			<ref type="agi">receive char</ref>
+			<ref type="agi">send text</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="record file" language="en_US">
 		<synopsis>
 			Records to a given file.
 		</synopsis>
 		<syntax>
-			<parameter name="filename" required="true" />
-			<parameter name="format" required="true" />
-			<parameter name="escape_digits" required="true" />
-			<parameter name="timeout" required="true" />
-			<parameter name="offset samples" />
-			<parameter name="BEEP" />
-			<parameter name="s=silence" />
+			<parameter name="filename" required="true">
+				<para>The destination filename of the recorded audio.</para>
+			</parameter>
+			<parameter name="format" required="true">
+				<para>The audio format in which to save the resulting file.</para>
+			</parameter>
+			<parameter name="escape_digits" required="true">
+				<para>The DTMF digits that will terminate the recording process.</para>
+			</parameter>
+			<parameter name="timeout" required="true">
+				<para>The maximum recording time in milliseconds. Set to -1 for no
+				limit.</para>
+			</parameter>
+			<parameter name="offset_samples">
+				<para>Causes the recording to first seek to the specified offset before
+				recording begins.</para>
+			</parameter>
+			<parameter name="beep">
+				<para>Causes Asterisk to play a beep as recording begins. This argument
+				can take any value.</para>
+			</parameter>
+			<parameter name="s=silence">
+				<para>The number of seconds of silence that are permitted before the
+				recording is terminated, regardless of the
+				<replaceable>escape_digits</replaceable> or <replaceable>timeout</replaceable>
+				arguments. If specified, this parameter must be preceded by
+				<literal>s=</literal>.</para>
+			</parameter>
 		</syntax>
 		<description>
 			<para>Record to a file until a given dtmf digit in the sequence is received.
@@ -399,11 +486,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			will be recorded. The <replaceable>timeout</replaceable> is the maximum record time in
 			milliseconds, or <literal>-1</literal> for no <replaceable>timeout</replaceable>.
 			<replaceable>offset samples</replaceable> is optional, and, if provided, will seek
-			to the offset without exceeding the end of the file. <replaceable>silence</replaceable> is
+			to the offset without exceeding the end of the
+			file. <replaceable>beep</replaceable> can take any value, and causes Asterisk
+			to play a beep to the channel that is about to be recorded. <replaceable>silence</replaceable> is
 			the number of seconds of silence allowed before the function returns despite the
 			lack of dtmf digits or reaching <replaceable>timeout</replaceable>. <replaceable>silence</replaceable>
 			value must be preceded by <literal>s=</literal> and is also optional.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say alpha" language="en_US">
 		<synopsis>
@@ -419,6 +511,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			without a digit being pressed, or the ASCII numerical value of the digit if one
 			was pressed or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say digits</ref>
+			<ref type="agi">say number</ref>
+			<ref type="agi">say phonetic</ref>
+			<ref type="agi">say date</ref>
+			<ref type="agi">say time</ref>
+			<ref type="agi">say datetime</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say digits" language="en_US">
 		<synopsis>
@@ -434,6 +535,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			without a digit being pressed, or the ASCII numerical value of the digit if one
 			was pressed or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say alpha</ref>
+			<ref type="agi">say number</ref>
+			<ref type="agi">say phonetic</ref>
+			<ref type="agi">say date</ref>
+			<ref type="agi">say time</ref>
+			<ref type="agi">say datetime</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say number" language="en_US">
 		<synopsis>
@@ -450,6 +560,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			completes without a digit being pressed, or the ASCII numerical value of
 			the digit if one was pressed or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say alpha</ref>
+			<ref type="agi">say digits</ref>
+			<ref type="agi">say phonetic</ref>
+			<ref type="agi">say date</ref>
+			<ref type="agi">say time</ref>
+			<ref type="agi">say datetime</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say phonetic" language="en_US">
 		<synopsis>
@@ -465,6 +584,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			playback completes without a digit pressed, the ASCII numerical value of the digit
 			if one was pressed, or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say alpha</ref>
+			<ref type="agi">say digits</ref>
+			<ref type="agi">say number</ref>
+			<ref type="agi">say date</ref>
+			<ref type="agi">say time</ref>
+			<ref type="agi">say datetime</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say date" language="en_US">
 		<synopsis>
@@ -483,6 +611,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			completes without a digit being pressed, or the ASCII numerical value of the
 			digit if one was pressed or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say alpha</ref>
+			<ref type="agi">say digits</ref>
+			<ref type="agi">say number</ref>
+			<ref type="agi">say phonetic</ref>
+			<ref type="agi">say time</ref>
+			<ref type="agi">say datetime</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say time" language="en_US">
 		<synopsis>
@@ -501,6 +638,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			without a digit being pressed, or the ASCII numerical value of the digit if
 			one was pressed or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say alpha</ref>
+			<ref type="agi">say digits</ref>
+			<ref type="agi">say number</ref>
+			<ref type="agi">say phonetic</ref>
+			<ref type="agi">say date</ref>
+			<ref type="agi">say datetime</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="say datetime" language="en_US">
 		<synopsis>
@@ -528,6 +674,15 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			completes without a digit being pressed, or the ASCII numerical value of the
 			digit if one was pressed or <literal>-1</literal> on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">say alpha</ref>
+			<ref type="agi">say digits</ref>
+			<ref type="agi">say number</ref>
+			<ref type="agi">say phonetic</ref>
+			<ref type="agi">say date</ref>
+			<ref type="agi">say time</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="send image" language="en_US">
 		<synopsis>
@@ -542,6 +697,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			the channel does not support image transmission.  Returns <literal>-1</literal>
 			only on error/hangup. Image names should not include extensions.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="send text" language="en_US">
 		<synopsis>
@@ -559,6 +717,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			channel does not support text transmission. Returns <literal>-1</literal> only
 			on error/hangup.</para>
 		</description>
+		<see-also>
+			<ref type="agi">receive text</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set autohangup" language="en_US">
 		<synopsis>
@@ -572,6 +734,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			seconds in the future. Of course it can be hungup before then as well. Setting to
 			<literal>0</literal> will cause the autohangup feature to be disabled on this channel.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set callerid" language="en_US">
 		<synopsis>
@@ -583,6 +748,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Changes the callerid of the current channel.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set context" language="en_US">
 		<synopsis>
@@ -594,6 +762,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Sets the context for continuation upon exiting the application.</para>
 		</description>
+		<see-also>
+			<ref type="agi">set extension</ref>
+			<ref type="agi">set priority</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set extension" language="en_US">
 		<synopsis>
@@ -605,6 +778,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Changes the extension for continuation upon exiting the application.</para>
 		</description>
+		<see-also>
+			<ref type="agi">set context</ref>
+			<ref type="agi">set priority</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set music" language="en_US">
 		<synopsis>
@@ -629,6 +807,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			used. This generator will be stopped automatically when playing a file.</para>
 			<para>Always returns <literal>0</literal>.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set priority" language="en_US">
 		<synopsis>
@@ -641,6 +822,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Changes the priority for continuation upon exiting the application.
 			The priority must be a valid priority or label.</para>
 		</description>
+		<see-also>
+			<ref type="agi">set context</ref>
+			<ref type="agi">set extension</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="set variable" language="en_US">
 		<synopsis>
@@ -653,6 +839,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Sets a variable to the current channel.</para>
 		</description>
+		<see-also>
+			<ref type="agi">get variable</ref>
+			<ref type="agi">get full variable</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="stream file" language="en_US">
 		<synopsis>
@@ -690,6 +881,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</description>
 		<see-also>
 			<ref type="agi">control stream file</ref>
+			<ref type="agi">get option</ref>
+			<ref type="application">AGI</ref>
 		</see-also>
 	</agi>
 	<agi name="tdd mode" language="en_US">
@@ -708,6 +901,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Enable/Disable TDD transmission/reception on a channel. Returns <literal>1</literal> if
 			successful, or <literal>0</literal> if channel is not TDD-capable.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="verbose" language="en_US">
 		<synopsis>
@@ -722,6 +918,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			message system. <replaceable>level</replaceable> is the verbose level (1-4).
 			Always returns <literal>1</literal></para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="wait for digit" language="en_US">
 		<synopsis>
@@ -737,6 +936,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			one is received. Use <literal>-1</literal> for the <replaceable>timeout</replaceable> value if
 			you desire the call to block indefinitely.</para>
 		</description>
+		<see-also>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech create" language="en_US">
 		<synopsis>
@@ -748,6 +950,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Create a speech object to be used by the other Speech AGI commands.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech set" language="en_US">
 		<synopsis>
@@ -760,6 +972,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Set an engine-specific setting.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech create</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech destroy" language="en_US">
 		<synopsis>
@@ -772,6 +994,13 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</description>
 		<see-also>
 			<ref type="agi">speech create</ref>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
 		</see-also>
 	</agi>
 	<agi name="speech load grammar" language="en_US">
@@ -785,6 +1014,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Loads the specified grammar as the specified name.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech create</ref>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech unload grammar" language="en_US">
 		<synopsis>
@@ -796,6 +1035,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Unloads the specified grammar.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech create</ref>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech activate grammar" language="en_US">
 		<synopsis>
@@ -807,6 +1056,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Activates the specified grammar on the speech object.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech create</ref>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech deactivate grammar" language="en_US">
 		<synopsis>
@@ -818,6 +1077,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Deactivates the specified grammar on the speech object.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech create</ref>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech recognize</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<agi name="speech recognize" language="en_US">
 		<synopsis>
@@ -832,14 +1101,27 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Plays back given <replaceable>prompt</replaceable> while listening for
 			speech and dtmf.</para>
 		</description>
+		<see-also>
+			<ref type="agi">speech create</ref>
+			<ref type="agi">speech set</ref>
+			<ref type="agi">speech destroy</ref>
+			<ref type="agi">speech load grammar</ref>
+			<ref type="agi">speech unload grammar</ref>
+			<ref type="agi">speech activate grammar</ref>
+			<ref type="agi">speech deactivate grammar</ref>
+			<ref type="application">AGI</ref>
+		</see-also>
 	</agi>
 	<application name="AGI" language="en_US">
 		<synopsis>
 			Executes an AGI compliant application.
 		</synopsis>
 		<syntax>
-			<parameter name="command" required="true" />
+			<parameter name="command" required="true">
+				<para>How AGI should be invoked on the channel.</para>
+			</parameter>
 			<parameter name="args">
+				<para>Arguments to pass to the AGI script or server.</para>
 				<argument name="arg1" required="true" />
 				<argument name="arg2" multiple="yes" />
 			</parameter>
@@ -848,21 +1130,72 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Executes an Asterisk Gateway Interface compliant
 			program on a channel. AGI allows Asterisk to launch external programs written
 			in any language to control a telephony channel, play audio, read DTMF digits,
-			etc. by communicating with the AGI protocol on <emphasis>stdin</emphasis> and
-			<emphasis>stdout</emphasis>. As of <literal>1.6.0</literal>, this channel will
+			etc. by communicating with the AGI protocol.</para>
+			<para>The following variants of AGI exist, and are chosen based on the value
+			passed to <replaceable>command</replaceable>:</para>
+			<enumlist>
+				<enum name="AGI">
+					<para>The classic variant of AGI, this will launch the script
+					specified by <replaceable>command</replaceable> as a new process.
+					Communication with the script occurs on <literal>stdin</literal> and
+					<literal>stdout</literal>. If the full path to the script is not
+					provided, the <directory>astagidir</directory> specified in
+					<filename>asterisk.conf</filename> will be used.
+					</para>
+				</enum>
+				<enum name="FastAGI">
+					<para>Connect Asterisk to a FastAGI server using a TCP connection.
+					The URI to the FastAGI server should be given in the form
+					<literal>[scheme]://host.domain[:port][/script/name]</literal>,
+					where <replaceable>scheme</replaceable> is either <literal>agi</literal>
+					or <literal>hagi</literal>.</para>
+					<para>In the case of <literal>hagi</literal>, an SRV lookup will be
+					performed to try to connect to a list of FastAGI servers. The hostname in
+					the URI must be prefixed with <literal>_agi._tcp</literal>. prior to the DNS resolution. For
+					example, if you specify the URI <literal>hagi://agi.example.com/foo.agi</literal>
+					the DNS query would be for <literal>_agi._tcp.agi.example.com</literal>. You
+					will need to make sure this resolves correctly.</para>
+				</enum>
+				<enum name="AsyncAGI">
+					<para>Use AMI to control the channel in AGI. AGI commands can be invoked
+					using the <literal>AMI</literal> action, with a variety of AGI specific
+					events passed back over the AMI connection. AsyncAGI should be invoked
+					by passing <literal>agi:async</literal> to the <replaceable>command</replaceable>
+					parameter.</para>
+				</enum>
+			</enumlist>
+			<note>
+			<para>As of <literal>1.6.0</literal>, this channel will
 			not stop dialplan execution on hangup inside of this application. Dialplan
 			execution will continue normally, even upon hangup until the AGI application
 			signals a desire to stop (either by exiting or, in the case of a net script, by
-			closing the connection). A locally executed AGI script will receive SIGHUP on
-			hangup from the channel except when using DeadAGI. A fast AGI server will
-			correspondingly receive a HANGUP inline with the command dialog. Both of theses
-			signals may be disabled by setting the <variable>AGISIGHUP</variable> channel
-			variable to <literal>no</literal> before executing the AGI application.
+			closing the connection).</para>
+			<para>A locally executed AGI script will receive <literal>SIGHUP</literal> on
+			hangup from the channel except when using <literal>DeadAGI</literal>
+			(or when the channel is already hungup). A fast AGI server will
+			correspondingly receive a <literal>HANGUP</literal> inline with the command dialog.
+			Both of these signals may be disabled by setting the <variable>AGISIGHUP</variable>
+			channel variable to <literal>no</literal> before executing the AGI application.
 			Alternatively, if you would like the AGI application to exit immediately
 			after a channel hangup is detected, set the <variable>AGIEXITONHANGUP</variable>
 			variable to <literal>yes</literal>.</para>
-			<para>Use the CLI command <literal>agi show commands</literal> to list available agi
-			commands.</para>
+			</note>
+			<example title="AGI invocation examples">
+				; Start the AGI script /tmp/my-cool-script.sh, passing it the contents
+				; of the channel variable FOO
+				same => n,AGI(/tmp/my-cool-script.sh,${FOO})
+
+				; Start the AGI script my-cool-script.sh located in the astagidir
+				; directory, specified in asterisk.conf
+				same => n,AGI(my-cool-script.sh)
+
+				; Connect to the FastAGI server located at 127.0.0.1 and start the script
+				; awesome-script
+				same => n,AGI(agi://127.0.0.1/awesome-script)
+
+				; Start AsyncAGI
+				same => n,AGI(agi:async)
+			</example>
 			<para>This application sets the following channel variable upon completion:</para>
 			<variablelist>
 				<variable name="AGISTATUS">
@@ -876,8 +1209,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			</variablelist>
 		</description>
 		<see-also>
+			<ref type="manager">AGI</ref>
+			<ref type="managerEvent">AsyncAGIStart</ref>
+			<ref type="managerEvent">AsyncAGIEnd</ref>
 			<ref type="application">EAGI</ref>
 			<ref type="application">DeadAGI</ref>
+			<ref type="filename">asterisk.conf</ref>
 		</see-also>
 	</application>
 	<application name="EAGI" language="en_US">
@@ -890,8 +1227,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		</syntax>
 		<description>
 			<para>Using 'EAGI' provides enhanced AGI, with incoming audio available out of band
-			on file descriptor 3.</para>
-			<xi:include xpointer="xpointer(/docs/application[@name='AGI']/description/para)" />
+			on file descriptor 3. In all other respects, it behaves in the same fashion as
+			AGI. See the documentation for the <literal>AGI</literal> dialplan application for
+			more information on invoking AGI on a channel.</para>
+			<para>This application sets the following channel variable upon completion:</para>
 			<xi:include xpointer="xpointer(/docs/application[@name='AGI']/description/variablelist)" />
 		</description>
 		<see-also>
@@ -908,7 +1247,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<xi:include xpointer="xpointer(/docs/application[@name='AGI']/syntax/parameter[@name='args'])" />
 		</syntax>
 		<description>
-			<xi:include xpointer="xpointer(/docs/application[@name='AGI']/description/para)" />
+			<warning>
+				<para>This application is deprecated and may be removed in a future version
+				of Asterisk. Use the replacement application <literal>AGI</literal> instead
+				of <literal>DeadAGI</literal>.
+				</para>
+			</warning>
+			<para>Execute AGI on a 'dead' or hungup channel. See the documentation for the
+			<literal>AGI</literal> dialplan application for more information on invoking
+			AGI on a channel.</para>
+			<para>This application sets the following channel variable upon completion:</para>
 			<xi:include xpointer="xpointer(/docs/application[@name='AGI']/description/variablelist)" />
 		</description>
 		<see-also>
@@ -936,6 +1284,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		<description>
 			<para>Add an AGI command to the execute queue of the channel in Async AGI.</para>
 		</description>
+		<see-also>
+			<ref type="managerEvent">AsyncAGIStart</ref>
+			<ref type="managerEvent">AsyncAGIExec</ref>
+			<ref type="managerEvent">AsyncAGIEnd</ref>
+		</see-also>
 	</manager>
 	<managerEvent language="en_US" name="AsyncAGIStart">
 		<managerEventInstance class="EVENT_FLAG_AGI">
@@ -946,6 +1299,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>URL encoded string read from the AsyncAGI server.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">AsyncAGIEnd</ref>
+				<ref type="managerEvent">AsyncAGIExec</ref>
+				<ref type="application">AGI</ref>
+				<ref type="manager">AGI</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AsyncAGIEnd">
@@ -954,6 +1313,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<syntax>
 				<channel_snapshot/>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">AsyncAGIStart</ref>
+				<ref type="managerEvent">AsyncAGIExec</ref>
+				<ref type="application">AGI</ref>
+				<ref type="manager">AGI</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AsyncAGIExec">
@@ -968,6 +1333,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>URL encoded result string from the executed AGI command.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">AsyncAGIStart</ref>
+				<ref type="managerEvent">AsyncAGIEnd</ref>
+				<ref type="application">AGI</ref>
+				<ref type="manager">AGI</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AGIExecStart">
@@ -982,6 +1353,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>Random identification number assigned to the execution of this command.</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">AGIExecEnd</ref>
+				<ref type="application">AGI</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
 	<managerEvent language="en_US" name="AGIExecEnd">
@@ -997,6 +1372,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					<para>The text result reason from AGI</para>
 				</parameter>
 			</syntax>
+			<see-also>
+				<ref type="managerEvent">AGIExecStart</ref>
+				<ref type="application">AGI</ref>
+			</see-also>
 		</managerEventInstance>
 	</managerEvent>
  ***/
@@ -2765,12 +3144,14 @@ static int handle_exec(struct ast_channe
 	ast_verb(3, "AGI Script Executing Application: (%s) Options: (%s)\n", argv[1], argc >= 3 ? argv[2] : "");
 
 	if ((app_to_exec = pbx_findapp(argv[1]))) {
+		ast_channel_lock(chan);
 		if (!(workaround = ast_test_flag(ast_channel_flags(chan), AST_FLAG_DISABLE_WORKAROUNDS))) {
 			ast_set_flag(ast_channel_flags(chan), AST_FLAG_DISABLE_WORKAROUNDS);
 		}
+		ast_channel_unlock(chan);
 		res = pbx_exec(chan, app_to_exec, argc == 2 ? "" : argv[2]);
 		if (!workaround) {
-			ast_clear_flag(ast_channel_flags(chan), AST_FLAG_DISABLE_WORKAROUNDS);
+			ast_channel_clear_flag(chan, AST_FLAG_DISABLE_WORKAROUNDS);
 		}
 	} else {
 		ast_log(LOG_WARNING, "Could not find application (%s)\n", argv[1]);
@@ -2829,6 +3210,10 @@ static int handle_channelstatus(struct a
 
 static int handle_setvariable(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])
 {
+	if (argc != 4) {
+		return RESULT_SHOWUSAGE;
+	}
+
 	if (argv[3])
 		pbx_builtin_setvar_helper(chan, argv[2], argv[3]);
 
@@ -3647,7 +4032,7 @@ static void publish_async_exec_end(struc
 
 static enum agi_result agi_handle_command(struct ast_channel *chan, AGI *agi, char *buf, int dead)
 {
-	const char *argv[MAX_ARGS];
+	const char *argv[MAX_ARGS] = {0};
 	int argc = MAX_ARGS;
 	int res;
 	agi_command *c;
@@ -3683,7 +4068,7 @@ static enum agi_result agi_handle_comman
 				ast_agi_send(agi->fd, chan, "520 Invalid command syntax.  Proper usage not available.\n");
 			} else {
 				ast_agi_send(agi->fd, chan, "520-Invalid command syntax.  Proper usage follows:\n");
-				ast_agi_send(agi->fd, chan, "%s", c->usage);
+				ast_agi_send(agi->fd, chan, "%s\n", c->usage);
 				ast_agi_send(agi->fd, chan, "520 End of proper usage.\n");
 			}
 
@@ -3719,7 +4104,7 @@ static enum agi_result agi_handle_comman
 			break;
 		}
 	} else if (c) {
-		ami_res = "Command Not Permitted on a dead channel";
+		ami_res = "Command Not Permitted on a dead channel or intercept routine";
 		resultcode = 511;
 
 		ast_agi_send(agi->fd, chan, "%d %s\n", resultcode, ami_res);
@@ -3737,23 +4122,6 @@ static enum agi_result agi_handle_comman
 	return AGI_RESULT_SUCCESS;
 }
 
-AST_LIST_HEAD_NOLOCK(deferred_frames, ast_frame);
-
-static void queue_deferred_frames(struct deferred_frames *deferred_frames,
-	struct ast_channel *chan)
-{
-	struct ast_frame *f;
-
-	if (!AST_LIST_EMPTY(deferred_frames)) {
-		ast_channel_lock(chan);
-		while ((f = AST_LIST_REMOVE_HEAD(deferred_frames, frame_list))) {
-			ast_queue_frame_head(chan, f);
-			ast_frfree(f);
-		}
-		ast_channel_unlock(chan);
-	}
-}
-
 static enum agi_result run_agi(struct ast_channel *chan, char *request, AGI *agi, int pid, int *status, int dead, int argc, char *argv[])
 {
 	struct ast_channel *c;
@@ -3772,9 +4140,8 @@ static enum agi_result run_agi(struct as
 	const char *sighup_str;
 	const char *exit_on_hangup_str;
 	int exit_on_hangup;
-	struct deferred_frames deferred_frames;
-
-	AST_LIST_HEAD_INIT_NOLOCK(&deferred_frames);
+	/*! Running in an interception routine is like DeadAGI mode.  No touchy the channel frames. */
+	int in_intercept = ast_channel_get_intercept_mode();
 
 	ast_channel_lock(chan);
 	sighup_str = pbx_builtin_getvar_helper(chan, "AGISIGHUP");
@@ -3809,7 +4176,7 @@ static enum agi_result run_agi(struct as
 			}
 		}
 		ms = -1;
-		if (dead) {
+		if (dead || in_intercept) {
 			c = ast_waitfor_nandfds(&chan, 0, &agi->ctrl, 1, NULL, &outfd, &ms);
 		} else if (!ast_check_hangup(chan)) {
 			c = ast_waitfor_nandfds(&chan, 1, &agi->ctrl, 1, NULL, &outfd, &ms);
@@ -3836,20 +4203,8 @@ static enum agi_result run_agi(struct as
 					/* Write, ignoring errors */
 					if (write(agi->audio, f->data.ptr, f->datalen) < 0) {
 					}
-					ast_frfree(f);
-				} else if (ast_is_deferrable_frame(f)) {
-					struct ast_frame *dup_f;
-
-					if ((dup_f = ast_frisolate(f))) {
-						AST_LIST_INSERT_HEAD(&deferred_frames, dup_f, frame_list);
-					}
-
-					if (dup_f != f) {
-						ast_frfree(f);
-					}
-				} else {
-					ast_frfree(f);
 				}
+				ast_frfree(f);
 			}
 		} else if (outfd > -1) {
 			size_t len = sizeof(buf);
@@ -3897,14 +4252,12 @@ static enum agi_result run_agi(struct as
 				buf[buflen - 1] = '\0';
 			}
 
-			queue_deferred_frames(&deferred_frames, chan);
-
 			if (agidebug)
 				ast_verbose("<%s>AGI Rx << %s\n", ast_channel_name(chan), buf);
-			cmd_status = agi_handle_command(chan, agi, buf, dead);
+			cmd_status = agi_handle_command(chan, agi, buf, dead || in_intercept);
 			switch (cmd_status) {
 			case AGI_RESULT_FAILURE:
-				if (dead || !ast_check_hangup(chan)) {
+				if (dead || in_intercept || !ast_check_hangup(chan)) {
 					/* The failure was not because of a hangup. */
 					returnstatus = AGI_RESULT_FAILURE;
 				}
@@ -3921,8 +4274,6 @@ static enum agi_result run_agi(struct as
 		}
 	}
 
-	queue_deferred_frames(&deferred_frames, chan);
-
 	if (agi->speech) {
 		ast_speech_destroy(agi->speech);
 	}
@@ -4232,15 +4583,30 @@ static int eagi_exec(struct ast_channel
 {
 	int res;
 	struct ast_format *readformat;
+	struct ast_format *requested_format = NULL;
+	const char *requested_format_name;
 
 	if (ast_check_hangup(chan)) {
 		ast_log(LOG_ERROR, "EAGI cannot be run on a dead/hungup channel, please use AGI.\n");
 		return 0;
 	}
+
+	requested_format_name = pbx_builtin_getvar_helper(chan, "EAGI_AUDIO_FORMAT");
+	if (requested_format_name) {
+		requested_format = ast_format_cache_get(requested_format_name);
+		if (requested_format) {
+			ast_verb(3, "<%s> Setting EAGI audio pipe format to %s\n",
+					 ast_channel_name(chan), ast_format_get_name(requested_format));
+		} else {
+			ast_log(LOG_ERROR, "Could not find requested format: %s\n", requested_format_name);
+		}
+	}
+
 	readformat = ao2_bump(ast_channel_readformat(chan));
-	if (ast_set_read_format(chan, ast_format_slin)) {
+	if (ast_set_read_format(chan, requested_format ?: ast_format_slin)) {
 		ast_log(LOG_WARNING, "Unable to set channel '%s' to linear mode\n", ast_channel_name(chan));
-		ao2_ref(readformat, -1);
+		ao2_cleanup(requested_format);
+		ao2_cleanup(readformat);
 		return -1;
 	}
 	res = agi_exec_full(chan, data, 1, 0);
@@ -4250,7 +4616,8 @@ static int eagi_exec(struct ast_channel
 				ast_format_get_name(readformat));
 		}
 	}
-	ao2_ref(readformat, -1);
+	ao2_cleanup(requested_format);
+	ao2_cleanup(readformat);
 	return res;
 }
 
diff -urpN asterisk-13.9.1/res/res_ari.c asterisk-13.17.0/res/res_ari.c
--- asterisk-13.9.1/res/res_ari.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari.c	2017-07-12 13:12:08.000000000 +0200
@@ -147,6 +147,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/astobj2.h"
 #include "asterisk/module.h"
 #include "asterisk/paths.h"
+#include "asterisk/stasis_app.h"
 
 #include <string.h>
 #include <sys/stat.h>
@@ -304,10 +305,11 @@ void ast_ari_response_alloc_failed(struc
 void ast_ari_response_created(struct ast_ari_response *response,
 	const char *url, struct ast_json *message)
 {
+	RAII_VAR(struct stasis_rest_handlers *, root, get_root_handler(), ao2_cleanup);
 	response->message = message;
 	response->response_code = 201;
 	response->response_text = "Created";
-	ast_str_append(&response->headers, 0, "Location: %s\r\n", url);
+	ast_str_append(&response->headers, 0, "Location: /%s%s\r\n", root->path_segment, url);
 }
 
 static void add_allow_header(struct stasis_rest_handlers *handler,
@@ -489,7 +491,7 @@ static void handle_options(struct stasis
 void ast_ari_invoke(struct ast_tcptls_session_instance *ser,
 	const char *uri, enum ast_http_method method,
 	struct ast_variable *get_params, struct ast_variable *headers,
-	struct ast_ari_response *response)
+	struct ast_json *body, struct ast_ari_response *response)
 {
 	RAII_VAR(struct stasis_rest_handlers *, root, NULL, ao2_cleanup);
 	struct stasis_rest_handlers *handler;
@@ -504,8 +506,10 @@ void ast_ari_invoke(struct ast_tcptls_se
 	while ((path_segment = strsep(&path, "/")) && (strlen(path_segment) > 0)) {
 		struct stasis_rest_handlers *found_handler = NULL;
 		int i;
+
 		ast_uri_decode(path_segment, ast_uri_http_legacy);
 		ast_debug(3, "Finding handler for %s\n", path_segment);
+
 		for (i = 0; found_handler == NULL && i < handler->num_children; ++i) {
 			struct stasis_rest_handlers *child = handler->children[i];
 
@@ -567,7 +571,7 @@ void ast_ari_invoke(struct ast_tcptls_se
 		return;
 	}
 
-	callback(ser, get_params, path_vars, headers, response);
+	callback(ser, get_params, path_vars, headers, body, response);
 	if (response->message == NULL && response->response_code == 0) {
 		/* Really should not happen */
 		ast_log(LOG_ERROR, "ARI %s %s not implemented\n",
@@ -578,7 +582,7 @@ void ast_ari_invoke(struct ast_tcptls_se
 	}
 }
 
-void ast_ari_get_docs(const char *uri, struct ast_variable *headers,
+void ast_ari_get_docs(const char *uri, const char *prefix, struct ast_variable *headers,
 			  struct ast_ari_response *response)
 {
 	RAII_VAR(struct ast_str *, absolute_path_builder, NULL, ast_free);
@@ -684,9 +688,15 @@ void ast_ari_get_docs(const char *uri, s
 			}
 		}
 		if (host != NULL) {
-			ast_json_object_set(
-				obj, "basePath",
-				ast_json_stringf("http://%s/ari", host->value));
+			if (prefix != NULL && strlen(prefix) > 0) {
+				ast_json_object_set(
+					obj, "basePath",
+					ast_json_stringf("http://%s%s/ari", host->value,prefix));
+			} else {
+				ast_json_object_set(
+					obj, "basePath",
+					ast_json_stringf("http://%s/ari", host->value));
+			}
 		} else {
 			/* Without the host, we don't have the basePath */
 			ast_json_object_del(obj, "basePath");
@@ -871,6 +881,10 @@ static int ast_ari_callback(struct ast_t
 	RAII_VAR(struct ast_ari_conf_user *, user, NULL, ao2_cleanup);
 	struct ast_ari_response response = {};
 	RAII_VAR(struct ast_variable *, post_vars, NULL, ast_variables_destroy);
+	struct ast_variable *var;
+	const char *app_name = NULL;
+	RAII_VAR(struct ast_json *, body, ast_json_null(), ast_json_free);
+	int debug_app = 0;
 
 	if (!response_body) {
 		ast_http_request_close_on_completion(ser);
@@ -918,6 +932,25 @@ static int ast_ari_callback(struct ast_t
 				"Bad Request", "Error parsing request body");
 			goto request_failed;
 		}
+
+		/* Look for a JSON request entity only if there were no post_vars.
+		 * If there were post_vars, then the request body would already have
+		 * been consumed and can not be read again.
+		 */
+		body = ast_http_get_json(ser, headers);
+		if (!body) {
+			switch (errno) {
+			case EFBIG:
+				ast_ari_response_error(&response, 413, "Request Entity Too Large", "Request body too large");
+				goto request_failed;
+			case ENOMEM:
+				ast_ari_response_error(&response, 500, "Internal Server Error", "Error processing request");
+				goto request_failed;
+			case EIO:
+				ast_ari_response_error(&response, 400, "Bad Request", "Error parsing request body");
+				goto request_failed;
+			}
+		}
 	}
 	if (get_params == NULL) {
 		get_params = post_vars;
@@ -934,6 +967,41 @@ static int ast_ari_callback(struct ast_t
 		get_params = post_vars;
 	}
 
+	/* At this point, get_params will contain post_vars (if any) */
+	app_name = ast_variable_find_in_list(get_params, "app");
+	if (!app_name) {
+		struct ast_json *app = ast_json_object_get(body, "app");
+
+		app_name = (app ? ast_json_string_get(app) : NULL);
+	}
+
+	/* stasis_app_get_debug_by_name returns an "||" of the app's debug flag
+	 * and the global debug flag.
+	 */
+	debug_app = stasis_app_get_debug_by_name(app_name);
+	if (debug_app) {
+		struct ast_str *buf = ast_str_create(512);
+		char *str = ast_json_dump_string_format(body, ast_ari_json_format());
+
+		if (!buf) {
+			ast_http_request_close_on_completion(ser);
+			ast_http_error(ser, 500, "Server Error", "Out of memory");
+			goto request_failed;
+		}
+
+		ast_str_append(&buf, 0, "<--- ARI request received from: %s --->\n",
+			ast_sockaddr_stringify(&ser->remote_address));
+		for (var = headers; var; var = var->next) {
+			ast_str_append(&buf, 0, "%s: %s\n", var->name, var->value);
+		}
+		for (var = get_params; var; var = var->next) {
+			ast_str_append(&buf, 0, "%s: %s\n", var->name, var->value);
+		}
+		ast_verbose("%sbody:\n%s\n\n", ast_str_buffer(buf), str);
+		ast_json_free(str);
+		ast_free(buf);
+	}
+
 	user = authenticate_user(get_params, headers);
 	if (response.response_code > 0) {
 		/* POST parameter processing error. Do nothing. */
@@ -968,11 +1036,11 @@ static int ast_ari_callback(struct ast_t
 			ast_ari_response_error(&response, 405, "Method Not Allowed", "Unsupported method");
 		} else {
 			/* Skip the api-docs prefix */
-			ast_ari_get_docs(strchr(uri, '/') + 1, headers, &response);
+			ast_ari_get_docs(strchr(uri, '/') + 1, urih->prefix, headers, &response);
 		}
 	} else {
 		/* Other RESTful resources */
-		ast_ari_invoke(ser, uri, method, get_params, headers,
+		ast_ari_invoke(ser, uri, method, get_params, headers, body,
 			&response);
 	}
 
@@ -984,6 +1052,7 @@ static int ast_ari_callback(struct ast_t
 	}
 
 request_failed:
+
 	/* If you explicitly want to have no content, set message to
 	 * ast_json_null().
 	 */
@@ -1006,8 +1075,13 @@ request_failed:
 		}
 	}
 
-	ast_debug(3, "Examining ARI response:\n%d %s\n%s\n%s\n", response.response_code,
-		response.response_text, ast_str_buffer(response.headers), ast_str_buffer(response_body));
+	if (debug_app) {
+		ast_verbose("<--- Sending ARI response to %s --->\n%d %s\n%s%s\n\n",
+			ast_sockaddr_stringify(&ser->remote_address), response.response_code,
+			response.response_text, ast_str_buffer(response.headers),
+			ast_str_buffer(response_body));
+	}
+
 	ast_http_send(ser, method, response.response_code,
 		      response.response_text, response.headers, response_body,
 		      0, 0);
@@ -1029,6 +1103,27 @@ static struct ast_http_uri http_uri = {
 	.no_decode_uri = 1,
 };
 
+static int unload_module(void)
+{
+	ast_ari_cli_unregister();
+
+	if (is_enabled()) {
+		ast_debug(3, "Disabling ARI\n");
+		ast_http_uri_unlink(&http_uri);
+	}
+
+	ast_ari_config_destroy();
+
+	ao2_cleanup(root_handler);
+	root_handler = NULL;
+	ast_mutex_destroy(&root_handler_lock);
+
+	ast_json_unref(oom_json);
+	oom_json = NULL;
+
+	return 0;
+}
+
 static int load_module(void)
 {
 	ast_mutex_init(&root_handler_lock);
@@ -1038,7 +1133,7 @@ static int load_module(void)
 		root_handler = root_handler_create();
 	}
 	if (!root_handler) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* oom_json may have been built during a declined load */
@@ -1048,10 +1143,12 @@ static int load_module(void)
 	}
 	if (!oom_json) {
 		/* Ironic */
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_ari_config_init() != 0) {
+		unload_module();
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -1063,33 +1160,13 @@ static int load_module(void)
 	}
 
 	if (ast_ari_cli_register() != 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-static int unload_module(void)
-{
-	ast_ari_cli_unregister();
-
-	if (is_enabled()) {
-		ast_debug(3, "Disabling ARI\n");
-		ast_http_uri_unlink(&http_uri);
-	}
-
-	ast_ari_config_destroy();
-
-	ao2_cleanup(root_handler);
-	root_handler = NULL;
-	ast_mutex_destroy(&root_handler_lock);
-
-	ast_json_unref(oom_json);
-	oom_json = NULL;
-
-	return 0;
-}
-
 static int reload_module(void)
 {
 	char was_enabled = is_enabled();
diff -urpN asterisk-13.9.1/res/res_ari_applications.c asterisk-13.17.0/res/res_ari_applications.c
--- asterisk-13.9.1/res/res_ari_applications.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_applications.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_applications_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_applications_list_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -113,11 +112,10 @@ fin: __attribute__((unused))
 static void ast_ari_applications_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_applications_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -210,11 +208,10 @@ int ast_ari_applications_subscribe_parse
 static void ast_ari_applications_subscribe_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_applications_subscribe_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -272,21 +269,6 @@ static void ast_ari_applications_subscri
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_applications_subscribe_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -376,11 +358,10 @@ int ast_ari_applications_unsubscribe_par
 static void ast_ari_applications_unsubscribe_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_applications_unsubscribe_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -438,21 +419,6 @@ static void ast_ari_applications_unsubsc
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_applications_unsubscribe_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -496,7 +462,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/applications.{format} */
+/*! \brief REST handler for /api-docs/applications.json */
 static struct stasis_rest_handlers applications_applicationName_subscription = {
 	.path_segment = "subscription",
 	.callbacks = {
@@ -506,7 +472,7 @@ static struct stasis_rest_handlers appli
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/applications.{format} */
+/*! \brief REST handler for /api-docs/applications.json */
 static struct stasis_rest_handlers applications_applicationName = {
 	.path_segment = "applicationName",
 	.is_wildcard = 1,
@@ -516,7 +482,7 @@ static struct stasis_rest_handlers appli
 	.num_children = 1,
 	.children = { &applications_applicationName_subscription, }
 };
-/*! \brief REST handler for /api-docs/applications.{format} */
+/*! \brief REST handler for /api-docs/applications.json */
 static struct stasis_rest_handlers applications = {
 	.path_segment = "applications",
 	.callbacks = {
@@ -526,19 +492,28 @@ static struct stasis_rest_handlers appli
 	.children = { &applications_applicationName, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&applications);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&applications);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&applications);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Stasis application resources",
diff -urpN asterisk-13.9.1/res/res_ari_asterisk.c asterisk-13.17.0/res/res_ari_asterisk.c
--- asterisk-13.9.1/res/res_ari_asterisk.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_asterisk.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,11 +62,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_asterisk_get_object_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_get_object_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -135,11 +134,10 @@ int ast_ari_asterisk_update_object_parse
 static void ast_ari_asterisk_update_object_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_update_object_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -157,21 +155,6 @@ static void ast_ari_asterisk_update_obje
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	args.fields = body;
 	ast_ari_asterisk_update_object(headers, &args, response);
 #if defined(AST_DEVMODE)
@@ -218,11 +201,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_delete_object_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_delete_object_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -322,11 +304,10 @@ int ast_ari_asterisk_get_info_parse_body
 static void ast_ari_asterisk_get_info_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_get_info_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -378,21 +359,6 @@ static void ast_ari_asterisk_get_info_cb
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_asterisk_get_info_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -441,10 +407,9 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_list_modules_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_list_modules_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -492,11 +457,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_get_module_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_get_module_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -552,11 +516,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_load_module_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_load_module_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -611,11 +574,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_unload_module_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_unload_module_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -671,11 +633,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_reload_module_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_reload_module_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -731,10 +692,9 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_list_log_channels_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_list_log_channels_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -795,11 +755,10 @@ int ast_ari_asterisk_add_log_parse_body(
 static void ast_ari_asterisk_add_log_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_add_log_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -817,21 +776,6 @@ static void ast_ari_asterisk_add_log_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_asterisk_add_log_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -880,11 +824,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_delete_log_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_delete_log_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -939,11 +882,10 @@ fin: __attribute__((unused))
 static void ast_ari_asterisk_rotate_log_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_rotate_log_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1011,11 +953,10 @@ int ast_ari_asterisk_get_global_var_pars
 static void ast_ari_asterisk_get_global_var_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_get_global_var_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1027,21 +968,6 @@ static void ast_ari_asterisk_get_global_
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_asterisk_get_global_var_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1106,11 +1032,10 @@ int ast_ari_asterisk_set_global_var_pars
 static void ast_ari_asterisk_set_global_var_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_asterisk_set_global_var_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1125,21 +1050,6 @@ static void ast_ari_asterisk_set_global_
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_asterisk_set_global_var_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1178,7 +1088,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_config_dynamic_configClass_objectType_id = {
 	.path_segment = "id",
 	.is_wildcard = 1,
@@ -1190,7 +1100,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_config_dynamic_configClass_objectType = {
 	.path_segment = "objectType",
 	.is_wildcard = 1,
@@ -1199,7 +1109,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_config_dynamic_configClass_objectType_id, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_config_dynamic_configClass = {
 	.path_segment = "configClass",
 	.is_wildcard = 1,
@@ -1208,7 +1118,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_config_dynamic_configClass_objectType, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_config_dynamic = {
 	.path_segment = "dynamic",
 	.callbacks = {
@@ -1216,7 +1126,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_config_dynamic_configClass, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_config = {
 	.path_segment = "config",
 	.callbacks = {
@@ -1224,7 +1134,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_config_dynamic, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_info = {
 	.path_segment = "info",
 	.callbacks = {
@@ -1233,7 +1143,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_modules_moduleName = {
 	.path_segment = "moduleName",
 	.is_wildcard = 1,
@@ -1246,7 +1156,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_modules = {
 	.path_segment = "modules",
 	.callbacks = {
@@ -1255,7 +1165,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_modules_moduleName, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_logging_logChannelName_rotate = {
 	.path_segment = "rotate",
 	.callbacks = {
@@ -1264,7 +1174,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_logging_logChannelName = {
 	.path_segment = "logChannelName",
 	.is_wildcard = 1,
@@ -1275,7 +1185,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_logging_logChannelName_rotate, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_logging = {
 	.path_segment = "logging",
 	.callbacks = {
@@ -1284,7 +1194,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 1,
 	.children = { &asterisk_logging_logChannelName, }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk_variable = {
 	.path_segment = "variable",
 	.callbacks = {
@@ -1294,7 +1204,7 @@ static struct stasis_rest_handlers aster
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/asterisk.{format} */
+/*! \brief REST handler for /api-docs/asterisk.json */
 static struct stasis_rest_handlers asterisk = {
 	.path_segment = "asterisk",
 	.callbacks = {
@@ -1303,19 +1213,28 @@ static struct stasis_rest_handlers aster
 	.children = { &asterisk_config,&asterisk_info,&asterisk_modules,&asterisk_logging,&asterisk_variable, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&asterisk);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&asterisk);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&asterisk);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Asterisk resources",
diff -urpN asterisk-13.9.1/res/res_ari_bridges.c asterisk-13.17.0/res/res_ari_bridges.c
--- asterisk-13.9.1/res/res_ari_bridges.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_bridges.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_bridges_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_list_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -134,11 +133,10 @@ int ast_ari_bridges_create_parse_body(
 static void ast_ari_bridges_create_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_create_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -156,21 +154,6 @@ static void ast_ari_bridges_create_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_create_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -234,11 +217,10 @@ int ast_ari_bridges_create_with_id_parse
 static void ast_ari_bridges_create_with_id_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_create_with_id_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -259,21 +241,6 @@ static void ast_ari_bridges_create_with_
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_create_with_id_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -320,11 +287,10 @@ fin: __attribute__((unused))
 static void ast_ari_bridges_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -379,11 +345,10 @@ fin: __attribute__((unused))
 static void ast_ari_bridges_destroy_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_destroy_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -480,11 +445,10 @@ int ast_ari_bridges_add_channel_parse_bo
 static void ast_ari_bridges_add_channel_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_add_channel_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -545,21 +509,6 @@ static void ast_ari_bridges_add_channel_
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_add_channel_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -650,11 +599,10 @@ int ast_ari_bridges_remove_channel_parse
 static void ast_ari_bridges_remove_channel_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_remove_channel_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -712,21 +660,6 @@ static void ast_ari_bridges_remove_chann
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_remove_channel_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -769,6 +702,127 @@ fin: __attribute__((unused))
 	ast_free(args.channel);
 	return;
 }
+/*!
+ * \brief Parameter parsing callback for /bridges/{bridgeId}/videoSource/{channelId}.
+ * \param get_params GET parameters in the HTTP request.
+ * \param path_vars Path variables extracted from the request.
+ * \param headers HTTP headers.
+ * \param[out] response Response to the HTTP request.
+ */
+static void ast_ari_bridges_set_video_source_cb(
+	struct ast_tcptls_session_instance *ser,
+	struct ast_variable *get_params, struct ast_variable *path_vars,
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
+{
+	struct ast_ari_bridges_set_video_source_args args = {};
+	struct ast_variable *i;
+#if defined(AST_DEVMODE)
+	int is_valid;
+	int code;
+#endif /* AST_DEVMODE */
+
+	for (i = path_vars; i; i = i->next) {
+		if (strcmp(i->name, "bridgeId") == 0) {
+			args.bridge_id = (i->value);
+		} else
+		if (strcmp(i->name, "channelId") == 0) {
+			args.channel_id = (i->value);
+		} else
+		{}
+	}
+	ast_ari_bridges_set_video_source(headers, &args, response);
+#if defined(AST_DEVMODE)
+	code = response->response_code;
+
+	switch (code) {
+	case 0: /* Implementation is still a stub, or the code wasn't set */
+		is_valid = response->message == NULL;
+		break;
+	case 500: /* Internal Server Error */
+	case 501: /* Not Implemented */
+	case 404: /* Bridge or Channel not found */
+	case 409: /* Channel not in Stasis application */
+	case 422: /* Channel not in this Bridge */
+		is_valid = 1;
+		break;
+	default:
+		if (200 <= code && code <= 299) {
+			is_valid = ast_ari_validate_void(
+				response->message);
+		} else {
+			ast_log(LOG_ERROR, "Invalid error response %d for /bridges/{bridgeId}/videoSource/{channelId}\n", code);
+			is_valid = 0;
+		}
+	}
+
+	if (!is_valid) {
+		ast_log(LOG_ERROR, "Response validation failed for /bridges/{bridgeId}/videoSource/{channelId}\n");
+		ast_ari_response_error(response, 500,
+			"Internal Server Error", "Response validation failed");
+	}
+#endif /* AST_DEVMODE */
+
+fin: __attribute__((unused))
+	return;
+}
+/*!
+ * \brief Parameter parsing callback for /bridges/{bridgeId}/videoSource.
+ * \param get_params GET parameters in the HTTP request.
+ * \param path_vars Path variables extracted from the request.
+ * \param headers HTTP headers.
+ * \param[out] response Response to the HTTP request.
+ */
+static void ast_ari_bridges_clear_video_source_cb(
+	struct ast_tcptls_session_instance *ser,
+	struct ast_variable *get_params, struct ast_variable *path_vars,
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
+{
+	struct ast_ari_bridges_clear_video_source_args args = {};
+	struct ast_variable *i;
+#if defined(AST_DEVMODE)
+	int is_valid;
+	int code;
+#endif /* AST_DEVMODE */
+
+	for (i = path_vars; i; i = i->next) {
+		if (strcmp(i->name, "bridgeId") == 0) {
+			args.bridge_id = (i->value);
+		} else
+		{}
+	}
+	ast_ari_bridges_clear_video_source(headers, &args, response);
+#if defined(AST_DEVMODE)
+	code = response->response_code;
+
+	switch (code) {
+	case 0: /* Implementation is still a stub, or the code wasn't set */
+		is_valid = response->message == NULL;
+		break;
+	case 500: /* Internal Server Error */
+	case 501: /* Not Implemented */
+	case 404: /* Bridge not found */
+		is_valid = 1;
+		break;
+	default:
+		if (200 <= code && code <= 299) {
+			is_valid = ast_ari_validate_void(
+				response->message);
+		} else {
+			ast_log(LOG_ERROR, "Invalid error response %d for /bridges/{bridgeId}/videoSource\n", code);
+			is_valid = 0;
+		}
+	}
+
+	if (!is_valid) {
+		ast_log(LOG_ERROR, "Response validation failed for /bridges/{bridgeId}/videoSource\n");
+		ast_ari_response_error(response, 500,
+			"Internal Server Error", "Response validation failed");
+	}
+#endif /* AST_DEVMODE */
+
+fin: __attribute__((unused))
+	return;
+}
 int ast_ari_bridges_start_moh_parse_body(
 	struct ast_json *body,
 	struct ast_ari_bridges_start_moh_args *args)
@@ -792,11 +846,10 @@ int ast_ari_bridges_start_moh_parse_body
 static void ast_ari_bridges_start_moh_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_start_moh_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -814,21 +867,6 @@ static void ast_ari_bridges_start_moh_cb
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_start_moh_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -877,11 +915,10 @@ fin: __attribute__((unused))
 static void ast_ari_bridges_stop_moh_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_stop_moh_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -966,11 +1003,10 @@ int ast_ari_bridges_play_parse_body(
 static void ast_ari_bridges_play_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_play_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1000,21 +1036,6 @@ static void ast_ari_bridges_play_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_play_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1088,11 +1109,10 @@ int ast_ari_bridges_play_with_id_parse_b
 static void ast_ari_bridges_play_with_id_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_play_with_id_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1122,21 +1142,6 @@ static void ast_ari_bridges_play_with_id
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_play_with_id_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1222,11 +1227,10 @@ int ast_ari_bridges_record_parse_body(
 static void ast_ari_bridges_record_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_bridges_record_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1262,21 +1266,6 @@ static void ast_ari_bridges_record_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_bridges_record_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1318,7 +1307,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId_addChannel = {
 	.path_segment = "addChannel",
 	.callbacks = {
@@ -1327,7 +1316,7 @@ static struct stasis_rest_handlers bridg
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId_removeChannel = {
 	.path_segment = "removeChannel",
 	.callbacks = {
@@ -1336,7 +1325,26 @@ static struct stasis_rest_handlers bridg
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
+static struct stasis_rest_handlers bridges_bridgeId_videoSource_channelId = {
+	.path_segment = "channelId",
+	.is_wildcard = 1,
+	.callbacks = {
+		[AST_HTTP_POST] = ast_ari_bridges_set_video_source_cb,
+	},
+	.num_children = 0,
+	.children = {  }
+};
+/*! \brief REST handler for /api-docs/bridges.json */
+static struct stasis_rest_handlers bridges_bridgeId_videoSource = {
+	.path_segment = "videoSource",
+	.callbacks = {
+		[AST_HTTP_DELETE] = ast_ari_bridges_clear_video_source_cb,
+	},
+	.num_children = 1,
+	.children = { &bridges_bridgeId_videoSource_channelId, }
+};
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId_moh = {
 	.path_segment = "moh",
 	.callbacks = {
@@ -1346,7 +1354,7 @@ static struct stasis_rest_handlers bridg
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId_play_playbackId = {
 	.path_segment = "playbackId",
 	.is_wildcard = 1,
@@ -1356,7 +1364,7 @@ static struct stasis_rest_handlers bridg
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId_play = {
 	.path_segment = "play",
 	.callbacks = {
@@ -1365,7 +1373,7 @@ static struct stasis_rest_handlers bridg
 	.num_children = 1,
 	.children = { &bridges_bridgeId_play_playbackId, }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId_record = {
 	.path_segment = "record",
 	.callbacks = {
@@ -1374,7 +1382,7 @@ static struct stasis_rest_handlers bridg
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges_bridgeId = {
 	.path_segment = "bridgeId",
 	.is_wildcard = 1,
@@ -1383,10 +1391,10 @@ static struct stasis_rest_handlers bridg
 		[AST_HTTP_GET] = ast_ari_bridges_get_cb,
 		[AST_HTTP_DELETE] = ast_ari_bridges_destroy_cb,
 	},
-	.num_children = 5,
-	.children = { &bridges_bridgeId_addChannel,&bridges_bridgeId_removeChannel,&bridges_bridgeId_moh,&bridges_bridgeId_play,&bridges_bridgeId_record, }
+	.num_children = 6,
+	.children = { &bridges_bridgeId_addChannel,&bridges_bridgeId_removeChannel,&bridges_bridgeId_videoSource,&bridges_bridgeId_moh,&bridges_bridgeId_play,&bridges_bridgeId_record, }
 };
-/*! \brief REST handler for /api-docs/bridges.{format} */
+/*! \brief REST handler for /api-docs/bridges.json */
 static struct stasis_rest_handlers bridges = {
 	.path_segment = "bridges",
 	.callbacks = {
@@ -1397,19 +1405,28 @@ static struct stasis_rest_handlers bridg
 	.children = { &bridges_bridgeId, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&bridges);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&bridges);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&bridges);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Bridge resources",
diff -urpN asterisk-13.9.1/res/res_ari_channels.c asterisk-13.17.0/res/res_ari_channels.c
--- asterisk-13.9.1/res/res_ari_channels.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_channels.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_channels_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_list_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -157,6 +156,10 @@ int ast_ari_channels_originate_parse_bod
 	if (field) {
 		args->originator = ast_json_string_get(field);
 	}
+	field = ast_json_object_get(body, "formats");
+	if (field) {
+		args->formats = ast_json_string_get(field);
+	}
 	return 0;
 }
 
@@ -170,11 +173,10 @@ int ast_ari_channels_originate_parse_bod
 static void ast_ari_channels_originate_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_originate_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -217,23 +219,11 @@ static void ast_ari_channels_originate_c
 		if (strcmp(i->name, "originator") == 0) {
 			args.originator = (i->value);
 		} else
+		if (strcmp(i->name, "formats") == 0) {
+			args.formats = (i->value);
+		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	args.variables = body;
 	ast_ari_channels_originate(headers, &args, response);
 #if defined(AST_DEVMODE)
@@ -246,6 +236,7 @@ static void ast_ari_channels_originate_c
 	case 500: /* Internal Server Error */
 	case 501: /* Not Implemented */
 	case 400: /* Invalid parameters for originating a channel. */
+	case 409: /* Channel with given unique ID already exists. */
 		is_valid = 1;
 		break;
 	default:
@@ -278,11 +269,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -377,6 +367,10 @@ int ast_ari_channels_originate_with_id_p
 	if (field) {
 		args->originator = ast_json_string_get(field);
 	}
+	field = ast_json_object_get(body, "formats");
+	if (field) {
+		args->formats = ast_json_string_get(field);
+	}
 	return 0;
 }
 
@@ -390,11 +384,10 @@ int ast_ari_channels_originate_with_id_p
 static void ast_ari_channels_originate_with_id_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_originate_with_id_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -434,6 +427,9 @@ static void ast_ari_channels_originate_w
 		if (strcmp(i->name, "originator") == 0) {
 			args.originator = (i->value);
 		} else
+		if (strcmp(i->name, "formats") == 0) {
+			args.formats = (i->value);
+		} else
 		{}
 	}
 	for (i = path_vars; i; i = i->next) {
@@ -442,21 +438,6 @@ static void ast_ari_channels_originate_w
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	args.variables = body;
 	ast_ari_channels_originate_with_id(headers, &args, response);
 #if defined(AST_DEVMODE)
@@ -469,6 +450,7 @@ static void ast_ari_channels_originate_w
 	case 500: /* Internal Server Error */
 	case 501: /* Not Implemented */
 	case 400: /* Invalid parameters for originating a channel. */
+	case 409: /* Channel with given unique ID already exists. */
 		is_valid = 1;
 		break;
 	default:
@@ -514,11 +496,10 @@ int ast_ari_channels_hangup_parse_body(
 static void ast_ari_channels_hangup_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_hangup_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -536,21 +517,6 @@ static void ast_ari_channels_hangup_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_hangup_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -624,11 +590,10 @@ int ast_ari_channels_continue_in_dialpla
 static void ast_ari_channels_continue_in_dialplan_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_continue_in_dialplan_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -655,21 +620,6 @@ static void ast_ari_channels_continue_in
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_continue_in_dialplan_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -731,11 +681,10 @@ int ast_ari_channels_redirect_parse_body
 static void ast_ari_channels_redirect_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_redirect_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -753,21 +702,6 @@ static void ast_ari_channels_redirect_cb
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_redirect_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -818,11 +752,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_answer_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_answer_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -878,11 +811,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_ring_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_ring_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -938,11 +870,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_ring_stop_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_ring_stop_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1027,11 +958,10 @@ int ast_ari_channels_send_dtmf_parse_bod
 static void ast_ari_channels_send_dtmf_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_send_dtmf_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1061,21 +991,6 @@ static void ast_ari_channels_send_dtmf_c
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_send_dtmf_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1138,11 +1053,10 @@ int ast_ari_channels_mute_parse_body(
 static void ast_ari_channels_mute_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_mute_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1160,21 +1074,6 @@ static void ast_ari_channels_mute_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_mute_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1236,11 +1135,10 @@ int ast_ari_channels_unmute_parse_body(
 static void ast_ari_channels_unmute_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_unmute_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1258,21 +1156,6 @@ static void ast_ari_channels_unmute_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_unmute_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1321,11 +1204,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_hold_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_hold_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1381,11 +1263,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_unhold_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_unhold_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1454,11 +1335,10 @@ int ast_ari_channels_start_moh_parse_bod
 static void ast_ari_channels_start_moh_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_start_moh_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1476,21 +1356,6 @@ static void ast_ari_channels_start_moh_c
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_start_moh_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1539,11 +1404,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_stop_moh_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_stop_moh_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1599,11 +1463,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_start_silence_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_start_silence_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1659,11 +1522,10 @@ fin: __attribute__((unused))
 static void ast_ari_channels_stop_silence_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_stop_silence_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1748,11 +1610,10 @@ int ast_ari_channels_play_parse_body(
 static void ast_ari_channels_play_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_play_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1782,21 +1643,6 @@ static void ast_ari_channels_play_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_play_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -1870,11 +1716,10 @@ int ast_ari_channels_play_with_id_parse_
 static void ast_ari_channels_play_with_id_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_play_with_id_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -1904,21 +1749,6 @@ static void ast_ari_channels_play_with_i
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_play_with_id_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -2004,11 +1834,10 @@ int ast_ari_channels_record_parse_body(
 static void ast_ari_channels_record_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_record_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -2044,21 +1873,6 @@ static void ast_ari_channels_record_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_record_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -2122,11 +1936,10 @@ int ast_ari_channels_get_channel_var_par
 static void ast_ari_channels_get_channel_var_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_get_channel_var_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -2144,21 +1957,6 @@ static void ast_ari_channels_get_channel
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_get_channel_var_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -2225,11 +2023,10 @@ int ast_ari_channels_set_channel_var_par
 static void ast_ari_channels_set_channel_var_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_set_channel_var_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -2250,21 +2047,6 @@ static void ast_ari_channels_set_channel
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_set_channel_var_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -2343,11 +2125,10 @@ int ast_ari_channels_snoop_channel_parse
 static void ast_ari_channels_snoop_channel_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_snoop_channel_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -2377,21 +2158,6 @@ static void ast_ari_channels_snoop_chann
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_snoop_channel_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -2465,11 +2231,10 @@ int ast_ari_channels_snoop_channel_with_
 static void ast_ari_channels_snoop_channel_with_id_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_channels_snoop_channel_with_id_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -2499,21 +2264,6 @@ static void ast_ari_channels_snoop_chann
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_channels_snoop_channel_with_id_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -2553,7 +2303,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_continue = {
 	.path_segment = "continue",
 	.callbacks = {
@@ -2562,7 +2312,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_redirect = {
 	.path_segment = "redirect",
 	.callbacks = {
@@ -2571,7 +2321,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_answer = {
 	.path_segment = "answer",
 	.callbacks = {
@@ -2580,7 +2330,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_ring = {
 	.path_segment = "ring",
 	.callbacks = {
@@ -2590,7 +2340,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_dtmf = {
 	.path_segment = "dtmf",
 	.callbacks = {
@@ -2599,7 +2349,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_mute = {
 	.path_segment = "mute",
 	.callbacks = {
@@ -2609,7 +2359,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_hold = {
 	.path_segment = "hold",
 	.callbacks = {
@@ -2619,7 +2369,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_moh = {
 	.path_segment = "moh",
 	.callbacks = {
@@ -2629,7 +2379,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_silence = {
 	.path_segment = "silence",
 	.callbacks = {
@@ -2639,7 +2389,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_play_playbackId = {
 	.path_segment = "playbackId",
 	.is_wildcard = 1,
@@ -2649,7 +2399,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_play = {
 	.path_segment = "play",
 	.callbacks = {
@@ -2658,7 +2408,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 1,
 	.children = { &channels_channelId_play_playbackId, }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_record = {
 	.path_segment = "record",
 	.callbacks = {
@@ -2667,7 +2417,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_variable = {
 	.path_segment = "variable",
 	.callbacks = {
@@ -2677,7 +2427,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_snoop_snoopId = {
 	.path_segment = "snoopId",
 	.is_wildcard = 1,
@@ -2687,7 +2437,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId_snoop = {
 	.path_segment = "snoop",
 	.callbacks = {
@@ -2696,7 +2446,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 1,
 	.children = { &channels_channelId_snoop_snoopId, }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels_channelId = {
 	.path_segment = "channelId",
 	.is_wildcard = 1,
@@ -2708,7 +2458,7 @@ static struct stasis_rest_handlers chann
 	.num_children = 13,
 	.children = { &channels_channelId_continue,&channels_channelId_redirect,&channels_channelId_answer,&channels_channelId_ring,&channels_channelId_dtmf,&channels_channelId_mute,&channels_channelId_hold,&channels_channelId_moh,&channels_channelId_silence,&channels_channelId_play,&channels_channelId_record,&channels_channelId_variable,&channels_channelId_snoop, }
 };
-/*! \brief REST handler for /api-docs/channels.{format} */
+/*! \brief REST handler for /api-docs/channels.json */
 static struct stasis_rest_handlers channels = {
 	.path_segment = "channels",
 	.callbacks = {
@@ -2719,19 +2469,28 @@ static struct stasis_rest_handlers chann
 	.children = { &channels_channelId, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&channels);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&channels);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&channels);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Channel resources",
diff -urpN asterisk-13.9.1/res/res_ari_device_states.c asterisk-13.17.0/res/res_ari_device_states.c
--- asterisk-13.9.1/res/res_ari_device_states.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_device_states.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_device_states_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_device_states_list_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -113,11 +112,10 @@ fin: __attribute__((unused))
 static void ast_ari_device_states_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_device_states_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -184,11 +182,10 @@ int ast_ari_device_states_update_parse_b
 static void ast_ari_device_states_update_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_device_states_update_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -206,21 +203,6 @@ static void ast_ari_device_states_update
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_device_states_update_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -269,11 +251,10 @@ fin: __attribute__((unused))
 static void ast_ari_device_states_delete_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_device_states_delete_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -320,7 +301,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/deviceStates.{format} */
+/*! \brief REST handler for /api-docs/deviceStates.json */
 static struct stasis_rest_handlers deviceStates_deviceName = {
 	.path_segment = "deviceName",
 	.is_wildcard = 1,
@@ -332,7 +313,7 @@ static struct stasis_rest_handlers devic
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/deviceStates.{format} */
+/*! \brief REST handler for /api-docs/deviceStates.json */
 static struct stasis_rest_handlers deviceStates = {
 	.path_segment = "deviceStates",
 	.callbacks = {
@@ -342,19 +323,28 @@ static struct stasis_rest_handlers devic
 	.children = { &deviceStates_deviceName, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&deviceStates);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&deviceStates);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&deviceStates);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Device state resources",
diff -urpN asterisk-13.9.1/res/res_ari_endpoints.c asterisk-13.17.0/res/res_ari_endpoints.c
--- asterisk-13.9.1/res/res_ari_endpoints.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_endpoints.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_endpoints_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_endpoints_list_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -134,11 +133,10 @@ int ast_ari_endpoints_send_message_parse
 static void ast_ari_endpoints_send_message_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_endpoints_send_message_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -156,21 +154,6 @@ static void ast_ari_endpoints_send_messa
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	args.variables = body;
 	ast_ari_endpoints_send_message(headers, &args, response);
 #if defined(AST_DEVMODE)
@@ -216,11 +199,10 @@ fin: __attribute__((unused))
 static void ast_ari_endpoints_list_by_tech_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_endpoints_list_by_tech_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -275,11 +257,10 @@ fin: __attribute__((unused))
 static void ast_ari_endpoints_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_endpoints_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -355,11 +336,10 @@ int ast_ari_endpoints_send_message_to_en
 static void ast_ari_endpoints_send_message_to_endpoint_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_endpoints_send_message_to_endpoint_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -383,21 +363,6 @@ static void ast_ari_endpoints_send_messa
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	args.variables = body;
 	ast_ari_endpoints_send_message_to_endpoint(headers, &args, response);
 #if defined(AST_DEVMODE)
@@ -434,7 +399,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/endpoints.{format} */
+/*! \brief REST handler for /api-docs/endpoints.json */
 static struct stasis_rest_handlers endpoints_sendMessage = {
 	.path_segment = "sendMessage",
 	.callbacks = {
@@ -443,7 +408,7 @@ static struct stasis_rest_handlers endpo
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/endpoints.{format} */
+/*! \brief REST handler for /api-docs/endpoints.json */
 static struct stasis_rest_handlers endpoints_tech_resource_sendMessage = {
 	.path_segment = "sendMessage",
 	.callbacks = {
@@ -452,7 +417,7 @@ static struct stasis_rest_handlers endpo
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/endpoints.{format} */
+/*! \brief REST handler for /api-docs/endpoints.json */
 static struct stasis_rest_handlers endpoints_tech_resource = {
 	.path_segment = "resource",
 	.is_wildcard = 1,
@@ -462,7 +427,7 @@ static struct stasis_rest_handlers endpo
 	.num_children = 1,
 	.children = { &endpoints_tech_resource_sendMessage, }
 };
-/*! \brief REST handler for /api-docs/endpoints.{format} */
+/*! \brief REST handler for /api-docs/endpoints.json */
 static struct stasis_rest_handlers endpoints_tech = {
 	.path_segment = "tech",
 	.is_wildcard = 1,
@@ -472,7 +437,7 @@ static struct stasis_rest_handlers endpo
 	.num_children = 1,
 	.children = { &endpoints_tech_resource, }
 };
-/*! \brief REST handler for /api-docs/endpoints.{format} */
+/*! \brief REST handler for /api-docs/endpoints.json */
 static struct stasis_rest_handlers endpoints = {
 	.path_segment = "endpoints",
 	.callbacks = {
@@ -482,19 +447,28 @@ static struct stasis_rest_handlers endpo
 	.children = { &endpoints_sendMessage,&endpoints_tech, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&endpoints);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&endpoints);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&endpoints);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Endpoint resources",
diff -urpN asterisk-13.9.1/res/res_ari_events.c asterisk-13.17.0/res/res_ari_events.c
--- asterisk-13.9.1/res/res_ari_events.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_events.c	2017-07-12 13:12:08.000000000 +0200
@@ -288,11 +288,10 @@ int ast_ari_events_user_event_parse_body
 static void ast_ari_events_user_event_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_events_user_event_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -353,21 +352,6 @@ static void ast_ari_events_user_event_cb
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	args.variables = body;
 	ast_ari_events_user_event(headers, &args, response);
 #if defined(AST_DEVMODE)
@@ -407,7 +391,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/events.{format} */
+/*! \brief REST handler for /api-docs/events.json */
 static struct stasis_rest_handlers events_user_eventName = {
 	.path_segment = "eventName",
 	.is_wildcard = 1,
@@ -417,7 +401,7 @@ static struct stasis_rest_handlers event
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/events.{format} */
+/*! \brief REST handler for /api-docs/events.json */
 static struct stasis_rest_handlers events_user = {
 	.path_segment = "user",
 	.callbacks = {
@@ -425,7 +409,7 @@ static struct stasis_rest_handlers event
 	.num_children = 1,
 	.children = { &events_user_eventName, }
 };
-/*! \brief REST handler for /api-docs/events.{format} */
+/*! \brief REST handler for /api-docs/events.json */
 static struct stasis_rest_handlers events = {
 	.path_segment = "events",
 	.callbacks = {
@@ -434,30 +418,6 @@ static struct stasis_rest_handlers event
 	.children = { &events_user, }
 };
 
-static int load_module(void)
-{
-	int res = 0;
-	struct ast_websocket_protocol *protocol;
-
-	events.ws_server = ast_websocket_server_create();
-	if (!events.ws_server) {
-		return AST_MODULE_LOAD_FAILURE;
-	}
-
-	protocol = ast_websocket_sub_protocol_alloc("ari");
-	if (!protocol) {
-		ao2_ref(events.ws_server, -1);
-		events.ws_server = NULL;
-		return AST_MODULE_LOAD_FAILURE;
-	}
-	protocol->session_attempted = ast_ari_events_event_websocket_ws_attempted_cb;
-	protocol->session_established = ast_ari_events_event_websocket_ws_established_cb;
-	res |= ast_websocket_server_add_protocol2(events.ws_server, protocol);
-	stasis_app_ref();
-	res |= ast_ari_add_handler(&events);
-	return res;
-}
-
 static int unload_module(void)
 {
 	ast_ari_remove_handler(&events);
@@ -467,6 +427,42 @@ static int unload_module(void)
 	return 0;
 }
 
+static int load_module(void)
+{
+	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+	/* This is scoped to not conflict with CHECK_ARI_MODULE_LOADED */
+	{
+		struct ast_websocket_protocol *protocol;
+
+		events.ws_server = ast_websocket_server_create();
+		if (!events.ws_server) {
+			return AST_MODULE_LOAD_DECLINE;
+		}
+
+		protocol = ast_websocket_sub_protocol_alloc("ari");
+		if (!protocol) {
+			ao2_ref(events.ws_server, -1);
+			events.ws_server = NULL;
+			return AST_MODULE_LOAD_DECLINE;
+		}
+		protocol->session_attempted = ast_ari_events_event_websocket_ws_attempted_cb;
+		protocol->session_established = ast_ari_events_event_websocket_ws_established_cb;
+		res |= ast_websocket_server_add_protocol2(events.ws_server, protocol);
+	}
+
+	stasis_app_ref();
+	res |= ast_ari_add_handler(&events);
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - WebSocket resource",
 	.support_level = AST_MODULE_SUPPORT_CORE,
 	.load = load_module,
diff -urpN asterisk-13.9.1/res/res_ari_mailboxes.c asterisk-13.17.0/res/res_ari_mailboxes.c
--- asterisk-13.9.1/res/res_ari_mailboxes.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_mailboxes.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_mailboxes_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_mailboxes_list_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -113,11 +112,10 @@ fin: __attribute__((unused))
 static void ast_ari_mailboxes_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_mailboxes_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -189,11 +187,10 @@ int ast_ari_mailboxes_update_parse_body(
 static void ast_ari_mailboxes_update_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_mailboxes_update_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -214,21 +211,6 @@ static void ast_ari_mailboxes_update_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_mailboxes_update_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -276,11 +258,10 @@ fin: __attribute__((unused))
 static void ast_ari_mailboxes_delete_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_mailboxes_delete_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -326,7 +307,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/mailboxes.{format} */
+/*! \brief REST handler for /api-docs/mailboxes.json */
 static struct stasis_rest_handlers mailboxes_mailboxName = {
 	.path_segment = "mailboxName",
 	.is_wildcard = 1,
@@ -338,7 +319,7 @@ static struct stasis_rest_handlers mailb
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/mailboxes.{format} */
+/*! \brief REST handler for /api-docs/mailboxes.json */
 static struct stasis_rest_handlers mailboxes = {
 	.path_segment = "mailboxes",
 	.callbacks = {
@@ -348,19 +329,28 @@ static struct stasis_rest_handlers mailb
 	.children = { &mailboxes_mailboxName, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&mailboxes);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&mailboxes);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&mailboxes);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Mailboxes resources",
diff -urpN asterisk-13.9.1/res/res_ari_model.c asterisk-13.17.0/res/res_ari_model.c
--- asterisk-13.9.1/res/res_ari_model.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_model.c	2017-07-12 13:12:08.000000000 +0200
@@ -192,7 +192,7 @@ static int load_module(void)
 		REG_EXTENDED | REG_ICASE | REG_NOSUB);
 
 	if (res != 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/res/res_ari_playbacks.c asterisk-13.17.0/res/res_ari_playbacks.c
--- asterisk-13.9.1/res/res_ari_playbacks.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_playbacks.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,11 +62,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_playbacks_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_playbacks_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -121,11 +120,10 @@ fin: __attribute__((unused))
 static void ast_ari_playbacks_stop_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_playbacks_stop_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -193,11 +191,10 @@ int ast_ari_playbacks_control_parse_body
 static void ast_ari_playbacks_control_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_playbacks_control_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -215,21 +212,6 @@ static void ast_ari_playbacks_control_cb
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_playbacks_control_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -270,7 +252,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/playbacks.{format} */
+/*! \brief REST handler for /api-docs/playbacks.json */
 static struct stasis_rest_handlers playbacks_playbackId_control = {
 	.path_segment = "control",
 	.callbacks = {
@@ -279,7 +261,7 @@ static struct stasis_rest_handlers playb
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/playbacks.{format} */
+/*! \brief REST handler for /api-docs/playbacks.json */
 static struct stasis_rest_handlers playbacks_playbackId = {
 	.path_segment = "playbackId",
 	.is_wildcard = 1,
@@ -290,7 +272,7 @@ static struct stasis_rest_handlers playb
 	.num_children = 1,
 	.children = { &playbacks_playbackId_control, }
 };
-/*! \brief REST handler for /api-docs/playbacks.{format} */
+/*! \brief REST handler for /api-docs/playbacks.json */
 static struct stasis_rest_handlers playbacks = {
 	.path_segment = "playbacks",
 	.callbacks = {
@@ -299,19 +281,28 @@ static struct stasis_rest_handlers playb
 	.children = { &playbacks_playbackId, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&playbacks);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&playbacks);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&playbacks);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Playback control resources",
diff -urpN asterisk-13.9.1/res/res_ari_recordings.c asterisk-13.17.0/res/res_ari_recordings.c
--- asterisk-13.9.1/res/res_ari_recordings.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_recordings.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,10 +62,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_recordings_list_stored_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_list_stored_args args = {};
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -113,11 +112,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_get_stored_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_get_stored_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -172,11 +170,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_delete_stored_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_delete_stored_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -244,11 +241,10 @@ int ast_ari_recordings_copy_stored_parse
 static void ast_ari_recordings_copy_stored_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_copy_stored_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -266,21 +262,6 @@ static void ast_ari_recordings_copy_stor
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_recordings_copy_stored_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -329,11 +310,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_get_live_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_get_live_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -388,11 +368,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_cancel_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_cancel_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -447,11 +426,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_stop_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_stop_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -506,11 +484,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_pause_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_pause_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -566,11 +543,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_unpause_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_unpause_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -626,11 +602,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_mute_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_mute_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -686,11 +661,10 @@ fin: __attribute__((unused))
 static void ast_ari_recordings_unmute_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_recordings_unmute_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -737,7 +711,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_stored_recordingName_copy = {
 	.path_segment = "copy",
 	.callbacks = {
@@ -746,7 +720,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_stored_recordingName = {
 	.path_segment = "recordingName",
 	.is_wildcard = 1,
@@ -757,7 +731,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 1,
 	.children = { &recordings_stored_recordingName_copy, }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_stored = {
 	.path_segment = "stored",
 	.callbacks = {
@@ -766,7 +740,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 1,
 	.children = { &recordings_stored_recordingName, }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_live_recordingName_stop = {
 	.path_segment = "stop",
 	.callbacks = {
@@ -775,7 +749,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_live_recordingName_pause = {
 	.path_segment = "pause",
 	.callbacks = {
@@ -785,7 +759,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_live_recordingName_mute = {
 	.path_segment = "mute",
 	.callbacks = {
@@ -795,7 +769,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_live_recordingName = {
 	.path_segment = "recordingName",
 	.is_wildcard = 1,
@@ -806,7 +780,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 3,
 	.children = { &recordings_live_recordingName_stop,&recordings_live_recordingName_pause,&recordings_live_recordingName_mute, }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings_live = {
 	.path_segment = "live",
 	.callbacks = {
@@ -814,7 +788,7 @@ static struct stasis_rest_handlers recor
 	.num_children = 1,
 	.children = { &recordings_live_recordingName, }
 };
-/*! \brief REST handler for /api-docs/recordings.{format} */
+/*! \brief REST handler for /api-docs/recordings.json */
 static struct stasis_rest_handlers recordings = {
 	.path_segment = "recordings",
 	.callbacks = {
@@ -823,19 +797,28 @@ static struct stasis_rest_handlers recor
 	.children = { &recordings_stored,&recordings_live, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&recordings);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&recordings);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&recordings);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Recording resources",
diff -urpN asterisk-13.9.1/res/res_ari_sounds.c asterisk-13.17.0/res/res_ari_sounds.c
--- asterisk-13.9.1/res/res_ari_sounds.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_ari_sounds.c	2017-07-12 13:12:08.000000000 +0200
@@ -79,11 +79,10 @@ int ast_ari_sounds_list_parse_body(
 static void ast_ari_sounds_list_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_sounds_list_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -98,21 +97,6 @@ static void ast_ari_sounds_list_cb(
 		} else
 		{}
 	}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 	if (ast_ari_sounds_list_parse_body(body, &args)) {
 		ast_ari_response_alloc_failed(response);
 		goto fin;
@@ -159,11 +143,10 @@ fin: __attribute__((unused))
 static void ast_ari_sounds_get_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_sounds_get_args args = {};
 	struct ast_variable *i;
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -208,7 +191,7 @@ fin: __attribute__((unused))
 	return;
 }
 
-/*! \brief REST handler for /api-docs/sounds.{format} */
+/*! \brief REST handler for /api-docs/sounds.json */
 static struct stasis_rest_handlers sounds_soundId = {
 	.path_segment = "soundId",
 	.is_wildcard = 1,
@@ -218,7 +201,7 @@ static struct stasis_rest_handlers sound
 	.num_children = 0,
 	.children = {  }
 };
-/*! \brief REST handler for /api-docs/sounds.{format} */
+/*! \brief REST handler for /api-docs/sounds.json */
 static struct stasis_rest_handlers sounds = {
 	.path_segment = "sounds",
 	.callbacks = {
@@ -228,19 +211,28 @@ static struct stasis_rest_handlers sound
 	.children = { &sounds_soundId, }
 };
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&sounds);
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&sounds);
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&sounds);
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - Sound resources",
diff -urpN asterisk-13.9.1/res/res_calendar.c asterisk-13.17.0/res/res_calendar.c
--- asterisk-13.9.1/res/res_calendar.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_calendar.c	2017-07-12 13:12:08.000000000 +0200
@@ -1882,7 +1882,7 @@ static int load_module(void)
 {
 	if (!(calendars = ao2_container_alloc(CALENDAR_BUCKETS, calendar_hash_fn, calendar_cmp_fn))) {
 		ast_log(LOG_ERROR, "Unable to allocate calendars container!\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (load_config(0)) {
@@ -1896,7 +1896,9 @@ static int load_module(void)
 
 	if (!(sched = ast_sched_context_create())) {
 		ast_log(LOG_ERROR, "Unable to create sched context\n");
-		return AST_MODULE_LOAD_FAILURE;
+		ast_config_destroy(calendar_config);
+		calendar_config = NULL;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_pthread_create_background(&refresh_thread, NULL, do_refresh, NULL) < 0) {
diff -urpN asterisk-13.9.1/res/res_calendar_caldav.c asterisk-13.17.0/res/res_calendar_caldav.c
--- asterisk-13.9.1/res/res_calendar_caldav.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_calendar_caldav.c	2017-07-12 13:12:08.000000000 +0200
@@ -482,7 +482,7 @@ static void handle_start_element(void *d
 {
 	struct xmlstate *state = data;
 
-	if (!xmlStrcasecmp(fullname, BAD_CAST "C:calendar-data")) {
+	if (!xmlStrcasecmp(fullname, BAD_CAST "C:calendar-data") || !xmlStrcasecmp(fullname, BAD_CAST "caldav:calendar-data")) {
 		state->in_caldata = 1;
 		ast_str_reset(state->cdata);
 	}
@@ -496,7 +496,7 @@ static void handle_end_element(void *dat
 	icalcomponent *iter;
 	icalcomponent *comp;
 
-	if (xmlStrcasecmp(name, BAD_CAST "C:calendar-data")) {
+	if (xmlStrcasecmp(name, BAD_CAST "C:calendar-data") && xmlStrcasecmp(name, BAD_CAST "caldav:calendar-data")) {
 		return;
 	}
 
diff -urpN asterisk-13.9.1/res/res_chan_stats.c asterisk-13.17.0/res/res_chan_stats.c
--- asterisk-13.9.1/res/res_chan_stats.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_chan_stats.c	2017-07-12 13:12:08.000000000 +0200
@@ -150,13 +150,22 @@ static void default_route(void *data, st
 	}
 }
 
+static int unload_module(void)
+{
+	stasis_unsubscribe_and_join(sub);
+	sub = NULL;
+	stasis_message_router_unsubscribe_and_join(router);
+	router = NULL;
+	return 0;
+}
+
 static int load_module(void)
 {
 	/* You can create a message router to route messages by type */
 	router = stasis_message_router_create(
 		ast_channel_topic_all_cached());
 	if (!router) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	stasis_message_router_add(router, stasis_cache_update_type(),
 		updates, NULL);
@@ -165,20 +174,12 @@ static int load_module(void)
 	/* Or a subscription to receive all of the messages from a topic */
 	sub = stasis_subscribe(ast_channel_topic_all(), statsmaker, NULL);
 	if (!sub) {
-		return AST_MODULE_LOAD_FAILURE;
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
-static int unload_module(void)
-{
-	stasis_unsubscribe_and_join(sub);
-	sub = NULL;
-	stasis_message_router_unsubscribe_and_join(router);
-	router = NULL;
-	return 0;
-}
-
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "Example of how to use Stasis",
 	.support_level = AST_MODULE_SUPPORT_EXTENDED,
 	.load = load_module,
diff -urpN asterisk-13.9.1/res/res_clioriginate.c asterisk-13.17.0/res/res_clioriginate.c
--- asterisk-13.9.1/res/res_clioriginate.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_clioriginate.c	2017-07-12 13:12:08.000000000 +0200
@@ -74,7 +74,9 @@ static char *orig_app(int fd, const char
 		return CLI_FAILURE;
 	}
 	ast_format_cap_append(cap, ast_format_slin, 0);
-	ast_pbx_outgoing_app(chantech, cap, chandata, TIMEOUT * 1000, app, appdata, &reason, 0, NULL, NULL, NULL, NULL, NULL, NULL);
+	ast_pbx_outgoing_app(chantech, cap, chandata, TIMEOUT * 1000, app, appdata,
+			&reason, AST_OUTGOING_NO_WAIT, NULL, NULL, NULL, NULL,
+			NULL, NULL);
 	ao2_ref(cap, -1);
 
 	return CLI_SUCCESS;
@@ -118,7 +120,9 @@ static char *orig_exten(int fd, const ch
 		return CLI_FAILURE;
 	}
 	ast_format_cap_append(cap, ast_format_slin, 0);
-	ast_pbx_outgoing_exten(chantech, cap, chandata, TIMEOUT * 1000, context, exten, 1, &reason, 0, NULL, NULL, NULL, NULL, NULL, 0, NULL);
+	ast_pbx_outgoing_exten(chantech, cap, chandata, TIMEOUT * 1000, context,
+			exten, 1, &reason, AST_OUTGOING_NO_WAIT, NULL, NULL,
+			NULL, NULL, NULL, 0, NULL);
 	ao2_ref(cap, -1);
 
 	return CLI_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_config_curl.c asterisk-13.17.0/res/res_config_curl.c
--- asterisk-13.9.1/res/res_config_curl.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_config_curl.c	2017-07-12 13:12:08.000000000 +0200
@@ -184,7 +184,8 @@ static struct ast_config *realtime_multi
 			continue;
 		}
 
-		if (!(cat = ast_category_new("", "", 99999))) {
+		cat = ast_category_new_anonymous();
+		if (!cat) {
 			continue;
 		}
 
@@ -571,8 +572,10 @@ static struct ast_config *config_curl(co
 		}
 
 		if (!cat || strcmp(category, cur_cat) || last_cat_metric != cat_metric) {
-			if (!(cat = ast_category_new(category, "", 99999)))
+			cat = ast_category_new_dynamic(category);
+			if (!cat) {
 				break;
+			}
 			cur_cat = category;
 			last_cat_metric = cat_metric;
 			ast_category_append(cfg, cat);
diff -urpN asterisk-13.9.1/res/res_config_ldap.c asterisk-13.17.0/res/res_config_ldap.c
--- asterisk-13.9.1/res/res_config_ldap.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_config_ldap.c	2017-07-12 13:12:08.000000000 +0200
@@ -124,7 +124,7 @@ static struct ldap_table_config *table_c
 
 	if (table_name) {
 		if (!(p->table_name = ast_strdup(table_name))) {
-			free(p);
+			ast_free(p);
 			return NULL;
 		}
 	}
@@ -192,7 +192,7 @@ static int semicolon_count_var(struct as
 		return 0;
 	}
 
-	ast_debug(2, "LINE(%d) semicolon_count_var: %s\n", __LINE__, var_value->value);
+	ast_debug(2, "semicolon_count_var: %s\n", var_value->value);
 
 	return semicolon_count_str(var_value->value);
 }
@@ -238,7 +238,7 @@ static void table_configs_free(void)
 		if (c->attributes) {
 			ast_variables_destroy(c->attributes);
 		}
-		free(c);
+		ast_free(c);
 	}
 
 	base_table_config = NULL;
@@ -332,7 +332,7 @@ static struct ast_variable *realtime_lda
 			for (v = values; *v; v++) {
 				value = *v;
 				valptr = value->bv_val;
-				ast_debug(2, "LINE(%d) attribute_name: %s LDAP value: %s\n", __LINE__, attribute_name, valptr);
+				ast_debug(2, "attribute_name: %s LDAP value: %s\n", attribute_name, valptr);
 				if (is_realmed_password_attribute) {
 					if (!strncasecmp(valptr, "{md5}", 5)) {
 						valptr += 5;
@@ -424,7 +424,7 @@ static struct ast_variable **realtime_ld
 	 * value in \a variable_value; otherwise, we keep \a vars static and increase the length of the linked list of variables in the array element.
 	 * This memory must be freed outside of this function.
 	 */
-	vars = ast_calloc(sizeof(struct ast_variable *), tot_count + 1);
+	vars = ast_calloc(tot_count + 1, sizeof(struct ast_variable *));
 
 	ldap_entry = ldap_first_entry(ldapConn, ldap_result_msg);
 
@@ -469,7 +469,7 @@ static struct ast_variable **realtime_ld
 								delim_value = ast_strdup(valptr);
 
 								if ((delim_tot_count = semicolon_count_str(delim_value)) > 0) {
-									ast_debug(4, "LINE(%d) is delimited %d times: %s\n", __LINE__, delim_tot_count, delim_value);
+									ast_debug(4, "is delimited %d times: %s\n", delim_tot_count, delim_value);
 									is_delimited = 1;
 								}
 							}
@@ -479,11 +479,11 @@ static struct ast_variable **realtime_ld
 								/* for non-Static RealTime, first */
 
 								for (i = pos; !ast_strlen_zero(valptr + i); i++) {
-									ast_debug(4, "LINE(%d) DELIM pos: %d i: %d\n", __LINE__, pos, i);
+									ast_debug(4, "DELIM pos: %d i: %d\n", pos, i);
 									if (delim_value[i] == ';') {
 										delim_value[i] = '\0';
 
-										ast_debug(2, "LINE(%d) DELIM - attribute_name: %s value: %s pos: %d\n", __LINE__, attribute_name, &delim_value[pos], pos);
+										ast_debug(2, "DELIM - attribute_name: %s value: %s pos: %d\n", attribute_name, &delim_value[pos], pos);
 
 										if (prev) {
 											prev->next = ast_variable_new(attribute_name, &delim_value[pos], table_config->table_name);
@@ -501,9 +501,9 @@ static struct ast_variable **realtime_ld
 									}
 								}
 								if (ast_strlen_zero(valptr + i)) {
-									ast_debug(4, "LINE(%d) DELIM pos: %d i: %d delim_count: %d\n", __LINE__, pos, i, delim_count);
+									ast_debug(4, "DELIM pos: %d i: %d delim_count: %d\n", pos, i, delim_count);
 									/* Last delimited value */
-									ast_debug(4, "LINE(%d) DELIM - attribute_name: %s value: %s pos: %d\n", __LINE__, attribute_name, &delim_value[pos], pos);
+									ast_debug(4, "DELIM - attribute_name: %s value: %s pos: %d\n", attribute_name, &delim_value[pos], pos);
 									if (prev) {
 										prev->next = ast_variable_new(attribute_name, &delim_value[pos], table_config->table_name);
 										if (prev->next) {
@@ -516,17 +516,17 @@ static struct ast_variable **realtime_ld
 									is_delimited = 0;
 									pos = 0;
 								}
-								free(delim_value);
+								ast_free(delim_value);
 								delim_value = NULL;
 
-								ast_debug(4, "LINE(%d) DELIM pos: %d i: %d\n", __LINE__, pos, i);
+								ast_debug(4, "DELIM pos: %d i: %d\n", pos, i);
 							} else {
 								/* not delimited */
 								if (delim_value) {
-									free(delim_value);
+									ast_free(delim_value);
 									delim_value = NULL;
 								}
-								ast_debug(2, "LINE(%d) attribute_name: %s value: %s\n", __LINE__, attribute_name, valptr);
+								ast_debug(2, "attribute_name: %s value: %s\n", attribute_name, valptr);
 
 								if (prev) {
 									prev->next = ast_variable_new(attribute_name, valptr, table_config->table_name);
@@ -550,7 +550,7 @@ static struct ast_variable **realtime_ld
 					const struct ast_variable *tmpdebug = variable_named(var, "variable_name");
 					const struct ast_variable *tmpdebug2 = variable_named(var, "variable_value");
 					if (tmpdebug && tmpdebug2) {
-						ast_debug(3, "LINE(%d) Added to vars - %s = %s\n", __LINE__, tmpdebug->value, tmpdebug2->value);
+						ast_debug(3, "Added to vars - %s = %s\n", tmpdebug->value, tmpdebug2->value);
 					}
 				}
 				vars[entry_index++] = var;
@@ -561,7 +561,7 @@ static struct ast_variable **realtime_ld
 		} while (delim_count <= delim_tot_count && static_table_config == table_config);
 
 		if (static_table_config != table_config) {
-			ast_debug(3, "LINE(%d) Added to vars - non static\n", __LINE__);
+			ast_debug(3, "Added to vars - non static\n");
 
 			vars[entry_index++] = var;
 			prev = NULL;
@@ -756,6 +756,47 @@ static void append_var_and_value_to_filt
 	ast_str_append(filter, 0, "(%s=%s)", name, value);
 }
 
+/*!
+ * \internal
+ * \brief Create an LDAP filter using search fields
+ *
+ * \param config the \c ldap_table_config for this search
+ * \param fields the \c ast_variable criteria to include
+ *
+ * \returns an \c ast_str pointer on success, NULL otherwise.
+ */
+static struct ast_str *create_lookup_filter(struct ldap_table_config *config, const struct ast_variable *fields)
+{
+	struct ast_str *filter;
+	const struct ast_variable *field;
+
+	filter = ast_str_create(80);
+	if (!filter) {
+		return NULL;
+	}
+
+	/*
+	 * Create the filter with the table additional filter and the
+	 * parameter/value pairs we were given
+	 */
+	ast_str_append(&filter, 0, "(&");
+	if (config && config->additional_filter) {
+		ast_str_append(&filter, 0, "%s", config->additional_filter);
+	}
+	if (config != base_table_config
+		&& base_table_config
+		&& base_table_config->additional_filter) {
+		ast_str_append(&filter, 0, "%s", base_table_config->additional_filter);
+	}
+	/* Append the lookup fields */
+	for (field = fields; field; field = field->next) {
+		append_var_and_value_to_filter(&filter, config, field->name, field->value);
+	}
+	ast_str_append(&filter, 0, ")");
+
+	return filter;
+}
+
 /*! \brief LDAP base function 
  * \return a null terminated array of ast_variable (one per entry) or NULL if no entry is found or if an error occured
  * caller should free the returned array and ast_variables
@@ -782,16 +823,9 @@ static struct ast_variable **realtime_ld
 		return NULL;
 	} 
 
-	if (!(filter = ast_str_create(80))) {
-		ast_log(LOG_ERROR, "Can't initialize data structures.n");
-		ast_free(clean_basedn);
-		return NULL;
-	}
-
 	if (!field) {
 		ast_log(LOG_ERROR, "Realtime retrieval requires at least 1 parameter"
 			" and 1 value to search on.\n");
-		ast_free(filter);
 		ast_free(clean_basedn);
 		return NULL;
 	}
@@ -801,7 +835,6 @@ static struct ast_variable **realtime_ld
 	/* We now have our complete statement; Lets connect to the server and execute it.  */
 	if (!ldap_reconnect()) {
 		ast_mutex_unlock(&ldap_lock);
-		ast_free(filter);
 		ast_free(clean_basedn);
 		return NULL;
 	}
@@ -810,30 +843,16 @@ static struct ast_variable **realtime_ld
 	if (!table_config) {
 		ast_log(LOG_WARNING, "No table named '%s'.\n", table_name);
 		ast_mutex_unlock(&ldap_lock);
-		ast_free(filter);
 		ast_free(clean_basedn);
 		return NULL;
 	}
 
-	ast_str_append(&filter, 0, "(&");
-
-	if (table_config && table_config->additional_filter) {
-		ast_str_append(&filter, 0, "%s", table_config->additional_filter);
-	}
-	if (table_config != base_table_config && base_table_config && 
-		base_table_config->additional_filter) {
-		ast_str_append(&filter, 0, "%s", base_table_config->additional_filter);
-	}
-
-	/* Create the first part of the query using the first parameter/value pairs we just extracted.
-	 * If there is only 1 set, then we have our query. Otherwise, loop thru the list and concat
-	 */
-
-	append_var_and_value_to_filter(&filter, table_config, field->name, field->value);
-	while ((field = field->next)) {
-		append_var_and_value_to_filter(&filter, table_config, field->name, field->value);
+	filter = create_lookup_filter(table_config, fields);
+	if (!filter) {
+		ast_mutex_unlock(&ldap_lock);
+		ast_free(clean_basedn);
+		return NULL;
 	}
-	ast_str_append(&filter, 0, ")");
 
 	do {
 		/* freeing ldap_result further down */
@@ -928,13 +947,8 @@ static struct ast_variable **realtime_ld
 		}
 	}
 
-	if (filter) {
-		ast_free(filter);
-	}
-
-	if (clean_basedn) {
-		ast_free(clean_basedn);
-	}
+	ast_free(filter);
+	ast_free(clean_basedn);
 
 	ast_mutex_unlock(&ldap_lock);
 
@@ -1007,7 +1021,7 @@ static struct ast_variable *realtime_lda
 			}
 			p++;
 		}
-		free(vars);
+		ast_free(vars);
 	}
 	return var;
 }
@@ -1045,10 +1059,8 @@ static struct ast_config *realtime_multi
 			struct ast_variable **p = vars;
 
 			while (*p) {
-				struct ast_category *cat = NULL;
-				cat = ast_category_new("", table_name, -1);
+				struct ast_category *cat = ast_category_new_anonymous();
 				if (!cat) {
-					ast_log(LOG_ERROR, "Unable to create a new category!\n");
 					break;
 				} else {
 					struct ast_variable *var = *p;
@@ -1066,7 +1078,7 @@ static struct ast_config *realtime_multi
 				p++;
 			}
 		}
-		free(vars);
+		ast_free(vars);
 	}
 	return cfg;
 
@@ -1138,7 +1150,7 @@ static struct ast_config *config_ldap(co
 	 * first, and since the data could easily exceed stack size, this is
 	 * allocated from the heap.
 	 */
-	if (!(categories = ast_calloc(sizeof(*categories), vars_count))) {
+	if (!(categories = ast_calloc(vars_count, sizeof(*categories)))) {
 		return NULL;
 	}
 
@@ -1197,7 +1209,7 @@ static struct ast_config *config_ldap(co
 		if (!last_category || strcmp(last_category, categories[i].name) ||
 			last_category_metric != categories[i].metric) {
 
-			cur_cat = ast_category_new(categories[i].name, table_name, -1);
+			cur_cat = ast_category_new_dynamic(categories[i].name);
 			if (!cur_cat) {
 				break;
 			}
@@ -1219,215 +1231,285 @@ static struct ast_config *config_ldap(co
 	return cfg;
 }
 
-/* \brief Function to update a set of values in ldap static mode
+/*!
+ * \internal
+ * \brief Create an LDAP modification structure (LDAPMod)
+ *
+ * \param attribute the name of the LDAP attribute to modify
+ * \param new_value the new value of the LDAP attribute
+ *
+ * \returns an LDAPMod * if successful, NULL otherwise.
  */
-static int update_ldap(const char *basedn, const char *table_name, const char *attribute,
-	const char *lookup, const struct ast_variable *fields)
+static LDAPMod *ldap_mod_create(const char *attribute, const char *new_value)
 {
-	int error = 0;
-	LDAPMessage *ldap_entry = NULL;
-	LDAPMod **ldap_mods;
-	const char *newparam;
-	const struct ast_variable *field = fields;
-	char *dn;
-	int num_entries = 0;
-	int i = 0;
-	int mods_size = 0;
-	int mod_exists = 0;
-	struct ldap_table_config *table_config = NULL;
-	char *clean_basedn = NULL;
-	struct ast_str *filter = NULL;
-	int tries = 0;
-	int result = 0;
-	LDAPMessage *ldap_result_msg = NULL;
+	LDAPMod *mod;
+	char *type;
 
-	if (!table_name) {
-		ast_log(LOG_ERROR, "No table_name specified.\n");
-		return -1;
-	} 
+	mod = ldap_memcalloc(1, sizeof(LDAPMod));
+	type = ldap_strdup(attribute);
 
-	if (!(filter = ast_str_create(80))) {
-		return -1;
+	if (!(mod && type)) {
+		ast_log(LOG_ERROR, "Memory allocation failure creating LDAP modification\n");
+		ldap_memfree(type);
+		ldap_memfree(mod);
+		return NULL;
 	}
 
-	if (!attribute || !lookup) {
-		ast_log(LOG_WARNING, "LINE(%d): search parameters are empty.\n", __LINE__);
-		return -1;
-	}
-	ast_mutex_lock(&ldap_lock);
+	mod->mod_type = type;
 
-	/* We now have our complete statement; Lets connect to the server and execute it.  */
-	if (!ldap_reconnect()) {
-		ast_mutex_unlock(&ldap_lock);
-		return -1;
-	}
+	if (strlen(new_value)) {
+		char **values, *value;
+		values = ldap_memcalloc(2, sizeof(char *));
+		value = ldap_strdup(new_value);
+
+		if (!(values && value)) {
+			ast_log(LOG_ERROR, "Memory allocation failure creating LDAP modification\n");
+			ldap_memfree(value);
+			ldap_memfree(values);
+			ldap_memfree(type);
+			ldap_memfree(mod);
+			return NULL;
+		}
 
-	table_config = table_config_for_table_name(table_name);
-	if (!table_config) {
-		ast_log(LOG_ERROR, "No table named '%s'.\n", table_name);
-		ast_mutex_unlock(&ldap_lock);
-		return -1;
+		mod->mod_op = LDAP_MOD_REPLACE;
+		mod->mod_values = values;
+		mod->mod_values[0] = value;
+	} else {
+		mod->mod_op = LDAP_MOD_DELETE;
 	}
 
-	clean_basedn = cleaned_basedn(NULL, basedn);
+	return mod;
+}
 
-	/* Create the filter with the table additional filter and the parameter/value pairs we were given */
-	ast_str_append(&filter, 0, "(&");
-	if (table_config && table_config->additional_filter) {
-		ast_str_append(&filter, 0, "%s", table_config->additional_filter);
+/*!
+ * \internal
+ * \brief Append a value to an existing LDAP modification structure
+ *
+ * \param src the LDAPMod to update
+ * \param new_value the new value to append to the LDAPMod
+ *
+ * \returns the \c src original passed in if successful, NULL otherwise.
+ */
+static LDAPMod *ldap_mod_append(LDAPMod *src, const char *new_value)
+{
+	char *new_buffer;
+
+	if (src->mod_op != LDAP_MOD_REPLACE) {
+		return src;
 	}
-	if (table_config != base_table_config && base_table_config && base_table_config->additional_filter) {
-		ast_str_append(&filter, 0, "%s", base_table_config->additional_filter);
+
+	new_buffer = ldap_memrealloc(
+			src->mod_values[0],
+			strlen(src->mod_values[0]) + strlen(new_value) + sizeof(";"));
+
+	if (!new_buffer) {
+		ast_log(LOG_ERROR, "Memory allocation failure creating LDAP modification\n");
+		return NULL;
 	}
-	append_var_and_value_to_filter(&filter, table_config, attribute, lookup);
-	ast_str_append(&filter, 0, ")");
 
-	/* Create the modification array with the parameter/value pairs we were given, 
-	 * if there are several parameters with the same name, we collect them into 
-	 * one parameter/value pair and delimit them with a semicolon */
-	newparam = convert_attribute_name_to_ldap(table_config, field->name);
-	if (!newparam) {
-		ast_log(LOG_WARNING, "LINE(%d): need at least one parameter to modify.\n", __LINE__);
-		return -1;
+	strcat(new_buffer, ";");
+	strcat(new_buffer, new_value);
+
+	src->mod_values[0] = new_buffer;
+
+	return src;
+}
+
+/*!
+ * \internal
+ * \brief Duplicates an LDAP modification structure
+ *
+ * \param src the LDAPMod to duplicate
+ *
+ * \returns a deep copy of \c src if successful, NULL otherwise.
+ */
+static LDAPMod *ldap_mod_duplicate(const LDAPMod *src)
+{
+	LDAPMod *mod;
+	char *type, **values = NULL;
+
+	mod = ldap_memcalloc(1, sizeof(LDAPMod));
+	type = ldap_strdup(src->mod_type);
+
+	if (!(mod && type)) {
+		ast_log(LOG_ERROR, "Memory allocation failure creating LDAP modification\n");
+		ldap_memfree(type);
+		ldap_memfree(mod);
+		return NULL;
 	}
 
-	mods_size = 2; /* one for the first param/value pair and one for the the terminating NULL */
-	ldap_mods = ldap_memcalloc(sizeof(LDAPMod *), mods_size);
-	ldap_mods[0] = ldap_memcalloc(1, sizeof(LDAPMod));
-
-	ldap_mods[0]->mod_op = LDAP_MOD_REPLACE;
-	ldap_mods[0]->mod_type = ldap_strdup(newparam);
-
-	ldap_mods[0]->mod_values = ast_calloc(sizeof(char *), 2);
-	ldap_mods[0]->mod_values[0] = ldap_strdup(field->value);
-
-	while ((field = field->next)) {
-		newparam = convert_attribute_name_to_ldap(table_config, field->name);
-		mod_exists = 0;
-
-		for (i = 0; i < mods_size - 1; i++) {
-			if (ldap_mods[i]&& !strcmp(ldap_mods[i]->mod_type, newparam)) {
-				/* We have the parameter allready, adding the value as a semicolon delimited value */
-				ldap_mods[i]->mod_values[0] = ldap_memrealloc(ldap_mods[i]->mod_values[0], sizeof(char) * (strlen(ldap_mods[i]->mod_values[0]) + strlen(field->value) + 2));
-				strcat(ldap_mods[i]->mod_values[0], ";");
-				strcat(ldap_mods[i]->mod_values[0], field->value);
-				mod_exists = 1;	
-				break;
-			}
+	if (src->mod_op == LDAP_MOD_REPLACE) {
+		char *value;
+
+		values = ldap_memcalloc(2, sizeof(char *));
+		value = ldap_strdup(src->mod_values[0]);
+
+		if (!(values && value)) {
+			ast_log(LOG_ERROR, "Memory allocation failure creating LDAP modification\n");
+			ldap_memfree(value);
+			ldap_memfree(values);
+			ldap_memfree(type);
+			ldap_memfree(mod);
+			return NULL;
 		}
 
-		/* create new mod */
-		if (!mod_exists) {
-			mods_size++;
-			ldap_mods = ldap_memrealloc(ldap_mods, sizeof(LDAPMod *) * mods_size);
-			ldap_mods[mods_size - 1] = NULL;
-			
-			ldap_mods[mods_size - 2] = ldap_memcalloc(1, sizeof(LDAPMod));
+		values[0] = value;
+	}
 
-			ldap_mods[mods_size - 2]->mod_type = ldap_memcalloc(sizeof(char), strlen(newparam) + 1);
-			strcpy(ldap_mods[mods_size - 2]->mod_type, newparam);
+	mod->mod_op = src->mod_op;
+	mod->mod_type = type;
+	mod->mod_values = values;
+	return mod;
+}
 
-			if (strlen(field->value) == 0) {
-				ldap_mods[mods_size - 2]->mod_op = LDAP_MOD_DELETE;
-			} else {
-				ldap_mods[mods_size - 2]->mod_op = LDAP_MOD_REPLACE;
+/*!
+ * \internal
+ * \brief Search for an existing LDAP modification structure
+ *
+ * \param modifications a NULL terminated array of LDAP modification structures
+ * \param lookup the attribute name to search for
+ *
+ * \returns an LDAPMod * if successful, NULL otherwise.
+ */
+static LDAPMod *ldap_mod_find(LDAPMod **modifications, const char *lookup)
+{
+	size_t i;
+	for (i = 0; modifications[i]; i++) {
+		if (modifications[i]->mod_op == LDAP_MOD_REPLACE &&
+			!strcasecmp(modifications[i]->mod_type, lookup)) {
+			return modifications[i];
+		}
+	}
+	return NULL;
+}
 
-				ldap_mods[mods_size - 2]->mod_values = ldap_memcalloc(sizeof(char *), 2);
-				ldap_mods[mods_size - 2]->mod_values[0] = ldap_memcalloc(sizeof(char), strlen(field->value) + 1);
-				strcpy(ldap_mods[mods_size - 2]->mod_values[0], field->value);
-			}
+/*!
+ * \internal
+ * \brief Determine if an LDAP entry has the specified attribute
+ *
+ * \param entry the LDAP entry to examine
+ * \param lookup the attribute name to search for
+ *
+ * \returns 1 if the attribute was found, 0 otherwise.
+ */
+static int ldap_entry_has_attribute(LDAPMessage *entry, const char *lookup)
+{
+	BerElement *ber = NULL;
+	char *attribute;
+
+	attribute = ldap_first_attribute(ldapConn, entry, &ber);
+	while (attribute) {
+		if (!strcasecmp(attribute, lookup)) {
+			ldap_memfree(attribute);
+			ber_free(ber, 0);
+			return 1;
 		}
+		ldap_memfree(attribute);
+		attribute = ldap_next_attribute(ldapConn, entry, ber);
 	}
-	/* freeing ldap_mods further down */
+	ber_free(ber, 0);
+	return 0;
+}
 
-	do {
-		/* freeing ldap_result further down */
-		result = ldap_search_ext_s(ldapConn, clean_basedn,
-				  LDAP_SCOPE_SUBTREE, ast_str_buffer(filter), NULL, 0, NULL, NULL, NULL, LDAP_NO_LIMIT,
-				  &ldap_result_msg);
-		if (result != LDAP_SUCCESS && is_ldap_connect_error(result)) {
-			ast_log(LOG_WARNING, "Failed to query directory. Try %d/3\n", tries + 1);
-			tries++;
-			if (tries < 3) {
-				usleep(500000L * tries);
-				if (ldapConn) {
-					ldap_unbind_ext_s(ldapConn, NULL, NULL);
-					ldapConn = NULL;
-				}
-				if (!ldap_reconnect())
-					break;
-			}
+/*!
+ * \internal
+ * \brief Remove LDAP_MOD_DELETE modifications that will not succeed
+ *
+ * \details
+ * A LDAP_MOD_DELETE operation will fail if the LDAP entry does not already have
+ * the corresponding attribute. Because we may be updating multiple LDAP entries
+ * in a single call to update_ldap(), we may need our own copy of the
+ * modifications array for each one.
+ *
+ * \note
+ * This function dynamically allocates memory. If it returns a non-NULL pointer,
+ * it is up to the caller to free it with ldap_mods_free()
+ *
+ * \returns an LDAPMod * if modifications needed to be removed, NULL otherwise.
+ */
+static LDAPMod **massage_mods_for_entry(LDAPMessage *entry, LDAPMod **mods)
+{
+	size_t k, i, remove_count;
+	LDAPMod **copies;
+
+	for (i = remove_count = 0; mods[i]; i++) {
+		if (mods[i]->mod_op == LDAP_MOD_DELETE
+			&& !ldap_entry_has_attribute(entry, mods[i]->mod_type)) {
+			remove_count++;
 		}
-	} while (result != LDAP_SUCCESS && tries < 3 && is_ldap_connect_error(result));
+	}
 
-	if (result != LDAP_SUCCESS) {
-		ast_log(LOG_WARNING, "Failed to query directory. Error: %s.\n", ldap_err2string(result));
-		ast_log(LOG_WARNING, "Query: %s\n", ast_str_buffer(filter));
+	if (!remove_count) {
+		return NULL;
+	}
 
-		ast_mutex_unlock(&ldap_lock);
-		free(filter);
-		free(clean_basedn);
-		ldap_msgfree(ldap_result_msg);
-		ldap_mods_free(ldap_mods, 0);
-		return -1;
+	copies = ldap_memcalloc(i - remove_count + 1, sizeof(LDAPMod *));
+	if (!copies) {
+		ast_log(LOG_ERROR, "Memory allocation failure massaging LDAP modification\n");
+		return NULL;
 	}
-	/* Ready to update */
-	if ((num_entries = ldap_count_entries(ldapConn, ldap_result_msg)) > 0) {
-		ast_debug(3, "LINE(%d) Modifying %s=%s hits: %d\n", __LINE__, attribute, lookup, num_entries);
-		for (i = 0; option_debug > 2 && i < mods_size - 1; i++) {
-			if (ldap_mods[i]->mod_op != LDAP_MOD_DELETE) {
-				ast_debug(3, "LINE(%d) %s=%s \n", __LINE__, ldap_mods[i]->mod_type, ldap_mods[i]->mod_values[0]);
-			} else {
-				ast_debug(3, "LINE(%d) deleting %s \n", __LINE__, ldap_mods[i]->mod_type);
-			}
-		}
-		ldap_entry = ldap_first_entry(ldapConn, ldap_result_msg);
 
-		for (i = 0; ldap_entry; i++) { 
-			dn = ldap_get_dn(ldapConn, ldap_entry);
-			if ((error = ldap_modify_ext_s(ldapConn, dn, ldap_mods, NULL, NULL)) != LDAP_SUCCESS)  {
-				ast_log(LOG_ERROR, "Couldn't modify '%s'='%s', dn:%s because %s\n",
-						attribute, lookup, dn, ldap_err2string(error));
+	for (i = k = 0; mods[i]; i++) {
+		if (mods[i]->mod_op != LDAP_MOD_DELETE
+			|| ldap_entry_has_attribute(entry, mods[i]->mod_type)) {
+			copies[k] = ldap_mod_duplicate(mods[i]);
+			if (!copies[k]) {
+				ast_log(LOG_ERROR, "Memory allocation failure massaging LDAP modification\n");
+				ldap_mods_free(copies, 1);
+				return NULL;
 			}
-			ldap_memfree(dn);
-			ldap_entry = ldap_next_entry(ldapConn, ldap_entry);
+			k++;
+		} else {
+			ast_debug(3, "Skipping %s deletion because it doesn't exist\n",
+					mods[i]->mod_type);
 		}
 	}
 
-	ast_mutex_unlock(&ldap_lock);
-	ast_free(filter);
-	ast_free(clean_basedn);
-	ldap_msgfree(ldap_result_msg);
-	ldap_mods_free(ldap_mods, 0);
-	return num_entries;
+	return copies;
+}
+
+/*!
+ * \internal
+ * \brief Count the number of variables in an ast_variables list
+ *
+ * \param vars the list of variables to count
+ *
+ * \returns the number of variables in the specified list
+ */
+static size_t variables_count(const struct ast_variable *vars)
+{
+	const struct ast_variable *var;
+	size_t count = 0;
+	for (var = vars; var; var = var->next) {
+		count++;
+	}
+	return count;
 }
 
 static int update2_ldap(const char *basedn, const char *table_name, const struct ast_variable *lookup_fields, const struct ast_variable *update_fields)
 {
-	int error = 0;
-	LDAPMessage *ldap_entry = NULL;
-	LDAPMod **ldap_mods;
-	const char *newparam;
 	const struct ast_variable *field;
-	char *dn;
-	int num_entries = 0;
-	int i = 0;
-	int mods_size = 0;
-	int mod_exists = 0;
 	struct ldap_table_config *table_config = NULL;
 	char *clean_basedn = NULL;
 	struct ast_str *filter = NULL;
+	int search_result = 0;
+	int res = -1;
 	int tries = 0;
-	int result = 0;
+	size_t update_count, update_index, entry_count;
+
+	LDAPMessage *ldap_entry = NULL;
+	LDAPMod **modifications;
 	LDAPMessage *ldap_result_msg = NULL;
 
 	if (!table_name) {
 		ast_log(LOG_ERROR, "No table_name specified.\n");
-		return -1;
-	} 
+		return res;
+	}
 
-	if (!(filter = ast_str_create(80))) {
-		return -1;
+	update_count = variables_count(update_fields);
+	if (!update_count) {
+		ast_log(LOG_WARNING, "Need at least one parameter to modify.\n");
+		return res;
 	}
 
 	ast_mutex_lock(&ldap_lock);
@@ -1435,100 +1517,40 @@ static int update2_ldap(const char *base
 	/* We now have our complete statement; Lets connect to the server and execute it.  */
 	if (!ldap_reconnect()) {
 		ast_mutex_unlock(&ldap_lock);
-		ast_free(filter);
-		return -1;
+		return res;
 	}
 
 	table_config = table_config_for_table_name(table_name);
 	if (!table_config) {
 		ast_log(LOG_ERROR, "No table named '%s'.\n", table_name);
 		ast_mutex_unlock(&ldap_lock);
-		ast_free(filter);
-		return -1;
+		return res;
 	}
 
 	clean_basedn = cleaned_basedn(NULL, basedn);
 
-	/* Create the filter with the table additional filter and the parameter/value pairs we were given */
-	ast_str_append(&filter, 0, "(&");
-	if (table_config && table_config->additional_filter) {
-		ast_str_append(&filter, 0, "%s", table_config->additional_filter);
-	}
-	if (table_config != base_table_config && base_table_config
-		&& base_table_config->additional_filter) {
-		ast_str_append(&filter, 0, "%s", base_table_config->additional_filter);
-	}
-
-	/* Get multiple lookup keyfields and values */
-	for (field = lookup_fields; field; field = field->next) {
-		append_var_and_value_to_filter(&filter, table_config, field->name, field->value);
-	}
-	ast_str_append(&filter, 0, ")");
-
-	/* Create the modification array with the parameter/value pairs we were given, 
-	 * if there are several parameters with the same name, we collect them into 
-	 * one parameter/value pair and delimit them with a semicolon */
-	field = update_fields;
-	newparam = convert_attribute_name_to_ldap(table_config, field->name);
-	if (!newparam) {
-		ast_log(LOG_WARNING, "LINE(%d): need at least one parameter to modify.\n", __LINE__);
-		ast_free(filter);
+	filter = create_lookup_filter(table_config, lookup_fields);
+	if (!filter) {
+		ast_mutex_unlock(&ldap_lock);
 		ast_free(clean_basedn);
-		return -1;
+		return res;
 	}
 
-	mods_size = 2; /* one for the first param/value pair and one for the the terminating NULL */
-	ldap_mods = ast_calloc(sizeof(LDAPMod *), mods_size);
-	ldap_mods[0] = ast_calloc(1, sizeof(LDAPMod));
-
-	ldap_mods[0]->mod_op = LDAP_MOD_REPLACE;
-	ldap_mods[0]->mod_type = ast_calloc(sizeof(char), strlen(newparam) + 1);
-	strcpy(ldap_mods[0]->mod_type, newparam);
-
-	ldap_mods[0]->mod_values = ast_calloc(sizeof(char), 2);
-	ldap_mods[0]->mod_values[0] = ast_calloc(sizeof(char), strlen(field->value) + 1);
-	strcpy(ldap_mods[0]->mod_values[0], field->value);
-
-	while ((field = field->next)) {
-		newparam = convert_attribute_name_to_ldap(table_config, field->name);
-		mod_exists = 0;
-
-		for (i = 0; i < mods_size - 1; i++) {
-			if (ldap_mods[i]&& !strcmp(ldap_mods[i]->mod_type, newparam)) {
-				/* We have the parameter allready, adding the value as a semicolon delimited value */
-				ldap_mods[i]->mod_values[0] = ast_realloc(ldap_mods[i]->mod_values[0], sizeof(char) * (strlen(ldap_mods[i]->mod_values[0]) + strlen(field->value) + 2));
-				strcat(ldap_mods[i]->mod_values[0], ";");
-				strcat(ldap_mods[i]->mod_values[0], field->value);
-				mod_exists = 1;	
-				break;
-			}
-		}
-
-		/* create new mod */
-		if (!mod_exists) {
-			mods_size++;
-			ldap_mods = ast_realloc(ldap_mods, sizeof(LDAPMod *) * mods_size);
-			ldap_mods[mods_size - 1] = NULL;
-			ldap_mods[mods_size - 2] = ast_calloc(1, sizeof(LDAPMod));
-
-			ldap_mods[mods_size - 2]->mod_op = LDAP_MOD_REPLACE;
-
-			ldap_mods[mods_size - 2]->mod_type = ast_calloc(sizeof(char), strlen(newparam) + 1);
-			strcpy(ldap_mods[mods_size - 2]->mod_type, newparam);
-
-			ldap_mods[mods_size - 2]->mod_values = ast_calloc(sizeof(char *), 2);
-			ldap_mods[mods_size - 2]->mod_values[0] = ast_calloc(sizeof(char), strlen(field->value) + 1);
-			strcpy(ldap_mods[mods_size - 2]->mod_values[0], field->value);
-		}
-	}
-	/* freeing ldap_mods further down */
+	/*
+	 * Find LDAP records that match our lookup filter. If there are none, then
+	 * we don't go through the hassle of building our modifications list.
+	 */
 
 	do {
-		/* freeing ldap_result further down */
-		result = ldap_search_ext_s(ldapConn, clean_basedn,
-				  LDAP_SCOPE_SUBTREE, ast_str_buffer(filter), NULL, 0, NULL, NULL, NULL, LDAP_NO_LIMIT,
-				  &ldap_result_msg);
-		if (result != LDAP_SUCCESS && is_ldap_connect_error(result)) {
+		search_result = ldap_search_ext_s(
+				ldapConn,
+				clean_basedn,
+				LDAP_SCOPE_SUBTREE,
+				ast_str_buffer(filter),
+				NULL, 0, NULL, NULL, NULL,
+				LDAP_NO_LIMIT,
+				&ldap_result_msg);
+		if (search_result != LDAP_SUCCESS && is_ldap_connect_error(search_result)) {
 			ast_log(LOG_WARNING, "Failed to query directory. Try %d/3\n", tries + 1);
 			tries++;
 			if (tries < 3) {
@@ -1542,47 +1564,128 @@ static int update2_ldap(const char *base
 				}
 			}
 		}
-	} while (result != LDAP_SUCCESS && tries < 3 && is_ldap_connect_error(result));
+	} while (search_result != LDAP_SUCCESS && tries < 3 && is_ldap_connect_error(search_result));
 
-	if (result != LDAP_SUCCESS) {
-		ast_log(LOG_WARNING, "Failed to query directory. Error: %s.\n", ldap_err2string(result));
+	if (search_result != LDAP_SUCCESS) {
+		ast_log(LOG_WARNING, "Failed to query directory. Error: %s.\n", ldap_err2string(search_result));
 		ast_log(LOG_WARNING, "Query: %s\n", ast_str_buffer(filter));
+		goto early_bailout;
+	}
 
-		ast_mutex_unlock(&ldap_lock);
-		ast_free(filter);
-		ast_free(clean_basedn);
-		ldap_msgfree(ldap_result_msg);
-		ldap_mods_free(ldap_mods, 0);
-		return -1;
+	entry_count = ldap_count_entries(ldapConn, ldap_result_msg);
+	if (!entry_count) {
+		/* Nothing found, nothing to update */
+		res = 0;
+		goto early_bailout;
+	}
+
+	/* We need to NULL terminate, so we allocate one more than we need */
+	modifications = ldap_memcalloc(update_count + 1, sizeof(LDAPMod *));
+	if (!modifications) {
+		ast_log(LOG_ERROR, "Memory allocation failure\n");
+		goto early_bailout;
 	}
-	/* Ready to update */
-	if ((num_entries = ldap_count_entries(ldapConn, ldap_result_msg)) > 0) {
-		for (i = 0; option_debug > 2 && i < mods_size - 1; i++) {
-			ast_debug(3, "LINE(%d) %s=%s \n", __LINE__, ldap_mods[i]->mod_type, ldap_mods[i]->mod_values[0]);
-		}
 
-		ldap_entry = ldap_first_entry(ldapConn, ldap_result_msg);
+	/*
+	 * Create the modification array with the parameter/value pairs we were given,
+	 * if there are several parameters with the same name, we collect them into
+	 * one parameter/value pair and delimit them with a semicolon
+	 */
+	for (field = update_fields, update_index = 0; field; field = field->next) {
+		LDAPMod *mod;
 
-		for (i = 0; ldap_entry; i++) {
-			dn = ldap_get_dn(ldapConn, ldap_entry);
-			if ((error = ldap_modify_ext_s(ldapConn, dn, ldap_mods, NULL, NULL)) != LDAP_SUCCESS)  {
-				ast_log(LOG_ERROR, "Couldn't modify dn:%s because %s", dn, ldap_err2string(error));
+		const char *ldap_attribute_name = convert_attribute_name_to_ldap(
+				table_config,
+				field->name);
+
+		/* See if we already have it */
+		mod = ldap_mod_find(modifications, ldap_attribute_name);
+		if (mod) {
+			mod = ldap_mod_append(mod, field->value);
+			if (!mod) {
+				goto late_bailout;
 			}
-			ldap_memfree(dn);
-			ldap_entry = ldap_next_entry(ldapConn, ldap_entry);
+		} else {
+			mod = ldap_mod_create(ldap_attribute_name, field->value);
+			if (!mod) {
+				goto late_bailout;
+			}
+			modifications[update_index++] = mod;
 		}
 	}
 
-	ast_mutex_unlock(&ldap_lock);
-	if (filter) {
-		ast_free(filter);
+	/* Ready to update */
+	ast_debug(3, "Modifying %zu matched entries\n", entry_count);
+	if (option_debug > 2) {
+		size_t i;
+		for (i = 0; modifications[i]; i++) {
+			if (modifications[i]->mod_op != LDAP_MOD_DELETE) {
+				ast_debug(3, "%s => %s\n", modifications[i]->mod_type,
+						modifications[i]->mod_values[0]);
+			} else {
+				ast_debug(3, "deleting %s\n", modifications[i]->mod_type);
+			}
+		}
 	}
-	if (clean_basedn) {
-		ast_free(clean_basedn);
+
+	for (ldap_entry = ldap_first_entry(ldapConn, ldap_result_msg);
+		ldap_entry;
+		ldap_entry = ldap_next_entry(ldapConn, ldap_entry)) {
+		int error;
+		LDAPMod **massaged, **working;
+
+		char *dn = ldap_get_dn(ldapConn, ldap_entry);
+		if (!dn) {
+			ast_log(LOG_ERROR, "Memory allocation failure\n");
+			goto late_bailout;
+		}
+
+		working = modifications;
+
+		massaged = massage_mods_for_entry(ldap_entry, modifications);
+		if (massaged) {
+			/* Did we massage everything out of the list? */
+			if (!massaged[0]) {
+				ast_debug(3, "Nothing left to modify - skipping\n");
+				ldap_mods_free(massaged, 1);
+				ldap_memfree(dn);
+				continue;
+			}
+			working = massaged;
+		}
+
+		if ((error = ldap_modify_ext_s(ldapConn, dn, working, NULL, NULL)) != LDAP_SUCCESS)  {
+			ast_log(LOG_ERROR, "Couldn't modify dn:%s because %s", dn, ldap_err2string(error));
+		}
+
+		if (massaged) {
+			ldap_mods_free(massaged, 1);
+		}
+
+		ldap_memfree(dn);
 	}
+
+	res = entry_count;
+
+late_bailout:
+	ldap_mods_free(modifications, 1);
+
+early_bailout:
 	ldap_msgfree(ldap_result_msg);
-	ldap_mods_free(ldap_mods, 0);
-	return num_entries;
+	ast_free(filter);
+	ast_free(clean_basedn);
+	ast_mutex_unlock(&ldap_lock);
+
+	return res;
+}
+
+static int update_ldap(const char *basedn, const char *table_name, const char *attribute, const char *lookup, const struct ast_variable *fields)
+{
+	int res;
+	struct ast_variable *lookup_fields = ast_variable_new(attribute, lookup, "");
+	res = update2_ldap(basedn, table_name, lookup_fields, fields);
+	ast_variables_destroy(lookup_fields);
+	return res;
 }
 
 static struct ast_config_engine ldap_engine = {
@@ -1683,6 +1786,21 @@ static int reload(void)
 	return 0;
 }
 
+static int config_can_be_inherited(const char *key)
+{
+	int i;
+	static const char * const config[] = {
+		"basedn", "host", "pass", "port", "protocol", "url", "user", "version", NULL
+	};
+
+	for (i = 0; config[i]; i++) {
+		if (!strcasecmp(key, config[i])) {
+			return 0;
+		}
+	}
+	return 1;
+}
+
 /*! \brief parse the configuration file
  */
 static int parse_config(void)
@@ -1773,7 +1891,9 @@ static int parse_config(void)
 				if (!strcasecmp(var->name, "additionalFilter")) {
 					table_config->additional_filter = ast_strdup(var->value);
 				} else {
-					ldap_table_config_add_attribute(table_config, var->name, var->value);
+					if (!is_general || config_can_be_inherited(var->name)) {
+						ldap_table_config_add_attribute(table_config, var->name, var->value);
+					}
 				}
 			}
 		}
diff -urpN asterisk-13.9.1/res/res_config_odbc.c asterisk-13.17.0/res/res_config_odbc.c
--- asterisk-13.9.1/res/res_config_odbc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_config_odbc.c	2017-07-12 13:12:08.000000000 +0200
@@ -47,6 +47,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/utils.h"
 #include "asterisk/stringfields.h"
 
+/*! Initial SQL query buffer size to allocate. */
+#define SQL_BUF_SIZE	1024
+
 AST_THREADSTORAGE(sql_buf);
 AST_THREADSTORAGE(rowdata_buf);
 
@@ -114,7 +117,7 @@ static SQLHSTMT custom_prepare(struct od
 
 	res = SQLPrepare(stmt, (unsigned char *)cps->sql, SQL_NTS);
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Prepare failed![%s]\n", cps->sql);
+		ast_log(LOG_WARNING, "SQL Prepare failed! [%s]\n", cps->sql);
 		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
 		return NULL;
 	}
@@ -137,6 +140,7 @@ static SQLHSTMT custom_prepare(struct od
 
 	if (!ast_strlen_zero(cps->extra)) {
 		const char *newval = cps->extra;
+		ast_debug(1, "Parameter %d = '%s'\n", x, newval);
 		if (strchr(newval, ';') || strchr(newval, '^')) {
 			ENCODE_CHUNK(encodebuf, newval);
 			ast_string_field_set(cps, encoding[x], encodebuf);
@@ -160,13 +164,13 @@ static SQLHSTMT custom_prepare(struct od
  *
  * \retval var on success
  * \retval NULL on failure
-*/
+ */
 static struct ast_variable *realtime_odbc(const char *database, const char *table, const struct ast_variable *fields)
 {
 	struct odbc_obj *obj;
 	SQLHSTMT stmt;
-	char sql[1024];
 	char coltitle[256];
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	struct ast_str *rowdata = ast_str_thread_get(&rowdata_buf, 128);
 	char *op;
 	const struct ast_variable *field = fields;
@@ -182,29 +186,30 @@ static struct ast_variable *realtime_odb
 	SQLSMALLINT decimaldigits;
 	SQLSMALLINT nullable;
 	SQLLEN indicator;
-	struct custom_prepare_struct cps = { .sql = sql, .fields = fields, };
+	struct custom_prepare_struct cps = { .fields = fields, };
 	struct ast_flags connected_flag = { RES_ODBC_CONNECTED };
 
-	if (!table || !field) {
+	if (!table || !field || !sql || !rowdata) {
 		return NULL;
 	}
 
 	obj = ast_odbc_request_obj2(database, connected_flag);
-
 	if (!obj) {
 		ast_log(LOG_ERROR, "No database handle available with the name of '%s' (check res_odbc.conf)\n", database);
 		return NULL;
 	}
 
 	op = !strchr(field->name, ' ') ? " =" : "";
-	snprintf(sql, sizeof(sql), "SELECT * FROM %s WHERE %s%s ?%s", table, field->name, op,
+	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s ?%s", table, field->name, op,
 		strcasestr(field->name, "LIKE") && !ast_odbc_backslash_is_escape(obj) ? " ESCAPE '\\\\'" : "");
 	while ((field = field->next)) {
 		op = !strchr(field->name, ' ') ? " =" : "";
-		snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), " AND %s%s ?%s", field->name, op,
+		ast_str_append(&sql, 0, " AND %s%s ?%s", field->name, op,
 			strcasestr(field->name, "LIKE") && !ast_odbc_backslash_is_escape(obj) ? " ESCAPE '\\\\'" : "");
 	}
 
+	cps.sql = ast_str_buffer(sql);
+
 	if (ast_string_field_init(&cps, 256)) {
 		ast_odbc_release_obj(obj);
 		return NULL;
@@ -219,7 +224,7 @@ static struct ast_variable *realtime_odb
 
 	res = SQLNumResultCols(stmt, &colcount);
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Column Count error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL Column Count error! [%s]\n", ast_str_buffer(sql));
 		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
 		ast_odbc_release_obj(obj);
 		return NULL;
@@ -232,7 +237,7 @@ static struct ast_variable *realtime_odb
 		return NULL;
 	}
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Fetch error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL Fetch error! [%s]\n", ast_str_buffer(sql));
 		SQLFreeHandle (SQL_HANDLE_STMT, stmt);
 		ast_odbc_release_obj(obj);
 		return NULL;
@@ -243,7 +248,7 @@ static struct ast_variable *realtime_odb
 		res = SQLDescribeCol(stmt, x + 1, (unsigned char *)coltitle, sizeof(coltitle), &collen, 
 					&datatype, &colsize, &decimaldigits, &nullable);
 		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-			ast_log(LOG_WARNING, "SQL Describe Column error!\n[%s]\n\n", sql);
+			ast_log(LOG_WARNING, "SQL Describe Column error! [%s]\n", ast_str_buffer(sql));
 			if (var)
 				ast_variables_destroy(var);
 			ast_odbc_release_obj(obj);
@@ -272,7 +277,7 @@ static struct ast_variable *realtime_odb
 		}
 
 		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-			ast_log(LOG_WARNING, "SQL Get Data error!\n[%s]\n\n", sql);
+			ast_log(LOG_WARNING, "SQL Get Data error! [%s]\n", ast_str_buffer(sql));
 			if (var)
 				ast_variables_destroy(var);
 			ast_odbc_release_obj(obj);
@@ -316,13 +321,13 @@ static struct ast_variable *realtime_odb
  *
  * \retval var on success
  * \retval NULL on failure
-*/
+ */
 static struct ast_config *realtime_multi_odbc(const char *database, const char *table, const struct ast_variable *fields)
 {
 	struct odbc_obj *obj;
 	SQLHSTMT stmt;
-	char sql[1024];
 	char coltitle[256];
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	struct ast_str *rowdata = ast_str_thread_get(&rowdata_buf, 128);
 	const char *initfield;
 	char *op;
@@ -342,9 +347,9 @@ static struct ast_config *realtime_multi
 	SQLSMALLINT decimaldigits;
 	SQLSMALLINT nullable;
 	SQLLEN indicator;
-	struct custom_prepare_struct cps = { .sql = sql, .fields = fields, };
+	struct custom_prepare_struct cps = { .fields = fields, };
 
-	if (!table || !field) {
+	if (!table || !field || !sql || !rowdata) {
 		return NULL;
 	}
 
@@ -359,15 +364,16 @@ static struct ast_config *realtime_multi
 	}
 
 	op = !strchr(field->name, ' ') ? " =" : "";
-	snprintf(sql, sizeof(sql), "SELECT * FROM %s WHERE %s%s ?%s", table, field->name, op,
+	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s ?%s", table, field->name, op,
 		strcasestr(field->name, "LIKE") && !ast_odbc_backslash_is_escape(obj) ? " ESCAPE '\\\\'" : "");
 	while ((field = field->next)) {
 		op = !strchr(field->name, ' ') ? " =" : "";
-		snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), " AND %s%s ?%s", field->name, op,
+		ast_str_append(&sql, 0, " AND %s%s ?%s", field->name, op,
 			strcasestr(field->name, "LIKE") && !ast_odbc_backslash_is_escape(obj) ? " ESCAPE '\\\\'" : "");
 	}
+	ast_str_append(&sql, 0, " ORDER BY %s", initfield);
 
-	snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), " ORDER BY %s", initfield);
+	cps.sql = ast_str_buffer(sql);
 
 	if (ast_string_field_init(&cps, 256)) {
 		ast_odbc_release_obj(obj);
@@ -383,7 +389,7 @@ static struct ast_config *realtime_multi
 
 	res = SQLNumResultCols(stmt, &colcount);
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Column Count error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL Column Count error! [%s]\n", ast_str_buffer(sql));
 		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 		ast_odbc_release_obj(obj);
 		return NULL;
@@ -400,12 +406,11 @@ static struct ast_config *realtime_multi
 	while ((res=SQLFetch(stmt)) != SQL_NO_DATA) {
 		var = NULL;
 		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-			ast_log(LOG_WARNING, "SQL Fetch error!\n[%s]\n\n", sql);
+			ast_log(LOG_WARNING, "SQL Fetch error! [%s]\n", ast_str_buffer(sql));
 			continue;
 		}
-		cat = ast_category_new("","",99999);
+		cat = ast_category_new_anonymous();
 		if (!cat) {
-			ast_log(LOG_WARNING, "Out of memory!\n");
 			continue;
 		}
 		for (x=0;x<colcount;x++) {
@@ -414,7 +419,7 @@ static struct ast_config *realtime_multi
 			res = SQLDescribeCol(stmt, x + 1, (unsigned char *)coltitle, sizeof(coltitle), &collen, 
 						&datatype, &colsize, &decimaldigits, &nullable);
 			if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-				ast_log(LOG_WARNING, "SQL Describe Column error!\n[%s]\n\n", sql);
+				ast_log(LOG_WARNING, "SQL Describe Column error! [%s]\n", ast_str_buffer(sql));
 				ast_category_destroy(cat);
 				goto next_sql_fetch;
 			}
@@ -439,7 +444,7 @@ static struct ast_config *realtime_multi
 			}
 
 			if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-				ast_log(LOG_WARNING, "SQL Get Data error!\n[%s]\n\n", sql);
+				ast_log(LOG_WARNING, "SQL Get Data error! [%s]\n", ast_str_buffer(sql));
 				ast_category_destroy(cat);
 				goto next_sql_fetch;
 			}
@@ -481,21 +486,21 @@ next_sql_fetch:;
  *
  * \retval number of rows affected
  * \retval -1 on failure
-*/
+ */
 static int update_odbc(const char *database, const char *table, const char *keyfield, const char *lookup, const struct ast_variable *fields)
 {
 	struct odbc_obj *obj;
 	SQLHSTMT stmt;
-	char sql[256];
 	SQLLEN rowcount=0;
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	const struct ast_variable *field = fields;
 	int res, count = 0, paramcount = 0;
-	struct custom_prepare_struct cps = { .sql = sql, .extra = lookup, .fields = fields, };
+	struct custom_prepare_struct cps = { .extra = lookup, .fields = fields, };
 	struct odbc_cache_tables *tableptr;
 	struct odbc_cache_columns *column = NULL;
 	struct ast_flags connected_flag = { RES_ODBC_CONNECTED };
 
-	if (!table || !field || !keyfield) {
+	if (!table || !field || !keyfield || !sql) {
 		return -1;
 	}
 
@@ -509,19 +514,19 @@ static int update_odbc(const char *datab
 		ast_log(LOG_WARNING, "Key field '%s' does not exist in table '%s@%s'.  Update will fail\n", keyfield, table, database);
 	}
 
-	snprintf(sql, sizeof(sql), "UPDATE %s SET ", table);
+	ast_str_set(&sql, 0, "UPDATE %s SET ", table);
 	while (field) {
 		if ((tableptr && (column = ast_odbc_find_column(tableptr, field->name))) || count >= 64) {
 			if (paramcount++) {
-				snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), ", ");
+				ast_str_append(&sql, 0, ", ");
 			}
 			/* NULL test for non-text columns */
 			if (count < 64 && ast_strlen_zero(field->value) && column->nullable && !is_text(column)) {
-				snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), "%s=NULL", field->name);
+				ast_str_append(&sql, 0, "%s=NULL", field->name);
 				cps.skip |= (1LL << count);
 			} else {
 				/* Value is not an empty string, or column is of text type, or we couldn't fit any more into cps.skip (count >= 64 ?!). */
-				snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), "%s=?", field->name);
+				ast_str_append(&sql, 0, "%s=?", field->name);
 			}
 		} else { /* the column does not exist in the table */
 			cps.skip |= (1LL << count);
@@ -529,9 +534,11 @@ static int update_odbc(const char *datab
 		++count;
 		field = field->next;
 	}
-	snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), " WHERE %s=?", keyfield);
+	ast_str_append(&sql, 0, " WHERE %s=?", keyfield);
 	ast_odbc_release_table(tableptr);
 
+	cps.sql = ast_str_buffer(sql);
+
 	if (ast_string_field_init(&cps, 256)) {
 		ast_odbc_release_obj(obj);
 		return -1;
@@ -549,7 +556,7 @@ static int update_odbc(const char *datab
 	ast_odbc_release_obj(obj);
 
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Row Count error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL Row Count error! [%s]\n", ast_str_buffer(sql));
 		return -1;
 	}
 
@@ -572,17 +579,15 @@ static SQLHSTMT update2_prepare(struct o
 	int res, x = 1, first = 1;
 	struct update2_prepare_struct *ups = data;
 	const struct ast_variable *field;
-	struct ast_str *sql = ast_str_thread_get(&sql_buf, 16);
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	SQLHSTMT stmt;
-	struct odbc_cache_tables *tableptr = ast_odbc_find_table(ups->database, ups->table);
+	struct odbc_cache_tables *tableptr;
 
 	if (!sql) {
-		if (tableptr) {
-			ast_odbc_release_table(tableptr);
-		}
 		return NULL;
 	}
 
+	tableptr = ast_odbc_find_table(ups->database, ups->table);
 	if (!tableptr) {
 		ast_log(LOG_ERROR, "Could not retrieve metadata for table '%s@%s'.  Update will fail!\n", ups->table, ups->database);
 		return NULL;
@@ -627,7 +632,7 @@ static SQLHSTMT update2_prepare(struct o
 
 	res = SQLPrepare(stmt, (unsigned char *)ast_str_buffer(sql), SQL_NTS);
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Prepare failed![%s]\n", ast_str_buffer(sql));
+		ast_log(LOG_WARNING, "SQL Prepare failed! [%s]\n", ast_str_buffer(sql));
 		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 		return NULL;
 	}
@@ -673,8 +678,9 @@ static int update2_odbc(const char *data
 
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
 		/* Since only a single thread can access this memory, we can retrieve what would otherwise be lost. */
-		sql = ast_str_thread_get(&sql_buf, 16);
-		ast_log(LOG_WARNING, "SQL Row Count error!\n[%s]\n", ast_str_buffer(sql));
+		sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
+		ast_assert(sql != NULL);
+		ast_log(LOG_WARNING, "SQL Row Count error! [%s]\n", ast_str_buffer(sql));
 		return -1;
 	}
 
@@ -697,36 +703,47 @@ static int update2_odbc(const char *data
  *
  * \retval number of rows affected
  * \retval -1 on failure
-*/
+ */
 static int store_odbc(const char *database, const char *table, const struct ast_variable *fields)
 {
 	struct odbc_obj *obj;
 	SQLHSTMT stmt;
-	char sql[256];
-	char keys[256];
-	char vals[256];
 	SQLLEN rowcount=0;
 	const struct ast_variable *field = fields;
+	struct ast_str *keys;
+	struct ast_str *vals;
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	int res;
-	struct custom_prepare_struct cps = { .sql = sql, .extra = NULL, .fields = fields, };
+	struct custom_prepare_struct cps = { .fields = fields, };
 	struct ast_flags connected_flag = { RES_ODBC_CONNECTED };
 
-	if (!table || !field) {
+	keys = ast_str_create(SQL_BUF_SIZE / 2);
+	vals = ast_str_create(SQL_BUF_SIZE / 4);
+	if (!table || !field || !keys || !vals || !sql) {
+		ast_free(vals);
+		ast_free(keys);
 		return -1;
 	}
 
 	obj = ast_odbc_request_obj2(database, connected_flag);
 	if (!obj) {
+		ast_free(vals);
+		ast_free(keys);
 		return -1;
 	}
 
-	snprintf(keys, sizeof(keys), "%s", field->name);
-	ast_copy_string(vals, "?", sizeof(vals));
+	ast_str_set(&keys, 0, "%s", field->name);
+	ast_str_set(&vals, 0, "?");
 	while ((field = field->next)) {
-		snprintf(keys + strlen(keys), sizeof(keys) - strlen(keys), ", %s", field->name);
-		snprintf(vals + strlen(vals), sizeof(vals) - strlen(vals), ", ?");
+		ast_str_append(&keys, 0, ", %s", field->name);
+		ast_str_append(&vals, 0, ", ?");
 	}
-	snprintf(sql, sizeof(sql), "INSERT INTO %s (%s) VALUES (%s)", table, keys, vals);
+	ast_str_set(&sql, 0, "INSERT INTO %s (%s) VALUES (%s)",
+		table, ast_str_buffer(keys), ast_str_buffer(vals));
+
+	ast_free(vals);
+	ast_free(keys);
+	cps.sql = ast_str_buffer(sql);
 
 	if (ast_string_field_init(&cps, 256)) {
 		ast_odbc_release_obj(obj);
@@ -745,7 +762,7 @@ static int store_odbc(const char *databa
 	ast_odbc_release_obj(obj);
 
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Row Count error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL Row Count error! [%s]\n", ast_str_buffer(sql));
 		return -1;
 	}
 
@@ -769,19 +786,19 @@ static int store_odbc(const char *databa
  *
  * \retval number of rows affected
  * \retval -1 on failure
-*/
+ */
 static int destroy_odbc(const char *database, const char *table, const char *keyfield, const char *lookup, const struct ast_variable *fields)
 {
 	struct odbc_obj *obj;
 	SQLHSTMT stmt;
-	char sql[256];
 	SQLLEN rowcount=0;
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	const struct ast_variable *field;
 	int res;
-	struct custom_prepare_struct cps = { .sql = sql, .extra = lookup, .fields = fields, };
+	struct custom_prepare_struct cps = { .extra = lookup, .fields = fields, };
 	struct ast_flags connected_flag = { RES_ODBC_CONNECTED };
 
-	if (!table) {
+	if (!table || !sql) {
 		return -1;
 	}
 
@@ -790,12 +807,13 @@ static int destroy_odbc(const char *data
 		return -1;
 	}
 
-	snprintf(sql, sizeof(sql), "DELETE FROM %s WHERE ", table);
-
+	ast_str_set(&sql, 0, "DELETE FROM %s WHERE ", table);
 	for (field = fields; field; field = field->next) {
-		snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), "%s=? AND ", field->name);
+		ast_str_append(&sql, 0, "%s=? AND ", field->name);
 	}
-	snprintf(sql + strlen(sql), sizeof(sql) - strlen(sql), "%s=?", keyfield);
+	ast_str_append(&sql, 0, "%s=?", keyfield);
+
+	cps.sql = ast_str_buffer(sql);
 
 	if (ast_string_field_init(&cps, 256)) {
 		ast_odbc_release_obj(obj);
@@ -814,7 +832,7 @@ static int destroy_odbc(const char *data
 	ast_odbc_release_obj(obj);
 
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL Row Count error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL Row Count error! [%s]\n", ast_str_buffer(sql));
 		return -1;
 	}
 
@@ -892,9 +910,7 @@ static struct ast_config *config_odbc(co
 	struct ast_category *cur_cat;
 	int res = 0;
 	struct odbc_obj *obj;
-	char sqlbuf[1024] = "";
-	char *sql = sqlbuf;
-	size_t sqlleft = sizeof(sqlbuf);
+	struct ast_str *sql = ast_str_thread_get(&sql_buf, SQL_BUF_SIZE);
 	unsigned int last_cat_metric = 0;
 	SQLSMALLINT rowcount = 0;
 	SQLHSTMT stmt;
@@ -905,21 +921,21 @@ static struct ast_config *config_odbc(co
 
 	memset(&q, 0, sizeof(q));
 
-	if (!file || !strcmp (file, "res_config_odbc.conf"))
+	if (!file || !strcmp (file, "res_config_odbc.conf") || !sql) {
 		return NULL;		/* cant configure myself with myself ! */
+	}
 
 	obj = ast_odbc_request_obj2(database, connected_flag);
 	if (!obj)
 		return NULL;
 
-	q.sql = sqlbuf;
-
-	ast_build_string(&sql, &sqlleft, "SELECT MAX(LENGTH(var_val)) FROM %s WHERE filename='%s'", table, file);
+	ast_str_set(&sql, 0, "SELECT MAX(LENGTH(var_val)) FROM %s WHERE filename='%s'",
+		table, file);
+	q.sql = ast_str_buffer(sql);
 
 	stmt = ast_odbc_prepare_and_execute(obj, length_determination_odbc_prepare, &q);
-
 	if (!stmt) {
-		ast_log(LOG_WARNING, "SQL select error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL select error! [%s]\n", ast_str_buffer(sql));
 		ast_odbc_release_obj(obj);
 		return NULL;
 	}
@@ -927,7 +943,7 @@ static struct ast_config *config_odbc(co
 	res = SQLNumResultCols(stmt, &rowcount);
 
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL NumResultCols error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL NumResultCols error! [%s]\n", ast_str_buffer(sql));
 		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 		ast_odbc_release_obj(obj);
 		return NULL;
@@ -949,12 +965,11 @@ static struct ast_config *config_odbc(co
 
 	/* Reset stuff to a fresh state for the actual query which will retrieve all configuration */
 	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-	sql = sqlbuf;
-	sqlleft = sizeof(sqlbuf);
 
-	ast_build_string(&sql, &sqlleft, "SELECT cat_metric, category, var_name, var_val FROM %s ", table);
-	ast_build_string(&sql, &sqlleft, "WHERE filename='%s' AND commented=0 ", file);
-	ast_build_string(&sql, &sqlleft, "ORDER BY cat_metric DESC, var_metric ASC, category, var_name ");
+	ast_str_set(&sql, 0, "SELECT cat_metric, category, var_name, var_val FROM %s ", table);
+	ast_str_append(&sql, 0, "WHERE filename='%s' AND commented=0 ", file);
+	ast_str_append(&sql, 0, "ORDER BY cat_metric DESC, var_metric ASC, category, var_name ");
+	q.sql = ast_str_buffer(sql);
 
 	q.var_val_size += 1;
 	q.var_val = ast_malloc(q.var_val_size);
@@ -965,9 +980,8 @@ static struct ast_config *config_odbc(co
 	}
 
 	stmt = ast_odbc_prepare_and_execute(obj, config_odbc_prepare, &q);
-
 	if (!stmt) {
-		ast_log(LOG_WARNING, "SQL select error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL select error! [%s]\n", ast_str_buffer(sql));
 		ast_odbc_release_obj(obj);
 		ast_free(q.var_val);
 		return NULL;
@@ -976,7 +990,7 @@ static struct ast_config *config_odbc(co
 	res = SQLNumResultCols(stmt, &rowcount);
 
 	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO)) {
-		ast_log(LOG_WARNING, "SQL NumResultCols error!\n[%s]\n\n", sql);
+		ast_log(LOG_WARNING, "SQL NumResultCols error! [%s]\n", ast_str_buffer(sql));
 		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 		ast_odbc_release_obj(obj);
 		ast_free(q.var_val);
@@ -1003,9 +1017,8 @@ static struct ast_config *config_odbc(co
 			continue;
 		} 
 		if (strcmp(last, q.category) || last_cat_metric != q.cat_metric) {
-			cur_cat = ast_category_new(q.category, "", 99999);
+			cur_cat = ast_category_new_dynamic(q.category);
 			if (!cur_cat) {
-				ast_log(LOG_WARNING, "Out of memory!\n");
 				break;
 			}
 			strcpy(last, q.category);
diff -urpN asterisk-13.9.1/res/res_config_pgsql.c asterisk-13.17.0/res/res_config_pgsql.c
--- asterisk-13.9.1/res/res_config_pgsql.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_config_pgsql.c	2017-07-12 13:12:08.000000000 +0200
@@ -270,6 +270,7 @@ static struct tables *find_table(const c
 	}
 
 	if (database == NULL) {
+		AST_LIST_UNLOCK(&psql_tables);
 		return NULL;
 	}
 
@@ -417,6 +418,9 @@ static struct columns *find_column(struc
 	return NULL;
 }
 
+#define IS_SQL_LIKE_CLAUSE(x) ((x) && ast_ends_with(x, " LIKE"))
+static char *ESCAPE_CLAUSE = " ESCAPE '\\'";
+
 static struct ast_variable *realtime_pgsql(const char *database, const char *tablename, const struct ast_variable *fields)
 {
 	RAII_VAR(PGresult *, result, NULL, PQclear);
@@ -426,6 +430,7 @@ static struct ast_variable *realtime_pgs
 	char *stringp;
 	char *chunk;
 	char *op;
+	char *escape = "";
 	const struct ast_variable *field = fields;
 	struct ast_variable *var = NULL, *prev = NULL;
 
@@ -440,6 +445,16 @@ static struct ast_variable *realtime_pgs
 		return NULL;
 	}
 
+	/*
+	 * Must connect to the server before anything else as ESCAPE_STRING()
+	 * uses pgsqlConn
+	 */
+	ast_mutex_lock(&pgsql_lock);
+	if (!pgsql_reconnect(database)) {
+		ast_mutex_unlock(&pgsql_lock);
+		return NULL;
+	}
+
 	/* Get the first parameter and first value in our list of passed paramater/value pairs */
 	if (!field) {
 		ast_log(LOG_WARNING,
@@ -448,38 +463,51 @@ static struct ast_variable *realtime_pgs
 			PQfinish(pgsqlConn);
 			pgsqlConn = NULL;
 		}
+		ast_mutex_unlock(&pgsql_lock);
 		return NULL;
 	}
 
 	/* Create the first part of the query using the first parameter/value pairs we just extracted
 	   If there is only 1 set, then we have our query. Otherwise, loop thru the list and concat */
-	op = strchr(field->name, ' ') ? "" : " =";
+	if (!strchr(field->name, ' ')) {
+		op = " =";
+	} else {
+		op = "";
+		if (IS_SQL_LIKE_CLAUSE(field->name)) {
+			escape = ESCAPE_CLAUSE;
+		}
+	}
 
 	ESCAPE_STRING(escapebuf, field->value);
 	if (pgresult) {
 		ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+		ast_mutex_unlock(&pgsql_lock);
 		return NULL;
 	}
 
-	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'", tablename, field->name, op, ast_str_buffer(escapebuf));
+	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'%s", tablename, field->name, op, ast_str_buffer(escapebuf), escape);
 	while ((field = field->next)) {
-		if (!strchr(field->name, ' '))
+		escape = "";
+		if (!strchr(field->name, ' ')) {
 			op = " =";
-		else
+		} else {
 			op = "";
+			if (IS_SQL_LIKE_CLAUSE(field->name)) {
+				escape = ESCAPE_CLAUSE;
+			}
+		}
 
 		ESCAPE_STRING(escapebuf, field->value);
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+			ast_mutex_unlock(&pgsql_lock);
 			return NULL;
 		}
 
-		ast_str_append(&sql, 0, " AND %s%s '%s'", field->name, op, ast_str_buffer(escapebuf));
+		ast_str_append(&sql, 0, " AND %s%s '%s'%s", field->name, op, ast_str_buffer(escapebuf), escape);
 	}
 
 	/* We now have our complete statement; Lets connect to the server and execute it. */
-	ast_mutex_lock(&pgsql_lock);
-
         if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {
 		ast_mutex_unlock(&pgsql_lock);
 		return NULL;
@@ -540,6 +568,7 @@ static struct ast_config *realtime_multi
 	char *stringp;
 	char *chunk;
 	char *op;
+	char *escape = "";
 	struct ast_variable *var = NULL;
 	struct ast_config *cfg = NULL;
 	struct ast_category *cat = NULL;
@@ -558,6 +587,16 @@ static struct ast_config *realtime_multi
 	if (!(cfg = ast_config_new()))
 		return NULL;
 
+	/*
+	 * Must connect to the server before anything else as ESCAPE_STRING()
+	 * uses pgsqlConn
+	 */
+	ast_mutex_lock(&pgsql_lock);
+	if (!pgsql_reconnect(database)) {
+		ast_mutex_unlock(&pgsql_lock);
+		return NULL;
+	}
+
 	/* Get the first parameter and first value in our list of passed paramater/value pairs */
 	if (!field) {
 		ast_log(LOG_WARNING,
@@ -566,6 +605,7 @@ static struct ast_config *realtime_multi
 			PQfinish(pgsqlConn);
 			pgsqlConn = NULL;
 		}
+		ast_mutex_unlock(&pgsql_lock);
 		ast_config_destroy(cfg);
 		return NULL;
 	}
@@ -578,43 +618,53 @@ static struct ast_config *realtime_multi
 	/* Create the first part of the query using the first parameter/value pairs we just extracted
 	   If there is only 1 set, then we have our query. Otherwise, loop thru the list and concat */
 
-	if (!strchr(field->name, ' '))
+	if (!strchr(field->name, ' ')) {
 		op = " =";
-	else
+		escape = "";
+	} else {
 		op = "";
+		if (IS_SQL_LIKE_CLAUSE(field->name)) {
+			escape = ESCAPE_CLAUSE;
+		}
+	}
 
 	ESCAPE_STRING(escapebuf, field->value);
 	if (pgresult) {
 		ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+		ast_mutex_unlock(&pgsql_lock);
 		ast_config_destroy(cfg);
 		return NULL;
 	}
 
-	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'", table, field->name, op, ast_str_buffer(escapebuf));
+	ast_str_set(&sql, 0, "SELECT * FROM %s WHERE %s%s '%s'%s", table, field->name, op, ast_str_buffer(escapebuf), escape);
 	while ((field = field->next)) {
-		if (!strchr(field->name, ' '))
+		escape = "";
+		if (!strchr(field->name, ' ')) {
 			op = " =";
-		else
+			escape = "";
+		} else {
 			op = "";
+			if (IS_SQL_LIKE_CLAUSE(field->name)) {
+				escape = ESCAPE_CLAUSE;
+			}
+		}
 
 		ESCAPE_STRING(escapebuf, field->value);
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+			ast_mutex_unlock(&pgsql_lock);
 			ast_config_destroy(cfg);
 			return NULL;
 		}
 
-		ast_str_append(&sql, 0, " AND %s%s '%s'", field->name, op, ast_str_buffer(escapebuf));
+		ast_str_append(&sql, 0, " AND %s%s '%s'%s", field->name, op, ast_str_buffer(escapebuf), escape);
 	}
 
 	if (initfield) {
 		ast_str_append(&sql, 0, " ORDER BY %s", initfield);
 	}
 
-
 	/* We now have our complete statement; Lets connect to the server and execute it. */
-	ast_mutex_lock(&pgsql_lock);
-
 	if (pgsql_exec(database, table, ast_str_buffer(sql), &result) != 0) {
 		ast_mutex_unlock(&pgsql_lock);
 		ast_config_destroy(cfg);
@@ -655,8 +705,10 @@ static struct ast_config *realtime_multi
 
 		for (rowIndex = 0; rowIndex < num_rows; rowIndex++) {
 			var = NULL;
-			if (!(cat = ast_category_new("","",99999)))
+			cat = ast_category_new_anonymous();
+			if (!cat) {
 				continue;
+			}
 			for (i = 0; i < numFields; i++) {
 				stringp = PQgetvalue(result, rowIndex, i);
 				while (stringp) {
@@ -709,6 +761,17 @@ static int update_pgsql(const char *data
 		return -1;
 	}
 
+	/*
+	 * Must connect to the server before anything else as ESCAPE_STRING()
+	 * uses pgsqlConn
+	 */
+	ast_mutex_lock(&pgsql_lock);
+	if (!pgsql_reconnect(database)) {
+		ast_mutex_unlock(&pgsql_lock);
+		release_table(table);
+		return -1;
+	}
+
 	/* Get the first parameter and first value in our list of passed paramater/value pairs */
 	if (!field) {
 		ast_log(LOG_WARNING,
@@ -717,6 +780,7 @@ static int update_pgsql(const char *data
 			PQfinish(pgsqlConn);
 			pgsqlConn = NULL;
 		}
+		ast_mutex_unlock(&pgsql_lock);
 		release_table(table);
 		return -1;
 	}
@@ -730,6 +794,7 @@ static int update_pgsql(const char *data
 
 	if (!column) {
 		ast_log(LOG_ERROR, "PostgreSQL RealTime: Updating on column '%s', but that column does not exist within the table '%s'!\n", field->name, tablename);
+		ast_mutex_unlock(&pgsql_lock);
 		release_table(table);
 		return -1;
 	}
@@ -740,6 +805,7 @@ static int update_pgsql(const char *data
 	ESCAPE_STRING(escapebuf, field->value);
 	if (pgresult) {
 		ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+		ast_mutex_unlock(&pgsql_lock);
 		release_table(table);
 		return -1;
 	}
@@ -754,6 +820,7 @@ static int update_pgsql(const char *data
 		ESCAPE_STRING(escapebuf, field->value);
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+			ast_mutex_unlock(&pgsql_lock);
 			release_table(table);
 			return -1;
 		}
@@ -765,6 +832,7 @@ static int update_pgsql(const char *data
 	ESCAPE_STRING(escapebuf, lookup);
 	if (pgresult) {
 		ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", lookup);
+		ast_mutex_unlock(&pgsql_lock);
 		return -1;
 	}
 
@@ -773,8 +841,6 @@ static int update_pgsql(const char *data
 	ast_debug(1, "PostgreSQL RealTime: Update SQL: %s\n", ast_str_buffer(sql));
 
 	/* We now have our complete statement; Lets connect to the server and execute it. */
-	ast_mutex_lock(&pgsql_lock);
-
 	if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {
 		ast_mutex_unlock(&pgsql_lock);
 		return -1;
@@ -841,12 +907,24 @@ static int update2_pgsql(const char *dat
 		return -1;
 	}
 
+	/*
+	 * Must connect to the server before anything else as ESCAPE_STRING()
+	 * uses pgsqlConn
+	 */
+	ast_mutex_lock(&pgsql_lock);
+	if (!pgsql_reconnect(database)) {
+		ast_mutex_unlock(&pgsql_lock);
+		release_table(table);
+		return -1;
+	}
+
 	ast_str_set(&sql, 0, "UPDATE %s SET", tablename);
 	ast_str_set(&where, 0, " WHERE");
 
 	for (field = lookup_fields; field; field = field->next) {
 		if (!find_column(table, field->name)) {
 			ast_log(LOG_ERROR, "Attempted to update based on criteria column '%s' (%s@%s), but that column does not exist!\n", field->name, tablename, database);
+			ast_mutex_unlock(&pgsql_lock);
 			release_table(table);
 			return -1;
 		}
@@ -854,6 +932,7 @@ static int update2_pgsql(const char *dat
 		ESCAPE_STRING(escapebuf, field->value);
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+			ast_mutex_unlock(&pgsql_lock);
 			release_table(table);
 			return -1;
 		}
@@ -868,6 +947,7 @@ static int update2_pgsql(const char *dat
 			PQfinish(pgsqlConn);
 			pgsqlConn = NULL;
 		}
+		ast_mutex_unlock(&pgsql_lock);
 		release_table(table);
 		return -1;
 	}
@@ -884,6 +964,7 @@ static int update2_pgsql(const char *dat
 		ESCAPE_STRING(escapebuf, field->value);
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", field->value);
+			ast_mutex_unlock(&pgsql_lock);
 			release_table(table);
 			return -1;
 		}
@@ -897,7 +978,7 @@ static int update2_pgsql(const char *dat
 
 	ast_debug(1, "PostgreSQL RealTime: Update SQL: %s\n", ast_str_buffer(sql));
 
-	/* We now have our complete statement; connect to the server and execute it. */
+	/* We now have our complete statement; Lets connect to the server and execute it. */
         if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {
 		ast_mutex_unlock(&pgsql_lock);
 	        return -1;
@@ -942,6 +1023,16 @@ static int store_pgsql(const char *datab
 		return -1;
 	}
 
+	/*
+	 * Must connect to the server before anything else as ESCAPE_STRING()
+	 * uses pgsqlConn
+	 */
+	ast_mutex_lock(&pgsql_lock);
+	if (!pgsql_reconnect(database)) {
+		ast_mutex_unlock(&pgsql_lock);
+		return -1;
+	}
+
 	/* Get the first parameter and first value in our list of passed paramater/value pairs */
 	if (!field) {
 		ast_log(LOG_WARNING,
@@ -950,12 +1041,6 @@ static int store_pgsql(const char *datab
 			PQfinish(pgsqlConn);
 			pgsqlConn = NULL;
 		}
-		return -1;
-	}
-
-	/* Must connect to the server before anything else, as the escape function requires the connection handle.. */
-	ast_mutex_lock(&pgsql_lock);
-	if (!pgsql_reconnect(database)) {
 		ast_mutex_unlock(&pgsql_lock);
 		return -1;
 	}
@@ -976,6 +1061,7 @@ static int store_pgsql(const char *datab
 
 	ast_debug(1, "PostgreSQL RealTime: Insert SQL: %s\n", ast_str_buffer(sql1));
 
+	/* We now have our complete statement; Lets connect to the server and execute it. */
         if (pgsql_exec(database, table, ast_str_buffer(sql1), &result) != 0) {
 		ast_mutex_unlock(&pgsql_lock);
 	        return -1;
@@ -1019,28 +1105,28 @@ static int destroy_pgsql(const char *dat
 		return -1;
 	}
 
+	/*
+	 * Must connect to the server before anything else as ESCAPE_STRING()
+	 * uses pgsqlConn
+	 */
+	ast_mutex_lock(&pgsql_lock);
+	if (!pgsql_reconnect(database)) {
+		ast_mutex_unlock(&pgsql_lock);
+		return -1;
+	}
+
 	/* Get the first parameter and first value in our list of passed paramater/value pairs */
-	/*newparam = va_arg(ap, const char *);
-	newval = va_arg(ap, const char *);
-	if (!newparam || !newval) {*/
 	if (ast_strlen_zero(keyfield) || ast_strlen_zero(lookup))  {
 		ast_log(LOG_WARNING,
 				"PostgreSQL RealTime: Realtime destroy requires at least 1 parameter and 1 value to search on.\n");
 		if (pgsqlConn) {
 			PQfinish(pgsqlConn);
 			pgsqlConn = NULL;
-		};
-		return -1;
-	}
-
-	/* Must connect to the server before anything else, as the escape function requires the connection handle.. */
-	ast_mutex_lock(&pgsql_lock);
-	if (!pgsql_reconnect(database)) {
+		}
 		ast_mutex_unlock(&pgsql_lock);
 		return -1;
 	}
 
-
 	/* Create the first part of the query using the first parameter/value pairs we just extracted
 	   If there is only 1 set, then we have our query. Otherwise, loop thru the list and concat */
 
@@ -1055,10 +1141,11 @@ static int destroy_pgsql(const char *dat
 
 	ast_debug(1, "PostgreSQL RealTime: Delete SQL: %s\n", ast_str_buffer(sql));
 
-        if (pgsql_exec(database, table, ast_str_buffer(sql), &result) != 0) {
+	/* We now have our complete statement; Lets connect to the server and execute it. */
+	if (pgsql_exec(database, table, ast_str_buffer(sql), &result) != 0) {
 		ast_mutex_unlock(&pgsql_lock);
-	        return -1;
-        }
+		return -1;
+	}
 
 	numrows = atoi(PQcmdTuples(result));
 	ast_mutex_unlock(&pgsql_lock);
@@ -1136,9 +1223,10 @@ static struct ast_config *config_pgsql(c
 			}
 
 			if (strcmp(last, field_category) || last_cat_metric != atoi(field_cat_metric)) {
-				cur_cat = ast_category_new(field_category, "", 99999);
-				if (!cur_cat)
+				cur_cat = ast_category_new_dynamic(field_category);
+				if (!cur_cat) {
 					break;
+				}
 				ast_copy_string(last, field_category, sizeof(last));
 				last_cat_metric = atoi(field_cat_metric);
 				ast_category_append(cfg, cur_cat);
@@ -1231,6 +1319,7 @@ static int require_pgsql(const char *dat
 		if (!column) {
 			if (requirements == RQ_WARN) {
 				ast_log(LOG_WARNING, "Table %s requires a column '%s' of size '%d', but no such column exists.\n", tablename, elm, size);
+				res = -1;
 			} else {
 				struct ast_str *sql = ast_str_create(100);
 				char fieldtype[15];
@@ -1270,7 +1359,8 @@ static int require_pgsql(const char *dat
 				ast_debug(1, "About to run ALTER query on table '%s' to add column '%s'\n", tablename, elm);
 
 			        if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {
-						ast_mutex_unlock(&pgsql_lock);
+					ast_mutex_unlock(&pgsql_lock);
+					release_table(table);
 				        return -1;
 			        }
 
@@ -1394,6 +1484,7 @@ static int parse_config(int is_reload)
 
 	ast_mutex_lock(&pgsql_lock);
 
+	/* XXX: Why would we do this before we're ready to establish a new connection? */
 	if (pgsqlConn) {
 		PQfinish(pgsqlConn);
 		pgsqlConn = NULL;
@@ -1501,13 +1592,18 @@ static int pgsql_reconnect(const char *d
 
 	/* mutex lock should have been locked before calling this function. */
 
-	if (pgsqlConn && PQstatus(pgsqlConn) != CONNECTION_OK) {
+	if (pgsqlConn) {
+		if (PQstatus(pgsqlConn) == CONNECTION_OK) {
+			/* We're good? */
+			return 1;
+		}
+
 		PQfinish(pgsqlConn);
 		pgsqlConn = NULL;
 	}
 
 	/* DB password can legitimately be 0-length */
-	if ((!pgsqlConn) && (!ast_strlen_zero(dbhost) || !ast_strlen_zero(dbsock)) && !ast_strlen_zero(dbuser) && !ast_strlen_zero(my_database)) {
+	if ((!ast_strlen_zero(dbhost) || !ast_strlen_zero(dbsock)) && !ast_strlen_zero(dbuser) && !ast_strlen_zero(my_database)) {
 		struct ast_str *conn_info = ast_str_create(128);
 
 		if (!conn_info) {
@@ -1605,7 +1701,7 @@ static char *handle_cli_realtime_pgsql_c
 static char *handle_cli_realtime_pgsql_status(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	char status[256], credentials[100] = "";
-	int ctimesec = time(NULL) - connect_time;
+	int is_connected = 0, ctimesec = time(NULL) - connect_time;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1621,7 +1717,11 @@ static char *handle_cli_realtime_pgsql_s
 	if (a->argc != 4)
 		return CLI_SHOWUSAGE;
 
-	if (pgsqlConn && PQstatus(pgsqlConn) == CONNECTION_OK) {
+	ast_mutex_lock(&pgsql_lock);
+	is_connected = (pgsqlConn && PQstatus(pgsqlConn) == CONNECTION_OK);
+	ast_mutex_unlock(&pgsql_lock);
+
+	if (is_connected) {
 		if (!ast_strlen_zero(dbhost))
 			snprintf(status, sizeof(status), "Connected to %s@%s, port %d", dbname, dbhost, dbport);
 		else if (!ast_strlen_zero(dbsock))
diff -urpN asterisk-13.9.1/res/res_config_sqlite.c asterisk-13.17.0/res/res_config_sqlite.c
--- asterisk-13.9.1/res/res_config_sqlite.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_config_sqlite.c	2017-07-12 13:12:08.000000000 +0200
@@ -875,10 +875,8 @@ static int add_cfg_entry(void *arg, int
 	}
 
 	if (!args->cat_name || strcmp(args->cat_name, argv[RES_CONFIG_SQLITE_CONFIG_CATEGORY])) {
-		args->cat = ast_category_new(argv[RES_CONFIG_SQLITE_CONFIG_CATEGORY], "", 99999);
-
+		args->cat = ast_category_new_dynamic(argv[RES_CONFIG_SQLITE_CONFIG_CATEGORY]);
 		if (!args->cat) {
-			ast_log(LOG_WARNING, "Unable to allocate category\n");
 			return 1;
 		}
 
@@ -1087,8 +1085,8 @@ static int add_rt_multi_cfg_entry(void *
 		return 1;
 	}
 
-	if (!(cat = ast_category_new(cat_name, "", 99999))) {
-		ast_log(LOG_WARNING, "Unable to allocate category\n");
+	cat = ast_category_new_dynamic(cat_name);
+	if (!cat) {
 		return 1;
 	}
 
@@ -1683,7 +1681,7 @@ static int load_module(void)
 		ast_log(LOG_ERROR, "%s\n", S_OR(errormsg, sqlite_error_string(error)));
 		sqlite_freemem(errormsg);
 		unload_module();
-		return 1;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	sqlite_freemem(errormsg);
@@ -1703,7 +1701,7 @@ static int load_module(void)
 		if (!query) {
 			ast_log(LOG_ERROR, "Unable to allocate SQL query\n");
 			unload_module();
-			return 1;
+			return AST_MODULE_LOAD_DECLINE;
 		}
 
 		ast_debug(1, "SQL query: %s\n", query);
@@ -1722,7 +1720,7 @@ static int load_module(void)
 				ast_log(LOG_ERROR, "%s\n", S_OR(errormsg, sqlite_error_string(error)));
 				sqlite_freemem(errormsg);
 				unload_module();
-				return 1;
+				return AST_MODULE_LOAD_DECLINE;
 			}
 
 			sqlite_freemem(errormsg);
@@ -1732,7 +1730,7 @@ static int load_module(void)
 			if (!query) {
 				ast_log(LOG_ERROR, "Unable to allocate SQL query\n");
 				unload_module();
-				return 1;
+				return AST_MODULE_LOAD_DECLINE;
 			}
 
 			ast_debug(1, "SQL query: %s\n", query);
@@ -1747,7 +1745,7 @@ static int load_module(void)
 				ast_log(LOG_ERROR, "%s\n", S_OR(errormsg, sqlite_error_string(error)));
 				sqlite_freemem(errormsg);
 				unload_module();
-				return 1;
+				return AST_MODULE_LOAD_DECLINE;
 			}
 		}
 		sqlite_freemem(errormsg);
@@ -1757,7 +1755,7 @@ static int load_module(void)
 
 		if (error) {
 			unload_module();
-			return 1;
+			return AST_MODULE_LOAD_DECLINE;
 		}
 
 		cdr_registered = 1;
@@ -1767,12 +1765,12 @@ static int load_module(void)
 
 	if (error) {
 		unload_module();
-		return 1;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	cli_status_registered = 1;
 
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Realtime SQLite configuration",
diff -urpN asterisk-13.9.1/res/res_config_sqlite3.c asterisk-13.17.0/res/res_config_sqlite3.c
--- asterisk-13.9.1/res/res_config_sqlite3.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_config_sqlite3.c	2017-07-12 13:12:08.000000000 +0200
@@ -60,6 +60,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 /*** DOCUMENTATION
  ***/
 
+static int has_explicit_like_escaping;
+
 static struct ast_config *realtime_sqlite3_load(const char *database, const char *table, const char *configfile, struct ast_config *config, struct ast_flags flags, const char *suggested_include_file, const char *who_asked);
 static struct ast_variable *realtime_sqlite3(const char *database, const char *table, const struct ast_variable *fields);
 static struct ast_config *realtime_sqlite3_multi(const char *database, const char *table, const struct ast_variable *fields);
@@ -115,7 +117,13 @@ AST_THREADSTORAGE(escape_table_buf);
 AST_THREADSTORAGE(escape_column_buf);
 AST_THREADSTORAGE(escape_value_buf);
 
-static int realtime_sqlite3_execute_handle(struct realtime_sqlite3_db *db, const char *sql, int (*callback)(void*, int, char **, char **), void *arg, int sync);
+typedef int (*callback_t)(void*, int, char **, char **);
+
+static int realtime_sqlite3_exec_query_with_handle(struct realtime_sqlite3_db *, const char *, callback_t, void *);
+static int realtime_sqlite3_exec_query(const char *, const char *, callback_t, void *);
+static int realtime_sqlite3_exec_update_with_handle(struct realtime_sqlite3_db *, const char *);
+static int realtime_sqlite3_exec_update(const char *, const char *);
+
 void db_start_batch(struct realtime_sqlite3_db *db);
 void db_stop_batch(struct realtime_sqlite3_db *db);
 
@@ -303,20 +311,20 @@ static void *db_sync_thread(void *data)
 {
 	struct realtime_sqlite3_db *db = data;
 	ao2_lock(db);
-	realtime_sqlite3_execute_handle(db, "BEGIN TRANSACTION", NULL, NULL, 0);
+	realtime_sqlite3_exec_query_with_handle(db, "BEGIN TRANSACTION", NULL, NULL);
 	for (;;) {
 		if (!db->wakeup) {
 			ast_cond_wait(&db->cond, ao2_object_get_lockaddr(db));
 		}
 		db->wakeup = 0;
-		if (realtime_sqlite3_execute_handle(db, "COMMIT", NULL, NULL, 0) < 0) {
-			realtime_sqlite3_execute_handle(db, "ROLLBACK", NULL, NULL, 0);
+		if (realtime_sqlite3_exec_query_with_handle(db, "COMMIT", NULL, NULL) < 0) {
+			realtime_sqlite3_exec_query_with_handle(db, "ROLLBACK", NULL, NULL);
 		}
 		if (db->exiting) {
 			ao2_unlock(db);
 			break;
 		}
-		realtime_sqlite3_execute_handle(db, "BEGIN TRANSACTION", NULL, NULL, 0);
+		realtime_sqlite3_exec_query_with_handle(db, "BEGIN TRANSACTION", NULL, NULL);
 		ao2_unlock(db);
 		usleep(1000 * db->batch);
 		ao2_lock(db);
@@ -497,7 +505,8 @@ static int append_row_to_cfg(void *arg,
 	struct ast_category *cat;
 	int i;
 
-	if (!(cat = ast_category_new("", "", 99999))) {
+	cat = ast_category_new_anonymous();
+	if (!cat) {
 		return SQLITE_ABORT;
 	}
 
@@ -527,18 +536,125 @@ struct cfg_entry_args {
 	const char *who_asked;
 };
 
-/*! Exeute an SQL statement given the database object
+/*!
+ * Structure passed to row counting SQLite callback.
+ */
+struct row_counter_args {
+	callback_t wrapped_callback;
+	void *wrapped_arg;
+	int row_count;
+};
+
+/*!
+ * \internal
+ * \brief SQLite3 callback that counts rows of a result set.
+ *
+ * \details
+ * This is used to decorate existing callbacks so that we can count the number
+ * of rows returned from a SELECT statement and still process each row
+ * independently.
+ *
+ * \param data user data pointer passed in via sqlite3_exec()
+ * \param num_columns number of columns in the result
+ * \param values array of pointers to column values
+ * \param columns array of pointers of to column names
+ *
+ * \return the return value of the wrapped callback, or 0 if no wrapped callback
+ *         is provided.
+ */
+static int row_counter_wrapper(void *arg, int num_columns, char **values, char **columns)
+{
+	struct row_counter_args *wrapped = arg;
+	wrapped->row_count++;
+	if (wrapped->wrapped_callback) {
+		return wrapped->wrapped_callback(wrapped->wrapped_arg, num_columns, values, columns);
+	}
+	return 0;
+}
+
+/*!
+ * \internal
+ * \brief Execute a SQL SELECT statement using a database handle
+ *
+ * \param db the database handle to use for the query
+ * \param sql the SQL statement to execute
+ * \param callback a user defined callback that will be called for each row of
+ *        the result set
+ * \param arg data to be passed to the user defined callback
+ *
+ * \return if successful, the number of rows returned from the provided SELECT
+ *         statement. -1 on failure.
+ */
+static int realtime_sqlite3_exec_query_with_handle(struct realtime_sqlite3_db *db, const char *sql, callback_t callback, void *arg)
+{
+	int res = 0;
+	char *errmsg;
+	struct row_counter_args wrapper = {
+		.wrapped_callback = callback,
+		.wrapped_arg = arg,
+		.row_count = 0,
+	};
+
+	ao2_lock(db);
+	if (sqlite3_exec(db->handle, sql, row_counter_wrapper, &wrapper, &errmsg) != SQLITE_OK) {
+		ast_log(LOG_WARNING, "Could not execute '%s': %s\n", sql, errmsg);
+		sqlite3_free(errmsg);
+		res = -1;
+	}
+	ao2_unlock(db);
+
+	return res == 0 ? wrapper.row_count : res;
+}
+
+/*!
+ * \internal
+ * \brief Execute a SQL SELECT statement on the specified database
+ *
+ * \param database the name of the database to query
+ * \param sql the SQL statement to execute
+ * \param callback a user defined callback that will be called for each row of
+ *        the result set
+ * \param arg data to be passed to the user defined callback
  *
- * \retval -1 ERROR
- * \retval > -1 Number of rows changed
+ * \return if successful, the number of rows returned from the provided SELECT
+ *         statement. -1 on failure.
  */
-static int realtime_sqlite3_execute_handle(struct realtime_sqlite3_db *db, const char *sql, int (*callback)(void*, int, char **, char **), void *arg, int sync)
+static int realtime_sqlite3_exec_query(const char *database, const char *sql, callback_t callback, void *arg)
+{
+	struct realtime_sqlite3_db *db;
+	int res;
+
+	if (!(db = find_database(database))) {
+		ast_log(LOG_WARNING, "Could not find database: %s\n", database);
+		return -1;
+	}
+
+	res = realtime_sqlite3_exec_query_with_handle(db, sql, callback, arg);
+	ao2_ref(db, -1);
+
+	return res;
+}
+
+/*!
+ * \internal
+ * \brief Execute a SQL INSERT/UPDATE/DELETE statement using a database handle
+ *
+ * \note A database sync operation is always performed after a statement
+ *       is executed.
+ *
+ * \param db the database handle to use for the query
+ * \param sql the SQL statement to execute
+ *
+ * \return if successful, the number of rows modified by the provided SQL
+ *         statement. -1 on failure.
+ */
+static int realtime_sqlite3_exec_update_with_handle(struct realtime_sqlite3_db *db, const char *sql)
 {
 	int res = 0;
 	char *errmsg;
 
 	ao2_lock(db);
-	if (sqlite3_exec(db->handle, sql, callback, arg, &errmsg) != SQLITE_OK) {
+	if (sqlite3_exec(db->handle, sql, NULL, NULL, &errmsg) != SQLITE_OK) {
 		ast_log(LOG_WARNING, "Could not execute '%s': %s\n", sql, errmsg);
 		sqlite3_free(errmsg);
 		res = -1;
@@ -547,19 +663,25 @@ static int realtime_sqlite3_execute_hand
 	}
 	ao2_unlock(db);
 
-	if (sync) {
-		db_sync(db);
-	}
+	db_sync(db);
 
 	return res;
 }
 
-/*! Exeute an SQL statement give the database name
+/*!
+ * \internal
+ * \brief Execute a SQL INSERT/UPDATE/DELETE statement using a database handle
+ *
+ * \note A database sync operation is always performed after a statement
+ *       is executed.
  *
- * \retval -1 ERROR
- * \retval > -1 Number of rows changed
+ * \param database the name of the database to query
+ * \param sql the SQL statement to execute
+ *
+ * \return if successful, the number of rows modified by the provided SQL
+ *         statement. -1 on failure.
  */
-static int realtime_sqlite3_execute(const char *database, const char *sql, int (*callback)(void*, int, char **, char **), void *arg, int sync)
+static int realtime_sqlite3_exec_update(const char *database, const char *sql)
 {
 	struct realtime_sqlite3_db *db;
 	int res;
@@ -569,7 +691,7 @@ static int realtime_sqlite3_execute(cons
 		return -1;
 	}
 
-	res = realtime_sqlite3_execute_handle(db, sql, callback, arg, sync);
+	res = realtime_sqlite3_exec_update_with_handle(db, sql);
 	ao2_ref(db, -1);
 
 	return res;
@@ -604,8 +726,8 @@ static int static_realtime_cb(void *arg,
 	}
 
 	if (!args->cat_name || strcmp(args->cat_name, values[COL_CATEGORY])) {
-		if (!(args->cat = ast_category_new(values[COL_CATEGORY], "", 99999))) {
-			ast_log(LOG_WARNING, "Unable to allocate category\n");
+		args->cat = ast_category_new_dynamic(values[COL_CATEGORY]);
+		if (!args->cat) {
 			return SQLITE_ABORT;
 		}
 
@@ -653,13 +775,15 @@ static struct ast_config *realtime_sqlit
 	args.flags = flags;
 	args.who_asked = who_asked;
 
-	realtime_sqlite3_execute(database, sql, static_realtime_cb, &args, 0);
+	realtime_sqlite3_exec_query(database, sql, static_realtime_cb, &args);
 
 	sqlite3_free(sql);
 
 	return config;
 }
 
+#define IS_SQL_LIKE_CLAUSE(x) ((x) && ast_ends_with(x, " LIKE"))
+
 /*! \brief Helper function for single and multi-row realtime load functions */
 static int realtime_sqlite3_helper(const char *database, const char *table, const struct ast_variable *fields, int is_multi, void *arg)
 {
@@ -685,13 +809,22 @@ static int realtime_sqlite3_helper(const
 			ast_str_append(&sql, 0, " AND %s %s", sqlite3_escape_column_op(field->name),
 					sqlite3_escape_value(field->value));
 		}
+
+		if (has_explicit_like_escaping && IS_SQL_LIKE_CLAUSE(field->name)) {
+			/*
+			 * The realtime framework is going to pre-escape these
+			 * for us with a backslash. We just need to make sure
+			 * to tell SQLite about it
+			 */
+			ast_str_append(&sql, 0, " ESCAPE '\\'");
+		}
 	}
 
 	if (!is_multi) {
 		ast_str_append(&sql, 0, "%s", " LIMIT 1");
 	}
 
-	if (realtime_sqlite3_execute(database, ast_str_buffer(sql), is_multi ? append_row_to_cfg : row_to_varlist, arg, 0) < 0) {
+	if (realtime_sqlite3_exec_query(database, ast_str_buffer(sql), is_multi ? append_row_to_cfg : row_to_varlist, arg) < 0) {
 		ast_free(sql);
 		return -1;
 	}
@@ -762,7 +895,7 @@ static int realtime_sqlite3_update(const
 
 	ast_str_append(&sql, 0, " WHERE %s %s", sqlite3_escape_column_op(keyfield), sqlite3_escape_value(entity));
 
-	res = realtime_sqlite3_execute(database, ast_str_buffer(sql), NULL, NULL, 1);
+	res = realtime_sqlite3_exec_update(database, ast_str_buffer(sql));
 	ast_free(sql);
 
 	return res;
@@ -813,7 +946,7 @@ static int realtime_sqlite3_update2(cons
 
 	ast_str_append(&sql, 0, "%s", ast_str_buffer(where_clause));
 
-	res = realtime_sqlite3_execute(database, ast_str_buffer(sql), NULL, NULL, 1);
+	res = realtime_sqlite3_exec_update(database, ast_str_buffer(sql));
 
 	ast_free(sql);
 	ast_free(where_clause);
@@ -857,7 +990,7 @@ static int realtime_sqlite3_store(const
 
 	ast_str_append(&sql, 0, "%s)", ast_str_buffer(values));
 
-	res = realtime_sqlite3_execute(database, ast_str_buffer(sql), NULL, NULL, 1);
+	res = realtime_sqlite3_exec_update(database, ast_str_buffer(sql));
 
 	ast_free(sql);
 	ast_free(values);
@@ -893,7 +1026,7 @@ static int realtime_sqlite3_destroy(cons
 		}
 	}
 
-	res = realtime_sqlite3_execute(database, ast_str_buffer(sql), NULL, NULL, 1);
+	res = realtime_sqlite3_exec_update(database, ast_str_buffer(sql));
 
 	ast_free(sql);
 
@@ -946,7 +1079,9 @@ static int handle_missing_table(struct r
 		return -1;
 	}
 
-	while ((column = va_arg(ap, typeof(column))) && (type = va_arg(ap, typeof(type))) && (sz = va_arg(ap, typeof(sz)))) {
+	while ((column = va_arg(ap, typeof(column)))) {
+		type = va_arg(ap, typeof(type));
+		sz = va_arg(ap, typeof(sz));
 		if (first) {
 			ast_str_set(&sql, 0, "CREATE TABLE IF NOT EXISTS %s (%s %s", sqlite3_escape_table(table),
 					sqlite3_escape_column(column), get_sqlite_column_type(type));
@@ -958,7 +1093,7 @@ static int handle_missing_table(struct r
 
 	ast_str_append(&sql, 0, ")");
 
-	res = realtime_sqlite3_execute_handle(db, ast_str_buffer(sql), NULL, NULL, 1) < 0 ? -1 : 0;
+	res = realtime_sqlite3_exec_update_with_handle(db, ast_str_buffer(sql)) < 0 ? -1 : 0;
 	ast_free(sql);
 
 	return res;
@@ -983,7 +1118,7 @@ static int handle_missing_column(struct
 		return -1;
 	}
 
-	if (!(res = (realtime_sqlite3_execute_handle(db, sql, NULL, NULL, 1) < 0 ? -1 : 0))) {
+	if (!(res = (realtime_sqlite3_exec_update_with_handle(db, sql) < 0 ? -1 : 0))) {
 		ast_log(LOG_NOTICE, "Creating column '%s' type %s for table %s\n", column, sqltype, table);
 	}
 
@@ -1061,7 +1196,7 @@ static int realtime_sqlite3_require(cons
 		return -1;
 	}
 
-	if ((res = realtime_sqlite3_execute_handle(db, sql, add_column_name, columns, 0)) < 0) {
+	if ((res = realtime_sqlite3_exec_query_with_handle(db, sql, add_column_name, columns)) < 0) {
 		unref_db(&db);
 		ao2_ref(columns, -1);
 		sqlite3_free(sql);
@@ -1077,8 +1212,10 @@ static int realtime_sqlite3_require(cons
 
 	sqlite3_free(sql);
 
-	while ((column = va_arg(ap, typeof(column))) && (type = va_arg(ap, typeof(type))) && (sz = va_arg(ap, typeof(sz)))) {
+	while ((column = va_arg(ap, typeof(column)))) {
 		char *found;
+		type = va_arg(ap, typeof(type));
+		sz = va_arg(ap, typeof(sz));
 		if (!(found = ao2_find(columns, column, OBJ_POINTER | OBJ_UNLINK))) {
 			if (handle_missing_column(db, table, column, type, sz)) {
 				unref_db(&db);
@@ -1127,6 +1264,8 @@ static int parse_config(int reload)
 	if (config == CONFIG_STATUS_FILEMISSING || config == CONFIG_STATUS_FILEINVALID) {
 		ast_log(LOG_ERROR, "%s config file '%s'\n",
 			config == CONFIG_STATUS_FILEMISSING ? "Missing" : "Invalid", config_filename);
+		ast_mutex_unlock(&config_lock);
+		return 0;
 	} else {
 		const char *cat;
 		struct realtime_sqlite3_db *db;
@@ -1184,6 +1323,29 @@ static int unload_module(void)
 	return 0;
 }
 
+static void discover_sqlite3_caps(void)
+{
+	/*
+	 * So we cheat a little bit here. SQLite3 added support for the
+	 * 'ESCAPE' keyword in 3.1.0. They added SQLITE_VERSION_NUMBER
+	 * in 3.1.2. So if we run into 3.1.0 or 3.1.1 in the wild, we
+	 * just treat it like < 3.1.0.
+	 *
+	 * For reference: 3.1.0, 3.1.1, and 3.1.2 were all released
+	 * within 30 days of each other in Jan/Feb 2005, so I don't
+	 * imagine we'll be finding something pre-3.1.2 that often in
+	 * practice.
+	 */
+#if defined(SQLITE_VERSION_NUMBER)
+	has_explicit_like_escaping = 1;
+#else
+	has_explicit_like_escaping = 0;
+#endif
+
+	ast_debug(3, "SQLite3 has 'LIKE ... ESCAPE ...' support? %s\n",
+			has_explicit_like_escaping ? "Yes" : "No");
+}
+
 /*!
  * \brief Load the module
  *
@@ -1196,19 +1358,21 @@ static int unload_module(void)
  */
 static int load_module(void)
 {
+	discover_sqlite3_caps();
+
 	if (!((databases = ao2_container_alloc(DB_BUCKETS, db_hash_fn, db_cmp_fn)))) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (parse_config(0)) {
 		ao2_ref(databases, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(ast_config_engine_register(&sqlite3_config_engine))) {
 		ast_log(LOG_ERROR, "The config API must have changed, this shouldn't happen.\n");
 		ao2_ref(databases, -1);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_corosync.c asterisk-13.17.0/res/res_corosync.c
--- asterisk-13.9.1/res/res_corosync.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_corosync.c	2017-07-12 13:12:08.000000000 +0200
@@ -47,11 +47,16 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/app.h"
 #include "asterisk/stasis.h"
 #include "asterisk/stasis_message_router.h"
+#include "asterisk/stasis_system.h"
 
 AST_RWLOCK_DEFINE_STATIC(event_types_lock);
 
 static void publish_mwi_to_stasis(struct ast_event *event);
 static void publish_device_state_to_stasis(struct ast_event *event);
+static void publish_cluster_discovery_to_stasis(struct ast_event *event);
+
+/*! \brief All the nodes that we're aware of */
+static struct ao2_container *nodes;
 
 /*! \brief The internal topic used for message forwarding and pings */
 static struct stasis_topic *corosync_aggregate_topic;
@@ -65,6 +70,87 @@ static struct stasis_topic *corosync_top
 	return corosync_aggregate_topic;
 }
 
+struct corosync_node {
+	/*! The corosync ID */
+	int id;
+	/*! The Asterisk EID */
+	struct ast_eid eid;
+	/*! The IP address of the node */
+	struct ast_sockaddr addr;
+};
+
+/*! \brief Corosync ipc dispatch/request and reply size */
+#define COROSYNC_IPC_BUFFER_SIZE				(8192 * 128)
+
+/*! \brief Version of pthread_create to ensure stack is large enough */
+#define corosync_pthread_create_background(a, b, c, d)				\
+	ast_pthread_create_stack(a, b, c, d,					\
+		(AST_BACKGROUND_STACKSIZE + (3 * COROSYNC_IPC_BUFFER_SIZE)),	\
+		__FILE__, __FUNCTION__, __LINE__, #c)
+
+static struct corosync_node *corosync_node_alloc(struct ast_event *event)
+{
+	struct corosync_node *node;
+
+	node = ao2_alloc_options(sizeof(*node), NULL, AO2_ALLOC_OPT_LOCK_NOLOCK);
+	if (!node) {
+		return NULL;
+	}
+
+	memcpy(&node->eid, (struct ast_eid *)ast_event_get_ie_raw(event, AST_EVENT_IE_EID), sizeof(node->eid));
+	node->id = ast_event_get_ie_uint(event, AST_EVENT_IE_NODE_ID);
+	ast_sockaddr_parse(&node->addr, ast_event_get_ie_str(event, AST_EVENT_IE_LOCAL_ADDR), PARSE_PORT_IGNORE);
+
+	return node;
+}
+
+static int corosync_node_hash_fn(const void *obj, const int flags)
+{
+	const struct corosync_node *node;
+	const int *id;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_KEY:
+		id = obj;
+		break;
+	case OBJ_SEARCH_OBJECT:
+		node = obj;
+		id = &node->id;
+		break;
+	default:
+		ast_assert(0);
+		return 0;
+	}
+	return *id;
+}
+
+static int corosync_node_cmp_fn(void *obj, void *arg, int flags)
+{
+	struct corosync_node *left = obj;
+	struct corosync_node *right = arg;
+	const int *id = arg;
+	int cmp;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_OBJECT:
+		id = &right->id;
+		/* Fall through */
+	case OBJ_SEARCH_KEY:
+		cmp = (left->id == *id);
+		break;
+	case OBJ_SEARCH_PARTIAL_KEY:
+		cmp = (left->id == right->id);
+		break;
+	default:
+		/* Sort can only work on something with a full or partial key. */
+		ast_assert(0);
+		cmp = 1;
+		break;
+	}
+	return cmp ? CMP_MATCH : 0;
+}
+
+
 /*! \brief A payload wrapper around a corosync ping event */
 struct corosync_ping_payload {
 	/*! The corosync ping event being passed over \ref stasis */
@@ -167,6 +253,12 @@ static struct {
 	                     .topic_fn = corosync_topic,
 	                     .message_type_fn = corosync_ping_message_type,
 	                     .publish_to_stasis = publish_corosync_ping_to_stasis, },
+	[AST_EVENT_CLUSTER_DISCOVERY] = { .name = "cluster_discovery",
+	                                  .publish_default = 1,
+	                                  .subscribe_default = 1,
+	                                  .topic_fn = ast_system_topic,
+	                                  .message_type_fn = ast_cluster_discovery_type,
+	                                  .publish_to_stasis = publish_cluster_discovery_to_stasis, },
 };
 
 static struct {
@@ -197,6 +289,97 @@ static corosync_cfg_callbacks_t cfg_call
 	.corosync_cfg_shutdown_callback = cfg_shutdown_cb,
 };
 
+/*! \brief Publish cluster discovery to \ref stasis */
+static void publish_cluster_discovery_to_stasis_full(struct corosync_node *node, int joined)
+{
+	struct ast_json *json;
+	struct ast_json_payload *payload;
+	struct stasis_message *message;
+	char eid[18];
+	const char *addr;
+
+	ast_eid_to_str(eid, sizeof(eid), &node->eid);
+	addr = ast_sockaddr_stringify_addr(&node->addr);
+
+	ast_log(AST_LOG_NOTICE, "Node %u (%s) at %s %s the cluster\n",
+		node->id,
+		eid,
+		addr,
+		joined ? "joined" : "left");
+
+	json = ast_json_pack("{s: s, s: i, s: s, s: i}",
+		"address", addr,
+		"node_id", node->id,
+		"eid", eid,
+		"joined", joined);
+	if (!json) {
+		return;
+	}
+
+	payload = ast_json_payload_create(json);
+	if (!payload) {
+		ast_json_unref(json);
+		return;
+	}
+
+	message = stasis_message_create(ast_cluster_discovery_type(), payload);
+	if (!message) {
+		ast_json_unref(json);
+		ao2_ref(payload, -1);
+		return;
+	}
+
+	stasis_publish(ast_system_topic(), message);
+	ast_json_unref(json);
+	ao2_ref(payload, -1);
+	ao2_ref(message, -1);
+}
+
+static void send_cluster_notify(void);
+
+/*! \brief Publish a received cluster discovery \ref ast_event to \ref stasis */
+static void publish_cluster_discovery_to_stasis(struct ast_event *event)
+{
+	struct corosync_node *node;
+	int id = ast_event_get_ie_uint(event, AST_EVENT_IE_NODE_ID);
+	struct ast_eid *event_eid;
+
+	ast_assert(ast_event_get_type(event) == AST_EVENT_CLUSTER_DISCOVERY);
+
+	event_eid = (struct ast_eid *)ast_event_get_ie_raw(event, AST_EVENT_IE_EID);
+	if (!ast_eid_cmp(&ast_eid_default, event_eid)) {
+		/* Don't feed events back in that originated locally. */
+		return;
+	}
+
+	ao2_lock(nodes);
+	node = ao2_find(nodes, &id, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (node) {
+		/* We already know about this node */
+		ao2_unlock(nodes);
+		ao2_ref(node, -1);
+		return;
+	}
+
+	node = corosync_node_alloc(event);
+	if (!node) {
+		ao2_unlock(nodes);
+		return;
+	}
+	ao2_link_flags(nodes, node, OBJ_NOLOCK);
+	ao2_unlock(nodes);
+
+	publish_cluster_discovery_to_stasis_full(node, 1);
+
+	ao2_ref(node, -1);
+
+	/*
+	 * When we get news that someone else has joined, we need to let them
+	 * know we exist as well.
+	 */
+	send_cluster_notify();
+}
+
 /*! \brief Publish a received MWI \ref ast_event to \ref stasis */
 static void publish_mwi_to_stasis(struct ast_event *event)
 {
@@ -228,7 +411,7 @@ static void publish_mwi_to_stasis(struct
 
 	if (ast_publish_mwi_state_full(mailbox, context, (int)new_msgs,
 	                               (int)old_msgs, NULL, event_eid)) {
-		char eid[16];
+		char eid[18];
 		ast_eid_to_str(eid, sizeof(eid), event_eid);
 		ast_log(LOG_WARNING, "Failed to publish MWI message for %s@%s from %s\n",
 			mailbox, context, eid);
@@ -255,7 +438,7 @@ static void publish_device_state_to_stas
 	}
 
 	if (ast_publish_device_state_full(device, state, cachable, event_eid)) {
-		char eid[16];
+		char eid[18];
 		ast_eid_to_str(eid, sizeof(eid), event_eid);
 		ast_log(LOG_WARNING, "Failed to publish device state message for %s from %s\n",
 			device, eid);
@@ -342,10 +525,27 @@ static void cpg_deliver_cb(cpg_handle_t
 	publish_handler(event);
 }
 
-static void publish_to_corosync(struct stasis_message *message)
+static void publish_event_to_corosync(struct ast_event *event)
 {
 	cs_error_t cs_err;
 	struct iovec iov;
+
+	iov.iov_base = (void *)event;
+	iov.iov_len = ast_event_get_size(event);
+
+	ast_debug(5, "Publishing event %s (%u) to corosync\n",
+		ast_event_get_type_name(event), ast_event_get_type(event));
+
+	/* The stasis subscription will only exist if we are configured to publish
+	 * these events, so just send away. */
+	if ((cs_err = cpg_mcast_joined(cpg_handle, CPG_TYPE_FIFO, &iov, 1)) != CS_OK) {
+		ast_log(LOG_WARNING, "CPG mcast failed (%u) for event %s (%u)\n",
+			cs_err, ast_event_get_type_name(event), ast_event_get_type(event));
+	}
+}
+
+static void publish_to_corosync(struct stasis_message *message)
+{
 	struct ast_event *event;
 
 	event = stasis_message_to_event(message);
@@ -368,17 +568,7 @@ static void publish_to_corosync(struct s
 		ast_log(LOG_NOTICE, "Sending event PING from this server with EID: '%s'\n", buf);
 	}
 
-	iov.iov_base = (void *)event;
-	iov.iov_len = ast_event_get_size(event);
-
-	ast_debug(5, "Publishing event %s (%u) to corosync\n",
-		ast_event_get_type_name(event), ast_event_get_type(event));
-
-	/* The stasis subscription will only exist if we are configured to publish
-	 * these events, so just send away. */
-	if ((cs_err = cpg_mcast_joined(cpg_handle, CPG_TYPE_FIFO, &iov, 1)) != CS_OK) {
-		ast_log(LOG_WARNING, "CPG mcast failed (%u)\n", cs_err);
-	}
+	publish_event_to_corosync(event);
 }
 
 static void stasis_message_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message)
@@ -410,9 +600,22 @@ static void cpg_confchg_cb(cpg_handle_t
 {
 	unsigned int i;
 
+
+	for (i = 0; i < left_list_entries; i++) {
+		const struct cpg_address *cpg_node = &left_list[i];
+		struct corosync_node* node;
+
+		node = ao2_find(nodes, &cpg_node->nodeid, OBJ_UNLINK | OBJ_SEARCH_KEY);
+		if (!node) {
+			continue;
+		}
+
+		publish_cluster_discovery_to_stasis_full(node, 0);
+		ao2_ref(node, -1);
+	}
+
 	/* If any new nodes have joined, dump our cache of events we are publishing
 	 * that originated from this server. */
-
 	if (!joined_list_entries) {
 		return;
 	}
@@ -442,6 +645,45 @@ static void cpg_confchg_cb(cpg_handle_t
 	}
 }
 
+/*! \brief Informs the cluster of our EID and our IP addresses */
+static void send_cluster_notify(void)
+{
+	struct ast_event *event;
+	unsigned int node_id;
+	cs_error_t cs_err;
+	corosync_cfg_node_address_t corosync_addr;
+	int num_addrs = 0;
+	struct sockaddr *sa;
+	size_t sa_len;
+	char buf[128];
+	int res;
+
+	if ((cs_err = corosync_cfg_local_get(cfg_handle, &node_id)) != CS_OK) {
+		ast_log(LOG_WARNING, "Failed to extract Corosync node ID for this node. Not informing cluster of existance.\n");
+		return;
+	}
+
+	if (((cs_err = corosync_cfg_get_node_addrs(cfg_handle, node_id, 1, &num_addrs, &corosync_addr)) != CS_OK) || (num_addrs < 1)) {
+		ast_log(LOG_WARNING, "Failed to get local Corosync address. Not informing cluster of existance.\n");
+		return;
+	}
+
+	sa = (struct sockaddr *)corosync_addr.address;
+	sa_len = (size_t)corosync_addr.address_length;
+	if ((res = getnameinfo(sa, sa_len, buf, sizeof(buf), NULL, 0, NI_NUMERICHOST))) {
+		ast_log(LOG_WARNING, "Failed to determine name of local Corosync address: %s (%d). Not informing cluster of existance.\n",
+			gai_strerror(res), res);
+		return;
+	}
+
+	event = ast_event_new(AST_EVENT_CLUSTER_DISCOVERY,
+				    AST_EVENT_IE_NODE_ID, AST_EVENT_IE_PLTYPE_UINT, node_id,
+				    AST_EVENT_IE_LOCAL_ADDR, AST_EVENT_IE_PLTYPE_STR, buf,
+				    AST_EVENT_IE_END);
+	publish_event_to_corosync(event);
+	ast_free(event);
+}
+
 static void *dispatch_thread_handler(void *data)
 {
 	cs_error_t cs_err;
@@ -463,6 +705,7 @@ static void *dispatch_thread_handler(voi
 
 	pfd[2].fd = dispatch_thread.alert_pipe[0];
 
+	send_cluster_notify();
 	while (!dispatch_thread.stop) {
 		int res;
 
@@ -530,6 +773,7 @@ static void *dispatch_thread_handler(voi
 			}
 
 			ast_log(LOG_NOTICE, "Corosync recovery complete.\n");
+			send_cluster_notify();
 		}
 	}
 
@@ -575,10 +819,21 @@ static char *corosync_show_members(struc
 	for (i = 1, cs_err = cpg_iteration_next(cpg_iter, &cpg_desc);
 			cs_err == CS_OK;
 			cs_err = cpg_iteration_next(cpg_iter, &cpg_desc), i++) {
+#ifdef HAVE_COROSYNC_CFG_STATE_TRACK
 		corosync_cfg_node_address_t addrs[8];
 		int num_addrs = 0;
 		unsigned int j;
+#endif
+
+		ast_cli(a->fd, "=== Node %u\n", i);
+		ast_cli(a->fd, "=== --> Group: %s\n", cpg_desc.group.value);
 
+#ifdef HAVE_COROSYNC_CFG_STATE_TRACK
+		/*
+		 * Corosync 2.x cfg lib needs to allocate 1M on stack after calling
+		 * corosync_cfg_get_node_addrs. netconsole thread has allocated only 0.5M
+		 * resulting in crash.
+		 */
 		cs_err = corosync_cfg_get_node_addrs(cfg_handle, cpg_desc.nodeid,
 				ARRAY_LEN(addrs), &num_addrs, addrs);
 		if (cs_err != CS_OK) {
@@ -586,9 +841,6 @@ static char *corosync_show_members(struc
 			continue;
 		}
 
-		ast_cli(a->fd, "=== Node %u\n", i);
-		ast_cli(a->fd, "=== --> Group: %s\n", cpg_desc.group.value);
-
 		for (j = 0; j < num_addrs; j++) {
 			struct sockaddr *sa = (struct sockaddr *) addrs[j].address;
 			size_t sa_len = (size_t) addrs[j].address_length;
@@ -598,7 +850,9 @@ static char *corosync_show_members(struc
 
 			ast_cli(a->fd, "=== --> Address %u: %s\n", j + 1, buf);
 		}
-
+#else
+		ast_cli(a->fd, "=== --> Nodeid: %"PRIu32"\n", cpg_desc.nodeid);
+#endif
 	}
 
 	ast_cli(a->fd, "===\n"
@@ -858,6 +1112,9 @@ static void cleanup_module(void)
 		ast_log(LOG_ERROR, "Failed to finalize cfg (%d)\n", (int) cs_err);
 	}
 	cfg_handle = 0;
+
+	ao2_cleanup(nodes);
+	nodes = NULL;
 }
 
 static int load_module(void)
@@ -865,6 +1122,16 @@ static int load_module(void)
 	cs_error_t cs_err;
 	struct cpg_name name;
 
+	if (ast_eid_is_empty(&ast_eid_default)) {
+		ast_log(LOG_ERROR, "Entity ID is not set.\n");
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	nodes = ao2_container_alloc(23, corosync_node_hash_fn, corosync_node_cmp_fn);
+	if (!nodes) {
+		goto failed;
+	}
+
 	corosync_aggregate_topic = stasis_topic_create("corosync_aggregate_topic");
 	if (!corosync_aggregate_topic) {
 		ast_log(AST_LOG_ERROR, "Failed to create stasis topic for corosync\n");
@@ -911,7 +1178,7 @@ static int load_module(void)
 		goto failed;
 	}
 
-	if (ast_pthread_create_background(&dispatch_thread.id, NULL,
+	if (corosync_pthread_create_background(&dispatch_thread.id, NULL,
 			dispatch_thread_handler, NULL)) {
 		ast_log(LOG_ERROR, "Error starting CPG dispatch thread.\n");
 		goto failed;
@@ -919,6 +1186,7 @@ static int load_module(void)
 
 	ast_cli_register_multiple(corosync_cli, ARRAY_LEN(corosync_cli));
 
+
 	return AST_MODULE_LOAD_SUCCESS;
 
 failed:
diff -urpN asterisk-13.9.1/res/res_endpoint_stats.c asterisk-13.17.0/res/res_endpoint_stats.c
--- asterisk-13.9.1/res/res_endpoint_stats.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_endpoint_stats.c	2017-07-12 13:12:08.000000000 +0200
@@ -120,7 +120,7 @@ static int load_module(void)
 
 	router = stasis_message_router_create(ast_endpoint_topic_all_cached());
 	if (!router) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	stasis_message_router_add(router, stasis_cache_update_type(), cache_update_cb, NULL);
 
diff -urpN asterisk-13.9.1/res/res_fax.c asterisk-13.17.0/res/res_fax.c
--- asterisk-13.9.1/res/res_fax.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_fax.c	2017-07-12 13:12:08.000000000 +0200
@@ -468,8 +468,6 @@ struct fax_gateway {
 struct fax_detect {
 	/*! \brief the start of our timeout counter */
 	struct timeval timeout_start;
-	/*! \brief faxdetect timeout */
-	int timeout;
 	/*! \brief DSP Processor */
 	struct ast_dsp *dsp;
 	/*! \brief original audio formats */
@@ -626,6 +624,8 @@ static const struct ast_datastore_info f
 static int fax_gateway_attach(struct ast_channel *chan, struct ast_fax_session_details *details);
 static int fax_detect_attach(struct ast_channel *chan, int timeout, int flags);
 static struct ast_fax_session_details *find_or_create_details(struct ast_channel *chan);
+static struct ast_fax_session *fax_v21_session_new (struct ast_channel *chan);
+
 
 /*! \brief Copies fax detection and gateway framehooks during masquerades
  *
@@ -641,6 +641,7 @@ static void fixup_callback(void *data, s
 		struct ast_fax_session_details *new_details = find_or_create_details(new_chan);
 
 		ast_framehook_detach(old_chan, old_details->gateway_id);
+		new_details->is_t38_negotiated = old_details->is_t38_negotiated;
 		fax_gateway_attach(new_chan, new_details);
 		ao2_cleanup(new_details);
 	}
@@ -1414,11 +1415,13 @@ static int report_fax_status(struct ast_
 	}
 
 	json_object = ast_json_pack("{s: s, s: s, s: s, s: s, s: o}",
-			"type", "status",
-			"operation", (details->caps & AST_FAX_TECH_GATEWAY) ? "gateway" : (details->caps & AST_FAX_TECH_RECEIVE) ? "receive" : "send",
-			"status", status,
-			"local_station_id", details->localstationid,
-			"filenames", json_filenames);
+		"type", "status",
+		"operation", (details->caps & AST_FAX_TECH_GATEWAY)
+			? "gateway"
+			: (details->caps & AST_FAX_TECH_RECEIVE) ? "receive" : "send",
+		"status", status,
+		"local_station_id", AST_JSON_UTF8_VALIDATE(details->localstationid),
+		"filenames", json_filenames);
 	if (!json_object) {
 		return -1;
 	}
@@ -1439,6 +1442,7 @@ static int report_fax_status(struct ast_
 static void set_channel_variables(struct ast_channel *chan, struct ast_fax_session_details *details)
 {
 	char buf[10];
+
 	pbx_builtin_setvar_helper(chan, "FAXSTATUS", S_OR(details->result, NULL));
 	pbx_builtin_setvar_helper(chan, "FAXERROR", S_OR(details->error, NULL));
 	pbx_builtin_setvar_helper(chan, "FAXSTATUSSTRING", S_OR(details->resultstr, NULL));
@@ -1447,6 +1451,12 @@ static void set_channel_variables(struct
 	pbx_builtin_setvar_helper(chan, "FAXBITRATE", S_OR(details->transfer_rate, NULL));
 	pbx_builtin_setvar_helper(chan, "FAXRESOLUTION", S_OR(details->resolution, NULL));
 
+	if (details->is_t38_negotiated) {
+		pbx_builtin_setvar_helper(chan, "FAXMODE", "T38");
+	} else {
+		pbx_builtin_setvar_helper(chan, "FAXMODE", "audio");
+	}
+
 	snprintf(buf, sizeof(buf), "%u", details->pages_transferred);
 	pbx_builtin_setvar_helper(chan, "FAXPAGES", buf);
 }
@@ -1592,6 +1602,13 @@ static int generic_fax_exec(struct ast_c
 
 	chancount = 1;
 
+	/* Make sure one or the other is set to avoid race condition */
+	if (t38negotiated) {
+		details->caps |= AST_FAX_TECH_T38;
+	} else {
+		details->caps |= AST_FAX_TECH_AUDIO;
+	}
+
 	/* create the FAX session */
 	if (!(fax = fax_session_new(details, chan, reserved, token))) {
 		ast_log(LOG_ERROR, "Can't create a FAX session, FAX attempt failed.\n");
@@ -1650,6 +1667,7 @@ static int generic_fax_exec(struct ast_c
 	ast_string_field_set(details, result, "");
 	ast_string_field_set(details, resultstr, "");
 	ast_string_field_set(details, error, "");
+	details->is_t38_negotiated = t38negotiated;
 	set_channel_variables(chan, details);
 
 	if (fax->tech->start_session(fax) < 0) {
@@ -1700,12 +1718,18 @@ static int generic_fax_exec(struct ast_c
 					 * do T.38 as well
 					 */
 					t38_parameters_fax_to_ast(&t38_parameters, &details->our_t38_parameters);
-					t38_parameters.request_response = (details->caps & AST_FAX_TECH_T38) ? AST_T38_NEGOTIATED : AST_T38_REFUSED;
+					if (details->caps & AST_FAX_TECH_T38) {
+						details->is_t38_negotiated = 1;
+						t38_parameters.request_response = AST_T38_NEGOTIATED;
+					} else {
+						t38_parameters.request_response = AST_T38_REFUSED;
+					}
 					ast_indicate_data(chan, AST_CONTROL_T38_PARAMETERS, &t38_parameters, sizeof(t38_parameters));
 					break;
 				case AST_T38_NEGOTIATED:
 					t38_parameters_ast_to_fax(&details->their_t38_parameters, parameters);
 					t38negotiated = 1;
+					details->is_t38_negotiated = 1;
 					break;
 				default:
 					break;
@@ -2071,6 +2095,7 @@ static int receivefax_exec(struct ast_ch
 	pbx_builtin_setvar_helper(chan, "FAXPAGES", "0");
 	pbx_builtin_setvar_helper(chan, "FAXBITRATE", NULL);
 	pbx_builtin_setvar_helper(chan, "FAXRESOLUTION", NULL);
+	pbx_builtin_setvar_helper(chan, "FAXMODE", NULL);
 
 	/* Get a FAX session details structure from the channel's FAX datastore and create one if
 	 * it does not already exist. */
@@ -2578,6 +2603,7 @@ static int sendfax_exec(struct ast_chann
 	pbx_builtin_setvar_helper(chan, "FAXPAGES", "0");
 	pbx_builtin_setvar_helper(chan, "FAXBITRATE", NULL);
 	pbx_builtin_setvar_helper(chan, "FAXRESOLUTION", NULL);
+	pbx_builtin_setvar_helper(chan, "FAXMODE", NULL);
 
 	/* Get a requirement structure and set it.  This structure is used
 	 * to tell the FAX technology module about the higher level FAX session */
@@ -2827,6 +2853,20 @@ static void destroy_gateway(void *data)
 	ao2_cleanup(gateway->peer_write_format);
 }
 
+static struct ast_fax_session *fax_v21_session_new (struct ast_channel *chan) {
+	struct ast_fax_session_details *v21_details;
+	struct ast_fax_session *v21_session;
+
+	if (!chan || !(v21_details = session_details_new())) {
+		return NULL;
+	}
+
+	v21_details->caps = AST_FAX_TECH_V21_DETECT;
+	v21_session = fax_session_new(v21_details, chan, NULL, NULL);
+	ao2_ref(v21_details, -1);
+	return v21_session;
+}
+
 /*! \brief Create a new fax gateway object.
  * \param chan the channel the gateway object will be attached to
  * \param details the fax session details
@@ -2835,30 +2875,16 @@ static void destroy_gateway(void *data)
 static struct fax_gateway *fax_gateway_new(struct ast_channel *chan, struct ast_fax_session_details *details)
 {
 	struct fax_gateway *gateway = ao2_alloc(sizeof(*gateway), destroy_gateway);
-	struct ast_fax_session_details *v21_details;
 	if (!gateway) {
 		return NULL;
 	}
 
-	if (!(v21_details = session_details_new())) {
-		ao2_ref(gateway, -1);
-		return NULL;
-	}
-
-	v21_details->caps = AST_FAX_TECH_V21_DETECT;
-	if (!(gateway->chan_v21_session = fax_session_new(v21_details, chan, NULL, NULL))) {
-		ao2_ref(v21_details, -1);
+	if (!(gateway->chan_v21_session = fax_v21_session_new(chan))) {
+		ast_log(LOG_ERROR, "Can't create V21 session on chan %s for T.38 gateway session\n", ast_channel_name(chan));
 		ao2_ref(gateway, -1);
 		return NULL;
 	}
 
-	if (!(gateway->peer_v21_session = fax_session_new(v21_details, chan, NULL, NULL))) {
-		ao2_ref(v21_details, -1);
-		ao2_ref(gateway, -1);
-		return NULL;
-	}
-	ao2_ref(v21_details, -1);
-
 	gateway->framehook = -1;
 
 	details->caps = AST_FAX_TECH_GATEWAY;
@@ -2872,11 +2898,17 @@ static struct fax_gateway *fax_gateway_n
 	return gateway;
 }
 
-/*! \brief Create a fax session and start T.30<->T.38 gateway mode
+/*!
+ * \brief Create a fax session and start T.30<->T.38 gateway mode
+ *
  * \param gateway a fax gateway object
  * \param details fax session details
  * \param chan active channel
- * \return 0 on error 1 on success*/
+ *
+ * \pre chan is locked on entry
+ *
+ * \return 0 on error 1 on success
+ */
 static int fax_gateway_start(struct fax_gateway *gateway, struct ast_fax_session_details *details, struct ast_channel *chan)
 {
 	struct ast_fax_session *s;
@@ -2888,6 +2920,7 @@ static int fax_gateway_start(struct fax_
 		ast_string_field_set(details, result, "FAILED");
 		ast_string_field_set(details, resultstr, "error starting gateway session");
 		ast_string_field_set(details, error, "INIT_ERROR");
+		details->is_t38_negotiated = 0;
 		set_channel_variables(chan, details);
 		report_fax_status(chan, details, "No Available Resource");
 		ast_log(LOG_ERROR, "Can't create a FAX session, gateway attempt failed.\n");
@@ -2908,6 +2941,7 @@ static int fax_gateway_start(struct fax_
 		ast_string_field_set(details, result, "FAILED");
 		ast_string_field_set(details, resultstr, "error starting gateway session");
 		ast_string_field_set(details, error, "INIT_ERROR");
+		details->is_t38_negotiated = 0;
 		set_channel_variables(chan, details);
 		return -1;
 	}
@@ -2920,6 +2954,7 @@ static int fax_gateway_start(struct fax_
 	return 0;
 }
 
+/*! \pre chan is locked on entry */
 static struct ast_frame *fax_gateway_request_t38(struct fax_gateway *gateway, struct ast_channel *chan, struct ast_frame *f)
 {
 	struct ast_frame *fp;
@@ -2952,12 +2987,14 @@ static struct ast_frame *fax_gateway_req
 
 	gateway->t38_state = T38_STATE_NEGOTIATING;
 	gateway->timeout_start = ast_tvnow();
+	details->is_t38_negotiated = 0;
 	details->gateway_timeout = FAX_GATEWAY_TIMEOUT;
 
 	ast_debug(1, "requesting T.38 for gateway session for %s\n", ast_channel_name(chan));
 	return fp;
 }
 
+/*! \pre chan is locked on entry */
 static struct ast_frame *fax_gateway_detect_v21(struct fax_gateway *gateway, struct ast_channel *chan, struct ast_channel *peer, struct ast_channel *active, struct ast_frame *f)
 {
 	struct ast_channel *other = (active == chan) ? peer : chan;
@@ -2973,8 +3010,14 @@ static struct ast_frame *fax_gateway_det
 	}
 
 	if (gateway->detected_v21) {
+		enum ast_t38_state state_other;
+
 		destroy_v21_sessions(gateway);
-		if (ast_channel_get_t38_state(other) == T38_STATE_UNKNOWN) {
+
+		ast_channel_unlock(chan);
+		state_other = ast_channel_get_t38_state(other);
+		ast_channel_lock(chan);
+		if (state_other == T38_STATE_UNKNOWN) {
 			ast_debug(1, "detected v21 preamble from %s\n", ast_channel_name(active));
 			return fax_gateway_request_t38(gateway, chan, f);
 		} else {
@@ -2985,21 +3028,29 @@ static struct ast_frame *fax_gateway_det
 	return f;
 }
 
-static int fax_gateway_indicate_t38(struct ast_channel *chan, struct ast_channel *active, struct ast_control_t38_parameters *control_params)
+/*! \pre chan is locked on entry */
+static void fax_gateway_indicate_t38(struct ast_channel *chan, struct ast_channel *active, struct ast_control_t38_parameters *control_params)
 {
 	if (active == chan) {
-		return ast_indicate_data(chan, AST_CONTROL_T38_PARAMETERS, control_params, sizeof(*control_params));
+		ast_channel_unlock(chan);
+		ast_indicate_data(chan, AST_CONTROL_T38_PARAMETERS, control_params, sizeof(*control_params));
+		ast_channel_lock(chan);
 	} else {
-		return ast_queue_control_data(chan, AST_CONTROL_T38_PARAMETERS, control_params, sizeof(*control_params));
+		ast_queue_control_data(chan, AST_CONTROL_T38_PARAMETERS, control_params, sizeof(*control_params));
 	}
 }
 
-/*! \brief T38 Gateway Negotiate t38 parameters
+/*!
+ * \brief T38 Gateway Negotiate t38 parameters
+ *
  * \param gateway gateway object
  * \param chan channel running the gateway
  * \param peer channel im bridged too
  * \param active channel the frame originated on
  * \param f the control frame to process
+ *
+ * \pre chan is locked on entry
+ *
  * \return processed control frame or null frame
  */
 static struct ast_frame *fax_gateway_detect_t38(struct fax_gateway *gateway, struct ast_channel *chan, struct ast_channel *peer, struct ast_channel *active, struct ast_frame *f)
@@ -3007,6 +3058,7 @@ static struct ast_frame *fax_gateway_det
 	struct ast_control_t38_parameters *control_params = f->data.ptr;
 	struct ast_channel *other = (active == chan) ? peer : chan;
 	struct ast_fax_session_details *details;
+	enum ast_t38_state state_other;
 
 	if (f->datalen != sizeof(struct ast_control_t38_parameters)) {
 		/* invalaid AST_CONTROL_T38_PARAMETERS frame, we can't
@@ -3029,9 +3081,11 @@ static struct ast_frame *fax_gateway_det
 	}
 
 	if (control_params->request_response == AST_T38_REQUEST_NEGOTIATE) {
-		enum ast_t38_state state = ast_channel_get_t38_state(other);
+		ast_channel_unlock(chan);
+		state_other = ast_channel_get_t38_state(other);
+		ast_channel_lock(chan);
 
-		if (state == T38_STATE_UNKNOWN) {
+		if (state_other == T38_STATE_UNKNOWN) {
 			/* we detected a request to negotiate T.38 and the
 			 * other channel appears to support T.38, we'll pass
 			 * the request through and only step in if the other
@@ -3040,10 +3094,11 @@ static struct ast_frame *fax_gateway_det
 			t38_parameters_ast_to_fax(&details->their_t38_parameters, control_params);
 			gateway->t38_state = T38_STATE_UNKNOWN;
 			gateway->timeout_start = ast_tvnow();
+			details->is_t38_negotiated = 0;
 			details->gateway_timeout = FAX_GATEWAY_TIMEOUT;
 			ao2_ref(details, -1);
 			return f;
-		} else if (state == T38_STATE_UNAVAILABLE || state == T38_STATE_REJECTED) {
+		} else if (state_other == T38_STATE_UNAVAILABLE || state_other == T38_STATE_REJECTED) {
 			/* the other channel does not support T.38, we need to
 			 * step in here */
 			ast_debug(1, "%s is attempting to negotiate T.38 but %s does not support it\n", ast_channel_name(active), ast_channel_name(other));
@@ -3055,12 +3110,14 @@ static struct ast_frame *fax_gateway_det
 			if (fax_gateway_start(gateway, details, chan)) {
 				ast_log(LOG_ERROR, "error starting T.38 gateway for T.38 channel %s and G.711 channel %s\n", ast_channel_name(active), ast_channel_name(other));
 				gateway->t38_state = T38_STATE_REJECTED;
+				details->is_t38_negotiated = 0;
 				control_params->request_response = AST_T38_REFUSED;
 
 				ast_framehook_detach(chan, details->gateway_id);
 				details->gateway_id = -1;
 			} else {
 				gateway->t38_state = T38_STATE_NEGOTIATED;
+				details->is_t38_negotiated = chan == active;
 				control_params->request_response = AST_T38_NEGOTIATED;
 				report_fax_status(chan, details, "T.38 Negotiated");
 			}
@@ -3078,6 +3135,7 @@ static struct ast_frame *fax_gateway_det
 			t38_parameters_ast_to_fax(&details->their_t38_parameters, control_params);
 			gateway->t38_state = T38_STATE_UNKNOWN;
 			gateway->timeout_start = ast_tvnow();
+			details->is_t38_negotiated = 0;
 			details->gateway_timeout = FAX_GATEWAY_TIMEOUT;
 
 			ast_debug(1, "%s is attempting to negotiate T.38 after we already sent a negotiation request based on v21 preamble detection\n", ast_channel_name(active));
@@ -3100,6 +3158,7 @@ static struct ast_frame *fax_gateway_det
 			ast_string_field_set(details, result, "SUCCESS");
 			ast_string_field_set(details, resultstr, "no gateway necessary");
 			ast_string_field_set(details, error, "NATIVE_T38");
+			details->is_t38_negotiated = 1;
 			set_channel_variables(chan, details);
 
 			ast_debug(1, "%s is attempting to negotiate T.38 after we already negotiated T.38 with %s, disabling the gateway\n", ast_channel_name(active), ast_channel_name(other));
@@ -3114,11 +3173,15 @@ static struct ast_frame *fax_gateway_det
 		&& control_params->request_response == AST_T38_REFUSED) {
 
 		ast_debug(1, "unable to negotiate T.38 on %s for fax gateway\n", ast_channel_name(active));
+		details->is_t38_negotiated = 0;
 
 		/* our request to negotiate T.38 was refused, if the other
 		 * channel supports T.38, they might still reinvite and save
 		 * the day.  Otherwise disable the gateway. */
-		if (ast_channel_get_t38_state(other) == T38_STATE_UNKNOWN) {
+		ast_channel_unlock(chan);
+		state_other = ast_channel_get_t38_state(other);
+		ast_channel_lock(chan);
+		if (state_other == T38_STATE_UNKNOWN) {
 			gateway->t38_state = T38_STATE_UNAVAILABLE;
 		} else {
 			ast_framehook_detach(chan, details->gateway_id);
@@ -3142,11 +3205,13 @@ static struct ast_frame *fax_gateway_det
 		if (fax_gateway_start(gateway, details, chan)) {
 			ast_log(LOG_ERROR, "error starting T.38 gateway for T.38 channel %s and G.711 channel %s\n", ast_channel_name(active), ast_channel_name(other));
 			gateway->t38_state = T38_STATE_NEGOTIATING;
+			details->is_t38_negotiated = 0;
 			control_params->request_response = AST_T38_REQUEST_TERMINATE;
 
 			fax_gateway_indicate_t38(chan, active, control_params);
 		} else {
 			gateway->t38_state = T38_STATE_NEGOTIATED;
+			details->is_t38_negotiated = chan == active;
 			report_fax_status(chan, details, "T.38 Negotiated");
 		}
 
@@ -3162,14 +3227,16 @@ static struct ast_frame *fax_gateway_det
 		t38_parameters_fax_to_ast(control_params, &details->our_t38_parameters);
 
 		if (fax_gateway_start(gateway, details, chan)) {
-			ast_log(LOG_ERROR, "error starting T.38 gateway for T.38 channel %s and G.711 channel %s\n", ast_channel_name(active), ast_channel_name(other));
+			ast_log(LOG_ERROR, "error starting T.38 gateway for T.38 channel %s and G.711 channel %s\n", ast_channel_name(other), ast_channel_name(active));
 			gateway->t38_state = T38_STATE_REJECTED;
+			details->is_t38_negotiated = 0;
 			control_params->request_response = AST_T38_REFUSED;
 
 			ast_framehook_detach(chan, details->gateway_id);
 			details->gateway_id = -1;
 		} else {
 			gateway->t38_state = T38_STATE_NEGOTIATED;
+			details->is_t38_negotiated = chan == other;
 			control_params->request_response = AST_T38_NEGOTIATED;
 		}
 
@@ -3185,6 +3252,7 @@ static struct ast_frame *fax_gateway_det
 		details->gateway_id = -1;
 
 		gateway->t38_state = T38_STATE_REJECTED;
+		details->is_t38_negotiated = 0;
 		control_params->request_response = AST_T38_TERMINATED;
 
 		fax_gateway_indicate_t38(chan, active, control_params);
@@ -3200,6 +3268,7 @@ static struct ast_frame *fax_gateway_det
 		ast_string_field_set(details, result, "SUCCESS");
 		ast_string_field_set(details, resultstr, "no gateway necessary");
 		ast_string_field_set(details, error, "NATIVE_T38");
+		details->is_t38_negotiated = 1;
 		set_channel_variables(chan, details);
 
 		ao2_ref(details, -1);
@@ -3242,7 +3311,8 @@ static void fax_gateway_framehook_destro
 	ao2_ref(gateway, -1);
 }
 
-/*! \brief T.30<->T.38 gateway framehook.
+/*!
+ * \brief T.30<->T.38 gateway framehook.
  *
  * Intercept packets on bridged channels and determine if a T.38 gateway is
  * required. If a gateway is required, start a gateway and handle T.38
@@ -3253,6 +3323,8 @@ static void fax_gateway_framehook_destro
  * \param event framehook event
  * \param data framehook data (struct fax_gateway *)
  *
+ * \pre chan is locked on entry
+ *
  * \return processed frame or NULL when f is NULL or a null frame
  */
 static struct ast_frame *fax_gateway_framehook(struct ast_channel *chan, struct ast_frame *f, enum ast_framehook_event event, void *data)
@@ -3315,8 +3387,16 @@ static struct ast_frame *fax_gateway_fra
 	}
 
 	if (!gateway->bridged) {
+		enum ast_t38_state state_chan;
+		enum ast_t38_state state_peer;
+
+		ast_channel_unlock(chan);
+		state_chan = ast_channel_get_t38_state(chan);
+		state_peer = ast_channel_get_t38_state(peer);
+		ast_channel_lock(chan);
+
 		/* don't start a gateway if neither channel can handle T.38 */
-		if (ast_channel_get_t38_state(chan) == T38_STATE_UNAVAILABLE && ast_channel_get_t38_state(peer) == T38_STATE_UNAVAILABLE) {
+		if (state_chan == T38_STATE_UNAVAILABLE && state_peer == T38_STATE_UNAVAILABLE) {
 			ast_debug(1, "not starting gateway for %s and %s; neither channel supports T.38\n", ast_channel_name(chan), ast_channel_name(peer));
 			ast_framehook_detach(chan, gateway->framehook);
 			details->gateway_id = -1;
@@ -3324,6 +3404,7 @@ static struct ast_frame *fax_gateway_fra
 			ast_string_field_set(details, result, "FAILED");
 			ast_string_field_set(details, resultstr, "neither channel supports T.38");
 			ast_string_field_set(details, error, "T38_NEG_ERROR");
+			details->is_t38_negotiated = 0;
 			set_channel_variables(chan, details);
 			return f;
 		}
@@ -3352,6 +3433,11 @@ static struct ast_frame *fax_gateway_fra
 		ast_channel_unlock(peer);
 
 		gateway->bridged = 1;
+		if (!(gateway->peer_v21_session = fax_v21_session_new(peer))) {
+			ast_log(LOG_ERROR, "Can't create V21 session on chan %s for T.38 gateway session\n", ast_channel_name(peer));
+			ast_framehook_detach(chan, gateway->framehook);
+			return f;
+		}
 	}
 
 	if (gateway->bridged && !ast_tvzero(gateway->timeout_start)) {
@@ -3363,6 +3449,7 @@ static struct ast_frame *fax_gateway_fra
 			ast_string_field_set(details, result, "FAILED");
 			ast_string_field_build(details, resultstr, "no fax activity after %d ms", details->gateway_timeout);
 			ast_string_field_set(details, error, "TIMEOUT");
+			details->is_t38_negotiated = 0;
 			set_channel_variables(chan, details);
 			return f;
 		}
@@ -3478,6 +3565,10 @@ static int fax_gateway_attach(struct ast
 		.disable_inheritance = 1, /* Masquerade inheritance is handled through the datastore fixup */
 	};
 
+	if (global_fax_debug) {
+		details->option.debug = AST_FAX_OPTFLAG_TRUE;
+	}
+
 	ast_string_field_set(details, result, "SUCCESS");
 	ast_string_field_set(details, resultstr, "gateway operation started successfully");
 	ast_string_field_set(details, error, "NO_ERROR");
@@ -3489,6 +3580,7 @@ static int fax_gateway_attach(struct ast
 		ast_string_field_set(details, result, "FAILED");
 		ast_string_field_set(details, resultstr, "error initializing gateway session");
 		ast_string_field_set(details, error, "INIT_ERROR");
+		details->is_t38_negotiated = 0;
 		set_channel_variables(chan, details);
 		report_fax_status(chan, details, "No Available Resource");
 		return -1;
@@ -3504,6 +3596,7 @@ static int fax_gateway_attach(struct ast
 		ast_string_field_set(details, result, "FAILED");
 		ast_string_field_set(details, resultstr, "error attaching gateway to channel");
 		ast_string_field_set(details, error, "INIT_ERROR");
+		details->is_t38_negotiated = 0;
 		set_channel_variables(chan, details);
 		return -1;
 	}
@@ -3520,13 +3613,13 @@ static void destroy_faxdetect(void *data
 		ast_dsp_free(faxdetect->dsp);
 		faxdetect->dsp = NULL;
 	}
-	ao2_ref(faxdetect->details, -1);
+	ao2_cleanup(faxdetect->details);
 	ao2_cleanup(faxdetect->orig_format);
 }
 
 /*! \brief Create a new fax detect object.
  * \param chan the channel attaching to
- * \param timeout remove framehook in this time if set
+ * \param timeout in ms to remove framehook in this time if not zero
  * \param flags required options
  * \return NULL or a fax gateway object
  */
@@ -3633,8 +3726,9 @@ static struct ast_frame *fax_detect_fram
 		return f;
 	}
 
-	if ((!ast_tvzero(faxdetect->timeout_start) &&
-	    (ast_tvdiff_ms(ast_tvnow(), faxdetect->timeout_start) > faxdetect->timeout))) {
+	if (!ast_tvzero(faxdetect->timeout_start)
+		&& ast_tvdiff_ms(ast_tvnow(), faxdetect->timeout_start) > details->faxdetect_timeout) {
+		ast_debug(1, "FAXOPT(faxdetect) timeout on %s\n", ast_channel_name(chan));
 		ast_framehook_detach(chan, details->faxdetect_id);
 		details->faxdetect_id = -1;
 		return f;
@@ -3682,30 +3776,36 @@ static struct ast_frame *fax_detect_fram
 	}
 
 	if (result) {
-		const char *target_context = S_OR(ast_channel_macrocontext(chan), ast_channel_context(chan));
+		const char *target_context;
+
 		switch (result) {
 		case 'f':
 		case 't':
+			target_context = S_OR(ast_channel_macrocontext(chan), ast_channel_context(chan));
+
 			ast_channel_unlock(chan);
+			ast_frfree(f);
+			f = &ast_null_frame;
 			if (ast_exists_extension(chan, target_context, "fax", 1,
 			    S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, NULL))) {
-				ast_channel_lock(chan);
 				ast_verb(2, "Redirecting '%s' to fax extension due to %s detection\n",
 					ast_channel_name(chan), (result == 'f') ? "CNG" : "T38");
 				pbx_builtin_setvar_helper(chan, "FAXEXTEN", ast_channel_exten(chan));
 				if (ast_async_goto(chan, target_context, "fax", 1)) {
 					ast_log(LOG_NOTICE, "Failed to async goto '%s' into fax of '%s'\n", ast_channel_name(chan), target_context);
 				}
-				ast_frfree(f);
-				f = &ast_null_frame;
 			} else {
-				ast_channel_lock(chan);
 				ast_log(LOG_NOTICE, "FAX %s detected but no fax extension in context (%s)\n",
 					(result == 'f') ? "CNG" : "T38", target_context);
 			}
+			ast_channel_lock(chan);
+
+			ast_framehook_detach(chan, details->faxdetect_id);
+			details->faxdetect_id = -1;
+			break;
+		default:
+			break;
 		}
-		ast_framehook_detach(chan, details->faxdetect_id);
-		details->faxdetect_id = -1;
 	}
 
 	return f;
@@ -3713,7 +3813,7 @@ static struct ast_frame *fax_detect_fram
 
 /*! \brief Attach a faxdetect framehook object to a channel.
  * \param chan the channel to attach to
- * \param timeout remove framehook in this time if set
+ * \param timeout in ms to remove framehook in this time if not zero
  * \return the faxdetect structure or NULL on error
  * \param flags required options
  * \retval -1 error
@@ -4461,8 +4561,14 @@ static int acf_faxopt_write(struct ast_c
 				details->gateway_timeout = 0;
 				if (timeout) {
 					unsigned int gwtimeout;
-					if (sscanf(timeout, "%u", &gwtimeout) == 1) {
-						details->gateway_timeout = gwtimeout * 1000;
+
+					if (sscanf(timeout, "%30u", &gwtimeout) == 1) {
+						if (gwtimeout >= 0) {
+							details->gateway_timeout = gwtimeout * 1000;
+						} else {
+							ast_log(LOG_WARNING, "%s(%s) timeout cannot be negative.  Ignoring timeout\n",
+								cmd, data);
+						}
 					} else {
 						ast_log(LOG_WARNING, "Unsupported timeout '%s' passed to FAXOPT(%s).\n", timeout, data);
 					}
@@ -4479,7 +4585,9 @@ static int acf_faxopt_write(struct ast_c
 				ast_log(LOG_WARNING, "Attempt to attach a T.38 gateway on channel (%s) with gateway already running.\n", ast_channel_name(chan));
 			}
 		} else if (ast_false(val)) {
+			ast_channel_lock(chan);
 			ast_framehook_detach(chan, details->gateway_id);
+			ast_channel_unlock(chan);
 			details->gateway_id = -1;
 		} else {
 			ast_log(LOG_WARNING, "Unsupported value '%s' passed to FAXOPT(%s).\n", value, data);
@@ -4497,11 +4605,18 @@ static int acf_faxopt_write(struct ast_c
 
 		if (ast_true(val) || !strcasecmp(val, "t38") || !strcasecmp(val, "cng")) {
 			if (details->faxdetect_id < 0) {
-				if (timeout && (sscanf(timeout, "%u", &fdtimeout) == 1)) {
-					if (fdtimeout > 0) {
-						fdtimeout = fdtimeout * 1000;
+				if (timeout) {
+					if (sscanf(timeout, "%30u", &fdtimeout) == 1) {
+						if (fdtimeout >= 0) {
+							fdtimeout *= 1000;
+						} else {
+							ast_log(LOG_WARNING, "%s(%s) timeout cannot be negative.  Ignoring timeout\n",
+								cmd, data);
+							fdtimeout = 0;
+						}
 					} else {
-						ast_log(LOG_WARNING, "Timeout cannot be negative ignoring timeout\n");
+						ast_log(LOG_WARNING, "Unsupported timeout '%s' passed to FAXOPT(%s).\n",
+							timeout, data);
 					}
 				}
 
@@ -4524,7 +4639,9 @@ static int acf_faxopt_write(struct ast_c
 				ast_log(LOG_WARNING, "Attempt to attach a FAX detect on channel (%s) with FAX detect already running.\n", ast_channel_name(chan));
 			}
 		} else if (ast_false(val)) {
+			ast_channel_lock(chan);
 			ast_framehook_detach(chan, details->faxdetect_id);
+			ast_channel_unlock(chan);
 			details->faxdetect_id = -1;
 		} else {
 			ast_log(LOG_WARNING, "Unsupported value '%s' passed to FAXOPT(%s).\n", value, data);
diff -urpN asterisk-13.9.1/res/res_format_attr_g729.c asterisk-13.17.0/res/res_format_attr_g729.c
--- asterisk-13.9.1/res/res_format_attr_g729.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_format_attr_g729.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,76 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc.
+ *
+ * Jason Parker <jparker@sangoma.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*** MODULEINFO
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_REGISTER_FILE()
+
+#include "asterisk/module.h"
+#include "asterisk/format.h"
+
+/* Destroy is a required callback and must exist */
+static void g729_destroy(struct ast_format *format)
+{
+}
+
+/* Clone is a required callback and must exist */
+static int g729_clone(const struct ast_format *src, struct ast_format *dst)
+{
+	return 0;
+}
+
+static void g729_generate_sdp_fmtp(const struct ast_format *format, unsigned int payload, struct ast_str **str)
+{
+	/*
+	 * According to the rfc the joint annexb format parameter should be set to 'yes'
+	 * or 'no' based on the answerer (rfc7261 - 3.3). However, Asterisk being a B2BUA
+	 * makes things tricky. So for now Asterisk will set annexb=no.
+	 */
+	ast_str_append(str, 0, "a=fmtp:%u annexb=no\r\n", payload);
+}
+
+static struct ast_format_interface g729_interface = {
+	.format_destroy = g729_destroy,
+	.format_clone = g729_clone,
+	.format_generate_sdp_fmtp = g729_generate_sdp_fmtp,
+};
+
+static int load_module(void)
+{
+	if (ast_format_interface_register("g729", &g729_interface)) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	return 0;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "G.729 Format Attribute Module",
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+);
diff -urpN asterisk-13.9.1/res/res_format_attr_h263.c asterisk-13.17.0/res/res_format_attr_h263.c
--- asterisk-13.9.1/res/res_format_attr_h263.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_format_attr_h263.c	2017-07-12 13:12:08.000000000 +0200
@@ -158,6 +158,8 @@ static struct ast_format *h263_parse_sdp
 	while ((attrib = strsep(&attribs, ";"))) {
 		unsigned int val, val2 = 0, val3 = 0, val4 = 0;
 
+		attrib = ast_strip(attrib);
+
 		if (sscanf(attrib, "SQCIF=%30u", &val) == 1) {
 			attr->SQCIF = val;
 		} else if (sscanf(attrib, "QCIF=%30u", &val) == 1) {
diff -urpN asterisk-13.9.1/res/res_format_attr_h264.c asterisk-13.17.0/res/res_format_attr_h264.c
--- asterisk-13.9.1/res/res_format_attr_h264.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_format_attr_h264.c	2017-07-12 13:12:08.000000000 +0200
@@ -186,6 +186,8 @@ static struct ast_format *h264_parse_sdp
 		unsigned int val;
 		unsigned long int val2;
 
+		attrib = ast_strip(attrib);
+
 		if (sscanf(attrib, "profile-level-id=%lx", &val2) == 1) {
 			attr->PROFILE_IDC = ((val2 >> 16) & 0xFF);
 			attr->PROFILE_IOP = ((val2 >> 8) & 0xFF);
diff -urpN asterisk-13.9.1/res/res_format_attr_opus.c asterisk-13.17.0/res/res_format_attr_opus.c
--- asterisk-13.9.1/res/res_format_attr_opus.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_format_attr_opus.c	2017-07-12 13:12:08.000000000 +0200
@@ -33,9 +33,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #include "asterisk/module.h"
 #include "asterisk/format.h"
-#include "asterisk/logger.h"            /* for ast_log, LOG_WARNING */
-#include "asterisk/strings.h"           /* for ast_str_append */
-#include "asterisk/utils.h"             /* for MIN, ast_malloc, ast_free */
+#include "asterisk/logger.h"
+#include "asterisk/strings.h"
+#include "asterisk/utils.h"
+#include "asterisk/opus.h"
 
 /*!
  * \brief Opus attribute structure.
@@ -43,32 +44,42 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
  * \note http://tools.ietf.org/html/rfc7587#section-6
  */
 struct opus_attr {
-	unsigned int maxbitrate;
-	unsigned int maxplayrate;
-	unsigned int unused; /* was minptime, kept for binary compatibility */
-	unsigned int stereo;
-	unsigned int cbr;
-	unsigned int fec;
-	unsigned int dtx;
-	unsigned int spropmaxcapturerate;
-	unsigned int spropstereo;
+	int maxbitrate;
+	int maxplayrate;
+	int ptime;
+	int stereo;
+	int cbr;
+	int fec;
+	int dtx;
+	int spropmaxcapturerate;
+	int spropstereo;
+	int maxptime;
+	/* Note data is expected to be an ao2_object type */
+	void *data;
 };
 
 static struct opus_attr default_opus_attr = {
-	.maxplayrate         = 48000,
-	.spropmaxcapturerate = 48000,
-	.maxbitrate          = 510000,
-	.stereo              = 0,
-	.spropstereo         = 0,
-	.cbr                 = 0,
-	.fec                 = 1,
-	.dtx                 = 0,
+	.maxbitrate = CODEC_OPUS_DEFAULT_BITRATE,
+	.maxplayrate = CODEC_OPUS_DEFAULT_SAMPLE_RATE,
+	.ptime = CODEC_OPUS_DEFAULT_PTIME,
+	.stereo = CODEC_OPUS_DEFAULT_STEREO,
+	.cbr = CODEC_OPUS_DEFAULT_CBR,
+	.fec = CODEC_OPUS_DEFAULT_FEC,
+	.dtx = CODEC_OPUS_DEFAULT_DTX,
+	.spropmaxcapturerate = CODEC_OPUS_DEFAULT_SAMPLE_RATE,
+	.spropstereo = CODEC_OPUS_DEFAULT_STEREO,
+	.maxptime = CODEC_OPUS_DEFAULT_MAX_PTIME
 };
 
 static void opus_destroy(struct ast_format *format)
 {
 	struct opus_attr *attr = ast_format_get_attribute_data(format);
 
+	if (!attr) {
+		return;
+	}
+
+	ao2_cleanup(attr->data);
 	ast_free(attr);
 }
 
@@ -81,81 +92,73 @@ static int opus_clone(const struct ast_f
 		return -1;
 	}
 
-	if (original) {
-		*attr = *original;
-	} else {
-		*attr = default_opus_attr;
-	}
+	*attr = original ? *original : default_opus_attr;
+	ao2_bump(attr->data);
 
 	ast_format_set_attribute_data(dst, attr);
 
 	return 0;
 }
 
-static struct ast_format *opus_parse_sdp_fmtp(const struct ast_format *format, const char *attributes)
+static void sdp_fmtp_get(const char *attributes, const char *name, int *attr)
 {
-	struct ast_format *cloned;
-	struct opus_attr *attr;
-	const char *kvp;
-	unsigned int val;
-
-	cloned = ast_format_clone(format);
-	if (!cloned) {
-		return NULL;
-	}
-	attr = ast_format_get_attribute_data(cloned);
+	const char *kvp = attributes;
+	int val;
 
-	if ((kvp = strstr(attributes, "maxplaybackrate")) && sscanf(kvp, "maxplaybackrate=%30u", &val) == 1) {
-		attr->maxplayrate = val;
-	} else {
-		attr->maxplayrate = 48000;
+	if (ast_strlen_zero(attributes)) {
+		return;
 	}
 
-	if ((kvp = strstr(attributes, "sprop-maxcapturerate")) && sscanf(kvp, "sprop-maxcapturerate=%30u", &val) == 1) {
-		attr->spropmaxcapturerate = val;
-	} else {
-		attr->spropmaxcapturerate = 48000;
-	}
+	/* This logic goes through each attribute in the fmtp line looking for the
+	 * requested named attribute.
+	 */
+	while (*kvp) {
+		/* Skip any preceeding blanks as some implementations separate attributes using spaces too */
+		kvp = ast_skip_blanks(kvp);
+
+		/* If we are at at the requested attribute get its value and return */
+		if (!strncmp(kvp, name, strlen(name)) && kvp[strlen(name)] == '=') {
+			if (sscanf(kvp, "%*[^=]=%30d", &val) == 1) {
+				*attr = val;
+				break;
+			}
+		}
 
-	if ((kvp = strstr(attributes, "maxaveragebitrate")) && sscanf(kvp, "maxaveragebitrate=%30u", &val) == 1) {
-		attr->maxbitrate = val;
-	} else {
-		attr->maxbitrate = 510000;
-	}
+		/* Move on to the next attribute if possible */
+		kvp = strchr(kvp, ';');
+		if (!kvp) {
+			break;
+		}
 
-	if (!strncmp(attributes, "stereo=1", 8)) {
-		attr->stereo = 1;
-	} else if (strstr(attributes, " stereo=1")) {
-		attr->stereo = 1;
-	} else if (strstr(attributes, ";stereo=1")) {
-		attr->stereo = 1;
-	} else {
-		attr->stereo = 0;
+		kvp++;
 	}
+}
 
-	if (strstr(attributes, "sprop-stereo=1")) {
-		attr->spropstereo = 1;
-	} else {
-		attr->spropstereo = 0;
-	}
+static struct ast_format *opus_parse_sdp_fmtp(const struct ast_format *format, const char *attributes)
+{
+	struct ast_format *cloned;
+	struct opus_attr *attr;
 
-	if (strstr(attributes, "cbr=1")) {
-		attr->cbr = 1;
-	} else {
-		attr->cbr = 0;
+	cloned = ast_format_clone(format);
+	if (!cloned) {
+		return NULL;
 	}
 
-	if (strstr(attributes, "useinbandfec=1")) {
-		attr->fec = 1;
-	} else {
-		attr->fec = 0;
-	}
+	attr = ast_format_get_attribute_data(cloned);
 
-	if (strstr(attributes, "usedtx=1")) {
-		attr->dtx = 1;
-	} else {
-		attr->dtx = 0;
-	}
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE, &attr->maxplayrate);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_MAX_CODED_AUDIO_BANDWIDTH,
+		&attr->maxplayrate);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE,
+		&attr->spropmaxcapturerate);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_MAX_PTIME, &attr->maxptime);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_PTIME, &attr->ptime);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE, &attr->maxbitrate);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_STEREO, &attr->stereo);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_SPROP_STEREO, &attr->spropstereo);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_CBR, &attr->cbr);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_FEC, &attr->fec);
+	sdp_fmtp_get(attributes, CODEC_OPUS_ATTR_DTX, &attr->dtx);
 
 	return cloned;
 }
@@ -163,7 +166,8 @@ static struct ast_format *opus_parse_sdp
 static void opus_generate_sdp_fmtp(const struct ast_format *format, unsigned int payload, struct ast_str **str)
 {
 	struct opus_attr *attr = ast_format_get_attribute_data(format);
-	int added = 0;
+	int base_fmtp_size;
+	int original_size;
 
 	if (!attr) {
 		/*
@@ -174,79 +178,53 @@ static void opus_generate_sdp_fmtp(const
 		attr = &default_opus_attr;
 	}
 
-	if (48000 != attr->maxplayrate) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "maxplaybackrate=%u", attr->maxplayrate);
+	original_size = ast_str_strlen(*str);
+	base_fmtp_size = ast_str_append(str, 0, "a=fmtp:%u ", payload);
+
+	if (CODEC_OPUS_DEFAULT_SAMPLE_RATE != attr->maxplayrate) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE, attr->maxplayrate);
 	}
 
-	if (48000 != attr->spropmaxcapturerate) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "sprop-maxcapturerate=%u", attr->spropmaxcapturerate);
+	if (CODEC_OPUS_DEFAULT_SAMPLE_RATE != attr->spropmaxcapturerate) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE, attr->spropmaxcapturerate);
 	}
 
-	if (510000 != attr->maxbitrate) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "maxaveragebitrate=%u", attr->maxbitrate);
+	if (CODEC_OPUS_DEFAULT_BITRATE != attr->maxbitrate || attr->maxbitrate > 0) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE, attr->maxbitrate);
 	}
 
-	if (0 != attr->stereo) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "stereo=%u", attr->stereo);
+	if (CODEC_OPUS_DEFAULT_STEREO != attr->stereo) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_STEREO, attr->stereo);
 	}
 
-	if (0 != attr->spropstereo) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "sprop-stereo=%u", attr->spropstereo);
+	if (CODEC_OPUS_DEFAULT_STEREO != attr->spropstereo) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_SPROP_STEREO, attr->spropstereo);
 	}
 
-	if (0 != attr->cbr) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "cbr=%u", attr->cbr);
+	if (CODEC_OPUS_DEFAULT_CBR != attr->cbr) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_CBR, attr->cbr);
 	}
 
-	if (0 != attr->fec) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "useinbandfec=%u", attr->fec);
+	if (CODEC_OPUS_DEFAULT_FEC!= attr->fec) {
+		ast_str_append(str, 0, "%s=%d;",
+		       CODEC_OPUS_ATTR_FEC, attr->fec);
 	}
 
-	if (0 != attr->dtx) {
-		if (added) {
-			ast_str_append(str, 0, ";");
-		} else if (0 < ast_str_append(str, 0, "a=fmtp:%u ", payload)) {
-			added = 1;
-		}
-		ast_str_append(str, 0, "usedtx=%u", attr->dtx);
+	if (CODEC_OPUS_DEFAULT_DTX != attr->dtx) {
+		ast_str_append(str, 0, "%s=%d;",
+			CODEC_OPUS_ATTR_DTX, attr->dtx);
 	}
 
-	if (added) {
+	if (base_fmtp_size == ast_str_strlen(*str) - original_size) {
+		ast_str_truncate(*str, original_size);
+	} else {
+		ast_str_truncate(*str, -1);
 		ast_str_append(str, 0, "\r\n");
 	}
 }
@@ -285,49 +263,68 @@ static struct ast_format *opus_getjoint(
 	 * to receive stereo signals, it may be a waste of bandwidth. */
 	attr_res->stereo = attr1->stereo && attr2->stereo ? 1 : 0;
 
-	attr_res->maxbitrate = MIN(attr1->maxbitrate, attr2->maxbitrate);
+	if (attr1->maxbitrate < 0) {
+		attr_res->maxbitrate = attr2->maxbitrate;
+	} else if (attr2->maxbitrate < 0) {
+		attr_res->maxbitrate = attr1->maxbitrate;
+	} else {
+		attr_res->maxbitrate = MIN(attr1->maxbitrate, attr2->maxbitrate);
+	}
+
 	attr_res->spropmaxcapturerate = MIN(attr1->spropmaxcapturerate, attr2->spropmaxcapturerate);
 	attr_res->maxplayrate = MIN(attr1->maxplayrate, attr2->maxplayrate);
 
 	return jointformat;
 }
 
-static struct ast_format *opus_set(const struct ast_format *format, const char *name, const char *value)
+static struct ast_format *opus_set(const struct ast_format *format,
+	const char *name, const char *value)
 {
 	struct ast_format *cloned;
 	struct opus_attr *attr;
-	unsigned int val;
+	int val;
 
-	if (sscanf(value, "%30u", &val) != 1) {
-		ast_log(LOG_WARNING, "Unknown value '%s' for attribute type '%s'\n",
-			value, name);
+	if (!(cloned = ast_format_clone(format))) {
 		return NULL;
 	}
 
-	cloned = ast_format_clone(format);
-	if (!cloned) {
+	attr = ast_format_get_attribute_data(cloned);
+
+	if (!strcmp(name, CODEC_OPUS_ATTR_DATA)) {
+		ao2_cleanup(attr->data);
+		attr->data = ao2_bump((void*)value);
+		return cloned;
+	}
+
+	if (sscanf(value, "%30d", &val) != 1) {
+		ast_log(LOG_WARNING, "Unknown value '%s' for attribute type '%s'\n",
+			value, name);
+		ao2_ref(cloned, -1);
 		return NULL;
 	}
-	attr = ast_format_get_attribute_data(cloned);
 
-	if (!strcasecmp(name, "max_bitrate")) {
-		attr->maxbitrate = val;
-	} else if (!strcasecmp(name, "max_playrate")) {
+	if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE)) {
+		attr->maxplayrate = val;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_CODED_AUDIO_BANDWIDTH)) {
 		attr->maxplayrate = val;
-	} else if (!strcasecmp(name, "minptime")) {
-		attr->unused = val;
-	} else if (!strcasecmp(name, "stereo")) {
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE)) {
+		attr->spropmaxcapturerate = val;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PTIME)) {
+		attr->maxptime = val;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_PTIME)) {
+		attr->ptime = val;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE)) {
+		attr->maxbitrate = val;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_STEREO)) {
 		attr->stereo = val;
-	} else if (!strcasecmp(name, "cbr")) {
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_STEREO)) {
+		attr->spropstereo = val;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_CBR)) {
 		attr->cbr = val;
-	} else if (!strcasecmp(name, "fec")) {
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_FEC)) {
 		attr->fec = val;
-	} else if (!strcasecmp(name, "dtx")) {
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_DTX)) {
 		attr->dtx = val;
-	} else if (!strcasecmp(name, "sprop_capture_rate")) {
-		attr->spropmaxcapturerate = val;
-	} else if (!strcasecmp(name, "sprop_stereo")) {
-		attr->spropstereo = val;
 	} else {
 		ast_log(LOG_WARNING, "unknown attribute type %s\n", name);
 	}
@@ -335,6 +332,44 @@ static struct ast_format *opus_set(const
 	return cloned;
 }
 
+static const void *opus_get(const struct ast_format *format, const char *name)
+{
+	struct opus_attr *attr = ast_format_get_attribute_data(format);
+	int *val = NULL;
+
+	if (!attr) {
+		return NULL;
+	}
+
+	if (!strcasecmp(name, CODEC_OPUS_ATTR_DATA)) {
+		return ao2_bump(attr->data);
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PLAYBACK_RATE)) {
+		val = &attr->maxplayrate;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_MAX_CAPTURE_RATE)) {
+		val = &attr->spropmaxcapturerate;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_PTIME)) {
+		val = &attr->maxptime;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_PTIME)) {
+		val = &attr->ptime;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_MAX_AVERAGE_BITRATE)) {
+		val = &attr->maxbitrate;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_STEREO)) {
+		val = &attr->stereo;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_SPROP_STEREO)) {
+		val = &attr->spropstereo;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_CBR)) {
+		val = &attr->cbr;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_FEC)) {
+		val = &attr->fec;
+	} else if (!strcasecmp(name, CODEC_OPUS_ATTR_DTX)) {
+		val = &attr->dtx;
+	} else {
+		ast_log(LOG_WARNING, "unknown attribute type %s\n", name);
+	}
+
+	return val;
+}
+
 static struct ast_format_interface opus_interface = {
 	.format_destroy = opus_destroy,
 	.format_clone = opus_clone,
@@ -342,11 +377,12 @@ static struct ast_format_interface opus_
 	.format_attribute_set = opus_set,
 	.format_parse_sdp_fmtp = opus_parse_sdp_fmtp,
 	.format_generate_sdp_fmtp = opus_generate_sdp_fmtp,
+	.format_attribute_get = opus_get
 };
 
 static int load_module(void)
 {
-	if (ast_format_interface_register("opus", &opus_interface)) {
+	if (__ast_format_interface_register("opus", &opus_interface, ast_module_info->self)) {
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -358,9 +394,9 @@ static int unload_module(void)
 	return 0;
 }
 
-AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Opus Format Attribute Module",
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, "Opus Format Attribute Module",
 	.support_level = AST_MODULE_SUPPORT_CORE,
 	.load = load_module,
 	.unload = unload_module,
-	.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+	.load_pri = AST_MODPRI_REALTIME_DRIVER /* Needs to load before codec_opus */
 );
diff -urpN asterisk-13.9.1/res/res_format_attr_silk.c asterisk-13.17.0/res/res_format_attr_silk.c
--- asterisk-13.9.1/res/res_format_attr_silk.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_format_attr_silk.c	2017-07-12 13:12:08.000000000 +0200
@@ -40,7 +40,6 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
  * \note The only attribute that affects compatibility here is the sample rate.
  */
 struct silk_attr {
-	unsigned int samplerate;
 	unsigned int maxbitrate;
 	unsigned int dtx;
 	unsigned int fec;
@@ -54,10 +53,15 @@ static void silk_destroy(struct ast_form
 	ast_free(attr);
 }
 
+static void attr_init(struct silk_attr *attr)
+{
+	memset(attr, 0, sizeof(*attr));
+}
+
 static int silk_clone(const struct ast_format *src, struct ast_format *dst)
 {
 	struct silk_attr *original = ast_format_get_attribute_data(src);
-	struct silk_attr *attr = ast_calloc(1, sizeof(*attr));
+	struct silk_attr *attr = ast_malloc(sizeof(*attr));
 
 	if (!attr) {
 		return -1;
@@ -65,6 +69,8 @@ static int silk_clone(const struct ast_f
 
 	if (original) {
 		*attr = *original;
+	} else {
+		attr_init(attr);
 	}
 
 	ast_format_set_attribute_data(dst, attr);
@@ -109,17 +115,17 @@ static void silk_generate_sdp_fmtp(const
 		ast_str_append(str, 0, "a=fmtp:%u maxaveragebitrate=%u\r\n", payload, attr->maxbitrate);
 	}
 
-	ast_str_append(str, 0, "a=fmtp:%u usedtx=%u\r\n", payload, attr->dtx);
-	ast_str_append(str, 0, "a=fmtp:%u useinbandfec=%u\r\n", payload, attr->fec);
+	if (attr->dtx) {
+		ast_str_append(str, 0, "a=fmtp:%u usedtx=%u\r\n", payload, attr->dtx);
+	}
+	if (attr->fec) {
+		ast_str_append(str, 0, "a=fmtp:%u useinbandfec=%u\r\n", payload, attr->fec);
+	}
 }
 
 static enum ast_format_cmp_res silk_cmp(const struct ast_format *format1, const struct ast_format *format2)
 {
-	struct silk_attr *attr1 = ast_format_get_attribute_data(format1);
-	struct silk_attr *attr2 = ast_format_get_attribute_data(format2);
-
-	if (((!attr1 || !attr1->samplerate) && (!attr2 || !attr2->samplerate)) ||
-		(attr1->samplerate == attr2->samplerate)) {
+	if (ast_format_get_sample_rate(format1) == ast_format_get_sample_rate(format2)) {
 		return AST_FORMAT_CMP_EQUAL;
 	}
 
@@ -130,13 +136,10 @@ static struct ast_format *silk_getjoint(
 {
 	struct silk_attr *attr1 = ast_format_get_attribute_data(format1);
 	struct silk_attr *attr2 = ast_format_get_attribute_data(format2);
-	unsigned int samplerate;
 	struct ast_format *jointformat;
 	struct silk_attr *attr_res;
 
-	samplerate = attr1->samplerate & attr2->samplerate;
-	/* sample rate is the only attribute that has any bearing on if joint capabilities exist or not */
-	if (samplerate) {
+	if (ast_format_get_sample_rate(format1) != ast_format_get_sample_rate(format2)) {
 		return NULL;
 	}
 
@@ -145,22 +148,25 @@ static struct ast_format *silk_getjoint(
 		return NULL;
 	}
 	attr_res = ast_format_get_attribute_data(jointformat);
-	attr_res->samplerate = samplerate;
 
-	/* Take the lowest max bitrate */
-	attr_res->maxbitrate = MIN(attr1->maxbitrate, attr2->maxbitrate);
+	if (!attr1 || !attr2) {
+		attr_init(attr_res);
+	} else {
+		/* Take the lowest max bitrate */
+		attr_res->maxbitrate = MIN(attr1->maxbitrate, attr2->maxbitrate);
 
-	/* Only do dtx if both sides want it. DTX is a trade off between
-	 * computational complexity and bandwidth. */
-	attr_res->dtx = attr1->dtx && attr2->dtx ? 1 : 0;
-
-	/* Only do FEC if both sides want it.  If a peer specifically requests not
-	 * to receive with FEC, it may be a waste of bandwidth. */
-	attr_res->fec = attr1->fec && attr2->fec ? 1 : 0;
-
-	/* Use the maximum packetloss percentage between the two attributes. This affects how
-	 * much redundancy is used in the FEC. */
-	attr_res->packetloss_percentage = MAX(attr1->packetloss_percentage, attr2->packetloss_percentage);
+		/* Only do dtx if both sides want it. DTX is a trade off between
+		 * computational complexity and bandwidth. */
+		attr_res->dtx = attr1->dtx && attr2->dtx ? 1 : 0;
+
+		/* Only do FEC if both sides want it.  If a peer specifically requests not
+		 * to receive with FEC, it may be a waste of bandwidth. */
+		attr_res->fec = attr1->fec && attr2->fec ? 1 : 0;
+
+		/* Use the maximum packetloss percentage between the two attributes. This affects how
+		 * much redundancy is used in the FEC. */
+		attr_res->packetloss_percentage = MAX(attr1->packetloss_percentage, attr2->packetloss_percentage);
+	}
 
 	return jointformat;
 }
@@ -183,9 +189,7 @@ static struct ast_format *silk_set(const
 	}
 	attr = ast_format_get_attribute_data(cloned);
 
-	if (!strcasecmp(name, "sample_rate")) {
-		attr->samplerate = val;
-	} else if (!strcasecmp(name, "max_bitrate")) {
+	if (!strcasecmp(name, "max_bitrate")) {
 		attr->maxbitrate = val;
 	} else if (!strcasecmp(name, "dtx")) {
 		attr->dtx = val;
@@ -205,9 +209,7 @@ static const void *silk_get(const struct
 	struct silk_attr *attr = ast_format_get_attribute_data(format);
 	unsigned int *val;
 
-	if (!strcasecmp(name, "sample_rate")) {
-		val = &attr->samplerate;
-	} else if (!strcasecmp(name, "max_bitrate")) {
+	if (!strcasecmp(name, "max_bitrate")) {
 		val = &attr->maxbitrate;
 	} else if (!strcasecmp(name, "dtx")) {
 		val = &attr->dtx;
diff -urpN asterisk-13.9.1/res/res_format_attr_siren14.c asterisk-13.17.0/res/res_format_attr_siren14.c
--- asterisk-13.9.1/res/res_format_attr_siren14.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_format_attr_siren14.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc.
+ *
+ * Joshua Colp <jcolp@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*!
+ * \file
+ * \brief Siren14 format attribute interface
+ *
+ * \author Joshua Colp <jcolp@digium.com>
+ */
+
+/*** MODULEINFO
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include "asterisk/module.h"
+#include "asterisk/format.h"
+
+/* Destroy is a required callback and must exist */
+static void siren14_destroy(struct ast_format *format)
+{
+}
+
+/* Clone is a required callback and must exist */
+static int siren14_clone(const struct ast_format *src, struct ast_format *dst)
+{
+	return 0;
+}
+
+static struct ast_format *siren14_parse_sdp_fmtp(const struct ast_format *format, const char *attributes)
+{
+	unsigned int val;
+
+	if (sscanf(attributes, "bitrate=%30u", &val) == 1) {
+		if (val != 48000) {
+			ast_log(LOG_WARNING, "Got siren14 offer at %u bps, but only 48000 bps supported; ignoring.\n", val);
+			return NULL;
+		}
+	}
+
+	/* We aren't modifying the format and once passed back it won't be touched, so use what we were given */
+	return ao2_bump((struct ast_format *)format);
+}
+
+static void siren14_generate_sdp_fmtp(const struct ast_format *format, unsigned int payload, struct ast_str **str)
+{
+	ast_str_append(str, 0, "a=fmtp:%u bitrate=48000\r\n", payload);
+}
+
+static struct ast_format_interface siren14_interface = {
+	.format_destroy = siren14_destroy,
+	.format_clone = siren14_clone,
+	.format_parse_sdp_fmtp = siren14_parse_sdp_fmtp,
+	.format_generate_sdp_fmtp = siren14_generate_sdp_fmtp,
+};
+
+static int load_module(void)
+{
+	if (ast_format_interface_register("siren14", &siren14_interface)) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	return 0;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Siren14 Format Attribute Module",
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+);
diff -urpN asterisk-13.9.1/res/res_format_attr_siren7.c asterisk-13.17.0/res/res_format_attr_siren7.c
--- asterisk-13.9.1/res/res_format_attr_siren7.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_format_attr_siren7.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc.
+ *
+ * Joshua Colp <jcolp@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*!
+ * \file
+ * \brief Siren7 format attribute interface
+ *
+ * \author Joshua Colp <jcolp@digium.com>
+ */
+
+/*** MODULEINFO
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include "asterisk/module.h"
+#include "asterisk/format.h"
+
+/* Destroy is a required callback and must exist */
+static void siren7_destroy(struct ast_format *format)
+{
+}
+
+/* Clone is a required callback and must exist */
+static int siren7_clone(const struct ast_format *src, struct ast_format *dst)
+{
+	return 0;
+}
+
+static struct ast_format *siren7_parse_sdp_fmtp(const struct ast_format *format, const char *attributes)
+{
+	unsigned int val;
+
+	if (sscanf(attributes, "bitrate=%30u", &val) == 1) {
+		if (val != 32000) {
+			ast_log(LOG_WARNING, "Got Siren7 offer at %u bps, but only 32000 bps supported; ignoring.\n", val);
+			return NULL;
+		}
+	}
+
+	/* We aren't modifying the format and once passed back it won't be touched, so use what we were given */
+	return ao2_bump((struct ast_format *)format);
+}
+
+static void siren7_generate_sdp_fmtp(const struct ast_format *format, unsigned int payload, struct ast_str **str)
+{
+	ast_str_append(str, 0, "a=fmtp:%u bitrate=32000\r\n", payload);
+}
+
+static struct ast_format_interface siren7_interface = {
+	.format_destroy = siren7_destroy,
+	.format_clone = siren7_clone,
+	.format_parse_sdp_fmtp = siren7_parse_sdp_fmtp,
+	.format_generate_sdp_fmtp = siren7_generate_sdp_fmtp,
+};
+
+static int load_module(void)
+{
+	if (ast_format_interface_register("siren7", &siren7_interface)) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	return 0;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Siren7 Format Attribute Module",
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+);
diff -urpN asterisk-13.9.1/res/res_hep.c asterisk-13.17.0/res/res_hep.c
--- asterisk-13.9.1/res/res_hep.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_hep.c	2017-07-12 13:12:08.000000000 +0200
@@ -60,7 +60,16 @@
 						</enumlist>
 					</description>
 				</configOption>
-				<configOption name="capture_address" default="192.168.1.1:9061">
+				<configOption name="uuid_type" default="call-id">
+					<synopsis>The preferred type of UUID to pass to Homer.</synopsis>
+					<description>
+						<enumlist>
+							<enum name="call-id"><para>Use the PJSIP Call-Id</para></enum>
+							<enum name="channel"><para>Use the Asterisk channel name</para></enum>
+						</enumlist>
+					</description>
+				</configOption>
+				<configOption name="capture_address">
 					<synopsis>The address and port of the Homer server to send packets to.</synopsis>
 				</configOption>
 				<configOption name="capture_password">
@@ -89,8 +98,6 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include <netinet/udp.h>
 #include <netinet/ip6.h>
 
-#define DEFAULT_HEP_SERVER ""
-
 /*! Generic vendor ID. Used for HEPv3 standard packets */
 #define GENERIC_VENDOR_ID 0x0000
 
@@ -231,6 +238,7 @@ struct hep_generic {
 struct hepv3_global_config {
 	unsigned int enabled;                    /*!< Whether or not sending is enabled */
 	unsigned int capture_id;                 /*!< Capture ID for this agent */
+	enum hep_uuid_type uuid_type;            /*!< The preferred type of the UUID */
 	AST_DECLARE_STRING_FIELDS(
 		AST_STRING_FIELD(capture_address);   /*!< Address to send to */
 		AST_STRING_FIELD(capture_password);  /*!< Password for Homer server */
@@ -272,11 +280,13 @@ static AO2_GLOBAL_OBJ_STATIC(global_data
 static struct ast_taskprocessor *hep_queue_tp;
 
 static void *module_config_alloc(void);
+static int hepv3_config_pre_apply(void);
 static void hepv3_config_post_apply(void);
 
 /*! \brief Register information about the configs being processed by this module */
 CONFIG_INFO_STANDARD(cfg_info, global_config, module_config_alloc,
 	.files = ACO_FILES(&hepv3_conf),
+	.pre_apply_config = hepv3_config_pre_apply,
 	.post_apply_config = hepv3_config_post_apply,
 );
 
@@ -329,6 +339,25 @@ static void *module_config_alloc(void)
 	return config;
 }
 
+/*! \brief Handler for the uuid_type attribute */
+static int uuid_type_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
+{
+	struct hepv3_global_config *global_config = obj;
+
+	if (strcasecmp(var->name, "uuid_type")) {
+		return -1;
+	}
+
+	if (!strcasecmp(var->value, "channel")) {
+		global_config->uuid_type = HEP_UUID_TYPE_CHANNEL;
+	} else if (!strcasecmp(var->value, "call-id")) {
+		global_config->uuid_type = HEP_UUID_TYPE_CALL_ID;
+	} else {
+		return -1;
+	}
+	return 0;
+}
+
 /*! \brief HEPv3 run-time data destructor */
 static void hepv3_data_dtor(void *obj)
 {
@@ -350,6 +379,8 @@ static struct hepv3_runtime_data *hepv3_
 		return NULL;
 	}
 
+	data->sockfd = -1;
+
 	if (!ast_sockaddr_parse(&data->remote_addr, config->capture_address, PARSE_PORT_REQUIRE)) {
 		ast_log(AST_LOG_WARNING, "Failed to create address from %s\n", config->capture_address);
 		ao2_ref(data, -1);
@@ -376,6 +407,25 @@ static void capture_info_dtor(void *obj)
 	ast_free(info->payload);
 }
 
+enum hep_uuid_type hepv3_get_uuid_type(void)
+{
+	RAII_VAR(struct module_config *, config, ao2_global_obj_ref(global_config), ao2_cleanup);
+
+	if (!config) {
+		/* Well, that's unfortunate. Return something. */
+		return HEP_UUID_TYPE_CALL_ID;
+	}
+
+	return config->general->uuid_type;
+}
+
+int hepv3_is_loaded(void)
+{
+	RAII_VAR(struct module_config *, config, ao2_global_obj_ref(global_config), ao2_cleanup);
+
+	return (config != NULL) ? 1 : 0;
+}
+
 struct hepv3_capture_info *hepv3_create_capture_info(const void *payload, size_t len)
 {
 	struct hepv3_capture_info *info;
@@ -393,6 +443,9 @@ struct hepv3_capture_info *hepv3_create_
 	memcpy(info->payload, payload, len);
 	info->len = len;
 
+	/* Set a reasonable default */
+	info->protocol_id = IPPROTO_UDP;
+
 	return info;
 }
 
@@ -424,7 +477,7 @@ static int hep_queue_cb(void *data)
 	/* Build HEPv3 header, capture info, and calculate the total packet size */
 	memcpy(hg_pkt.header.id, "\x48\x45\x50\x33", 4);
 
-	INITIALIZE_GENERIC_HEP_CHUNK_DATA(&hg_pkt.ip_proto, CHUNK_TYPE_IP_PROTOCOL_ID, 0x11);
+	INITIALIZE_GENERIC_HEP_CHUNK_DATA(&hg_pkt.ip_proto, CHUNK_TYPE_IP_PROTOCOL_ID, capture_info->protocol_id);
 	INITIALIZE_GENERIC_HEP_CHUNK_DATA(&hg_pkt.src_port, CHUNK_TYPE_SRC_PORT, htons(ast_sockaddr_port(&capture_info->src_addr)));
 	INITIALIZE_GENERIC_HEP_CHUNK_DATA(&hg_pkt.dst_port, CHUNK_TYPE_DST_PORT, htons(ast_sockaddr_port(&capture_info->dst_addr)));
 	INITIALIZE_GENERIC_HEP_CHUNK_DATA(&hg_pkt.time_sec, CHUNK_TYPE_TIMESTAMP_SEC, htonl(capture_info->capture_time.tv_sec));
@@ -545,11 +598,33 @@ int hepv3_send_packet(struct hepv3_captu
 }
 
 /*!
+ * \brief Pre-apply callback for the config framework.
+ *
+ * This validates that required fields exist and are populated.
+ */
+static int hepv3_config_pre_apply(void)
+{
+	struct module_config *config = aco_pending_config(&cfg_info);
+
+	if (!config->general->enabled) {
+		/* If we're not enabled, we don't care about anything else */
+		return 0;
+	}
+
+	if (ast_strlen_zero(config->general->capture_address)) {
+		ast_log(AST_LOG_ERROR, "Missing required configuration option 'capture_address'\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
  * \brief Post-apply callback for the config framework.
  *
  * This will create the run-time information from the supplied
  * configuration.
-*/
+ */
 static void hepv3_config_post_apply(void)
 {
 	RAII_VAR(struct module_config *, mod_cfg, ao2_global_obj_ref(global_config), ao2_cleanup);
@@ -604,9 +679,10 @@ static int load_module(void)
 	}
 
 	aco_option_register(&cfg_info, "enabled", ACO_EXACT, global_options, "yes", OPT_BOOL_T, 1, FLDSET(struct hepv3_global_config, enabled));
-	aco_option_register(&cfg_info, "capture_address", ACO_EXACT, global_options, DEFAULT_HEP_SERVER, OPT_STRINGFIELD_T, 0, STRFLDSET(struct hepv3_global_config, capture_address));
+	aco_option_register(&cfg_info, "capture_address", ACO_EXACT, global_options, "", OPT_STRINGFIELD_T, 1, STRFLDSET(struct hepv3_global_config, capture_address));
 	aco_option_register(&cfg_info, "capture_password", ACO_EXACT, global_options, "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct hepv3_global_config, capture_password));
 	aco_option_register(&cfg_info, "capture_id", ACO_EXACT, global_options, "0", OPT_UINT_T, 0, STRFLDSET(struct hepv3_global_config, capture_id));
+	aco_option_register_custom(&cfg_info, "uuid_type", ACO_EXACT, global_options, "call-id", uuid_type_handler, 0);
 
 	if (aco_process_config(&cfg_info, 0) == ACO_PROCESS_ERROR) {
 		goto error;
diff -urpN asterisk-13.9.1/res/res_hep.exports.in asterisk-13.17.0/res/res_hep.exports.in
--- asterisk-13.9.1/res/res_hep.exports.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_hep.exports.in	2017-07-12 13:12:08.000000000 +0200
@@ -2,6 +2,8 @@
 	global:
 		LINKER_SYMBOL_PREFIX*hepv3_send_packet;
 		LINKER_SYMBOL_PREFIX*hepv3_create_capture_info;
+		LINKER_SYMBOL_PREFIX*hepv3_get_uuid_type;
+		LINKER_SYMBOL_PREFIX*hepv3_is_loaded;
 	local:
 		*;
 };
diff -urpN asterisk-13.9.1/res/res_hep_pjsip.c asterisk-13.17.0/res/res_hep_pjsip.c
--- asterisk-13.9.1/res/res_hep_pjsip.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_hep_pjsip.c	2017-07-12 13:12:08.000000000 +0200
@@ -51,13 +51,18 @@ static char *assign_uuid(const pj_str_t
 	RAII_VAR(struct ast_sip_session *, session, NULL, ao2_cleanup);
 	pjsip_dialog *dlg;
 	char *uuid = NULL;
+	enum hep_uuid_type uuid_type = hepv3_get_uuid_type();
 
-	if ((dlg = pjsip_ua_find_dialog(call_id, local_tag, remote_tag, PJ_FALSE))
+	if ((uuid_type == HEP_UUID_TYPE_CHANNEL)
+		&& (dlg = pjsip_ua_find_dialog(call_id, local_tag, remote_tag, PJ_FALSE))
 	    && (session = ast_sip_dialog_get_session(dlg))
 	    && (session->channel)) {
 
 		uuid = ast_strdup(ast_channel_name(session->channel));
-	} else {
+	}
+
+	/* If we couldn't get the channel or we never wanted it, default to the call-id */
+	if (!uuid) {
 
 		uuid = ast_malloc(pj_strlen(call_id) + 1);
 		if (uuid) {
@@ -68,6 +73,15 @@ static char *assign_uuid(const pj_str_t
 	return uuid;
 }
 
+static int transport_to_protocol_id(pjsip_transport *tp)
+{
+	/* XXX If we ever add SCTP support, we'll need to revisit */
+	if (tp->flag & PJSIP_TRANSPORT_RELIABLE) {
+		return IPPROTO_TCP;
+	}
+	return IPPROTO_UDP;
+}
+
 static pj_status_t logging_on_tx_msg(pjsip_tx_data *tdata)
 {
 	char local_buf[256];
@@ -77,13 +91,35 @@ static pj_status_t logging_on_tx_msg(pjs
 	pjsip_cid_hdr *cid_hdr;
 	pjsip_from_hdr *from_hdr;
 	pjsip_to_hdr *to_hdr;
+	pjsip_tpmgr_fla2_param prm;
 
 	capture_info = hepv3_create_capture_info(tdata->buf.start, (size_t)(tdata->buf.cur - tdata->buf.start));
 	if (!capture_info) {
 		return PJ_SUCCESS;
 	}
 
-	pj_sockaddr_print(&tdata->tp_info.transport->local_addr, local_buf, sizeof(local_buf), 3);
+	/* Attempt to determine what IP address will we send this packet out of */
+	pjsip_tpmgr_fla2_param_default(&prm);
+	prm.tp_type = tdata->tp_info.transport->key.type;
+	pj_strset2(&prm.dst_host, tdata->tp_info.dst_name);
+	prm.local_if = PJ_TRUE;
+
+	/* If we can't get the local address use what we have already */
+	if (pjsip_tpmgr_find_local_addr2(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()), tdata->pool, &prm) != PJ_SUCCESS) {
+		pj_sockaddr_print(&tdata->tp_info.transport->local_addr, local_buf, sizeof(local_buf), 3);
+	} else {
+		if (prm.tp_type & PJSIP_TRANSPORT_IPV6) {
+			snprintf(local_buf, sizeof(local_buf), "[%.*s]:%hu",
+				(int)pj_strlen(&prm.ret_addr),
+				pj_strbuf(&prm.ret_addr),
+				prm.ret_port);
+		} else {
+			snprintf(local_buf, sizeof(local_buf), "%.*s:%hu",
+				(int)pj_strlen(&prm.ret_addr),
+				pj_strbuf(&prm.ret_addr),
+				prm.ret_port);
+		}
+	}
 	pj_sockaddr_print(&tdata->tp_info.dst_addr, remote_buf, sizeof(remote_buf), 3);
 
 	cid_hdr = PJSIP_MSG_CID_HDR(tdata->msg);
@@ -99,6 +135,7 @@ static pj_status_t logging_on_tx_msg(pjs
 	ast_sockaddr_parse(&capture_info->src_addr, local_buf, PARSE_PORT_REQUIRE);
 	ast_sockaddr_parse(&capture_info->dst_addr, remote_buf, PARSE_PORT_REQUIRE);
 
+	capture_info->protocol_id = transport_to_protocol_id(tdata->tp_info.transport);
 	capture_info->capture_time = ast_tvnow();
 	capture_info->capture_type = HEPV3_CAPTURE_TYPE_SIP;
 	capture_info->uuid = uuid;
@@ -115,17 +152,39 @@ static pj_bool_t logging_on_rx_msg(pjsip
 	char remote_buf[256];
 	char *uuid;
 	struct hepv3_capture_info *capture_info;
+	pjsip_tpmgr_fla2_param prm;
 
 	capture_info = hepv3_create_capture_info(&rdata->pkt_info.packet, rdata->pkt_info.len);
 	if (!capture_info) {
 		return PJ_SUCCESS;
 	}
 
-	if (rdata->tp_info.transport->addr_len) {
-		pj_sockaddr_print(&rdata->tp_info.transport->local_addr, local_buf, sizeof(local_buf), 3);
+	if (!rdata->pkt_info.src_addr_len) {
+		return PJ_SUCCESS;
 	}
-	if (rdata->pkt_info.src_addr_len) {
-		pj_sockaddr_print(&rdata->pkt_info.src_addr, remote_buf, sizeof(remote_buf), 3);
+	pj_sockaddr_print(&rdata->pkt_info.src_addr, remote_buf, sizeof(remote_buf), 3);
+
+	/* Attempt to determine what IP address we probably received this packet on */
+	pjsip_tpmgr_fla2_param_default(&prm);
+	prm.tp_type = rdata->tp_info.transport->key.type;
+	pj_strset2(&prm.dst_host, rdata->pkt_info.src_name);
+	prm.local_if = PJ_TRUE;
+
+	/* If we can't get the local address use what we have already */
+	if (pjsip_tpmgr_find_local_addr2(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()), rdata->tp_info.pool, &prm) != PJ_SUCCESS) {
+		pj_sockaddr_print(&rdata->tp_info.transport->local_addr, local_buf, sizeof(local_buf), 3);
+	} else {
+		if (prm.tp_type & PJSIP_TRANSPORT_IPV6) {
+			snprintf(local_buf, sizeof(local_buf), "[%.*s]:%hu",
+				(int)pj_strlen(&prm.ret_addr),
+				pj_strbuf(&prm.ret_addr),
+				prm.ret_port);
+		} else {
+			snprintf(local_buf, sizeof(local_buf), "%.*s:%hu",
+				(int)pj_strlen(&prm.ret_addr),
+				pj_strbuf(&prm.ret_addr),
+				prm.ret_port);
+		}
 	}
 
 	uuid = assign_uuid(&rdata->msg_info.cid->id, &rdata->msg_info.to->tag, &rdata->msg_info.from->tag);
@@ -136,6 +195,8 @@ static pj_bool_t logging_on_rx_msg(pjsip
 
 	ast_sockaddr_parse(&capture_info->src_addr, remote_buf, PARSE_PORT_REQUIRE);
 	ast_sockaddr_parse(&capture_info->dst_addr, local_buf, PARSE_PORT_REQUIRE);
+
+	capture_info->protocol_id = transport_to_protocol_id(rdata->tp_info.transport);
 	capture_info->capture_time.tv_sec = rdata->pkt_info.timestamp.sec;
 	capture_info->capture_time.tv_usec = rdata->pkt_info.timestamp.msec * 1000;
 	capture_info->capture_type = HEPV3_CAPTURE_TYPE_SIP;
@@ -161,6 +222,11 @@ static int load_module(void)
 {
 	CHECK_PJSIP_MODULE_LOADED();
 
+	if (!ast_module_check("res_hep.so") || !hepv3_is_loaded()) {
+		ast_log(AST_LOG_WARNING, "res_hep is not loaded or running; declining module load\n");
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
 	ast_sip_register_service(&logging_module);
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/res/res_hep_rtcp.c asterisk-13.17.0/res/res_hep_rtcp.c
--- asterisk-13.9.1/res/res_hep_rtcp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_hep_rtcp.c	2017-07-12 13:12:08.000000000 +0200
@@ -36,6 +36,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/res_hep.h"
 #include "asterisk/module.h"
 #include "asterisk/netsock2.h"
+#include "asterisk/channel.h"
+#include "asterisk/pbx.h"
 #include "asterisk/stasis.h"
 #include "asterisk/rtp_engine.h"
 #include "asterisk/json.h"
@@ -43,6 +45,45 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 static struct stasis_subscription *stasis_rtp_subscription;
 
+static char *assign_uuid(struct ast_json *json_channel)
+{
+	const char *channel_name = ast_json_string_get(ast_json_object_get(json_channel, "name"));
+	enum hep_uuid_type uuid_type = hepv3_get_uuid_type();
+	char *uuid = NULL;
+
+	if (!channel_name) {
+		return NULL;
+	}
+
+	if (uuid_type == HEP_UUID_TYPE_CALL_ID) {
+		struct ast_channel *chan = NULL;
+		char buf[128];
+
+		if (ast_begins_with(channel_name, "PJSIP")) {
+			chan = ast_channel_get_by_name(channel_name);
+
+			if (chan && !ast_func_read(chan, "CHANNEL(pjsip,call-id)", buf, sizeof(buf))) {
+				uuid = ast_strdup(buf);
+			}
+		} else if (ast_begins_with(channel_name, "SIP")) {
+			chan = ast_channel_get_by_name(channel_name);
+
+			if (chan && !ast_func_read(chan, "SIP_HEADER(call-id)", buf, sizeof(buf))) {
+				uuid = ast_strdup(buf);
+			}
+		}
+
+		ast_channel_cleanup(chan);
+	}
+
+	/* If we couldn't get the call-id or didn't want it, just use the channel name */
+	if (!uuid) {
+		uuid = ast_strdup(channel_name);
+	}
+
+	return uuid;
+}
+
 static void rtcp_message_handler(struct stasis_message *message)
 {
 
@@ -94,7 +135,7 @@ static void rtcp_message_handler(struct
 	ast_sockaddr_parse(&capture_info->src_addr, ast_json_string_get(from), PARSE_PORT_REQUIRE);
 	ast_sockaddr_parse(&capture_info->dst_addr, ast_json_string_get(to), PARSE_PORT_REQUIRE);
 
-	capture_info->uuid = ast_strdup(ast_json_string_get(ast_json_object_get(json_channel, "name")));
+	capture_info->uuid = assign_uuid(json_channel);
 	if (!capture_info->uuid) {
 		ao2_ref(capture_info, -1);
 		return;
@@ -118,11 +159,15 @@ static void rtp_topic_handler(void *data
 
 static int load_module(void)
 {
+	if (!ast_module_check("res_hep.so") || !hepv3_is_loaded()) {
+		ast_log(AST_LOG_WARNING, "res_hep is not loaded or running; declining module load\n");
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
 	stasis_rtp_subscription = stasis_subscribe(ast_rtp_topic(),
 		rtp_topic_handler, NULL);
 	if (!stasis_rtp_subscription) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
@@ -138,6 +183,7 @@ static int unload_module(void)
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "RTCP HEPv3 Logger",
+	.support_level = AST_MODULE_SUPPORT_EXTENDED,
 	.load = load_module,
 	.unload = unload_module,
 	.load_pri = AST_MODPRI_DEFAULT,
diff -urpN asterisk-13.9.1/res/res_http_websocket.c asterisk-13.17.0/res/res_http_websocket.c
--- asterisk-13.9.1/res/res_http_websocket.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_http_websocket.c	2017-07-12 13:12:08.000000000 +0200
@@ -51,16 +51,29 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 /*! \brief Number of buckets for registered protocols */
 #define MAX_PROTOCOL_BUCKETS 7
 
+#ifdef LOW_MEMORY
 /*! \brief Size of the pre-determined buffer for WebSocket frames */
-#define MAXIMUM_FRAME_SIZE 16384
+#define MAXIMUM_FRAME_SIZE 8192
 
 /*! \brief Default reconstruction size for multi-frame payload reconstruction. If exceeded the next frame will start a
  *         payload.
  */
-#define DEFAULT_RECONSTRUCTION_CEILING 16384
+#define DEFAULT_RECONSTRUCTION_CEILING 8192
 
 /*! \brief Maximum reconstruction size for multi-frame payload reconstruction. */
-#define MAXIMUM_RECONSTRUCTION_CEILING 16384
+#define MAXIMUM_RECONSTRUCTION_CEILING 8192
+#else
+/*! \brief Size of the pre-determined buffer for WebSocket frames */
+#define MAXIMUM_FRAME_SIZE 32768
+
+/*! \brief Default reconstruction size for multi-frame payload reconstruction. If exceeded the next frame will start a
+ *         payload.
+ */
+#define DEFAULT_RECONSTRUCTION_CEILING 32768
+
+/*! \brief Maximum reconstruction size for multi-frame payload reconstruction. */
+#define MAXIMUM_RECONSTRUCTION_CEILING 32768
+#endif
 
 /*! \brief Maximum size of a websocket frame header
  * 1 byte flags and opcode
@@ -1421,7 +1434,7 @@ static int load_module(void)
 {
 	websocketuri.data = websocket_server_internal_create();
 	if (!websocketuri.data) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_http_uri_link(&websocketuri);
 	websocket_add_protocol_internal("echo", websocket_echo_callback);
diff -urpN asterisk-13.9.1/res/res_limit.c asterisk-13.17.0/res/res_limit.c
--- asterisk-13.9.1/res/res_limit.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_limit.c	2017-07-12 13:12:08.000000000 +0200
@@ -211,7 +211,7 @@ static int unload_module(void)
 
 static int load_module(void)
 {
-	return ast_cli_register(&cli_ulimit) ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_SUCCESS;
+	return ast_cli_register(&cli_ulimit) ? AST_MODULE_LOAD_DECLINE : AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "Resource limits");
diff -urpN asterisk-13.9.1/res/res_musiconhold.c asterisk-13.17.0/res/res_musiconhold.c
--- asterisk-13.9.1/res/res_musiconhold.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_musiconhold.c	2017-07-12 13:12:08.000000000 +0200
@@ -154,6 +154,7 @@ struct moh_files_state {
 
 /* Custom astobj2 flag */
 #define MOH_NOTDELETED          (1 << 30)       /*!< Find only records that aren't deleted? */
+#define MOH_REALTIME          (1 << 31)       /*!< Find only records that are realtime */
 
 static struct ast_flags global_flags[1] = {{0}};        /*!< global MOH_ flags */
 
@@ -1075,16 +1076,13 @@ static int moh_scan_files(struct mohclas
 	DIR *files_DIR;
 	struct dirent *files_dirent;
 	char dir_path[PATH_MAX];
-	char path[PATH_MAX];
 	char filepath[PATH_MAX];
 	char *ext;
 	struct stat statbuf;
 	int i;
 
 	if (class->dir[0] != '/') {
-		ast_copy_string(dir_path, ast_config_AST_DATA_DIR, sizeof(dir_path));
-		strncat(dir_path, "/", sizeof(dir_path) - 1);
-		strncat(dir_path, class->dir, sizeof(dir_path) - 1);
+		snprintf(dir_path, sizeof(dir_path), "%s/%s", ast_config_AST_DATA_DIR, class->dir);
 	} else {
 		ast_copy_string(dir_path, class->dir, sizeof(dir_path));
 	}
@@ -1100,16 +1098,6 @@ static int moh_scan_files(struct mohclas
 	}
 	class->total_files = 0;
 
-	if (!getcwd(path, sizeof(path))) {
-		ast_log(LOG_WARNING, "getcwd() failed: %s\n", strerror(errno));
-		closedir(files_DIR);
-		return -1;
-	}
-	if (chdir(dir_path) < 0) {
-		ast_log(LOG_WARNING, "chdir() failed: %s\n", strerror(errno));
-		closedir(files_DIR);
-		return -1;
-	}
 	while ((files_dirent = readdir(files_DIR))) {
 		/* The file name must be at least long enough to have the file type extension */
 		if ((strlen(files_dirent->d_name) < 4))
@@ -1146,10 +1134,6 @@ static int moh_scan_files(struct mohclas
 	}
 
 	closedir(files_DIR);
-	if (chdir(path) < 0) {
-		ast_log(LOG_WARNING, "chdir() failed: %s\n", strerror(errno));
-		return -1;
-	}
 	if (ast_test_flag(class, MOH_SORTALPHA))
 		qsort(&class->filearray[0], class->total_files, sizeof(char *), moh_sort_compare);
 	return class->total_files;
@@ -1433,6 +1417,7 @@ static int local_ast_moh_start(struct as
 				else if (!strcasecmp(tmp->name, "sort") && !strcasecmp(tmp->value, "alpha")) 
 					ast_set_flag(mohclass, MOH_SORTALPHA);
 				else if (!strcasecmp(tmp->name, "format")) {
+					ao2_cleanup(mohclass->format);
 					mohclass->format = ast_format_cache_get(tmp->value);
 					if (!mohclass->format) {
 						ast_log(LOG_WARNING, "Unknown format '%s' -- defaulting to SLIN\n", tmp->value);
@@ -1563,8 +1548,10 @@ static int local_ast_moh_start(struct as
 		}
 	}
 	if (!res) {
+		ast_channel_lock(chan);
 		ast_channel_latest_musicclass_set(chan, mohclass->name);
 		ast_set_flag(ast_channel_flags(chan), AST_FLAG_MOH);
+		ast_channel_unlock(chan);
 	}
 
 	mohclass = mohclass_unref(mohclass, "unreffing local reference to mohclass in local_ast_moh_start");
@@ -1574,10 +1561,10 @@ static int local_ast_moh_start(struct as
 
 static void local_ast_moh_stop(struct ast_channel *chan)
 {
-	ast_clear_flag(ast_channel_flags(chan), AST_FLAG_MOH);
 	ast_deactivate_generator(chan);
 
 	ast_channel_lock(chan);
+	ast_clear_flag(ast_channel_flags(chan), AST_FLAG_MOH);
 	if (ast_channel_music_state(chan)) {
 		if (ast_channel_stream(chan)) {
 			ast_closestream(ast_channel_stream(chan));
@@ -1682,7 +1669,9 @@ static int moh_class_mark(void *obj, voi
 {
 	struct mohclass *class = obj;
 
-	class->delete = 1;
+	if ( ((flags & MOH_REALTIME) && class->realtime) || !(flags & MOH_REALTIME) ) {
+		class->delete = 1;
+	}
 
 	return 0;
 }
@@ -1698,22 +1687,27 @@ static int load_moh_classes(int reload)
 {
 	struct ast_config *cfg;
 	struct ast_variable *var;
-	struct mohclass *class;	
+	struct mohclass *class;
 	char *cat;
 	int numclasses = 0;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
 
 	cfg = ast_config_load("musiconhold.conf", config_flags);
 
-	if (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEINVALID) {
+	if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
 		if (ast_check_realtime("musiconhold") && reload) {
-			ao2_t_callback(mohclasses, OBJ_NODATA, moh_class_mark, NULL, "Mark deleted classes");
+			ao2_t_callback(mohclasses, OBJ_NODATA | MOH_REALTIME, moh_class_mark, NULL, "Mark realtime classes for deletion");
 			ao2_t_callback(mohclasses, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, moh_classes_delete_marked, NULL, "Purge marked classes");
 		}
+		moh_rescan_files();
 		return 0;
 	}
-	if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
-		moh_rescan_files();
+
+	if (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEINVALID) {
+		if (ast_check_realtime("musiconhold") && reload) {
+			ao2_t_callback(mohclasses, OBJ_NODATA, moh_class_mark, NULL, "Mark deleted classes");
+			ao2_t_callback(mohclasses, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, moh_classes_delete_marked, NULL, "Purge marked classes");
+		}
 		return 0;
 	}
 
@@ -1765,6 +1759,7 @@ static int load_moh_classes(int reload)
 			} else if (!strcasecmp(var->name, "sort") && !strcasecmp(var->value, "alpha")) {
 				ast_set_flag(class, MOH_SORTALPHA);
 			} else if (!strcasecmp(var->name, "format")) {
+				ao2_cleanup(class->format);
 				class->format = ast_format_cache_get(var->value);
 				if (!class->format) {
 					ast_log(LOG_WARNING, "Unknown format '%s' -- defaulting to SLIN\n", var->value);
diff -urpN asterisk-13.9.1/res/res_odbc.c asterisk-13.17.0/res/res_odbc.c
--- asterisk-13.9.1/res/res_odbc.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_odbc.c	2017-07-12 13:12:08.000000000 +0200
@@ -41,6 +41,7 @@
 
 /*** MODULEINFO
 	<depend>generic_odbc</depend>
+	<depend>res_odbc_transaction</depend>
 	<depend>ltdl</depend>
 	<support_level>core</support_level>
  ***/
@@ -78,10 +79,19 @@ struct odbc_class
 	unsigned int forcecommit:1;          /*!< Should uncommitted transactions be auto-committed on handle release? */
 	unsigned int isolation;              /*!< Flags for how the DB should deal with data in other, uncommitted transactions */
 	unsigned int conntimeout;            /*!< Maximum time the connection process should take */
+	unsigned int maxconnections;         /*!< Maximum number of allowed connections */
 	/*! When a connection fails, cache that failure for how long? */
 	struct timeval negative_connection_cache;
 	/*! When a connection fails, when did that last occur? */
 	struct timeval last_negative_connect;
+	/*! A pool of available connections */
+	AST_LIST_HEAD_NOLOCK(, odbc_obj) connections;
+	/*! Lock to protect the connections */
+	ast_mutex_t lock;
+	/*! Condition to notify any pending connection requesters */
+	ast_cond_t cond;
+	/*! The total number of current connections */
+	size_t connection_cnt;
 };
 
 static struct ao2_container *class_container;
@@ -90,7 +100,7 @@ static AST_RWLIST_HEAD_STATIC(odbc_table
 
 static odbc_status odbc_obj_connect(struct odbc_obj *obj);
 static odbc_status odbc_obj_disconnect(struct odbc_obj *obj);
-static int odbc_register_class(struct odbc_class *class, int connect);
+static void odbc_register_class(struct odbc_class *class, int connect);
 
 AST_THREADSTORAGE(errors_buf);
 
@@ -157,6 +167,8 @@ int ast_odbc_text2isolation(const char *
 static void odbc_class_destructor(void *data)
 {
 	struct odbc_class *class = data;
+	struct odbc_obj *obj;
+
 	/* Due to refcounts, we can safely assume that any objects with a reference
 	 * to us will prevent our destruction, so we don't need to worry about them.
 	 */
@@ -169,7 +181,14 @@ static void odbc_class_destructor(void *
 	if (class->sanitysql) {
 		ast_free(class->sanitysql);
 	}
+
+	while ((obj = AST_LIST_REMOVE_HEAD(&class->connections, list))) {
+		ao2_ref(obj, -1);
+	}
+
 	SQLFreeHandle(SQL_HANDLE_ENV, class->env);
+	ast_mutex_destroy(&class->lock);
+	ast_cond_destroy(&class->cond);
 }
 
 static int null_hash_fn(const void *obj, const int flags)
@@ -180,21 +199,23 @@ static int null_hash_fn(const void *obj,
 static void odbc_obj_destructor(void *data)
 {
 	struct odbc_obj *obj = data;
-	struct odbc_class *class = obj->parent;
-	obj->parent = NULL;
+
 	odbc_obj_disconnect(obj);
-	ao2_ref(class, -1);
 }
 
-static void destroy_table_cache(struct odbc_cache_tables *table) {
+static void destroy_table_cache(struct odbc_cache_tables *table)
+{
 	struct odbc_cache_columns *col;
+
 	ast_debug(1, "Destroying table cache for %s\n", table->table);
+
 	AST_RWLIST_WRLOCK(&table->columns);
 	while ((col = AST_RWLIST_REMOVE_HEAD(&table->columns, list))) {
 		ast_free(col);
 	}
 	AST_RWLIST_UNLOCK(&table->columns);
 	AST_RWLIST_HEAD_DESTROY(&table->columns);
+
 	ast_free(table);
 }
 
@@ -370,18 +391,19 @@ SQLHSTMT ast_odbc_prepare_and_execute(st
 	 * We must therefore redo everything when we establish a new
 	 * connection. */
 	stmt = prepare_cb(obj, data);
+	if (!stmt) {
+		return NULL;
+	}
 
-	if (stmt) {
-		res = SQLExecute(stmt);
-		if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO) && (res != SQL_NO_DATA)) {
-			if (res == SQL_ERROR) {
-				ast_odbc_print_errors(SQL_HANDLE_STMT, stmt, "SQL Execute");
-			}
-
-			ast_log(LOG_WARNING, "SQL Execute error %d!\n", res);
-			SQLFreeHandle(SQL_HANDLE_STMT, stmt);
-			stmt = NULL;
+	res = SQLExecute(stmt);
+	if ((res != SQL_SUCCESS) && (res != SQL_SUCCESS_WITH_INFO) && (res != SQL_NO_DATA)) {
+		if (res == SQL_ERROR) {
+			ast_odbc_print_errors(SQL_HANDLE_STMT, stmt, "SQL Execute");
 		}
+
+		ast_log(LOG_WARNING, "SQL Execute error %d!\n", res);
+		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+		stmt = NULL;
 	}
 
 	return stmt;
@@ -468,7 +490,7 @@ static int load_odbc_config(void)
 	struct ast_variable *v;
 	char *cat;
 	const char *dsn, *username, *password, *sanitysql;
-	int enabled, bse, conntimeout, forcecommit, isolation;
+	int enabled, bse, conntimeout, forcecommit, isolation, maxconnections;
 	struct timeval ncache = { 0, 0 };
 	int preconnect = 0, res = 0;
 	struct ast_flags config_flags = { 0 };
@@ -495,12 +517,13 @@ static int load_odbc_config(void)
 			conntimeout = 10;
 			forcecommit = 0;
 			isolation = SQL_TXN_READ_COMMITTED;
+			maxconnections = 1;
 			for (v = ast_variable_browse(config, cat); v; v = v->next) {
 				if (!strcasecmp(v->name, "pooling") ||
 						!strncasecmp(v->name, "share", 5) ||
 						!strcasecmp(v->name, "limit") ||
 						!strcasecmp(v->name, "idlecheck")) {
-					ast_log(LOG_WARNING, "The 'pooling', 'shared_connections', 'limit', and 'idlecheck' options are deprecated. Please see UPGRADE.txt for information\n");
+					ast_log(LOG_WARNING, "The 'pooling', 'shared_connections', 'limit', and 'idlecheck' options were replaced by 'max_connections'.  See res_odbc.conf.sample.\n");
 				} else if (!strcasecmp(v->name, "enabled")) {
 					enabled = ast_true(v->value);
 				} else if (!strcasecmp(v->name, "pre-connect")) {
@@ -538,6 +561,11 @@ static int load_odbc_config(void)
 						ast_log(LOG_ERROR, "Unrecognized value for 'isolation': '%s' in section '%s'\n", v->value, cat);
 						isolation = SQL_TXN_READ_COMMITTED;
 					}
+				} else if (!strcasecmp(v->name, "max_connections")) {
+					if (sscanf(v->value, "%30d", &maxconnections) != 1 || maxconnections < 1) {
+						ast_log(LOG_WARNING, "max_connections must be a positive integer\n");
+						maxconnections = 1;
+                                        }
 				}
 			}
 
@@ -563,6 +591,7 @@ static int load_odbc_config(void)
 				new->isolation = isolation;
 				new->conntimeout = conntimeout;
 				new->negative_connection_cache = ncache;
+				new->maxconnections = maxconnections;
 
 				if (cat)
 					ast_copy_string(new->name, cat, sizeof(new->name));
@@ -581,6 +610,9 @@ static int load_odbc_config(void)
 					break;
 				}
 
+				ast_mutex_init(&new->lock);
+				ast_cond_init(&new->cond, NULL);
+
 				odbc_register_class(new, preconnect);
 				ast_log(LOG_NOTICE, "Registered ODBC class '%s' dsn->[%s]\n", cat, dsn);
 				ao2_ref(new, -1);
@@ -641,6 +673,7 @@ static char *handle_cli_odbc_show(struct
 			ast_strftime(timestr, sizeof(timestr), "%Y-%m-%d %T", &tm);
 			ast_cli(a->fd, "  Name:   %s\n  DSN:    %s\n", class->name, class->dsn);
 			ast_cli(a->fd, "    Last connection attempt: %s\n", timestr);
+			ast_cli(a->fd, "    Number of active connections: %zd (out of %d)\n", class->connection_cnt, class->maxconnections);
 			ast_cli(a->fd, "\n");
 		}
 		ao2_ref(class, -1);
@@ -654,38 +687,47 @@ static struct ast_cli_entry cli_odbc[] =
 	AST_CLI_DEFINE(handle_cli_odbc_show, "List ODBC DSN(s)")
 };
 
-static int odbc_register_class(struct odbc_class *class, int preconnect)
+static void odbc_register_class(struct odbc_class *class, int preconnect)
 {
 	struct odbc_obj *obj;
-	if (class) {
-		ao2_link(class_container, class);
-		/* I still have a reference in the caller, so a deref is NOT missing here. */
-
-		if (preconnect) {
-			/* Request and release builds a connection */
-			obj = ast_odbc_request_obj(class->name, 0);
-			if (obj) {
-				ast_odbc_release_obj(obj);
-			}
-		}
 
-		return 0;
-	} else {
-		ast_log(LOG_WARNING, "Attempted to register a NULL class?\n");
-		return -1;
+	ao2_link(class_container, class);
+	/* I still have a reference in the caller, so a deref is NOT missing here. */
+
+	if (!preconnect) {
+		return;
 	}
+
+	/* Request and release builds a connection */
+	obj = ast_odbc_request_obj(class->name, 0);
+	if (obj) {
+		ast_odbc_release_obj(obj);
+	}
+
+	return;
 }
 
 void ast_odbc_release_obj(struct odbc_obj *obj)
 {
-	ast_debug(2, "Releasing ODBC handle %p\n", obj);
+	struct odbc_class *class = obj->parent;
+
+	ast_debug(2, "Releasing ODBC handle %p into pool\n", obj);
+
+	/* The odbc_obj only holds a reference to the class when it is
+	 * actively being used. This guarantees no circular reference
+	 * between odbc_class and odbc_obj. Since it is being released
+	 * we also release our class reference. If a reload occurred before
+	 * the class will go away automatically once all odbc_obj are
+	 * released back.
+	 */
+	obj->parent = NULL;
+
+	ast_mutex_lock(&class->lock);
+	AST_LIST_INSERT_HEAD(&class->connections, obj, list);
+	ast_cond_signal(&class->cond);
+	ast_mutex_unlock(&class->lock);
 
-#ifdef DEBUG_THREADS
-	obj->file[0] = '\0';
-	obj->function[0] = '\0';
-	obj->lineno = 0;
-#endif
-	ao2_ref(obj, -1);
+	ao2_ref(class, -1);
 }
 
 int ast_odbc_backslash_is_escape(struct odbc_obj *obj)
@@ -703,6 +745,66 @@ static int aoro2_class_cb(void *obj, voi
 	return 0;
 }
 
+unsigned int ast_odbc_get_max_connections(const char *name)
+{
+	struct odbc_class *class;
+	unsigned int max_connections;
+
+	class = ao2_callback(class_container, 0, aoro2_class_cb, (char *) name);
+	if (!class) {
+		return 0;
+	}
+
+	max_connections = class->maxconnections;
+	ao2_ref(class, -1);
+
+	return max_connections;
+}
+
+/*
+ * \brief Determine if the connection has died.
+ *
+ * \param connection The connection to check
+ * \param class The ODBC class
+ * \retval 1 Yep, it's dead
+ * \retval 0 It's alive and well
+ */
+static int connection_dead(struct odbc_obj *connection, struct odbc_class *class)
+{
+	char *test_sql = "select 1";
+	SQLINTEGER dead;
+	SQLRETURN res;
+	SQLHSTMT stmt;
+
+	res = SQLGetConnectAttr(connection->con, SQL_ATTR_CONNECTION_DEAD, &dead, 0, 0);
+	if (SQL_SUCCEEDED(res)) {
+		return dead == SQL_CD_TRUE ? 1 : 0;
+	}
+
+	/* If the Driver doesn't support SQL_ATTR_CONNECTION_DEAD do a
+	 * probing query instead
+	 */
+	res = SQLAllocHandle(SQL_HANDLE_STMT, connection->con, &stmt);
+	if (!SQL_SUCCEEDED(res)) {
+		return 1;
+	}
+
+	if (!ast_strlen_zero(class->sanitysql)) {
+		test_sql = class->sanitysql;
+	}
+
+	res = SQLPrepare(stmt, (unsigned char *)test_sql, SQL_NTS);
+	if (!SQL_SUCCEEDED(res)) {
+		SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+		return 1;
+	}
+
+	res = SQLExecute(stmt);
+	SQLFreeHandle(SQL_HANDLE_STMT, stmt);
+
+	return SQL_SUCCEEDED(res) ? 0 : 1;
+}
+
 struct odbc_obj *_ast_odbc_request_obj2(const char *name, struct ast_flags flags, const char *file, const char *function, int lineno)
 {
 	struct odbc_obj *obj = NULL;
@@ -713,17 +815,60 @@ struct odbc_obj *_ast_odbc_request_obj2(
 		return NULL;
 	}
 
-	/* XXX ODBC connection objects do not have shared ownership, so there is no reason
-	 * to use refcounted objects here.
-	 */
-	obj = ao2_alloc(sizeof(*obj), odbc_obj_destructor);
-	/* Inherit reference from the ao2_callback from before */
-	obj->parent = class;
-	if (odbc_obj_connect(obj) == ODBC_FAIL) {
-		ao2_ref(obj, -1);
-		return NULL;
+	ast_mutex_lock(&class->lock);
+
+	while (!obj) {
+		obj = AST_LIST_REMOVE_HEAD(&class->connections, list);
+
+		if (!obj) {
+			if (class->connection_cnt < class->maxconnections) {
+				/* If no connection is immediately available establish a new
+				 * one if allowed. If we try and fail we give up completely as
+				 * we could go into an infinite loop otherwise.
+				 */
+				obj = ao2_alloc(sizeof(*obj), odbc_obj_destructor);
+				if (!obj) {
+					break;
+				}
+
+				obj->parent = ao2_bump(class);
+				if (odbc_obj_connect(obj) == ODBC_FAIL) {
+					ao2_ref(obj->parent, -1);
+					ao2_ref(obj, -1);
+					obj = NULL;
+					break;
+				}
+
+				class->connection_cnt++;
+				ast_debug(2, "Created ODBC handle %p on class '%s', new count is %zd\n", obj,
+					name, class->connection_cnt);
+			} else {
+				/* Otherwise if we're not allowed to create a new one we
+				 * wait for another thread to give up the connection they
+				 * own.
+				 */
+				ast_cond_wait(&class->cond, &class->lock);
+			}
+		} else if (connection_dead(obj, class)) {
+			/* If the connection is dead try to grab another functional one from the
+			 * pool instead of trying to resurrect this one.
+			 */
+			ao2_ref(obj, -1);
+			obj = NULL;
+			class->connection_cnt--;
+			ast_debug(2, "ODBC handle %p dead - removing from class '%s', new count is %zd\n",
+				obj, name, class->connection_cnt);
+		} else {
+			/* We successfully grabbed a connection from the pool and all is well!
+			 */
+			obj->parent = ao2_bump(class);
+			ast_debug(2, "Reusing ODBC handle %p from class '%s'\n", obj, name);
+		}
 	}
 
+	ast_mutex_unlock(&class->lock);
+	ao2_ref(class, -1);
+
 	return obj;
 }
 
@@ -755,14 +900,6 @@ static odbc_status odbc_obj_disconnect(s
 	obj->con = NULL;
 	res = SQLDisconnect(con);
 
-	if (obj->parent) {
-		if (res == SQL_SUCCESS || res == SQL_SUCCESS_WITH_INFO) {
-			ast_debug(3, "Disconnected %d from %s [%s](%p)\n", res, obj->parent->name, obj->parent->dsn, obj);
-		} else {
-			ast_debug(3, "res_odbc: %s [%s](%p) already disconnected\n", obj->parent->name, obj->parent->dsn, obj);
-		}
-	}
-
 	if ((res = SQLFreeHandle(SQL_HANDLE_DBC, con)) == SQL_SUCCESS) {
 		ast_debug(3, "Database handle %p (connection %p) deallocated\n", obj, con);
 	} else {
diff -urpN asterisk-13.9.1/res/res_odbc_transaction.c asterisk-13.17.0/res/res_odbc_transaction.c
--- asterisk-13.9.1/res/res_odbc_transaction.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_odbc_transaction.c	2017-07-12 13:12:08.000000000 +0200
@@ -26,7 +26,7 @@
 #include "asterisk/module.h"
 
 /*** MODULEINFO
-	<depend>res_odbc</depend>
+	<depend>generic_odbc</depend>
 	<support_level>core</support_level>
  ***/
 
diff -urpN asterisk-13.9.1/res/res_phoneprov.c asterisk-13.17.0/res/res_phoneprov.c
--- asterisk-13.9.1/res/res_phoneprov.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_phoneprov.c	2017-07-12 13:12:08.000000000 +0200
@@ -410,10 +410,13 @@ static int load_file(const char *filenam
 	fseek(f, 0, SEEK_END);
 	len = ftell(f);
 	fseek(f, 0, SEEK_SET);
-	if (!(*ret = ast_malloc(len + 1)))
+	if (!(*ret = ast_malloc(len + 1))) {
+		fclose(f);
 		return -2;
+	}
 
 	if (len != fread(*ret, sizeof(char), len, f)) {
+		fclose(f);
 		free(*ret);
 		*ret = NULL;
 		return -3;
diff -urpN asterisk-13.9.1/res/res_pjproject.c asterisk-13.17.0/res/res_pjproject.c
--- asterisk-13.9.1/res/res_pjproject.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjproject.c	2017-07-12 13:12:08.000000000 +0200
@@ -41,6 +41,27 @@
 	<configInfo name="res_pjproject" language="en_US">
 		<synopsis>pjproject common configuration</synopsis>
 		<configFile name="pjproject.conf">
+			<configObject name="startup">
+				<synopsis>Asterisk startup time options for PJPROJECT</synopsis>
+				<description>
+					<note><para>The id of this object, as well as its type, must be
+					'startup' or it won't be found.</para></note>
+				</description>
+				<configOption name="type">
+					<synopsis>Must be of type 'startup'.</synopsis>
+				</configOption>
+				<configOption name="log_level" default="2">
+					<synopsis>Initial maximum pjproject logging level to log.</synopsis>
+					<description>
+						<para>Valid values are: 0-6, and default</para>
+					<note><para>
+						This option is needed very early in the startup process
+						so it can only be read from config files because the
+						modules for other methods have not been loaded yet.
+					</para></note>
+					</description>
+				</configOption>
+			</configObject>
 			<configObject name="log_mappings">
 				<synopsis>PJPROJECT to Asterisk Log Level Mapping</synopsis>
 				<description><para>Warnings and errors in the pjproject libraries are generally handled
@@ -64,7 +85,7 @@
 				<configOption name="asterisk_notice" default="">
 					<synopsis>A comma separated list of pjproject log levels to map to Asterisk LOG_NOTICE.</synopsis>
 				</configOption>
-				<configOption name="asterisk_debug" default="3,4,5">
+				<configOption name="asterisk_debug" default="3,4,5,6">
 					<synopsis>A comma separated list of pjproject log levels to map to Asterisk LOG_DEBUG.</synopsis>
 				</configOption>
 				<configOption name="asterisk_verbose" default="">
@@ -84,6 +105,7 @@ ASTERISK_REGISTER_FILE()
 #include <pjsip.h>
 #include <pj/log.h>
 
+#include "asterisk/options.h"
 #include "asterisk/logger.h"
 #include "asterisk/module.h"
 #include "asterisk/cli.h"
@@ -146,9 +168,11 @@ static struct log_mappings *get_log_mapp
 
 static int get_log_level(int pj_level)
 {
-	RAII_VAR(struct log_mappings *, mappings, get_log_mappings(), ao2_cleanup);
+	int mapped_level;
 	unsigned char l;
+	struct log_mappings *mappings;
 
+	mappings = get_log_mappings();
 	if (!mappings) {
 		return __LOG_ERROR;
 	}
@@ -156,18 +180,21 @@ static int get_log_level(int pj_level)
 	l = '0' + fmin(pj_level, 9);
 
 	if (strchr(mappings->asterisk_error, l)) {
-		return __LOG_ERROR;
+		mapped_level = __LOG_ERROR;
 	} else if (strchr(mappings->asterisk_warning, l)) {
-		return __LOG_WARNING;
+		mapped_level = __LOG_WARNING;
 	} else if (strchr(mappings->asterisk_notice, l)) {
-		return __LOG_NOTICE;
+		mapped_level = __LOG_NOTICE;
 	} else if (strchr(mappings->asterisk_verbose, l)) {
-		return __LOG_VERBOSE;
+		mapped_level = __LOG_VERBOSE;
 	} else if (strchr(mappings->asterisk_debug, l)) {
-		return __LOG_DEBUG;
+		mapped_level = __LOG_DEBUG;
+	} else {
+		mapped_level = __LOG_SUPPRESS;
 	}
 
-	return __LOG_SUPPRESS;
+	ao2_ref(mappings, -1);
+	return mapped_level;
 }
 
 static void log_forwarder(int level, const char *data, int len)
@@ -177,7 +204,6 @@ static void log_forwarder(int level, con
 	const char * log_source = "pjproject";
 	int log_line = 0;
 	const char *log_func = "<?>";
-	int mod_level;
 
 	if (pjproject_log_intercept.fd != -1
 		&& pjproject_log_intercept.thread == pthread_self()) {
@@ -195,15 +221,6 @@ static void log_forwarder(int level, con
 		return;
 	}
 
-	if (ast_level == __LOG_DEBUG) {
-		/* For levels 3 and up, obey the debug level for res_pjproject */
-		mod_level = ast_opt_dbg_module ?
-			ast_debug_get_by_module("res_pjproject") : 0;
-		if (option_debug < level && mod_level < level) {
-			return;
-		}
-	}
-
 	/* PJPROJECT uses indention to indicate function call depth. We'll prepend
 	 * log statements with a tab so they'll have a better shot at lining
 	 * up */
@@ -354,9 +371,99 @@ static char *handle_pjproject_show_log_m
 	return CLI_SUCCESS;
 }
 
+struct max_pjproject_log_level_check {
+	/*!
+	 * Compile time sanity check to determine if
+	 * MAX_PJ_LOG_MAX_LEVEL matches CLI syntax.
+	 */
+	char check[1 / (6 == MAX_PJ_LOG_MAX_LEVEL)];
+};
+
+static char *handle_pjproject_set_log_level(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int level_new;
+	int level_old;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pjproject set log level {default|0|1|2|3|4|5|6}";
+		e->usage =
+			"Usage: pjproject set log level {default|<level>}\n"
+			"\n"
+			"       Set the maximum active pjproject logging level.\n"
+			"       See pjproject.conf.sample for additional information\n"
+			"       about the various levels pjproject uses.\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc != 5) {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!strcasecmp(a->argv[4], "default")) {
+		level_new = DEFAULT_PJ_LOG_MAX_LEVEL;
+	} else {
+		if (sscanf(a->argv[4], "%30d", &level_new) != 1
+			|| level_new < 0 || MAX_PJ_LOG_MAX_LEVEL < level_new) {
+			return CLI_SHOWUSAGE;
+		}
+	}
+
+	/* Update pjproject logging level */
+	if (ast_pjproject_max_log_level < level_new) {
+		level_new = ast_pjproject_max_log_level;
+		ast_cli(a->fd,
+			"Asterisk built or linked with pjproject PJ_LOG_MAX_LEVEL=%d.\n"
+			"Lowering request to the max supported level.\n",
+			ast_pjproject_max_log_level);
+	}
+	level_old = ast_option_pjproject_log_level;
+	if (level_old == level_new) {
+		ast_cli(a->fd, "pjproject log level is still %d.\n", level_old);
+	} else {
+		ast_cli(a->fd, "pjproject log level was %d and is now %d.\n",
+			level_old, level_new);
+		ast_option_pjproject_log_level = level_new;
+		pj_log_set_level(level_new);
+	}
+
+	return CLI_SUCCESS;
+}
+
+static char *handle_pjproject_show_log_level(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pjproject show log level";
+		e->usage =
+			"Usage: pjproject show log level\n"
+			"\n"
+			"       Show the current maximum active pjproject logging level.\n"
+			"       See pjproject.conf.sample for additional information\n"
+			"       about the various levels pjproject uses.\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc != 4) {
+		return CLI_SHOWUSAGE;
+	}
+
+	ast_cli(a->fd, "pjproject log level is %d.%s\n",
+		ast_option_pjproject_log_level,
+		ast_option_pjproject_log_level == DEFAULT_PJ_LOG_MAX_LEVEL ? " (default)" : "");
+
+	return CLI_SUCCESS;
+}
+
 static struct ast_cli_entry pjproject_cli[] = {
+	AST_CLI_DEFINE(handle_pjproject_set_log_level, "Set the maximum active pjproject logging level"),
 	AST_CLI_DEFINE(handle_pjproject_show_buildopts, "Show the compiled config of the pjproject in use"),
 	AST_CLI_DEFINE(handle_pjproject_show_log_mappings, "Show pjproject to Asterisk log mappings"),
+	AST_CLI_DEFINE(handle_pjproject_show_log_level, "Show the maximum active pjproject logging level"),
 };
 
 static int load_module(void)
@@ -390,10 +497,11 @@ static int load_module(void)
 	}
 	ast_string_field_set(default_log_mappings, asterisk_error, "0,1");
 	ast_string_field_set(default_log_mappings, asterisk_warning, "2");
-	ast_string_field_set(default_log_mappings, asterisk_debug, "3,4,5");
+	ast_string_field_set(default_log_mappings, asterisk_debug, "3,4,5,6");
 
 	ast_sorcery_load(pjproject_sorcery);
 
+	AST_PJPROJECT_INIT_LOG_LEVEL();
 	pj_init();
 
 	decor_orig = pj_log_get_decor();
@@ -408,9 +516,22 @@ static int load_module(void)
 	 */
 	pj_log_set_log_func(capture_buildopts_cb);
 	pj_log_set_decor(0);
+	pj_log_set_level(MAX_PJ_LOG_MAX_LEVEL);/* Set level to guarantee the dump output. */
 	pj_dump_config();
 	pj_log_set_decor(PJ_LOG_HAS_SENDER | PJ_LOG_HAS_INDENT);
 	pj_log_set_log_func(log_forwarder);
+	if (ast_pjproject_max_log_level < ast_option_pjproject_log_level) {
+		ast_log(LOG_WARNING,
+			"Asterisk built or linked with pjproject PJ_LOG_MAX_LEVEL=%d which is too low for startup level: %d.\n",
+			ast_pjproject_max_log_level, ast_option_pjproject_log_level);
+		ast_option_pjproject_log_level = ast_pjproject_max_log_level;
+	}
+	pj_log_set_level(ast_option_pjproject_log_level);
+	if (!AST_VECTOR_SIZE(&buildopts)) {
+		ast_log(LOG_NOTICE,
+			"Asterisk built or linked with pjproject PJ_LOG_MAX_LEVEL=%d which is too low to get buildopts.\n",
+			ast_pjproject_max_log_level);
+	}
 
 	ast_cli_register_multiple(pjproject_cli, ARRAY_LEN(pjproject_cli));
 
diff -urpN asterisk-13.9.1/res/res_pjsip/config_global.c asterisk-13.17.0/res/res_pjsip/config_global.c
--- asterisk-13.9.1/res/res_pjsip/config_global.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/config_global.c	2017-07-12 13:12:08.000000000 +0200
@@ -24,6 +24,7 @@
 #include "asterisk/res_pjsip.h"
 #include "include/res_pjsip_private.h"
 #include "asterisk/sorcery.h"
+#include "asterisk/taskprocessor.h"
 #include "asterisk/ast_version.h"
 #include "asterisk/res_pjsip_cli.h"
 
@@ -35,9 +36,27 @@
 #define DEFAULT_ENDPOINT_IDENTIFIER_ORDER "ip,username,anonymous"
 #define DEFAULT_MAX_INITIAL_QUALIFY_TIME 0
 #define DEFAULT_FROM_USER "asterisk"
+#define DEFAULT_REALM "asterisk"
 #define DEFAULT_REGCONTEXT ""
 #define DEFAULT_CONTACT_EXPIRATION_CHECK_INTERVAL 30
+#define DEFAULT_DISABLE_MULTI_DOMAIN 0
 #define DEFAULT_VOICEMAIL_EXTENSION ""
+#define DEFAULT_UNIDENTIFIED_REQUEST_COUNT 5
+#define DEFAULT_UNIDENTIFIED_REQUEST_PERIOD 5
+#define DEFAULT_UNIDENTIFIED_REQUEST_PRUNE_INTERVAL 30
+#define DEFAULT_MWI_TPS_QUEUE_HIGH AST_TASKPROCESSOR_HIGH_WATER_LEVEL
+#define DEFAULT_MWI_TPS_QUEUE_LOW -1
+#define DEFAULT_MWI_DISABLE_INITIAL_UNSOLICITED 0
+#define DEFAULT_IGNORE_URI_USER_OPTIONS 0
+
+/*!
+ * \brief Cached global config object
+ *
+ * \details
+ * Cached so we don't have to keep asking sorcery for the config.
+ * We could ask for it hundreds of times a second if not more.
+ */
+static AO2_GLOBAL_OBJ_STATIC(global_cfg);
 
 static char default_useragent[256];
 
@@ -55,15 +74,35 @@ struct global_config {
 		AST_STRING_FIELD(default_from_user);
 		/*! Default voicemail extension */
 		AST_STRING_FIELD(default_voicemail_extension);
+		/*! Realm to use in challenges before an endpoint is identified */
+		AST_STRING_FIELD(default_realm);
 	);
-	/* Value to put in Max-Forwards header */
+	/*! Value to put in Max-Forwards header */
 	unsigned int max_forwards;
-	/* The interval at which to send keep alive messages to active connection-oriented transports */
+	/*! The interval at which to send keep alive messages to active connection-oriented transports */
 	unsigned int keep_alive_interval;
-	/* The maximum time for all contacts to be qualified at startup */
+	/*! The maximum time for all contacts to be qualified at startup */
 	unsigned int max_initial_qualify_time;
-	/* The interval at which to check for expired contacts */
+	/*! The interval at which to check for expired contacts */
 	unsigned int contact_expiration_check_interval;
+	/*! Nonzero to disable multi domain support */
+	unsigned int disable_multi_domain;
+	/*! The maximum number of unidentified requests per source IP address before a security event is logged */
+	unsigned int unidentified_request_count;
+	/*! The period during which unidentified requests are accumulated */
+	unsigned int unidentified_request_period;
+	/*! Interval at which expired unidentifed requests will be pruned */
+	unsigned int unidentified_request_prune_interval;
+	struct {
+		/*! Taskprocessor high water alert trigger level */
+		unsigned int tps_queue_high;
+		/*! Taskprocessor low water clear alert level. */
+		int tps_queue_low;
+		/*! Nonzero to disable sending unsolicited mwi to all endpoints on startup */
+		unsigned int disable_initial_unsolicited;
+	} mwi;
+	/*! Nonzero if URI user field options are ignored. */
+	unsigned int ignore_uri_user_options;
 };
 
 static void global_destructor(void *obj)
@@ -91,28 +130,31 @@ static int global_apply(const struct ast
 	struct global_config *cfg = obj;
 	char max_forwards[10];
 
+	if (ast_strlen_zero(cfg->debug)) {
+		ast_log(LOG_ERROR,
+			"Global option 'debug' can't be empty.  Set it to a valid value or remove the entry to accept 'no' as the default\n");
+		return -1;
+	}
+
+	if (ast_strlen_zero(cfg->default_from_user)) {
+		ast_log(LOG_ERROR,
+			"Global option 'default_from_user' can't be empty.  Set it to a valid value or remove the entry to accept 'asterisk' as the default\n");
+		return -1;
+	}
+
 	snprintf(max_forwards, sizeof(max_forwards), "%u", cfg->max_forwards);
 
 	ast_sip_add_global_request_header("Max-Forwards", max_forwards, 1);
 	ast_sip_add_global_request_header("User-Agent", cfg->useragent, 1);
 	ast_sip_add_global_response_header("Server", cfg->useragent, 1);
+
+	ao2_t_global_obj_replace_unref(global_cfg, cfg, "Applying global settings");
 	return 0;
 }
 
 static struct global_config *get_global_cfg(void)
 {
-	struct global_config *cfg;
-	struct ao2_container *globals;
-
-	globals = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(), "global",
-		AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
-	if (!globals) {
-		return NULL;
-	}
-
-	cfg = ao2_find(globals, NULL, 0);
-	ao2_ref(globals, -1);
-	return cfg;
+	return ao2_global_obj_ref(global_cfg);
 }
 
 char *ast_sip_global_default_outbound_endpoint(void)
@@ -222,6 +264,21 @@ unsigned int ast_sip_get_contact_expirat
 	return interval;
 }
 
+unsigned int ast_sip_get_disable_multi_domain(void)
+{
+	unsigned int disable_multi_domain;
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		return DEFAULT_DISABLE_MULTI_DOMAIN;
+	}
+
+	disable_multi_domain = cfg->disable_multi_domain;
+	ao2_ref(cfg, -1);
+	return disable_multi_domain;
+}
+
 unsigned int ast_sip_get_max_initial_qualify_time(void)
 {
 	unsigned int time;
@@ -237,6 +294,40 @@ unsigned int ast_sip_get_max_initial_qua
 	return time;
 }
 
+void ast_sip_get_unidentified_request_thresholds(unsigned int *count, unsigned int *period,
+	unsigned int *prune_interval)
+{
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		*count = DEFAULT_UNIDENTIFIED_REQUEST_COUNT;
+		*period = DEFAULT_UNIDENTIFIED_REQUEST_PERIOD;
+		*prune_interval = DEFAULT_UNIDENTIFIED_REQUEST_PRUNE_INTERVAL;
+		return;
+	}
+
+	*count = cfg->unidentified_request_count;
+	*period = cfg->unidentified_request_period;
+	*prune_interval = cfg->unidentified_request_prune_interval;
+
+	ao2_ref(cfg, -1);
+	return;
+}
+
+void ast_sip_get_default_realm(char *realm, size_t size)
+{
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		ast_copy_string(realm, DEFAULT_REALM, size);
+	} else {
+		ast_copy_string(realm, cfg->default_realm, size);
+		ao2_ref(cfg, -1);
+	}
+}
+
 void ast_sip_get_default_from_user(char *from_user, size_t size)
 {
 	struct global_config *cfg;
@@ -250,6 +341,67 @@ void ast_sip_get_default_from_user(char
 	}
 }
 
+
+unsigned int ast_sip_get_mwi_tps_queue_high(void)
+{
+	unsigned int tps_queue_high;
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		return DEFAULT_MWI_TPS_QUEUE_HIGH;
+	}
+
+	tps_queue_high = cfg->mwi.tps_queue_high;
+	ao2_ref(cfg, -1);
+	return tps_queue_high;
+}
+
+int ast_sip_get_mwi_tps_queue_low(void)
+{
+	int tps_queue_low;
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		return DEFAULT_MWI_TPS_QUEUE_LOW;
+	}
+
+	tps_queue_low = cfg->mwi.tps_queue_low;
+	ao2_ref(cfg, -1);
+	return tps_queue_low;
+}
+
+unsigned int ast_sip_get_mwi_disable_initial_unsolicited(void)
+{
+	unsigned int disable_initial_unsolicited;
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		return DEFAULT_MWI_DISABLE_INITIAL_UNSOLICITED;
+	}
+
+	disable_initial_unsolicited = cfg->mwi.disable_initial_unsolicited;
+	ao2_ref(cfg, -1);
+	return disable_initial_unsolicited;
+}
+
+unsigned int ast_sip_get_ignore_uri_user_options(void)
+{
+	unsigned int ignore_uri_user_options;
+	struct global_config *cfg;
+
+	cfg = get_global_cfg();
+	if (!cfg) {
+		return DEFAULT_IGNORE_URI_USER_OPTIONS;
+	}
+
+	ignore_uri_user_options = cfg->ignore_uri_user_options;
+	ao2_ref(cfg, -1);
+	return ignore_uri_user_options;
+}
+
 /*!
  * \internal
  * \brief Observer to set default global object if none exist.
@@ -327,6 +479,8 @@ int ast_sip_destroy_sorcery_global(void)
 
 	ast_sorcery_instance_observer_remove(sorcery, &observer_callbacks_global);
 
+	ao2_t_global_obj_release(global_cfg, "Module is unloading");
+
 	return 0;
 }
 
@@ -373,6 +527,32 @@ int ast_sip_initialize_sorcery_global(vo
 	ast_sorcery_object_field_register(sorcery, "global", "contact_expiration_check_interval",
 		__stringify(DEFAULT_CONTACT_EXPIRATION_CHECK_INTERVAL),
 		OPT_UINT_T, 0, FLDSET(struct global_config, contact_expiration_check_interval));
+	ast_sorcery_object_field_register(sorcery, "global", "disable_multi_domain",
+		DEFAULT_DISABLE_MULTI_DOMAIN ? "yes" : "no",
+		OPT_BOOL_T, 1, FLDSET(struct global_config, disable_multi_domain));
+	ast_sorcery_object_field_register(sorcery, "global", "unidentified_request_count",
+		__stringify(DEFAULT_UNIDENTIFIED_REQUEST_COUNT),
+		OPT_UINT_T, 0, FLDSET(struct global_config, unidentified_request_count));
+	ast_sorcery_object_field_register(sorcery, "global", "unidentified_request_period",
+		__stringify(DEFAULT_UNIDENTIFIED_REQUEST_PERIOD),
+		OPT_UINT_T, 0, FLDSET(struct global_config, unidentified_request_period));
+	ast_sorcery_object_field_register(sorcery, "global", "unidentified_request_prune_interval",
+		__stringify(DEFAULT_UNIDENTIFIED_REQUEST_PRUNE_INTERVAL),
+		OPT_UINT_T, 0, FLDSET(struct global_config, unidentified_request_prune_interval));
+	ast_sorcery_object_field_register(sorcery, "global", "default_realm", DEFAULT_REALM,
+		OPT_STRINGFIELD_T, 0, STRFLDSET(struct global_config, default_realm));
+	ast_sorcery_object_field_register(sorcery, "global", "mwi_tps_queue_high",
+		__stringify(DEFAULT_MWI_TPS_QUEUE_HIGH),
+		OPT_UINT_T, 0, FLDSET(struct global_config, mwi.tps_queue_high));
+	ast_sorcery_object_field_register(sorcery, "global", "mwi_tps_queue_low",
+		__stringify(DEFAULT_MWI_TPS_QUEUE_LOW),
+		OPT_INT_T, 0, FLDSET(struct global_config, mwi.tps_queue_low));
+	ast_sorcery_object_field_register(sorcery, "global", "mwi_disable_initial_unsolicited",
+		DEFAULT_MWI_DISABLE_INITIAL_UNSOLICITED ? "yes" : "no",
+		OPT_BOOL_T, 1, FLDSET(struct global_config, mwi.disable_initial_unsolicited));
+	ast_sorcery_object_field_register(sorcery, "global", "ignore_uri_user_options",
+		DEFAULT_IGNORE_URI_USER_OPTIONS ? "yes" : "no",
+		OPT_BOOL_T, 1, FLDSET(struct global_config, ignore_uri_user_options));
 
 	if (ast_sorcery_instance_observer_add(sorcery, &observer_callbacks_global)) {
 		return -1;
diff -urpN asterisk-13.9.1/res/res_pjsip/config_transport.c asterisk-13.17.0/res/res_pjsip/config_transport.c
--- asterisk-13.9.1/res/res_pjsip/config_transport.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/config_transport.c	2017-07-12 13:12:08.000000000 +0200
@@ -286,15 +286,16 @@ static struct internal_state *find_inter
 static struct ast_sip_transport_state *find_state_by_transport(const struct ast_sip_transport *transport)
 {
 	struct internal_state *state;
+	struct ast_sip_transport_state *trans_state;
 
 	state = find_internal_state_by_transport(transport);
 	if (!state) {
 		return NULL;
 	}
-	ao2_bump(state->state);
-	ao2_cleanup(state);
+	trans_state = ao2_bump(state->state);
+	ao2_ref(state, -1);
 
-	return state->state;
+	return trans_state;
 }
 
 static int remove_temporary_state(void)
@@ -378,6 +379,10 @@ static struct ast_sip_transport_state *f
 	new_state->type = transport->type;
 
 	pjsip_tls_setting_default(&new_state->tls);
+#ifdef HAVE_PJSIP_TLS_TRANSPORT_PROTO
+	/* proto must be forced to 0 to enable all protocols otherwise only TLS will work */
+	new_state->tls.proto = 0;
+#endif
 	new_state->tls.ciphers = new_state->ciphers;
 
 	ao2_ref(new_state, +1);
@@ -548,21 +553,35 @@ static int transport_apply(const struct
 			}
 		}
 
-		if (res == PJ_SUCCESS && (transport->tos || transport->cos)) {
-			pj_sock_t sock;
-			pj_qos_params qos_params;
-			sock = pjsip_udp_transport_get_socket(temp_state->state->transport);
-			pj_sock_get_qos_params(sock, &qos_params);
-			set_qos(transport, &qos_params);
-			pj_sock_set_qos_params(sock, &qos_params);
+		if (res == PJ_SUCCESS) {
+			temp_state->state->transport->info = pj_pool_alloc(temp_state->state->transport->pool,
+				(AST_SIP_X_AST_TXP_LEN + strlen(transport_id) + 2));
+
+			sprintf(temp_state->state->transport->info, "%s:%s", AST_SIP_X_AST_TXP, transport_id);
+
+			if (transport->tos || transport->cos) {
+				pj_sock_t sock;
+				pj_qos_params qos_params;
+				sock = pjsip_udp_transport_get_socket(temp_state->state->transport);
+				pj_sock_get_qos_params(sock, &qos_params);
+				set_qos(transport, &qos_params);
+				pj_sock_set_qos_params(sock, &qos_params);
+			}
 		}
 	} else if (transport->type == AST_TRANSPORT_TCP) {
 		pjsip_tcp_transport_cfg cfg;
+		static int option = 1;
 
 		pjsip_tcp_transport_cfg_default(&cfg, temp_state->state->host.addr.sa_family);
 		cfg.bind_addr = temp_state->state->host;
 		cfg.async_cnt = transport->async_operations;
 		set_qos(transport, &cfg.qos_params);
+		/* sockopt_params.options is copied to each newly connected socket */
+		cfg.sockopt_params.options[0].level = pj_SOL_TCP();
+		cfg.sockopt_params.options[0].optname = pj_TCP_NODELAY();
+		cfg.sockopt_params.options[0].optval = &option;
+		cfg.sockopt_params.options[0].optlen = sizeof(option);
+		cfg.sockopt_params.cnt = 1;
 
 		for (i = 0; i < BIND_TRIES && res != PJ_SUCCESS; i++) {
 			if (perm_state && perm_state->state && perm_state->state->factory
@@ -1279,22 +1298,22 @@ static struct ast_sip_cli_formatter_entr
 
 struct ast_sip_transport_state *ast_sip_get_transport_state(const char *transport_id)
 {
-	struct internal_state * state = NULL;
+	struct internal_state *state = NULL;
+	struct ast_sip_transport_state *trans_state;
 
 	if (!transport_states) {
 		return NULL;
 	}
 
 	state = ao2_find(transport_states, transport_id, OBJ_SEARCH_KEY);
-	if (!state || !state->state) {
-		ao2_cleanup(state);
+	if (!state) {
 		return NULL;
 	}
 
-	ao2_ref(state->state, +1);
+	trans_state = ao2_bump(state->state);
 	ao2_ref(state, -1);
 
-	return state->state;
+	return trans_state;
 }
 
 static int populate_transport_states(void *obj, void *arg, int flags)
@@ -1329,7 +1348,7 @@ int ast_sip_initialize_sorcery_transport
 	transport_states = ao2_container_alloc(DEFAULT_STATE_BUCKETS, internal_state_hash, internal_state_cmp);
 	if (!transport_states) {
 		ast_log(LOG_ERROR, "Unable to allocate transport states container\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return -1;
 	}
 
 	ast_sorcery_apply_default(sorcery, "transport", "config", "pjsip.conf,criteria=type=transport");
@@ -1364,6 +1383,7 @@ int ast_sip_initialize_sorcery_transport
 	ast_sorcery_object_field_register(sorcery, "transport", "cos", "0", OPT_UINT_T, 0, FLDSET(struct ast_sip_transport, cos));
 	ast_sorcery_object_field_register(sorcery, "transport", "websocket_write_timeout", AST_DEFAULT_WEBSOCKET_WRITE_TIMEOUT_STR, OPT_INT_T, PARSE_IN_RANGE, FLDSET(struct ast_sip_transport, write_timeout), 1, INT_MAX);
 	ast_sorcery_object_field_register(sorcery, "transport", "allow_reload", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_transport, allow_reload));
+	ast_sorcery_object_field_register(sorcery, "transport", "symmetric_transport", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_transport, symmetric_transport));
 
 	internal_sip_register_endpoint_formatter(&endpoint_transport_formatter);
 
diff -urpN asterisk-13.9.1/res/res_pjsip/include/res_pjsip_private.h asterisk-13.17.0/res/res_pjsip/include/res_pjsip_private.h
--- asterisk-13.9.1/res/res_pjsip/include/res_pjsip_private.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/include/res_pjsip_private.h	2017-07-12 13:12:08.000000000 +0200
@@ -184,6 +184,14 @@ void ast_sip_destroy_global_headers(void
 int ast_res_pjsip_init_options_handling(int reload);
 
 /*!
+ * \internal Initialize message IP updating handling.
+ *
+ * \retval 0 on success
+ * \retval other on failure
+ */
+int ast_res_pjsip_init_message_ip_updater(void);
+
+/*!
  * \internal
  * \brief Initialize transport storage for contacts.
  *
@@ -248,6 +256,12 @@ void ast_res_pjsip_cleanup_options_handl
 
 /*!
  * \internal
+ * \brief Clean up res_pjsip message ip updating handling
+ */
+void ast_res_pjsip_cleanup_message_ip_updater(void);
+
+/*!
+ * \internal
  * \brief Get threadpool options
  */
 void sip_get_threadpool_options(struct ast_threadpool_options *threadpool_options);
@@ -325,4 +339,23 @@ struct ast_sip_contact_status *ast_res_p
  */
 int ast_sip_validate_uri_length(const char *uri);
 
+/*!
+ * \brief Initialize scheduler
+ * \since 13.9.0
+ *
+ * \retval -1 failure
+ * \retval 0 success
+ */
+int ast_sip_initialize_scheduler(void);
+
+/*!
+ * \internal
+ * \brief Destroy scheduler
+ * \since 13.9.0
+ *
+ * \retval -1 failure
+ * \retval 0 success
+ */
+int ast_sip_destroy_scheduler(void);
+
 #endif /* RES_PJSIP_PRIVATE_H_ */
diff -urpN asterisk-13.9.1/res/res_pjsip/location.c asterisk-13.17.0/res/res_pjsip/location.c
--- asterisk-13.9.1/res/res_pjsip/location.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/location.c	2017-07-12 13:12:08.000000000 +0200
@@ -23,7 +23,9 @@
 #include "asterisk/res_pjsip.h"
 #include "asterisk/logger.h"
 #include "asterisk/astobj2.h"
+#include "asterisk/paths.h"
 #include "asterisk/sorcery.h"
+#include "asterisk/taskprocessor.h"
 #include "include/res_pjsip_private.h"
 #include "asterisk/res_pjsip_cli.h"
 #include "asterisk/statsd.h"
@@ -120,6 +122,11 @@ static void *contact_alloc(const char *n
 		return NULL;
 	}
 
+	ast_string_field_init_extended(contact, endpoint_name);
+	ast_string_field_init_extended(contact, reg_server);
+	ast_string_field_init_extended(contact, via_addr);
+	ast_string_field_init_extended(contact, call_id);
+
 	/* Dynamic contacts are delimited with ";@" and static ones with "@@" */
 	if ((aor_separator = strstr(id, ";@")) || (aor_separator = strstr(id, "@@"))) {
 		*aor_separator = '\0';
@@ -164,23 +171,52 @@ static int contact_link_static(void *obj
 	return 0;
 }
 
-struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact(const struct ast_sip_aor *aor)
+/*! \brief Internal callback function which removes any contact which is unreachable */
+static int contact_remove_unreachable(void *obj, void *arg, int flags)
 {
-	RAII_VAR(struct ao2_container *, contacts, NULL, ao2_cleanup);
-	struct ast_sip_contact *contact;
+	struct ast_sip_contact *contact = obj;
+	struct ast_sip_contact_status *status;
+	int unreachable;
 
-	contacts = ast_sip_location_retrieve_aor_contacts(aor);
-	if (!contacts || (ao2_container_count(contacts) == 0)) {
-		return NULL;
+	status = ast_res_pjsip_find_or_create_contact_status(contact);
+	if (!status) {
+		return 0;
 	}
 
-	/* Get the first AOR contact in the container. */
-	contact = ao2_callback(contacts, 0, NULL, NULL);
+	unreachable = (status->status == UNAVAILABLE);
+	ao2_ref(status, -1);
+
+	return unreachable ? CMP_MATCH : 0;
+}
+
+struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact(const struct ast_sip_aor *aor)
+{
+	return ast_sip_location_retrieve_first_aor_contact_filtered(aor, AST_SIP_CONTACT_FILTER_DEFAULT);
+}
+
+struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact_filtered(const struct ast_sip_aor *aor,
+	unsigned int flags)
+{
+	struct ao2_container *contacts;
+	struct ast_sip_contact *contact = NULL;
+
+	contacts = ast_sip_location_retrieve_aor_contacts_filtered(aor, flags);
+	if (contacts && ao2_container_count(contacts)) {
+		/* Get the first AOR contact in the container. */
+		contact = ao2_callback(contacts, 0, NULL, NULL);
+	}
+	ao2_cleanup(contacts);
 	return contact;
 }
 
 struct ao2_container *ast_sip_location_retrieve_aor_contacts_nolock(const struct ast_sip_aor *aor)
 {
+	return ast_sip_location_retrieve_aor_contacts_nolock_filtered(aor, AST_SIP_CONTACT_FILTER_DEFAULT);
+}
+
+struct ao2_container *ast_sip_location_retrieve_aor_contacts_nolock_filtered(const struct ast_sip_aor *aor,
+	unsigned int flags)
+{
 	/* Give enough space for ^ at the beginning and ;@ at the end, since that is our object naming scheme */
 	char regex[strlen(ast_sorcery_object_get_id(aor)) + 4];
 	struct ao2_container *contacts;
@@ -199,30 +235,47 @@ struct ao2_container *ast_sip_location_r
 		ao2_callback(aor->permanent_contacts, OBJ_NODATA, contact_link_static, contacts);
 	}
 
+	if (flags & AST_SIP_CONTACT_FILTER_REACHABLE) {
+		ao2_callback(contacts, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK, contact_remove_unreachable, NULL);
+	}
+
 	return contacts;
 }
 
 struct ao2_container *ast_sip_location_retrieve_aor_contacts(const struct ast_sip_aor *aor)
 {
+	return ast_sip_location_retrieve_aor_contacts_filtered(aor, AST_SIP_CONTACT_FILTER_DEFAULT);
+}
+
+struct ao2_container *ast_sip_location_retrieve_aor_contacts_filtered(const struct ast_sip_aor *aor,
+	unsigned int flags)
+{
 	struct ao2_container *contacts;
 	struct ast_named_lock *lock;
 
-	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_RWLOCK, "aor", ast_sorcery_object_get_id(aor));
+	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_MUTEX, "aor", ast_sorcery_object_get_id(aor));
 	if (!lock) {
 		return NULL;
 	}
 
-	ao2_wrlock(lock);
-	contacts = ast_sip_location_retrieve_aor_contacts_nolock(aor);
+	ao2_lock(lock);
+	contacts = ast_sip_location_retrieve_aor_contacts_nolock_filtered(aor, flags);
 	ao2_unlock(lock);
 	ast_named_lock_put(lock);
 
 	return contacts;
 }
 
+
 void ast_sip_location_retrieve_contact_and_aor_from_list(const char *aor_list, struct ast_sip_aor **aor,
 	struct ast_sip_contact **contact)
 {
+	ast_sip_location_retrieve_contact_and_aor_from_list_filtered(aor_list, AST_SIP_CONTACT_FILTER_DEFAULT, aor, contact);
+}
+
+void ast_sip_location_retrieve_contact_and_aor_from_list_filtered(const char *aor_list, unsigned int flags,
+	struct ast_sip_aor **aor, struct ast_sip_contact **contact)
+{
 	char *aor_name;
 	char *rest;
 
@@ -241,7 +294,7 @@ void ast_sip_location_retrieve_contact_a
 		if (!(*aor)) {
 			continue;
 		}
-		*contact = ast_sip_location_retrieve_first_aor_contact(*aor);
+		*contact = ast_sip_location_retrieve_first_aor_contact_filtered(*aor, flags);
 		/* If a valid contact is available use its URI for dialing */
 		if (*contact) {
 			break;
@@ -305,16 +358,19 @@ struct ast_sip_contact *ast_sip_location
 
 int ast_sip_location_add_contact_nolock(struct ast_sip_aor *aor, const char *uri,
 		struct timeval expiration_time, const char *path_info, const char *user_agent,
+		const char *via_addr, int via_port, const char *call_id,
 		struct ast_sip_endpoint *endpoint)
 {
+	struct ast_sip_contact *contact;
+	int res;
 	char name[MAX_OBJECT_FIELD * 2 + 3];
-	RAII_VAR(struct ast_sip_contact *, contact, NULL, ao2_cleanup);
 	char hash[33];
 
 	ast_md5_hash(hash, uri);
 	snprintf(name, sizeof(name), "%s;@%s", ast_sorcery_object_get_id(aor), hash);
 
-	if (!(contact = ast_sorcery_alloc(ast_sip_get_sorcery(), "contact", name))) {
+	contact = ast_sorcery_alloc(ast_sip_get_sorcery(), "contact", name);
+	if (!contact) {
 		return -1;
 	}
 
@@ -335,25 +391,46 @@ int ast_sip_location_add_contact_nolock(
 		ast_string_field_set(contact, user_agent, user_agent);
 	}
 
+	if (!ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {
+		ast_string_field_set(contact, reg_server, ast_config_AST_SYSTEM_NAME);
+	}
+
+	if (!ast_strlen_zero(via_addr)) {
+		ast_string_field_set(contact, via_addr, via_addr);
+	}
+	contact->via_port = via_port;
+
+	if (!ast_strlen_zero(call_id)) {
+		ast_string_field_set(contact, call_id, call_id);
+	}
+
 	contact->endpoint = ao2_bump(endpoint);
 
-	return ast_sorcery_create(ast_sip_get_sorcery(), contact);
+	if (endpoint) {
+		ast_string_field_set(contact, endpoint_name, ast_sorcery_object_get_id(endpoint));
+	}
+
+	res = ast_sorcery_create(ast_sip_get_sorcery(), contact);
+	ao2_ref(contact, -1);
+	return res;
 }
 
 int ast_sip_location_add_contact(struct ast_sip_aor *aor, const char *uri,
 		struct timeval expiration_time, const char *path_info, const char *user_agent,
+		const char *via_addr, int via_port, const char *call_id,
 		struct ast_sip_endpoint *endpoint)
 {
 	int res;
 	struct ast_named_lock *lock;
 
-	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_RWLOCK, "aor", ast_sorcery_object_get_id(aor));
+	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_MUTEX, "aor", ast_sorcery_object_get_id(aor));
 	if (!lock) {
 		return -1;
 	}
 
-	ao2_wrlock(lock);
+	ao2_lock(lock);
 	res = ast_sip_location_add_contact_nolock(aor, uri, expiration_time, path_info, user_agent,
+		via_addr, via_port, call_id,
 		endpoint);
 	ao2_unlock(lock);
 	ast_named_lock_put(lock);
@@ -576,7 +653,9 @@ static int voicemail_extension_to_str(co
 
 int ast_sip_for_each_aor(const char *aors, ao2_callback_fn on_aor, void *arg)
 {
-	char *copy, *name;
+	char *copy;
+	char *name;
+	int res;
 
 	if (!on_aor || ast_strlen_zero(aors)) {
 		return 0;
@@ -584,15 +663,15 @@ int ast_sip_for_each_aor(const char *aor
 
 	copy = ast_strdupa(aors);
 	while ((name = ast_strip(strsep(&copy, ",")))) {
-		RAII_VAR(struct ast_sip_aor *, aor,
-			 ast_sip_location_retrieve_aor(name), ao2_cleanup);
-
-		if (!aor) {
-			continue;
-		}
+		struct ast_sip_aor *aor;
 
-		if (on_aor(aor, arg, 0)) {
-			return -1;
+		aor = ast_sip_location_retrieve_aor(name);
+		if (aor) {
+			res = on_aor(aor, arg, 0);
+			ao2_ref(aor, -1);
+			if (res) {
+				return -1;
+			}
 		}
 	}
 	return 0;
@@ -601,15 +680,16 @@ int ast_sip_for_each_aor(const char *aor
 static void contact_wrapper_destroy(void *obj)
 {
 	struct ast_sip_contact_wrapper *wrapper = obj;
+
 	ast_free(wrapper->aor_id);
 	ast_free(wrapper->contact_id);
-	ao2_ref(wrapper->contact, -1);
+	ao2_cleanup(wrapper->contact);
 }
 
 int ast_sip_for_each_contact(const struct ast_sip_aor *aor,
 		ao2_callback_fn on_contact, void *arg)
 {
-	RAII_VAR(struct ao2_container *, contacts, NULL, ao2_cleanup);
+	struct ao2_container *contacts;
 	struct ao2_iterator i;
 	int res = 0;
 	void *object = NULL;
@@ -625,7 +705,8 @@ int ast_sip_for_each_contact(const struc
 		RAII_VAR(struct ast_sip_contact_wrapper *, wrapper, NULL, ao2_cleanup);
 		const char *aor_id = ast_sorcery_object_get_id(aor);
 
-		wrapper = ao2_alloc(sizeof(struct ast_sip_contact_wrapper), contact_wrapper_destroy);
+		wrapper = ao2_alloc_options(sizeof(struct ast_sip_contact_wrapper),
+			contact_wrapper_destroy, AO2_ALLOC_OPT_LOCK_NOLOCK);
 		if (!wrapper) {
 			res = -1;
 			break;
@@ -649,6 +730,7 @@ int ast_sip_for_each_contact(const struc
 		}
 	}
 	ao2_iterator_destroy(&i);
+	ao2_ref(contacts, -1);
 	return res;
 }
 
@@ -664,10 +746,11 @@ int ast_sip_contact_to_str(void *object,
 
 static int sip_aor_to_ami(const struct ast_sip_aor *aor, struct ast_str **buf)
 {
-	RAII_VAR(struct ast_variable *, objset, ast_sorcery_objectset_create2(
-			 ast_sip_get_sorcery(), aor, AST_HANDLER_ONLY_STRING), ast_variables_destroy);
+	struct ast_variable *objset;
 	struct ast_variable *i;
 
+	objset = ast_sorcery_objectset_create2(ast_sip_get_sorcery(), aor,
+		AST_HANDLER_ONLY_STRING);
 	if (!objset) {
 		return -1;
 	}
@@ -679,6 +762,7 @@ static int sip_aor_to_ami(const struct a
 
 	for (i = objset; i; i = i->next) {
 		char *camel = ast_to_camel_case(i->name);
+
 		if (strcmp(camel, "Contact") == 0) {
 			ast_free(camel);
 			camel = NULL;
@@ -687,23 +771,28 @@ static int sip_aor_to_ami(const struct a
 		ast_free(camel);
 	}
 
+	ast_variables_destroy(objset);
 	return 0;
 }
 
 static int contacts_to_str(const void *obj, const intptr_t *args, char **buf)
 {
 	const struct ast_sip_aor *aor = obj;
-	RAII_VAR(struct ast_str *, str, ast_str_create(MAX_OBJECT_FIELD), ast_free);
+	struct ast_str *str;
+
+	str = ast_str_create(MAX_OBJECT_FIELD);
+	if (!str) {
+		*buf = NULL;
+		return -1;
+	}
 
 	ast_sip_for_each_contact(aor, ast_sip_contact_to_str, &str);
 	ast_str_truncate(str, -1);
 
 	*buf = ast_strdup(ast_str_buffer(str));
-	if (!*buf) {
-		return -1;
-	}
+	ast_free(str);
 
-	return 0;
+	return *buf ? 0 : -1;
 }
 
 static int format_ami_aor_handler(void *obj, void *arg, int flags)
@@ -711,17 +800,20 @@ static int format_ami_aor_handler(void *
 	struct ast_sip_aor *aor = obj;
 	struct ast_sip_ami *ami = arg;
 	const struct ast_sip_endpoint *endpoint = ami->arg;
-	RAII_VAR(struct ast_str *, buf,
-		 ast_sip_create_ami_event("AorDetail", ami), ast_free);
-
+	struct ast_str *buf;
+	struct ao2_container *contacts;
 	int total_contacts;
 	int num_permanent;
-	RAII_VAR(struct ao2_container *, contacts,
-		 ast_sip_location_retrieve_aor_contacts(aor), ao2_cleanup);
 
+	buf = ast_sip_create_ami_event("AorDetail", ami);
 	if (!buf) {
 		return -1;
 	}
+	contacts = ast_sip_location_retrieve_aor_contacts(aor);
+	if (!contacts) {
+		ast_free(buf);
+		return -1;
+	}
 
 	sip_aor_to_ami(aor, &buf);
 	total_contacts = ao2_container_count(contacts);
@@ -737,6 +829,8 @@ static int format_ami_aor_handler(void *
 	astman_append(ami->s, "%s\r\n", ast_str_buffer(buf));
 	ami->count++;
 
+	ast_free(buf);
+	ao2_ref(contacts, -1);
 	return 0;
 }
 
@@ -754,7 +848,7 @@ struct ast_sip_endpoint_formatter endpoi
 
 static struct ao2_container *cli_aor_get_container(const char *regex)
 {
-	RAII_VAR(struct ao2_container *, container, NULL, ao2_cleanup);
+	struct ao2_container *container;
 	struct ao2_container *s_container;
 
 	container = ast_sorcery_retrieve_by_regex(ast_sip_get_sorcery(), "aor", regex);
@@ -762,16 +856,15 @@ static struct ao2_container *cli_aor_get
 		return NULL;
 	}
 
+	/* Create a sorted container of aors. */
 	s_container = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_NOLOCK, 0,
 		ast_sorcery_object_id_sort, ast_sorcery_object_id_compare);
-	if (!s_container) {
-		return NULL;
-	}
-
-	if (ao2_container_dup(s_container, container, 0)) {
+	if (s_container
+		&& ao2_container_dup(s_container, container, 0)) {
 		ao2_ref(s_container, -1);
-		return NULL;
+		s_container = NULL;
 	}
+	ao2_ref(container, -1);
 
 	return s_container;
 }
@@ -873,7 +966,7 @@ static struct ao2_container *cli_contact
 	struct ao2_container *child_container;
 	regex_t regexbuf;
 
-	parent_container =  cli_aor_get_container("");
+	parent_container = cli_aor_get_container("");
 	if (!parent_container) {
 		return NULL;
 	}
@@ -900,9 +993,17 @@ static struct ao2_container *cli_contact
 
 static void *cli_contact_retrieve_by_id(const char *id)
 {
-	RAII_VAR(struct ao2_container *, container, cli_contact_get_container(""), ao2_cleanup);
+	struct ao2_container *container;
+	void *obj;
+
+	container = cli_contact_get_container("");
+	if (!container) {
+		return NULL;
+	}
 
-	return ao2_find(container, id, OBJ_KEY | OBJ_NOLOCK);
+	obj = ao2_find(container, id, OBJ_SEARCH_KEY);
+	ao2_ref(container, -1);
+	return obj;
 }
 
 static int cli_contact_print_header(void *obj, void *arg, int flags)
@@ -929,14 +1030,13 @@ static int cli_contact_print_body(void *
 	int flexwidth;
 	const char *contact_id = ast_sorcery_object_get_id(contact);
 	const char *hash_start = contact_id + strlen(contact->aor) + 2;
-
-	RAII_VAR(struct ast_sip_contact_status *, status,
-		ast_sorcery_retrieve_by_id( ast_sip_get_sorcery(), CONTACT_STATUS, contact_id),
-		ao2_cleanup);
+	struct ast_sip_contact_status *status;
 
 	ast_assert(contact->uri != NULL);
 	ast_assert(context->output_buffer != NULL);
 
+	status = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), CONTACT_STATUS, contact_id);
+
 	indent = CLI_INDENT_TO_SPACES(context->indent_level);
 	flexwidth = CLI_LAST_TABSTOP - indent - 9 - strlen(contact->aor) + 1;
 
@@ -950,6 +1050,7 @@ static int cli_contact_print_body(void *
 		ast_sip_get_contact_short_status_label(status ? status->status : UNKNOWN),
 		(status && (status->status != UNKNOWN) ? ((long long) status->rtt) / 1000.0 : NAN));
 
+	ao2_cleanup(status);
 	return 0;
 }
 
@@ -973,8 +1074,6 @@ static const char *cli_aor_get_id(const
 static int cli_aor_print_header(void *obj, void *arg, int flags)
 {
 	struct ast_sip_cli_context *context = arg;
-	RAII_VAR(struct ast_sip_cli_formatter_entry *, formatter_entry, NULL, ao2_cleanup);
-
 	int indent = CLI_INDENT_TO_SPACES(context->indent_level);
 	int filler = CLI_LAST_TABSTOP - indent - 7;
 
@@ -985,10 +1084,13 @@ static int cli_aor_print_header(void *ob
 		indent, "Aor", filler, filler, CLI_HEADER_FILLER);
 
 	if (context->recurse) {
+		struct ast_sip_cli_formatter_entry *formatter_entry;
+
 		context->indent_level++;
 		formatter_entry = ast_sip_lookup_cli_formatter("contact");
 		if (formatter_entry) {
 			formatter_entry->print_header(NULL, context, 0);
+			ao2_ref(formatter_entry, -1);
 		}
 		context->indent_level--;
 	}
@@ -1000,7 +1102,6 @@ static int cli_aor_print_body(void *obj,
 {
 	struct ast_sip_aor *aor = obj;
 	struct ast_sip_cli_context *context = arg;
-	RAII_VAR(struct ast_sip_cli_formatter_entry *, formatter_entry, NULL, ao2_cleanup);
 	int indent;
 	int flexwidth;
 
@@ -1018,11 +1119,14 @@ static int cli_aor_print_body(void *obj,
 		ast_sorcery_object_get_id(aor), aor->max_contacts);
 
 	if (context->recurse) {
+		struct ast_sip_cli_formatter_entry *formatter_entry;
+
 		context->indent_level++;
 
 		formatter_entry = ast_sip_lookup_cli_formatter("contact");
 		if (formatter_entry) {
 			formatter_entry->iterate(aor, formatter_entry->print_body, context);
+			ao2_ref(formatter_entry, -1);
 		}
 
 		context->indent_level--;
@@ -1098,6 +1202,8 @@ int ast_sip_initialize_sorcery_location(
 	ast_pjproject_get_buildopt("PJSIP_MAX_URL_SIZE", "%d", &pjsip_max_url_size);
 
 	ast_sorcery_apply_default(sorcery, "contact", "astdb", "registrar");
+	ast_sorcery_object_set_congestion_levels(sorcery, "contact", -1,
+		3 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);
 	ast_sorcery_apply_default(sorcery, "aor", "config", "pjsip.conf,criteria=type=aor");
 
 	if (ast_sorcery_object_register(sorcery, "contact", contact_alloc, NULL, contact_apply_handler) ||
@@ -1114,8 +1220,14 @@ int ast_sip_initialize_sorcery_location(
 	ast_sorcery_object_field_register(sorcery, "contact", "qualify_frequency", 0, OPT_UINT_T,
 		PARSE_IN_RANGE, FLDSET(struct ast_sip_contact, qualify_frequency), 0, 86400);
 	ast_sorcery_object_field_register(sorcery, "contact", "qualify_timeout", "3.0", OPT_DOUBLE_T, 0, FLDSET(struct ast_sip_contact, qualify_timeout));
+	ast_sorcery_object_field_register(sorcery, "contact", "authenticate_qualify", "no", OPT_YESNO_T, 1, FLDSET(struct ast_sip_contact, authenticate_qualify));
 	ast_sorcery_object_field_register(sorcery, "contact", "outbound_proxy", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_contact, outbound_proxy));
 	ast_sorcery_object_field_register(sorcery, "contact", "user_agent", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_contact, user_agent));
+	ast_sorcery_object_field_register(sorcery, "contact", "endpoint", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_contact, endpoint_name));
+	ast_sorcery_object_field_register(sorcery, "contact", "reg_server", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_contact, reg_server));
+	ast_sorcery_object_field_register(sorcery, "contact", "via_addr", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_contact, via_addr));
+	ast_sorcery_object_field_register(sorcery, "contact", "via_port", "0", OPT_UINT_T, 0, FLDSET(struct ast_sip_contact, via_port));
+	ast_sorcery_object_field_register(sorcery, "contact", "call_id", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_contact, call_id));
 
 	ast_sorcery_object_field_register(sorcery, "aor", "type", "", OPT_NOOP_T, 0, 0);
 	ast_sorcery_object_field_register(sorcery, "aor", "minimum_expiration", "60", OPT_UINT_T, 0, FLDSET(struct ast_sip_aor, minimum_expiration));
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_cli.c asterisk-13.17.0/res/res_pjsip/pjsip_cli.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_cli.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/pjsip_cli.c	2017-07-12 13:12:08.000000000 +0200
@@ -221,6 +221,8 @@ char *ast_sip_cli_traverse_objects(struc
 			return CLI_SUCCESS;
 		}
 		ao2_callback(container, OBJ_NODATA, formatter_entry->print_body, &context);
+		ast_str_append(&context.output_buffer, 0, "\nObjects found: %d\n", ao2_container_count(container));
+
 	} else {
 		if (ast_strlen_zero(object_id)) {
 			ast_free(context.output_buffer);
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_configuration.c asterisk-13.17.0/res/res_pjsip/pjsip_configuration.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_configuration.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/pjsip_configuration.c	2017-07-12 13:12:08.000000000 +0200
@@ -58,64 +58,15 @@ static int persistent_endpoint_cmp(void
 	return !strcmp(ast_endpoint_get_resource(persistent1->endpoint), id) ? CMP_MATCH | CMP_STOP : 0;
 }
 
-/*! \brief Callback function for changing the state of an endpoint */
-static int persistent_endpoint_update_state(void *obj, void *arg, int flags)
+/*! \brief Internal function for changing the state of an endpoint */
+static void endpoint_update_state(struct ast_endpoint *endpoint, enum ast_endpoint_state state)
 {
-	struct sip_persistent_endpoint *persistent = obj;
-	struct ast_endpoint *endpoint = persistent->endpoint;
-	struct ast_sip_contact_status *status = arg;
-	struct ao2_container *contacts;
 	struct ast_json *blob;
-	struct ao2_iterator i;
-	struct ast_sip_contact *contact;
-	enum ast_endpoint_state state = AST_ENDPOINT_OFFLINE;
 	char *regcontext;
 
-	if (status) {
-		char rtt[32];
-
-		/* If the status' aor isn't one of the endpoint's, we skip */
-		if (!strstr(persistent->aors, status->aor)) {
-			return 0;
-		}
-
-		snprintf(rtt, sizeof(rtt), "%" PRId64, status->rtt);
-		blob = ast_json_pack("{s: s, s: s, s: s, s: s, s: s}",
-			"contact_status", ast_sip_get_contact_status_label(status->status),
-			"aor", status->aor,
-			"uri", status->uri,
-			"roundtrip_usec", rtt,
-			"endpoint_name", ast_endpoint_get_resource(endpoint));
-		ast_endpoint_blob_publish(endpoint, ast_endpoint_contact_state_type(), blob);
-		ast_json_unref(blob);
-	}
-
-	/* Find all the contacts for this endpoint.  If ANY are available,
-	 * mark the endpoint as ONLINE.
-	 */
-	contacts = ast_sip_location_retrieve_contacts_from_aor_list(persistent->aors);
-	if (contacts) {
-		i = ao2_iterator_init(contacts, 0);
-		while (state == AST_ENDPOINT_OFFLINE && (contact = ao2_iterator_next(&i))) {
-			struct ast_sip_contact_status *contact_status;
-			const char *contact_id = ast_sorcery_object_get_id(contact);
-
-			contact_status = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(),
-				CONTACT_STATUS, contact_id);
-
-			if (contact_status && contact_status->status != UNAVAILABLE) {
-				state = AST_ENDPOINT_ONLINE;
-			}
-			ao2_cleanup(contact_status);
-			ao2_ref(contact, -1);
-		}
-		ao2_iterator_destroy(&i);
-		ao2_ref(contacts, -1);
-	}
-
 	/* If there was no state change, don't publish anything. */
 	if (ast_endpoint_get_state(endpoint) == state) {
-		return 0;
+		return;
 	}
 
 	regcontext = ast_sip_get_regcontext();
@@ -131,7 +82,7 @@ static int persistent_endpoint_update_st
 			}
 		}
 
-		ast_verb(1, "Endpoint %s is now Reachable\n", ast_endpoint_get_resource(endpoint));
+		ast_verb(2, "Endpoint %s is now Reachable\n", ast_endpoint_get_resource(endpoint));
 	} else {
 		ast_endpoint_set_state(endpoint, AST_ENDPOINT_OFFLINE);
 		blob = ast_json_pack("{s: s}", "peer_status", "Unreachable");
@@ -144,7 +95,7 @@ static int persistent_endpoint_update_st
 			}
 		}
 
-		ast_verb(1, "Endpoint %s is now Unreachable\n", ast_endpoint_get_resource(endpoint));
+		ast_verb(2, "Endpoint %s is now Unreachable\n", ast_endpoint_get_resource(endpoint));
 	}
 
 	ast_free(regcontext);
@@ -152,6 +103,83 @@ static int persistent_endpoint_update_st
 	ast_endpoint_blob_publish(endpoint, ast_endpoint_state_type(), blob);
 	ast_json_unref(blob);
 	ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "PJSIP/%s", ast_endpoint_get_resource(endpoint));
+}
+
+static void endpoint_publish_contact_status(struct ast_endpoint *endpoint, struct ast_sip_contact_status *contact)
+{
+	struct ast_json *blob;
+	char rtt[32];
+
+	snprintf(rtt, sizeof(rtt), "%" PRId64, contact->rtt);
+	blob = ast_json_pack("{s: s, s: s, s: s, s: s, s: s}",
+		"contact_status", ast_sip_get_contact_status_label(contact->status),
+		"aor", contact->aor,
+		"uri", contact->uri,
+		"roundtrip_usec", rtt,
+		"endpoint_name", ast_endpoint_get_resource(endpoint));
+	if (blob) {
+		ast_endpoint_blob_publish(endpoint, ast_endpoint_contact_state_type(), blob);
+		ast_json_unref(blob);
+	}
+}
+
+/*! \brief Callback function for publishing the status of an endpoint */
+static int persistent_endpoint_publish_status(void *obj, void *arg, int flags)
+{
+	struct sip_persistent_endpoint *persistent = obj;
+	struct ast_endpoint *endpoint = persistent->endpoint;
+	struct ast_sip_contact_status *status = arg;
+
+	/* If the status' aor isn't one of the endpoint's, we skip */
+	if (!strstr(persistent->aors, status->aor)) {
+		return 0;
+	}
+
+	endpoint_publish_contact_status(endpoint, status);
+	return 0;
+}
+
+/*! \brief Callback function for changing the state of an endpoint */
+static int persistent_endpoint_update_state(void *obj, void *arg, int flags)
+{
+	struct sip_persistent_endpoint *persistent = obj;
+	struct ast_endpoint *endpoint = persistent->endpoint;
+	struct ast_sip_contact_status *status = arg;
+	struct ao2_container *contacts;
+	struct ao2_iterator iter;
+	struct ast_sip_contact *contact;
+	enum ast_endpoint_state state = AST_ENDPOINT_OFFLINE;
+
+	/* If the status' aor isn't one of the endpoint's, we skip */
+	if (!strstr(persistent->aors, status->aor)) {
+		return 0;
+	}
+
+	endpoint_publish_contact_status(endpoint, status);
+
+	/* Find all the contacts for this endpoint.  If ANY are available,
+	 * mark the endpoint as ONLINE.
+	 */
+	contacts = ast_sip_location_retrieve_contacts_from_aor_list(persistent->aors);
+	if (contacts) {
+		iter = ao2_iterator_init(contacts, 0);
+		while (state == AST_ENDPOINT_OFFLINE && (contact = ao2_iterator_next(&iter))) {
+			struct ast_sip_contact_status *contact_status;
+			const char *contact_id = ast_sorcery_object_get_id(contact);
+
+			contact_status = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(),
+				CONTACT_STATUS, contact_id);
+			if (contact_status && contact_status->status != UNAVAILABLE) {
+				state = AST_ENDPOINT_ONLINE;
+			}
+			ao2_cleanup(contact_status);
+			ao2_ref(contact, -1);
+		}
+		ao2_iterator_destroy(&iter);
+		ao2_ref(contacts, -1);
+	}
+
+	endpoint_update_state(endpoint, state);
 
 	return 0;
 }
@@ -176,7 +204,7 @@ static void persistent_endpoint_contact_
 	}
 	contact_status->status = CREATED;
 
-	ast_verb(1, "Contact %s/%s has been created\n",contact->aor, contact->uri);
+	ast_verb(2, "Contact %s/%s has been created\n", contact->aor, contact->uri);
 
 	ao2_callback(persistent_endpoints, OBJ_NODATA, persistent_endpoint_update_state, contact_status);
 	ao2_cleanup(contact_status);
@@ -190,12 +218,12 @@ static void persistent_endpoint_contact_
 
 	contact_status = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), CONTACT_STATUS, ast_sorcery_object_get_id(contact));
 	if (!contact_status) {
-		ast_log(LOG_ERROR, "Unable to create ast_sip_contact_status for contact %s/%s\n",
+		ast_log(LOG_ERROR, "Unable to find ast_sip_contact_status for contact %s/%s\n",
 			contact->aor, contact->uri);
 		return;
 	}
 
-	ast_verb(1, "Contact %s/%s has been deleted\n", contact->aor, contact->uri);
+	ast_verb(2, "Contact %s/%s has been deleted\n", contact->aor, contact->uri);
 	ast_statsd_log_string_va("PJSIP.contacts.states.%s", AST_STATSD_GAUGE,
 		"-1", 1.0, ast_sip_get_contact_status_label(contact_status->status));
 	ast_statsd_log_string_va("PJSIP.contacts.states.%s", AST_STATSD_GAUGE,
@@ -217,13 +245,21 @@ static void persistent_endpoint_contact_
 {
 	struct ast_sip_contact_status *contact_status = (struct ast_sip_contact_status *)object;
 
+	if (contact_status->refresh) {
+		/* We are only re-publishing the contact status. */
+		ao2_callback(persistent_endpoints, OBJ_NODATA,
+			persistent_endpoint_publish_status, contact_status);
+		return;
+	}
+
 	/* If rtt_start is set (this is the outgoing OPTIONS), ignore. */
 	if (contact_status->rtt_start.tv_sec > 0) {
 		return;
 	}
 
 	if (contact_status->status != contact_status->last_status) {
-		ast_verb(1, "Contact %s/%s is now %s.  RTT: %.3f msec\n", contact_status->aor, contact_status->uri,
+		ast_verb(3, "Contact %s/%s is now %s.  RTT: %.3f msec\n",
+			contact_status->aor, contact_status->uri,
 			ast_sip_get_contact_status_label(contact_status->status),
 			contact_status->rtt / 1000.0);
 
@@ -234,19 +270,23 @@ static void persistent_endpoint_contact_
 
 		ast_test_suite_event_notify("AOR_CONTACT_UPDATE",
 			"Contact: %s\r\n"
-				"Status: %s",
+			"Status: %s",
 			ast_sorcery_object_get_id(contact_status),
 			ast_sip_get_contact_status_label(contact_status->status));
 
-		ao2_callback(persistent_endpoints, OBJ_NODATA, persistent_endpoint_update_state, contact_status);
+		ao2_callback(persistent_endpoints, OBJ_NODATA, persistent_endpoint_update_state,
+			contact_status);
 	} else {
 		ast_debug(3, "Contact %s/%s status didn't change: %s, RTT: %.3f msec\n",
-			contact_status->aor, contact_status->uri, ast_sip_get_contact_status_label(contact_status->status),
+			contact_status->aor, contact_status->uri,
+			ast_sip_get_contact_status_label(contact_status->status),
 			contact_status->rtt / 1000.0);
 	}
 
 	ast_statsd_log_full_va("PJSIP.contacts.%s.rtt", AST_STATSD_TIMER,
-		contact_status->status != AVAILABLE ? -1 : contact_status->rtt / 1000, 1.0, ast_sorcery_object_get_id(contact_status));
+		contact_status->status != AVAILABLE ? -1 : contact_status->rtt / 1000,
+		1.0,
+		ast_sorcery_object_get_id(contact_status));
 }
 
 /*! \brief Observer for contacts so state can be updated on respective endpoints */
@@ -258,13 +298,73 @@ static void endpoint_deleted_observer(co
 {
 	const struct ast_sip_endpoint *endpoint = object;
 
-	ao2_find(persistent_endpoints, ast_endpoint_get_resource(endpoint->persistent), OBJ_SEARCH_KEY | OBJ_UNLINK | OBJ_NODATA);
+	ao2_find(persistent_endpoints, ast_endpoint_get_resource(endpoint->persistent),
+		OBJ_SEARCH_KEY | OBJ_UNLINK | OBJ_NODATA);
 }
 
 static const struct ast_sorcery_observer endpoint_observers = {
 	.deleted = endpoint_deleted_observer,
 };
 
+static int endpoint_acl_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
+{
+	struct ast_sip_endpoint *endpoint = obj;
+	int error = 0;
+	int ignore;
+
+	if (ast_strlen_zero(var->value)) return 0;
+
+	if (!strncmp(var->name, "contact_", 8)) {
+		ast_append_acl(var->name + 8, var->value, &endpoint->contact_acl, &error, &ignore);
+	} else {
+		ast_append_acl(var->name, var->value, &endpoint->acl, &error, &ignore);
+	}
+
+	return error;
+}
+
+static int acl_to_str(const void *obj, const intptr_t *args, char **buf)
+{
+	const struct ast_sip_endpoint *endpoint = obj;
+	struct ast_acl_list *acl_list;
+	struct ast_acl *first_acl;
+
+	if (endpoint && !ast_acl_list_is_empty(acl_list=endpoint->acl)) {
+		AST_LIST_LOCK(acl_list);
+		first_acl = AST_LIST_FIRST(acl_list);
+		if (ast_strlen_zero(first_acl->name)) {
+			*buf = "deny/permit";
+		} else {
+			*buf = first_acl->name;
+		}
+		AST_LIST_UNLOCK(acl_list);
+	}
+
+	*buf = ast_strdup(*buf);
+	return 0;
+}
+
+static int contact_acl_to_str(const void *obj, const intptr_t *args, char **buf)
+{
+	const struct ast_sip_endpoint *endpoint = obj;
+	struct ast_acl_list *acl_list;
+	struct ast_acl *first_acl;
+
+	if (endpoint && !ast_acl_list_is_empty(acl_list=endpoint->contact_acl)) {
+		AST_LIST_LOCK(acl_list);
+		first_acl = AST_LIST_FIRST(acl_list);
+		if (ast_strlen_zero(first_acl->name)) {
+			*buf = "deny/permit";
+		} else {
+			*buf = first_acl->name;
+		}
+		AST_LIST_UNLOCK(acl_list);
+	}
+
+	*buf = ast_strdup(*buf);
+	return 0;
+}
+
 static int dtmf_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
 {
 	struct ast_sip_endpoint *endpoint = obj;
@@ -273,10 +373,12 @@ static int dtmf_handler(const struct aco
 		endpoint->dtmf = AST_SIP_DTMF_RFC_4733;
 	} else if (!strcasecmp(var->value, "inband")) {
 		endpoint->dtmf = AST_SIP_DTMF_INBAND;
+	} else if (!strcasecmp(var->value, "auto_info")) {
+		endpoint->dtmf = AST_SIP_DTMF_AUTO_INFO;
 	} else if (!strcasecmp(var->value, "info")) {
 		endpoint->dtmf = AST_SIP_DTMF_INFO;
-        } else if (!strcasecmp(var->value, "auto")) {
-                endpoint->dtmf = AST_SIP_DTMF_AUTO;
+	} else if (!strcasecmp(var->value, "auto")) {
+		endpoint->dtmf = AST_SIP_DTMF_AUTO;
 	} else if (!strcasecmp(var->value, "none")) {
 		endpoint->dtmf = AST_SIP_DTMF_NONE;
 	} else {
@@ -297,8 +399,11 @@ static int dtmf_to_str(const void *obj,
 		*buf = "inband"; break;
 	case AST_SIP_DTMF_INFO :
 		*buf = "info"; break;
-       case AST_SIP_DTMF_AUTO :
-                *buf = "auto"; break;
+	case AST_SIP_DTMF_AUTO :
+		*buf = "auto"; break;
+	case AST_SIP_DTMF_AUTO_INFO :
+		*buf = "auto_info";
+		break;
 	default:
 		*buf = "none";
 	}
@@ -479,6 +584,16 @@ static int ident_handler(const struct ac
 	struct ast_sip_endpoint *endpoint = obj;
 	char *idents = ast_strdupa(var->value);
 	char *val;
+	enum ast_sip_endpoint_identifier_type method;
+
+	/*
+	 * If there's already something in the vector when we get here,
+	 * it's the default value so we need to clean it out.
+	 */
+	if (AST_VECTOR_SIZE(&endpoint->ident_method_order)) {
+		AST_VECTOR_RESET(&endpoint->ident_method_order, AST_VECTOR_ELEM_CLEANUP_NOOP);
+		endpoint->ident_method = 0;
+	}
 
 	while ((val = ast_strip(strsep(&idents, ",")))) {
 		if (ast_strlen_zero(val)) {
@@ -486,27 +601,59 @@ static int ident_handler(const struct ac
 		}
 
 		if (!strcasecmp(val, "username")) {
-			endpoint->ident_method |= AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;
+			method = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;
+		} else	if (!strcasecmp(val, "auth_username")) {
+			method = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;
 		} else {
 			ast_log(LOG_ERROR, "Unrecognized identification method %s specified for endpoint %s\n",
 					val, ast_sorcery_object_get_id(endpoint));
+			AST_VECTOR_RESET(&endpoint->ident_method_order, AST_VECTOR_ELEM_CLEANUP_NOOP);
+			endpoint->ident_method = 0;
 			return -1;
 		}
+		if (endpoint->ident_method & method) {
+			/* We are already indentifying by this method.  No need to do it again. */
+			continue;
+		}
+
+		endpoint->ident_method |= method;
+		AST_VECTOR_APPEND(&endpoint->ident_method_order, method);
 	}
+
 	return 0;
 }
 
 static int ident_to_str(const void *obj, const intptr_t *args, char **buf)
 {
 	const struct ast_sip_endpoint *endpoint = obj;
-	switch (endpoint->ident_method) {
-	case AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME :
-		*buf = "username"; break;
-	default:
+	int methods;
+	char *method;
+	int i;
+	int j = 0;
+
+	methods = AST_VECTOR_SIZE(&endpoint->ident_method_order);
+	if (!methods) {
 		return 0;
 	}
 
-	*buf = ast_strdup(*buf);
+	if (!(*buf = ast_calloc(MAX_OBJECT_FIELD, sizeof(char)))) {
+		return -1;
+	}
+
+	for (i = 0; i < methods; i++) {
+		switch (AST_VECTOR_GET(&endpoint->ident_method_order, i)) {
+		case AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME :
+			method = "username";
+			break;
+		case AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME :
+			method = "auth_username";
+			break;
+		default:
+			continue;
+		}
+		j = sprintf(*buf + j, "%s%s", method, i < methods - 1 ? "," : "");
+	}
+
 	return 0;
 }
 
@@ -828,7 +975,9 @@ static int dtls_handler(const struct aco
 {
 	struct ast_sip_endpoint *endpoint = obj;
 	char *name = ast_strdupa(var->name);
-	char *front, *back, *buf = name;
+	char *front = NULL;
+	char *back = NULL;
+	char *buf = name;
 
 	/* strip out underscores in the name */
 	front = strtok_r(buf, "_", &back);
@@ -1073,6 +1222,31 @@ static int voicemail_extension_to_str(co
 	return 0;
 }
 
+static int contact_user_handler(const struct aco_option *opt,
+	struct ast_variable *var, void *obj)
+{
+	struct ast_sip_endpoint *endpoint = obj;
+
+	endpoint->contact_user = ast_strdup(var->value);
+	if (!endpoint->contact_user) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int contact_user_to_str(const void *obj, const intptr_t *args, char **buf)
+{
+	const struct ast_sip_endpoint *endpoint = obj;
+
+	*buf = ast_strdup(endpoint->contact_user);
+	if (!(*buf)) {
+		return -1;
+	}
+
+	return 0;
+}
+
 static void *sip_nat_hook_alloc(const char *name)
 {
 	return ast_sorcery_generic_alloc(sizeof(struct ast_sip_nat_hook), NULL);
@@ -1087,29 +1261,48 @@ static void persistent_endpoint_destroy(
 	ast_free(persistent->aors);
 }
 
+int ast_sip_persistent_endpoint_update_state(const char *endpoint_name, enum ast_endpoint_state state)
+{
+	struct sip_persistent_endpoint *persistent;
+
+	ao2_lock(persistent_endpoints);
+	persistent = ao2_find(persistent_endpoints, endpoint_name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (persistent) {
+		endpoint_update_state(persistent->endpoint, state);
+		ao2_ref(persistent, -1);
+	}
+	ao2_unlock(persistent_endpoints);
+	return persistent ? 0 : -1;
+}
+
 /*! \brief Internal function which finds (or creates) persistent endpoint information */
 static struct ast_endpoint *persistent_endpoint_find_or_create(const struct ast_sip_endpoint *endpoint)
 {
 	RAII_VAR(struct sip_persistent_endpoint *, persistent, NULL, ao2_cleanup);
 	SCOPED_AO2LOCK(lock, persistent_endpoints);
 
-	if (!(persistent = ao2_find(persistent_endpoints, ast_sorcery_object_get_id(endpoint), OBJ_KEY | OBJ_NOLOCK))) {
-		if (!(persistent = ao2_alloc(sizeof(*persistent), persistent_endpoint_destroy))) {
+	persistent = ao2_find(persistent_endpoints, ast_sorcery_object_get_id(endpoint),
+		OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (!persistent) {
+		persistent = ao2_alloc_options(sizeof(*persistent), persistent_endpoint_destroy,
+			AO2_ALLOC_OPT_LOCK_NOLOCK);
+		if (!persistent) {
 			return NULL;
 		}
 
-		if (!(persistent->endpoint = ast_endpoint_create("PJSIP", ast_sorcery_object_get_id(endpoint)))) {
+		persistent->endpoint = ast_endpoint_create("PJSIP",
+			ast_sorcery_object_get_id(endpoint));
+		if (!persistent->endpoint) {
 			return NULL;
 		}
 
 		persistent->aors = ast_strdup(endpoint->aors);
-
-		if (ast_strlen_zero(persistent->aors)) {
-			ast_endpoint_set_state(persistent->endpoint, AST_ENDPOINT_UNKNOWN);
-		} else {
-			persistent_endpoint_update_state(persistent, NULL, 0);
+		if (!persistent->aors) {
+			return NULL;
 		}
 
+		ast_endpoint_set_state(persistent->endpoint, AST_ENDPOINT_OFFLINE);
+
 		ao2_link_flags(persistent_endpoints, persistent, OBJ_NOLOCK);
 	}
 
@@ -1523,9 +1716,7 @@ static int cli_endpoint_print_body(void
 
 	if (number) {
 		print_name_len = strlen(id) + strlen(number) + 2;
-		if (!(print_name = alloca(print_name_len))) {
-			return -1;
-		}
+		print_name = ast_alloca(print_name_len);
 		snprintf(print_name, print_name_len, "%s/%s", id, number);
 	}
 
@@ -1589,6 +1780,22 @@ static struct ast_cli_entry cli_commands
 struct ast_sip_cli_formatter_entry *channel_formatter;
 struct ast_sip_cli_formatter_entry *endpoint_formatter;
 
+static int on_load_endpoint(void *obj, void *arg, int flags)
+{
+	return sip_endpoint_apply_handler(sip_sorcery, obj);
+}
+
+static void load_all_endpoints(void)
+{
+	struct ao2_container *endpoints;
+
+	endpoints = ast_sorcery_retrieve_by_fields(sip_sorcery, "endpoint", AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
+	if (endpoints) {
+		ao2_callback(endpoints, OBJ_NODATA, on_load_endpoint, NULL);
+		ao2_ref(endpoints, -1);
+	}
+}
+
 int ast_res_pjsip_initialize_configuration(const struct ast_module_info *ast_module_info)
 {
 	if (ast_manager_register_xml(AMI_SHOW_ENDPOINTS, EVENT_FLAG_SYSTEM, ami_show_endpoints) ||
@@ -1596,7 +1803,9 @@ int ast_res_pjsip_initialize_configurati
 		return -1;
 	}
 
-	if (!(persistent_endpoints = ao2_container_alloc(PERSISTENT_BUCKETS, persistent_endpoint_hash, persistent_endpoint_cmp))) {
+	persistent_endpoints = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0,
+		PERSISTENT_BUCKETS, persistent_endpoint_hash, NULL, persistent_endpoint_cmp);
+	if (!persistent_endpoints) {
 		return -1;
 	}
 
@@ -1688,6 +1897,7 @@ int ast_res_pjsip_initialize_configurati
 	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "t38_udptl_ec", "none", t38udptl_ec_handler, t38udptl_ec_to_str, NULL, 0, 0);
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "t38_udptl_maxdatagram", "0", OPT_UINT_T, 0, FLDSET(struct ast_sip_endpoint, media.t38.maxdatagram));
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "fax_detect", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, faxdetect));
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "fax_detect_timeout", "0", OPT_UINT_T, 0, FLDSET(struct ast_sip_endpoint, faxdetect_timeout));
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "t38_udptl_nat", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, media.t38.nat));
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "t38_udptl_ipv6", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, media.t38.ipv6));
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "tone_zone", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_endpoint, zone));
@@ -1724,6 +1934,19 @@ int ast_res_pjsip_initialize_configurati
 	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "set_var", "", set_var_handler, set_var_to_str, set_var_to_vl, 0, 0);
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "message_context", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_endpoint, message_context));
 	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "accountcode", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ast_sip_endpoint, accountcode));
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "deny", "", endpoint_acl_handler, NULL, NULL, 0, 0);
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "permit", "", endpoint_acl_handler, NULL, NULL, 0, 0);
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "acl", "", endpoint_acl_handler, acl_to_str, NULL, 0, 0);
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "contact_deny", "", endpoint_acl_handler, NULL, NULL, 0, 0);
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "contact_permit", "", endpoint_acl_handler, NULL, NULL, 0, 0);
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "contact_acl", "", endpoint_acl_handler, contact_acl_to_str, NULL, 0, 0);
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "subscribe_context", "", OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct ast_sip_endpoint, subscription.context));
+	ast_sorcery_object_field_register_custom(sip_sorcery, "endpoint", "contact_user", "", contact_user_handler, contact_user_to_str, NULL, 0, 0);
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "asymmetric_rtp_codec", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, asymmetric_rtp_codec));
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "rtcp_mux", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, rtcp_mux));
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "allow_overlap", "yes", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, allow_overlap));
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "refer_blind_progress", "yes", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, refer_blind_progress));
+	ast_sorcery_object_field_register(sip_sorcery, "endpoint", "notify_early_inuse_ringing", "no", OPT_BOOL_T, 1, FLDSET(struct ast_sip_endpoint, notify_early_inuse_ringing));
 
 	if (ast_sip_initialize_sorcery_transport()) {
 		ast_log(LOG_ERROR, "Failed to register SIP transport support with sorcery\n");
@@ -1784,6 +2007,8 @@ int ast_res_pjsip_initialize_configurati
 
 	ast_sorcery_load(sip_sorcery);
 
+	load_all_endpoints();
+
 	return 0;
 }
 
@@ -1807,6 +2032,7 @@ void ast_res_pjsip_destroy_configuration
 	ast_sip_unregister_cli_formatter(endpoint_formatter);
 	ast_sip_destroy_cli();
 	ao2_cleanup(persistent_endpoints);
+	persistent_endpoints = NULL;
 }
 
 int ast_res_pjsip_reload_configuration(void)
@@ -1851,6 +2077,10 @@ static void endpoint_destructor(void* ob
 	endpoint->pickup.named_pickupgroups = ast_unref_namedgroups(endpoint->pickup.named_pickupgroups);
 	ao2_cleanup(endpoint->persistent);
 	ast_variables_destroy(endpoint->channel_vars);
+	AST_VECTOR_FREE(&endpoint->ident_method_order);
+	ast_free(endpoint->contact_user);
+	ast_free_acl_list(endpoint->contact_acl);
+	ast_free_acl_list(endpoint->acl);
 }
 
 static int init_subscription_configuration(struct ast_sip_endpoint_subscription_configuration *subscription)
@@ -1895,6 +2125,11 @@ void *ast_sip_endpoint_alloc(const char
 		return NULL;
 	}
 	ast_party_id_init(&endpoint->id.self);
+
+	if (AST_VECTOR_INIT(&endpoint->ident_method_order, 1)) {
+		return NULL;
+	}
+
 	return endpoint;
 }
 
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_distributor.c asterisk-13.17.0/res/res_pjsip/pjsip_distributor.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_distributor.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/pjsip_distributor.c	2017-07-12 13:12:08.000000000 +0200
@@ -21,32 +21,49 @@
 #include <pjsip.h>
 
 #include "asterisk/res_pjsip.h"
+#include "asterisk/acl.h"
 #include "include/res_pjsip_private.h"
 #include "asterisk/taskprocessor.h"
 #include "asterisk/threadpool.h"
+#include "asterisk/res_pjsip_cli.h"
 
 static int distribute(void *data);
 static pj_bool_t distributor(pjsip_rx_data *rdata);
-static pj_status_t record_serializer(pjsip_tx_data *tdata);
 
 static pjsip_module distributor_mod = {
 	.name = {"Request Distributor", 19},
 	.priority = PJSIP_MOD_PRIORITY_TSX_LAYER - 6,
-	.on_tx_request = record_serializer,
+	.on_tx_request = ast_sip_record_request_serializer,
 	.on_rx_request = distributor,
 	.on_rx_response = distributor,
 };
 
-/*!
- * \internal
- * \brief Record the task's serializer name on the tdata structure.
- * \since 14.0.0
- *
- * \param tdata The outgoing message.
- *
- * \retval PJ_SUCCESS.
- */
-static pj_status_t record_serializer(pjsip_tx_data *tdata)
+struct ast_sched_context *prune_context;
+
+/* From the auth/realm realtime column size */
+#define MAX_REALM_LENGTH 40
+
+#define DEFAULT_SUSPECTS_BUCKETS 53
+
+static struct ao2_container *unidentified_requests;
+static unsigned int unidentified_count;
+static unsigned int unidentified_period;
+static unsigned int unidentified_prune_interval;
+static int using_auth_username;
+
+struct unidentified_request{
+	struct timeval first_seen;
+	int count;
+	char src_name[];
+};
+
+/*! Number of serializers in pool if one not otherwise known.  (Best if prime number) */
+#define DISTRIBUTOR_POOL_SIZE		31
+
+/*! Pool of serializers to use if not supplied. */
+static struct ast_taskprocessor *distributor_pool[DISTRIBUTOR_POOL_SIZE];
+
+pj_status_t ast_sip_record_request_serializer(pjsip_tx_data *tdata)
 {
 	struct ast_taskprocessor *serializer;
 
@@ -92,12 +109,12 @@ static struct ast_taskprocessor *find_re
 
 	tsx = pjsip_tsx_layer_find_tsx(&tsx_key, PJ_TRUE);
 	if (!tsx) {
-		ast_debug(1, "Could not find %.*s transaction for %d response.\n",
-			(int) pj_strlen(&rdata->msg_info.cseq->method.name),
-			pj_strbuf(&rdata->msg_info.cseq->method.name),
-			rdata->msg_info.msg->line.status.code);
+		ast_debug(1, "Could not find transaction for %s.\n",
+			pjsip_rx_data_get_info(rdata));
 		return NULL;
 	}
+	ast_debug(3, "Found transaction %s for %s.\n",
+		tsx->obj_name, pjsip_rx_data_get_info(rdata));
 
 	if (tsx->last_tx) {
 		const char *serializer_name;
@@ -123,62 +140,189 @@ static struct ast_taskprocessor *find_re
 
 /*! Dialog-specific information the distributor uses */
 struct distributor_dialog_data {
+	/*! dialog_associations ao2 container key */
+	pjsip_dialog *dlg;
 	/*! Serializer to distribute tasks to for this dialog */
 	struct ast_taskprocessor *serializer;
 	/*! Endpoint associated with this dialog */
 	struct ast_sip_endpoint *endpoint;
 };
 
+#define DIALOG_ASSOCIATIONS_BUCKETS 251
+
+static struct ao2_container *dialog_associations;
+
 /*!
  * \internal
+ * \brief Compute a hash value on an arbitrary buffer.
+ * \since 13.17.0
+ *
+ * \param[in] pos The buffer to add to the hash
+ * \param[in] len The buffer length to add to the hash
+ * \param[in] hash The hash value to add to
+ *
+ * \details
+ * This version of the function is for when you need to compute a
+ * hash of more than one buffer.
  *
- * \note Call this with the dialog locked
+ * This famous hash algorithm was written by Dan Bernstein and is
+ * commonly used.
+ *
+ * \sa http://www.cse.yorku.ca/~oz/hash.html
  */
-static struct distributor_dialog_data *distributor_dialog_data_alloc(pjsip_dialog *dlg)
+static int buf_hash_add(const char *pos, size_t len, int hash)
 {
-	struct distributor_dialog_data *dist;
+	while (len--) {
+		hash = hash * 33 ^ *pos++;
+	}
 
-	dist = PJ_POOL_ZALLOC_T(dlg->pool, struct distributor_dialog_data);
-	pjsip_dlg_set_mod_data(dlg, distributor_mod.id, dist);
+	return hash;
+}
 
-	return dist;
+/*!
+ * \internal
+ * \brief Compute a hash value on an arbitrary buffer.
+ * \since 13.17.0
+ *
+ * \param[in] pos The buffer to add to the hash
+ * \param[in] len The buffer length to add to the hash
+ *
+ * \details
+ * This version of the function is for when you need to compute a
+ * hash of more than one buffer.
+ *
+ * This famous hash algorithm was written by Dan Bernstein and is
+ * commonly used.
+ *
+ * \sa http://www.cse.yorku.ca/~oz/hash.html
+ */
+static int buf_hash(const char *pos, size_t len)
+{
+	return buf_hash_add(pos, len, 5381);
+}
+
+static int dialog_associations_hash(const void *obj, int flags)
+{
+	const struct distributor_dialog_data *object;
+	union {
+		const pjsip_dialog *dlg;
+		const char buf[sizeof(pjsip_dialog *)];
+	} key;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_KEY:
+		key.dlg = obj;
+		break;
+	case OBJ_SEARCH_OBJECT:
+		object = obj;
+		key.dlg = object->dlg;
+		break;
+	default:
+		/* Hash can only work on something with a full key. */
+		ast_assert(0);
+		return 0;
+	}
+	return ast_str_hash_restrict(buf_hash(key.buf, sizeof(key.buf)));
+}
+
+static int dialog_associations_cmp(void *obj, void *arg, int flags)
+{
+	const struct distributor_dialog_data *object_left = obj;
+	const struct distributor_dialog_data *object_right = arg;
+	const pjsip_dialog *right_key = arg;
+	int cmp = 0;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_OBJECT:
+		right_key = object_right->dlg;
+		/* Fall through */
+	case OBJ_SEARCH_KEY:
+		if (object_left->dlg == right_key) {
+			cmp = CMP_MATCH;
+		}
+		break;
+	case OBJ_SEARCH_PARTIAL_KEY:
+		/* There is no such thing for this container. */
+		ast_assert(0);
+		break;
+	default:
+		cmp = 0;
+		break;
+	}
+	return cmp;
 }
 
 void ast_sip_dialog_set_serializer(pjsip_dialog *dlg, struct ast_taskprocessor *serializer)
 {
 	struct distributor_dialog_data *dist;
-	SCOPED_LOCK(lock, dlg, pjsip_dlg_inc_lock, pjsip_dlg_dec_lock);
 
-	dist = pjsip_dlg_get_mod_data(dlg, distributor_mod.id);
+	ao2_wrlock(dialog_associations);
+	dist = ao2_find(dialog_associations, dlg, OBJ_SEARCH_KEY | OBJ_NOLOCK);
 	if (!dist) {
-		dist = distributor_dialog_data_alloc(dlg);
+		if (serializer) {
+			dist = ao2_alloc(sizeof(*dist), NULL);
+			if (dist) {
+				dist->dlg = dlg;
+				dist->serializer = serializer;
+				ao2_link_flags(dialog_associations, dist, OBJ_NOLOCK);
+				ao2_ref(dist, -1);
+			}
+		}
+	} else {
+		ao2_lock(dist);
+		dist->serializer = serializer;
+		if (!dist->serializer && !dist->endpoint) {
+			ao2_unlink_flags(dialog_associations, dist, OBJ_NOLOCK);
+		}
+		ao2_unlock(dist);
+		ao2_ref(dist, -1);
 	}
-	dist->serializer = serializer;
+	ao2_unlock(dialog_associations);
 }
 
 void ast_sip_dialog_set_endpoint(pjsip_dialog *dlg, struct ast_sip_endpoint *endpoint)
 {
 	struct distributor_dialog_data *dist;
-	SCOPED_LOCK(lock, dlg, pjsip_dlg_inc_lock, pjsip_dlg_dec_lock);
 
-	dist = pjsip_dlg_get_mod_data(dlg, distributor_mod.id);
+	ao2_wrlock(dialog_associations);
+	dist = ao2_find(dialog_associations, dlg, OBJ_SEARCH_KEY | OBJ_NOLOCK);
 	if (!dist) {
-		dist = distributor_dialog_data_alloc(dlg);
+		if (endpoint) {
+			dist = ao2_alloc(sizeof(*dist), NULL);
+			if (dist) {
+				dist->dlg = dlg;
+				dist->endpoint = endpoint;
+				ao2_link_flags(dialog_associations, dist, OBJ_NOLOCK);
+				ao2_ref(dist, -1);
+			}
+		}
+	} else {
+		ao2_lock(dist);
+		dist->endpoint = endpoint;
+		if (!dist->serializer && !dist->endpoint) {
+			ao2_unlink_flags(dialog_associations, dist, OBJ_NOLOCK);
+		}
+		ao2_unlock(dist);
+		ao2_ref(dist, -1);
 	}
-	dist->endpoint = endpoint;
+	ao2_unlock(dialog_associations);
 }
 
 struct ast_sip_endpoint *ast_sip_dialog_get_endpoint(pjsip_dialog *dlg)
 {
 	struct distributor_dialog_data *dist;
-	SCOPED_LOCK(lock, dlg, pjsip_dlg_inc_lock, pjsip_dlg_dec_lock);
+	struct ast_sip_endpoint *endpoint;
 
-	dist = pjsip_dlg_get_mod_data(dlg, distributor_mod.id);
-	if (!dist || !dist->endpoint) {
-		return NULL;
+	dist = ao2_find(dialog_associations, dlg, OBJ_SEARCH_KEY);
+	if (dist) {
+		ao2_lock(dist);
+		endpoint = ao2_bump(dist->endpoint);
+		ao2_unlock(dist);
+		ao2_ref(dist, -1);
+	} else {
+		endpoint = NULL;
 	}
-	ao2_ref(dist->endpoint, +1);
-	return dist->endpoint;
+	return endpoint;
 }
 
 static pjsip_dialog *find_dialog(pjsip_rx_data *rdata)
@@ -209,20 +353,34 @@ static pjsip_dialog *find_dialog(pjsip_r
 	if (rdata->msg_info.msg->type == PJSIP_RESPONSE_MSG ||
 			pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_cancel_method) ||
 			rdata->msg_info.to->tag.slen != 0) {
-		return pjsip_ua_find_dialog(&rdata->msg_info.cid->id, local_tag,
-				remote_tag, PJ_TRUE);
+		dlg = pjsip_ua_find_dialog(&rdata->msg_info.cid->id, local_tag,
+				remote_tag, PJ_FALSE);
+		if (dlg) {
+			return dlg;
+		}
 	}
 
-	/* Incoming CANCEL without a to-tag can't use same method for finding the
-	 * dialog. Instead, we have to find the matching INVITE transaction and
-	 * then get the dialog from the transaction
+	/*
+	 * There may still be a matching dialog if this is
+	 * 1) an incoming CANCEL request without a to-tag
+	 * 2) an incoming response to a dialog-creating request.
 	 */
-	pjsip_tsx_create_key(rdata->tp_info.pool, &tsx_key, PJSIP_ROLE_UAS,
-			pjsip_get_invite_method(), rdata);
+	if (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG) {
+		/* CANCEL requests will need to match the INVITE we initially received. Any
+		 * other request type will either have been matched already or is not in
+		 * dialog
+		 */
+		pjsip_tsx_create_key(rdata->tp_info.pool, &tsx_key, PJSIP_ROLE_UAS,
+				pjsip_get_invite_method(), rdata);
+	} else {
+		pjsip_tsx_create_key(rdata->tp_info.pool, &tsx_key, PJSIP_ROLE_UAC,
+				&rdata->msg_info.cseq->method, rdata);
+	}
 
 	tsx = pjsip_tsx_layer_find_tsx(&tsx_key, PJ_TRUE);
 	if (!tsx) {
-		ast_log(LOG_ERROR, "Could not find matching INVITE transaction for CANCEL request\n");
+		ast_debug(3, "Could not find matching transaction for %s\n",
+			pjsip_rx_data_get_info(rdata));
 		return NULL;
 	}
 
@@ -234,12 +392,75 @@ static pjsip_dialog *find_dialog(pjsip_r
 	pj_mutex_unlock(tsx->mutex);
 #endif
 
-	if (!dlg) {
+	return dlg;
+}
+
+/*!
+ * \internal
+ * \brief Compute a hash value on a pjlib string
+ * \since 13.10.0
+ *
+ * \param[in] str The pjlib string to add to the hash
+ * \param[in] hash The hash value to add to
+ *
+ * \details
+ * This version of the function is for when you need to compute a
+ * string hash of more than one string.
+ *
+ * This famous hash algorithm was written by Dan Bernstein and is
+ * commonly used.
+ *
+ * \sa http://www.cse.yorku.ca/~oz/hash.html
+ */
+static int pjstr_hash_add(pj_str_t *str, int hash)
+{
+	return buf_hash_add(pj_strbuf(str), pj_strlen(str), hash);
+}
+
+/*!
+ * \internal
+ * \brief Compute a hash value on a pjlib string
+ * \since 13.10.0
+ *
+ * \param[in] str The pjlib string to hash
+ *
+ * This famous hash algorithm was written by Dan Bernstein and is
+ * commonly used.
+ *
+ * http://www.cse.yorku.ca/~oz/hash.html
+ */
+static int pjstr_hash(pj_str_t *str)
+{
+	return pjstr_hash_add(str, 5381);
+}
+
+struct ast_taskprocessor *ast_sip_get_distributor_serializer(pjsip_rx_data *rdata)
+{
+	int hash;
+	pj_str_t *remote_tag;
+	struct ast_taskprocessor *serializer;
+
+	if (!rdata->msg_info.msg) {
 		return NULL;
 	}
 
-	pjsip_dlg_inc_lock(dlg);
-	return dlg;
+	if (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG) {
+		remote_tag = &rdata->msg_info.from->tag;
+	} else {
+		remote_tag = &rdata->msg_info.to->tag;
+	}
+
+	/* Compute the hash from the SIP message call-id and remote-tag */
+	hash = pjstr_hash(&rdata->msg_info.cid->id);
+	hash = pjstr_hash_add(remote_tag, hash);
+	hash = ast_str_hash_restrict(hash);
+
+	serializer = ao2_bump(distributor_pool[hash % ARRAY_LEN(distributor_pool)]);
+	if (serializer) {
+		ast_debug(3, "Calculated serializer %s to use for %s\n",
+			ast_taskprocessor_name(serializer), pjsip_rx_data_get_info(rdata));
+	}
+	return serializer;
 }
 
 static pj_bool_t endpoint_lookup(pjsip_rx_data *rdata);
@@ -250,61 +471,95 @@ static pjsip_module endpoint_mod = {
 	.on_rx_request = endpoint_lookup,
 };
 
-#define SIP_MAX_QUEUE (AST_TASKPROCESSOR_HIGH_WATER_LEVEL * 3)
-
 static pj_bool_t distributor(pjsip_rx_data *rdata)
 {
-	pjsip_dialog *dlg = find_dialog(rdata);
+	pjsip_dialog *dlg;
 	struct distributor_dialog_data *dist = NULL;
 	struct ast_taskprocessor *serializer = NULL;
 	pjsip_rx_data *clone;
 
+	if (!ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {
+		/*
+		 * Ignore everything until we are fully booted.  Let the
+		 * peer retransmit messages until we are ready.
+		 */
+		return PJ_TRUE;
+	}
+
+	dlg = find_dialog(rdata);
 	if (dlg) {
-		ast_debug(3, "Searching for serializer on dialog %s for %s\n",
-				dlg->obj_name, rdata->msg_info.info);
-		dist = pjsip_dlg_get_mod_data(dlg, distributor_mod.id);
+		ast_debug(3, "Searching for serializer associated with dialog %s for %s\n",
+			dlg->obj_name, pjsip_rx_data_get_info(rdata));
+		dist = ao2_find(dialog_associations, dlg, OBJ_SEARCH_KEY);
 		if (dist) {
+			ao2_lock(dist);
 			serializer = ao2_bump(dist->serializer);
+			ao2_unlock(dist);
 			if (serializer) {
-				ast_debug(3, "Found serializer %s on dialog %s\n",
-						ast_taskprocessor_name(serializer), dlg->obj_name);
+				ast_debug(3, "Found serializer %s associated with dialog %s\n",
+					ast_taskprocessor_name(serializer), dlg->obj_name);
 			}
 		}
-		pjsip_dlg_dec_lock(dlg);
 	}
 
 	if (serializer) {
 		/* We have a serializer so we know where to send the message. */
 	} else if (rdata->msg_info.msg->type == PJSIP_RESPONSE_MSG) {
-		ast_debug(3, "No dialog serializer for response %s. Using request transaction as basis\n",
-				rdata->msg_info.info);
+		ast_debug(3, "No dialog serializer for %s.  Using request transaction as basis.\n",
+			pjsip_rx_data_get_info(rdata));
 		serializer = find_request_serializer(rdata);
+		if (!serializer) {
+			/*
+			 * Pick a serializer for the unmatched response.
+			 * We couldn't determine what serializer originally
+			 * sent the request or the serializer is gone.
+			 */
+			serializer = ast_sip_get_distributor_serializer(rdata);
+		}
 	} else if (!pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_cancel_method)
 		|| !pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_bye_method)) {
 		/* We have a BYE or CANCEL request without a serializer. */
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata,
 			PJSIP_SC_CALL_TSX_DOES_NOT_EXIST, NULL, NULL, NULL);
+		ao2_cleanup(dist);
 		return PJ_TRUE;
+	} else {
+		if (ast_taskprocessor_alert_get()) {
+			/*
+			 * When taskprocessors get backed up, there is a good chance that
+			 * we are being overloaded and need to defer adding new work to
+			 * the system.  To defer the work we will ignore the request and
+			 * rely on the peer's transport layer to retransmit the message.
+			 * We usually work off the overload within a few seconds.  The
+			 * alternative is to send back a 503 response to these requests
+			 * and be done with it.
+			 */
+			ast_debug(3, "Taskprocessor overload alert: Ignoring '%s'.\n",
+				pjsip_rx_data_get_info(rdata));
+			ao2_cleanup(dist);
+			return PJ_TRUE;
+		}
+
+		/* Pick a serializer for the out-of-dialog request. */
+		serializer = ast_sip_get_distributor_serializer(rdata);
 	}
 
-	pjsip_rx_data_clone(rdata, 0, &clone);
+	if (pjsip_rx_data_clone(rdata, 0, &clone) != PJ_SUCCESS) {
+		ast_taskprocessor_unreference(serializer);
+		ao2_cleanup(dist);
+		return PJ_TRUE;
+	}
 
 	if (dist) {
+		ao2_lock(dist);
 		clone->endpt_info.mod_data[endpoint_mod.id] = ao2_bump(dist->endpoint);
+		ao2_unlock(dist);
+		ao2_cleanup(dist);
 	}
 
-	if (ast_sip_threadpool_queue_size() > SIP_MAX_QUEUE) {
-		/* When the threadpool is backed up this much, there is a good chance that we have encountered
-		 * some sort of terrible condition and don't need to be adding more work to the threadpool.
-		 * It's in our best interest to send back a 503 response and be done with it.
-		 */
-		if (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG) {
-			pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 503, NULL, NULL, NULL);
-		}
+	if (ast_sip_push_task(serializer, distribute, clone)) {
 		ao2_cleanup(clone->endpt_info.mod_data[endpoint_mod.id]);
 		pjsip_rx_data_free_cloned(clone);
-	} else {
-		ast_sip_push_task(serializer, distribute, clone);
 	}
 
 	ast_taskprocessor_unreference(serializer);
@@ -312,35 +567,54 @@ static pj_bool_t distributor(pjsip_rx_da
 	return PJ_TRUE;
 }
 
-static struct ast_sip_auth *artificial_auth;
+static struct ast_sip_auth *alloc_artificial_auth(char *default_realm)
+{
+	struct ast_sip_auth *fake_auth;
+
+	fake_auth = ast_sorcery_alloc(ast_sip_get_sorcery(), SIP_SORCERY_AUTH_TYPE,
+		"artificial");
+	if (!fake_auth) {
+		return NULL;
+	}
+
+	ast_string_field_set(fake_auth, realm, default_realm);
+	ast_string_field_set(fake_auth, auth_user, "");
+	ast_string_field_set(fake_auth, auth_pass, "");
+	fake_auth->type = AST_SIP_AUTH_TYPE_ARTIFICIAL;
+
+	return fake_auth;
+}
+
+static AO2_GLOBAL_OBJ_STATIC(artificial_auth);
 
 static int create_artificial_auth(void)
 {
-	if (!(artificial_auth = ast_sorcery_alloc(
-		      ast_sip_get_sorcery(), SIP_SORCERY_AUTH_TYPE, "artificial"))) {
+	char default_realm[MAX_REALM_LENGTH + 1];
+	struct ast_sip_auth *fake_auth;
+
+	ast_sip_get_default_realm(default_realm, sizeof(default_realm));
+	fake_auth = alloc_artificial_auth(default_realm);
+	if (!fake_auth) {
 		ast_log(LOG_ERROR, "Unable to create artificial auth\n");
 		return -1;
 	}
 
-	ast_string_field_set(artificial_auth, realm, "asterisk");
-	ast_string_field_set(artificial_auth, auth_user, "");
-	ast_string_field_set(artificial_auth, auth_pass, "");
-	artificial_auth->type = AST_SIP_AUTH_TYPE_ARTIFICIAL;
+	ao2_global_obj_replace_unref(artificial_auth, fake_auth);
+	ao2_ref(fake_auth, -1);
 	return 0;
 }
 
 struct ast_sip_auth *ast_sip_get_artificial_auth(void)
 {
-	ao2_ref(artificial_auth, +1);
-	return artificial_auth;
+	return ao2_global_obj_ref(artificial_auth);
 }
 
 static struct ast_sip_endpoint *artificial_endpoint = NULL;
 
 static int create_artificial_endpoint(void)
 {
-	if (!(artificial_endpoint = ast_sorcery_alloc(
-		      ast_sip_get_sorcery(), "endpoint", NULL))) {
+	artificial_endpoint = ast_sorcery_alloc(ast_sip_get_sorcery(), "endpoint", NULL);
+	if (!artificial_endpoint) {
 		return -1;
 	}
 
@@ -359,31 +633,69 @@ struct ast_sip_endpoint *ast_sip_get_art
 	return artificial_endpoint;
 }
 
-static void log_unidentified_request(pjsip_rx_data *rdata)
+static void log_failed_request(pjsip_rx_data *rdata, char *msg, unsigned int count, unsigned int period)
 {
 	char from_buf[PJSIP_MAX_URL_SIZE];
 	char callid_buf[PJSIP_MAX_URL_SIZE];
+	char method_buf[PJSIP_MAX_URL_SIZE];
 	pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR, rdata->msg_info.from->uri, from_buf, PJSIP_MAX_URL_SIZE);
 	ast_copy_pj_str(callid_buf, &rdata->msg_info.cid->id, PJSIP_MAX_URL_SIZE);
-	ast_log(LOG_NOTICE, "Request from '%s' failed for '%s:%d' (callid: %s) - No matching endpoint found\n",
-		from_buf, rdata->pkt_info.src_name, rdata->pkt_info.src_port, callid_buf);
+	ast_copy_pj_str(method_buf, &rdata->msg_info.msg->line.req.method.name, PJSIP_MAX_URL_SIZE);
+	if (count) {
+		ast_log(LOG_NOTICE, "Request '%s' from '%s' failed for '%s:%d' (callid: %s) - %s"
+			" after %u tries in %.3f ms\n",
+			method_buf, from_buf, rdata->pkt_info.src_name, rdata->pkt_info.src_port, callid_buf, msg, count, period / 1000.0);
+	} else {
+		ast_log(LOG_NOTICE, "Request '%s' from '%s' failed for '%s:%d' (callid: %s) - %s\n",
+			method_buf, from_buf, rdata->pkt_info.src_name, rdata->pkt_info.src_port, callid_buf, msg);
+	}
+}
+
+static void check_endpoint(pjsip_rx_data *rdata, struct unidentified_request *unid,
+	const char *name)
+{
+	int64_t ms = ast_tvdiff_ms(ast_tvnow(), unid->first_seen);
+
+	ao2_wrlock(unid);
+	unid->count++;
+
+	if (ms < (unidentified_period * 1000) && unid->count >= unidentified_count) {
+		log_failed_request(rdata, "No matching endpoint found", unid->count, ms);
+		ast_sip_report_invalid_endpoint(name, rdata);
+	}
+	ao2_unlock(unid);
 }
 
 static pj_bool_t endpoint_lookup(pjsip_rx_data *rdata)
 {
 	struct ast_sip_endpoint *endpoint;
+	struct unidentified_request *unid;
 	int is_ack = rdata->msg_info.msg->line.req.method.id == PJSIP_ACK_METHOD;
 
 	endpoint = rdata->endpt_info.mod_data[endpoint_mod.id];
 	if (endpoint) {
+		/*
+		 * ao2_find with OBJ_UNLINK always write locks the container before even searching
+		 * for the object.  Since the majority case is that the object won't be found, do
+		 * the find without OBJ_UNLINK to prevent the unnecessary write lock, then unlink
+		 * if needed.
+		 */
+		if ((unid = ao2_find(unidentified_requests, rdata->pkt_info.src_name, OBJ_SEARCH_KEY))) {
+			ao2_unlink(unidentified_requests, unid);
+			ao2_ref(unid, -1);
+		}
 		return PJ_FALSE;
 	}
 
 	endpoint = ast_sip_identify_endpoint(rdata);
+	if (endpoint) {
+		if ((unid = ao2_find(unidentified_requests, rdata->pkt_info.src_name, OBJ_SEARCH_KEY))) {
+			ao2_unlink(unidentified_requests, unid);
+			ao2_ref(unid, -1);
+		}
+	}
 
-	if (!endpoint && !is_ack) {
-		char name[AST_UUID_STR_LEN] = "";
-		pjsip_uri *from = rdata->msg_info.from->uri;
+	if (!endpoint) {
 
 		/* always use an artificial endpoint - per discussion no reason
 		   to have "alwaysauthreject" as an option.  It is felt using it
@@ -391,19 +703,122 @@ static pj_bool_t endpoint_lookup(pjsip_r
 		   breaking old stuff and we really don't want to enable the discovery
 		   of SIP accounts */
 		endpoint = ast_sip_get_artificial_endpoint();
+	}
+
+	rdata->endpt_info.mod_data[endpoint_mod.id] = endpoint;
+
+	if ((endpoint == artificial_endpoint) && !is_ack) {
+		char name[AST_UUID_STR_LEN] = "";
+		pjsip_uri *from = rdata->msg_info.from->uri;
 
 		if (PJSIP_URI_SCHEME_IS_SIP(from) || PJSIP_URI_SCHEME_IS_SIPS(from)) {
 			pjsip_sip_uri *sip_from = pjsip_uri_get_uri(from);
 			ast_copy_pj_str(name, &sip_from->user, sizeof(name));
 		}
 
-		log_unidentified_request(rdata);
-		ast_sip_report_invalid_endpoint(name, rdata);
+		if ((unid = ao2_find(unidentified_requests, rdata->pkt_info.src_name, OBJ_SEARCH_KEY))) {
+			check_endpoint(rdata, unid, name);
+			ao2_ref(unid, -1);
+		} else if (using_auth_username) {
+			ao2_wrlock(unidentified_requests);
+			/* The check again with the write lock held allows us to eliminate the DUPS_REPLACE and sort_fn */
+			if ((unid = ao2_find(unidentified_requests, rdata->pkt_info.src_name, OBJ_SEARCH_KEY | OBJ_NOLOCK))) {
+				check_endpoint(rdata, unid, name);
+			} else {
+				unid = ao2_alloc_options(sizeof(*unid) + strlen(rdata->pkt_info.src_name) + 1, NULL,
+					AO2_ALLOC_OPT_LOCK_RWLOCK);
+				if (!unid) {
+					ao2_unlock(unidentified_requests);
+					return PJ_TRUE;
+				}
+				strcpy(unid->src_name, rdata->pkt_info.src_name); /* Safe */
+				unid->first_seen = ast_tvnow();
+				unid->count = 1;
+				ao2_link_flags(unidentified_requests, unid, OBJ_NOLOCK);
+			}
+			ao2_ref(unid, -1);
+			ao2_unlock(unidentified_requests);
+		} else {
+			log_failed_request(rdata, "No matching endpoint found", 0, 0);
+			ast_sip_report_invalid_endpoint(name, rdata);
+		}
 	}
-	rdata->endpt_info.mod_data[endpoint_mod.id] = endpoint;
 	return PJ_FALSE;
 }
 
+static int apply_endpoint_acl(pjsip_rx_data *rdata, struct ast_sip_endpoint *endpoint)
+{
+	struct ast_sockaddr addr;
+
+	if (ast_acl_list_is_empty(endpoint->acl)) {
+		return 0;
+	}
+
+	memset(&addr, 0, sizeof(addr));
+	ast_sockaddr_parse(&addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);
+	ast_sockaddr_set_port(&addr, rdata->pkt_info.src_port);
+
+	if (ast_apply_acl(endpoint->acl, &addr, "SIP ACL: ") != AST_SENSE_ALLOW) {
+		log_failed_request(rdata, "Not match Endpoint ACL", 0, 0);
+		ast_sip_report_failed_acl(endpoint, rdata, "not_match_endpoint_acl");
+		return 1;
+	}
+	return 0;
+}
+
+static int extract_contact_addr(pjsip_contact_hdr *contact, struct ast_sockaddr **addrs)
+{
+	pjsip_sip_uri *sip_uri;
+	char host[256];
+
+	if (!contact || contact->star) {
+		*addrs = NULL;
+		return 0;
+	}
+	if (!PJSIP_URI_SCHEME_IS_SIP(contact->uri) && !PJSIP_URI_SCHEME_IS_SIPS(contact->uri)) {
+		*addrs = NULL;
+		return 0;
+	}
+	sip_uri = pjsip_uri_get_uri(contact->uri);
+	ast_copy_pj_str(host, &sip_uri->host, sizeof(host));
+	return ast_sockaddr_resolve(addrs, host, PARSE_PORT_FORBID, AST_AF_UNSPEC);
+}
+
+static int apply_endpoint_contact_acl(pjsip_rx_data *rdata, struct ast_sip_endpoint *endpoint)
+{
+	int num_contact_addrs;
+	int forbidden = 0;
+	struct ast_sockaddr *contact_addrs;
+	int i;
+	pjsip_contact_hdr *contact = (pjsip_contact_hdr *)&rdata->msg_info.msg->hdr;
+
+	if (ast_acl_list_is_empty(endpoint->contact_acl)) {
+		return 0;
+	}
+
+	while ((contact = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, contact->next))) {
+		num_contact_addrs = extract_contact_addr(contact, &contact_addrs);
+		if (num_contact_addrs <= 0) {
+			continue;
+		}
+		for (i = 0; i < num_contact_addrs; ++i) {
+			if (ast_apply_acl(endpoint->contact_acl, &contact_addrs[i], "SIP Contact ACL: ") != AST_SENSE_ALLOW) {
+				log_failed_request(rdata, "Not match Endpoint Contact ACL", 0, 0);
+				ast_sip_report_failed_acl(endpoint, rdata, "not_match_endpoint_contact_acl");
+				forbidden = 1;
+				break;
+			}
+		}
+		ast_free(contact_addrs);
+		if (forbidden) {
+			/* No use checking other contacts if we already have failed ACL check */
+			break;
+		}
+	}
+
+	return forbidden;
+}
+
 static pj_bool_t authenticate(pjsip_rx_data *rdata)
 {
 	RAII_VAR(struct ast_sip_endpoint *, endpoint, ast_pjsip_rdata_get_endpoint(rdata), ao2_cleanup);
@@ -411,8 +826,19 @@ static pj_bool_t authenticate(pjsip_rx_d
 
 	ast_assert(endpoint != NULL);
 
+	if (endpoint!=artificial_endpoint) {
+		if (apply_endpoint_acl(rdata, endpoint) || apply_endpoint_contact_acl(rdata, endpoint)) {
+			if (!is_ack) {
+				pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
+			}
+			return PJ_TRUE;
+		}
+	}
+
 	if (!is_ack && ast_sip_requires_authentication(endpoint, rdata)) {
 		pjsip_tx_data *tdata;
+		struct unidentified_request *unid;
+
 		pjsip_endpt_create_response(ast_sip_get_pjsip_endpoint(), rdata, 401, NULL, &tdata);
 		switch (ast_sip_check_authentication(endpoint, rdata, tdata)) {
 		case AST_SIP_AUTHENTICATION_CHALLENGE:
@@ -421,19 +847,26 @@ static pj_bool_t authenticate(pjsip_rx_d
 			pjsip_endpt_send_response2(ast_sip_get_pjsip_endpoint(), rdata, tdata, NULL, NULL);
 			return PJ_TRUE;
 		case AST_SIP_AUTHENTICATION_SUCCESS:
+			/* See note in endpoint_lookup about not holding an unnecessary write lock */
+			if ((unid = ao2_find(unidentified_requests, rdata->pkt_info.src_name, OBJ_SEARCH_KEY))) {
+				ao2_unlink(unidentified_requests, unid);
+				ao2_ref(unid, -1);
+			}
 			ast_sip_report_auth_success(endpoint, rdata);
-			pjsip_tx_data_dec_ref(tdata);
-			return PJ_FALSE;
+			break;
 		case AST_SIP_AUTHENTICATION_FAILED:
+			log_failed_request(rdata, "Failed to authenticate", 0, 0);
 			ast_sip_report_auth_failed_challenge_response(endpoint, rdata);
 			pjsip_endpt_send_response2(ast_sip_get_pjsip_endpoint(), rdata, tdata, NULL, NULL);
 			return PJ_TRUE;
 		case AST_SIP_AUTHENTICATION_ERROR:
+			log_failed_request(rdata, "Error to authenticate", 0, 0);
 			ast_sip_report_auth_failed_challenge_response(endpoint, rdata);
 			pjsip_tx_data_dec_ref(tdata);
 			pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);
 			return PJ_TRUE;
 		}
+		pjsip_tx_data_dec_ref(tdata);
 	}
 
 	return PJ_FALSE;
@@ -451,7 +884,7 @@ static int distribute(void *data)
 		.start_mod = &distributor_mod,
 		.idx_after_start = 1,
 	};
-	pj_bool_t handled;
+	pj_bool_t handled = PJ_FALSE;
 	pjsip_rx_data *rdata = data;
 	int is_request = rdata->msg_info.msg->type == PJSIP_REQUEST_MSG;
 	int is_ack = is_request ? rdata->msg_info.msg->line.req.method.id == PJSIP_ACK_METHOD : 0;
@@ -480,31 +913,380 @@ struct ast_sip_endpoint *ast_pjsip_rdata
 	return endpoint;
 }
 
+static int suspects_sort(const void *obj, const void *arg, int flags)
+{
+	const struct unidentified_request *object_left = obj;
+	const struct unidentified_request *object_right = arg;
+	const char *right_key = arg;
+	int cmp;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_OBJECT:
+		right_key = object_right->src_name;
+		/* Fall through */
+	case OBJ_SEARCH_KEY:
+		cmp = strcmp(object_left->src_name, right_key);
+		break;
+	case OBJ_SEARCH_PARTIAL_KEY:
+		cmp = strncmp(object_left->src_name, right_key, strlen(right_key));
+		break;
+	default:
+		cmp = 0;
+		break;
+	}
+	return cmp;
+}
+
+static int suspects_compare(void *obj, void *arg, int flags)
+{
+	const struct unidentified_request *object_left = obj;
+	const struct unidentified_request *object_right = arg;
+	const char *right_key = arg;
+	int cmp = 0;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_OBJECT:
+		right_key = object_right->src_name;
+		/* Fall through */
+	case OBJ_SEARCH_KEY:
+		if (strcmp(object_left->src_name, right_key) == 0) {
+			cmp = CMP_MATCH;
+		}
+		break;
+	case OBJ_SEARCH_PARTIAL_KEY:
+		if (strncmp(object_left->src_name, right_key, strlen(right_key)) == 0) {
+			cmp = CMP_MATCH;
+		}
+		break;
+	default:
+		cmp = 0;
+		break;
+	}
+	return cmp;
+}
+
+static int suspects_hash(const void *obj, int flags)
+{
+	const struct unidentified_request *object;
+	const char *key;
+
+	switch (flags & OBJ_SEARCH_MASK) {
+	case OBJ_SEARCH_KEY:
+		key = obj;
+		break;
+	case OBJ_SEARCH_OBJECT:
+		object = obj;
+		key = object->src_name;
+		break;
+	default:
+		/* Hash can only work on something with a full key. */
+		ast_assert(0);
+		return 0;
+	}
+	return ast_str_hash(key);
+}
+
+static struct ao2_container *cli_unid_get_container(const char *regex)
+{
+	struct ao2_container *s_container;
+
+	s_container = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_NOLOCK, 0,
+		suspects_sort, suspects_compare);
+	if (!s_container) {
+		return NULL;
+	}
+
+	if (ao2_container_dup(s_container, unidentified_requests, 0)) {
+		ao2_ref(s_container, -1);
+		return NULL;
+	}
+
+	return s_container;
+}
+
+static int cli_unid_iterate(void *container, ao2_callback_fn callback, void *args)
+{
+	ao2_callback(container, 0, callback, args);
+
+	return 0;
+}
+
+static void *cli_unid_retrieve_by_id(const char *id)
+{
+	return ao2_find(unidentified_requests, id, OBJ_SEARCH_KEY);
+}
+
+static const char *cli_unid_get_id(const void *obj)
+{
+	const struct unidentified_request *unid = obj;
+
+	return unid->src_name;
+}
+
+static int cli_unid_print_header(void *obj, void *arg, int flags)
+{
+	struct ast_sip_cli_context *context = arg;
+	RAII_VAR(struct ast_sip_cli_formatter_entry *, formatter_entry, NULL, ao2_cleanup);
+
+	int indent = CLI_INDENT_TO_SPACES(context->indent_level);
+	int filler = CLI_LAST_TABSTOP - indent - 7;
+
+	ast_assert(context->output_buffer != NULL);
+
+	ast_str_append(&context->output_buffer, 0,
+		"%*s:  <IP Address%*.*s>  <Count> <Age(sec)>\n",
+		indent, "Request", filler, filler, CLI_HEADER_FILLER);
+
+	return 0;
+}
+
+static int cli_unid_print_body(void *obj, void *arg, int flags)
+{
+	struct unidentified_request *unid = obj;
+	struct ast_sip_cli_context *context = arg;
+	int indent;
+	int flexwidth;
+	int64_t ms = ast_tvdiff_ms(ast_tvnow(), unid->first_seen);
+
+	ast_assert(context->output_buffer != NULL);
+
+	indent = CLI_INDENT_TO_SPACES(context->indent_level);
+	flexwidth = CLI_LAST_TABSTOP - 4;
+
+	ast_str_append(&context->output_buffer, 0, "%*s:  %-*.*s  %7d %10.3f\n",
+		indent,
+		"Request",
+		flexwidth, flexwidth,
+		unid->src_name, unid->count,  ms / 1000.0);
+
+	return 0;
+}
+
+static struct ast_cli_entry cli_commands[] = {
+	AST_CLI_DEFINE(ast_sip_cli_traverse_objects, "Show PJSIP Unidentified Requests",
+		.command = "pjsip show unidentified_requests",
+		.usage = "Usage: pjsip show unidentified_requests\n"
+				"       Show the PJSIP Unidentified Requests\n"),
+};
+
+struct ast_sip_cli_formatter_entry *unid_formatter;
+
+static int expire_requests(void *object, void *arg, int flags)
+{
+	struct unidentified_request *unid = object;
+	int *maxage = arg;
+	int64_t ms = ast_tvdiff_ms(ast_tvnow(), unid->first_seen);
+
+	if (ms > (*maxage) * 2 * 1000) {
+		return CMP_MATCH;
+	}
+
+	return 0;
+}
+
+static int prune_task(const void *data)
+{
+	unsigned int maxage;
+
+	ast_sip_get_unidentified_request_thresholds(&unidentified_count, &unidentified_period, &unidentified_prune_interval);
+	maxage = unidentified_period * 2;
+	ao2_callback(unidentified_requests, OBJ_MULTIPLE | OBJ_NODATA | OBJ_UNLINK, expire_requests, &maxage);
+
+	return unidentified_prune_interval * 1000;
+}
+
+static int clean_task(const void *data)
+{
+	return 0;
+}
+
+static void global_loaded(const char *object_type)
+{
+	char default_realm[MAX_REALM_LENGTH + 1];
+	struct ast_sip_auth *fake_auth;
+	char *identifier_order;
+
+	/* Update using_auth_username */
+	identifier_order = ast_sip_get_endpoint_identifier_order();
+	if (identifier_order) {
+		char *identify_method;
+		char *io_copy = ast_strdupa(identifier_order);
+		int new_using = 0;
+
+		ast_free(identifier_order);
+		while ((identify_method = ast_strip(strsep(&io_copy, ",")))) {
+			if (!strcmp(identify_method, "auth_username")) {
+				new_using = 1;
+				break;
+			}
+		}
+		using_auth_username = new_using;
+	}
+
+	/* Update default_realm of artificial_auth */
+	ast_sip_get_default_realm(default_realm, sizeof(default_realm));
+	fake_auth = ast_sip_get_artificial_auth();
+	if (!fake_auth || strcmp(fake_auth->realm, default_realm)) {
+		ao2_cleanup(fake_auth);
+
+		fake_auth = alloc_artificial_auth(default_realm);
+		if (fake_auth) {
+			ao2_global_obj_replace_unref(artificial_auth, fake_auth);
+			ao2_ref(fake_auth, -1);
+		}
+	}
+
+	ast_sip_get_unidentified_request_thresholds(&unidentified_count, &unidentified_period, &unidentified_prune_interval);
+
+	/* Clean out the old task, if any */
+	ast_sched_clean_by_callback(prune_context, prune_task, clean_task);
+	/* Have to do something with the return value to shut up the stupid compiler. */
+	if (ast_sched_add_variable(prune_context, unidentified_prune_interval * 1000, prune_task, NULL, 1) < 0) {
+		return;
+	}
+}
+
+/*! \brief Observer which is used to update our interval and default_realm when the global setting changes */
+static struct ast_sorcery_observer global_observer = {
+	.loaded = global_loaded,
+};
+
+/*!
+ * \internal
+ * \brief Shutdown the serializers in the distributor pool.
+ * \since 13.10.0
+ *
+ * \return Nothing
+ */
+static void distributor_pool_shutdown(void)
+{
+	int idx;
+
+	for (idx = 0; idx < ARRAY_LEN(distributor_pool); ++idx) {
+		ast_taskprocessor_unreference(distributor_pool[idx]);
+		distributor_pool[idx] = NULL;
+	}
+}
+
+/*!
+ * \internal
+ * \brief Setup the serializers in the distributor pool.
+ * \since 13.10.0
+ *
+ * \retval 0 on success.
+ * \retval -1 on error.
+ */
+static int distributor_pool_setup(void)
+{
+	char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
+	int idx;
+
+	for (idx = 0; idx < ARRAY_LEN(distributor_pool); ++idx) {
+		/* Create name with seq number appended. */
+		ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/distributor");
+
+		distributor_pool[idx] = ast_sip_create_serializer_named(tps_name);
+		if (!distributor_pool[idx]) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
 int ast_sip_initialize_distributor(void)
 {
+	unidentified_requests = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_RWLOCK, 0,
+		DEFAULT_SUSPECTS_BUCKETS, suspects_hash, NULL, suspects_compare);
+	if (!unidentified_requests) {
+		return -1;
+	}
+
+	dialog_associations = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_RWLOCK, 0,
+		DIALOG_ASSOCIATIONS_BUCKETS, dialog_associations_hash, NULL,
+		dialog_associations_cmp);
+	if (!dialog_associations) {
+		ast_sip_destroy_distributor();
+		return -1;
+	}
+
+	if (distributor_pool_setup()) {
+		ast_sip_destroy_distributor();
+		return -1;
+	}
+
+	prune_context = ast_sched_context_create();
+	if (!prune_context) {
+		ast_sip_destroy_distributor();
+		return -1;
+	}
+
+	if (ast_sched_start_thread(prune_context)) {
+		ast_sip_destroy_distributor();
+		return -1;
+	}
+
+	ast_sorcery_observer_add(ast_sip_get_sorcery(), "global", &global_observer);
+	ast_sorcery_reload_object(ast_sip_get_sorcery(), "global");
+
 	if (create_artificial_endpoint() || create_artificial_auth()) {
+		ast_sip_destroy_distributor();
 		return -1;
 	}
 
 	if (internal_sip_register_service(&distributor_mod)) {
+		ast_sip_destroy_distributor();
 		return -1;
 	}
 	if (internal_sip_register_service(&endpoint_mod)) {
+		ast_sip_destroy_distributor();
 		return -1;
 	}
 	if (internal_sip_register_service(&auth_mod)) {
+		ast_sip_destroy_distributor();
 		return -1;
 	}
 
+	unid_formatter = ao2_alloc_options(sizeof(struct ast_sip_cli_formatter_entry), NULL,
+		AO2_ALLOC_OPT_LOCK_NOLOCK);
+	if (!unid_formatter) {
+		ast_sip_destroy_distributor();
+		ast_log(LOG_ERROR, "Unable to allocate memory for unid_formatter\n");
+		return -1;
+	}
+	unid_formatter->name = "unidentified_request";
+	unid_formatter->print_header = cli_unid_print_header;
+	unid_formatter->print_body = cli_unid_print_body;
+	unid_formatter->get_container = cli_unid_get_container;
+	unid_formatter->iterate = cli_unid_iterate;
+	unid_formatter->get_id = cli_unid_get_id;
+	unid_formatter->retrieve_by_id = cli_unid_retrieve_by_id;
+	ast_sip_register_cli_formatter(unid_formatter);
+
+	ast_cli_register_multiple(cli_commands, ARRAY_LEN(cli_commands));
+
 	return 0;
 }
 
 void ast_sip_destroy_distributor(void)
 {
-	internal_sip_unregister_service(&distributor_mod);
-	internal_sip_unregister_service(&endpoint_mod);
+	ast_cli_unregister_multiple(cli_commands, ARRAY_LEN(cli_commands));
+	ast_sip_unregister_cli_formatter(unid_formatter);
+
 	internal_sip_unregister_service(&auth_mod);
+	internal_sip_unregister_service(&endpoint_mod);
+	internal_sip_unregister_service(&distributor_mod);
 
-	ao2_cleanup(artificial_auth);
+	ao2_global_obj_release(artificial_auth);
 	ao2_cleanup(artificial_endpoint);
+
+	ast_sorcery_observer_remove(ast_sip_get_sorcery(), "global", &global_observer);
+
+	if (prune_context) {
+		ast_sched_context_destroy(prune_context);
+	}
+
+	distributor_pool_shutdown();
+
+	ao2_cleanup(dialog_associations);
+	ao2_cleanup(unidentified_requests);
 }
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_global_headers.c asterisk-13.17.0/res/res_pjsip/pjsip_global_headers.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_global_headers.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/pjsip_global_headers.c	2017-07-12 13:12:08.000000000 +0200
@@ -87,6 +87,14 @@ static void add_headers_to_message(struc
 		return;
 	}
 	AST_LIST_TRAVERSE(headers, iter, next) {
+		pj_str_t name;
+		pjsip_generic_string_hdr *hdr;
+
+		hdr = pjsip_msg_find_hdr_by_name(tdata->msg, pj_cstr(&name, iter->name), NULL);
+		if (hdr) {
+			continue;
+		}
+
 		ast_sip_add_header(tdata, iter->name, iter->value);
 	};
 	tdata->mod_data[global_header_mod.id] = &handled_id;
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_message_ip_updater.c asterisk-13.17.0/res/res_pjsip/pjsip_message_ip_updater.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_message_ip_updater.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_pjsip/pjsip_message_ip_updater.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,388 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2014-2016, Digium, Inc.
+ *
+ * Joshua Colp <jcolp@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+#include "asterisk.h"
+
+#include <pjsip.h>
+#include <pjsip_ua.h>
+
+#include "asterisk/res_pjsip.h"
+#include "asterisk/res_pjsip_session.h"
+#include "include/res_pjsip_private.h"
+
+#define MOD_DATA_RESTRICTIONS "restrictions"
+
+static pj_status_t multihomed_on_tx_message(pjsip_tx_data *tdata);
+static pj_bool_t multihomed_on_rx_message(pjsip_rx_data *rdata);
+
+/*! \brief Outgoing message modification restrictions */
+struct multihomed_message_restrictions {
+	/*! \brief Disallow modification of the From domain */
+	unsigned int disallow_from_domain_modification;
+};
+
+static pjsip_module multihomed_module = {
+	.name = { "Multihomed Routing", 18 },
+	.id = -1,
+	.priority = PJSIP_MOD_PRIORITY_TSX_LAYER - 1,
+	.on_tx_request = multihomed_on_tx_message,
+	.on_tx_response = multihomed_on_tx_message,
+	.on_rx_request = multihomed_on_rx_message,
+};
+
+/*! \brief Helper function to get (or allocate if not already present) restrictions on a message */
+static struct multihomed_message_restrictions *multihomed_get_restrictions(pjsip_tx_data *tdata)
+{
+	struct multihomed_message_restrictions *restrictions;
+
+	restrictions = ast_sip_mod_data_get(tdata->mod_data, multihomed_module.id, MOD_DATA_RESTRICTIONS);
+	if (restrictions) {
+		return restrictions;
+	}
+
+	restrictions = PJ_POOL_ALLOC_T(tdata->pool, struct multihomed_message_restrictions);
+	ast_sip_mod_data_set(tdata->pool, tdata->mod_data, multihomed_module.id, MOD_DATA_RESTRICTIONS, restrictions);
+
+	return restrictions;
+}
+
+/*! \brief Callback invoked on non-session outgoing messages */
+static void multihomed_outgoing_message(struct ast_sip_endpoint *endpoint, struct ast_sip_contact *contact, struct pjsip_tx_data *tdata)
+{
+	struct multihomed_message_restrictions *restrictions = multihomed_get_restrictions(tdata);
+
+	restrictions->disallow_from_domain_modification = !ast_strlen_zero(endpoint->fromdomain);
+}
+
+/*! \brief PJSIP Supplement for tagging messages with restrictions */
+static struct ast_sip_supplement multihomed_supplement = {
+	.priority = AST_SIP_SUPPLEMENT_PRIORITY_FIRST,
+	.outgoing_request = multihomed_outgoing_message,
+	.outgoing_response = multihomed_outgoing_message,
+};
+
+/*! \brief Callback invoked on session outgoing messages */
+static void multihomed_session_outgoing_message(struct ast_sip_session *session, struct pjsip_tx_data *tdata)
+{
+	struct multihomed_message_restrictions *restrictions = multihomed_get_restrictions(tdata);
+
+	restrictions->disallow_from_domain_modification = !ast_strlen_zero(session->endpoint->fromdomain);
+}
+
+/*! \brief PJSIP Session Supplement for tagging messages with restrictions */
+static struct ast_sip_session_supplement multihomed_session_supplement = {
+	.priority = 1,
+	.outgoing_request = multihomed_session_outgoing_message,
+	.outgoing_response = multihomed_session_outgoing_message,
+};
+
+/*! \brief Helper function which returns a UDP transport bound to the given address and port */
+static pjsip_transport *multihomed_get_udp_transport(pj_str_t *address, int port)
+{
+	struct ao2_container *transport_states = ast_sip_get_transport_states();
+	struct ast_sip_transport_state *transport_state;
+	struct ao2_iterator iter;
+	pjsip_transport *sip_transport = NULL;
+
+	if (!transport_states) {
+		return NULL;
+	}
+
+	for (iter = ao2_iterator_init(transport_states, 0); (transport_state = ao2_iterator_next(&iter)); ao2_ref(transport_state, -1)) {
+		if (transport_state && ((transport_state->type != AST_TRANSPORT_UDP) ||
+			(pj_strcmp(&transport_state->transport->local_name.host, address)) ||
+			(transport_state->transport->local_name.port != port))) {
+			continue;
+		}
+
+		sip_transport = transport_state->transport;
+		break;
+	}
+	ao2_iterator_destroy(&iter);
+
+	ao2_ref(transport_states, -1);
+
+	return sip_transport;
+}
+
+/*! \brief Helper function which determines if a transport is bound to any */
+static int multihomed_bound_any(pjsip_transport *transport)
+{
+	pj_uint32_t loop6[4] = {0, 0, 0, 0};
+
+	if ((transport->local_addr.addr.sa_family == pj_AF_INET() &&
+		transport->local_addr.ipv4.sin_addr.s_addr == PJ_INADDR_ANY) ||
+		(transport->local_addr.addr.sa_family == pj_AF_INET6() &&
+		!pj_memcmp(&transport->local_addr.ipv6.sin6_addr, loop6, sizeof(loop6)))) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/*! \brief Helper function which determines if the address within SDP should be rewritten */
+static int multihomed_rewrite_sdp(struct pjmedia_sdp_session *sdp)
+{
+	if (!sdp->conn) {
+		return 0;
+	}
+
+	/* If the host address is used in the SDP replace it with the address of what this is going out on */
+	if ((!pj_strcmp2(&sdp->conn->addr_type, "IP4") && !pj_strcmp2(&sdp->conn->addr,
+		ast_sip_get_host_ip_string(pj_AF_INET()))) ||
+		(!pj_strcmp2(&sdp->conn->addr_type, "IP6") && !pj_strcmp2(&sdp->conn->addr,
+		ast_sip_get_host_ip_string(pj_AF_INET6())))) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static void sanitize_tdata(pjsip_tx_data *tdata)
+{
+	static const pj_str_t x_name = { AST_SIP_X_AST_TXP, AST_SIP_X_AST_TXP_LEN };
+	pjsip_param *x_transport;
+	pjsip_sip_uri *uri;
+	pjsip_fromto_hdr *fromto;
+	pjsip_contact_hdr *contact;
+	pjsip_hdr *hdr;
+
+	if (tdata->msg->type == PJSIP_REQUEST_MSG) {
+		uri = pjsip_uri_get_uri(tdata->msg->line.req.uri);
+		x_transport = pjsip_param_find(&uri->other_param, &x_name);
+		if (x_transport) {
+			pj_list_erase(x_transport);
+		}
+	}
+
+	for (hdr = tdata->msg->hdr.next; hdr != &tdata->msg->hdr; hdr = hdr->next) {
+		if (hdr->type == PJSIP_H_TO || hdr->type == PJSIP_H_FROM) {
+			fromto = (pjsip_fromto_hdr *) hdr;
+			uri = pjsip_uri_get_uri(fromto->uri);
+			x_transport = pjsip_param_find(&uri->other_param, &x_name);
+			if (x_transport) {
+				pj_list_erase(x_transport);
+			}
+		} else if (hdr->type == PJSIP_H_CONTACT) {
+			contact = (pjsip_contact_hdr *) hdr;
+			uri = pjsip_uri_get_uri(contact->uri);
+			x_transport = pjsip_param_find(&uri->other_param, &x_name);
+			if (x_transport) {
+				pj_list_erase(x_transport);
+			}
+		}
+	}
+
+	pjsip_tx_data_invalidate_msg(tdata);
+}
+
+static pj_status_t multihomed_on_tx_message(pjsip_tx_data *tdata)
+{
+	struct multihomed_message_restrictions *restrictions = ast_sip_mod_data_get(tdata->mod_data, multihomed_module.id, MOD_DATA_RESTRICTIONS);
+	pjsip_tpmgr_fla2_param prm;
+	pjsip_cseq_hdr *cseq;
+	pjsip_via_hdr *via;
+	pjsip_fromto_hdr *from;
+
+	sanitize_tdata(tdata);
+
+	/* Use the destination information to determine what local interface this message will go out on */
+	pjsip_tpmgr_fla2_param_default(&prm);
+	prm.tp_type = tdata->tp_info.transport->key.type;
+	pj_strset2(&prm.dst_host, tdata->tp_info.dst_name);
+	prm.local_if = PJ_TRUE;
+
+	/* If we can't get the local address use best effort and let it pass */
+	if (pjsip_tpmgr_find_local_addr2(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()), tdata->pool, &prm) != PJ_SUCCESS) {
+		return PJ_SUCCESS;
+	}
+
+	/* For UDP we can have multiple transports so the port needs to be maintained */
+	if (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||
+		tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {
+		prm.ret_port = tdata->tp_info.transport->local_name.port;
+	}
+
+	/* If the IP source differs from the existing transport see if we need to update it */
+	if (pj_strcmp(&prm.ret_addr, &tdata->tp_info.transport->local_name.host)) {
+
+		/* If the transport it is going out on is different reflect it in the message */
+		if (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||
+			tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {
+			pjsip_transport *transport;
+
+			transport = multihomed_get_udp_transport(&prm.ret_addr, prm.ret_port);
+
+			if (transport) {
+				tdata->tp_info.transport = transport;
+			}
+		}
+
+		/* If the chosen transport is not bound to any we can't use the source address as it won't get back to us */
+		if (!multihomed_bound_any(tdata->tp_info.transport)) {
+			pj_strassign(&prm.ret_addr, &tdata->tp_info.transport->local_name.host);
+		}
+	} else {
+		/* The transport chosen will deliver this but ensure it is updated with the right information */
+		pj_strassign(&prm.ret_addr, &tdata->tp_info.transport->local_name.host);
+	}
+
+	/* If the message needs to be updated with new address do so */
+	if (tdata->msg->type == PJSIP_REQUEST_MSG || !(cseq = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CSEQ, NULL)) ||
+		pj_strcmp2(&cseq->method.name, "REGISTER")) {
+		pjsip_contact_hdr *contact = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL);
+		if (contact && (PJSIP_URI_SCHEME_IS_SIP(contact->uri) || PJSIP_URI_SCHEME_IS_SIPS(contact->uri))
+			&& !(tdata->msg->type == PJSIP_RESPONSE_MSG && tdata->msg->line.status.code / 100 == 3)) {
+			pjsip_sip_uri *uri = pjsip_uri_get_uri(contact->uri);
+
+			/* prm.ret_addr is allocated from the tdata pool OR the transport so it is perfectly fine to just do an assignment like this */
+			pj_strassign(&uri->host, &prm.ret_addr);
+			uri->port = prm.ret_port;
+			ast_debug(4, "Re-wrote Contact URI host/port to %.*s:%d\n",
+				(int)pj_strlen(&uri->host), pj_strbuf(&uri->host), uri->port);
+
+			if (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||
+				tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {
+				uri->transport_param.slen = 0;
+			} else {
+				pj_strdup2(tdata->pool, &uri->transport_param, pjsip_transport_get_type_name(tdata->tp_info.transport->key.type));
+			}
+
+			pjsip_tx_data_invalidate_msg(tdata);
+		}
+	}
+
+	if (tdata->msg->type == PJSIP_REQUEST_MSG && (via = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL))) {
+		pj_strassign(&via->sent_by.host, &prm.ret_addr);
+		via->sent_by.port = prm.ret_port;
+
+		pjsip_tx_data_invalidate_msg(tdata);
+	}
+
+	if (tdata->msg->type == PJSIP_REQUEST_MSG && (from = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_FROM, NULL)) &&
+		(restrictions && !restrictions->disallow_from_domain_modification)) {
+		pjsip_name_addr *id_name_addr = (pjsip_name_addr *)from->uri;
+		pjsip_sip_uri *uri = pjsip_uri_get_uri(id_name_addr);
+		pj_sockaddr ip;
+
+		if (pj_strcmp2(&uri->host, "localhost") && pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &uri->host, &ip) == PJ_SUCCESS) {
+			pj_strassign(&uri->host, &prm.ret_addr);
+			pjsip_tx_data_invalidate_msg(tdata);
+		}
+	}
+
+	/* Update the SDP if it is present */
+	if (tdata->msg->body && ast_sip_is_content_type(&tdata->msg->body->content_type, "application", "sdp") &&
+		multihomed_rewrite_sdp(tdata->msg->body->data)) {
+		struct pjmedia_sdp_session *sdp = tdata->msg->body->data;
+		static const pj_str_t STR_IP4 = { "IP4", 3 };
+		static const pj_str_t STR_IP6 = { "IP6", 3 };
+		pj_str_t STR_IP;
+		int stream;
+
+		STR_IP = tdata->tp_info.transport->key.type & PJSIP_TRANSPORT_IPV6 ? STR_IP6 : STR_IP4;
+
+		pj_strassign(&sdp->origin.addr, &prm.ret_addr);
+		sdp->origin.addr_type = STR_IP;
+		pj_strassign(&sdp->conn->addr, &prm.ret_addr);
+		sdp->conn->addr_type = STR_IP;
+
+		for (stream = 0; stream < sdp->media_count; ++stream) {
+			if (sdp->media[stream]->conn) {
+				pj_strassign(&sdp->media[stream]->conn->addr, &prm.ret_addr);
+				sdp->media[stream]->conn->addr_type = STR_IP;
+			}
+		}
+
+		pjsip_tx_data_invalidate_msg(tdata);
+	}
+
+	return PJ_SUCCESS;
+}
+
+static pj_bool_t multihomed_on_rx_message(pjsip_rx_data *rdata)
+{
+	pjsip_contact_hdr *contact;
+	pjsip_sip_uri *uri;
+	const char *transport_id;
+	struct ast_sip_transport *transport;
+	pjsip_param *x_transport;
+
+	if (rdata->msg_info.msg->type != PJSIP_REQUEST_MSG) {
+		return PJ_FALSE;
+	}
+
+	contact = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);
+	if (!(contact && contact->uri
+		&& ast_begins_with(rdata->tp_info.transport->info, AST_SIP_X_AST_TXP ":"))) {
+		return PJ_FALSE;
+	}
+
+	uri = pjsip_uri_get_uri(contact->uri);
+
+	transport_id = rdata->tp_info.transport->info + AST_SIP_X_AST_TXP_LEN + 1;
+	transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport", transport_id);
+
+	if (!(transport && transport->symmetric_transport)) {
+		ao2_cleanup(transport);
+		return PJ_FALSE;
+	}
+	ao2_cleanup(transport);
+
+	x_transport = PJ_POOL_ALLOC_T(rdata->tp_info.pool, pjsip_param);
+	x_transport->name = pj_strdup3(rdata->tp_info.pool, AST_SIP_X_AST_TXP);
+	x_transport->value = pj_strdup3(rdata->tp_info.pool, transport_id);
+
+	pj_list_insert_before(&uri->other_param, x_transport);
+
+	ast_debug(1, "Set transport '%s' on %.*s from %.*s:%d\n", transport_id,
+		(int)rdata->msg_info.msg->line.req.method.name.slen,
+		rdata->msg_info.msg->line.req.method.name.ptr,
+		(int)uri->host.slen, uri->host.ptr, uri->port);
+
+	return PJ_FALSE;
+}
+
+void ast_res_pjsip_cleanup_message_ip_updater(void)
+{
+	ast_sip_unregister_service(&multihomed_module);
+	ast_sip_unregister_supplement(&multihomed_supplement);
+	ast_sip_session_unregister_supplement(&multihomed_session_supplement);
+}
+
+int ast_res_pjsip_init_message_ip_updater(void)
+{
+	if (ast_sip_session_register_supplement(&multihomed_session_supplement)) {
+		ast_log(LOG_ERROR, "Could not register multihomed session supplement for outgoing requests\n");
+		return -1;
+	}
+
+	if (ast_sip_register_supplement(&multihomed_supplement)) {
+		ast_log(LOG_ERROR, "Could not register multihomed supplement for outgoing requests\n");
+		ast_res_pjsip_cleanup_message_ip_updater();
+		return -1;
+	}
+
+	if (ast_sip_register_service(&multihomed_module)) {
+		ast_log(LOG_ERROR, "Could not register multihomed module for incoming and outgoing requests\n");
+		ast_res_pjsip_cleanup_message_ip_updater();
+		return -1;
+	}
+
+	return 0;
+}
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_options.c asterisk-13.17.0/res/res_pjsip/pjsip_options.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_options.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/pjsip_options.c	2017-07-12 13:12:08.000000000 +0200
@@ -31,6 +31,7 @@
 #include "asterisk/test.h"
 #include "asterisk/statsd.h"
 #include "include/res_pjsip_private.h"
+#include "asterisk/taskprocessor.h"
 
 #define DEFAULT_LANGUAGE "en"
 #define DEFAULT_ENCODING "text/plain"
@@ -52,6 +53,9 @@ static const char *short_status_map [] =
 	[REMOVED] = "Removed",
 };
 
+static void contact_deleted(const void *obj);
+static void qualify_and_schedule(struct ast_sip_contact *contact);
+
 const char *ast_sip_get_contact_status_label(const enum ast_sip_contact_status_type status)
 {
 	return status_map[status];
@@ -105,6 +109,29 @@ static void *contact_status_alloc(const
 	return status;
 }
 
+static int qualify_and_schedule_aor_contact(void *obj)
+{
+	struct ast_sip_contact *contact = obj;
+	struct ast_sip_aor *aor;
+
+	if (!contact || ast_strlen_zero(contact->aor) ||
+		!(aor = ast_sip_location_retrieve_aor(contact->aor))) {
+		ao2_ref(contact, -1);
+		return -1;
+	}
+
+	contact->qualify_frequency = aor->qualify_frequency;
+	contact->qualify_timeout = aor->qualify_timeout;
+	contact->authenticate_qualify = aor->authenticate_qualify;
+
+	ao2_ref(aor, -1);
+
+	qualify_and_schedule(contact);
+	ao2_ref(contact, -1);
+
+	return 0;
+}
+
 AST_MUTEX_DEFINE_STATIC(creation_lock);
 
 /*!
@@ -146,6 +173,18 @@ struct ast_sip_contact_status *ast_res_p
 		return NULL;
 	}
 
+	/* The permanent contact added after asterisk start should be qualified. */
+	if (ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED) && ast_tvzero(contact->expiration_time)) {
+		/*
+		 * The FULLY_BOOTED to filter out contacts that already existed when asterisk started.
+		 * The zero expiration_time to select only permanent contacts.
+		 */
+		ao2_ref((struct ast_sip_contact *) contact, +1);
+		if (ast_sip_push_task(NULL, qualify_and_schedule_aor_contact, (struct ast_sip_contact *) contact)) {
+			ao2_ref((struct ast_sip_contact *) contact, -1);
+		}
+	}
+
 	ast_statsd_log_string_va("PJSIP.contacts.states.%s", AST_STATSD_GAUGE,
 		"+1", 1.0, ast_sip_get_contact_status_label(status->status));
 
@@ -157,7 +196,7 @@ struct ast_sip_contact_status *ast_res_p
  * \brief Update an ast_sip_contact_status's elements.
  */
 static void update_contact_status(const struct ast_sip_contact *contact,
-	enum ast_sip_contact_status_type value)
+	enum ast_sip_contact_status_type value, int is_contact_refresh)
 {
 	RAII_VAR(struct ast_sip_contact_status *, status, NULL, ao2_cleanup);
 	RAII_VAR(struct ast_sip_contact_status *, update, NULL, ao2_cleanup);
@@ -169,6 +208,26 @@ static void update_contact_status(const
 		return;
 	}
 
+	if (is_contact_refresh
+		&& status->status == CREATED) {
+		/*
+		 * The contact status hasn't been updated since creation
+		 * and we don't want to re-send a created status.
+		 */
+		if (contact->qualify_frequency
+			|| status->rtt_start.tv_sec > 0) {
+			/* Ignore, the status will change soon. */
+			return;
+		}
+
+		/*
+		 * Convert to a regular contact status update
+		 * because the status may never change.
+		 */
+		is_contact_refresh = 0;
+		value = UNKNOWN;
+	}
+
 	update = ast_sorcery_alloc(ast_sip_get_sorcery(), CONTACT_STATUS,
 		ast_sorcery_object_get_id(status));
 	if (!update) {
@@ -182,22 +241,34 @@ static void update_contact_status(const
 		return;
 	}
 
-	update->last_status = status->status;
-	update->status = value;
+	if (is_contact_refresh) {
+		/* Copy everything just to set the refresh flag. */
+		update->status = status->status;
+		update->last_status = status->last_status;
+		update->rtt = status->rtt;
+		update->rtt_start = status->rtt_start;
+		update->refresh = 1;
+	} else {
+		update->last_status = status->status;
+		update->status = value;
 
-	/* if the contact is available calculate the rtt as
-	   the diff between the last start time and "now" */
-	update->rtt = update->status == AVAILABLE && status->rtt_start.tv_sec > 0 ?
-		ast_tvdiff_us(ast_tvnow(), status->rtt_start) : 0;
-	update->rtt_start = ast_tv(0, 0);
-
-	ast_test_suite_event_notify("AOR_CONTACT_QUALIFY_RESULT",
-		"Contact: %s\r\n"
-		"Status: %s\r\n"
-		"RTT: %" PRId64,
-		ast_sorcery_object_get_id(update),
-		ast_sip_get_contact_status_label(update->status),
-		update->rtt);
+		/*
+		 * if the contact is available calculate the rtt as
+		 * the diff between the last start time and "now"
+		 */
+		update->rtt = update->status == AVAILABLE && status->rtt_start.tv_sec > 0
+			? ast_tvdiff_us(ast_tvnow(), status->rtt_start)
+			: 0;
+		update->rtt_start = ast_tv(0, 0);
+
+		ast_test_suite_event_notify("AOR_CONTACT_QUALIFY_RESULT",
+			"Contact: %s\r\n"
+			"Status: %s\r\n"
+			"RTT: %" PRId64,
+			ast_sorcery_object_get_id(update),
+			ast_sip_get_contact_status_label(update->status),
+			update->rtt);
+	}
 
 	if (ast_sorcery_update(ast_sip_get_sorcery(), update)) {
 		ast_log(LOG_ERROR, "Unable to update ast_sip_contact_status for contact %s\n",
@@ -314,10 +385,10 @@ static void qualify_contact_cb(void *tok
 		/* Fall through */
 	case PJSIP_EVENT_TRANSPORT_ERROR:
 	case PJSIP_EVENT_TIMER:
-		update_contact_status(contact, UNAVAILABLE);
+		update_contact_status(contact, UNAVAILABLE, 0);
 		break;
 	case PJSIP_EVENT_RX_MSG:
-		update_contact_status(contact, AVAILABLE);
+		update_contact_status(contact, AVAILABLE, 0);
 		break;
 	}
 	ao2_cleanup(contact);
@@ -338,10 +409,16 @@ static int qualify_contact(struct ast_si
 	if (endpoint) {
 		endpoint_local = ao2_bump(endpoint);
 	} else {
-		endpoint_local = find_an_endpoint(contact);
+		if (!ast_strlen_zero(contact->endpoint_name)) {
+			endpoint_local = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", contact->endpoint_name);
+		}
+		if (!endpoint_local) {
+			endpoint_local = find_an_endpoint(contact);
+		}
 		if (!endpoint_local) {
-			ast_log(LOG_ERROR, "Unable to find an endpoint to qualify contact %s\n",
+			ast_log(LOG_WARNING, "Unable to find an endpoint to qualify contact %s. Deleting this contact\n",
 				contact->uri);
+			contact_deleted(contact);
 			return -1;
 		}
 	}
@@ -368,7 +445,7 @@ static int qualify_contact(struct ast_si
 		!= PJ_SUCCESS) {
 		ast_log(LOG_ERROR, "Unable to send request to qualify contact %s\n",
 			contact->uri);
-		update_contact_status(contact, UNAVAILABLE);
+		update_contact_status(contact, UNAVAILABLE, 0);
 		ao2_ref(contact, -1);
 		return -1;
 	}
@@ -528,7 +605,7 @@ static void qualify_and_schedule(struct
 
 		schedule_qualify(contact, contact->qualify_frequency * 1000);
 	} else {
-		update_contact_status(contact, UNKNOWN);
+		update_contact_status(contact, UNKNOWN, 0);
 	}
 }
 
@@ -543,6 +620,15 @@ static void contact_created(const void *
 
 /*!
  * \internal
+ * \brief A contact has been updated.
+ */
+static void contact_updated(const void *obj)
+{
+	update_contact_status(obj, AVAILABLE, 1);
+}
+
+/*!
+ * \internal
  * \brief A contact has been deleted remove status tracking.
  */
 static void contact_deleted(const void *obj)
@@ -567,7 +653,8 @@ static void contact_deleted(const void *
 
 static const struct ast_sorcery_observer contact_observer = {
 	.created = contact_created,
-	.deleted = contact_deleted
+	.updated = contact_updated,
+	.deleted = contact_deleted,
 };
 
 static pj_bool_t options_start(void)
@@ -624,7 +711,8 @@ static pj_status_t send_options_response
 	pj_status_t status;
 
 	/* Make the response object */
-	if ((status = ast_sip_create_response(rdata, code, NULL, &tdata) != PJ_SUCCESS)) {
+	status = ast_sip_create_response(rdata, code, NULL, &tdata);
+	if (status != PJ_SUCCESS) {
 		ast_log(LOG_ERROR, "Unable to create response (%d)\n", status);
 		return status;
 	}
@@ -673,8 +761,7 @@ static pj_bool_t options_on_rx_request(p
 	pjsip_sip_uri *sip_ruri;
 	char exten[AST_MAX_EXTENSION];
 
-	if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method,
-			     &pjsip_options_method)) {
+	if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_options_method)) {
 		return PJ_FALSE;
 	}
 
@@ -691,13 +778,20 @@ static pj_bool_t options_on_rx_request(p
 	sip_ruri = pjsip_uri_get_uri(ruri);
 	ast_copy_pj_str(exten, &sip_ruri->user, sizeof(exten));
 
+	/*
+	 * We may want to match in the dialplan without any user
+	 * options getting in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(exten);
+
 	if (ast_shutting_down()) {
 		/*
 		 * Not taking any new calls at this time.
 		 * Likely a server availability OPTIONS poll.
 		 */
 		send_options_response(rdata, 503);
-	} else if (!ast_strlen_zero(exten) && !ast_exists_extension(NULL, endpoint->context, exten, 1, NULL)) {
+	} else if (!ast_strlen_zero(exten)
+		&& !ast_exists_extension(NULL, endpoint->context, exten, 1, NULL)) {
 		send_options_response(rdata, 404);
 	} else {
 		send_options_response(rdata, 200);
@@ -1002,6 +1096,8 @@ int ast_sip_initialize_sorcery_qualify(v
 
 	/* initialize sorcery ast_sip_contact_status resource */
 	ast_sorcery_apply_default(sorcery, CONTACT_STATUS, "memory", NULL);
+	ast_sorcery_object_set_congestion_levels(sorcery, CONTACT_STATUS, -1,
+		3 * AST_TASKPROCESSOR_HIGH_WATER_LEVEL);
 
 	if (ast_sorcery_internal_object_register(sorcery, CONTACT_STATUS,
 					contact_status_alloc, NULL, NULL)) {
@@ -1023,17 +1119,11 @@ int ast_sip_initialize_sorcery_qualify(v
 	return 0;
 }
 
-static int qualify_and_schedule_cb(void *obj, void *arg, int flags)
+static void qualify_and_schedule_contact(struct ast_sip_contact *contact)
 {
-	struct ast_sip_contact *contact = obj;
-	struct ast_sip_aor *aor = arg;
 	int initial_interval;
 	int max_time = ast_sip_get_max_initial_qualify_time();
 
-	contact->qualify_frequency = aor->qualify_frequency;
-	contact->qualify_timeout = aor->qualify_timeout;
-	contact->authenticate_qualify = aor->authenticate_qualify;
-
 	/* Delay initial qualification by a random fraction of the specified interval */
 	if (max_time && max_time < contact->qualify_frequency) {
 		initial_interval = max_time;
@@ -1047,28 +1137,49 @@ static int qualify_and_schedule_cb(void
 	if (contact->qualify_frequency) {
 		schedule_qualify(contact, initial_interval);
 	} else {
-		update_contact_status(contact, UNKNOWN);
+		update_contact_status(contact, UNKNOWN, 0);
 	}
+}
+
+static int qualify_and_schedule_cb_with_aor(void *obj, void *arg, int flags)
+{
+	struct ast_sip_contact *contact = obj;
+	struct ast_sip_aor *aor = arg;
+
+	contact->qualify_frequency = aor->qualify_frequency;
+	contact->qualify_timeout = aor->qualify_timeout;
+	contact->authenticate_qualify = aor->authenticate_qualify;
+
+	qualify_and_schedule_contact(contact);
+
+	return 0;
+}
+
+static int qualify_and_schedule_cb_without_aor(void *obj, void *arg, int flags)
+{
+	qualify_and_schedule_contact((struct ast_sip_contact *) obj);
 
 	return 0;
 }
 
 /*!
  * \internal
- * \brief Qualify and schedule an endpoint's contacts
+ * \brief Qualify and schedule an aor's contacts
  *
- * \details For the given endpoint retrieve its list of aors, qualify all
- *         contacts, and schedule for checks if configured.
+ * \details For the given aor check if it has permanent contacts,
+ *         qualify all contacts and schedule for checks if configured.
  */
 static int qualify_and_schedule_all_cb(void *obj, void *arg, int flags)
 {
 	struct ast_sip_aor *aor = obj;
 	struct ao2_container *contacts;
 
-	contacts = ast_sip_location_retrieve_aor_contacts(aor);
-	if (contacts) {
-		ao2_callback(contacts, OBJ_NODATA, qualify_and_schedule_cb, aor);
-		ao2_ref(contacts, -1);
+	if (aor->permanent_contacts) {
+		contacts = ast_sip_location_retrieve_aor_contacts(aor);
+		if (contacts) {
+			ao2_callback(contacts, OBJ_NODATA, qualify_and_schedule_cb_with_aor, aor);
+			ao2_ref(contacts, -1);
+		}
 	}
 
 	return 0;
@@ -1091,6 +1202,7 @@ static void qualify_and_schedule_all(voi
 {
 	struct ast_variable *var = ast_variable_new("qualify_frequency >", "0", "");
 	struct ao2_container *aors;
+	struct ao2_container *contacts;
 
 	if (!var) {
 		return;
@@ -1098,19 +1210,25 @@ static void qualify_and_schedule_all(voi
 	aors = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(),
 		"aor", AST_RETRIEVE_FLAG_MULTIPLE, var);
 
-	ast_variables_destroy(var);
-
 	ao2_callback(sched_qualifies, OBJ_NODATA | OBJ_MULTIPLE | OBJ_UNLINK, unschedule_all_cb, NULL);
 
-	if (!aors) {
-		return;
+	if (aors) {
+		ao2_callback(aors, OBJ_NODATA, qualify_and_schedule_all_cb, NULL);
+		ao2_ref(aors, -1);
+	}
+
+	contacts = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(),
+		"contact", AST_RETRIEVE_FLAG_MULTIPLE, var);
+	if (contacts) {
+		ao2_callback(contacts, OBJ_NODATA, qualify_and_schedule_cb_without_aor, NULL);
+		ao2_ref(contacts, -1);
 	}
 
-	ao2_callback(aors, OBJ_NODATA, qualify_and_schedule_all_cb, NULL);
-	ao2_ref(aors, -1);
+	ast_variables_destroy(var);
+
 }
 
-static int format_contact_status(void *obj, void *arg, int flags)
+int ast_sip_format_contact_ami(void *obj, void *arg, int flags)
 {
 	struct ast_sip_contact_wrapper *wrapper = obj;
 	struct ast_sip_contact *contact = wrapper->contact;
@@ -1132,14 +1250,32 @@ static int format_contact_status(void *o
 	ast_str_append(&buf, 0, "URI: %s\r\n", contact->uri);
 	ast_str_append(&buf, 0, "UserAgent: %s\r\n", contact->user_agent);
 	ast_str_append(&buf, 0, "RegExpire: %ld\r\n", contact->expiration_time.tv_sec);
-	ast_str_append(&buf, 0, "Status: %s\r\n", ast_sip_get_contact_status_label(status->status));
-	if (status->status == UNKNOWN) {
+	if (!ast_strlen_zero(contact->via_addr)) {
+		ast_str_append(&buf, 0, "ViaAddress: %s", contact->via_addr);
+		if (contact->via_port) {
+			ast_str_append(&buf, 0, ":%d", contact->via_port);
+		}
+		ast_str_append(&buf, 0, "\r\n");
+	}
+	if (!ast_strlen_zero(contact->call_id)) {
+		ast_str_append(&buf, 0, "CallID: %s\r\n", contact->call_id);
+	}
+	ast_str_append(&buf, 0, "Status: %s\r\n", ast_sip_get_contact_status_label(status ? status->status : UNKNOWN));
+	if (!status || status->status == UNKNOWN) {
 		ast_str_append(&buf, 0, "RoundtripUsec: N/A\r\n");
 	} else {
 		ast_str_append(&buf, 0, "RoundtripUsec: %" PRId64 "\r\n", status->rtt);
 	}
 	ast_str_append(&buf, 0, "EndpointName: %s\r\n",
-			ast_sorcery_object_get_id(endpoint));
+			endpoint ? ast_sorcery_object_get_id(endpoint) : S_OR(contact->endpoint_name, ""));
+
+	ast_str_append(&buf, 0, "ID: %s\r\n", ast_sorcery_object_get_id(contact));
+	ast_str_append(&buf, 0, "AuthenticateQualify: %d\r\n", contact->authenticate_qualify);
+	ast_str_append(&buf, 0, "OutboundProxy: %s\r\n", contact->outbound_proxy);
+	ast_str_append(&buf, 0, "Path: %s\r\n", contact->path);
+	ast_str_append(&buf, 0, "QualifyFrequency: %u\r\n", contact->qualify_frequency);
+	ast_str_append(&buf, 0, "QualifyTimeout: %.3f\r\n", contact->qualify_timeout);
+
 	astman_append(ami->s, "%s\r\n", ast_str_buffer(buf));
 	ami->count++;
 	
@@ -1152,7 +1288,7 @@ static int format_contact_status_for_aor
 {
 	struct ast_sip_aor *aor = obj;
 
-	return ast_sip_for_each_contact(aor, format_contact_status, arg);
+	return ast_sip_for_each_contact(aor, ast_sip_format_contact_ami, arg);
 }
 
 static int format_ami_contact_status(const struct ast_sip_endpoint *endpoint,
@@ -1173,7 +1309,7 @@ static void aor_observer_modified(const
 
 	contacts = ast_sip_location_retrieve_aor_contacts(aor);
 	if (contacts) {
-		ao2_callback(contacts, OBJ_NODATA, qualify_and_schedule_cb, aor);
+		ao2_callback(contacts, OBJ_NODATA, qualify_and_schedule_cb_with_aor, aor);
 		ao2_ref(contacts, -1);
 	}
 }
@@ -1192,7 +1328,7 @@ static void aor_observer_deleted(const v
 
 	contacts = ast_sip_location_retrieve_aor_contacts(aor);
 	if (contacts) {
-		ao2_callback(contacts, OBJ_NODATA, unschedule_contact_cb, NULL);
+		ao2_callback(contacts, OBJ_NODATA | OBJ_MULTIPLE, unschedule_contact_cb, NULL);
 		ao2_ref(contacts, -1);
 	}
 }
@@ -1203,6 +1339,126 @@ static const struct ast_sorcery_observer
 	.deleted = aor_observer_deleted
 };
 
+static int aor_update_endpoint_state(void *obj, void *arg, int flags)
+{
+	struct ast_sip_endpoint *endpoint = obj;
+	const char *endpoint_name = ast_sorcery_object_get_id(endpoint);
+	char *aor = arg;
+	char *endpoint_aor;
+	char *endpoint_aors;
+
+	if (ast_strlen_zero(aor) || ast_strlen_zero(endpoint->aors)) {
+		return 0;
+	}
+
+	endpoint_aors = ast_strdupa(endpoint->aors);
+	while ((endpoint_aor = ast_strip(strsep(&endpoint_aors, ",")))) {
+		if (!strcmp(aor, endpoint_aor)) {
+			if (ast_sip_persistent_endpoint_update_state(endpoint_name, AST_ENDPOINT_ONLINE) == -1) {
+				ast_log(LOG_WARNING, "Unable to find persistent endpoint '%s' for aor '%s'\n",
+					endpoint_name, aor);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int on_aor_update_endpoint_state(void *obj, void *arg, int flags)
+{
+	struct ast_sip_aor *aor = obj;
+	struct ao2_container *endpoints;
+	RAII_VAR(struct ast_variable *, var, NULL, ast_variables_destroy);
+	const char *aor_name = ast_sorcery_object_get_id(aor);
+	char *aor_like;
+
+	if (ast_strlen_zero(aor_name)) {
+		return -1;
+	}
+
+	if (aor->permanent_contacts && ((int)(aor->qualify_frequency * 1000)) <= 0) {
+		aor_like = ast_alloca(strlen(aor_name) + 3);
+		sprintf(aor_like, "%%%s%%", aor_name);
+		var = ast_variable_new("aors LIKE", aor_like, "");
+		if (!var) {
+			return -1;
+		}
+		endpoints = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(),
+			"endpoint", AST_RETRIEVE_FLAG_MULTIPLE, var);
+
+		if (endpoints) {
+		    /*
+		     * Because aors are a string list, we have to use a pattern match but since a simple
+		     * pattern match could return an endpoint that has an aor of "aaabccc" when searching
+		     * for "abc", we still have to iterate over them to find an exact aor match.
+		     */
+		    ao2_callback(endpoints, 0, aor_update_endpoint_state, (char *)aor_name);
+		    ao2_ref(endpoints, -1);
+		}
+	}
+
+	return 0;
+}
+
+static int contact_update_endpoint_state(void *obj, void *arg, int flags)
+{
+	const struct ast_sip_contact *contact = obj;
+	struct timeval tv = ast_tvnow();
+
+	if (!ast_strlen_zero(contact->endpoint_name) && ((int)(contact->qualify_frequency * 1000)) <= 0 &&
+		contact->expiration_time.tv_sec > tv.tv_sec) {
+
+		if (ast_sip_persistent_endpoint_update_state(contact->endpoint_name, AST_ENDPOINT_ONLINE) == -1) {
+			ast_log(LOG_WARNING, "Unable to find persistent endpoint '%s' for contact '%s/%s'\n",
+				contact->endpoint_name, contact->aor, contact->uri);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void update_all_unqualified_endpoints(void)
+{
+	struct ao2_container *aors;
+	struct ao2_container *contacts;
+	RAII_VAR(struct ast_variable *, var_aor, NULL, ast_variables_destroy);
+	RAII_VAR(struct ast_variable *, var_contact, NULL, ast_variables_destroy);
+	RAII_VAR(char *, time_now, NULL, ast_free);
+	struct timeval tv = ast_tvnow();
+
+	if (!(var_aor = ast_variable_new("contact !=", "", ""))) {
+		return;
+	}
+	if (!(var_aor->next = ast_variable_new("qualify_frequency <=", "0", ""))) {
+		return;
+	}
+
+	if (ast_asprintf(&time_now, "%ld", tv.tv_sec) == -1) {
+		return;
+	}
+	if (!(var_contact = ast_variable_new("expiration_time >", time_now, ""))) {
+		return;
+	}
+	if (!(var_contact->next = ast_variable_new("qualify_frequency <=", "0", ""))) {
+		return;
+	}
+
+	aors = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(),
+		"aor", AST_RETRIEVE_FLAG_MULTIPLE, var_aor);
+	if (aors) {
+		ao2_callback(aors, OBJ_NODATA, on_aor_update_endpoint_state, NULL);
+		ao2_ref(aors, -1);
+	}
+
+	contacts = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(),
+		"contact", AST_RETRIEVE_FLAG_MULTIPLE, var_contact);
+	if (contacts) {
+		ao2_callback(contacts, OBJ_NODATA, contact_update_endpoint_state, NULL);
+		ao2_ref(contacts, -1);
+	}
+}
+
 int ast_res_pjsip_init_options_handling(int reload)
 {
 	static const pj_str_t STR_OPTIONS = { "OPTIONS", 7 };
@@ -1244,6 +1500,7 @@ int ast_res_pjsip_init_options_handling(
 	ast_manager_register2("PJSIPQualify", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, ami_sip_qualify, NULL, NULL, NULL);
 	ast_cli_register_multiple(cli_options, ARRAY_LEN(cli_options));
 
+	update_all_unqualified_endpoints();
 	qualify_and_schedule_all();
 
 	return 0;
diff -urpN asterisk-13.9.1/res/res_pjsip/pjsip_scheduler.c asterisk-13.17.0/res/res_pjsip/pjsip_scheduler.c
--- asterisk-13.9.1/res/res_pjsip/pjsip_scheduler.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_pjsip/pjsip_scheduler.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,491 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Fairview 5 Engineering, LLC
+ *
+ * George Joseph <george.joseph@fairview5.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief res_pjsip Scheduler
+ *
+ * \author George Joseph <george.joseph@fairview5.com>
+ */
+
+#include "asterisk.h"
+
+ASTERISK_REGISTER_FILE()
+
+#include "asterisk/res_pjsip.h"
+#include "include/res_pjsip_private.h"
+#include "asterisk/res_pjsip_cli.h"
+
+#define TASK_BUCKETS 53
+
+static struct ast_sched_context *scheduler_context;
+static struct ao2_container *tasks;
+static int task_count;
+
+struct ast_sip_sched_task {
+	/*! ast_sip_sched task id */
+	uint32_t task_id;
+	/*! ast_sched scheudler id */
+	int current_scheduler_id;
+	/*! task is currently running */
+	int is_running;
+	/*! task */
+	ast_sip_task task;
+	/*! task data */
+	void *task_data;
+	/*! reschedule interval in milliseconds */
+	int interval;
+	/*! the time the task was queued */
+	struct timeval when_queued;
+	/*! the last time the task was started */
+	struct timeval last_start;
+	/*! the last time the task was ended */
+	struct timeval last_end;
+	/*! times run */
+	int run_count;
+	/*! the task reschedule, cleanup and policy flags */
+	enum ast_sip_scheduler_task_flags flags;
+	/*! the serializer to be used (if any) */
+	struct ast_taskprocessor *serializer;
+	/* A name to be associated with the task */
+	char name[0];
+};
+
+AO2_STRING_FIELD_HASH_FN(ast_sip_sched_task, name);
+AO2_STRING_FIELD_CMP_FN(ast_sip_sched_task, name);
+AO2_STRING_FIELD_SORT_FN(ast_sip_sched_task, name);
+
+static int push_to_serializer(const void *data);
+
+/*
+ * This function is run in the context of the serializer.
+ * It runs the task with a simple call and reschedules based on the result.
+ */
+static int run_task(void *data)
+{
+	RAII_VAR(struct ast_sip_sched_task *, schtd, ao2_bump(data), ao2_cleanup);
+	int res;
+	int delay;
+
+	ao2_lock(schtd);
+	schtd->last_start = ast_tvnow();
+	schtd->is_running = 1;
+	schtd->run_count++;
+	ao2_unlock(schtd);
+
+	res = schtd->task(schtd->task_data);
+
+	ao2_lock(schtd);
+	schtd->is_running = 0;
+	schtd->last_end = ast_tvnow();
+
+	/*
+	 * Don't restart if the task returned 0 or if the interval
+	 * was set to 0 while the task was running
+	 */
+	if (!res || !schtd->interval) {
+		schtd->interval = 0;
+		ao2_unlock(schtd);
+		ao2_unlink(tasks, schtd);
+		return -1;
+	}
+
+	if (schtd->flags & AST_SIP_SCHED_TASK_VARIABLE) {
+		schtd->interval = res;
+	}
+
+	if (schtd->flags & AST_SIP_SCHED_TASK_DELAY) {
+		delay = schtd->interval;
+	} else {
+		delay = schtd->interval - (ast_tvdiff_ms(schtd->last_end, schtd->last_start) % schtd->interval);
+	}
+
+	schtd->current_scheduler_id = ast_sched_add(scheduler_context, delay, push_to_serializer, (const void *)schtd);
+	if (schtd->current_scheduler_id < 0) {
+		schtd->interval = 0;
+		ao2_unlock(schtd);
+		ao2_unlink(tasks, schtd);
+		return -1;
+	}
+
+	ao2_unlock(schtd);
+
+	return 0;
+}
+
+/*
+ * This function is run by the scheduler thread.  Its only job is to push the task
+ * to the serialize and return.  It returns 0 so it's not rescheduled.
+ */
+static int push_to_serializer(const void *data)
+{
+	struct ast_sip_sched_task *schtd = (struct ast_sip_sched_task *)data;
+
+	if (ast_sip_push_task(schtd->serializer, run_task, schtd)) {
+		ao2_ref(schtd, -1);
+	}
+
+	return 0;
+}
+
+int ast_sip_sched_task_cancel(struct ast_sip_sched_task *schtd)
+{
+	int res;
+
+	if (!ao2_ref_and_lock(schtd)) {
+		return -1;
+	}
+
+	if (schtd->current_scheduler_id < 0 || schtd->interval <= 0) {
+		ao2_unlock_and_unref(schtd);
+		return 0;
+	}
+
+	schtd->interval = 0;
+	ao2_unlock_and_unref(schtd);
+	ao2_unlink(tasks, schtd);
+	res = ast_sched_del(scheduler_context, schtd->current_scheduler_id);
+
+	return res;
+}
+
+int ast_sip_sched_task_cancel_by_name(const char *name)
+{
+	RAII_VAR(struct ast_sip_sched_task *, schtd, NULL, ao2_cleanup);
+
+	if (ast_strlen_zero(name)) {
+		return -1;
+	}
+
+	schtd = ao2_find(tasks, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (!schtd) {
+		return -1;
+	}
+
+	return ast_sip_sched_task_cancel(schtd);
+}
+
+
+int ast_sip_sched_task_get_times(struct ast_sip_sched_task *schtd,
+	struct timeval *queued, struct timeval *last_start, struct timeval *last_end)
+{
+	if (!ao2_ref_and_lock(schtd)) {
+		return -1;
+	}
+
+	if (queued) {
+		memcpy(queued, &schtd->when_queued, sizeof(struct timeval));
+	}
+	if (last_start) {
+		memcpy(last_start, &schtd->last_start, sizeof(struct timeval));
+	}
+	if (last_end) {
+		memcpy(last_end, &schtd->last_end, sizeof(struct timeval));
+	}
+
+	ao2_unlock_and_unref(schtd);
+
+	return 0;
+}
+
+int ast_sip_sched_task_get_times_by_name(const char *name,
+	struct timeval *queued, struct timeval *last_start, struct timeval *last_end)
+{
+	RAII_VAR(struct ast_sip_sched_task *, schtd, NULL, ao2_cleanup);
+
+	if (ast_strlen_zero(name)) {
+		return -1;
+	}
+
+	schtd = ao2_find(tasks, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (!schtd) {
+		return -1;
+	}
+
+	return ast_sip_sched_task_get_times(schtd, queued, last_start, last_end);
+}
+
+int ast_sip_sched_task_get_name(struct ast_sip_sched_task *schtd, char *name, size_t maxlen)
+{
+	if (maxlen <= 0) {
+		return -1;
+	}
+
+	if (!ao2_ref_and_lock(schtd)) {
+		return -1;
+	}
+
+	ast_copy_string(name, schtd->name, maxlen);
+
+	ao2_unlock_and_unref(schtd);
+
+	return 0;
+}
+
+int ast_sip_sched_task_get_next_run(struct ast_sip_sched_task *schtd)
+{
+	int delay;
+	struct timeval since_when;
+	struct timeval now;
+
+	if (!ao2_ref_and_lock(schtd)) {
+		return -1;
+	}
+
+	if (schtd->interval) {
+		delay = schtd->interval;
+		now = ast_tvnow();
+
+		if (schtd->flags & AST_SIP_SCHED_TASK_DELAY) {
+			since_when = schtd->is_running ? now : schtd->last_end;
+		} else {
+			since_when = schtd->last_start.tv_sec ? schtd->last_start : schtd->when_queued;
+		}
+
+		delay -= ast_tvdiff_ms(now, since_when);
+
+		delay = delay < 0 ? 0 : delay;
+	} else {
+		delay = -1;
+	}
+
+	ao2_unlock_and_unref(schtd);
+
+	return delay;
+}
+
+int ast_sip_sched_task_get_next_run_by_name(const char *name)
+{
+	RAII_VAR(struct ast_sip_sched_task *, schtd, NULL, ao2_cleanup);
+
+	if (ast_strlen_zero(name)) {
+		return -1;
+	}
+
+	schtd = ao2_find(tasks, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (!schtd) {
+		return -1;
+	}
+
+	return ast_sip_sched_task_get_next_run(schtd);
+}
+
+int ast_sip_sched_is_task_running(struct ast_sip_sched_task *schtd)
+{
+	if (!schtd) {
+		return 0;
+	}
+
+	return schtd->is_running;
+}
+
+int ast_sip_sched_is_task_running_by_name(const char *name)
+{
+	RAII_VAR(struct ast_sip_sched_task *, schtd, NULL, ao2_cleanup);
+
+	if (ast_strlen_zero(name)) {
+		return 0;
+	}
+
+	schtd = ao2_find(tasks, name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+	if (!schtd) {
+		return 0;
+	}
+
+	return schtd->is_running;
+}
+
+static void schtd_destructor(void *data)
+{
+	struct ast_sip_sched_task *schtd = data;
+
+	if (schtd->flags & AST_SIP_SCHED_TASK_DATA_AO2) {
+		/* release our own ref, then release the callers if asked to do so */
+		ao2_ref(schtd->task_data, (schtd->flags & AST_SIP_SCHED_TASK_DATA_FREE) ? -2 : -1);
+	} else if (schtd->task_data && (schtd->flags & AST_SIP_SCHED_TASK_DATA_FREE)) {
+		ast_free(schtd->task_data);
+	}
+}
+
+struct ast_sip_sched_task *ast_sip_schedule_task(struct ast_taskprocessor *serializer,
+	int interval, ast_sip_task sip_task, char *name, void *task_data, enum ast_sip_scheduler_task_flags flags)
+{
+#define ID_LEN 13 /* task_deadbeef */
+	struct ast_sip_sched_task *schtd;
+	int res;
+
+	if (interval < 0) {
+		return NULL;
+	}
+
+	schtd = ao2_alloc((sizeof(*schtd) + (!ast_strlen_zero(name) ? strlen(name) : ID_LEN) + 1), schtd_destructor);
+	if (!schtd) {
+		return NULL;
+	}
+
+	schtd->task_id = ast_atomic_fetchadd_int(&task_count, 1);
+	schtd->serializer = serializer;
+	schtd->task = sip_task;
+	if (!ast_strlen_zero(name)) {
+		strcpy(schtd->name, name); /* Safe */
+	} else {
+		sprintf(schtd->name, "task_%08x", schtd->task_id);
+	}
+	schtd->task_data = task_data;
+	schtd->flags = flags;
+	schtd->interval = interval;
+	schtd->when_queued = ast_tvnow();
+
+	if (flags & AST_SIP_SCHED_TASK_DATA_AO2) {
+		ao2_ref(task_data, +1);
+	}
+	res = ast_sched_add(scheduler_context, interval, push_to_serializer, (const void *)schtd);
+	if (res < 0) {
+		ao2_ref(schtd, -1);
+		return NULL;
+	} else {
+		schtd->current_scheduler_id = res;
+		ao2_link(tasks, schtd);
+	}
+
+	return schtd;
+#undef ID_LEN
+}
+
+static char *cli_show_tasks(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	struct ao2_iterator i;
+	struct ast_sip_sched_task *schtd;
+	const char *log_format = ast_logger_get_dateformat();
+	struct ast_tm tm;
+	char queued[32];
+	char last_start[32];
+	char next_start[32];
+	int datelen;
+	struct timeval now = ast_tvnow();
+	const char *separator = "======================================";
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pjsip show scheduled_tasks";
+		e->usage = "Usage: pjsip show scheduled_tasks\n"
+		            "      Show all scheduled tasks\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc != 3) {
+		return CLI_SHOWUSAGE;
+	}
+
+	ast_localtime(&now, &tm, NULL);
+	datelen = ast_strftime(queued, sizeof(queued), log_format, &tm);
+
+	ast_cli(a->fd, "PJSIP Scheduled Tasks:\n\n");
+
+	ast_cli(a->fd, " %1$-24s %2$-9s %3$-9s %4$-5s  %6$-*5$s  %7$-*5$s  %8$-*5$s %9$7s\n",
+		"Task Name", "Interval", "Times Run", "State",
+		datelen, "Queued", "Last Started", "Next Start", "( secs)");
+
+	ast_cli(a->fd, " %1$-24.24s %2$-9.9s %3$-9.9s %4$-5.5s  %6$-*5$.*5$s  %7$-*5$.*5$s  %9$-*8$.*8$s\n",
+		separator, separator, separator, separator,
+		datelen, separator, separator, datelen + 8, separator);
+
+
+	ao2_ref(tasks, +1);
+	ao2_rdlock(tasks);
+	i = ao2_iterator_init(tasks, 0);
+	while ((schtd = ao2_iterator_next(&i))) {
+		int next_run_sec = ast_sip_sched_task_get_next_run(schtd) / 1000;
+		struct timeval next = ast_tvadd(now, (struct timeval) {next_run_sec, 0});
+
+		ast_localtime(&schtd->when_queued, &tm, NULL);
+		ast_strftime(queued, sizeof(queued), log_format, &tm);
+
+		if (ast_tvzero(schtd->last_start)) {
+			strcpy(last_start, "not yet started");
+		} else {
+			ast_localtime(&schtd->last_start, &tm, NULL);
+			ast_strftime(last_start, sizeof(last_start), log_format, &tm);
+		}
+
+		ast_localtime(&next, &tm, NULL);
+		ast_strftime(next_start, sizeof(next_start), log_format, &tm);
+
+		ast_cli(a->fd, " %1$-24.24s %2$9.3f %3$9d %4$-5s  %6$-*5$s  %7$-*5$s  %8$-*5$s (%9$5d)\n",
+			schtd->name,
+			schtd->interval / 1000.0,
+			schtd->run_count,
+			schtd->is_running ? "run" : "wait",
+			datelen, queued, last_start,
+			next_start,
+			next_run_sec);
+		ao2_cleanup(schtd);
+	}
+	ao2_iterator_destroy(&i);
+	ao2_unlock(tasks);
+	ao2_ref(tasks, -1);
+	ast_cli(a->fd, "\n");
+
+	return CLI_SUCCESS;
+}
+
+static struct ast_cli_entry cli_commands[] = {
+	AST_CLI_DEFINE(cli_show_tasks, "Show all scheduled tasks"),
+};
+
+int ast_sip_initialize_scheduler(void)
+{
+	if (!(scheduler_context = ast_sched_context_create())) {
+		ast_log(LOG_ERROR, "Failed to create scheduler. Aborting load\n");
+		return -1;
+	}
+
+	if (ast_sched_start_thread(scheduler_context)) {
+		ast_log(LOG_ERROR, "Failed to start scheduler. Aborting load\n");
+		ast_sched_context_destroy(scheduler_context);
+		return -1;
+	}
+
+	tasks = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_RWLOCK, AO2_CONTAINER_ALLOC_OPT_DUPS_REJECT,
+		TASK_BUCKETS, ast_sip_sched_task_hash_fn, ast_sip_sched_task_sort_fn, ast_sip_sched_task_cmp_fn);
+	if (!tasks) {
+		ast_log(LOG_ERROR, "Failed to allocate task container. Aborting load\n");
+		ast_sched_context_destroy(scheduler_context);
+		return -1;
+	}
+
+	ast_cli_register_multiple(cli_commands, ARRAY_LEN(cli_commands));
+
+	return 0;
+}
+
+int ast_sip_destroy_scheduler(void)
+{
+	ast_cli_unregister_multiple(cli_commands, ARRAY_LEN(cli_commands));
+
+	if (scheduler_context) {
+		ast_sched_context_destroy(scheduler_context);
+	}
+
+	ao2_cleanup(tasks);
+	tasks = NULL;
+
+	return 0;
+}
diff -urpN asterisk-13.9.1/res/res_pjsip/presence_xml.c asterisk-13.17.0/res/res_pjsip/presence_xml.c
--- asterisk-13.9.1/res/res_pjsip/presence_xml.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/presence_xml.c	2017-07-12 13:12:08.000000000 +0200
@@ -82,7 +82,8 @@ void ast_sip_sanitize_xml(const char *in
 }
 
 void ast_sip_presence_exten_state_to_str(int state, char **statestring, char **pidfstate,
-			       char **pidfnote, enum ast_sip_pidf_state *local_state)
+			       char **pidfnote, enum ast_sip_pidf_state *local_state,
+			       unsigned int notify_early_inuse_ringing)
 {
 	switch (state) {
 	case AST_EXTENSION_RINGING:
@@ -92,7 +93,11 @@ void ast_sip_presence_exten_state_to_str
 		*pidfnote = "Ringing";
 		break;
 	case (AST_EXTENSION_INUSE | AST_EXTENSION_RINGING):
-		*statestring = "confirmed";
+		if (notify_early_inuse_ringing) {
+			*statestring = "early";
+		} else {
+			*statestring = "confirmed";
+		}
 		*local_state = NOTIFY_INUSE;
 		*pidfstate = "busy";
 		*pidfnote = "Ringing";
diff -urpN asterisk-13.9.1/res/res_pjsip/security_events.c asterisk-13.17.0/res/res_pjsip/security_events.c
--- asterisk-13.9.1/res/res_pjsip/security_events.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip/security_events.c	2017-07-12 13:12:08.000000000 +0200
@@ -44,9 +44,9 @@ static enum ast_transport security_event
 	} else if (rdata->tp_info.transport->key.type == PJSIP_TRANSPORT_TLS ||
 		rdata->tp_info.transport->key.type == PJSIP_TRANSPORT_TLS6) {
 		return AST_TRANSPORT_TLS;
-	} else if (!strcmp(rdata->tp_info.transport->type_name, "WS")) {
+	} else if (!strcasecmp(rdata->tp_info.transport->type_name, "WS")) {
 		return AST_TRANSPORT_WS;
-	} else if (!strcmp(rdata->tp_info.transport->type_name, "WSS")) {
+	} else if (!strcasecmp(rdata->tp_info.transport->type_name, "WSS")) {
 		return AST_TRANSPORT_WSS;
 	} else {
 		return 0;
diff -urpN asterisk-13.9.1/res/res_pjsip.c asterisk-13.17.0/res/res_pjsip.c
--- asterisk-13.9.1/res/res_pjsip.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip.c	2017-07-12 13:12:08.000000000 +0200
@@ -24,6 +24,7 @@
 #include <pjsip/sip_transaction.h>
 #include <pj/timer.h>
 #include <pjlib.h>
+#include <pjmedia/errno.h>
 
 #include "asterisk/res_pjsip.h"
 #include "res_pjsip/include/res_pjsip_private.h"
@@ -99,6 +100,9 @@
 				<configOption name="allow">
 					<synopsis>Media Codec(s) to allow</synopsis>
 				</configOption>
+				<configOption name="allow_overlap" default="yes">
+					<synopsis>Enable RFC3578 overlap dialing support.</synopsis>
+				</configOption>
 				<configOption name="aors">
 					<synopsis>AoR(s) to be used with the endpoint</synopsis>
 					<description><para>
@@ -111,9 +115,15 @@
 						This is a comma-delimited list of <replaceable>auth</replaceable> sections defined
 						in <filename>pjsip.conf</filename> to be used to verify inbound connection attempts.
 						</para><para>
-						Endpoints without an <literal>authentication</literal> object
-						configured will allow connections without vertification.
-					</para></description>
+						Endpoints without an authentication object
+						configured will allow connections without verification.</para>
+						<note><para>
+						Using the same auth section for inbound and outbound
+						authentication is not recommended.  There is a difference in
+						meaning for an empty realm setting between inbound and outbound
+						authentication uses.  See the auth realm description for details.
+						</para></note>
+					</description>
 				</configOption>
 				<configOption name="callerid">
 					<synopsis>CallerID information for the endpoint</synopsis>
@@ -183,11 +193,18 @@
 					<description>
 						<para>Method used when updating connected line information.</para>
 						<enumlist>
-							<enum name="invite" />
+							<enum name="invite">
+							<para>When set to <literal>invite</literal>, check the remote's Allow header and
+							if UPDATE is allowed, send UPDATE instead of INVITE to avoid SDP
+							renegotiation.  If UPDATE is not Allowed, send INVITE.</para>
+							</enum>
 							<enum name="reinvite">
 								<para>Alias for the <literal>invite</literal> value.</para>
 							</enum>
-							<enum name="update" />
+							<enum name="update">
+							<para>If set to <literal>update</literal>, send UPDATE regardless of what the remote
+							Allows. </para>
+							</enum>
 						</enumlist>
 					</description>
 				</configOption>
@@ -216,10 +233,12 @@
 							<enum name="info">
 								<para>DTMF is sent as SIP INFO packets.</para>
 							</enum>
-                                                        <enum name="auto">
-                                                                <para>DTMF is sent as RFC 4733 if the other side supports it or as INBAND if not.</para>
-                                                        </enum>
-
+							<enum name="auto">
+								<para>DTMF is sent as RFC 4733 if the other side supports it or as INBAND if not.</para>
+							</enum>
+							<enum name="auto_info">
+								<para>DTMF is sent as RFC 4733 if the other side supports it or as SIP INFO if not.</para>
+							</enum>
 						</enumlist>
 					</description>
 				</configOption>
@@ -252,18 +271,35 @@
 				<configOption name="identify_by" default="username,location">
 					<synopsis>Way(s) for Endpoint to be identified</synopsis>
 					<description><para>
-						An endpoint can be identified in multiple ways. Currently, the only supported
-						option is <literal>username</literal>, which matches the endpoint based on the
-						username in the From header.
+						Endpoints and aors can be identified in multiple ways. Currently, the supported
+						options are <literal>username</literal>, which matches the endpoint or aor id based on
+						the username and domain in the From header (or To header for aors), and
+						<literal>auth_username</literal>, which matches the endpoint or aor id based on the
+						username and realm in the Authentication header.  In all cases, if an exact match
+						on both username and domain/realm fails, the match will be retried with just the username.
 						</para>
+						<note><para>
+						Identification by auth_username has some security considerations because an
+						Authentication header is not present on the first message of a dialog when
+						digest authentication is used.  The client can't generate it until the server
+						sends the challenge in a 401 response.  Since Asterisk normally sends a security
+						event when an incoming request can't be matched to an endpoint, using auth_username
+						requires that the security event be deferred until a request is received with
+						the Authentication header and only generated if the username doesn't result in a
+						match.  This may result in a delay before an attack is recognized.  You can control
+						how many unmatched requests are received from a single ip address before a security
+						event is generated using the unidentified_request parameters in the "global"
+						configuration object.
+						</para></note>
 						<note><para>Endpoints can also be identified by IP address; however, that method
 						of identification is not handled by this configuration option. See the documentation
 						for the <literal>identify</literal> configuration section for more details on that
-						method of endpoint identification. If this option is set to <literal>username</literal>
-						and an <literal>identify</literal> configuration section exists for the endpoint, then
-						the endpoint can be identified in multiple ways.</para></note>
+						method of endpoint identification. If this option is set and an <literal>identify</literal>
+						configuration section exists for the endpoint, then the endpoint can be identified in
+						multiple ways.</para></note>
 						<enumlist>
 							<enum name="username" />
+							<enum name="auth_username" />
 						</enumlist>
 					</description>
 				</configOption>
@@ -312,10 +348,21 @@
 					<synopsis>Default Music On Hold class</synopsis>
 				</configOption>
 				<configOption name="outbound_auth">
-					<synopsis>Authentication object used for outbound requests</synopsis>
+					<synopsis>Authentication object(s) used for outbound requests</synopsis>
+					<description><para>
+						This is a comma-delimited list of <replaceable>auth</replaceable>
+						sections defined in <filename>pjsip.conf</filename> used to respond
+						to outbound connection authentication challenges.</para>
+						<note><para>
+						Using the same auth section for inbound and outbound
+						authentication is not recommended.  There is a difference in
+						meaning for an empty realm setting between inbound and outbound
+						authentication uses.  See the auth realm description for details.
+						</para></note>
+					</description>
 				</configOption>
 				<configOption name="outbound_proxy">
-					<synopsis>Proxy through which to send requests, a full SIP URI must be provided</synopsis>
+					<synopsis>Full SIP URI of the outbound proxy used to send requests</synopsis>
 				</configOption>
 				<configOption name="rewrite_contact">
 					<synopsis>Allow Contact header to be rewritten with the source IP address-port</synopsis>
@@ -492,15 +539,15 @@
 				<configOption name="g726_non_standard" default="no">
 					<synopsis>Force g.726 to use AAL2 packing order when negotiating g.726 audio</synopsis>
 					<description><para>
-                                                When set to "yes" and an endpoint negotiates g.726 audio then use g.726 for AAL2
-                                                packing order instead of what is recommended by RFC3551. Since this essentially
-                                                replaces the underlying 'g726' codec with 'g726aal2' then 'g726aal2' needs to be
-                                                specified in the endpoint's allowed codec list.
+						When set to "yes" and an endpoint negotiates g.726 audio then use g.726 for AAL2
+						packing order instead of what is recommended by RFC3551. Since this essentially
+						replaces the underlying 'g726' codec with 'g726aal2' then 'g726aal2' needs to be
+						specified in the endpoint's allowed codec list.
 					</para></description>
 				</configOption>
 				<configOption name="inband_progress" default="no">
 					<synopsis>Determines whether chan_pjsip will indicate ringing using inband
-					    progress.</synopsis>
+						progress.</synopsis>
 					<description><para>
 						If set to <literal>yes</literal>, chan_pjsip will send a 183 Session Progress
 						when told to indicate ringing and will immediately start sending ringing
@@ -582,6 +629,14 @@
 						detected.
 					</para></description>
 				</configOption>
+				<configOption name="fax_detect_timeout">
+					<synopsis>How long into a call before fax_detect is disabled for the call</synopsis>
+					<description><para>
+						The option determines how many seconds into a call before the
+						fax_detect option is disabled for the call.  Setting the value
+						to zero disables the timeout.
+					</para></description>
+				</configOption>
 				<configOption name="t38_udptl_nat" default="no">
 					<synopsis>Whether NAT support is enabled on UDPTL sessions</synopsis>
 					<description><para>
@@ -785,7 +840,7 @@
 				<configOption name="set_var">
 					<synopsis>Variable set on a channel involving the endpoint.</synopsis>
 					<description><para>
-					        When a new channel is created using the endpoint set the specified
+						When a new channel is created using the endpoint set the specified
 						variable(s) on that channel. For multiple channel variables specify
 						multiple 'set_var'(s).
 					</para></description>
@@ -829,6 +884,104 @@
 						channel is hung up. By default this option is set to 0, which means do not check.
 					</para></description>
 				</configOption>
+				<configOption name="acl">
+					<synopsis>List of IP ACL section names in acl.conf</synopsis>
+					<description><para>
+						This matches sections configured in <literal>acl.conf</literal>. The value is
+						defined as a list of comma-delimited section names.
+					</para></description>
+				</configOption>
+				<configOption name="deny">
+					<synopsis>List of IP addresses to deny access from</synopsis>
+					<description><para>
+						The value is a comma-delimited list of IP addresses. IP addresses may
+						have a subnet mask appended. The subnet mask may be written in either
+						CIDR or dotted-decimal notation. Separate the IP address and subnet
+						mask with a slash ('/')
+					</para></description>
+				</configOption>
+				<configOption name="permit">
+					<synopsis>List of IP addresses to permit access from</synopsis>
+					<description><para>
+						The value is a comma-delimited list of IP addresses. IP addresses may
+						have a subnet mask appended. The subnet mask may be written in either
+						CIDR or dotted-decimal notation. Separate the IP address and subnet
+						mask with a slash ('/')
+					</para></description>
+				</configOption>
+				<configOption name="contact_acl">
+					<synopsis>List of Contact ACL section names in acl.conf</synopsis>
+					<description><para>
+						This matches sections configured in <literal>acl.conf</literal>. The value is
+						defined as a list of comma-delimited section names.
+					</para></description>
+				</configOption>
+				<configOption name="contact_deny">
+					<synopsis>List of Contact header addresses to deny</synopsis>
+					<description><para>
+						The value is a comma-delimited list of IP addresses. IP addresses may
+						have a subnet mask appended. The subnet mask may be written in either
+						CIDR or dotted-decimal notation. Separate the IP address and subnet
+						mask with a slash ('/')
+					</para></description>
+				</configOption>
+				<configOption name="contact_permit">
+					<synopsis>List of Contact header addresses to permit</synopsis>
+					<description><para>
+						The value is a comma-delimited list of IP addresses. IP addresses may
+						have a subnet mask appended. The subnet mask may be written in either
+						CIDR or dotted-decimal notation. Separate the IP address and subnet
+						mask with a slash ('/')
+					</para></description>
+				</configOption>
+				<configOption name="subscribe_context">
+					<synopsis>Context for incoming MESSAGE requests.</synopsis>
+					<description><para>
+						If specified, incoming SUBSCRIBE requests will be searched for the matching
+						extension in the indicated context.
+						If no <replaceable>subscribe_context</replaceable> is specified,
+						then the <replaceable>context</replaceable> setting is used.
+					</para></description>
+				</configOption>
+				<configOption name="contact_user" default="">
+					<synopsis>Force the user on the outgoing Contact header to this value.</synopsis>
+					<description><para>
+						On outbound requests, force the user portion of the Contact header to this value.
+					</para></description>
+				</configOption>
+				<configOption name="asymmetric_rtp_codec" default="no">
+					<synopsis>Allow the sending and receiving RTP codec to differ</synopsis>
+					<description><para>
+						When set to "yes" the codec in use for sending will be allowed to differ from
+						that of the received one. PJSIP will not automatically switch the sending one
+						to the receiving one.
+					</para></description>
+				</configOption>
+				<configOption name="rtcp_mux" default="no">
+					<synopsis>Enable RFC 5761 RTCP multiplexing on the RTP port</synopsis>
+					<description><para>
+						With this option enabled, Asterisk will attempt to negotiate the use of the "rtcp-mux"
+						attribute on all media streams. This will result in RTP and RTCP being sent and received
+						on the same port. This shifts the demultiplexing logic to the application rather than
+						the transport layer. This option is useful when interoperating with WebRTC endpoints
+						since they mandate this option's use.
+					</para></description>
+				</configOption>
+				<configOption name="refer_blind_progress" default="yes">
+					<synopsis>Whether to notifies all the progress details on blind transfer</synopsis>
+					<description><para>
+						Some SIP phones (Mitel/Aastra, Snom) expect a sip/frag "200 OK"
+						after REFER has been accepted. If set to <literal>no</literal> then asterisk
+						will not send the progress details, but immediately will send "200 OK".
+					</para></description>
+				</configOption>
+				<configOption name="notify_early_inuse_ringing" default="no">
+					<synopsis>Whether to notifies dialog-info 'early' on InUse&amp;Ringing state</synopsis>
+					<description><para>
+						Control whether dialog-info subscriptions get 'early' state
+						on Ringing when already INUSE.
+					</para></description>
+				</configOption>
 			</configObject>
 			<configObject name="auth">
 				<synopsis>Authentication type</synopsis>
@@ -863,8 +1016,30 @@
 					<synopsis>PlainText password used for authentication.</synopsis>
 					<description><para>Only used when auth_type is <literal>userpass</literal>.</para></description>
 				</configOption>
-				<configOption name="realm" default="asterisk">
+				<configOption name="realm">
 					<synopsis>SIP realm for endpoint</synopsis>
+					<description><para>
+						The treatment of this value depends upon how the authentication
+						object is used.
+						</para><para>
+						When used as an inbound authentication object, the realm is sent
+						as part of the challenge so the peer can know which key to use
+						when responding.  An empty value will use the
+						<replaceable>global</replaceable> section's
+						<literal>default_realm</literal> value when issuing a challenge.
+						</para><para>
+						When used as an outbound authentication object, the realm is
+						matched with the received challenge realm to determine which
+						authentication object to use when responding to the challenge.  An
+						empty value matches any challenging realm when determining
+						which authentication object matches a received challenge.
+						</para>
+						<note><para>
+						Using the same auth section for inbound and outbound
+						authentication is not recommended.  There is a difference in
+						meaning for an empty realm setting between inbound and outbound
+						authentication uses.</para></note>
+					</description>
 				</configOption>
 				<configOption name="type">
 					<synopsis>Must be 'auth'</synopsis>
@@ -1040,6 +1215,22 @@
 						in-progress calls.</para>
 					</description>
 				</configOption>
+				<configOption name="symmetric_transport" default="no">
+					<synopsis>Use the same transport for outgoing reqests as incoming ones.</synopsis>
+					<description>
+						<para>When a request from a dynamic contact
+							comes in on a transport with this option set to 'yes',
+							the transport name will be saved and used for subsequent
+							outgoing requests like OPTIONS, NOTIFY and INVITE.  It's
+							saved as a contact uri parameter named 'x-ast-txp' and will
+							display with the contact uri in CLI, AMI, and ARI output.
+							On the outgoing request, if a transport wasn't explicitly
+							set on the endpoint AND the request URI is not a hostname,
+							the saved transport will be used and the 'x-ast-txp'
+							parameter stripped from the outgoing packet.
+						</para>
+					</description>
+				</configOption>
 			</configObject>
 			<configObject name="contact">
 				<synopsis>A way of creating an aliased name to a SIP URI</synopsis>
@@ -1075,6 +1266,13 @@
 						If <literal>0</literal> no timeout. Time in fractional seconds.
 					</para></description>
 				</configOption>
+				<configOption name="authenticate_qualify" default="no">
+					<synopsis>Authenticates a qualify request if needed</synopsis>
+					<description><para>
+						If true and a qualify request receives a challenge or authenticate response
+						authentication is attempted before declaring the contact available.
+					</para></description>
+				</configOption>
 				<configOption name="outbound_proxy">
 					<synopsis>Outbound proxy used when sending OPTIONS request</synopsis>
 					<description><para>
@@ -1092,6 +1290,40 @@
 						REGISTER requests and is not intended to be configured manually.
 					</para></description>
 				</configOption>
+				<configOption name="endpoint">
+					<synopsis>Endpoint name</synopsis>
+					<description><para>
+						The name of the endpoint this contact belongs to
+					</para></description>
+				</configOption>
+				<configOption name="reg_server">
+					<synopsis>Asterisk Server name</synopsis>
+					<description><para>
+						Asterisk Server name on which SIP endpoint registered.
+					</para></description>
+				</configOption>
+				<configOption name="via_addr">
+					<synopsis>IP-address of the last Via header from registration.</synopsis>
+					<description><para>
+						The last Via header should contain the address of UA which sent the request.
+						The IP-address of the last Via header is automatically stored based on data present
+						in incoming SIP REGISTER requests and is not intended to be configured manually.
+					</para></description>
+				</configOption>
+				<configOption name="via_port">
+					<synopsis>IP-port of the last Via header from registration.</synopsis>
+					<description><para>
+						The IP-port of the last Via header is automatically stored based on data present
+						in incoming SIP REGISTER requests and is not intended to be configured manually.
+					</para></description>
+				</configOption>
+				<configOption name="call_id">
+					<synopsis>Call-ID header from registration.</synopsis>
+					<description><para>
+						The Call-ID header is automatically stored based on data present
+						in incoming SIP REGISTER requests and is not intended to be configured manually.
+					</para></description>
+				</configOption>
 			</configObject>
 			<configObject name="aor">
 				<synopsis>The configuration for a location of an endpoint</synopsis>
@@ -1291,10 +1523,34 @@
 				<configOption name="contact_expiration_check_interval" default="30">
 					<synopsis>The interval (in seconds) to check for expired contacts.</synopsis>
 				</configOption>
+				<configOption name="disable_multi_domain" default="no">
+					<synopsis>Disable Multi Domain support</synopsis>
+					<description><para>
+						If disabled it can improve realtime performace by reducing number of database requsts.
+					</para></description>
+				</configOption>
 				<configOption name="max_initial_qualify_time" default="0">
 					<synopsis>The maximum amount of time from startup that qualifies should be attempted on all contacts.
 					If greater than the qualify_frequency for an aor, qualify_frequency will be used instead.</synopsis>
 				</configOption>
+				<configOption name="unidentified_request_period" default="5">
+					<synopsis>The number of seconds over which to accumulate unidentified requests.</synopsis>
+					<description><para>
+					If <literal>unidentified_request_count</literal> unidentified requests are received
+					during <literal>unidentified_request_period</literal>, a security event will be generated.
+					</para></description>
+				</configOption>
+				<configOption name="unidentified_request_count" default="5">
+					<synopsis>The number of unidentified requests from a single IP to allow.</synopsis>
+					<description><para>
+					If <literal>unidentified_request_count</literal> unidentified requests are received
+					during <literal>unidentified_request_period</literal>, a security event will be generated.
+					</para></description>
+				</configOption>
+				<configOption name="unidentified_request_prune_interval" default="30">
+					<synopsis>The interval at which unidentified requests are older than
+					twice the unidentified_request_period are pruned.</synopsis>
+				</configOption>
 				<configOption name="type">
 					<synopsis>Must be of type 'global'.</synopsis>
 				</configOption>
@@ -1302,9 +1558,9 @@
 					<synopsis>Value used in User-Agent header for SIP requests and Server header for SIP responses.</synopsis>
 				</configOption>
 				<configOption name="regcontext" default="">
-                                        <synopsis>When set, Asterisk will dynamically create and destroy a NoOp priority 1 extension for a given
-					peer who registers or unregisters with us.</synopsis>
-                                </configOption>
+					<synopsis>When set, Asterisk will dynamically create and destroy a NoOp priority 1 extension for a given
+						peer who registers or unregisters with us.</synopsis>
+				</configOption>
 				<configOption name="default_outbound_endpoint" default="default_outbound_endpoint">
 					<synopsis>Endpoint to use when sending an outbound request to a URI without a specified endpoint.</synopsis>
 				</configOption>
@@ -1313,17 +1569,105 @@
 				</configOption>
 				<configOption name="debug" default="no">
 					<synopsis>Enable/Disable SIP debug logging.  Valid options include yes|no or
-                                        a host address</synopsis>
+						a host address</synopsis>
 				</configOption>
 				<configOption name="endpoint_identifier_order" default="ip,username,anonymous">
 					<synopsis>The order by which endpoint identifiers are processed and checked.
-                                        Identifier names are usually derived from and can be found in the endpoint
-                                        identifier module itself (res_pjsip_endpoint_identifier_*)</synopsis>
+						Identifier names are usually derived from and can be found in the endpoint
+						identifier module itself (res_pjsip_endpoint_identifier_*).
+						You can use the CLI command "pjsip show identifiers" to see the
+						identifiers currently available.</synopsis>
+					<description>
+						<note><para>
+						One of the identifiers is "auth_username" which matches on the username in
+						an Authentication header.  This method has some security considerations because an
+						Authentication header is not present on the first message of a dialog when
+						digest authentication is used.  The client can't generate it until the server
+						sends the challenge in a 401 response.  Since Asterisk normally sends a security
+						event when an incoming request can't be matched to an endpoint, using auth_username
+						requires that the security event be deferred until a request is received with
+						the Authentication header and only generated if the username doesn't result in a
+						match.  This may result in a delay before an attack is recognized.  You can control
+						how many unmatched requests are received from a single ip address before a security
+						event is generated using the unidentified_request parameters.
+						</para></note>
+					</description>
 				</configOption>
 				<configOption name="default_from_user" default="asterisk">
 					<synopsis>When Asterisk generates an outgoing SIP request, the From header username will be
-                                        set to this value if there is no better option (such as CallerID) to be
-                                        used.</synopsis>
+						set to this value if there is no better option (such as CallerID) to be
+						used.</synopsis>
+				</configOption>
+				<configOption name="default_realm" default="asterisk">
+					<synopsis>When Asterisk generates a challenge, the digest realm will be
+						set to this value if there is no better option (such as auth/realm) to be
+						used.</synopsis>
+				</configOption>
+				<configOption name="mwi_tps_queue_high" default="500">
+					<synopsis>MWI taskprocessor high water alert trigger level.</synopsis>
+					<description>
+						<para>On a heavily loaded system you may need to adjust the
+						taskprocessor queue limits.  If any taskprocessor queue size
+						reaches its high water level then pjsip will stop processing
+						new requests until the alert is cleared.  The alert clears
+						when all alerting taskprocessor queues have dropped to their
+						low water clear level.
+						</para>
+					</description>
+				</configOption>
+				<configOption name="mwi_tps_queue_low" default="-1">
+					<synopsis>MWI taskprocessor low water clear alert level.</synopsis>
+					<description>
+						<para>On a heavily loaded system you may need to adjust the
+						taskprocessor queue limits.  If any taskprocessor queue size
+						reaches its high water level then pjsip will stop processing
+						new requests until the alert is cleared.  The alert clears
+						when all alerting taskprocessor queues have dropped to their
+						low water clear level.
+						</para>
+						<note><para>Set to -1 for the low water level to be 90% of
+						the high water level.</para></note>
+					</description>
+				</configOption>
+				<configOption name="mwi_disable_initial_unsolicited" default="no">
+					<synopsis>Enable/Disable sending unsolicited MWI to all endpoints on startup.</synopsis>
+					<description>
+						<para>When the initial unsolicited MWI notification are
+						enabled on startup then the initial notifications
+						get sent at startup.  If you have a lot of endpoints
+						(thousands) that use unsolicited MWI then you may
+						want to consider disabling the initial startup
+						notifications.
+						</para>
+						<para>When the initial unsolicited MWI notifications are
+						disabled on startup then the notifications will start
+						on the endpoint's next contact update.
+						</para>
+					</description>
+				</configOption>
+				<configOption name="ignore_uri_user_options">
+					<synopsis>Enable/Disable ignoring SIP URI user field options.</synopsis>
+					<description>
+						<para>If you have this option enabled and there are semicolons
+						in the user field of a SIP URI then the field is truncated
+						at the first semicolon.  This effectively makes the semicolon
+						a non-usable character for PJSIP endpoint names, extensions,
+						and AORs.  This can be useful for improving compatability with
+						an ITSP that likes to use user options for whatever reason.
+						</para>
+						<example title="Sample SIP URI">
+							sip:1235557890;phone-context=national@x.x.x.x;user=phone
+						</example>
+						<example title="Sample SIP URI user field">
+							1235557890;phone-context=national
+						</example>
+						<example title="Sample SIP URI user field truncated">
+							1235557890
+						</example>
+						<note><para>The caller-id and redirecting number strings
+						obtained from incoming SIP URI user fields are always truncated
+						at the first semicolon.</para></note>
+					</description>
 				</configOption>
 			</configObject>
 		</configFile>
@@ -1803,6 +2147,12 @@
 				<parameter name="ActiveChannels">
 					<para>The number of active channels associated with this endpoint.</para>
 				</parameter>
+				<parameter name="SubscribeContext">
+					<para><xi:include xpointer="xpointer(/docs/configInfo[@name='res_pjsip']/configFile[@name='pjsip.conf']/configObject[@name='endpoint']/configOption[@name='subscribe_context']/synopsis/node())"/></para>
+				</parameter>
+				<parameter name="Allowoverlap">
+					<para><xi:include xpointer="xpointer(/docs/configInfo[@name='res_pjsip']/configFile[@name='pjsip.conf']/configObject[@name='endpoint']/configOption[@name='allow_overlap']/synopsis/node())"/></para>
+				</parameter>
 			</syntax>
 		</managerEventInstance>
 	</managerEvent>
@@ -1835,6 +2185,33 @@
 				<parameter name="RegExpire">
 					<para>Absolute time that this contact is no longer valid after</para>
 				</parameter>
+				<parameter name="ViaAddress">
+					<para>IP address:port of the last Via header in REGISTER request.
+					Will only appear in the event if available.</para>
+				</parameter>
+				<parameter name="CallID">
+					<para>Content of the Call-ID header in REGISTER request.
+					Will only appear in the event if available.</para>
+				</parameter>
+				<parameter name="ID">
+					<para>The sorcery ID of the contact.</para>
+				</parameter>
+				<parameter name="AuthenticateQualify">
+					<para>A boolean indicating whether a qualify should be authenticated.</para>
+				</parameter>
+				<parameter name="OutboundProxy">
+					<para>The contact's outbound proxy.</para>
+				</parameter>
+				<parameter name="Path">
+					<para>The Path header received on the REGISTER.</para>
+				</parameter>
+				<parameter name="QualifyFrequency">
+					<para>The interval in seconds at which the contact will be qualified.</para>
+				</parameter>
+				<parameter name="QualifyTimeout">
+					<para>The elapsed time in decimal seconds after which an OPTIONS
+					message is sent before the contact is considered unavailable.</para>
+				</parameter>
 			</syntax>
 		</managerEventInstance>
 	</managerEvent>
@@ -1879,7 +2256,7 @@
 			Provides a listing of all endpoints.  For each endpoint an <literal>EndpointList</literal> event
 			is raised that contains relevant attributes and status information.  Once all
 			endpoints have been listed an <literal>EndpointListComplete</literal> event is issued.
-                        </para>
+			</para>
 		</description>
 		<responses>
 			<list-elements>
@@ -1915,7 +2292,7 @@
 			<literal>IdentifyDetail</literal>.  Some events may be listed multiple times if multiple objects are
 			associated (for instance AoRs).  Once all detail events have been raised a final
 			<literal>EndpointDetailComplete</literal> event is issued.
-                        </para>
+			</para>
 		</description>
 		<responses>
 			<list-elements>
@@ -1958,13 +2335,13 @@ static struct ast_threadpool *sip_thread
 static pj_sockaddr host_ip_ipv4;
 
 /*! Local host address for IPv4 (string form) */
-static char host_ip_ipv4_string[PJ_INET6_ADDRSTRLEN + 2];
+static char host_ip_ipv4_string[PJ_INET6_ADDRSTRLEN];
 
 /*! Local host address for IPv6 */
 static pj_sockaddr host_ip_ipv6;
 
 /*! Local host address for IPv6 (string form) */
-static char host_ip_ipv6_string[PJ_INET6_ADDRSTRLEN + 2];
+static char host_ip_ipv6_string[PJ_INET6_ADDRSTRLEN];
 
 static int register_service_noref(void *data)
 {
@@ -2075,7 +2452,7 @@ enum ast_sip_check_auth_result ast_sip_c
 {
 	if (!registered_authenticator) {
 		ast_log(LOG_WARNING, "No SIP authenticator registered. Assuming authentication is successful\n");
-		return 0;
+		return AST_SIP_AUTHENTICATION_SUCCESS;
 	}
 	return registered_authenticator->check_authentication(endpoint, rdata, tdata);
 }
@@ -2430,12 +2807,59 @@ pjsip_endpoint *ast_sip_get_pjsip_endpoi
 	return ast_pjsip_endpoint;
 }
 
-static int sip_dialog_create_from(pj_pool_t *pool, pj_str_t *from, const char *user, const char *domain, const pj_str_t *target, pjsip_tpselector *selector)
+int ast_sip_get_transport_name(const struct ast_sip_endpoint *endpoint,
+	pjsip_sip_uri *sip_uri, char *buf, size_t buf_len)
+{
+	char *host = NULL;
+	static const pj_str_t x_name = { AST_SIP_X_AST_TXP, AST_SIP_X_AST_TXP_LEN };
+	pjsip_param *x_transport;
+
+	if (!ast_strlen_zero(endpoint->transport)) {
+		ast_copy_string(buf, endpoint->transport, buf_len);
+		return 0;
+	}
+
+	x_transport = pjsip_param_find(&sip_uri->other_param, &x_name);
+	if (!x_transport) {
+		return -1;
+	}
+
+	/* Only use x_transport if the uri host is an ip (4 or 6) address */
+	host = ast_alloca(sip_uri->host.slen + 1);
+	ast_copy_pj_str(host, &sip_uri->host, sip_uri->host.slen + 1);
+	if (!ast_sockaddr_parse(NULL, host, PARSE_PORT_FORBID)) {
+		return -1;
+	}
+
+	ast_copy_pj_str(buf, &x_transport->value, buf_len);
+
+	return 0;
+}
+
+int ast_sip_dlg_set_transport(const struct ast_sip_endpoint *endpoint, pjsip_dialog *dlg,
+	pjsip_tpselector *selector)
+{
+	pjsip_sip_uri *uri;
+	pjsip_tpselector sel = { .type = PJSIP_TPSELECTOR_NONE, };
+
+	uri = pjsip_uri_get_uri(dlg->target);
+	if (!selector) {
+		selector = &sel;
+	}
+
+	ast_sip_set_tpselector_from_ep_or_uri(endpoint, uri, selector);
+	pjsip_dlg_set_transport(dlg, selector);
+
+	return 0;
+}
+
+static int sip_dialog_create_from(pj_pool_t *pool, pj_str_t *from, const char *user,
+	const char *domain, const pj_str_t *target, pjsip_tpselector *selector)
 {
 	pj_str_t tmp, local_addr;
 	pjsip_uri *uri;
 	pjsip_sip_uri *sip_uri;
-	pjsip_transport_type_e type = PJSIP_TRANSPORT_UNSPECIFIED;
+	pjsip_transport_type_e type;
 	int local_port;
 	char default_user[PJSIP_MAX_URL_SIZE];
 
@@ -2455,21 +2879,21 @@ static int sip_dialog_create_from(pj_poo
 	sip_uri = pjsip_uri_get_uri(uri);
 
 	/* Determine the transport type to use */
+	type = pjsip_transport_get_type_from_name(&sip_uri->transport_param);
 	if (PJSIP_URI_SCHEME_IS_SIPS(sip_uri)) {
-		type = PJSIP_TRANSPORT_TLS;
+		if (type == PJSIP_TRANSPORT_UNSPECIFIED
+			|| !(pjsip_transport_get_flag_from_type(type) & PJSIP_TRANSPORT_SECURE)) {
+			type = PJSIP_TRANSPORT_TLS;
+		}
 	} else if (!sip_uri->transport_param.slen) {
 		type = PJSIP_TRANSPORT_UDP;
-	} else {
-		type = pjsip_transport_get_type_from_name(&sip_uri->transport_param);
-	}
-
-	if (type == PJSIP_TRANSPORT_UNSPECIFIED) {
+	} else if (type == PJSIP_TRANSPORT_UNSPECIFIED) {
 		return -1;
 	}
 
 	/* If the host is IPv6 turn the transport into an IPv6 version */
-	if (pj_strchr(&sip_uri->host, ':') && type < PJSIP_TRANSPORT_START_OTHER) {
-		type = (pjsip_transport_type_e)(((int)type) + PJSIP_TRANSPORT_IPV6);
+	if (pj_strchr(&sip_uri->host, ':')) {
+		type |= PJSIP_TRANSPORT_IPV6;
 	}
 
 	if (!ast_strlen_zero(domain)) {
@@ -2493,8 +2917,8 @@ static int sip_dialog_create_from(pj_poo
 	}
 
 	/* If IPv6 was specified in the transport, set the proper type */
-	if (pj_strchr(&local_addr, ':') && type < PJSIP_TRANSPORT_START_OTHER) {
-		type = (pjsip_transport_type_e)(((int)type) + PJSIP_TRANSPORT_IPV6);
+	if (pj_strchr(&local_addr, ':')) {
+		type |= PJSIP_TRANSPORT_IPV6;
 	}
 
 	from->ptr = pj_pool_alloc(pool, PJSIP_MAX_URL_SIZE);
@@ -2560,15 +2984,16 @@ int ast_sip_set_tpselector_from_transpor
 	return ast_sip_set_tpselector_from_transport(transport, selector);
 }
 
-static int sip_get_tpselector_from_endpoint(const struct ast_sip_endpoint *endpoint, pjsip_tpselector *selector)
+int ast_sip_set_tpselector_from_ep_or_uri(const struct ast_sip_endpoint *endpoint,
+	pjsip_sip_uri *sip_uri, pjsip_tpselector *selector)
 {
-	const char *transport_name = endpoint->transport;
+	char transport_name[128];
 
-	if (ast_strlen_zero(transport_name)) {
+	if (ast_sip_get_transport_name(endpoint, sip_uri, transport_name, sizeof(transport_name))) {
 		return 0;
 	}
 
-	return ast_sip_set_tpselector_from_transport_name(endpoint->transport, selector);
+	return ast_sip_set_tpselector_from_transport_name(transport_name, selector);
 }
 
 void ast_sip_add_usereqphone(const struct ast_sip_endpoint *endpoint, pj_pool_t *pool, pjsip_uri *uri)
@@ -2576,8 +3001,8 @@ void ast_sip_add_usereqphone(const struc
 	pjsip_sip_uri *sip_uri;
 	int i = 0;
 	pjsip_param *param;
-	const pj_str_t STR_USER = { "user", 4 };
-	const pj_str_t STR_PHONE = { "phone", 5 };
+	static const pj_str_t STR_USER = { "user", 4 };
+	static const pj_str_t STR_PHONE = { "phone", 5 };
 
 	if (!endpoint || !endpoint->usereqphone || (!PJSIP_URI_SCHEME_IS_SIP(uri) && !PJSIP_URI_SCHEME_IS_SIPS(uri))) {
 		return;
@@ -2610,7 +3035,8 @@ void ast_sip_add_usereqphone(const struc
 	pj_list_insert_before(&sip_uri->other_param, param);
 }
 
-pjsip_dialog *ast_sip_create_dialog_uac(const struct ast_sip_endpoint *endpoint, const char *uri, const char *request_user)
+pjsip_dialog *ast_sip_create_dialog_uac(const struct ast_sip_endpoint *endpoint,
+	const char *uri, const char *request_user)
 {
 	char enclosed_uri[PJSIP_MAX_URL_SIZE];
 	pj_str_t local_uri = { "sip:temp@temp", 13 }, remote_uri, target_uri;
@@ -2628,18 +3054,20 @@ pjsip_dialog *ast_sip_create_dialog_uac(
 	res = pjsip_dlg_create_uac(pjsip_ua_instance(), &local_uri, NULL, &remote_uri, &target_uri, &dlg);
 	if (res != PJ_SUCCESS) {
 		if (res == PJSIP_EINVALIDURI) {
-			ast_log(LOG_ERROR, "Could not create dialog to endpoint '%s' as URI '%s' is not valid\n",
+			ast_log(LOG_ERROR,
+				"Endpoint '%s': Could not create dialog to invalid URI '%s'.  Is endpoint registered and reachable?\n",
 				ast_sorcery_object_get_id(endpoint), uri);
 		}
 		return NULL;
 	}
 
-	if (sip_get_tpselector_from_endpoint(endpoint, &selector)) {
-		pjsip_dlg_terminate(dlg);
-		return NULL;
-	}
+	/* We have to temporarily bump up the sess_count here so the dialog is not prematurely destroyed */
+	dlg->sess_count++;
+
+	ast_sip_dlg_set_transport(endpoint, dlg, &selector);
 
 	if (sip_dialog_create_from(dlg->pool, &local_uri, endpoint->fromuser, endpoint->fromdomain, &remote_uri, &selector)) {
+		dlg->sess_count--;
 		pjsip_dlg_terminate(dlg);
 		return NULL;
 	}
@@ -2647,8 +3075,16 @@ pjsip_dialog *ast_sip_create_dialog_uac(
 	/* Update the dialog with the new local URI, we do it afterwards so we can use the dialog pool for construction */
 	pj_strdup_with_null(dlg->pool, &dlg->local.info_str, &local_uri);
 	dlg->local.info->uri = pjsip_parse_uri(dlg->pool, dlg->local.info_str.ptr, dlg->local.info_str.slen, 0);
+
 	dlg->local.contact = pjsip_parse_hdr(dlg->pool, &HCONTACT, local_uri.ptr, local_uri.slen, NULL);
 
+	if (!ast_strlen_zero(endpoint->contact_user)) {
+		pjsip_sip_uri *sip_uri;
+
+		sip_uri = pjsip_uri_get_uri(dlg->local.contact->uri);
+		pj_strdup2(dlg->pool, &sip_uri->user, endpoint->contact_user);
+	}
+
 	/* If a request user has been specified and we are permitted to change it, do so */
 	if (!ast_strlen_zero(request_user)) {
 		pjsip_sip_uri *sip_uri;
@@ -2667,11 +3103,6 @@ pjsip_dialog *ast_sip_create_dialog_uac(
 	ast_sip_add_usereqphone(endpoint, dlg->pool, dlg->target);
 	ast_sip_add_usereqphone(endpoint, dlg->pool, dlg->remote.info->uri);
 
-	/* We have to temporarily bump up the sess_count here so the dialog is not prematurely destroyed */
-	dlg->sess_count++;
-
-	pjsip_dlg_set_transport(dlg, &selector);
-
 	if (!ast_strlen_zero(outbound_proxy)) {
 		pjsip_route_hdr route_set, *route;
 		static const pj_str_t ROUTE_HNAME = { "Route", 5 };
@@ -2740,10 +3171,13 @@ pjsip_dialog *ast_sip_create_dialog_uas(
 	pjsip_transport_type_e type = rdata->tp_info.transport->key.type;
 	pjsip_tpselector selector = { .type = PJSIP_TPSELECTOR_NONE, };
 	pjsip_transport *transport;
+	pjsip_contact_hdr *contact_hdr;
 
 	ast_assert(status != NULL);
 
-	if (sip_get_tpselector_from_endpoint(endpoint, &selector)) {
+	contact_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);
+	if (ast_sip_set_tpselector_from_ep_or_uri(endpoint, pjsip_uri_get_uri(contact_hdr->uri),
+		&selector)) {
 		return NULL;
 	}
 
@@ -2789,8 +3223,8 @@ pjsip_dialog *ast_sip_create_dialog_uas(
 	return dlg;
 }
 
-int ast_sip_create_rdata(pjsip_rx_data *rdata, char *packet, const char *src_name, int src_port,
-	char *transport_type, const char *local_name, int local_port)
+int ast_sip_create_rdata_with_contact(pjsip_rx_data *rdata, char *packet, const char *src_name, int src_port,
+	char *transport_type, const char *local_name, int local_port, const char *contact)
 {
 	pj_str_t tmp;
 
@@ -2814,6 +3248,16 @@ int ast_sip_create_rdata(pjsip_rx_data *
 		return -1;
 	}
 
+	if (!ast_strlen_zero(contact)) {
+		pjsip_contact_hdr *contact_hdr;
+
+		contact_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);
+		if (contact_hdr) {
+			contact_hdr->uri = pjsip_parse_uri(rdata->tp_info.pool, (char *)contact,
+				strlen(contact), PJSIP_PARSE_URI_AS_NAMEADDR);
+		}
+	}
+
 	pj_strdup2(rdata->tp_info.pool, &rdata->msg_info.via->recvd_param, rdata->pkt_info.src_name);
 	rdata->msg_info.via->rport_param = -1;
 
@@ -2825,6 +3269,13 @@ int ast_sip_create_rdata(pjsip_rx_data *
 	return 0;
 }
 
+int ast_sip_create_rdata(pjsip_rx_data *rdata, char *packet, const char *src_name, int src_port,
+	char *transport_type, const char *local_name, int local_port)
+{
+	return ast_sip_create_rdata_with_contact(rdata, packet, src_name, src_port, transport_type,
+		local_name, local_port, NULL);
+}
+
 /* PJSIP doesn't know about the INFO method, so we have to define it ourselves */
 static const pjsip_method info_method = {PJSIP_OTHER_METHOD, {"INFO", 4} };
 static const pjsip_method message_method = {PJSIP_OTHER_METHOD, {"MESSAGE", 7} };
@@ -2906,14 +3357,6 @@ static int create_out_of_dialog_request(
 		pj_cstr(&remote_uri, uri);
 	}
 
-	if (endpoint) {
-		if (sip_get_tpselector_from_endpoint(endpoint, &selector)) {
-			ast_log(LOG_ERROR, "Unable to retrieve PJSIP transport selector for endpoint %s\n",
-				ast_sorcery_object_get_id(endpoint));
-			return -1;
-		}
-	}
-
 	pool = pjsip_endpt_create_pool(ast_sip_get_pjsip_endpoint(), "Outbound request", 256, 256);
 
 	if (!pool) {
@@ -2931,6 +3374,8 @@ static int create_out_of_dialog_request(
 		return -1;
 	}
 
+	ast_sip_set_tpselector_from_ep_or_uri(endpoint, pjsip_uri_get_uri(sip_uri), &selector);
+
 	fromuser = endpoint ? (!ast_strlen_zero(endpoint->fromuser) ? endpoint->fromuser : ast_sorcery_object_get_id(endpoint)) : NULL;
 	if (sip_dialog_create_from(pool, &from, fromuser,
 				endpoint ? endpoint->fromdomain : NULL, &remote_uri, &selector)) {
@@ -2950,6 +3395,21 @@ static int create_out_of_dialog_request(
 		return -1;
 	}
 
+	pjsip_tx_data_set_transport(*tdata, &selector);
+
+	if (endpoint && !ast_strlen_zero(endpoint->contact_user)){
+		pjsip_contact_hdr *contact_hdr;
+		pjsip_sip_uri *contact_uri;
+		static const pj_str_t HCONTACT = { "Contact", 7 };
+		static const pj_str_t HCONTACTSHORT = { "m", 1 };
+
+		contact_hdr = pjsip_msg_find_hdr_by_names((*tdata)->msg, &HCONTACT, &HCONTACTSHORT, NULL);
+		if (contact_hdr) {
+			contact_uri = pjsip_uri_get_uri(contact_hdr->uri);
+			pj_strdup2(pool, &contact_uri->user, endpoint->contact_user);
+		}
+	}
+
 	/* Add the user=phone parameter if applicable */
 	ast_sip_add_usereqphone(endpoint, (*tdata)->pool, (*tdata)->msg->line.req.uri);
 
@@ -2978,6 +3438,8 @@ int ast_sip_create_request(const char *m
 {
 	const pjsip_method *pmethod = get_pjsip_method(method);
 
+	ast_assert(endpoint != NULL);
+
 	if (!pmethod) {
 		ast_log(LOG_WARNING, "Unknown method '%s'. Cannot send request\n", method);
 		return -1;
@@ -3099,6 +3561,8 @@ struct send_request_wrapper {
 	void (*callback)(void *token, pjsip_event *e);
 	/*! Non-zero when the callback is called. */
 	unsigned int cb_called;
+	/*! Non-zero if endpt_send_request_cb() was called. */
+	unsigned int send_cb_called;
 	/*! Timeout timer. */
 	pj_timer_entry *timeout_timer;
 	/*! Original timeout. */
@@ -3114,6 +3578,13 @@ struct send_request_wrapper {
 static void endpt_send_request_cb(void *token, pjsip_event *e)
 {
 	struct send_request_wrapper *req_wrapper = token;
+	unsigned int cb_called;
+
+	/*
+	 * Needed because we cannot otherwise tell if this callback was
+	 * called when pjsip_endpt_send_request() returns error.
+	 */
+	req_wrapper->send_cb_called = 1;
 
 	if (e->body.tsx_state.type == PJSIP_EVENT_TIMER) {
 		ast_debug(2, "%p: PJSIP tsx timer expired\n", req_wrapper);
@@ -3143,7 +3614,6 @@ static void endpt_send_request_cb(void *
 		timers_cancelled = pj_timer_heap_cancel_if_active(
 			pjsip_endpt_get_timer_heap(ast_sip_get_pjsip_endpoint()),
 			req_wrapper->timeout_timer, TIMER_INACTIVE);
-
 		if (timers_cancelled > 0) {
 			/* If the timer was cancelled the callback will never run so
 			 * clean up its reference to the wrapper.
@@ -3151,25 +3621,27 @@ static void endpt_send_request_cb(void *
 			ast_debug(3, "%p: Timer cancelled\n", req_wrapper);
 			ao2_ref(req_wrapper, -1);
 		} else {
-			/* If it wasn't cancelled, it MAY be in the callback already
-			 * waiting on the lock so set the id to INACTIVE so
-			 * when the callback comes out of the lock, it knows to not
-			 * proceed.
+			/*
+			 * If it wasn't cancelled, it MAY be in the callback already
+			 * waiting on the lock.  When we release the lock, it will
+			 * now know not to proceed.
 			 */
 			ast_debug(3, "%p: Timer already expired\n", req_wrapper);
-			req_wrapper->timeout_timer->id = TIMER_INACTIVE;
 		}
 	}
 
+	cb_called = req_wrapper->cb_called;
+	req_wrapper->cb_called = 1;
+	ao2_unlock(req_wrapper);
+
 	/* It's possible that our own timer expired and called the callbacks
 	 * so no need to call them again.
 	 */
-	if (!req_wrapper->cb_called && req_wrapper->callback) {
+	if (!cb_called && req_wrapper->callback) {
 		req_wrapper->callback(req_wrapper->token, e);
-		req_wrapper->cb_called = 1;
 		ast_debug(2, "%p: Callbacks executed\n", req_wrapper);
 	}
-	ao2_unlock(req_wrapper);
+
 	ao2_ref(req_wrapper, -1);
 }
 
@@ -3180,15 +3652,16 @@ static void endpt_send_request_cb(void *
  */
 static void send_request_timer_callback(pj_timer_heap_t *theap, pj_timer_entry *entry)
 {
-	pjsip_event event;
 	struct send_request_wrapper *req_wrapper = entry->user_data;
+	unsigned int cb_called;
 
 	ast_debug(2, "%p: Internal tsx timer expired after %d msec\n",
 		req_wrapper, req_wrapper->timeout);
 
 	ao2_lock(req_wrapper);
-	/* If the id is not TIMEOUT_TIMER2 then the timer was cancelled above
-	 * while the lock was being held so just clean up.
+	/*
+	 * If the id is not TIMEOUT_TIMER2 then the timer was cancelled
+	 * before we got the lock or it was already handled so just clean up.
 	 */
 	if (entry->id != TIMEOUT_TIMER2) {
 		ao2_unlock(req_wrapper);
@@ -3196,20 +3669,24 @@ static void send_request_timer_callback(
 		ao2_ref(req_wrapper, -1);
 		return;
 	}
+	entry->id = TIMER_INACTIVE;
 
 	ast_debug(3, "%p: Timer handled here\n", req_wrapper);
 
-	PJSIP_EVENT_INIT_TX_MSG(event, req_wrapper->tdata);
-	event.body.tsx_state.type = PJSIP_EVENT_TIMER;
-	entry->id = TIMER_INACTIVE;
+	cb_called = req_wrapper->cb_called;
+	req_wrapper->cb_called = 1;
+	ao2_unlock(req_wrapper);
+
+	if (!cb_called && req_wrapper->callback) {
+		pjsip_event event;
+
+		PJSIP_EVENT_INIT_TX_MSG(event, req_wrapper->tdata);
+		event.body.tsx_state.type = PJSIP_EVENT_TIMER;
 
-	if (!req_wrapper->cb_called && req_wrapper->callback) {
 		req_wrapper->callback(req_wrapper->token, &event);
-		req_wrapper->cb_called = 1;
 		ast_debug(2, "%p: Callbacks executed\n", req_wrapper);
 	}
 
-	ao2_unlock(req_wrapper);
 	ao2_ref(req_wrapper, -1);
 }
 
@@ -3227,7 +3704,12 @@ static pj_status_t endpt_send_request(st
 	struct send_request_wrapper *req_wrapper;
 	pj_status_t ret_val;
 	pjsip_endpoint *endpt = ast_sip_get_pjsip_endpoint();
-	pjsip_tpselector selector = { .type = PJSIP_TPSELECTOR_NONE, };
+
+	if (!cb && token) {
+		/* Silly.  Without a callback we cannot do anything with token. */
+		pjsip_tx_data_dec_ref(tdata);
+		return PJ_EINVAL;
+	}
 
 	/* Create wrapper to detect if the callback was actually called on an error. */
 	req_wrapper = ao2_alloc(sizeof(*req_wrapper), send_request_wrapper_destructor);
@@ -3246,8 +3728,6 @@ static pj_status_t endpt_send_request(st
 	/* Add a reference to tdata.  The wrapper destructor cleans it up. */
 	pjsip_tx_data_add_ref(tdata);
 
-	ao2_lock(req_wrapper);
-
 	if (timeout > 0) {
 		pj_time_val timeout_timer_val = { timeout / 1000, timeout % 1000 };
 
@@ -3256,43 +3736,39 @@ static pj_status_t endpt_send_request(st
 		ast_debug(2, "%p: Set timer to %d msec\n", req_wrapper, timeout);
 
 		pj_timer_entry_init(req_wrapper->timeout_timer, TIMEOUT_TIMER2,
-			req_wrapper, &send_request_timer_callback);
-
-		pj_timer_heap_cancel_if_active(pjsip_endpt_get_timer_heap(endpt),
-			req_wrapper->timeout_timer, TIMER_INACTIVE);
+			req_wrapper, send_request_timer_callback);
 
 		/* We need to insure that the wrapper and tdata are available if/when the
 		 * timer callback is executed.
 		 */
 		ao2_ref(req_wrapper, +1);
-		pj_timer_heap_schedule(pjsip_endpt_get_timer_heap(endpt),
+		ret_val = pj_timer_heap_schedule(pjsip_endpt_get_timer_heap(endpt),
 			req_wrapper->timeout_timer, &timeout_timer_val);
-
-		req_wrapper->timeout_timer->id = TIMEOUT_TIMER2;
-	} else {
-		req_wrapper->timeout_timer = NULL;
+		if (ret_val != PJ_SUCCESS) {
+			ast_log(LOG_ERROR,
+				"Failed to set timer.  Not sending %.*s request to endpoint %s.\n",
+				(int) pj_strlen(&tdata->msg->line.req.method.name),
+				pj_strbuf(&tdata->msg->line.req.method.name),
+				endpoint ? ast_sorcery_object_get_id(endpoint) : "<unknown>");
+			ao2_t_ref(req_wrapper, -2, "Drop timer and routine ref");
+			pjsip_tx_data_dec_ref(tdata);
+			return ret_val;
+		}
 	}
 
+	ast_sip_record_request_serializer(tdata);
+
 	/* We need to insure that the wrapper and tdata are available when the
 	 * transaction callback is executed.
 	 */
 	ao2_ref(req_wrapper, +1);
-
-	if (endpoint) {
-		sip_get_tpselector_from_endpoint(endpoint, &selector);
-		pjsip_tx_data_set_transport(tdata, &selector);
-	}
-
 	ret_val = pjsip_endpt_send_request(endpt, tdata, -1, req_wrapper, endpt_send_request_cb);
 	if (ret_val != PJ_SUCCESS) {
 		char errmsg[PJ_ERR_MSG_SIZE];
 
-		if (timeout > 0) {
-			int timers_cancelled = pj_timer_heap_cancel_if_active(pjsip_endpt_get_timer_heap(endpt),
-				req_wrapper->timeout_timer, TIMER_INACTIVE);
-			if (timers_cancelled > 0) {
-				ao2_ref(req_wrapper, -1);
-			}
+		if (!req_wrapper->send_cb_called) {
+			/* endpt_send_request_cb is not expected to ever be called now. */
+			ao2_ref(req_wrapper, -1);
 		}
 
 		/* Complain of failure to send the request. */
@@ -3302,20 +3778,44 @@ static pj_status_t endpt_send_request(st
 			pj_strbuf(&tdata->msg->line.req.method.name),
 			endpoint ? ast_sorcery_object_get_id(endpoint) : "<unknown>");
 
-		/* Was the callback called? */
-		if (req_wrapper->cb_called) {
+		if (timeout > 0) {
+			int timers_cancelled;
+
+			ao2_lock(req_wrapper);
+			timers_cancelled = pj_timer_heap_cancel_if_active(
+				pjsip_endpt_get_timer_heap(endpt),
+				req_wrapper->timeout_timer, TIMER_INACTIVE);
+			if (timers_cancelled > 0) {
+				ao2_ref(req_wrapper, -1);
+			}
+
+			/* Was the callback called? */
+			if (req_wrapper->cb_called) {
+				/*
+				 * Yes so we cannot report any error.  The callback
+				 * has already freed any resources associated with
+				 * token.
+				 */
+				ret_val = PJ_SUCCESS;
+			} else {
+				/*
+				 * No so we claim it is called so our caller can free
+				 * any resources associated with token because of
+				 * failure.
+				 */
+				req_wrapper->cb_called = 1;
+			}
+			ao2_unlock(req_wrapper);
+		} else if (req_wrapper->cb_called) {
 			/*
-			 * Yes so we cannot report any error.  The callback
-			 * has already freed any resources associated with
+			 * We cannot report any error.  The callback has
+			 * already freed any resources associated with
 			 * token.
 			 */
 			ret_val = PJ_SUCCESS;
-		} else {
-			/* No and it is not expected to ever be called. */
-			ao2_ref(req_wrapper, -1);
 		}
 	}
-	ao2_unlock(req_wrapper);
+
 	ao2_ref(req_wrapper, -1);
 	return ret_val;
 }
@@ -3602,11 +4102,7 @@ int ast_sip_push_task(struct ast_taskpro
 		serializer = serializer_pool[pos];
 	}
 
-	if (serializer) {
-		return ast_taskprocessor_push(serializer, sip_task, task_data);
-	} else {
-		return ast_threadpool_push(sip_threadpool, sip_task, task_data);
-	}
+	return ast_taskprocessor_push(serializer, sip_task, task_data);
 }
 
 struct sync_task_data {
@@ -3909,11 +4405,15 @@ void ast_sip_modify_id_header(pj_pool_t
 	id_uri = pjsip_uri_get_uri(id_name_addr->uri);
 
 	if (id->name.valid) {
-		int name_buf_len = strlen(id->name.str) * 2 + 1;
-		char *name_buf = ast_alloca(name_buf_len);
+		if (!ast_strlen_zero(id->name.str)) {
+			int name_buf_len = strlen(id->name.str) * 2 + 1;
+			char *name_buf = ast_alloca(name_buf_len);
 
-		ast_escape_quoted(id->name.str, name_buf, name_buf_len);
-		pj_strdup2(pool, &id_name_addr->display, name_buf);
+			ast_escape_quoted(id->name.str, name_buf, name_buf_len);
+			pj_strdup2(pool, &id_name_addr->display, name_buf);
+		} else {
+			pj_strdup2(pool, &id_name_addr->display, NULL);
+		}
 	}
 
 	if (id->number.valid) {
@@ -3939,6 +4439,7 @@ long ast_sip_threadpool_queue_size(void)
 	return ast_threadpool_queue_size(sip_threadpool);
 }
 
+#ifdef TEST_FRAMEWORK
 AST_TEST_DEFINE(xml_sanitization_end_null)
 {
 	char sanitized[8];
@@ -3989,6 +4490,7 @@ AST_TEST_DEFINE(xml_sanitization_exceeds
 
 	return AST_TEST_PASS;
 }
+#endif
 
 /*!
  * \internal
@@ -4011,6 +4513,7 @@ static int unload_pjsip(void *data)
 	if (ast_pjsip_endpoint && serializer_pool[0]) {
 		ast_res_pjsip_cleanup_options_handling();
 		internal_sip_destroy_outbound_authentication();
+		ast_res_pjsip_cleanup_message_ip_updater();
 		ast_sip_destroy_distributor();
 		ast_res_pjsip_destroy_configuration();
 		ast_sip_destroy_system();
@@ -4024,8 +4527,13 @@ static int unload_pjsip(void *data)
 	}
 
 	if (memory_pool) {
-		pj_pool_release(memory_pool);
+		/* This mimics the behavior of pj_pool_safe_release
+		 * which was introduced in pjproject 2.6.
+		 */
+		pj_pool_t *temp_pool = memory_pool;
+
 		memory_pool = NULL;
+		pj_pool_release(temp_pool);
 	}
 
 	ast_pjsip_endpoint = NULL;
@@ -4041,6 +4549,7 @@ static int unload_pjsip(void *data)
 
 static int load_pjsip(void)
 {
+	const unsigned int flags = 0; /* no port, no brackets */
 	pj_status_t status;
 
 	/* The third parameter is just copied from
@@ -4065,12 +4574,12 @@ static int load_pjsip(void)
 	}
 
 	if (!pj_gethostip(pj_AF_INET(), &host_ip_ipv4)) {
-		pj_sockaddr_print(&host_ip_ipv4, host_ip_ipv4_string, sizeof(host_ip_ipv4_string), 2);
+		pj_sockaddr_print(&host_ip_ipv4, host_ip_ipv4_string, sizeof(host_ip_ipv4_string), flags);
 		ast_verb(3, "Local IPv4 address determined to be: %s\n", host_ip_ipv4_string);
 	}
 
 	if (!pj_gethostip(pj_AF_INET6(), &host_ip_ipv6)) {
-		pj_sockaddr_print(&host_ip_ipv6, host_ip_ipv6_string, sizeof(host_ip_ipv6_string), 2);
+		pj_sockaddr_print(&host_ip_ipv6, host_ip_ipv6_string, sizeof(host_ip_ipv6_string), flags);
 		ast_verb(3, "Local IPv6 address determined to be: %s\n", host_ip_ipv6_string);
 	}
 
@@ -4092,6 +4601,19 @@ error:
 	return AST_MODULE_LOAD_DECLINE;
 }
 
+/*
+ * This is a place holder function to ensure that pjmedia_strerr() is at
+ * least directly referenced by this module to ensure that the loader
+ * linker will link to the function.  If a module only indirectly
+ * references a function from another module, such as a callback parameter
+ * to a function, the loader linker has been known to miss the link.
+ */
+void never_called_res_pjsip(void);
+void never_called_res_pjsip(void)
+{
+	pjmedia_strerror(0, NULL, 0);
+}
+
 static int load_module(void)
 {
 	struct ast_threadpool_options options;
@@ -4107,6 +4629,12 @@ static int load_module(void)
 		goto error;
 	}
 
+	/* Register PJMEDIA error codes for SDP parsing errors */
+	if (pj_register_strerror(PJMEDIA_ERRNO_START, PJ_ERRNO_SPACE_SIZE, pjmedia_strerror)
+		!= PJ_SUCCESS) {
+		ast_log(LOG_WARNING, "Failed to register pjmedia error codes.  Codes will not be decoded.\n");
+	}
+
 	if (ast_sip_initialize_system()) {
 		ast_log(LOG_ERROR, "Failed to initialize SIP 'system' configuration section. Aborting load\n");
 		goto error;
@@ -4125,6 +4653,11 @@ static int load_module(void)
 		goto error;
 	}
 
+	if (ast_sip_initialize_scheduler()) {
+		ast_log(LOG_ERROR, "Failed to start scheduler. Aborting load\n");
+		goto error;
+	}
+
 	/* Now load all the pjproject infrastructure. */
 	if (load_pjsip()) {
 		goto error;
@@ -4155,6 +4688,12 @@ static int load_module(void)
 	}
 
 	ast_res_pjsip_init_options_handling(0);
+
+	if (ast_res_pjsip_init_message_ip_updater()) {
+		ast_log(LOG_ERROR, "Failed to initialize message IP updating. Aborting load\n");
+		goto error;
+	}
+
 	ast_cli_register_multiple(cli_commands, ARRAY_LEN(cli_commands));
 
 	AST_TEST_REGISTER(xml_sanitization_end_null);
@@ -4165,8 +4704,10 @@ static int load_module(void)
 	return AST_MODULE_LOAD_SUCCESS;
 
 error:
-	/* These functions all check for NULLs and are safe to call at any time */
 	unload_pjsip(NULL);
+
+	/* These functions all check for NULLs and are safe to call at any time */
+	ast_sip_destroy_scheduler();
 	serializer_pool_shutdown();
 	ast_threadpool_shutdown(sip_threadpool);
 
@@ -4197,7 +4738,7 @@ static int unload_module(void)
 	 * so we have to push the work to the threadpool to handle
 	 */
 	ast_sip_push_task_synchronous(NULL, unload_pjsip, NULL);
-
+	ast_sip_destroy_scheduler();
 	serializer_pool_shutdown();
 	ast_threadpool_shutdown(sip_threadpool);
 
diff -urpN asterisk-13.9.1/res/res_pjsip_authenticator_digest.c asterisk-13.17.0/res/res_pjsip_authenticator_digest.c
--- asterisk-13.9.1/res/res_pjsip_authenticator_digest.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_authenticator_digest.c	2017-07-12 13:12:08.000000000 +0200
@@ -31,6 +31,10 @@
 	<support_level>core</support_level>
  ***/
 
+/* From the auth/realm realtime column size */
+#define MAX_REALM_LENGTH 40
+static char default_realm[MAX_REALM_LENGTH + 1];
+
 AO2_GLOBAL_OBJ_STATIC(entity_id);
 
 /*!
@@ -83,46 +87,46 @@ static void auth_store_cleanup(void *dat
 AST_THREADSTORAGE_CUSTOM(auth_store, NULL, auth_store_cleanup);
 
 /*!
- * \brief Store authentication information in thread-local storage
+ * \brief Store shallow copy authentication information in thread-local storage
  */
-static int store_auth(struct ast_sip_auth *auth)
+static int store_auth(const struct ast_sip_auth *auth)
 {
-	struct ast_sip_auth **pointing;
+	const struct ast_sip_auth **pointing;
+
 	pointing = ast_threadstorage_get(&auth_store, sizeof(pointing));
-	if (!pointing || *pointing) {
+	if (!pointing) {
 		return -1;
 	}
 
-	ao2_ref(auth, +1);
 	*pointing = auth;
 	return 0;
 }
 
 /*!
- * \brief Remove authentication information from thread-local storage
+ * \brief Remove shallow copy authentication information from thread-local storage
  */
 static int remove_auth(void)
 {
 	struct ast_sip_auth **pointing;
+
 	pointing = ast_threadstorage_get(&auth_store, sizeof(pointing));
 	if (!pointing) {
 		return -1;
 	}
 
-	ao2_cleanup(*pointing);
 	*pointing = NULL;
 	return 0;
 }
 
 /*!
- * \brief Retrieve authentication information from thread-local storage
+ * \brief Retrieve shallow copy authentication information from thread-local storage
  */
-static struct ast_sip_auth *get_auth(void)
+static const struct ast_sip_auth *get_auth(void)
 {
 	struct ast_sip_auth **auth;
+
 	auth = ast_threadstorage_get(&auth_store, sizeof(auth));
-	if (auth && *auth) {
-		ao2_ref(*auth, +1);
+	if (auth) {
 		return *auth;
 	}
 	return NULL;
@@ -146,7 +150,9 @@ static struct ast_sip_auth *get_auth(voi
 static pj_status_t digest_lookup(pj_pool_t *pool, const pj_str_t *realm,
 		const pj_str_t *acc_name, pjsip_cred_info *info)
 {
-	RAII_VAR(struct ast_sip_auth *, auth, get_auth(), ao2_cleanup);
+	const struct ast_sip_auth *auth;
+
+	auth = get_auth();
 	if (!auth) {
 		return PJSIP_SC_FORBIDDEN;
 	}
@@ -202,9 +208,12 @@ static int build_nonce(struct ast_str **
 	RAII_VAR(char *, eid, ao2_global_obj_ref(entity_id), ao2_cleanup);
 	char hash[33];
 
+	/*
+	 * Note you may be tempted to think why not include the port. The reason
+	 * is that when using TCP the port can potentially differ from before.
+	 */
 	ast_str_append(&str, 0, "%s", timestamp);
 	ast_str_append(&str, 0, ":%s", rdata->pkt_info.src_name);
-	ast_str_append(&str, 0, ":%d", rdata->pkt_info.src_port);
 	ast_str_append(&str, 0, ":%s", eid);
 	ast_str_append(&str, 0, ":%s", realm);
 	ast_md5_hash(hash, ast_str_buffer(str));
@@ -305,7 +314,7 @@ enum digest_verify_result {
  * \return CMP_MATCH on successful authentication
  * \return 0 on failed authentication
  */
-static int verify(struct ast_sip_auth *auth, pjsip_rx_data *rdata, pj_pool_t *pool)
+static int verify(const struct ast_sip_auth *auth, pjsip_rx_data *rdata, pj_pool_t *pool)
 {
 	pj_status_t authed;
 	int response_code;
@@ -322,9 +331,7 @@ static int verify(struct ast_sip_auth *a
 	setup_auth_srv(pool, &auth_server, auth->realm);
 
 	store_auth(auth);
-
 	authed = pjsip_auth_srv_verify(&auth_server, rdata, &response_code);
-
 	remove_auth();
 
 	if (authed == PJ_SUCCESS) {
@@ -382,47 +389,88 @@ static enum ast_sip_check_auth_result di
 		pjsip_rx_data *rdata, pjsip_tx_data *tdata)
 {
 	struct ast_sip_auth **auths;
+	struct ast_sip_auth **auths_shallow;
 	enum digest_verify_result *verify_res;
+	struct ast_sip_endpoint *artificial_endpoint;
 	enum ast_sip_check_auth_result res;
-	int i;
+	int idx;
+	int is_artificial;
 	int failures = 0;
 	size_t auth_size;
 
-	RAII_VAR(struct ast_sip_endpoint *, artificial_endpoint,
-		 ast_sip_get_artificial_endpoint(), ao2_cleanup);
-
 	auth_size = AST_VECTOR_SIZE(&endpoint->inbound_auths);
+	ast_assert(0 < auth_size);
 
 	auths = ast_alloca(auth_size * sizeof(*auths));
 	verify_res = ast_alloca(auth_size * sizeof(*verify_res));
 
-	if (!auths) {
+	artificial_endpoint = ast_sip_get_artificial_endpoint();
+	if (!artificial_endpoint) {
+		/* Should not happen except possibly if we are shutting down. */
 		return AST_SIP_AUTHENTICATION_ERROR;
 	}
 
-	if (endpoint == artificial_endpoint) {
+	is_artificial = endpoint == artificial_endpoint;
+	ao2_ref(artificial_endpoint, -1);
+	if (is_artificial) {
+		ast_assert(auth_size == 1);
 		auths[0] = ast_sip_get_artificial_auth();
-	} else if (ast_sip_retrieve_auths(&endpoint->inbound_auths, auths)) {
-		res = AST_SIP_AUTHENTICATION_ERROR;
-		goto cleanup;
+		if (!auths[0]) {
+			/* Should not happen except possibly if we are shutting down. */
+			return AST_SIP_AUTHENTICATION_ERROR;
+		}
+	} else {
+		memset(auths, 0, auth_size * sizeof(*auths));
+		if (ast_sip_retrieve_auths(&endpoint->inbound_auths, auths)) {
+			res = AST_SIP_AUTHENTICATION_ERROR;
+			goto cleanup;
+		}
 	}
 
-	for (i = 0; i < auth_size; ++i) {
-		if (ast_strlen_zero(auths[i]->realm)) {
-			ast_string_field_set(auths[i], realm, "asterisk");
+	/* Setup shallow copy of auths */
+	if (ast_strlen_zero(default_realm)) {
+		auths_shallow = auths;
+	} else {
+		/*
+		 * Set default realm on a shallow copy of the authentication
+		 * objects that don't have a realm set.
+		 */
+		auths_shallow = ast_alloca(auth_size * sizeof(*auths_shallow));
+		for (idx = 0; idx < auth_size; ++idx) {
+			if (ast_strlen_zero(auths[idx]->realm)) {
+				/*
+				 * Make a shallow copy and set the default realm on it.
+				 *
+				 * The stack allocation is OK here.  Normally this will
+				 * loop one time.  If you have multiple auths then you
+				 * shouldn't need more auths than the normal complement
+				 * of fingers and toes.  Otherwise, you should check
+				 * your sanity for setting up your system up that way.
+				 */
+				auths_shallow[idx] = ast_alloca(sizeof(**auths_shallow));
+				memcpy(auths_shallow[idx], auths[idx], sizeof(**auths_shallow));
+				*((char **) (&auths_shallow[idx]->realm)) = default_realm;
+				ast_debug(3, "Using default realm '%s' on incoming auth '%s'.\n",
+					default_realm, ast_sorcery_object_get_id(auths_shallow[idx]));
+			} else {
+				auths_shallow[idx] = auths[idx];
+			}
 		}
-		verify_res[i] = verify(auths[i], rdata, tdata->pool);
-		if (verify_res[i] == AUTH_SUCCESS) {
+	}
+
+	for (idx = 0; idx < auth_size; ++idx) {
+		verify_res[idx] = verify(auths_shallow[idx], rdata, tdata->pool);
+		if (verify_res[idx] == AUTH_SUCCESS) {
 			res = AST_SIP_AUTHENTICATION_SUCCESS;
 			goto cleanup;
 		}
-		if (verify_res[i] == AUTH_FAIL) {
+		if (verify_res[idx] == AUTH_FAIL) {
 			failures++;
 		}
 	}
 
-	for (i = 0; i < auth_size; ++i) {
-		challenge(auths[i]->realm, tdata, rdata, verify_res[i] == AUTH_STALE);
+	for (idx = 0; idx < auth_size; ++idx) {
+		challenge(auths_shallow[idx]->realm, tdata, rdata, verify_res[idx] == AUTH_STALE);
 	}
 
 	if (failures == auth_size) {
@@ -456,6 +504,16 @@ static int build_entity_id(void)
 	return 0;
 }
 
+static void global_loaded(const char *object_type)
+{
+	ast_sip_get_default_realm(default_realm, sizeof(default_realm));
+}
+
+/*! \brief Observer which is used to update our default_realm when the global setting changes */
+static struct ast_sorcery_observer global_observer = {
+	.loaded = global_loaded,
+};
+
 static int reload_module(void)
 {
 	if (build_entity_id()) {
@@ -471,6 +529,10 @@ static int load_module(void)
 	if (build_entity_id()) {
 		return AST_MODULE_LOAD_DECLINE;
 	}
+
+	ast_sorcery_observer_add(ast_sip_get_sorcery(), "global", &global_observer);
+	ast_sorcery_reload_object(ast_sip_get_sorcery(), "global");
+
 	if (ast_sip_register_authenticator(&digest_authenticator)) {
 		ao2_global_obj_release(entity_id);
 		return AST_MODULE_LOAD_DECLINE;
@@ -480,6 +542,7 @@ static int load_module(void)
 
 static int unload_module(void)
 {
+	ast_sorcery_observer_remove(ast_sip_get_sorcery(), "global", &global_observer);
 	ast_sip_unregister_authenticator(&digest_authenticator);
 	ao2_global_obj_release(entity_id);
 	return 0;
@@ -490,5 +553,5 @@ AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MO
 		.load = load_module,
 		.unload = unload_module,
 		.reload = reload_module,
-		.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+		.load_pri = AST_MODPRI_CHANNEL_DEPEND - 5,
 );
diff -urpN asterisk-13.9.1/res/res_pjsip_caller_id.c asterisk-13.17.0/res/res_pjsip_caller_id.c
--- asterisk-13.9.1/res/res_pjsip_caller_id.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_caller_id.c	2017-07-12 13:12:08.000000000 +0200
@@ -46,11 +46,29 @@ static void set_id_from_hdr(pjsip_fromto
 	char cid_num[AST_CHANNEL_NAME];
 	pjsip_sip_uri *uri;
 	pjsip_name_addr *id_name_addr = (pjsip_name_addr *) hdr->uri;
+	char *semi;
 
 	uri = pjsip_uri_get_uri(id_name_addr);
 	ast_copy_pj_str(cid_name, &id_name_addr->display, sizeof(cid_name));
 	ast_copy_pj_str(cid_num, &uri->user, sizeof(cid_num));
 
+	/* Always truncate caller-id number at a semicolon. */
+	semi = strchr(cid_num, ';');
+	if (semi) {
+		/*
+		 * We need to be able to handle URI's looking like
+		 * "sip:1235557890;phone-context=national@x.x.x.x;user=phone"
+		 *
+		 * Where the uri->user field will result in:
+		 * "1235557890;phone-context=national"
+		 *
+		 * People don't care about anything after the semicolon
+		 * showing up on their displays even though the RFC
+		 * allows the semicolon.
+		 */
+		*semi = '\0';
+	}
+
 	ast_free(id->name.str);
 	id->name.str = ast_strdup(cid_name);
 	if (!ast_strlen_zero(cid_name)) {
@@ -413,12 +431,12 @@ static pjsip_fromto_hdr *create_new_id_h
 	id_hdr = pjsip_from_hdr_create(tdata->pool);
 	id_hdr->type = PJSIP_H_OTHER;
 	pj_strdup(tdata->pool, &id_hdr->name, hdr_name);
-	id_hdr->sname.slen = 0;
+	id_hdr->sname = id_hdr->name;
 
 	id_name_addr = pjsip_uri_clone(tdata->pool, base->uri);
 	id_uri = pjsip_uri_get_uri(id_name_addr->uri);
 
-	if (id->name.valid) {
+	if (id->name.valid && !ast_strlen_zero(id->name.str)) {
 		int name_buf_len = strlen(id->name.str) * 2 + 1;
 		char *name_buf = ast_alloca(name_buf_len);
 
@@ -432,7 +450,12 @@ static pjsip_fromto_hdr *create_new_id_h
 		pj_strdup2(tdata->pool, &id_name_addr->display, NULL);
 	}
 
-	pj_strdup2(tdata->pool, &id_uri->user, id->number.str);
+	if (id->number.valid) {
+		pj_strdup2(tdata->pool, &id_uri->user, id->number.str);
+	} else {
+		/* Similar to name, make sure the number is also cleared when invalid */
+		pj_strdup2(tdata->pool, &id_uri->user, NULL);
+	}
 
 	id_hdr->uri = (pjsip_uri *) id_name_addr;
 	return id_hdr;
@@ -505,8 +528,11 @@ static void add_pai_header(const struct
 		}
 	}
 
-	base = tdata->msg->type == PJSIP_REQUEST_MSG ? session->saved_from_hdr :
-		PJSIP_MSG_TO_HDR(tdata->msg);
+	if (tdata->msg->type == PJSIP_REQUEST_MSG) {
+		base = session->saved_from_hdr ? session->saved_from_hdr : PJSIP_MSG_FROM_HDR(tdata->msg);
+	} else {
+		base = PJSIP_MSG_TO_HDR(tdata->msg);
+	}
 
 	pai_hdr = create_new_id_hdr(&pj_pai_name, base, tdata, id);
 	if (!pai_hdr) {
@@ -611,8 +637,11 @@ static void add_rpid_header(const struct
 		}
 	}
 
-	base = tdata->msg->type == PJSIP_REQUEST_MSG ? session->saved_from_hdr :
-		PJSIP_MSG_TO_HDR(tdata->msg);
+	if (tdata->msg->type == PJSIP_REQUEST_MSG) {
+		base = session->saved_from_hdr ? session->saved_from_hdr : PJSIP_MSG_FROM_HDR(tdata->msg);
+	} else {
+		base = PJSIP_MSG_TO_HDR(tdata->msg);
+	}
 
 	rpid_hdr = create_new_id_hdr(&pj_rpid_name, base, tdata, id);
 	if (!rpid_hdr) {
diff -urpN asterisk-13.9.1/res/res_pjsip_config_wizard.c asterisk-13.17.0/res/res_pjsip_config_wizard.c
--- asterisk-13.9.1/res/res_pjsip_config_wizard.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_config_wizard.c	2017-07-12 13:12:08.000000000 +0200
@@ -141,6 +141,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					entry in the list.  If send_registrations is also set, a registration will
 					also be created for each.</para></description>
 				</configOption>
+				<configOption name="outbound_proxy">
+					<synopsis>Shortcut for specifying proxy on individual objects.</synopsis>
+					<description><para>Shortcut for specifying endpoint/outbound_proxy,
+					aor/outbound_proxy, and registration/outbound_proxy individually.
+					</para></description>
+				</configOption>
 				<configOption name="sends_auth" default="no">
 					<synopsis>Send outbound authentication to remote hosts.</synopsis>
 					<description><para>At least outbound_auth/username is required.</para></description>
@@ -155,6 +161,13 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 					be created for each host in the remote _hosts string.  If authentication is required,
 					sends_auth and an outbound_auth/username must also be supplied.</para></description>
 				</configOption>
+				<configOption name="sends_line_with_registrations" default="no">
+					<synopsis>Sets "line" and "endpoint parameters on registrations.</synopsis>
+					<description><para>Setting this to true will cause the wizard to skip the
+					creation of an identify object to match incoming requests to the endpoint and
+					instead add the line and endpoint parameters to the outbound registration object.
+					</para></description>
+				</configOption>
 				<configOption name="accepts_registrations" default="no">
 					<synopsis>Accept inbound registration from remote hosts.</synopsis>
 					<description><para>An AOR with dynamic contacts will be created.  If
@@ -597,11 +610,16 @@ static int handle_aor(const struct ast_s
 	struct ast_sorcery_object *obj = NULL;
 	const char *id = ast_category_get_name(wiz);
 	const char *contact_pattern;
+	const char *outbound_proxy = ast_variable_find_last_in_list(wizvars, "outbound_proxy");
 	int host_count = AST_VECTOR_SIZE(remote_hosts_vector);
 	RAII_VAR(struct ast_variable *, vars, get_object_variables(wizvars, "aor/"), ast_variables_destroy);
 
 	variable_list_append(&vars, "@pjsip_wizard", id);
 
+	if (!ast_strlen_zero(outbound_proxy)) {
+		variable_list_append_return(&vars, "outbound_proxy", outbound_proxy);
+	}
+
 	/* If the user explicitly specified an aor/contact, don't use remote hosts. */
 	if (!ast_variable_find_last_in_list(vars, "contact")) {
 		if (!(contact_pattern = ast_variable_find_last_in_list(wizvars, "contact_pattern"))) {
@@ -649,6 +667,7 @@ static int handle_endpoint(const struct
 	struct ast_variable *wizvars = ast_category_first(wiz);
 	struct ast_sorcery_object *obj = NULL;
 	const char *id = ast_category_get_name(wiz);
+	const char *outbound_proxy = ast_variable_find_last_in_list(wizvars, "outbound_proxy");
 	const char *transport = ast_variable_find_last_in_list(wizvars, "transport");
 	const char *hint_context = hint_context = ast_variable_find_last_in_list(wizvars, "hint_context");
 	const char *hint_exten = ast_variable_find_last_in_list(wizvars, "hint_exten");
@@ -659,6 +678,10 @@ static int handle_endpoint(const struct
 	variable_list_append_return(&vars, "@pjsip_wizard", id);
 	variable_list_append_return(&vars, "aors", id);
 
+	if (!ast_strlen_zero(outbound_proxy)) {
+		variable_list_append_return(&vars, "outbound_proxy", outbound_proxy);
+	}
+
 	if (ast_strlen_zero(hint_context)) {
 		hint_context = ast_variable_find_last_in_list(vars, "context");
 	}
@@ -721,8 +744,9 @@ static int handle_identify(const struct
 
 	snprintf(new_id, sizeof(new_id), "%s-identify", id);
 
-	/* If accepting registrations, we don't need an identify. */
-	if (is_variable_true(wizvars, "accepts_registrations")) {
+	/* If accepting registrations or we're sending line, we don't need an identify. */
+	if (is_variable_true(wizvars, "accepts_registrations")
+		|| is_variable_true(wizvars, "sends_line_with_registrations")) {
 		/* If one exists, delete it. */
 		obj = otw->wizard->retrieve_id(sorcery, otw->wizard_data, "identify", new_id);
 		if (obj) {
@@ -838,6 +862,7 @@ static int handle_registrations(const st
 	const char *id = ast_category_get_name(wiz);
 	const char *server_uri_pattern;
 	const char *client_uri_pattern;
+	const char *outbound_proxy = ast_variable_find_last_in_list(wizvars, "outbound_proxy");
 	const char *transport = ast_variable_find_last_in_list(wizvars, "transport");
 	const char *username;
 	char new_id[strlen(id) + MAX_ID_SUFFIX];
@@ -857,6 +882,10 @@ static int handle_registrations(const st
 		return -1;
 	}
 
+	if (!ast_strlen_zero(outbound_proxy)) {
+		variable_list_append_return(&vars, "outbound_proxy", outbound_proxy);
+	}
+
 	otw->wizard->retrieve_multiple(sorcery, otw->wizard_data, "registration", existing, search);
 	ast_variables_destroy(search);
 
@@ -927,6 +956,11 @@ static int handle_registrations(const st
 			variable_list_append_return(&registration_vars, "transport", transport);
 		}
 
+		if (is_variable_true(wizvars, "sends_line_with_registrations")) {
+			variable_list_append_return(&registration_vars, "line", "yes");
+			variable_list_append_return(&registration_vars, "endpoint", id);
+		}
+
 		snprintf(new_id, sizeof(new_id), "%s-reg-%d", id, host_counter);
 
 		obj = create_object(sorcery, new_id, "registration", registration_vars);
@@ -989,7 +1023,7 @@ static int wizard_apply_handler(const st
 		rc = handle_registrations(sorcery, otw, wiz, &remote_hosts_vector);
 	}
 
-	AST_VECTOR_REMOVE_CMP_UNORDERED(&remote_hosts_vector, NULL, NOT_EQUALS, ast_free);
+	AST_VECTOR_REMOVE_ALL_CMP_UNORDERED(&remote_hosts_vector, NULL, NOT_EQUALS, ast_free);
 	AST_VECTOR_FREE(&remote_hosts_vector);
 
 	ast_debug(4, "%s handler complete.  rc: %d\n", otw->object_type, rc);
@@ -1293,7 +1327,7 @@ static int unload_module(void)
 {
 	ast_cli_unregister_multiple(config_wizard_cli, ARRAY_LEN(config_wizard_cli));
 	ast_sorcery_global_observer_remove(&global_observer);
-	AST_VECTOR_REMOVE_CMP_UNORDERED(&object_type_wizards, NULL, NOT_EQUALS, OTW_DELETE_CB);
+	AST_VECTOR_REMOVE_ALL_CMP_UNORDERED(&object_type_wizards, NULL, NOT_EQUALS, OTW_DELETE_CB);
 	AST_VECTOR_RW_FREE(&object_type_wizards);
 
 	return 0;
diff -urpN asterisk-13.9.1/res/res_pjsip_dialog_info_body_generator.c asterisk-13.17.0/res/res_pjsip_dialog_info_body_generator.c
--- asterisk-13.9.1/res/res_pjsip_dialog_info_body_generator.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_dialog_info_body_generator.c	2017-07-12 13:12:08.000000000 +0200
@@ -107,6 +107,8 @@ static int dialog_info_generate_body_con
 	enum ast_sip_pidf_state local_state;
 	unsigned int version;
 	char version_str[32], sanitized[PJSIP_MAX_URL_SIZE];
+	struct ast_sip_endpoint *endpoint = NULL;
+	unsigned int notify_early_inuse_ringing = 0;
 
 	if (!local || !state_data->sub) {
 		return -1;
@@ -120,8 +122,12 @@ static int dialog_info_generate_body_con
 	stripped = ast_strip_quoted(local, "<", ">");
 	ast_sip_sanitize_xml(stripped, sanitized, sizeof(sanitized));
 
+	if (state_data->sub && (endpoint = ast_sip_subscription_get_endpoint(state_data->sub))) {
+	    notify_early_inuse_ringing = endpoint->notify_early_inuse_ringing;
+	    ao2_cleanup(endpoint);
+	}
 	ast_sip_presence_exten_state_to_str(state_data->exten_state, &statestring,
-			&pidfstate, &pidfnote, &local_state);
+			&pidfstate, &pidfnote, &local_state, notify_early_inuse_ringing);
 
 	ast_sip_presence_xml_create_attr(state_data->pool, dialog_info, "xmlns", "urn:ietf:params:xml:ns:dialog-info");
 
@@ -133,7 +139,7 @@ static int dialog_info_generate_body_con
 
 	dialog = ast_sip_presence_xml_create_node(state_data->pool, dialog_info, "dialog");
 	ast_sip_presence_xml_create_attr(state_data->pool, dialog, "id", state_data->exten);
-	if (state_data->exten_state == AST_EXTENSION_RINGING) {
+	if (!ast_strlen_zero(statestring) && !strcmp(statestring, "early")) {
 		ast_sip_presence_xml_create_attr(state_data->pool, dialog, "direction", "recipient");
 	}
 
diff -urpN asterisk-13.9.1/res/res_pjsip_diversion.c asterisk-13.17.0/res/res_pjsip_diversion.c
--- asterisk-13.9.1/res/res_pjsip_diversion.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_diversion.c	2017-07-12 13:12:08.000000000 +0200
@@ -148,11 +148,32 @@ static void set_redirecting_id(pjsip_nam
 			       struct ast_set_party_id *update)
 {
 	pjsip_sip_uri *uri = pjsip_uri_get_uri(name_addr->uri);
+	char *semi;
+	pj_str_t uri_user;
 
-	if (pj_strlen(&uri->user)) {
+	uri_user = uri->user;
+
+	/* Always truncate redirecting number at a semicolon. */
+	semi = pj_strchr(&uri_user, ';');
+	if (semi) {
+		/*
+		 * We need to be able to handle URI's looking like
+		 * "sip:1235557890;phone-context=national@x.x.x.x;user=phone"
+		 *
+		 * Where the uri->user field will result in:
+		 * "1235557890;phone-context=national"
+		 *
+		 * People don't care about anything after the semicolon
+		 * showing up on their displays even though the RFC
+		 * allows the semicolon.
+		 */
+		pj_strset(&uri_user, (char *) pj_strbuf(&uri_user), semi - pj_strbuf(&uri_user));
+	}
+
+	if (pj_strlen(&uri_user)) {
 		update->number = 1;
 		data->number.valid = 1;
-		set_redirecting_value(&data->number.str, &uri->user);
+		set_redirecting_value(&data->number.str, &uri_user);
 	}
 
 	if (pj_strlen(&name_addr->display)) {
@@ -256,6 +277,7 @@ static int diversion_incoming_request(st
 static void diversion_incoming_response(struct ast_sip_session *session, pjsip_rx_data *rdata)
 {
 	static const pj_str_t contact_name = { "Contact", 7 };
+	static const pj_str_t contact_name_s = { "m", 1 };
 
 	pjsip_status_line status = rdata->msg_info.msg->line.status;
 	pjsip_fromto_hdr *div_hdr;
@@ -271,7 +293,7 @@ static void diversion_incoming_response(
 		div_hdr = PJSIP_MSG_TO_HDR(rdata->msg_info.msg);
 	}
 
-	contact_hdr = pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &contact_name, NULL);
+	contact_hdr = pjsip_msg_find_hdr_by_names(rdata->msg_info.msg, &contact_name, &contact_name_s, NULL);
 
 	set_redirecting(session, div_hdr, contact_hdr ?	(pjsip_name_addr*)contact_hdr->uri :
 			(pjsip_name_addr*)PJSIP_MSG_FROM_HDR(rdata->msg_info.msg)->uri);
@@ -305,7 +327,7 @@ static void add_diversion_header(pjsip_t
 	hdr = pjsip_from_hdr_create(tdata->pool);
 	hdr->type = PJSIP_H_OTHER;
 	pj_strdup(tdata->pool, &hdr->name, &diversion_name);
-	hdr->sname.slen = 0;
+	hdr->sname = hdr->name;
 
 	name_addr = pjsip_uri_clone(tdata->pool, base);
 	uri = pjsip_uri_get_uri(name_addr->uri);
diff -urpN asterisk-13.9.1/res/res_pjsip_dtmf_info.c asterisk-13.17.0/res/res_pjsip_dtmf_info.c
--- asterisk-13.9.1/res/res_pjsip_dtmf_info.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_dtmf_info.c	2017-07-12 13:12:08.000000000 +0200
@@ -103,13 +103,13 @@ static int dtmf_info_incoming_request(st
 	if (!body || !body->len) {
 		/* need to return 200 OK on empty body */
 		send_response(session, rdata, 200);
-		return 0;
+		return 1;
 	}
 
 	res = body->print_body(body, buf, body->len);
 	if (res < 0) {
 		send_response(session, rdata, 500);
-		return 0;
+		return 1;
 	}
 	buf[res] = '\0';
 
@@ -150,11 +150,12 @@ static int dtmf_info_incoming_request(st
 	}
 
 	send_response(session, rdata, event ? 200 : 500);
-	return event ? 0 : -1;
+	return 1;
 }
 
 static struct ast_sip_session_supplement dtmf_info_supplement = {
 	.method = "INFO",
+	.priority = AST_SIP_SUPPLEMENT_PRIORITY_FIRST,
 	.incoming_request = dtmf_info_incoming_request,
 };
 
diff -urpN asterisk-13.9.1/res/res_pjsip_empty_info.c asterisk-13.17.0/res/res_pjsip_empty_info.c
--- asterisk-13.9.1/res/res_pjsip_empty_info.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_pjsip_empty_info.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,89 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc.
+ *
+ * Bradley Latus <brad.latus@gmail.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*** MODULEINFO
+	<depend>pjproject</depend>
+	<depend>res_pjsip</depend>
+	<depend>res_pjsip_session</depend>
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_REGISTER_FILE()
+
+#include <pjsip.h>
+#include <pjsip_ua.h>
+
+#include "asterisk/res_pjsip.h"
+#include "asterisk/res_pjsip_session.h"
+#include "asterisk/module.h"
+
+static void send_response(struct ast_sip_session *session,
+		struct pjsip_rx_data *rdata, int code)
+{
+	pjsip_tx_data *tdata;
+	pjsip_dialog *dlg = session->inv_session->dlg;
+
+	if (pjsip_dlg_create_response(dlg, rdata, code, NULL, &tdata) == PJ_SUCCESS) {
+		struct pjsip_transaction *tsx = pjsip_rdata_get_tsx(rdata);
+		pjsip_dlg_send_response(dlg, tsx, tdata);
+	}
+}
+
+static int empty_info_incoming_request(struct ast_sip_session *session,
+		struct pjsip_rx_data *rdata)
+{
+	if (!rdata->msg_info.ctype) {
+		/* Need to return 200 OK on empty body */
+		/* Some SBCs use empty INFO as a KEEPALIVE */
+		send_response(session, rdata, 200);
+		return 1;
+	}
+
+	/* Let another module respond */
+	return 0;
+
+}
+
+static struct ast_sip_session_supplement empty_info_supplement = {
+	.method = "INFO",
+	.priority = AST_SIP_SUPPLEMENT_PRIORITY_LAST,
+	.incoming_request = empty_info_incoming_request,
+};
+
+static int load_module(void)
+{
+	CHECK_PJSIP_SESSION_MODULE_LOADED();
+
+	ast_sip_session_register_supplement(&empty_info_supplement);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	ast_sip_session_unregister_supplement(&empty_info_supplement);
+	return 0;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP Empty INFO Support",
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_APP_DEPEND,
+);
diff -urpN asterisk-13.9.1/res/res_pjsip_endpoint_identifier_anonymous.c asterisk-13.17.0/res/res_pjsip_endpoint_identifier_anonymous.c
--- asterisk-13.9.1/res/res_pjsip_endpoint_identifier_anonymous.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_endpoint_identifier_anonymous.c	2017-07-12 13:12:08.000000000 +0200
@@ -69,28 +69,30 @@ static struct ast_sip_endpoint *anonymou
 		return NULL;
 	}
 
-	/* Attempt to find the endpoint given the name and domain provided */
-	snprintf(id, sizeof(id), "anonymous@%s", domain_name);
-	if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
-		goto done;
-	}
-
-	/* See if an alias exists for the domain provided */
-	if ((alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain_name))) {
-		snprintf(id, sizeof(id), "anonymous@%s", alias->domain);
+	if (!ast_sip_get_disable_multi_domain()) {
+		/* Attempt to find the endpoint given the name and domain provided */
+		snprintf(id, sizeof(id), "anonymous@%s", domain_name);
 		if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
 			goto done;
 		}
-	}
 
-	/* See if the transport this came in on has a provided domain */
-	if ((transport_states = ast_sip_get_transport_states())
-		&& (transport_state = ao2_callback(transport_states, 0, find_transport_state_in_use, rdata))
-		&& (transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport", transport_state->id))
-		&& !ast_strlen_zero(transport->domain)) {
-		snprintf(id, sizeof(id), "anonymous@%s", transport->domain);
-		if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
-			goto done;
+		/* See if an alias exists for the domain provided */
+		if ((alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain_name))) {
+			snprintf(id, sizeof(id), "anonymous@%s", alias->domain);
+			if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
+				goto done;
+			}
+		}
+
+		/* See if the transport this came in on has a provided domain */
+		if ((transport_states = ast_sip_get_transport_states())
+			&& (transport_state = ao2_callback(transport_states, 0, find_transport_state_in_use, rdata))
+			&& (transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport", transport_state->id))
+			&& !ast_strlen_zero(transport->domain)) {
+			snprintf(id, sizeof(id), "anonymous@%s", transport->domain);
+			if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
+				goto done;
+			}
 		}
 	}
 
diff -urpN asterisk-13.9.1/res/res_pjsip_endpoint_identifier_ip.c asterisk-13.17.0/res/res_pjsip_endpoint_identifier_ip.c
--- asterisk-13.9.1/res/res_pjsip_endpoint_identifier_ip.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_endpoint_identifier_ip.c	2017-07-12 13:12:08.000000000 +0200
@@ -35,20 +35,48 @@
 
 /*** DOCUMENTATION
 	<configInfo name="res_pjsip_endpoint_identifier_ip" language="en_US">
-		<synopsis>Module that identifies endpoints via source IP address</synopsis>
+		<synopsis>Module that identifies endpoints</synopsis>
 		<configFile name="pjsip.conf">
 			<configObject name="identify">
-				<synopsis>Identifies endpoints via source IP address</synopsis>
+				<synopsis>Identifies endpoints via some criteria.</synopsis>
+				<description>
+					<para>This module provides alternatives to matching inbound requests to
+					a configured endpoint. At least one of the matching mechanisms
+					must be provided, or the object configuration will be invalid.</para>
+					<para>If multiple criteria are provided, an inbound request will
+					be matched if it matches <emphasis>any</emphasis> of the criteria.</para>
+					<para>The matching mechanisms are provided by the following
+					configuration options:</para>
+					<enumlist>
+						<enum name="match"><para>Match by source IP address.</para></enum>
+						<enum name="match_header"><para>Match by SIP header.</para></enum>
+					</enumlist>
+				</description>
 				<configOption name="endpoint">
 					<synopsis>Name of Endpoint</synopsis>
 				</configOption>
 				<configOption name="match">
-					<synopsis>IP addresses or networks to match against</synopsis>
+					<synopsis>IP addresses or networks to match against.</synopsis>
 					<description><para>
 						The value is a comma-delimited list of IP addresses. IP addresses may
 						have a subnet mask appended. The subnet mask may be written in either
 						CIDR or dot-decimal notation. Separate the IP address and subnet
-						mask with a slash ('/')
+						mask with a slash ('/').
+					</para></description>
+				</configOption>
+				<configOption name="srv_lookups" default="yes">
+					<synopsis>Perform SRV lookups for provided hostnames.</synopsis>
+					<description><para>When enabled, <replaceable>srv_lookups</replaceable> will
+					perform SRV lookups for _sip._udp, _sip._tcp, and _sips._tcp of the given
+					hostnames to determine additional addresses that traffic may originate from.
+					</para></description>
+				</configOption>
+				<configOption name="match_header">
+					<synopsis>Header/value pair to match against.</synopsis>
+					<description><para>A SIP header who value is used to match against. SIP
+					requests containing the header, along with the specified value, will be
+					mapped to the specified endpoint. The header must be specified with a
+					<literal>:</literal>, as in <literal>match_header = SIPHeader: value</literal>.
 					</para></description>
 				</configOption>
 				<configOption name="type">
@@ -59,6 +87,9 @@
 	</configInfo>
  ***/
 
+/*! \brief The number of buckets for storing hosts for resolution */
+#define HOSTS_BUCKETS 53
+
 /*! \brief Structure for an IP identification matching object */
 struct ip_identify_match {
 	/*! \brief Sorcery object details */
@@ -67,9 +98,15 @@ struct ip_identify_match {
 	AST_DECLARE_STRING_FIELDS(
 		/*! The name of the endpoint */
 		AST_STRING_FIELD(endpoint_name);
+		/*! If matching by header, the header/value to match against */
+		AST_STRING_FIELD(match_header);
 	);
 	/*! \brief Networks or addresses that should match this */
 	struct ast_ha *matches;
+	/*! \brief Perform SRV resolution of hostnames */
+	unsigned int srv_lookups;
+	/*! \brief Hosts to be resolved after applying configuration */
+	struct ao2_container *hosts;
 };
 
 /*! \brief Destructor function for a matching object */
@@ -79,6 +116,7 @@ static void ip_identify_destroy(void *ob
 
 	ast_string_field_free_memory(identify);
 	ast_free_ha(identify->matches);
+	ao2_cleanup(identify->hosts);
 }
 
 /*! \brief Allocator function for a matching object */
@@ -94,7 +132,53 @@ static void *ip_identify_alloc(const cha
 	return identify;
 }
 
-/*! \brief Comparator function for a matching object */
+/*! \brief Comparator function for matching an object by header */
+static int header_identify_match_check(void *obj, void *arg, int flags)
+{
+	struct ip_identify_match *identify = obj;
+	struct pjsip_rx_data *rdata = arg;
+	pjsip_generic_string_hdr *header;
+	pj_str_t pj_header_name;
+	pj_str_t pj_header_value;
+	char *c_header;
+	char *c_value;
+
+	if (ast_strlen_zero(identify->match_header)) {
+		return 0;
+	}
+
+	c_header = ast_strdupa(identify->match_header);
+	c_value = strchr(c_header, ':');
+	if (!c_value) {
+		ast_log(LOG_WARNING, "Identify '%s' has invalid header_match: No ':' separator found!\n",
+			ast_sorcery_object_get_id(identify));
+		return 0;
+	}
+	*c_value = '\0';
+	c_value++;
+	c_value = ast_strip(c_value);
+
+	pj_header_name = pj_str(c_header);
+	header = pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &pj_header_name, NULL);
+	if (!header) {
+		ast_debug(3, "SIP message does not contain header '%s'\n", c_header);
+		return 0;
+	}
+
+	pj_header_value = pj_str(c_value);
+	if (pj_strcmp(&pj_header_value, &header->hvalue)) {
+		ast_debug(3, "SIP message contains header '%s' but value '%.*s' does not match value '%s' for endpoint '%s'\n",
+			c_header,
+			(int) pj_strlen(&header->hvalue), pj_strbuf(&header->hvalue),
+			c_value,
+			identify->endpoint_name);
+		return 0;
+	}
+
+	return CMP_MATCH | CMP_STOP;
+}
+
+/*! \brief Comparator function for matching an object by IP address */
 static int ip_identify_match_check(void *obj, void *arg, int flags)
 {
 	struct ip_identify_match *identify = obj;
@@ -132,10 +216,14 @@ static struct ast_sip_endpoint *ip_ident
 	ast_sockaddr_parse(&addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);
 	ast_sockaddr_set_port(&addr, rdata->pkt_info.src_port);
 
-	if (!(match = ao2_callback(candidates, 0, ip_identify_match_check, &addr))) {
-		ast_debug(3, "'%s' did not match any identify section rules\n",
+	match = ao2_callback(candidates, 0, ip_identify_match_check, &addr);
+	if (!match) {
+		ast_debug(3, "Identify checks by IP address failed to find match: '%s' did not match any identify section rules\n",
 				ast_sockaddr_stringify(&addr));
-		return NULL;
+		match = ao2_callback(candidates, 0, header_identify_match_check, rdata);
+		if (!match) {
+			return NULL;
+		}
 	}
 
 	endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", match->endpoint_name);
@@ -153,6 +241,72 @@ static struct ast_sip_endpoint_identifie
 	.identify_endpoint = ip_identify,
 };
 
+/*! \brief Helper function which performs a host lookup and adds result to identify match */
+static int ip_identify_match_host_lookup(struct ip_identify_match *identify, const char *host)
+{
+	struct ast_sockaddr *addrs;
+	int num_addrs = 0, error = 0, i;
+	int results = 0;
+
+	num_addrs = ast_sockaddr_resolve(&addrs, host, PARSE_PORT_FORBID, AST_AF_UNSPEC);
+	if (!num_addrs) {
+		return -1;
+	}
+
+	for (i = 0; i < num_addrs; ++i) {
+		/* Check if the address is already in the list, if so don't bother adding it again */
+		if (identify->matches && (ast_apply_ha(identify->matches, &addrs[i]) != AST_SENSE_ALLOW)) {
+			continue;
+		}
+
+		/* We deny what we actually want to match because there is an implicit permit all rule for ACLs */
+		identify->matches = ast_append_ha("d", ast_sockaddr_stringify_addr(&addrs[i]), identify->matches, &error);
+
+		if (!identify->matches || error) {
+			results = -1;
+			break;
+		}
+
+		results += 1;
+	}
+
+	ast_free(addrs);
+
+	return results;
+}
+
+/*! \brief Helper function which performs an SRV lookup and then resolves the hostname */
+static int ip_identify_match_srv_lookup(struct ip_identify_match *identify, const char *prefix, const char *host)
+{
+	char service[NI_MAXHOST];
+	struct srv_context *context = NULL;
+	int srv_ret;
+	const char *srvhost;
+	unsigned short srvport;
+	int results = 0;
+
+	snprintf(service, sizeof(service), "%s.%s", prefix, host);
+
+	while (!(srv_ret = ast_srv_lookup(&context, service, &srvhost, &srvport))) {
+		int hosts;
+
+		/* In the case of the SRV lookup we don't care if it fails, we will output a log message
+		 * when we fallback to a normal lookup.
+		 */
+		hosts = ip_identify_match_host_lookup(identify, srvhost);
+		if (hosts == -1) {
+			results = -1;
+			break;
+		} else {
+			results += hosts;
+		}
+	}
+
+	ast_srv_cleanup(&context);
+
+	return results;
+}
+
 /*! \brief Custom handler for match field */
 static int ip_identify_match_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
 {
@@ -165,9 +319,8 @@ static int ip_identify_match_handler(con
 	}
 
 	while ((current_string = ast_strip(strsep(&input_string, ",")))) {
-		struct ast_sockaddr *addrs;
-		int num_addrs = 0, error = 0, i;
 		char *mask = strrchr(current_string, '/');
+		int error = 0;
 
 		if (ast_strlen_zero(current_string)) {
 			continue;
@@ -185,36 +338,79 @@ static int ip_identify_match_handler(con
 			continue;
 		}
 
-		num_addrs = ast_sockaddr_resolve(&addrs, current_string, PARSE_PORT_FORBID, AST_AF_UNSPEC);
-		if (!num_addrs) {
-			ast_log(LOG_ERROR, "Address '%s' provided on ip endpoint identifier '%s' did not resolve to any address\n",
-				var->value, ast_sorcery_object_get_id(obj));
+		if (!identify->hosts) {
+			identify->hosts = ast_str_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, HOSTS_BUCKETS);
+			if (!identify->hosts) {
+				ast_log(LOG_ERROR, "Failed to create container to store hosts on ip endpoint identifier '%s'\n",
+					ast_sorcery_object_get_id(obj));
+				return -1;
+			}
+		}
+
+		error = ast_str_container_add(identify->hosts, current_string);
+		if (error) {
+			ast_log(LOG_ERROR, "Failed to store host '%s' for resolution on ip endpoint identifier '%s'\n",
+				current_string, ast_sorcery_object_get_id(obj));
 			return -1;
 		}
+	}
 
-		for (i = 0; i < num_addrs; ++i) {
-			/* We deny what we actually want to match because there is an implicit permit all rule for ACLs */
-			identify->matches = ast_append_ha("d", ast_sockaddr_stringify_addr(&addrs[i]), identify->matches, &error);
+	return 0;
+}
 
-			if (!identify->matches || error) {
-				ast_log(LOG_ERROR, "Failed to add address '%s' to ip endpoint identifier '%s'\n",
-					ast_sockaddr_stringify_addr(&addrs[i]), ast_sorcery_object_get_id(obj));
-				error = -1;
-				break;
+/*! \brief Apply handler for identify type */
+static int ip_identify_apply(const struct ast_sorcery *sorcery, void *obj)
+{
+	struct ip_identify_match *identify = obj;
+	char *current_string;
+	struct ao2_iterator i;
+
+	if (!identify->hosts) {
+		return 0;
+	}
+
+	i = ao2_iterator_init(identify->hosts, 0);
+	while ((current_string = ao2_iterator_next(&i))) {
+		struct ast_sockaddr address;
+		int results = 0;
+
+		/* If the provided string is not an IP address perform SRV resolution on it */
+		if (identify->srv_lookups && !ast_sockaddr_parse(&address, current_string, 0)) {
+			results = ip_identify_match_srv_lookup(identify, "_sip._udp", current_string);
+			if (results != -1) {
+				results += ip_identify_match_srv_lookup(identify, "_sip._tcp", current_string);
+			}
+			if (results != -1) {
+				results += ip_identify_match_srv_lookup(identify, "_sips._tcp", current_string);
 			}
 		}
 
-		ast_free(addrs);
+		/* If SRV falls fall back to a normal lookup on the host itself */
+		if (!results) {
+			results = ip_identify_match_host_lookup(identify, current_string);
+		}
 
-		if (error) {
+		if (results == 0) {
+			ast_log(LOG_ERROR, "Address '%s' provided on ip endpoint identifier '%s' did not resolve to any address\n",
+				current_string, ast_sorcery_object_get_id(obj));
+		} else if (results == -1) {
+			ast_log(LOG_ERROR, "An error occurred when adding resolution results of '%s' on '%s'\n",
+				current_string, ast_sorcery_object_get_id(obj));
+			ao2_ref(current_string, -1);
+			ao2_iterator_destroy(&i);
 			return -1;
 		}
+
+		ao2_ref(current_string, -1);
 	}
+	ao2_iterator_destroy(&i);
+
+	ao2_ref(identify->hosts, -1);
+	identify->hosts = NULL;
 
 	return 0;
 }
 
-
 static int match_to_str(const void *obj, const intptr_t *args, char **buf)
 {
 	RAII_VAR(struct ast_str *, str, ast_str_create(MAX_OBJECT_FIELD), ast_free);
@@ -372,7 +568,7 @@ static int cli_print_header(void *obj, v
 		filler = CLI_LAST_TABSTOP - indent - 24;
 
 		ast_str_append(&context->output_buffer, 0,
-			"%*s:  <ip/cidr%*.*s>\n",
+			"%*s:  <criteria%*.*s>\n",
 			indent, "Match", filler, filler, CLI_HEADER_FILLER);
 
 		context->indent_level--;
@@ -409,6 +605,13 @@ static int cli_print_body(void *obj, voi
 				addr, ast_sockaddr_cidr_bits(&match->netmask));
 		}
 
+		if (!ast_strlen_zero(ident->match_header)) {
+			ast_str_append(&context->output_buffer, 0, "%*s: %s\n",
+				indent,
+				"Match",
+				ident->match_header);
+		}
+
 		context->indent_level--;
 
 		if (context->indent_level == 0) {
@@ -462,13 +665,15 @@ static int load_module(void)
 	ast_sorcery_apply_config(ast_sip_get_sorcery(), "res_pjsip_endpoint_identifier_ip");
 	ast_sorcery_apply_default(ast_sip_get_sorcery(), "identify", "config", "pjsip.conf,criteria=type=identify");
 
-	if (ast_sorcery_object_register(ast_sip_get_sorcery(), "identify", ip_identify_alloc, NULL, NULL)) {
+	if (ast_sorcery_object_register(ast_sip_get_sorcery(), "identify", ip_identify_alloc, NULL, ip_identify_apply)) {
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	ast_sorcery_object_field_register(ast_sip_get_sorcery(), "identify", "type", "", OPT_NOOP_T, 0, 0);
 	ast_sorcery_object_field_register(ast_sip_get_sorcery(), "identify", "endpoint", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, endpoint_name));
 	ast_sorcery_object_field_register_custom(ast_sip_get_sorcery(), "identify", "match", "", ip_identify_match_handler, match_to_str, match_to_var_list, 0, 0);
+	ast_sorcery_object_field_register(ast_sip_get_sorcery(), "identify", "match_header", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, match_header));
+	ast_sorcery_object_field_register(ast_sip_get_sorcery(), "identify", "srv_lookups", "yes", OPT_BOOL_T, 1, FLDSET(struct ip_identify_match, srv_lookups));
 	ast_sorcery_load_object(ast_sip_get_sorcery(), "identify");
 
 	ast_sip_register_endpoint_identifier_with_name(&ip_identifier, "ip");
@@ -515,5 +720,5 @@ AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MO
 		.load = load_module,
 		.reload = reload_module,
 		.unload = unload_module,
-		.load_pri = AST_MODPRI_APP_DEPEND,
+		.load_pri = AST_MODPRI_CHANNEL_DEPEND - 4,
 	       );
diff -urpN asterisk-13.9.1/res/res_pjsip_endpoint_identifier_user.c asterisk-13.17.0/res/res_pjsip_endpoint_identifier_user.c
--- asterisk-13.9.1/res/res_pjsip_endpoint_identifier_user.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_endpoint_identifier_user.c	2017-07-12 13:12:08.000000000 +0200
@@ -29,19 +29,37 @@
 #include "asterisk/res_pjsip.h"
 #include "asterisk/module.h"
 
-static int get_endpoint_details(pjsip_rx_data *rdata, char *endpoint, size_t endpoint_size, char *domain, size_t domain_size)
+static int get_from_header(pjsip_rx_data *rdata, char *username, size_t username_size, char *domain, size_t domain_size)
 {
 	pjsip_uri *from = rdata->msg_info.from->uri;
 	pjsip_sip_uri *sip_from;
+
 	if (!PJSIP_URI_SCHEME_IS_SIP(from) && !PJSIP_URI_SCHEME_IS_SIPS(from)) {
 		return -1;
 	}
 	sip_from = (pjsip_sip_uri *) pjsip_uri_get_uri(from);
-	ast_copy_pj_str(endpoint, &sip_from->user, endpoint_size);
+	ast_copy_pj_str(username, &sip_from->user, username_size);
 	ast_copy_pj_str(domain, &sip_from->host, domain_size);
 	return 0;
 }
 
+static pjsip_authorization_hdr *get_auth_header(pjsip_rx_data *rdata, char *username,
+	size_t username_size, char *realm, size_t realm_size, pjsip_authorization_hdr *start)
+{
+	pjsip_authorization_hdr *header;
+
+	header = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_AUTHORIZATION, start);
+
+	if (!header || pj_stricmp2(&header->scheme, "digest")) {
+		return NULL;
+	}
+
+	ast_copy_pj_str(username, &header->credential.digest.username, username_size);
+	ast_copy_pj_str(realm, &header->credential.digest.realm, realm_size);
+
+	return header;
+}
+
 static int find_transport_state_in_use(void *obj, void *arg, int flags)
 {
 	struct ast_sip_transport_state *transport_state = obj;
@@ -56,74 +74,133 @@ static int find_transport_state_in_use(v
 	return 0;
 }
 
-static struct ast_sip_endpoint *username_identify(pjsip_rx_data *rdata)
+static struct ast_sip_endpoint *find_endpoint(pjsip_rx_data *rdata, char *endpoint_name,
+	char *domain_name)
 {
-	char endpoint_name[64], domain_name[64], id[AST_UUID_STR_LEN];
+	char id[AST_UUID_STR_LEN];
 	struct ast_sip_endpoint *endpoint;
 	RAII_VAR(struct ast_sip_domain_alias *, alias, NULL, ao2_cleanup);
 	RAII_VAR(struct ao2_container *, transport_states, NULL, ao2_cleanup);
 	RAII_VAR(struct ast_sip_transport_state *, transport_state, NULL, ao2_cleanup);
 	RAII_VAR(struct ast_sip_transport *, transport, NULL, ao2_cleanup);
 
-	if (get_endpoint_details(rdata, endpoint_name, sizeof(endpoint_name), domain_name, sizeof(domain_name))) {
-		return NULL;
-	}
-
-	/* Attempt to find the endpoint given the name and domain provided */
-	snprintf(id, sizeof(id), "%s@%s", endpoint_name, domain_name);
-	if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
-		goto done;
-	}
-
-	/* See if an alias exists for the domain provided */
-	if ((alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain_name))) {
-		snprintf(id, sizeof(id), "%s@%s", endpoint_name, alias->domain);
+	if (!ast_sip_get_disable_multi_domain()) {
+		/* Attempt to find the endpoint given the name and domain provided */
+		snprintf(id, sizeof(id), "%s@%s", endpoint_name, domain_name);
 		if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
-			goto done;
+			return endpoint;
 		}
-	}
 
-	/* See if the transport this came in on has a provided domain */
-	if ((transport_states = ast_sip_get_transport_states())
-		&& (transport_state = ao2_callback(transport_states, 0, find_transport_state_in_use, rdata))
-		&& (transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport", transport_state->id))
-		&& !ast_strlen_zero(transport->domain)) {
-		snprintf(id, sizeof(id), "anonymous@%s", transport->domain);
-		if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
-			goto done;
+		/* See if an alias exists for the domain provided */
+		if ((alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain_name))) {
+			snprintf(id, sizeof(id), "%s@%s", endpoint_name, alias->domain);
+			if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
+				return endpoint;
+			}
+		}
+		/* See if the transport this came in on has a provided domain */
+		if ((transport_states = ast_sip_get_transport_states())
+			&& (transport_state = ao2_callback(transport_states, 0, find_transport_state_in_use, rdata))
+			&& (transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport", transport_state->id))
+			&& !ast_strlen_zero(transport->domain)) {
+			snprintf(id, sizeof(id), "anonymous@%s", transport->domain);
+			if ((endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", id))) {
+				return endpoint;
+			}
 		}
 	}
 
 	/* Fall back to no domain */
-	endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", endpoint_name);
+	return ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", endpoint_name);
+}
 
-done:
-	if (endpoint) {
-		if (!(endpoint->ident_method & AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME)) {
-			ao2_ref(endpoint, -1);
-			return NULL;
-		}
-		ast_debug(3, "Retrieved endpoint %s\n", ast_sorcery_object_get_id(endpoint));
-	} else {
-		ast_debug(3, "Could not identify endpoint by username '%s'\n", endpoint_name);
+static struct ast_sip_endpoint *username_identify(pjsip_rx_data *rdata)
+{
+	char username[64];
+	char domain[64];
+	struct ast_sip_endpoint *endpoint;
+
+	if (get_from_header(rdata, username, sizeof(username), domain, sizeof(domain))) {
+		return NULL;
+	}
+
+	/*
+	 * We may want to be matched without any user options getting
+	 * in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(username);
+
+	ast_debug(3, "Attempting identify by From username '%s' domain '%s'\n", username, domain);
+
+	endpoint = find_endpoint(rdata, username, domain);
+	if (!endpoint) {
+		ast_debug(3, "Endpoint not found for From username '%s' domain '%s'\n", username, domain);
+		return NULL;
 	}
+	if (!(endpoint->ident_method & AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME)) {
+		ast_debug(3, "Endpoint found for '%s' but 'username' method not supported'\n", username);
+		ao2_cleanup(endpoint);
+		return NULL;
+	}
+	ast_debug(3, "Identified by From username '%s' domain '%s'\n", username, domain);
+
 	return endpoint;
 }
 
+static struct ast_sip_endpoint *auth_username_identify(pjsip_rx_data *rdata)
+{
+	char username[64], realm[64];
+	struct ast_sip_endpoint *endpoint;
+	pjsip_authorization_hdr *auth_header = NULL;
+
+	while ((auth_header = get_auth_header(rdata, username, sizeof(username), realm, sizeof(realm),
+		auth_header ? auth_header->next : NULL))) {
+		ast_debug(3, "Attempting identify by Authorization username '%s' realm '%s'\n", username,
+			realm);
+
+		endpoint = find_endpoint(rdata, username, realm);
+		if (!endpoint) {
+			ast_debug(3, "Endpoint not found for Authentication username '%s' realm '%s'\n",
+				username, realm);
+			ao2_cleanup(endpoint);
+			continue;
+		}
+		if (!(endpoint->ident_method & AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME)) {
+			ast_debug(3, "Endpoint found for '%s' but 'auth_username' method not supported'\n",
+				username);
+			ao2_cleanup(endpoint);
+			continue;
+		}
+		ast_debug(3, "Identified by Authorization username '%s' realm '%s'\n", username, realm);
+
+		return endpoint;
+	}
+
+	return NULL;
+}
+
+
 static struct ast_sip_endpoint_identifier username_identifier = {
 	.identify_endpoint = username_identify,
 };
 
+static struct ast_sip_endpoint_identifier auth_username_identifier = {
+	.identify_endpoint = auth_username_identify,
+};
+
+
 static int load_module(void)
 {
 	CHECK_PJSIP_MODULE_LOADED();
 
 	ast_sip_register_endpoint_identifier_with_name(&username_identifier, "username");
+	ast_sip_register_endpoint_identifier_with_name(&auth_username_identifier, "auth_username");
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
 static int unload_module(void)
 {
+	ast_sip_unregister_endpoint_identifier(&auth_username_identifier);
 	ast_sip_unregister_endpoint_identifier(&username_identifier);
 	return 0;
 }
@@ -132,5 +209,5 @@ AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MO
 		.support_level = AST_MODULE_SUPPORT_CORE,
 		.load = load_module,
 		.unload = unload_module,
-		.load_pri = AST_MODPRI_APP_DEPEND,
+		.load_pri = AST_MODPRI_CHANNEL_DEPEND - 4,
 	       );
diff -urpN asterisk-13.9.1/res/res_pjsip_exten_state.c asterisk-13.17.0/res/res_pjsip_exten_state.c
--- asterisk-13.9.1/res/res_pjsip_exten_state.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_exten_state.c	2017-07-12 13:12:08.000000000 +0200
@@ -352,9 +352,12 @@ static void subscription_shutdown(struct
 static int new_subscribe(struct ast_sip_endpoint *endpoint,
 		const char *resource)
 {
-	if (!ast_exists_extension(NULL, endpoint->context, resource, PRIORITY_HINT, NULL)) {
-		ast_log(LOG_NOTICE, "Extension state subscription failed: Extension %s does not exist in context '%s' or has no associated hint\n",
-			resource, endpoint->context);
+	const char *context = S_OR(endpoint->subscription.context, endpoint->context);
+
+	if (!ast_exists_extension(NULL, context, resource, PRIORITY_HINT, NULL)) {
+		ast_log(LOG_NOTICE, "Endpoint '%s' state subscription failed: "
+			"Extension '%s' does not exist in context '%s' or has no associated hint\n",
+			ast_sorcery_object_get_id(endpoint), resource, context);
 		return 404;
 	}
 
@@ -372,7 +375,9 @@ static int subscription_established(stru
 		return -1;
 	}
 
-	ast_copy_string(exten_state_sub->context, endpoint->context, sizeof(exten_state_sub->context));
+	ast_copy_string(exten_state_sub->context,
+		S_OR(endpoint->subscription.context, endpoint->context),
+		sizeof(exten_state_sub->context));
 	ast_copy_string(exten_state_sub->exten, resource, sizeof(exten_state_sub->exten));
 
 	if ((exten_state_sub->id = ast_extension_state_add_destroy_extended(
@@ -517,8 +522,8 @@ static int unload_module(void)
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP Extension State Notifications",
-		.support_level = AST_MODULE_SUPPORT_CORE,
-		.load = load_module,
-		.unload = unload_module,
-		.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND + 5,
 );
diff -urpN asterisk-13.9.1/res/res_pjsip_header_funcs.c asterisk-13.17.0/res/res_pjsip_header_funcs.c
--- asterisk-13.9.1/res/res_pjsip_header_funcs.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_header_funcs.c	2017-07-12 13:12:08.000000000 +0200
@@ -39,7 +39,8 @@
 /*** DOCUMENTATION
 	<function name="PJSIP_HEADER" language="en_US">
 		<synopsis>
-			Gets, adds, updates or removes the specified SIP header from a PJSIP session.
+			Gets headers from an inbound PJSIP channel. Adds, updates or removes the
+			specified SIP header from an outbound PJSIP channel.
 		</synopsis>
 		<syntax>
 			<parameter name="action" required="true">
@@ -75,6 +76,10 @@
 
 		</syntax>
 		<description>
+			<para>PJSIP_HEADER allows you to read specific SIP headers from the inbound
+			PJSIP channel as well as write(add, update, remove) headers on the outbound
+			channel. One exception is that you can read headers that you have already
+			added on the outbound channel.</para>
 			<para>Examples:</para>
 			<para>;</para>
 			<para>; Set 'somevar' to the value of the 'From' header.</para>
@@ -120,7 +125,7 @@
 
 			<note><para>If you call PJSIP_HEADER in a normal dialplan context you'll be
 			operating on the <emphasis>caller's (incoming)</emphasis> channel which
-			may not be what you want.  To operate on the <emphasis>callee's (outgoing)</emphasis>
+			may not be what you want. To operate on the <emphasis>callee's (outgoing)</emphasis>
 			channel call PJSIP_HEADER in a pre-dial handler. </para>
 			<para>Example:</para>
 			<para>;</para>
diff -urpN asterisk-13.9.1/res/res_pjsip_history.c asterisk-13.17.0/res/res_pjsip_history.c
--- asterisk-13.9.1/res/res_pjsip_history.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_history.c	2017-07-12 13:12:08.000000000 +0200
@@ -159,6 +159,9 @@ struct expression_token {
 	char field[];
 };
 
+/*! \brief Log level for history output */
+static int log_level = -1;
+
 /*!
  * \brief Operator callback for determining equality
  */
@@ -605,8 +608,13 @@ static void pjsip_history_entry_dtor(voi
 	struct pjsip_history_entry *entry = obj;
 
 	if (entry->pool) {
-		pj_pool_release(entry->pool);
+		/* This mimics the behavior of pj_pool_safe_release
+		 * which was introduced in pjproject 2.6.
+		 */
+		pj_pool_t *temp_pool = entry->pool;
+
 		entry->pool = NULL;
+		pj_pool_release(temp_pool);
 	}
 }
 
@@ -646,6 +654,41 @@ static struct pjsip_history_entry *pjsip
 	return entry;
 }
 
+/*! \brief Format single line history entry */
+static void sprint_list_entry(struct pjsip_history_entry *entry, char *line, int len)
+{
+	char addr[64];
+
+	if (entry->transmitted) {
+		pj_sockaddr_print(&entry->dst, addr, sizeof(addr), 3);
+	} else {
+		pj_sockaddr_print(&entry->src, addr, sizeof(addr), 3);
+	}
+
+	if (entry->msg->type == PJSIP_REQUEST_MSG) {
+		char uri[128];
+
+		pjsip_uri_print(PJSIP_URI_IN_REQ_URI, entry->msg->line.req.uri, uri, sizeof(uri));
+		snprintf(line, len, "%-5.5d %-10.10ld %-5.5s %-24.24s %.*s %s SIP/2.0",
+			entry->number,
+			entry->timestamp.tv_sec,
+			entry->transmitted ? "* ==>" : "* <==",
+			addr,
+			(int)pj_strlen(&entry->msg->line.req.method.name),
+			pj_strbuf(&entry->msg->line.req.method.name),
+			uri);
+	} else {
+		snprintf(line, len, "%-5.5d %-10.10ld %-5.5s %-24.24s SIP/2.0 %u %.*s",
+			entry->number,
+			entry->timestamp.tv_sec,
+			entry->transmitted ? "* ==>" : "* <==",
+			addr,
+			entry->msg->line.status.code,
+			(int)pj_strlen(&entry->msg->line.status.reason),
+			pj_strbuf(&entry->msg->line.status.reason));
+	}
+}
+
 /*! \brief PJSIP callback when a SIP message is transmitted */
 static pj_status_t history_on_tx_msg(pjsip_tx_data *tdata)
 {
@@ -667,6 +710,13 @@ static pj_status_t history_on_tx_msg(pjs
 	AST_VECTOR_APPEND(&vector_history, entry);
 	ast_mutex_unlock(&history_lock);
 
+	if (log_level != -1) {
+		char line[256];
+
+		sprint_list_entry(entry, line, sizeof(line));
+		ast_log_dynamic_level(log_level, "%s\n", line);
+	}
+
 	return PJ_SUCCESS;
 }
 
@@ -700,6 +750,13 @@ static pj_bool_t history_on_rx_msg(pjsip
 	AST_VECTOR_APPEND(&vector_history, entry);
 	ast_mutex_unlock(&history_lock);
 
+	if (log_level != -1) {
+		char line[256];
+
+		sprint_list_entry(entry, line, sizeof(line));
+		ast_log_dynamic_level(log_level, "%s\n", line);
+	}
+
 	return PJ_FALSE;
 }
 
@@ -1120,38 +1177,12 @@ static void display_entry_list(struct as
 
 	for (i = 0; i < AST_VECTOR_SIZE(vec); i++) {
 		struct pjsip_history_entry *entry;
-		char addr[64];
 		char line[256];
 
 		entry = AST_VECTOR_GET(vec, i);
+		sprint_list_entry(entry, line, sizeof(line));
 
-		if (entry->transmitted) {
-			pj_sockaddr_print(&entry->dst, addr, sizeof(addr), 3);
-		} else {
-			pj_sockaddr_print(&entry->src, addr, sizeof(addr), 3);
-		}
-
-		if (entry->msg->type == PJSIP_REQUEST_MSG) {
-			char uri[128];
-
-			pjsip_uri_print(PJSIP_URI_IN_REQ_URI, entry->msg->line.req.uri, uri, sizeof(uri));
-			snprintf(line, sizeof(line), "%.*s %s SIP/2.0",
-				(int)pj_strlen(&entry->msg->line.req.method.name),
-				pj_strbuf(&entry->msg->line.req.method.name),
-				uri);
-		} else {
-			snprintf(line, sizeof(line), "SIP/2.0 %u %.*s",
-				entry->msg->line.status.code,
-				(int)pj_strlen(&entry->msg->line.status.reason),
-				pj_strbuf(&entry->msg->line.status.reason));
-		}
-
-		ast_cli(a->fd, "%-5.5d %-10.10ld %-5.5s %-24.24s %s\n",
-			entry->number,
-			entry->timestamp.tv_sec,
-			entry->transmitted ? "* ==>" : "* <==",
-			addr,
-			line);
+		ast_cli(a->fd, "%s\n", line);
 	}
 }
 
@@ -1321,6 +1352,11 @@ static int load_module(void)
 {
 	CHECK_PJSIP_MODULE_LOADED();
 
+	log_level = ast_logger_register_level("PJSIP_HISTORY");
+	if (log_level < 0) {
+		ast_log(LOG_WARNING, "Unable to register history log level\n");
+	}
+
 	pj_caching_pool_init(&cachingpool, &pj_pool_factory_default_policy, 0);
 
 	AST_VECTOR_INIT(&vector_history, HISTORY_INITIAL_SIZE);
@@ -1341,6 +1377,10 @@ static int unload_module(void)
 
 	pj_caching_pool_destroy(&cachingpool);
 
+	if (log_level != -1) {
+		ast_logger_unregister_level("PJSIP_HISTORY");
+	}
+
 	return 0;
 }
 
diff -urpN asterisk-13.9.1/res/res_pjsip_messaging.c asterisk-13.17.0/res/res_pjsip_messaging.c
--- asterisk-13.9.1/res/res_pjsip_messaging.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_messaging.c	2017-07-12 13:12:08.000000000 +0200
@@ -24,11 +24,11 @@
  ***/
 
 /*** DOCUMENTATION
-	<info name="PJSIPMessageFromInfo" language="en_US" tech="PJSIP">
+	<info name="MessageFromInfo" language="en_US" tech="PJSIP">
 		<para>The <literal>from</literal> parameter can be a configured endpoint
 		or in the form of "display-name" &lt;URI&gt;.</para>
 	</info>
-	<info name="PJSIPMessageToInfo" language="en_US" tech="PJSIP">
+	<info name="MessageToInfo" language="en_US" tech="PJSIP">
 		<para>Specifying a prefix of <literal>pjsip:</literal> will send the
 		message as a SIP MESSAGE request.</para>
 	</info>
@@ -106,8 +106,9 @@ static const char *skip_sip(const char *
  *
  * Expects the given 'to' to be in one of the following formats:
  *      sip[s]:endpoint[/aor]
- *      sip[s]:endpoint[/uri]
- *      sip[s]:uri <-- will use default outbound endpoint
+ *      sip[s]:endpoint[/uri] - Where uri is: sip[s]:user@domain
+ *      sip[s]:endpoint[@domain]
+ *      sip[s]:unknown_user@domain <-- will use default outbound endpoint
  *
  * If an optional aor is given it will try to find an associated uri
  * to return.  If an optional uri is given then that will be returned,
@@ -116,50 +117,66 @@ static const char *skip_sip(const char *
  * \param to 'From' or 'To' field with possible endpoint
  * \param uri Optional uri to return
  */
-static struct ast_sip_endpoint* get_outbound_endpoint(
-	const char *to, char **uri)
+static struct ast_sip_endpoint *get_outbound_endpoint(const char *to, char **uri)
 {
-	char *name, *aor_uri;
-	struct ast_sip_endpoint* endpoint;
-	RAII_VAR(struct ast_sip_aor *, aor, NULL, ao2_cleanup);
-	RAII_VAR(struct ast_sip_contact *, contact, NULL, ao2_cleanup);
+	char *name;
+	char *aor_uri;
+	struct ast_sip_endpoint *endpoint;
 
 	name = ast_strdupa(skip_sip(to));
 
 	/* attempt to extract the endpoint name */
 	if ((aor_uri = strchr(name, '/'))) {
-		/* format was 'endpoint/' */
+		/* format was 'endpoint/(aor_name | uri)' */
 		*aor_uri++ = '\0';
 	} else if ((aor_uri = strchr(name, '@'))) {
-		/* format was 'endpoint@' - don't use the rest */
+		/* format was 'endpoint@domain' - discard the domain */
 		*aor_uri = '\0';
+
+		/*
+		 * We may want to match without any user options getting
+		 * in the way.
+		 */
+		AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(name);
 	}
 
 	/* at this point, if name is not empty then it
 	   might be an endpoint, so try to retrieve it */
-	if (ast_strlen_zero(name) || !(endpoint = ast_sorcery_retrieve_by_id(
-		      ast_sip_get_sorcery(), "endpoint", name))) {
+	if (ast_strlen_zero(name)
+		|| !(endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint",
+			name))) {
 		/* an endpoint was not found, so assume sending directly
 		   to a uri and use the default outbound endpoint */
 		*uri = ast_strdup(to);
 		return ast_sip_default_outbound_endpoint();
 	}
 
-	*uri = aor_uri;
-	if (*uri) {
-		char *end = strchr(*uri, '>');
+	if (ast_strlen_zero(aor_uri)) {
+		*uri = NULL;
+	} else {
+		struct ast_sip_aor *aor;
+		struct ast_sip_contact *contact = NULL;
+		char *end;
+
+		/* Trim off any stray angle bracket that shouldn't be here */
+		end = strchr(aor_uri, '>');
 		if (end) {
-			*end++ = '\0';
+			*end = '\0';
 		}
 
-		/* if what's in 'uri' is a retrievable aor use the uri on it
-		   instead, otherwise assume what's there is already a uri*/
-		if ((aor = ast_sip_location_retrieve_aor(*uri)) &&
-			(contact = ast_sip_location_retrieve_first_aor_contact(aor))) {
-			*uri = (char*)contact->uri;
+		/*
+		 * if what's in 'uri' is a retrievable aor use the uri on it
+		 * instead, otherwise assume what's there is already a uri
+		 */
+		aor = ast_sip_location_retrieve_aor(aor_uri);
+		if (aor && (contact = ast_sip_location_retrieve_first_aor_contact(aor))) {
+			aor_uri = (char *) contact->uri;
 		}
 		/* need to copy because underlying uri goes away */
-		*uri = ast_strdup(*uri);
+		*uri = ast_strdup(aor_uri);
+
+		ao2_cleanup(contact);
+		ao2_cleanup(aor);
 	}
 
 	return endpoint;
@@ -176,16 +193,16 @@ static struct ast_sip_endpoint* get_outb
  */
 static void update_to(pjsip_tx_data *tdata, char *to)
 {
-	pjsip_name_addr *name_addr = (pjsip_name_addr *)
-		PJSIP_MSG_TO_HDR(tdata->msg)->uri;
-	pjsip_uri *parsed;
-
-	if ((parsed = pjsip_parse_uri(tdata->pool, to, strlen(to),
-				      PJSIP_PARSE_URI_AS_NAMEADDR))) {
-		pjsip_name_addr *parsed_name_addr = (pjsip_name_addr *)parsed;
+	pjsip_name_addr *parsed_name_addr;
+
+	parsed_name_addr = (pjsip_name_addr *) pjsip_parse_uri(tdata->pool, to, strlen(to),
+		PJSIP_PARSE_URI_AS_NAMEADDR);
+	if (parsed_name_addr) {
 		if (pj_strlen(&parsed_name_addr->display)) {
-			pj_strdup(tdata->pool, &name_addr->display,
-				  &parsed_name_addr->display);
+			pjsip_name_addr *name_addr =
+				(pjsip_name_addr *) PJSIP_MSG_TO_HDR(tdata->msg)->uri;
+
+			pj_strdup(tdata->pool, &name_addr->display, &parsed_name_addr->display);
 		}
 	}
 }
@@ -204,22 +221,32 @@ static void update_to(pjsip_tx_data *tda
  */
 static void update_from(pjsip_tx_data *tdata, char *from)
 {
-	pjsip_name_addr *name_addr = (pjsip_name_addr *)
-		PJSIP_MSG_FROM_HDR(tdata->msg)->uri;
-	pjsip_sip_uri *uri = pjsip_uri_get_uri(name_addr);
-	pjsip_uri *parsed;
+	pjsip_name_addr *name_addr;
+	pjsip_sip_uri *uri;
+	pjsip_name_addr *parsed_name_addr;
 
 	if (ast_strlen_zero(from)) {
 		return;
 	}
 
-	if ((parsed = pjsip_parse_uri(tdata->pool, from, strlen(from),
-				      PJSIP_PARSE_URI_AS_NAMEADDR))) {
-		pjsip_name_addr *parsed_name_addr = (pjsip_name_addr *)parsed;
-		pjsip_sip_uri *parsed_uri = pjsip_uri_get_uri(parsed_name_addr->uri);
+	name_addr = (pjsip_name_addr *) PJSIP_MSG_FROM_HDR(tdata->msg)->uri;
+	uri = pjsip_uri_get_uri(name_addr);
+
+	parsed_name_addr = (pjsip_name_addr *) pjsip_parse_uri(tdata->pool, from,
+		strlen(from), PJSIP_PARSE_URI_AS_NAMEADDR);
+	if (parsed_name_addr) {
+		pjsip_sip_uri *parsed_uri;
+
+		if (!PJSIP_URI_SCHEME_IS_SIP(parsed_name_addr->uri)
+				&& !PJSIP_URI_SCHEME_IS_SIPS(parsed_name_addr->uri)) {
+			ast_log(LOG_WARNING, "From address '%s' is not a valid SIP/SIPS URI\n", from);
+			return;
+		}
+
+		parsed_uri = pjsip_uri_get_uri(parsed_name_addr->uri);
+
 		if (pj_strlen(&parsed_name_addr->display)) {
-			pj_strdup(tdata->pool, &name_addr->display,
-				  &parsed_name_addr->display);
+			pj_strdup(tdata->pool, &name_addr->display, &parsed_name_addr->display);
 		}
 
 		pj_strdup(tdata->pool, &uri->user, &parsed_uri->user);
@@ -228,11 +255,17 @@ static void update_from(pjsip_tx_data *t
 	} else {
 		/* assume it is 'user[@domain]' format */
 		char *domain = strchr(from, '@');
+
 		if (domain) {
-			*domain++ = '\0';
-			pj_strdup2(tdata->pool, &uri->host, domain);
+			pj_str_t pj_from;
+
+			pj_strset3(&pj_from, from, domain);
+			pj_strdup(tdata->pool, &uri->user, &pj_from);
+
+			pj_strdup2(tdata->pool, &uri->host, domain + 1);
+		} else {
+			pj_strdup2(tdata->pool, &uri->user, from);
 		}
-		pj_strdup2(tdata->pool, &uri->user, from);
 	}
 }
 
@@ -448,6 +481,12 @@ static enum pjsip_status_code rx_data_to
 	sip_ruri = pjsip_uri_get_uri(ruri);
 	ast_copy_pj_str(exten, &sip_ruri->user, AST_MAX_EXTENSION);
 
+	/*
+	 * We may want to match in the dialplan without any user
+	 * options getting in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(exten);
+
 	endpt = ast_pjsip_rdata_get_endpoint(rdata);
 	ast_assert(endpt != NULL);
 
@@ -476,6 +515,24 @@ static enum pjsip_status_code rx_data_to
 	field = pj_sockaddr_print(&rdata->pkt_info.src_addr, buf, sizeof(buf) - 1, 1);
 	res |= ast_msg_set_var(msg, "PJSIP_RECVADDR", field);
 
+	switch (rdata->tp_info.transport->key.type) {
+	case PJSIP_TRANSPORT_UDP:
+	case PJSIP_TRANSPORT_UDP6:
+		field = "udp";
+		break;
+	case PJSIP_TRANSPORT_TCP:
+	case PJSIP_TRANSPORT_TCP6:
+		field = "tcp";
+		break;
+	case PJSIP_TRANSPORT_TLS:
+	case PJSIP_TRANSPORT_TLS6:
+		field = "tls";
+		break;
+	default:
+		field = rdata->tp_info.transport->type_name;
+	}
+	ast_msg_set_var(msg, "PJSIP_TRANSPORT", field);
+
 	if (print_body(rdata, buf, sizeof(buf) - 1) > 0) {
 		res |= ast_msg_set_body(msg, "%s", buf);
 	}
@@ -508,9 +565,9 @@ static void msg_data_destroy(void *obj)
 	ast_msg_destroy(mdata->msg);
 }
 
-static struct msg_data* msg_data_create(const struct ast_msg *msg, const char *to, const char *from)
+static struct msg_data *msg_data_create(const struct ast_msg *msg, const char *to, const char *from)
 {
-	char *tag;
+	char *uri_params;
 	struct msg_data *mdata = ao2_alloc(sizeof(*mdata), msg_data_destroy);
 
 	if (!mdata) {
@@ -518,26 +575,31 @@ static struct msg_data* msg_data_create(
 	}
 
 	/* typecast to suppress const warning */
-	mdata->msg = ast_msg_ref((struct ast_msg*)msg);
+	mdata->msg = ast_msg_ref((struct ast_msg *) msg);
 
-	/* starts with 'pjsip:' the 'pj' needs to be removed and maybe even
-	   the entire string. */
+	/* To starts with 'pjsip:' which needs to be removed. */
 	if (!(to = strchr(to, ':'))) {
 		ao2_ref(mdata, -1);
 		return NULL;
 	}
+	++to;/* Now skip the ':' */
 
 	/* Make sure we start with sip: */
-	mdata->to = ast_begins_with(to, "sip:") ? ast_strdup(++to) : ast_strdup(to - 3);
+	mdata->to = ast_begins_with(to, "sip:") ? ast_strdup(to) : ast_strdup(to - 4);
 	mdata->from = ast_strdup(from);
 	if (!mdata->to || !mdata->from) {
 		ao2_ref(mdata, -1);
 		return NULL;
 	}
 
-	/* sometimes from can still contain the tag at this point, so remove it */
-	if ((tag = strchr(mdata->from, ';'))) {
-		*tag = '\0';
+	/*
+	 * Sometimes from URI can contain URI parameters, so remove them.
+	 *
+	 * sip:user;user-options@domain;uri-parameters
+	 */
+	uri_params = strchr(mdata->from, '@');
+	if (uri_params && (uri_params = strchr(mdata->from, ';'))) {
+		*uri_params = '\0';
 	}
 	return mdata;
 }
@@ -554,12 +616,13 @@ static int msg_send(void *data)
 
 	pjsip_tx_data *tdata;
 	RAII_VAR(char *, uri, NULL, ast_free);
-	RAII_VAR(struct ast_sip_endpoint *, endpoint, get_outbound_endpoint(
-			 mdata->to, &uri), ao2_cleanup);
+	RAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);
 
+	endpoint = get_outbound_endpoint(mdata->to, &uri);
 	if (!endpoint) {
-		ast_log(LOG_ERROR, "PJSIP MESSAGE - Could not find endpoint '%s' and "
-			"no default outbound endpoint configured\n", mdata->to);
+		ast_log(LOG_ERROR,
+			"PJSIP MESSAGE - Could not find endpoint '%s' and no default outbound endpoint configured\n",
+			mdata->to);
 		return -1;
 	}
 
diff -urpN asterisk-13.9.1/res/res_pjsip_multihomed.c asterisk-13.17.0/res/res_pjsip_multihomed.c
--- asterisk-13.9.1/res/res_pjsip_multihomed.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_multihomed.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,222 +0,0 @@
-/*
- * Asterisk -- An open source telephony toolkit.
- *
- * Copyright (C) 2014, Digium, Inc.
- *
- * Joshua Colp <jcolp@digium.com>
- *
- * See http://www.asterisk.org for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*** MODULEINFO
-	<depend>pjproject</depend>
-	<depend>res_pjsip</depend>
-	<support_level>core</support_level>
- ***/
-
-#include "asterisk.h"
-
-#include <pjsip.h>
-#include <pjsip_ua.h>
-
-#include "asterisk/res_pjsip.h"
-#include "asterisk/module.h"
-
-/*! \brief Helper function which returns a UDP transport bound to the given address and port */
-static pjsip_transport *multihomed_get_udp_transport(pj_str_t *address, int port)
-{
-	struct ao2_container *transport_states = ast_sip_get_transport_states();
-	struct ast_sip_transport_state *transport_state;
-	struct ao2_iterator iter;
-	pjsip_transport *sip_transport = NULL;
-
-	if (!transport_states) {
-		return NULL;
-	}
-
-	for (iter = ao2_iterator_init(transport_states, 0); (transport_state = ao2_iterator_next(&iter)); ao2_ref(transport_state, -1)) {
-		if (transport_state && ((transport_state->type != AST_TRANSPORT_UDP) ||
-			(pj_strcmp(&transport_state->transport->local_name.host, address)) ||
-			(transport_state->transport->local_name.port != port))) {
-			continue;
-		}
-
-		sip_transport = transport_state->transport;
-		break;
-	}
-	ao2_iterator_destroy(&iter);
-
-	ao2_ref(transport_states, -1);
-
-	return sip_transport;
-}
-
-/*! \brief Helper function which determines if the address within SDP should be rewritten */
-static int multihomed_rewrite_sdp(struct pjmedia_sdp_session *sdp)
-{
-	if (!sdp->conn) {
-		return 0;
-	}
-
-	/* If the host address is used in the SDP replace it with the address of what this is going out on */
-	if ((!pj_strcmp2(&sdp->conn->addr_type, "IP4") && !pj_strcmp2(&sdp->conn->addr,
-		ast_sip_get_host_ip_string(pj_AF_INET()))) ||
-		(!pj_strcmp2(&sdp->conn->addr_type, "IP6") && !pj_strcmp2(&sdp->conn->addr,
-		ast_sip_get_host_ip_string(pj_AF_INET6())))) {
-		return 1;
-	}
-
-	return 0;
-}
-
-/*! \brief Helper function which determines if a transport is bound to any */
-static int multihomed_bound_any(pjsip_transport *transport)
-{
-	pj_uint32_t loop6[4] = {0, 0, 0, 0};
-
-	if ((transport->local_addr.addr.sa_family == pj_AF_INET() &&
-		transport->local_addr.ipv4.sin_addr.s_addr == PJ_INADDR_ANY) ||
-		(transport->local_addr.addr.sa_family == pj_AF_INET6() &&
-		!pj_memcmp(&transport->local_addr.ipv6.sin6_addr, loop6, sizeof(loop6)))) {
-		return 1;
-	}
-
-	return 0;
-}
-
-static pj_status_t multihomed_on_tx_message(pjsip_tx_data *tdata)
-{
-	pjsip_tpmgr_fla2_param prm;
-	pjsip_cseq_hdr *cseq;
-	pjsip_via_hdr *via;
-
-	/* Use the destination information to determine what local interface this message will go out on */
-	pjsip_tpmgr_fla2_param_default(&prm);
-	prm.tp_type = tdata->tp_info.transport->key.type;
-	pj_strset2(&prm.dst_host, tdata->tp_info.dst_name);
-	prm.local_if = PJ_TRUE;
-
-	/* If we can't get the local address use best effort and let it pass */
-	if (pjsip_tpmgr_find_local_addr2(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()), tdata->pool, &prm) != PJ_SUCCESS) {
-		return PJ_SUCCESS;
-	}
-
-	/* The port in the message should always be that of the original transport */
-	prm.ret_port = tdata->tp_info.transport->local_name.port;
-
-	/* If the IP source differs from the existing transport see if we need to update it */
-	if (pj_strcmp(&prm.ret_addr, &tdata->tp_info.transport->local_name.host)) {
-
-		/* If the transport it is going out on is different reflect it in the message */
-		if (tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP ||
-			tdata->tp_info.transport->key.type == PJSIP_TRANSPORT_UDP6) {
-			pjsip_transport *transport;
-
-			transport = multihomed_get_udp_transport(&prm.ret_addr, prm.ret_port);
-
-			if (transport) {
-				tdata->tp_info.transport = transport;
-			}
-		}
-
-		/* If the chosen transport is not bound to any we can't use the source address as it won't get back to us */
-		if (!multihomed_bound_any(tdata->tp_info.transport)) {
-			pj_strassign(&prm.ret_addr, &tdata->tp_info.transport->local_name.host);
-		}
-	} else {
-		/* The transport chosen will deliver this but ensure it is updated with the right information */
-		pj_strassign(&prm.ret_addr, &tdata->tp_info.transport->local_name.host);
-	}
-
-	/* If the message needs to be updated with new address do so */
-	if (tdata->msg->type == PJSIP_REQUEST_MSG || !(cseq = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CSEQ, NULL)) ||
-		pj_strcmp2(&cseq->method.name, "REGISTER")) {
-		pjsip_contact_hdr *contact = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL);
-		if (contact && (PJSIP_URI_SCHEME_IS_SIP(contact->uri) || PJSIP_URI_SCHEME_IS_SIPS(contact->uri))
-			&& !(tdata->msg->type == PJSIP_RESPONSE_MSG && tdata->msg->line.status.code / 100 == 3)) {
-			pjsip_sip_uri *uri = pjsip_uri_get_uri(contact->uri);
-
-			/* prm.ret_addr is allocated from the tdata pool OR the transport so it is perfectly fine to just do an assignment like this */
-			pj_strassign(&uri->host, &prm.ret_addr);
-			uri->port = prm.ret_port;
-			ast_debug(4, "Re-wrote Contact URI host/port to %.*s:%d\n",
-				(int)pj_strlen(&uri->host), pj_strbuf(&uri->host), uri->port);
-
-			pjsip_tx_data_invalidate_msg(tdata);
-		}
-	}
-
-	if (tdata->msg->type == PJSIP_REQUEST_MSG && (via = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL))) {
-		pj_strassign(&via->sent_by.host, &prm.ret_addr);
-		via->sent_by.port = prm.ret_port;
-
-		pjsip_tx_data_invalidate_msg(tdata);
-	}
-
-	/* Update the SDP if it is present */
-	if (tdata->msg->body && ast_sip_is_content_type(&tdata->msg->body->content_type, "application", "sdp") &&
-		multihomed_rewrite_sdp(tdata->msg->body->data)) {
-		struct pjmedia_sdp_session *sdp = tdata->msg->body->data;
-		int stream;
-
-		pj_strassign(&sdp->conn->addr, &prm.ret_addr);
-
-		for (stream = 0; stream < sdp->media_count; ++stream) {
-			if (sdp->media[stream]->conn) {
-				pj_strassign(&sdp->media[stream]->conn->addr, &prm.ret_addr);
-			}
-		}
-
-		pjsip_tx_data_invalidate_msg(tdata);
-	}
-
-	return PJ_SUCCESS;
-}
-
-static pjsip_module multihomed_module = {
-	.name = { "Multihomed Routing", 18 },
-	.id = -1,
-	.priority = PJSIP_MOD_PRIORITY_TSX_LAYER - 1,
-	.on_tx_request = multihomed_on_tx_message,
-	.on_tx_response = multihomed_on_tx_message,
-};
-
-static int unload_module(void)
-{
-	ast_sip_unregister_service(&multihomed_module);
-	return 0;
-}
-
-static int load_module(void)
-{
-	char hostname[MAXHOSTNAMELEN] = "";
-
-	CHECK_PJSIP_MODULE_LOADED();
-
-	if (!gethostname(hostname, sizeof(hostname) - 1)) {
-		ast_verb(2, "Performing DNS resolution of local hostname '%s' to get local IPv4 and IPv6 address\n",
-			hostname);
-	}
-
-	if (ast_sip_register_service(&multihomed_module)) {
-		ast_log(LOG_ERROR, "Could not register multihomed module for incoming and outgoing requests\n");
-		return AST_MODULE_LOAD_FAILURE;
-	}
-
-	return AST_MODULE_LOAD_SUCCESS;
-}
-
-AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP Multihomed Routing Support",
-		.support_level = AST_MODULE_SUPPORT_CORE,
-		.load = load_module,
-		.unload = unload_module,
-		.load_pri = AST_MODPRI_APP_DEPEND,
-	       );
diff -urpN asterisk-13.9.1/res/res_pjsip_mwi.c asterisk-13.17.0/res/res_pjsip_mwi.c
--- asterisk-13.9.1/res/res_pjsip_mwi.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_mwi.c	2017-07-12 13:12:08.000000000 +0200
@@ -35,6 +35,7 @@
 #include "asterisk/module.h"
 #include "asterisk/logger.h"
 #include "asterisk/astobj2.h"
+#include "asterisk/taskprocessor.h"
 #include "asterisk/sorcery.h"
 #include "asterisk/stasis.h"
 #include "asterisk/app.h"
@@ -52,6 +53,12 @@ static char *default_voicemail_extension
 
 #define MWI_DATASTORE "MWI datastore"
 
+/*! Number of serializers in pool if one not supplied. */
+#define MWI_SERIALIZER_POOL_SIZE 8
+
+/*! Pool of serializers to use if not supplied. */
+static struct ast_taskprocessor *mwi_serializer_pool[MWI_SERIALIZER_POOL_SIZE];
+
 static void mwi_subscription_shutdown(struct ast_sip_subscription *sub);
 static void mwi_to_ami(struct ast_sip_subscription *sub, struct ast_str **buf);
 static int mwi_new_subscribe(struct ast_sip_endpoint *endpoint,
@@ -119,6 +126,117 @@ struct mwi_subscription {
 	char id[1];
 };
 
+/*!
+ * \internal
+ * \brief Shutdown the serializers in the mwi pool.
+ * \since 13.12.0
+ *
+ * \return Nothing
+ */
+static void mwi_serializer_pool_shutdown(void)
+{
+	int idx;
+
+	for (idx = 0; idx < MWI_SERIALIZER_POOL_SIZE; ++idx) {
+		ast_taskprocessor_unreference(mwi_serializer_pool[idx]);
+		mwi_serializer_pool[idx] = NULL;
+	}
+}
+
+/*!
+ * \internal
+ * \brief Setup the serializers in the mwi pool.
+ * \since 13.12.0
+ *
+ * \retval 0 on success.
+ * \retval -1 on error.
+ */
+static int mwi_serializer_pool_setup(void)
+{
+	char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
+	int idx;
+
+	for (idx = 0; idx < MWI_SERIALIZER_POOL_SIZE; ++idx) {
+		/* Create name with seq number appended. */
+		ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/mwi");
+
+		mwi_serializer_pool[idx] = ast_sip_create_serializer_named(tps_name);
+		if (!mwi_serializer_pool[idx]) {
+			mwi_serializer_pool_shutdown();
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*!
+ * \internal
+ * \brief Pick a mwi serializer from the pool.
+ * \since 13.12.0
+ *
+ * \retval least queue size task processor.
+ */
+static struct ast_taskprocessor *get_mwi_serializer(void)
+{
+	int idx;
+	int pos;
+
+	if (!mwi_serializer_pool[0]) {
+		return NULL;
+	}
+
+	for (pos = idx = 0; idx < MWI_SERIALIZER_POOL_SIZE; ++idx) {
+		if (ast_taskprocessor_size(mwi_serializer_pool[idx]) < ast_taskprocessor_size(mwi_serializer_pool[pos])) {
+			pos = idx;
+		}
+	}
+
+	return mwi_serializer_pool[pos];
+}
+
+/*!
+ * \internal
+ * \brief Set taskprocessor alert levels for the serializers in the mwi pool.
+ * \since 13.12.0
+ *
+ * \retval 0 on success.
+ * \retval -1 on error.
+ */
+static int mwi_serializer_set_alert_levels(void)
+{
+	int idx;
+	long tps_queue_high;
+	long tps_queue_low;
+
+	if (!mwi_serializer_pool[0]) {
+		return -1;
+	}
+
+	tps_queue_high = ast_sip_get_mwi_tps_queue_high();
+	if (tps_queue_high <= 0) {
+		ast_log(AST_LOG_WARNING, "Invalid taskprocessor high water alert trigger level '%ld'\n",
+			tps_queue_high);
+		tps_queue_high = AST_TASKPROCESSOR_HIGH_WATER_LEVEL;
+	}
+
+	tps_queue_low = ast_sip_get_mwi_tps_queue_low();
+	if (tps_queue_low < -1 || tps_queue_high < tps_queue_low) {
+		ast_log(AST_LOG_WARNING, "Invalid taskprocessor low water clear alert level '%ld'\n",
+			tps_queue_low);
+		tps_queue_low = -1;
+	}
+
+	for (idx = 0; idx < MWI_SERIALIZER_POOL_SIZE; ++idx) {
+		if (ast_taskprocessor_alert_set_levels(mwi_serializer_pool[idx], tps_queue_low, tps_queue_high)) {
+			ast_log(AST_LOG_WARNING, "Failed to set alert levels for MWI serializer pool #%d.\n",
+				idx);
+		}
+	}
+
+	return 0;
+}
+
+
 static void mwi_stasis_cb(void *userdata, struct stasis_subscription *sub,
 		struct stasis_message *msg);
 
@@ -384,6 +502,7 @@ static int send_unsolicited_mwi_notify_t
 	body.subtype = MWI_SUBTYPE;
 	body_text = ast_str_create(64);
 	if (!body_text) {
+		pjsip_tx_data_dec_ref(tdata);
 		return 0;
 	}
 
@@ -399,6 +518,7 @@ static int send_unsolicited_mwi_notify_t
 	if (ast_sip_pubsub_generate_body_content(body.type, body.subtype, &body_data, &body_text)) {
 		ast_log(LOG_WARNING, "Unable to generate SIP MWI NOTIFY body.\n");
 		ast_free(body_text);
+		pjsip_tx_data_dec_ref(tdata);
 		return 0;
 	}
 
@@ -630,7 +750,6 @@ static int endpoint_receives_unsolicited
 	int ret = 0;
 
 	mwi_subs = ao2_find(unsolicited_mwi, endpoint_id, OBJ_SEARCH_KEY | OBJ_MULTIPLE);
-
 	if (!mwi_subs) {
 		return 0;
 	}
@@ -945,7 +1064,7 @@ static int send_notify(void *obj, void *
 	struct mwi_subscription *mwi_sub = obj;
 	struct ast_taskprocessor *serializer = mwi_sub->is_solicited
 		? ast_sip_subscription_get_serializer(mwi_sub->sip_sub)
-		: NULL;
+		: get_mwi_serializer();
 
 	if (ast_sip_push_task(serializer, serialized_notify, ao2_bump(mwi_sub))) {
 		ao2_ref(mwi_sub, -1);
@@ -971,44 +1090,25 @@ static void mwi_stasis_cb(void *userdata
 	}
 }
 
-/*! \note Called with the unsolicited_mwi conainer lock held. */
+/*! \note Called with the unsolicited_mwi container lock held. */
 static int create_mwi_subscriptions_for_endpoint(void *obj, void *arg, int flags)
 {
 	RAII_VAR(struct mwi_subscription *, aggregate_sub, NULL, ao2_cleanup);
 	struct ast_sip_endpoint *endpoint = obj;
-	char *endpoint_aors, *aor_name, *mailboxes, *mailbox;
-	struct ao2_container *contacts = NULL;
+	char *mailboxes, *mailbox;
 
 	if (ast_strlen_zero(endpoint->subscription.mwi.mailboxes)) {
 		return 0;
 	}
 
-	endpoint_aors = ast_strdupa(endpoint->aors);
-
-	while ((aor_name = ast_strip(strsep(&endpoint_aors, ",")))) {
-		RAII_VAR(struct ast_sip_aor *, aor, ast_sip_location_retrieve_aor(aor_name), ao2_cleanup);
-
-		if (!aor) {
-			continue;
-		}
+	if (endpoint->subscription.mwi.aggregate) {
+		const char *endpoint_id = ast_sorcery_object_get_id(endpoint);
 
-		contacts = ast_sip_location_retrieve_aor_contacts(aor);
-		if (!contacts || (ao2_container_count(contacts) == 0)) {
-			ao2_cleanup(contacts);
-			contacts = NULL;
-			continue;
+		/* Check if subscription exists */
+		aggregate_sub = ao2_find(unsolicited_mwi, endpoint_id, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+		if (aggregate_sub) {
+			return 0;
 		}
-
-		break;
-	}
-
-	if (!contacts) {
-		return 0;
-	}
-
-	ao2_ref(contacts, -1);
-
-	if (endpoint->subscription.mwi.aggregate) {
 		aggregate_sub = mwi_subscription_alloc(endpoint, 0, NULL);
 		if (!aggregate_sub) {
 			return 0;
@@ -1020,7 +1120,9 @@ static int create_mwi_subscriptions_for_
 		struct mwi_subscription *sub;
 		struct mwi_stasis_subscription *mwi_stasis_sub;
 
-		if (ast_strlen_zero(mailbox)) {
+		/* check if subscription exists */
+		if (ast_strlen_zero(mailbox) ||
+			(!aggregate_sub && endpoint_receives_unsolicited_mwi_for_mailbox(endpoint, mailbox))) {
 			continue;
 		}
 
@@ -1089,56 +1191,101 @@ static int send_contact_notify(void *obj
 		return 0;
 	}
 
-	if (ast_sip_push_task(NULL, serialized_notify, ao2_bump(mwi_sub))) {
+	if (ast_sip_push_task(get_mwi_serializer(), serialized_notify, ao2_bump(mwi_sub))) {
 		ao2_ref(mwi_sub, -1);
 	}
 
 	return 0;
 }
 
-/*! \brief Function called when a contact is updated */
-static void mwi_contact_updated(const void *object)
+/*! \brief Create mwi subscriptions and notify */
+static void mwi_contact_changed(const struct ast_sip_contact *contact)
 {
-	char *id = ast_strdupa(ast_sorcery_object_get_id(object)), *aor = NULL;
+	char *id = ast_strdupa(ast_sorcery_object_get_id(contact));
+	char *aor = NULL;
+	struct ast_sip_endpoint *endpoint = NULL;
 
-	aor = strsep(&id, ";@");
+	if (contact->endpoint) {
+		endpoint = ao2_bump(contact->endpoint);
+	} else {
+		if (!ast_strlen_zero(contact->endpoint_name)) {
+			endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", contact->endpoint_name);
+		}
+	}
+
+	if (!endpoint || ast_strlen_zero(endpoint->subscription.mwi.mailboxes)) {
+		ao2_cleanup(endpoint);
+		return;
+	}
 
+	ao2_lock(unsolicited_mwi);
+	create_mwi_subscriptions_for_endpoint(endpoint, NULL, 0);
+	ao2_unlock(unsolicited_mwi);
+	ao2_cleanup(endpoint);
+
+	aor = strsep(&id, ";@");
 	ao2_callback(unsolicited_mwi, OBJ_NODATA, send_contact_notify, aor);
 }
 
+/*! \brief Function called when a contact is updated */
+static void mwi_contact_updated(const void *object)
+{
+	mwi_contact_changed(object);
+}
+
 /*! \brief Function called when a contact is added */
 static void mwi_contact_added(const void *object)
 {
+	mwi_contact_changed(object);
+}
+
+/*! \brief Function called when a contact is deleted */
+static void mwi_contact_deleted(const void *object)
+{
 	const struct ast_sip_contact *contact = object;
 	struct ao2_iterator *mwi_subs;
 	struct mwi_subscription *mwi_sub;
-	const char *endpoint_id = ast_sorcery_object_get_id(contact->endpoint);
+	struct ast_sip_endpoint *endpoint = NULL;
+	struct ast_sip_contact *found_contact;
+
+	if (contact->endpoint) {
+		endpoint = ao2_bump(contact->endpoint);
+	} else {
+		if (!ast_strlen_zero(contact->endpoint_name)) {
+			endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", contact->endpoint_name);
+		}
+	}
 
-	if (ast_strlen_zero(contact->endpoint->subscription.mwi.mailboxes)) {
+	if (!endpoint || ast_strlen_zero(endpoint->subscription.mwi.mailboxes)) {
+		ao2_cleanup(endpoint);
 		return;
 	}
 
-	ao2_lock(unsolicited_mwi);
+	/* Check if there is another contact */
+	found_contact = ast_sip_location_retrieve_contact_from_aor_list(endpoint->aors);
+	ao2_cleanup(endpoint);
+	if (found_contact) {
+		ao2_cleanup(found_contact);
+		return;
+	}
 
-	mwi_subs = ao2_find(unsolicited_mwi, endpoint_id, OBJ_SEARCH_KEY | OBJ_MULTIPLE | OBJ_NOLOCK | OBJ_UNLINK);
+	ao2_lock(unsolicited_mwi);
+	mwi_subs = ao2_find(unsolicited_mwi, contact->endpoint_name,
+		OBJ_SEARCH_KEY | OBJ_MULTIPLE | OBJ_NOLOCK | OBJ_UNLINK);
 	if (mwi_subs) {
 		for (; (mwi_sub = ao2_iterator_next(mwi_subs)); ao2_cleanup(mwi_sub)) {
 			unsubscribe(mwi_sub, NULL, 0);
 		}
 		ao2_iterator_destroy(mwi_subs);
 	}
-
-	create_mwi_subscriptions_for_endpoint(contact->endpoint, NULL, 0);
-
 	ao2_unlock(unsolicited_mwi);
-
-	mwi_contact_updated(object);
 }
 
 /*! \brief Observer for contacts so unsolicited MWI is sent when a contact changes */
 static const struct ast_sorcery_observer mwi_contact_observer = {
 	.created = mwi_contact_added,
 	.updated = mwi_contact_updated,
+	.deleted = mwi_contact_deleted,
 };
 
 /*! \brief Task invoked to send initial MWI NOTIFY for unsolicited */
@@ -1175,6 +1322,7 @@ static void global_loaded(const char *ob
 {
 	ast_free(default_voicemail_extension);
 	default_voicemail_extension = ast_sip_get_default_voicemail_extension();
+	mwi_serializer_set_alert_levels();
 }
 
 static struct ast_sorcery_observer global_observer = {
@@ -1183,7 +1331,9 @@ static struct ast_sorcery_observer globa
 
 static int reload(void)
 {
-	create_mwi_subscriptions();
+	if (!ast_sip_get_mwi_disable_initial_unsolicited()) {
+		create_mwi_subscriptions();
+	}
 	return 0;
 }
 
@@ -1195,21 +1345,29 @@ static int load_module(void)
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
-	unsolicited_mwi = ao2_container_alloc(MWI_BUCKETS, mwi_sub_hash, mwi_sub_cmp);
+	if (mwi_serializer_pool_setup()) {
+		ast_log(AST_LOG_WARNING, "Failed to create MWI serializer pool. The default SIP pool will be used for MWI\n");
+	}
+
+	unsolicited_mwi = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0, MWI_BUCKETS,
+		mwi_sub_hash, NULL, mwi_sub_cmp);
 	if (!unsolicited_mwi) {
+		mwi_serializer_pool_shutdown();
 		ast_sip_unregister_subscription_handler(&mwi_handler);
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
-	create_mwi_subscriptions();
 	ast_sorcery_observer_add(ast_sip_get_sorcery(), "contact", &mwi_contact_observer);
 	ast_sorcery_observer_add(ast_sip_get_sorcery(), "global", &global_observer);
 	ast_sorcery_reload_object(ast_sip_get_sorcery(), "global");
 
-	if (ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {
-		ast_sip_push_task(NULL, send_initial_notify_all, NULL);
-	} else {
-		stasis_subscribe_pool(ast_manager_get_topic(), mwi_startup_event_cb, NULL);
+	if (!ast_sip_get_mwi_disable_initial_unsolicited()) {
+		create_mwi_subscriptions();
+		if (ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {
+			ast_sip_push_task(NULL, send_initial_notify_all, NULL);
+		} else {
+			stasis_subscribe_pool(ast_manager_get_topic(), mwi_startup_event_cb, NULL);
+		}
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
@@ -1217,19 +1375,26 @@ static int load_module(void)
 
 static int unload_module(void)
 {
-	ao2_callback(unsolicited_mwi, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, unsubscribe, NULL);
-	ao2_ref(unsolicited_mwi, -1);
 	ast_sorcery_observer_remove(ast_sip_get_sorcery(), "global", &global_observer);
 	ast_sorcery_observer_remove(ast_sip_get_sorcery(), "contact", &mwi_contact_observer);
+
+	ao2_callback(unsolicited_mwi, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, unsubscribe, NULL);
+	ao2_ref(unsolicited_mwi, -1);
+	unsolicited_mwi = NULL;
+
+	mwi_serializer_pool_shutdown();
+
 	ast_sip_unregister_subscription_handler(&mwi_handler);
+
 	ast_free(default_voicemail_extension);
+	default_voicemail_extension = NULL;
 	return 0;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP MWI resource",
-		.support_level = AST_MODULE_SUPPORT_CORE,
-		.load = load_module,
-		.unload = unload_module,
-		.reload = reload,
-		.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.unload = unload_module,
+	.reload = reload,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND + 5,
 );
diff -urpN asterisk-13.9.1/res/res_pjsip_mwi_body_generator.c asterisk-13.17.0/res/res_pjsip_mwi_body_generator.c
--- asterisk-13.9.1/res/res_pjsip_mwi_body_generator.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_mwi_body_generator.c	2017-07-12 13:12:08.000000000 +0200
@@ -61,11 +61,11 @@ static int mwi_generate_body_content(voi
 
 	ast_str_append(mwi, 0, "Messages-Waiting: %s\r\n",
 			counter->new_msgs ? "yes" : "no");
-	ast_str_append(mwi, 0, "Voice-Message: %d/%d (0/0)\r\n",
-			counter->new_msgs, counter->old_msgs);
 	if (!ast_strlen_zero(counter->message_account))  {
 		ast_str_append(mwi, 0, "Message-Account: %s\r\n", counter->message_account);
 	}
+	ast_str_append(mwi, 0, "Voice-Message: %d/%d (0/0)\r\n",
+			counter->new_msgs, counter->old_msgs);
 
 	return 0;
 }
diff -urpN asterisk-13.9.1/res/res_pjsip_nat.c asterisk-13.17.0/res/res_pjsip_nat.c
--- asterisk-13.9.1/res/res_pjsip_nat.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_nat.c	2017-07-12 13:12:08.000000000 +0200
@@ -35,7 +35,9 @@
 static void rewrite_uri(pjsip_rx_data *rdata, pjsip_sip_uri *uri)
 {
 	pj_cstr(&uri->host, rdata->pkt_info.src_name);
-	if (strcasecmp("udp", rdata->tp_info.transport->type_name)) {
+	if (!strcasecmp("WSS", rdata->tp_info.transport->type_name)) {
+		/* WSS is special, we don't want to overwrite the URI at all as it needs to be ws */
+	} else if (strcasecmp("udp", rdata->tp_info.transport->type_name)) {
 		uri->transport_param = pj_str(rdata->tp_info.transport->type_name);
 	} else {
 		uri->transport_param.slen = 0;
@@ -260,32 +262,33 @@ static pj_status_t nat_on_tx_message(pjs
 		return PJ_SUCCESS;
 	}
 
-	if ( !transport_state->localnet || 	ast_sockaddr_isnull(&transport_state->external_address)) {
-		return PJ_SUCCESS;
-	}
-
-	ast_sockaddr_parse(&addr, tdata->tp_info.dst_name, PARSE_PORT_FORBID);
-	ast_sockaddr_set_port(&addr, tdata->tp_info.dst_port);
-
-	/* See if where we are sending this request is local or not, and if not that we can get a Contact URI to modify */
-	if (ast_apply_ha(transport_state->localnet, &addr) != AST_SENSE_ALLOW) {
-		return PJ_SUCCESS;
+	if (transport_state->localnet) {
+		ast_sockaddr_parse(&addr, tdata->tp_info.dst_name, PARSE_PORT_FORBID);
+		ast_sockaddr_set_port(&addr, tdata->tp_info.dst_port);
+
+		/* See if where we are sending this request is local or not, and if not that we can get a Contact URI to modify */
+		if (ast_apply_ha(transport_state->localnet, &addr) != AST_SENSE_ALLOW) {
+			ast_debug(5, "Request is being sent to local address, skipping NAT manipulation\n");
+			return PJ_SUCCESS;
+		}
 	}
 
-	/* Update the contact header with the external address */
-	if (uri || (uri = nat_get_contact_sip_uri(tdata))) {
-		pj_strdup2(tdata->pool, &uri->host, ast_sockaddr_stringify_host(&transport_state->external_address));
-		if (transport->external_signaling_port) {
-			uri->port = transport->external_signaling_port;
-			ast_debug(4, "Re-wrote Contact URI port to %d\n", uri->port);
+	if (!ast_sockaddr_isnull(&transport_state->external_address)) {
+		/* Update the contact header with the external address */
+		if (uri || (uri = nat_get_contact_sip_uri(tdata))) {
+			pj_strdup2(tdata->pool, &uri->host, ast_sockaddr_stringify_host(&transport_state->external_address));
+			if (transport->external_signaling_port) {
+				uri->port = transport->external_signaling_port;
+				ast_debug(4, "Re-wrote Contact URI port to %d\n", uri->port);
+			}
 		}
-	}
 
-	/* Update the via header if relevant */
-	if ((tdata->msg->type == PJSIP_REQUEST_MSG) && (via || (via = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL)))) {
-		pj_strdup2(tdata->pool, &via->sent_by.host, ast_sockaddr_stringify_host(&transport_state->external_address));
-		if (transport->external_signaling_port) {
-			via->sent_by.port = transport->external_signaling_port;
+		/* Update the via header if relevant */
+		if ((tdata->msg->type == PJSIP_REQUEST_MSG) && (via || (via = pjsip_msg_find_hdr(tdata->msg, PJSIP_H_VIA, NULL)))) {
+			pj_strdup2(tdata->pool, &via->sent_by.host, ast_sockaddr_stringify_host(&transport_state->external_address));
+			if (transport->external_signaling_port) {
+				via->sent_by.port = transport->external_signaling_port;
+			}
 		}
 	}
 
@@ -358,13 +361,13 @@ static int load_module(void)
 
 	if (ast_sip_register_service(&nat_module)) {
 		ast_log(LOG_ERROR, "Could not register NAT module for incoming and outgoing requests\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_sip_session_register_supplement(&nat_supplement)) {
 		ast_log(LOG_ERROR, "Could not register NAT session supplement for incoming and outgoing INVITE requests\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_pjsip_one_touch_record_info.c asterisk-13.17.0/res/res_pjsip_one_touch_record_info.c
--- asterisk-13.9.1/res/res_pjsip_one_touch_record_info.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_one_touch_record_info.c	2017-07-12 13:12:08.000000000 +0200
@@ -72,13 +72,13 @@ static int handle_incoming_request(struc
 
 	if (!session->channel) {
 		send_response(session, 481, rdata);
-		return 0;
+		return 1;
 	}
 
 	/* Is this endpoint configured with One Touch Recording? */
 	if (!session->endpoint->info.recording.enabled || ast_strlen_zero(feature)) {
 		send_response(session, 403, rdata);
-		return 0;
+		return 1;
 	}
 
 	ast_channel_lock(session->channel);
@@ -87,7 +87,7 @@ static int handle_incoming_request(struc
 
 	if (feature_res || ast_strlen_zero(feature_code)) {
 		send_response(session, 403, rdata);
-		return 0;
+		return 1;
 	}
 
 	for (digit = feature_code; *digit; ++digit) {
@@ -97,11 +97,12 @@ static int handle_incoming_request(struc
 
 	send_response(session, 200, rdata);
 
-	return 0;
+	return 1;
 }
 
 static struct ast_sip_session_supplement info_supplement = {
 	.method = "INFO",
+	.priority = AST_SIP_SUPPLEMENT_PRIORITY_FIRST,
 	.incoming_request = handle_incoming_request,
 };
 
@@ -111,7 +112,7 @@ static int load_module(void)
 
 	if (ast_sip_session_register_supplement(&info_supplement)) {
 		ast_log(LOG_ERROR, "Unable to register One Touch Recording supplement\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_pjsip_outbound_authenticator_digest.c asterisk-13.17.0/res/res_pjsip_outbound_authenticator_digest.c
--- asterisk-13.9.1/res/res_pjsip_outbound_authenticator_digest.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_outbound_authenticator_digest.c	2017-07-12 13:12:08.000000000 +0200
@@ -31,7 +31,9 @@
 #include "asterisk/module.h"
 #include "asterisk/strings.h"
 
-static pjsip_www_authenticate_hdr *get_auth_header(pjsip_rx_data *challenge) {
+static pjsip_www_authenticate_hdr *get_auth_header(pjsip_rx_data *challenge,
+	const void *start)
+{
 	pjsip_hdr_e search_type;
 
 	if (challenge->msg_info.msg->line.status.code == PJSIP_SC_UNAUTHORIZED) {
@@ -45,17 +47,17 @@ static pjsip_www_authenticate_hdr *get_a
 		return NULL ;
 	}
 
-	return pjsip_msg_find_hdr(challenge->msg_info.msg, search_type, NULL);
+	return pjsip_msg_find_hdr(challenge->msg_info.msg, search_type, start);
 
 }
 
 static int set_outbound_authentication_credentials(pjsip_auth_clt_sess *auth_sess,
-		const struct ast_sip_auth_vector *auth_vector, pjsip_rx_data *challenge)
+		const struct ast_sip_auth_vector *auth_vector, pjsip_rx_data *challenge,
+		pjsip_www_authenticate_hdr *auth_hdr)
 {
 	size_t auth_size = AST_VECTOR_SIZE(auth_vector);
 	struct ast_sip_auth **auths = ast_alloca(auth_size * sizeof(*auths));
 	pjsip_cred_info *auth_creds = ast_alloca(auth_size * sizeof(*auth_creds));
-	pjsip_www_authenticate_hdr *auth_hdr = NULL;
 	int res = 0;
 	int i;
 
@@ -64,13 +66,6 @@ static int set_outbound_authentication_c
 		goto cleanup;
 	}
 
-	auth_hdr = get_auth_header(challenge);
-	if (auth_hdr == NULL) {
-		res = -1;
-		ast_log(LOG_ERROR, "Unable to find authenticate header in challenge.\n");
-		goto cleanup;
-	}
-
 	for (i = 0; i < auth_size; ++i) {
 		if (ast_strlen_zero(auths[i]->realm)) {
 			auth_creds[i].realm = auth_hdr->challenge.common.realm;
@@ -101,25 +96,64 @@ cleanup:
 	return res;
 }
 
-static int digest_create_request_with_auth_from_old(const struct ast_sip_auth_vector *auths, pjsip_rx_data *challenge,
-		pjsip_tx_data *old_request, pjsip_tx_data **new_request)
+static int digest_create_request_with_auth_from_old(const struct ast_sip_auth_vector *auths,
+	pjsip_rx_data *challenge, pjsip_tx_data *old_request, pjsip_tx_data **new_request)
 {
 	pjsip_auth_clt_sess auth_sess;
 	pjsip_cseq_hdr *cseq;
+	pj_status_t status;
+	struct ast_sip_endpoint *endpoint;
+	char *id = NULL;
+	const char *id_type;
+	pjsip_www_authenticate_hdr *auth_hdr;
+	struct ast_str *realms;
+	pjsip_dialog *dlg;
+
+	dlg = pjsip_rdata_get_dlg(challenge);
+	if (dlg) {
+		endpoint = ast_sip_dialog_get_endpoint(dlg);
+		id = endpoint ? ast_strdupa(ast_sorcery_object_get_id(endpoint)) : NULL;
+		ao2_cleanup(endpoint);
+		id_type = "Endpoint";
+	}
+	/* If there was no dialog, then this is probably a REGISTER so no endpoint */
+	if (!id) {
+		id = ast_alloca(strlen(challenge->pkt_info.src_name) + 7 /* ':' + port + NULL */);
+		sprintf(id, "%s:%d", challenge->pkt_info.src_name, challenge->pkt_info.src_port);
+		id_type = "Host";
+	}
+
+	auth_hdr = get_auth_header(challenge, NULL);
+	if (auth_hdr == NULL) {
+		ast_log(LOG_ERROR, "%s: '%s': Unable to find authenticate header in challenge.\n",
+			id_type, id);
+		return -1;
+	}
 
 	if (pjsip_auth_clt_init(&auth_sess, ast_sip_get_pjsip_endpoint(),
 				old_request->pool, 0) != PJ_SUCCESS) {
-		ast_log(LOG_WARNING, "Failed to initialize client authentication session\n");
+		ast_log(LOG_ERROR, "%s: '%s': Failed to initialize client authentication session\n",
+			id_type, id);
 		return -1;
 	}
 
-	if (set_outbound_authentication_credentials(&auth_sess, auths, challenge)) {
-		ast_log(LOG_WARNING, "Failed to set authentication credentials\n");
+	if (set_outbound_authentication_credentials(&auth_sess, auths, challenge, auth_hdr)) {
+		ast_log(LOG_WARNING, "%s: '%s': Failed to set authentication credentials\n",
+			id_type, id);
+#if defined(HAVE_PJSIP_AUTH_CLT_DEINIT)
+		/* In case it is not a noop here in the future. */
+		pjsip_auth_clt_deinit(&auth_sess);
+#endif
 		return -1;
 	}
 
-	switch (pjsip_auth_clt_reinit_req(&auth_sess, challenge,
-				old_request, new_request)) {
+	status = pjsip_auth_clt_reinit_req(&auth_sess, challenge, old_request, new_request);
+#if defined(HAVE_PJSIP_AUTH_CLT_DEINIT)
+	/* Release any cached auths */
+	pjsip_auth_clt_deinit(&auth_sess);
+#endif
+
+	switch (status) {
 	case PJ_SUCCESS:
 		/* PJSIP creates a new transaction for new_request (meaning it creates a new
 		 * branch). However, it recycles the Call-ID, from-tag, and CSeq from the
@@ -132,18 +166,33 @@ static int digest_create_request_with_au
 		++cseq->cseq;
 		return 0;
 	case PJSIP_ENOCREDENTIAL:
-		ast_log(LOG_WARNING, "Unable to create request with auth."
-				"No auth credentials for any realms in challenge.\n");
+		realms = ast_str_create(32);
+		if (realms) {
+			ast_str_append(&realms, 0, "%.*s", (int)auth_hdr->challenge.common.realm.slen,
+				auth_hdr->challenge.common.realm.ptr);
+			while((auth_hdr = get_auth_header(challenge, auth_hdr->next))) {
+				ast_str_append(&realms, 0, ",%.*s", (int)auth_hdr->challenge.common.realm.slen,
+					auth_hdr->challenge.common.realm.ptr);
+			}
+		}
+		ast_log(LOG_WARNING,
+			"%s: '%s': Unable to create request with auth. "
+			"No auth credentials for realm(s) '%s' in challenge.\n", id_type, id,
+			realms ? ast_str_buffer(realms) : "<unknown>");
+		ast_free(realms);
 		break;
 	case PJSIP_EAUTHSTALECOUNT:
-		ast_log(LOG_WARNING, "Unable to create request with auth."
-				"Number of stale retries exceeded\n");
+		ast_log(LOG_WARNING,
+			"%s: '%s': Unable to create request with auth.  Number of stale retries exceeded.\n",
+			id_type, id);
 		break;
 	case PJSIP_EFAILEDCREDENTIAL:
-		ast_log(LOG_WARNING, "Authentication credentials not accepted by server\n");
+		ast_log(LOG_WARNING, "%s: '%s': Authentication credentials not accepted by server.\n",
+			id_type, id);
 		break;
 	default:
-		ast_log(LOG_WARNING, "Unable to create request with auth. Unknown failure\n");
+		ast_log(LOG_WARNING, "%s: '%s': Unable to create request with auth. Unknown failure.\n",
+			id_type, id);
 		break;
 	}
 
diff -urpN asterisk-13.9.1/res/res_pjsip_outbound_publish.c asterisk-13.17.0/res/res_pjsip_outbound_publish.c
--- asterisk-13.9.1/res/res_pjsip_outbound_publish.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_outbound_publish.c	2017-07-12 13:12:08.000000000 +0200
@@ -31,6 +31,7 @@
 #include "asterisk/res_pjsip_outbound_publish.h"
 #include "asterisk/module.h"
 #include "asterisk/taskprocessor.h"
+#include "asterisk/threadpool.h"
 #include "asterisk/datastore.h"
 
 /*** DOCUMENTATION
@@ -53,10 +54,21 @@
 					<synopsis>Expiration time for publications in seconds</synopsis>
 				</configOption>
 				<configOption name="outbound_auth" default="">
-					<synopsis>Authentication object to be used for outbound publishes.</synopsis>
+					<synopsis>Authentication object(s) to be used for outbound publishes.</synopsis>
+					<description><para>
+						This is a comma-delimited list of <replaceable>auth</replaceable>
+						sections defined in <filename>pjsip.conf</filename> used to respond
+						to outbound authentication challenges.</para>
+						<note><para>
+						Using the same auth section for inbound and outbound
+						authentication is not recommended.  There is a difference in
+						meaning for an empty realm setting between inbound and outbound
+						authentication uses.  See the auth realm description for details.
+						</para></note>
+					</description>
 				</configOption>
 				<configOption name="outbound_proxy" default="">
-					<synopsis>SIP URI of the outbound proxy used to send publishes</synopsis>
+					<synopsis>Full SIP URI of the outbound proxy used to send publishes</synopsis>
 				</configOption>
 				<configOption name="server_uri">
 					<synopsis>SIP URI of the server and entity to publish to</synopsis>
@@ -161,6 +173,8 @@ struct ast_sip_outbound_publish_client {
 	struct ast_sip_outbound_publish *publish;
 	/*! \brief The name of the transport to be used for the publish */
 	char *transport_name;
+	/*! \brief Serializer for stuff and things */
+	struct ast_taskprocessor *serializer;
 };
 
 /*! \brief Outbound publish state information (persists for lifetime of a publish) */
@@ -171,13 +185,11 @@ struct ast_sip_outbound_publish_state {
 	char id[0];
 };
 
-/*! \brief Unloading data */
-struct unloading_data {
-	int is_unloading;
-	int count;
-	ast_mutex_t lock;
-	ast_cond_t cond;
-} unloading;
+/*! Time needs to be long enough for a transaction to timeout if nothing replies. */
+#define MAX_UNLOAD_TIMEOUT_TIME		35	/* Seconds */
+
+/*! Shutdown group to monitor sip_outbound_registration_client_state serializers. */
+static struct ast_serializer_shutdown_group *shutdown_group;
 
 /*! \brief Default number of client state container buckets */
 #define DEFAULT_STATE_BUCKETS 31
@@ -348,6 +360,7 @@ static int send_unpublish_task(void *dat
 			pjsip_tx_data_set_transport(tdata, &selector);
 		}
 
+		ast_sip_record_request_serializer(tdata);
 		pjsip_publishc_send(client->client, tdata);
 	}
 
@@ -389,11 +402,11 @@ static void sip_outbound_publish_synchro
 			} else {
 				state->client->started = 1;
 			}
-		} else if (state->client->started && !handler && removed && !strcmp(publish->event, removed->event_name)) {
+		} else if (!handler && removed && !strcmp(publish->event, removed->event_name)) {
 			/* If the publisher client has been started but it is going away stop it */
 			removed->stop_publishing(state->client);
 			state->client->started = 0;
-			if (ast_sip_push_task(NULL, cancel_refresh_timer_task, ao2_bump(state->client))) {
+			if (ast_sip_push_task(state->client->serializer, cancel_refresh_timer_task, ao2_bump(state->client))) {
 				ast_log(LOG_WARNING, "Could not stop refresh timer on client '%s'\n",
 					ast_sorcery_object_get_id(publish));
 				ao2_ref(state->client, -1);
@@ -406,22 +419,30 @@ static void sip_outbound_publish_synchro
 	ao2_ref(states, -1);
 }
 
-struct ast_sip_outbound_publish_client *ast_sip_publish_client_get(const char *name)
+static struct ast_sip_outbound_publish_state *sip_publish_state_get(const char *id)
 {
-	RAII_VAR(struct ao2_container *, states,
-		 ao2_global_obj_ref(current_states), ao2_cleanup);
-	RAII_VAR(struct ast_sip_outbound_publish_state *, state, NULL, ao2_cleanup);
+	struct ao2_container *states = ao2_global_obj_ref(current_states);
+	struct ast_sip_outbound_publish_state *res;
 
 	if (!states) {
 		return NULL;
 	}
 
-	state = ao2_find(states, name, OBJ_SEARCH_KEY);
+	res = ao2_find(states, id, OBJ_SEARCH_KEY);
+	ao2_ref(states, -1);
+	return res;
+}
+
+struct ast_sip_outbound_publish_client *ast_sip_publish_client_get(const char *name)
+{
+	struct ast_sip_outbound_publish_state *state = sip_publish_state_get(name);
+
 	if (!state) {
 		return NULL;
 	}
 
 	ao2_ref(state->client, +1);
+	ao2_ref(state, -1);
 	return state->client;
 }
 
@@ -589,6 +610,7 @@ static int sip_publish_client_service_qu
 		pjsip_tx_data_set_transport(tdata, &selector);
 	}
 
+	ast_sip_record_request_serializer(tdata);
 	status = pjsip_publishc_send(client->client, tdata);
 	if (status == PJ_EBUSY) {
 		/* We attempted to send the message but something else got there first */
@@ -606,7 +628,7 @@ fatal:
 	ast_free(message);
 
 service:
-	if (ast_sip_push_task(NULL, sip_publish_client_service_queue, ao2_bump(client))) {
+	if (ast_sip_push_task(client->serializer, sip_publish_client_service_queue, ao2_bump(client))) {
 		ao2_ref(client, -1);
 	}
 	return -1;
@@ -648,7 +670,7 @@ int ast_sip_publish_client_send(struct a
 
 	AST_LIST_INSERT_TAIL(&client->queue, message, entry);
 
-	res = ast_sip_push_task(NULL, sip_publish_client_service_queue, ao2_bump(client));
+	res = ast_sip_push_task(client->serializer, sip_publish_client_service_queue, ao2_bump(client));
 	if (res) {
 		ao2_ref(client, -1);
 	}
@@ -671,24 +693,22 @@ static void sip_outbound_publish_client_
 	ao2_cleanup(client->datastores);
 	ao2_cleanup(client->publish);
 	ast_free(client->transport_name);
-
-	/* if unloading the module and all objects have been unpublished
-	   send the signal to finish unloading */
-	if (unloading.is_unloading) {
-		ast_mutex_lock(&unloading.lock);
-		if (--unloading.count == 0) {
-			ast_cond_signal(&unloading.cond);
-		}
-		ast_mutex_unlock(&unloading.lock);
-	}
+	ast_taskprocessor_unreference(client->serializer);
 }
 
 static int explicit_publish_destroy(void *data)
 {
 	struct ast_sip_outbound_publish_client *client = data;
 
-	pjsip_publishc_destroy(client->client);
-	ao2_ref(client, -1);
+	/*
+	 * If there is no pjsip publishing client then we obviously don't need
+	 * to destroy it. Also, the ref for the Asterisk publishing client that
+	 * pjsip had would not exist or should already be gone as well.
+	 */
+	if (client->client) {
+		pjsip_publishc_destroy(client->client);
+		ao2_ref(client, -1);
+	}
 
 	return 0;
 }
@@ -703,7 +723,7 @@ static int cancel_and_unpublish(struct a
 		/* If the client was never started, there's nothing to unpublish, so just
 		 * destroy the publication and remove its reference to the client.
 		 */
-		ast_sip_push_task(NULL, explicit_publish_destroy, client);
+		ast_sip_push_task(client->serializer, explicit_publish_destroy, client);
 		return 0;
 	}
 
@@ -713,7 +733,7 @@ static int cancel_and_unpublish(struct a
 	}
 
 	client->started = 0;
-	if (ast_sip_push_task(NULL, cancel_refresh_timer_task, ao2_bump(client))) {
+	if (ast_sip_push_task(client->serializer, cancel_refresh_timer_task, ao2_bump(client))) {
 		ast_log(LOG_WARNING, "Could not stop refresh timer on outbound publish '%s'\n",
 			ast_sorcery_object_get_id(client->publish));
 		ao2_ref(client, -1);
@@ -721,7 +741,7 @@ static int cancel_and_unpublish(struct a
 
 	/* If nothing is being sent right now send the unpublish - the destroy will happen in the subsequent callback */
 	if (!client->sending) {
-		if (ast_sip_push_task(NULL, send_unpublish_task, ao2_bump(client))) {
+		if (ast_sip_push_task(client->serializer, send_unpublish_task, ao2_bump(client))) {
 			ast_log(LOG_WARNING, "Could not send unpublish message on outbound publish '%s'\n",
 				ast_sorcery_object_get_id(client->publish));
 			ao2_ref(client, -1);
@@ -868,6 +888,11 @@ static int sip_outbound_publish_client_a
 /*! \brief Callback function for publish client responses */
 static void sip_outbound_publish_callback(struct pjsip_publishc_cbparam *param)
 {
+#define DESTROY_CLIENT() do {			   \
+	pjsip_publishc_destroy(client->client); \
+	client->client = NULL; \
+	ao2_ref(client, -1); } while (0)
+
 	RAII_VAR(struct ast_sip_outbound_publish_client *, client, ao2_bump(param->token), ao2_cleanup);
 	RAII_VAR(struct ast_sip_outbound_publish *, publish, ao2_bump(client->publish), ao2_cleanup);
 	SCOPED_AO2LOCK(lock, client);
@@ -877,7 +902,7 @@ static void sip_outbound_publish_callbac
 		if (client->sending) {
 			client->sending = NULL;
 
-			if (!ast_sip_push_task(NULL, send_unpublish_task, ao2_bump(client))) {
+			if (!ast_sip_push_task(client->serializer, send_unpublish_task, ao2_bump(client))) {
 				return;
 			}
 			ast_log(LOG_WARNING, "Could not send unpublish message on outbound publish '%s'\n",
@@ -885,8 +910,7 @@ static void sip_outbound_publish_callbac
 			ao2_ref(client, -1);
 		}
 		/* Once the destroy is called this callback will not get called any longer, so drop the client ref */
-		pjsip_publishc_destroy(client->client);
-		ao2_ref(client, -1);
+		DESTROY_CLIENT();
 		return;
 	}
 
@@ -899,14 +923,13 @@ static void sip_outbound_publish_callbac
 				pjsip_tx_data_set_transport(tdata, &selector);
 			}
 
+			ast_sip_record_request_serializer(tdata);
 			pjsip_publishc_send(client->client, tdata);
 		}
 		client->auth_attempts++;
 
 		if (client->auth_attempts == publish->max_auth_attempts) {
-			pjsip_publishc_destroy(client->client);
-			client->client = NULL;
-
+			DESTROY_CLIENT();
 			ast_log(LOG_ERROR, "Reached maximum number of PUBLISH authentication attempts on outbound publish '%s'\n",
 				ast_sorcery_object_get_id(publish));
 
@@ -918,9 +941,7 @@ static void sip_outbound_publish_callbac
 	client->auth_attempts = 0;
 
 	if (param->code == 412) {
-		pjsip_publishc_destroy(client->client);
-		client->client = NULL;
-
+		DESTROY_CLIENT();
 		if (sip_outbound_publish_client_alloc(client)) {
 			ast_log(LOG_ERROR, "Failed to create a new outbound publish client for '%s' on 412 response\n",
 				ast_sorcery_object_get_id(publish));
@@ -935,10 +956,9 @@ static void sip_outbound_publish_callbac
 
 		expires = pjsip_msg_find_hdr(param->rdata->msg_info.msg, PJSIP_H_MIN_EXPIRES, NULL);
 		if (!expires || !expires->ivalue) {
+			DESTROY_CLIENT();
 			ast_log(LOG_ERROR, "Received 423 response on outbound publish '%s' without a Min-Expires header\n",
 				ast_sorcery_object_get_id(publish));
-			pjsip_publishc_destroy(client->client);
-			client->client = NULL;
 			goto end;
 		}
 
@@ -967,7 +987,7 @@ end:
 			ast_free(message);
 		}
 	} else {
-		if (ast_sip_push_task(NULL, sip_publish_client_service_queue, ao2_bump(client))) {
+		if (ast_sip_push_task(client->serializer, sip_publish_client_service_queue, ao2_bump(client))) {
 			ao2_ref(client, -1);
 		}
 	}
@@ -1039,6 +1059,7 @@ static struct ast_sip_outbound_publish_s
 	const char *id = ast_sorcery_object_get_id(publish);
 	struct ast_sip_outbound_publish_state *state =
 		ao2_alloc(sizeof(*state) + strlen(id) + 1, sip_outbound_publish_state_destroy);
+	char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
 
 	if (!state) {
 		return NULL;
@@ -1056,6 +1077,17 @@ static struct ast_sip_outbound_publish_s
 		return NULL;
 	}
 
+	/* Create name with seq number appended. */
+	ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/outpub/%s",
+		ast_sorcery_object_get_id(publish));
+
+	state->client->serializer = ast_sip_create_serializer_group_named(tps_name,
+		shutdown_group);
+	if (!state->client->serializer) {
+		ao2_ref(state, -1);
+		return NULL;
+	}
+
 	state->client->timer.user_data = state->client;
 	state->client->timer.cb = sip_outbound_publish_timer_cb;
 	state->client->transport_name = ast_strdup(publish->transport);
@@ -1065,25 +1097,89 @@ static struct ast_sip_outbound_publish_s
 	return state;
 }
 
-/*! \brief Apply function which finds or allocates a state structure */
-static int sip_outbound_publish_apply(const struct ast_sorcery *sorcery, void *obj)
+static int initialize_publish_client(struct ast_sip_outbound_publish *publish,
+				     struct ast_sip_outbound_publish_state *state)
 {
-	RAII_VAR(struct ao2_container *, states, ao2_global_obj_ref(current_states), ao2_cleanup);
-	RAII_VAR(struct ast_sip_outbound_publish_state *, state, NULL, ao2_cleanup);
-	struct ast_sip_outbound_publish *applied = obj;
+	if (ast_sip_push_task_synchronous(state->client->serializer, sip_outbound_publish_client_alloc, state->client)) {
+		ast_log(LOG_ERROR, "Unable to create client for outbound publish '%s'\n",
+			ast_sorcery_object_get_id(publish));
+		return -1;
+	}
+
+	return 0;
+}
 
-	if (ast_strlen_zero(applied->server_uri)) {
+static int validate_publish_config(struct ast_sip_outbound_publish *publish)
+{
+	if (ast_strlen_zero(publish->server_uri)) {
 		ast_log(LOG_ERROR, "No server URI specified on outbound publish '%s'\n",
-			ast_sorcery_object_get_id(applied));
+			ast_sorcery_object_get_id(publish));
 		return -1;
-	} else if (ast_strlen_zero(applied->event)) {
+	} else if (ast_strlen_zero(publish->event)) {
 		ast_log(LOG_ERROR, "No event type specified for outbound publish '%s'\n",
-			ast_sorcery_object_get_id(applied));
+			ast_sorcery_object_get_id(publish));
 		return -1;
 	}
+	return 0;
+}
+
+static int current_state_reusable(struct ast_sip_outbound_publish *publish,
+				  struct ast_sip_outbound_publish_state *current_state)
+{
+	struct ast_sip_outbound_publish *old_publish;
 
+	if (!can_reuse_publish(current_state->client->publish, publish)) {
+		/*
+		 * Something significant has changed in the configuration, so we are
+		 * unable to use the old state object. The current state needs to go
+		 * away and a new one needs to be created.
+		 */
+		return 0;
+	}
+
+	/*
+	 * We can reuse the current state object so keep it, but swap out the
+	 * underlying publish object with the new one.
+	 */
+	old_publish = current_state->client->publish;
+	current_state->client->publish = publish;
+	if (initialize_publish_client(publish, current_state)) {
+		/*
+		 * If the state object fails to re-initialize then swap
+		 * the old publish info back in.
+		 */
+		current_state->client->publish = publish;
+		return -1;
+	}
+
+	/*
+	 * Since we swapped out the publish object the new one needs a ref
+	 * while the old one needs to go away.
+	 */
+	ao2_ref(current_state->client->publish, +1);
+	ao2_cleanup(old_publish);
+
+	/* Tell the caller that the current state object should be used */
+	return 1;
+}
+
+/*! \brief Apply function which finds or allocates a state structure */
+static int sip_outbound_publish_apply(const struct ast_sorcery *sorcery, void *obj)
+{
+#define ADD_TO_NEW_STATES(__obj) \
+	do { if (__obj) { \
+	     ao2_link(new_states, __obj); \
+	     ao2_ref(__obj, -1); } } while (0)
+
+	struct ast_sip_outbound_publish *applied = obj;
+	struct ast_sip_outbound_publish_state *current_state, *new_state;
+	int res;
+
+	/*
+	 * New states are being loaded or reloaded. We'll need to add the new
+	 * object if created/updated, or keep the old object if an error occurs.
+	 */
 	if (!new_states) {
-		/* make sure new_states has been allocated as we will be adding to it */
 		new_states = ao2_container_alloc_options(
 			AO2_ALLOC_OPT_LOCK_NOLOCK, DEFAULT_STATE_BUCKETS,
 			outbound_publish_state_hash, outbound_publish_state_cmp);
@@ -1094,35 +1190,44 @@ static int sip_outbound_publish_apply(co
 		}
 	}
 
-	if (states) {
-		state = ao2_find(states, ast_sorcery_object_get_id(obj), OBJ_SEARCH_KEY);
-		if (state) {
-			if (can_reuse_publish(state->client->publish, applied)) {
-				ao2_replace(state->client->publish, applied);
-			} else {
-				ao2_ref(state, -1);
-				state = NULL;
-			}
-		}
+	/* If there is current state we'll want to maintain it if any errors occur */
+	current_state = sip_publish_state_get(ast_sorcery_object_get_id(applied));
+
+	if ((res = validate_publish_config(applied))) {
+		ADD_TO_NEW_STATES(current_state);
+		return res;
 	}
 
-	if (!state) {
-		state = sip_outbound_publish_state_alloc(applied);
-		if (!state) {
-			ast_log(LOG_ERROR, "Unable to create state for outbound publish '%s'\n",
-				ast_sorcery_object_get_id(applied));
-			return -1;
-		};
+	if (current_state && (res = current_state_reusable(applied, current_state))) {
+		/*
+		 * The current state object was able to be reused, or an error
+		 * occurred. Either way we keep the current state and be done.
+		 */
+		ADD_TO_NEW_STATES(current_state);
+		return res == 1 ? 0 : -1;
 	}
 
-	if (ast_sip_push_task_synchronous(NULL, sip_outbound_publish_client_alloc, state->client)) {
-		ast_log(LOG_ERROR, "Unable to create client for outbound publish '%s'\n",
+	/*
+	 * No current state was found or it was unable to be reused. Either way
+	 * we'll need to create a new state object.
+	 */
+	new_state = sip_outbound_publish_state_alloc(applied);
+	if (!new_state) {
+		ast_log(LOG_ERROR, "Unable to create state for outbound publish '%s'\n",
 			ast_sorcery_object_get_id(applied));
+		ADD_TO_NEW_STATES(current_state);
+		return -1;
+	};
+
+	if (initialize_publish_client(applied, new_state)) {
+		ADD_TO_NEW_STATES(current_state);
+		ao2_ref(new_state, -1);
 		return -1;
 	}
 
-	ao2_link(new_states, state);
-	return 0;
+	ADD_TO_NEW_STATES(new_state);
+	ao2_cleanup(current_state);
+	return res;
 }
 
 static int outbound_auth_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
@@ -1132,15 +1237,48 @@ static int outbound_auth_handler(const s
 	return ast_sip_auth_vector_init(&publish->outbound_auths, var->value);
 }
 
+
+static int unload_module(void)
+{
+	int remaining;
+
+	ast_sorcery_object_unregister(ast_sip_get_sorcery(), "outbound-publish");
+
+	ao2_global_obj_release(current_states);
+
+	/* Wait for publication serializers to get destroyed. */
+	ast_debug(2, "Waiting for publication to complete for unload.\n");
+	remaining = ast_serializer_shutdown_group_join(shutdown_group, MAX_UNLOAD_TIMEOUT_TIME);
+	if (remaining) {
+		ast_log(LOG_WARNING, "Unload incomplete.  Could not stop %d outbound publications.  Try again later.\n",
+			remaining);
+		return -1;
+	}
+
+	ast_debug(2, "Successful shutdown.\n");
+
+	ao2_cleanup(shutdown_group);
+	shutdown_group = NULL;
+
+	return 0;
+}
+
 static int load_module(void)
 {
 	CHECK_PJSIP_MODULE_LOADED();
 
+	shutdown_group = ast_serializer_shutdown_group_alloc();
+	if (!shutdown_group) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
 	ast_sorcery_apply_config(ast_sip_get_sorcery(), "res_pjsip_outbound_publish");
 	ast_sorcery_apply_default(ast_sip_get_sorcery(), "outbound-publish", "config", "pjsip.conf,criteria=type=outbound-publish");
 
 	if (ast_sorcery_object_register(ast_sip_get_sorcery(), "outbound-publish", sip_outbound_publish_alloc, NULL,
 		sip_outbound_publish_apply)) {
+		ast_log(LOG_ERROR, "Unable to register 'outbound-publish' type with sorcery\n");
+		unload_module();
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -1176,48 +1314,6 @@ static int reload_module(void)
 	return 0;
 }
 
-static int unload_module(void)
-{
-	struct timeval start = ast_tvnow();
-	struct timespec end = {
-		.tv_sec = start.tv_sec + 10,
-		.tv_nsec = start.tv_usec * 1000
-	};
-	int res = 0;
-	struct ao2_container *states = ao2_global_obj_ref(current_states);
-
-	if (!states || !(unloading.count = ao2_container_count(states))) {
-		return 0;
-	}
-	ao2_ref(states, -1);
-
-	ast_mutex_init(&unloading.lock);
-	ast_cond_init(&unloading.cond, NULL);
-	ast_mutex_lock(&unloading.lock);
-
-	unloading.is_unloading = 1;
-	ao2_global_obj_release(current_states);
-
-	/* wait for items to unpublish */
-	ast_verb(5, "Waiting to complete unpublishing task(s)\n");
-	while (unloading.count) {
-		res = ast_cond_timedwait(&unloading.cond, &unloading.lock, &end);
-	}
-	ast_mutex_unlock(&unloading.lock);
-
-	ast_mutex_destroy(&unloading.lock);
-	ast_cond_destroy(&unloading.cond);
-
-	if (res) {
-		ast_verb(5, "At least %d items were unable to unpublish "
-			"in the allowed time\n", unloading.count);
-	} else {
-		ast_verb(5, "All items successfully unpublished\n");
-	}
-
-	return res;
-}
-
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, "PJSIP Outbound Publish Support",
 		.load = load_module,
 		.reload = reload_module,
diff -urpN asterisk-13.9.1/res/res_pjsip_outbound_registration.c asterisk-13.17.0/res/res_pjsip_outbound_registration.c
--- asterisk-13.9.1/res/res_pjsip_outbound_registration.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_outbound_registration.c	2017-07-12 13:12:08.000000000 +0200
@@ -82,10 +82,21 @@
 					<synopsis>Maximum number of registration attempts.</synopsis>
 				</configOption>
 				<configOption name="outbound_auth" default="">
-					<synopsis>Authentication object to be used for outbound registrations.</synopsis>
+					<synopsis>Authentication object(s) to be used for outbound registrations.</synopsis>
+					<description><para>
+						This is a comma-delimited list of <replaceable>auth</replaceable>
+						sections defined in <filename>pjsip.conf</filename> used to respond
+						to outbound authentication challenges.</para>
+						<note><para>
+						Using the same auth section for inbound and outbound
+						authentication is not recommended.  There is a difference in
+						meaning for an empty realm setting between inbound and outbound
+						authentication uses.  See the auth realm description for details.
+						</para></note>
+					</description>
 				</configOption>
 				<configOption name="outbound_proxy" default="">
-					<synopsis>Outbound Proxy used to send registrations</synopsis>
+					<synopsis>Full SIP URI of the outbound proxy used to send registrations</synopsis>
 				</configOption>
 				<configOption name="retry_interval" default="60">
 					<synopsis>Interval in seconds between retries if outbound registration is unsuccessful</synopsis>
@@ -169,12 +180,12 @@
 		<syntax>
 			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
 			<parameter name="Registration" required="true">
-				<para>The outbound registration to unregister.</para>
+				<para>The outbound registration to unregister or '*all' to unregister them all.</para>
 			</parameter>
 		</syntax>
 		<description>
 			<para>
-			Unregisters the specified outbound registration and stops future registration attempts.
+			Unregisters the specified (or all) outbound registration(s) and stops future registration attempts.
 			Call PJSIPRegister to start registration and schedule re-registrations according to configuration.
             </para>
 		</description>
@@ -186,14 +197,13 @@
 		<syntax>
 			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
 			<parameter name="Registration" required="true">
-				<para>The outbound registration to register.</para>
+				<para>The outbound registration to register or '*all' to register them all.</para>
 			</parameter>
 		</syntax>
 		<description>
 			<para>
-			Unregisters the specified outbound registration then starts registration and schedules re-registrations
+			Unregisters the specified (or all) outbound registration(s) then starts registration and schedules re-registrations
 			according to configuration.
-			future registrations.
             </para>
 		</description>
 	</manager>
@@ -368,6 +378,9 @@ static struct ast_serializer_shutdown_gr
 #define DEFAULT_STATE_BUCKETS 53
 static AO2_GLOBAL_OBJ_STATIC(current_states);
 
+/*! subscription id for network change events */
+static struct stasis_subscription *network_change_sub;
+
 /*! \brief hashing function for state objects */
 static int registration_state_hash(const void *obj, const int flags)
 {
@@ -514,6 +527,7 @@ static pj_status_t registration_client_s
 
 	callback_invoked = ast_threadstorage_get(&register_callback_invoked, sizeof(int));
 	if (!callback_invoked) {
+		pjsip_tx_data_dec_ref(tdata);
 		return PJ_ENOMEM;
 	}
 	*callback_invoked = 0;
@@ -527,6 +541,7 @@ static pj_status_t registration_client_s
 	 */
 	ast_sip_set_tpselector_from_transport_name(client_state->transport_name, &selector);
 	pjsip_regc_set_transport(client_state->client, &selector);
+	ast_sip_record_request_serializer(tdata);
 	status = pjsip_regc_send(client_state->client, tdata);
 
 	/* If the attempt to send the message failed and the callback was not invoked we need to
@@ -567,6 +582,7 @@ static int handle_client_registration(vo
 			/* insert a new Supported header */
 			hdr = pjsip_supported_hdr_create(tdata->pool);
 			if (!hdr) {
+				pjsip_tx_data_dec_ref(tdata);
 				return -1;
 			}
 
@@ -625,15 +641,30 @@ static void schedule_registration(struct
 
 static void update_client_state_status(struct sip_outbound_registration_client_state *client_state, enum sip_outbound_registration_status status)
 {
+	const char *status_old;
+	const char *status_new;
+
 	if (client_state->status == status) {
+		/* Status state did not change at all. */
+		return;
+	}
+
+	status_old = sip_outbound_registration_status_str(client_state->status);
+	status_new = sip_outbound_registration_status_str(status);
+	client_state->status = status;
+
+	if (!strcmp(status_old, status_new)) {
+		/*
+		 * The internal status state may have changed but the status
+		 * state we tell the world did not change at all.
+		 */
 		return;
 	}
 
 	ast_statsd_log_string_va("PJSIP.registrations.state.%s", AST_STATSD_GAUGE, "-1", 1.0,
-		sip_outbound_registration_status_str(client_state->status));
+		status_old);
 	ast_statsd_log_string_va("PJSIP.registrations.state.%s", AST_STATSD_GAUGE, "+1", 1.0,
-		sip_outbound_registration_status_str(status));
-	client_state->status = status;
+		status_new);
 }
 
 /*! \brief Callback function for unregistering (potentially) and destroying state */
@@ -1056,7 +1087,7 @@ static int sip_dialog_create_contact(pj_
 	pj_str_t tmp, local_addr;
 	pjsip_uri *uri;
 	pjsip_sip_uri *sip_uri;
-	pjsip_transport_type_e type = PJSIP_TRANSPORT_UNSPECIFIED;
+	pjsip_transport_type_e type;
 	int local_port;
 
 	pj_strdup_with_null(pool, &tmp, target);
@@ -1068,20 +1099,20 @@ static int sip_dialog_create_contact(pj_
 
 	sip_uri = pjsip_uri_get_uri(uri);
 
+	type = pjsip_transport_get_type_from_name(&sip_uri->transport_param);
 	if (PJSIP_URI_SCHEME_IS_SIPS(sip_uri)) {
-		type = PJSIP_TRANSPORT_TLS;
+		if (type == PJSIP_TRANSPORT_UNSPECIFIED
+			|| !(pjsip_transport_get_flag_from_type(type) & PJSIP_TRANSPORT_SECURE)) {
+			type = PJSIP_TRANSPORT_TLS;
+		}
 	} else if (!sip_uri->transport_param.slen) {
 		type = PJSIP_TRANSPORT_UDP;
-	} else {
-		type = pjsip_transport_get_type_from_name(&sip_uri->transport_param);
-	}
-
-	if (type == PJSIP_TRANSPORT_UNSPECIFIED) {
+	} else if (type == PJSIP_TRANSPORT_UNSPECIFIED) {
 		return -1;
 	}
 
 	if (pj_strchr(&sip_uri->host, ':')) {
-		type = (pjsip_transport_type_e)(((int)type) + PJSIP_TRANSPORT_IPV6);
+		type |= PJSIP_TRANSPORT_IPV6;
 	}
 
 	if (pjsip_tpmgr_find_local_addr(pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint()),
@@ -1090,13 +1121,13 @@ static int sip_dialog_create_contact(pj_
 	}
 
 	if (!pj_strchr(&sip_uri->host, ':') && pj_strchr(&local_addr, ':')) {
-		type = (pjsip_transport_type_e)(((int)type) + PJSIP_TRANSPORT_IPV6);
+		type |= PJSIP_TRANSPORT_IPV6;
 	}
 
 	contact->ptr = pj_pool_alloc(pool, PJSIP_MAX_URL_SIZE);
 	contact->slen = pj_ansi_snprintf(contact->ptr, PJSIP_MAX_URL_SIZE,
 		"<%s:%s@%s%.*s%s:%d%s%s%s%s>",
-		(pjsip_transport_get_flag_from_type(type) & PJSIP_TRANSPORT_SECURE) ? "sips" : "sip",
+		((pjsip_transport_get_flag_from_type(type) & PJSIP_TRANSPORT_SECURE) && PJSIP_URI_SCHEME_IS_SIPS(uri)) ? "sips" : "sip",
 		user,
 		(type & PJSIP_TRANSPORT_IPV6) ? "[" : "",
 		(int)local_addr.slen,
@@ -1181,6 +1212,17 @@ static int sip_outbound_registration_reg
 		return -1;
 	}
 
+	if (!ast_strlen_zero(registration->outbound_proxy)) {
+		pj_strdup2_with_null(pool, &tmp, registration->outbound_proxy);
+		uri = pjsip_parse_uri(pool, tmp.ptr, tmp.slen, 0);
+		if (!uri) {
+			ast_log(LOG_ERROR, "Invalid outbound proxy URI '%s' specified on outbound registration '%s'\n",
+				registration->outbound_proxy, ast_sorcery_object_get_id(registration));
+			pjsip_endpt_release_pool(ast_sip_get_pjsip_endpoint(), pool);
+			return -1;
+		}
+	}
+
 	pjsip_endpt_release_pool(ast_sip_get_pjsip_endpoint(), pool);
 
 
@@ -1430,6 +1472,26 @@ static int queue_register(struct sip_out
 	return 0;
 }
 
+static void unregister_all(void)
+{
+	struct ao2_container *states;
+
+	states = ao2_global_obj_ref(current_states);
+	if (!states) {
+		return;
+	}
+
+	/* Clean out all the states and let sorcery handle recreating the registrations */
+	ao2_callback(states, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
+	ao2_ref(states, -1);
+}
+
+static void reregister_all(void)
+{
+	unregister_all();
+	ast_sorcery_load_object(ast_sip_get_sorcery(), "registration");
+}
+
 static char *cli_complete_registration(const char *line, const char *word,
 				       int pos, int state)
 {
@@ -1445,6 +1507,10 @@ static char *cli_complete_registration(c
 	}
 
 	wordlen = strlen(word);
+	if (wordlen == 0 && ++which > state) {
+		return ast_strdup("*all");
+	}
+
 	registrations = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(), "registration",
 		AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
 	if (!registrations) {
@@ -1479,8 +1545,9 @@ static char *cli_unregister(struct ast_c
 	case CLI_INIT:
 		e->command = "pjsip send unregister";
 		e->usage =
-			"Usage: pjsip send unregister <registration>\n"
-			"       Unregisters the specified outbound registration and stops future registration attempts.\n";
+			"Usage: pjsip send unregister <registration> | *all\n"
+			"       Unregisters the specified (or all) outbound registration(s) "
+			"and stops future registration attempts.\n";
 		return NULL;
 	case CLI_GENERATE:
 		return cli_complete_registration(a->line, a->word, a->pos, a->n);
@@ -1492,6 +1559,12 @@ static char *cli_unregister(struct ast_c
 
 	registration_name = a->argv[3];
 
+	if (strcmp(registration_name, "*all") == 0) {
+		unregister_all();
+		ast_cli(a->fd, "Unregister all queued\n");
+		return CLI_SUCCESS;
+	}
+
 	state = get_state(registration_name);
 	if (!state) {
 		ast_cli(a->fd, "Unable to retrieve registration %s\n", registration_name);
@@ -1515,9 +1588,9 @@ static char *cli_register(struct ast_cli
 	case CLI_INIT:
 		e->command = "pjsip send register";
 		e->usage =
-			"Usage: pjsip send register <registration>\n"
-			"       Unregisters the specified outbound "
-			"registration then re-registers and re-schedules it.\n";
+			"Usage: pjsip send register <registration> | *all \n"
+			"       Unregisters the specified (or all) outbound "
+			"registration(s) then starts registration(s) and schedules re-registrations.\n";
 		return NULL;
 	case CLI_GENERATE:
 		return cli_complete_registration(a->line, a->word, a->pos, a->n);
@@ -1529,6 +1602,12 @@ static char *cli_register(struct ast_cli
 
 	registration_name = a->argv[3];
 
+	if (strcmp(registration_name, "*all") == 0) {
+		reregister_all();
+		ast_cli(a->fd, "Re-register all queued\n");
+		return CLI_SUCCESS;
+	}
+
 	state = get_state(registration_name);
 	if (!state) {
 		ast_cli(a->fd, "Unable to retrieve registration %s\n", registration_name);
@@ -1558,6 +1637,12 @@ static int ami_unregister(struct mansess
 		return 0;
 	}
 
+	if (strcmp(registration_name, "*all") == 0) {
+		unregister_all();
+		astman_send_ack(s, m, "Unregistrations queued.");
+		return 0;
+	}
+
 	state = get_state(registration_name);
 	if (!state) {
 		astman_send_error(s, m, "Unable to retrieve registration entry\n");
@@ -1584,6 +1669,12 @@ static int ami_register(struct mansessio
 		return 0;
 	}
 
+	if (strcmp(registration_name, "*all") == 0) {
+		reregister_all();
+		astman_send_ack(s, m, "Reregistrations queued.");
+		return 0;
+	}
+
 	state = get_state(registration_name);
 	if (!state) {
 		astman_send_error(s, m, "Unable to retrieve registration entry\n");
@@ -1759,10 +1850,6 @@ static int cli_print_body(void *obj, voi
 
 	ast_assert(context->output_buffer != NULL);
 
-	if (!state) {
-		return 0;
-	}
-
 	ast_str_append(&context->output_buffer, 0, " %-s/%-*.*s  %-16s  %-16s\n",
 		id,
 		(int) (REGISTRATION_URI_FIELD_LEN - strlen(id)),
@@ -1771,8 +1858,8 @@ static int cli_print_body(void *obj, voi
 		AST_VECTOR_SIZE(&registration->outbound_auths)
 			? AST_VECTOR_GET(&registration->outbound_auths, 0)
 			: "n/a",
-		sip_outbound_registration_status_str(state->client_state->status));
-	ao2_ref(state, -1);
+		(state ? sip_outbound_registration_status_str(state->client_state->status) : "Unregistered"));
+	ao2_cleanup(state);
 
 	if (context->show_details
 		|| (context->show_details_only_level_0 && context->indent_level == 0)) {
@@ -1912,10 +1999,43 @@ static const struct ast_sorcery_instance
 	.object_type_loaded = registration_loaded_observer,
 };
 
+static void registration_deleted_observer(const void *obj)
+{
+	const struct sip_outbound_registration *registration = obj;
+	struct ao2_container *states;
+
+	states = ao2_global_obj_ref(current_states);
+	if (!states) {
+		/* Global container has gone.  Likely shutting down. */
+		return;
+	}
+
+	ao2_find(states, ast_sorcery_object_get_id(registration), OBJ_UNLINK | OBJ_NODATA | OBJ_SEARCH_KEY);
+
+	ao2_ref(states, -1);
+}
+
+static const struct ast_sorcery_observer registration_observer = {
+	.deleted = registration_deleted_observer,
+};
+
+static void network_change_stasis_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message)
+{
+	/* This callback is only concerned with network change messages from the system topic. */
+	if (stasis_message_type(message) != ast_network_change_type()) {
+		return;
+	}
+	ast_debug(3, "Received network change event\n");
+
+	reregister_all();
+}
+
 static int unload_module(void)
 {
 	int remaining;
 
+	network_change_sub = stasis_unsubscribe_and_join(network_change_sub);
+
 	ast_manager_unregister("PJSIPShowRegistrationsOutbound");
 	ast_manager_unregister("PJSIPUnregister");
 	ast_manager_unregister("PJSIPRegister");
@@ -1963,7 +2083,7 @@ static int load_module(void)
 
 	shutdown_group = ast_serializer_shutdown_group_alloc();
 	if (!shutdown_group) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Create outbound registration states container. */
@@ -1972,7 +2092,7 @@ static int load_module(void)
 	if (!new_states) {
 		ast_log(LOG_ERROR, "Unable to allocate registration states container\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ao2_global_obj_replace_unref(current_states, new_states);
 	ao2_ref(new_states, -1);
@@ -2011,10 +2131,12 @@ static int load_module(void)
 	if (ast_sorcery_instance_observer_add(ast_sip_get_sorcery(),
 		&observer_callbacks_registrations)
 		|| ast_sorcery_observer_add(ast_sip_get_sorcery(), "auth",
-			&observer_callbacks_auth)) {
+			&observer_callbacks_auth)
+		|| ast_sorcery_observer_add(ast_sip_get_sorcery(), "registration",
+			&registration_observer)) {
 		ast_log(LOG_ERROR, "Unable to register observers.\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	/* Register how this module identifies endpoints. */
@@ -2025,7 +2147,7 @@ static int load_module(void)
 	if (!cli_formatter) {
 		ast_log(LOG_ERROR, "Unable to allocate memory for cli formatter\n");
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	cli_formatter->name = "registration";
 	cli_formatter->print_header = cli_print_header;
@@ -2051,6 +2173,9 @@ static int load_module(void)
 	/* Load configuration objects */
 	ast_sorcery_load_object(ast_sip_get_sorcery(), "registration");
 
+	network_change_sub = stasis_subscribe(ast_system_topic(),
+		network_change_stasis_cb, NULL);
+
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/res/res_pjsip_path.c asterisk-13.17.0/res/res_pjsip_path.c
--- asterisk-13.9.1/res/res_pjsip_path.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_path.c	2017-07-12 13:12:08.000000000 +0200
@@ -40,7 +40,8 @@ static struct ast_sip_aor *find_aor(stru
 	char *configured_aors, *aor_name;
 	pjsip_sip_uri *sip_uri;
 	char *domain_name;
-	RAII_VAR(struct ast_str *, id, NULL, ast_free);
+	char *username;
+	struct ast_str *id = NULL;
 
 	if (ast_strlen_zero(endpoint->aors)) {
 		return NULL;
@@ -49,6 +50,14 @@ static struct ast_sip_aor *find_aor(stru
 	sip_uri = pjsip_uri_get_uri(uri);
 	domain_name = ast_alloca(sip_uri->host.slen + 1);
 	ast_copy_pj_str(domain_name, &sip_uri->host, sip_uri->host.slen + 1);
+	username = ast_alloca(sip_uri->user.slen + 1);
+	ast_copy_pj_str(username, &sip_uri->user, sip_uri->user.slen + 1);
+
+	/*
+	 * We may want to match without any user options getting
+	 * in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(username);
 
 	configured_aors = ast_strdupa(endpoint->aors);
 
@@ -60,15 +69,16 @@ static struct ast_sip_aor *find_aor(stru
 			continue;
 		}
 
-		if (!pj_strcmp2(&sip_uri->user, aor_name)) {
+		if (!strcmp(username, aor_name)) {
 			break;
 		}
 
-		if (!id && !(id = ast_str_create(sip_uri->user.slen + sip_uri->host.slen + 2))) {
-			return NULL;
+		if (!id && !(id = ast_str_create(strlen(username) + sip_uri->host.slen + 2))) {
+			aor_name = NULL;
+			break;
 		}
 
-		ast_str_set(&id, 0, "%.*s@", (int)sip_uri->user.slen, sip_uri->user.ptr);
+		ast_str_set(&id, 0, "%s@", username);
 		if ((alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain_name))) {
 			ast_str_append(&id, 0, "%s", alias->domain);
 			ao2_cleanup(alias);
@@ -77,10 +87,10 @@ static struct ast_sip_aor *find_aor(stru
 		}
 
 		if (!strcmp(aor_name, ast_str_buffer(id))) {
-			ast_free(id);
 			break;
 		}
 	}
+	ast_free(id);
 
 	if (ast_strlen_zero(aor_name)) {
 		return NULL;
diff -urpN asterisk-13.9.1/res/res_pjsip_pidf_body_generator.c asterisk-13.17.0/res/res_pjsip_pidf_body_generator.c
--- asterisk-13.9.1/res/res_pjsip_pidf_body_generator.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_pidf_body_generator.c	2017-07-12 13:12:08.000000000 +0200
@@ -58,7 +58,7 @@ static int pidf_generate_body_content(vo
 	struct ast_sip_exten_state_data *state_data = data;
 
 	ast_sip_presence_exten_state_to_str(state_data->exten_state, &statestring,
-			&pidfstate, &pidfnote, &local_state);
+			&pidfstate, &pidfnote, &local_state, 0);
 
 	if (!pjpidf_pres_add_note(state_data->pool, pres, pj_cstr(&note, pidfnote))) {
 		ast_log(LOG_WARNING, "Unable to add note to PIDF presence\n");
diff -urpN asterisk-13.9.1/res/res_pjsip_pidf_eyebeam_body_supplement.c asterisk-13.17.0/res/res_pjsip_pidf_eyebeam_body_supplement.c
--- asterisk-13.9.1/res/res_pjsip_pidf_eyebeam_body_supplement.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_pidf_eyebeam_body_supplement.c	2017-07-12 13:12:08.000000000 +0200
@@ -80,7 +80,7 @@ static int pidf_supplement_body(void *bo
 	enum ast_sip_pidf_state local_state;
 
 	ast_sip_presence_exten_state_to_str(state_data->exten_state, &statestring,
-			&pidfstate, &pidfnote, &local_state);
+			&pidfstate, &pidfnote, &local_state, 0);
 
 	add_eyebeam(state_data->pool, pres, pidfstate);
 	return 0;
diff -urpN asterisk-13.9.1/res/res_pjsip_publish_asterisk.c asterisk-13.17.0/res/res_pjsip_publish_asterisk.c
--- asterisk-13.9.1/res/res_pjsip_publish_asterisk.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_publish_asterisk.c	2017-07-12 13:12:08.000000000 +0200
@@ -858,10 +858,16 @@ static int load_module(void)
 {
 	CHECK_PJSIP_PUBSUB_MODULE_LOADED();
 
-	ast_sorcery_apply_config(ast_sip_get_sorcery(), "asterisk-publication");
+	if (ast_eid_is_empty(&ast_eid_default)) {
+		ast_log(LOG_ERROR, "Entity ID is not set.\n");
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	ast_sorcery_apply_config(ast_sip_get_sorcery(), "res_pjsip_publish_asterisk");
 	ast_sorcery_apply_default(ast_sip_get_sorcery(), "asterisk-publication", "config", "pjsip.conf,criteria=type=asterisk-publication");
 
 	if (ast_sorcery_object_register(ast_sip_get_sorcery(), "asterisk-publication", asterisk_publication_config_alloc, NULL, NULL)) {
+		ast_log(LOG_ERROR, "Unable to register 'asterisk-publication' type with sorcery\n");
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -919,12 +925,13 @@ static int unload_module(void)
 	ast_sip_unregister_publish_handler(&asterisk_mwi_publication_handler);
 	ast_sip_unregister_event_publisher_handler(&asterisk_devicestate_publisher_handler);
 	ast_sip_unregister_event_publisher_handler(&asterisk_mwi_publisher_handler);
+	ast_sorcery_object_unregister(ast_sip_get_sorcery(), "asterisk-publication");
 	return 0;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP Asterisk Event PUBLISH Support",
-		.load = load_module,
-		.reload = reload_module,
-		.unload = unload_module,
-		.load_pri = AST_MODPRI_CHANNEL_DEPEND,
+	.load = load_module,
+	.reload = reload_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND + 5,
 );
diff -urpN asterisk-13.9.1/res/res_pjsip_pubsub.c asterisk-13.17.0/res/res_pjsip_pubsub.c
--- asterisk-13.9.1/res/res_pjsip_pubsub.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_pubsub.c	2017-07-12 13:12:08.000000000 +0200
@@ -42,6 +42,7 @@
 #include "asterisk/res_pjsip.h"
 #include "asterisk/callerid.h"
 #include "asterisk/manager.h"
+#include "asterisk/cli.h"
 #include "asterisk/test.h"
 #include "res_pjsip/include/res_pjsip_private.h"
 #include "asterisk/res_pjsip_presence_xml.h"
@@ -122,6 +123,9 @@
 				<configOption name="expires">
 					<synopsis>The time at which the subscription expires</synopsis>
 				</configOption>
+				<configOption name="contact_uri">
+					<synopsis>The Contact URI of the dialog for the subscription</synopsis>
+				</configOption>
 			</configObject>
 			<configObject name="resource_list">
 				<synopsis>Resource list configuration parameters.</synopsis>
@@ -355,7 +359,7 @@ struct ast_sip_publication {
 struct subscription_persistence {
 	/*! Sorcery object details */
 	SORCERY_OBJECT(details);
-	/*! The name of the endpoint involved in the subscrption */
+	/*! The name of the endpoint involved in the subscription */
 	char *endpoint;
 	/*! SIP message that creates the subscription */
 	char packet[PJSIP_MAX_PKT_LEN];
@@ -375,6 +379,29 @@ struct subscription_persistence {
 	char *tag;
 	/*! When this subscription expires */
 	struct timeval expires;
+	/*! Contact URI */
+	char contact_uri[PJSIP_MAX_URL_SIZE];
+};
+
+/*!
+ * \brief The state of the subscription tree
+ */
+enum sip_subscription_tree_state {
+	/*! Normal operation */
+	SIP_SUB_TREE_NORMAL = 0,
+	/*! A terminate has been requested by Asterisk, the client, or pjproject */
+	SIP_SUB_TREE_TERMINATE_PENDING,
+	/*! The terminate is in progress */
+	SIP_SUB_TREE_TERMINATE_IN_PROGRESS,
+	/*! The terminate process has finished and the subscription tree is no longer valid */
+	SIP_SUB_TREE_TERMINATED,
+};
+
+static char *sub_tree_state_description[] = {
+	"Normal",
+	"TerminatePending",
+	"TerminateInProgress",
+	"Terminated"
 };
 
 /*!
@@ -411,8 +438,13 @@ struct sip_subscription_tree {
 	int is_list;
 	/*! Next item in the list */
 	AST_LIST_ENTRY(sip_subscription_tree) next;
-	/*! Indicates that a NOTIFY is currently being sent on the SIP subscription */
-	int last_notify;
+	/*! Subscription tree state */
+	enum sip_subscription_tree_state state;
+	/*! On asterisk restart, this is the task data used
+	 * to restart the expiration timer if pjproject isn't
+	 * capable of restarting the timer.
+	 */
+	struct ast_sip_sched_task *expiration_task;
 };
 
 /*!
@@ -467,6 +499,17 @@ static const char *sip_subscription_role
 	[AST_SIP_NOTIFIER] = "Notifier"
 };
 
+enum sip_persistence_update_type {
+	/*! Called from send request */
+	SUBSCRIPTION_PERSISTENCE_SEND_REQUEST = 0,
+	/*! Subscription created from initial client request */
+	SUBSCRIPTION_PERSISTENCE_CREATED,
+	/*! Subscription recreated by asterisk on startup */
+	SUBSCRIPTION_PERSISTENCE_RECREATED,
+	/*! Subscription created from client refresh */
+	SUBSCRIPTION_PERSISTENCE_REFRESHED,
+};
+
 AST_RWLIST_HEAD_STATIC(subscriptions, sip_subscription_tree);
 
 AST_RWLIST_HEAD_STATIC(body_generators, ast_sip_pubsub_body_generator);
@@ -545,7 +588,7 @@ static struct subscription_persistence *
 
 /*! \brief Function which updates persistence information of a subscription in sorcery */
 static void subscription_persistence_update(struct sip_subscription_tree *sub_tree,
-	pjsip_rx_data *rdata)
+	pjsip_rx_data *rdata, enum sip_persistence_update_type type)
 {
 	pjsip_dialog *dlg;
 
@@ -553,28 +596,38 @@ static void subscription_persistence_upd
 		return;
 	}
 
+	ast_debug(3, "Updating persistence for '%s->%s'\n", sub_tree->persistence->endpoint,
+		sub_tree->root->resource);
+
 	dlg = sub_tree->dlg;
 	sub_tree->persistence->cseq = dlg->local.cseq;
 
 	if (rdata) {
 		int expires;
 		pjsip_expires_hdr *expires_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES, NULL);
+		pjsip_contact_hdr *contact_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);
 
 		expires = expires_hdr ? expires_hdr->ivalue : DEFAULT_PUBLISH_EXPIRES;
 		sub_tree->persistence->expires = ast_tvadd(ast_tvnow(), ast_samp2tv(expires, 1));
 
+		pjsip_uri_print(PJSIP_URI_IN_CONTACT_HDR, contact_hdr->uri,
+			sub_tree->persistence->contact_uri, sizeof(sub_tree->persistence->contact_uri));
+
 		/* When receiving a packet on an streaming transport, it's possible to receive more than one SIP
 		 * message at a time into the rdata->pkt_info.packet buffer. However, the rdata->msg_info.msg_buf
 		 * will always point to the proper SIP message that is to be processed. When updating subscription
 		 * persistence that is pulled from persistent storage, though, the rdata->pkt_info.packet will
 		 * only ever have a single SIP message on it, and so we base persistence on that.
 		 */
-		if (rdata->msg_info.msg_buf) {
-			ast_copy_string(sub_tree->persistence->packet, rdata->msg_info.msg_buf,
-					MIN(sizeof(sub_tree->persistence->packet), rdata->msg_info.len));
-		} else {
-			ast_copy_string(sub_tree->persistence->packet, rdata->pkt_info.packet,
-					sizeof(sub_tree->persistence->packet));
+		if (type == SUBSCRIPTION_PERSISTENCE_CREATED
+			|| type == SUBSCRIPTION_PERSISTENCE_RECREATED) {
+			if (rdata->msg_info.msg_buf) {
+				ast_copy_string(sub_tree->persistence->packet, rdata->msg_info.msg_buf,
+						MIN(sizeof(sub_tree->persistence->packet), rdata->msg_info.len));
+			} else {
+				ast_copy_string(sub_tree->persistence->packet, rdata->pkt_info.packet,
+						sizeof(sub_tree->persistence->packet));
+			}
 		}
 		ast_copy_string(sub_tree->persistence->src_name, rdata->pkt_info.src_name,
 				sizeof(sub_tree->persistence->src_name));
@@ -875,19 +928,20 @@ static void build_node_children(struct a
 			if (PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {
 				current = tree_node_alloc(resource, visited, 0);
 				if (!current) {
-					ast_debug(1, "Subscription to leaf resource %s was successful, but encountered"
-							"allocation error afterwards\n", resource);
+					ast_debug(1,
+						"Subscription to leaf resource %s was successful, but encountered allocation error afterwards\n",
+						resource);
 					continue;
 				}
-				ast_debug(1, "Subscription to leaf resource %s resulted in success. Adding to parent %s\n",
+				ast_debug(2, "Subscription to leaf resource %s resulted in success. Adding to parent %s\n",
 						resource, parent->resource);
 				AST_VECTOR_APPEND(&parent->children, current);
 			} else {
-				ast_debug(1, "Subscription to leaf resource %s resulted in error response %d\n",
+				ast_debug(2, "Subscription to leaf resource %s resulted in error response %d\n",
 						resource, resp);
 			}
 		} else {
-			ast_debug(1, "Resource %s (child of %s) is a list\n", resource, parent->resource);
+			ast_debug(2, "Resource %s (child of %s) is a list\n", resource, parent->resource);
 			current = tree_node_alloc(resource, visited, child_list->full_state);
 			if (!current) {
 				ast_debug(1, "Cannot build children of resource %s due to allocation failure\n", resource);
@@ -898,7 +952,7 @@ static void build_node_children(struct a
 				ast_debug(1, "List %s had no successful children.\n", resource);
 				AST_VECTOR_APPEND(&parent->children, current);
 			} else {
-				ast_debug(1, "List %s had successful children. Adding to parent %s\n",
+				ast_debug(2, "List %s had successful children. Adding to parent %s\n",
 						resource, parent->resource);
 				tree_node_destroy(current);
 			}
@@ -970,7 +1024,8 @@ static int build_resource_tree(struct as
 	struct resources visited;
 
 	if (!has_eventlist_support || !(list = retrieve_resource_list(resource, handler->event_name))) {
-		ast_debug(1, "Subscription to resource %s is not to a list\n", resource);
+		ast_debug(2, "Subscription '%s->%s' is not to a list\n",
+			ast_sorcery_object_get_id(endpoint), resource);
 		tree->root = tree_node_alloc(resource, NULL, 0);
 		if (!tree->root) {
 			return 500;
@@ -978,7 +1033,8 @@ static int build_resource_tree(struct as
 		return handler->notifier->new_subscribe(endpoint, resource);
 	}
 
-	ast_debug(1, "Subscription to resource %s is a list\n", resource);
+	ast_debug(2, "Subscription '%s->%s' is a list\n",
+		ast_sorcery_object_get_id(endpoint), resource);
 	if (AST_VECTOR_INIT(&visited, AST_VECTOR_SIZE(&list->items))) {
 		return 500;
 	}
@@ -1025,30 +1081,36 @@ static int datastore_cmp(void *obj, void
 
 static void add_subscription(struct sip_subscription_tree *obj)
 {
-	SCOPED_LOCK(lock, &subscriptions, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
+	AST_RWLIST_WRLOCK(&subscriptions);
 	AST_RWLIST_INSERT_TAIL(&subscriptions, obj, next);
+	AST_RWLIST_UNLOCK(&subscriptions);
 }
 
 static void remove_subscription(struct sip_subscription_tree *obj)
 {
 	struct sip_subscription_tree *i;
-	SCOPED_LOCK(lock, &subscriptions, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
+
+	AST_RWLIST_WRLOCK(&subscriptions);
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&subscriptions, i, next) {
 		if (i == obj) {
 			AST_RWLIST_REMOVE_CURRENT(next);
 			if (i->root) {
-				ast_debug(1, "Removing subscription to resource %s from list of subscriptions\n",
-						ast_sip_subscription_get_resource_name(i->root));
+				ast_debug(2, "Removing subscription '%s->%s' from list of subscriptions\n",
+					ast_sorcery_object_get_id(i->endpoint), ast_sip_subscription_get_resource_name(i->root));
 			}
 			break;
 		}
 	}
 	AST_RWLIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&subscriptions);
 }
 
 static void destroy_subscription(struct ast_sip_subscription *sub)
 {
-	ast_debug(3, "Destroying SIP subscription to resource %s\n", sub->resource);
+	ast_debug(3, "Destroying SIP subscription from '%s->%s'\n",
+		sub->tree->endpoint ? ast_sorcery_object_get_id(sub->tree->endpoint) : "Unknown",
+		sub->resource);
+
 	ast_free(sub->body_text);
 
 	AST_VECTOR_FREE(&sub->children);
@@ -1200,9 +1262,10 @@ static void subscription_tree_destructor
 {
 	struct sip_subscription_tree *sub_tree = obj;
 
-	ast_debug(3, "Destroying subscription tree %p\n", sub_tree);
-
-	ao2_cleanup(sub_tree->endpoint);
+	ast_debug(3, "Destroying subscription tree %p '%s->%s'\n",
+		sub_tree,
+		sub_tree->endpoint ? ast_sorcery_object_get_id(sub_tree->endpoint) : "Unknown",
+		sub_tree->root ? sub_tree->root->resource : "Unknown");
 
 	destroy_subscriptions(sub_tree->root);
 
@@ -1210,13 +1273,16 @@ static void subscription_tree_destructor
 		ast_sip_push_task_synchronous(sub_tree->serializer, subscription_unreference_dialog, sub_tree);
 	}
 
+	ao2_cleanup(sub_tree->endpoint);
+
 	ast_taskprocessor_unreference(sub_tree->serializer);
 	ast_module_unref(ast_module_info->self);
 }
 
 void ast_sip_subscription_destroy(struct ast_sip_subscription *sub)
 {
-	ast_debug(3, "Removing subscription %p reference to subscription tree %p\n", sub, sub->tree);
+	ast_debug(3, "Removing subscription %p '%s->%s' reference to subscription tree %p\n",
+		sub, ast_sorcery_object_get_id(sub->tree->endpoint), sub->resource, sub->tree);
 	ao2_cleanup(sub->tree);
 }
 
@@ -1229,10 +1295,9 @@ static void subscription_setup_dialog(st
 	pjsip_dlg_inc_session(dlg, &pubsub_module);
 }
 
-static struct sip_subscription_tree *allocate_subscription_tree(struct ast_sip_endpoint *endpoint)
+static struct sip_subscription_tree *allocate_subscription_tree(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata)
 {
 	struct sip_subscription_tree *sub_tree;
-	char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
 
 	sub_tree = ao2_alloc(sizeof *sub_tree, subscription_tree_destructor);
 	if (!sub_tree) {
@@ -1241,11 +1306,24 @@ static struct sip_subscription_tree *all
 
 	ast_module_ref(ast_module_info->self);
 
-	/* Create name with seq number appended. */
-	ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/pubsub/%s",
-		ast_sorcery_object_get_id(endpoint));
+	if (rdata) {
+		/*
+		 * We must continue using the serializer that the original
+		 * SUBSCRIBE came in on for the dialog.  There may be
+		 * retransmissions already enqueued in the original
+		 * serializer that can result in reentrancy and message
+		 * sequencing problems.
+		 */
+		sub_tree->serializer = ast_sip_get_distributor_serializer(rdata);
+	} else {
+		char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
+
+		/* Create name with seq number appended. */
+		ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/pubsub/%s",
+			ast_sorcery_object_get_id(endpoint));
 
-	sub_tree->serializer = ast_sip_create_serializer_named(tps_name);
+		sub_tree->serializer = ast_sip_create_serializer_named(tps_name);
+	}
 	if (!sub_tree->serializer) {
 		ao2_ref(sub_tree, -1);
 		return NULL;
@@ -1286,7 +1364,7 @@ static struct sip_subscription_tree *cre
 	pjsip_dialog *dlg;
 	struct subscription_persistence *persistence;
 
-	sub_tree = allocate_subscription_tree(endpoint);
+	sub_tree = allocate_subscription_tree(endpoint, rdata);
 	if (!sub_tree) {
 		*dlg_status = PJ_ENOMEM;
 		return NULL;
@@ -1311,12 +1389,15 @@ static struct sip_subscription_tree *cre
 		dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);
 		pjsip_ua_register_dlg(pjsip_ua_instance(), dlg);
 		dlg->local.cseq = persistence->cseq;
-		dlg->remote.cseq = persistence->cseq;
 	}
 
 	pjsip_evsub_create_uas(dlg, &pubsub_cb, rdata, 0, &sub_tree->evsub);
 	subscription_setup_dialog(sub_tree, dlg);
 
+#ifdef HAVE_PJSIP_EVSUB_GRP_LOCK
+	pjsip_evsub_add_ref(sub_tree->evsub);
+#endif
+
 	ast_sip_mod_data_set(dlg->pool, dlg->mod_data, pubsub_module.id, MOD_DATA_MSG,
 			pjsip_msg_clone(dlg->pool, rdata->msg_info.msg));
 
@@ -1332,112 +1413,208 @@ static struct sip_subscription_tree *cre
 	return sub_tree;
 }
 
+/*! Wrapper structure for initial_notify_task */
+struct initial_notify_data {
+	struct sip_subscription_tree *sub_tree;
+	int expires;
+};
+
 static int initial_notify_task(void *obj);
 static int send_notify(struct sip_subscription_tree *sub_tree, unsigned int force_full_state);
 
-/*! \brief Callback function to perform the actual recreation of a subscription */
-static int subscription_persistence_recreate(void *obj, void *arg, int flags)
+/*! Persistent subscription recreation continuation under distributor serializer data */
+struct persistence_recreate_data {
+	struct subscription_persistence *persistence;
+	pjsip_rx_data *rdata;
+};
+
+/*!
+ * \internal
+ * \brief subscription_persistence_recreate continuation under distributor serializer.
+ * \since 13.10.0
+ *
+ * \retval 0 on success.
+ * \retval -1 on error.
+ */
+static int sub_persistence_recreate(void *obj)
 {
-	struct subscription_persistence *persistence = obj;
-	pj_pool_t *pool = arg;
-	pjsip_rx_data rdata = { { 0, }, };
-	RAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);
+	struct persistence_recreate_data *recreate_data = obj;
+	struct subscription_persistence *persistence = recreate_data->persistence;
+	pjsip_rx_data *rdata = recreate_data->rdata;
+	struct ast_sip_endpoint *endpoint;
 	struct sip_subscription_tree *sub_tree;
 	struct ast_sip_pubsub_body_generator *generator;
-	int resp;
+	struct ast_sip_subscription_handler *handler;
 	char *resource;
-	size_t resource_size;
 	pjsip_sip_uri *request_uri;
+	size_t resource_size;
+	int resp;
 	struct resource_tree tree;
 	pjsip_expires_hdr *expires_header;
-	struct ast_sip_subscription_handler *handler;
 
-	/* If this subscription has already expired remove it */
-	if (ast_tvdiff_ms(persistence->expires, ast_tvnow()) <= 0) {
-		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
-		return 0;
-	}
+	request_uri = pjsip_uri_get_uri(rdata->msg_info.msg->line.req.uri);
+	resource_size = pj_strlen(&request_uri->user) + 1;
+	resource = ast_alloca(resource_size);
+	ast_copy_pj_str(resource, &request_uri->user, resource_size);
 
-	endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint", persistence->endpoint);
-	if (!endpoint) {
-		ast_log(LOG_WARNING, "A subscription for '%s' could not be recreated as the endpoint was not found\n",
+	/*
+	 * We may want to match without any user options getting
+	 * in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource);
+
+	handler = subscription_get_handler_from_rdata(rdata);
+	if (!handler || !handler->notifier) {
+		ast_log(LOG_WARNING, "Failed recreating '%s' subscription: Could not get subscription handler.\n",
 			persistence->endpoint);
 		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
 		return 0;
 	}
 
-	pj_pool_reset(pool);
-	rdata.tp_info.pool = pool;
-
-	if (ast_sip_create_rdata(&rdata, persistence->packet, persistence->src_name, persistence->src_port,
-		persistence->transport_key, persistence->local_name, persistence->local_port)) {
-		ast_log(LOG_WARNING, "A subscription for '%s' could not be recreated as the message could not be parsed\n",
+	generator = subscription_get_generator_from_rdata(rdata, handler);
+	if (!generator) {
+		ast_log(LOG_WARNING, "Failed recreating '%s' subscription: Body generator not available.\n",
 			persistence->endpoint);
 		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
 		return 0;
 	}
 
-	if (rdata.msg_info.msg->type != PJSIP_REQUEST_MSG) {
-		ast_log(LOG_NOTICE, "Endpoint %s persisted a SIP response instead of a subscribe request. Unable to reload subscription.\n",
-				ast_sorcery_object_get_id(endpoint));
+	ast_sip_mod_data_set(rdata->tp_info.pool, rdata->endpt_info.mod_data,
+		pubsub_module.id, MOD_DATA_PERSISTENCE, persistence);
+
+	/* Getting the endpoint may take some time that can affect the expiration. */
+	endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint",
+		persistence->endpoint);
+	if (!endpoint) {
+		ast_log(LOG_WARNING, "Failed recreating '%s' subscription: The endpoint was not found\n",
+			persistence->endpoint);
 		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
 		return 0;
 	}
 
-	request_uri = pjsip_uri_get_uri(rdata.msg_info.msg->line.req.uri);
-	resource_size = pj_strlen(&request_uri->user) + 1;
-	resource = ast_alloca(resource_size);
-	ast_copy_pj_str(resource, &request_uri->user, resource_size);
-
 	/* Update the expiration header with the new expiration */
-	expires_header = pjsip_msg_find_hdr(rdata.msg_info.msg, PJSIP_H_EXPIRES, rdata.msg_info.msg->hdr.next);
+	expires_header = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES,
+		rdata->msg_info.msg->hdr.next);
 	if (!expires_header) {
-		expires_header = pjsip_expires_hdr_create(pool, 0);
+		expires_header = pjsip_expires_hdr_create(rdata->tp_info.pool, 0);
 		if (!expires_header) {
+			ast_log(LOG_WARNING, "Failed recreating '%s' subscription: Could not update expires header.\n",
+				persistence->endpoint);
 			ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+			ao2_ref(endpoint, -1);
 			return 0;
 		}
-		pjsip_msg_add_hdr(rdata.msg_info.msg, (pjsip_hdr*)expires_header);
-	}
-	expires_header->ivalue = (ast_tvdiff_ms(persistence->expires, ast_tvnow()) / 1000);
-
-	handler = subscription_get_handler_from_rdata(&rdata);
-	if (!handler || !handler->notifier) {
-		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
-		return 0;
+		pjsip_msg_add_hdr(rdata->msg_info.msg, (pjsip_hdr *) expires_header);
 	}
 
-	generator = subscription_get_generator_from_rdata(&rdata, handler);
-	if (!generator) {
+	expires_header->ivalue = (ast_tvdiff_ms(persistence->expires, ast_tvnow()) / 1000);
+	if (expires_header->ivalue <= 0) {
+		/* The subscription expired since we started recreating the subscription. */
+		ast_debug(3, "Expired subscription retrived from persistent store '%s' %s\n",
+			persistence->endpoint, persistence->tag);
 		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+		ao2_ref(endpoint, -1);
 		return 0;
 	}
 
-	ast_sip_mod_data_set(rdata.tp_info.pool, rdata.endpt_info.mod_data,
-			pubsub_module.id, MOD_DATA_PERSISTENCE, persistence);
-
 	memset(&tree, 0, sizeof(tree));
 	resp = build_resource_tree(endpoint, handler, resource, &tree,
-		ast_sip_pubsub_has_eventlist_support(&rdata));
+		ast_sip_pubsub_has_eventlist_support(rdata));
 	if (PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {
 		pj_status_t dlg_status;
 
-		sub_tree = create_subscription_tree(handler, endpoint, &rdata, resource, generator, &tree, &dlg_status);
+		sub_tree = create_subscription_tree(handler, endpoint, rdata, resource, generator,
+			&tree, &dlg_status);
 		if (!sub_tree) {
-			ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
-			ast_log(LOG_WARNING, "Failed to re-create subscription for %s\n", persistence->endpoint);
-			return 0;
-		}
-		sub_tree->persistence = ao2_bump(persistence);
-		subscription_persistence_update(sub_tree, &rdata);
-		if (ast_sip_push_task(sub_tree->serializer, initial_notify_task, ao2_bump(sub_tree))) {
-			pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
-			ao2_ref(sub_tree, -1);
+			if (dlg_status != PJ_EEXISTS) {
+				ast_log(LOG_WARNING, "Failed recreating '%s' subscription: Could not create subscription tree.\n",
+					persistence->endpoint);
+				ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+			}
+		} else {
+			struct initial_notify_data *ind = ast_malloc(sizeof(*ind));
+
+			if (!ind) {
+				pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
+				goto error;
+			}
+
+			ind->sub_tree = ao2_bump(sub_tree);
+			ind->expires = expires_header->ivalue;
+
+			sub_tree->persistence = ao2_bump(persistence);
+			subscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_RECREATED);
+			if (ast_sip_push_task(sub_tree->serializer, initial_notify_task, ind)) {
+				/* Could not send initial subscribe NOTIFY */
+				pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
+				ao2_ref(sub_tree, -1);
+				ast_free(ind);
+			}
 		}
 	} else {
 		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
 	}
+
+error:
 	resource_tree_destroy(&tree);
+	ao2_ref(endpoint, -1);
+
+	return 0;
+}
+
+/*! \brief Callback function to perform the actual recreation of a subscription */
+static int subscription_persistence_recreate(void *obj, void *arg, int flags)
+{
+	struct subscription_persistence *persistence = obj;
+	pj_pool_t *pool = arg;
+	struct ast_taskprocessor *serializer;
+	pjsip_rx_data rdata;
+	struct persistence_recreate_data recreate_data;
+
+	/* If this subscription has already expired remove it */
+	if (ast_tvdiff_ms(persistence->expires, ast_tvnow()) <= 0) {
+		ast_debug(3, "Expired subscription retrived from persistent store '%s' %s\n",
+			persistence->endpoint, persistence->tag);
+		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+		return 0;
+	}
+
+	memset(&rdata, 0, sizeof(rdata));
+	pj_pool_reset(pool);
+	rdata.tp_info.pool = pool;
+
+	if (ast_sip_create_rdata_with_contact(&rdata, persistence->packet, persistence->src_name,
+		persistence->src_port, persistence->transport_key, persistence->local_name,
+		persistence->local_port, persistence->contact_uri)) {
+		ast_log(LOG_WARNING, "Failed recreating '%s' subscription: The message could not be parsed\n",
+			persistence->endpoint);
+		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+		return 0;
+	}
+
+	if (rdata.msg_info.msg->type != PJSIP_REQUEST_MSG) {
+		ast_log(LOG_NOTICE, "Failed recreating '%s' subscription: Stored a SIP response instead of a request.\n",
+			persistence->endpoint);
+		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+		return 0;
+	}
+
+	/* Continue the remainder in the distributor serializer */
+	serializer = ast_sip_get_distributor_serializer(&rdata);
+	if (!serializer) {
+		ast_log(LOG_WARNING, "Failed recreating '%s' subscription: Could not get distributor serializer.\n",
+			persistence->endpoint);
+		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+		return 0;
+	}
+	recreate_data.persistence = persistence;
+	recreate_data.rdata = &rdata;
+	if (ast_sip_push_task_synchronous(serializer, sub_persistence_recreate, &recreate_data)) {
+		ast_log(LOG_WARNING, "Failed recreating '%s' subscription: Could not continue under distributor serializer.\n",
+			persistence->endpoint);
+		ast_sorcery_delete(ast_sip_get_sorcery(), persistence);
+	}
+	ast_taskprocessor_unreference(serializer);
 
 	return 0;
 }
@@ -1497,18 +1674,19 @@ static int for_each_subscription(on_subs
 {
 	int num = 0;
 	struct sip_subscription_tree *i;
-	SCOPED_LOCK(lock, &subscriptions, AST_RWLIST_RDLOCK, AST_RWLIST_UNLOCK);
 
 	if (!on_subscription) {
 		return num;
 	}
 
+	AST_RWLIST_RDLOCK(&subscriptions);
 	AST_RWLIST_TRAVERSE(&subscriptions, i, next) {
 		if (on_subscription(i, arg)) {
 			break;
 		}
 		++num;
 	}
+	AST_RWLIST_UNLOCK(&subscriptions);
 	return num;
 }
 
@@ -1559,28 +1737,6 @@ void *ast_sip_subscription_get_header(co
 	return pjsip_msg_find_hdr_by_name(msg, &name, NULL);
 }
 
-/*!
- * \internal
- * \brief Wrapper for pjsip_evsub_send_request
- *
- * This function (re)sets the transport before sending to catch cases
- * where the transport might have changed.
- *
- * If pjproject gives us the ability to resend, we'll only reset the transport
- * if PJSIP_ETPNOTAVAIL is returned from send.
- *
- * \returns pj_status_t
- */
-static pj_status_t internal_pjsip_evsub_send_request(struct sip_subscription_tree *sub_tree, pjsip_tx_data *tdata)
-{
-	pjsip_tpselector selector = { .type = PJSIP_TPSELECTOR_NONE, };
-
-	ast_sip_set_tpselector_from_transport_name(sub_tree->endpoint->transport, &selector);
-	pjsip_dlg_set_transport(sub_tree->dlg, &selector);
-
-	return pjsip_evsub_send_request(sub_tree->evsub, tdata);
-}
-
 /* XXX This function is not used. */
 struct ast_sip_subscription *ast_sip_create_subscription(const struct ast_sip_subscription_handler *handler,
 		struct ast_sip_endpoint *endpoint, const char *resource)
@@ -1593,7 +1749,7 @@ struct ast_sip_subscription *ast_sip_cre
 	pjsip_evsub *evsub;
 	struct sip_subscription_tree *sub_tree = NULL;
 
-	sub_tree = allocate_subscription_tree(endpoint);
+	sub_tree = allocate_subscription_tree(endpoint, NULL);
 	if (!sub_tree) {
 		return NULL;
 	}
@@ -1628,7 +1784,7 @@ struct ast_sip_subscription *ast_sip_cre
 	evsub = sub_tree->evsub;
 
 	if (pjsip_evsub_initiate(evsub, NULL, -1, &tdata) == PJ_SUCCESS) {
-		internal_pjsip_evsub_send_request(sub_tree, tdata);
+		pjsip_evsub_send_request(sub_tree->evsub, tdata);
 	} else {
 		/* pjsip_evsub_terminate will result in pubsub_on_evsub_state,
 		 * being called and terminating the subscription. Therefore, we don't
@@ -1721,12 +1877,13 @@ static int sip_subscription_send_request
 
 	if (allocate_tdata_buffer(tdata)) {
 		ast_log(LOG_ERROR, "SIP request %s is too large to send.\n", tdata->info);
+		pjsip_tx_data_dec_ref(tdata);
 		return -1;
 	}
 
-	res = internal_pjsip_evsub_send_request(sub_tree, tdata);
+	res = pjsip_evsub_send_request(sub_tree->evsub, tdata);
 
-	subscription_persistence_update(sub_tree, NULL);
+	subscription_persistence_update(sub_tree, NULL, SUBSCRIPTION_PERSISTENCE_SEND_REQUEST);
 
 	ast_test_suite_event_notify("SUBSCRIPTION_STATE_SET",
 		"StateText: %s\r\n"
@@ -2173,10 +2330,8 @@ static int send_notify(struct sip_subscr
 		pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr *) require);
 	}
 
-	if (sub_tree->root->subscription_state == PJSIP_EVSUB_STATE_TERMINATED) {
-		sub_tree->last_notify = 1;
-	}
 	if (sip_subscription_send_request(sub_tree, tdata)) {
+		/* do not call pjsip_tx_data_dec_ref(tdata). The pjsip_dlg_send_request deletes the message on error */
 		return -1;
 	}
 
@@ -2191,21 +2346,32 @@ static int serialized_send_notify(void *
 	pjsip_dialog *dlg = sub_tree->dlg;
 
 	pjsip_dlg_inc_lock(dlg);
+
 	/* It's possible that between when the notification was scheduled
-	 * and now, that a new SUBSCRIBE arrived, requiring full state to be
-	 * sent out in an immediate NOTIFY. If that has happened, we need to
+	 * and now a new SUBSCRIBE arrived requiring full state to be
+	 * sent out in an immediate NOTIFY. It's also possible that we're
+	 * already processing a terminate.  If that has happened, we need to
 	 * bail out here instead of sending the batched NOTIFY.
 	 */
-	if (!sub_tree->send_scheduled_notify) {
+
+	if (sub_tree->state >= SIP_SUB_TREE_TERMINATE_IN_PROGRESS
+		|| !sub_tree->send_scheduled_notify) {
 		pjsip_dlg_dec_lock(dlg);
 		ao2_cleanup(sub_tree);
 		return 0;
 	}
 
+	if (sub_tree->root->subscription_state == PJSIP_EVSUB_STATE_TERMINATED) {
+		sub_tree->state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;
+	}
+
 	send_notify(sub_tree, 0);
-	ast_test_suite_event_notify("SUBSCRIPTION_STATE_CHANGED",
-			"Resource: %s",
-			sub_tree->root->resource);
+
+	ast_test_suite_event_notify(
+		sub_tree->state == SIP_SUB_TREE_TERMINATED
+			? "SUBSCRIPTION_TERMINATED" : "SUBSCRIPTION_STATE_CHANGED",
+		"Resource: %s", sub_tree->root->resource);
+
 	sub_tree->notify_sched_id = -1;
 	pjsip_dlg_dec_lock(dlg);
 	ao2_cleanup(sub_tree);
@@ -2217,7 +2383,10 @@ static int sched_cb(const void *data)
 	struct sip_subscription_tree *sub_tree = (struct sip_subscription_tree *) data;
 
 	/* We don't need to bump the refcount of sub_tree since we bumped it when scheduling this task */
-	ast_sip_push_task(sub_tree->serializer, serialized_send_notify, sub_tree);
+	if (ast_sip_push_task(sub_tree->serializer, serialized_send_notify, sub_tree)) {
+		ao2_cleanup(sub_tree);
+	}
+
 	return 0;
 }
 
@@ -2228,12 +2397,13 @@ static int schedule_notification(struct
 		return 0;
 	}
 
+	sub_tree->send_scheduled_notify = 1;
 	sub_tree->notify_sched_id = ast_sched_add(sched, sub_tree->notification_batch_interval, sched_cb, ao2_bump(sub_tree));
 	if (sub_tree->notify_sched_id < 0) {
+		ao2_cleanup(sub_tree);
 		return -1;
 	}
 
-	sub_tree->send_scheduled_notify = 1;
 	return 0;
 }
 
@@ -2245,7 +2415,7 @@ int ast_sip_subscription_notify(struct a
 
 	pjsip_dlg_inc_lock(dlg);
 
-	if (!sub->tree->evsub) {
+	if (sub->tree->state != SIP_SUB_TREE_NORMAL) {
 		pjsip_dlg_dec_lock(dlg);
 		return 0;
 	}
@@ -2259,6 +2429,7 @@ int ast_sip_subscription_notify(struct a
 	sub->body_changed = 1;
 	if (terminate) {
 		sub->subscription_state = PJSIP_EVSUB_STATE_TERMINATED;
+		sub->tree->state = SIP_SUB_TREE_TERMINATE_PENDING;
 	}
 
 	if (sub->tree->notification_batch_interval) {
@@ -2266,6 +2437,9 @@ int ast_sip_subscription_notify(struct a
 	} else {
 		/* See the note in pubsub_on_rx_refresh() for why sub->tree is refbumped here */
 		ao2_ref(sub->tree, +1);
+		if (terminate) {
+			sub->tree->state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;
+		}
 		res = send_notify(sub->tree, 0);
 		ast_test_suite_event_notify(terminate ? "SUBSCRIPTION_TERMINATED" : "SUBSCRIPTION_STATE_CHANGED",
 				"Resource: %s",
@@ -2433,8 +2607,9 @@ static int publication_cmp_fn(void *obj,
 
 static void publish_add_handler(struct ast_sip_publish_handler *handler)
 {
-	SCOPED_LOCK(lock, &publish_handlers, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
+	AST_RWLIST_WRLOCK(&publish_handlers);
 	AST_RWLIST_INSERT_TAIL(&publish_handlers, handler, next);
+	AST_RWLIST_UNLOCK(&publish_handlers);
 }
 
 int ast_sip_register_publish_handler(struct ast_sip_publish_handler *handler)
@@ -2461,7 +2636,8 @@ int ast_sip_register_publish_handler(str
 void ast_sip_unregister_publish_handler(struct ast_sip_publish_handler *handler)
 {
 	struct ast_sip_publish_handler *iter;
-	SCOPED_LOCK(lock, &publish_handlers, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
+
+	AST_RWLIST_WRLOCK(&publish_handlers);
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&publish_handlers, iter, next) {
 		if (handler == iter) {
 			AST_RWLIST_REMOVE_CURRENT(next);
@@ -2471,27 +2647,30 @@ void ast_sip_unregister_publish_handler(
 		}
 	}
 	AST_RWLIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&publish_handlers);
 }
 
 AST_RWLIST_HEAD_STATIC(subscription_handlers, ast_sip_subscription_handler);
 
 static void sub_add_handler(struct ast_sip_subscription_handler *handler)
 {
-	SCOPED_LOCK(lock, &subscription_handlers, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
+	AST_RWLIST_WRLOCK(&subscription_handlers);
 	AST_RWLIST_INSERT_TAIL(&subscription_handlers, handler, next);
 	ast_module_ref(ast_module_info->self);
+	AST_RWLIST_UNLOCK(&subscription_handlers);
 }
 
 static struct ast_sip_subscription_handler *find_sub_handler_for_event_name(const char *event_name)
 {
 	struct ast_sip_subscription_handler *iter;
-	SCOPED_LOCK(lock, &subscription_handlers, AST_RWLIST_RDLOCK, AST_RWLIST_UNLOCK);
 
+	AST_RWLIST_RDLOCK(&subscription_handlers);
 	AST_RWLIST_TRAVERSE(&subscription_handlers, iter, next) {
 		if (!strcmp(iter->event_name, event_name)) {
 			break;
 		}
 	}
+	AST_RWLIST_UNLOCK(&subscription_handlers);
 	return iter;
 }
 
@@ -2509,8 +2688,9 @@ int ast_sip_register_subscription_handle
 
 	existing = find_sub_handler_for_event_name(handler->event_name);
 	if (existing) {
-		ast_log(LOG_ERROR, "Unable to register subscription handler for event %s."
-				"A handler is already registered\n", handler->event_name);
+		ast_log(LOG_ERROR,
+			"Unable to register subscription handler for event %s.  A handler is already registered\n",
+			handler->event_name);
 		return -1;
 	}
 
@@ -2530,7 +2710,8 @@ int ast_sip_register_subscription_handle
 void ast_sip_unregister_subscription_handler(struct ast_sip_subscription_handler *handler)
 {
 	struct ast_sip_subscription_handler *iter;
-	SCOPED_LOCK(lock, &subscription_handlers, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
+
+	AST_RWLIST_WRLOCK(&subscription_handlers);
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&subscription_handlers, iter, next) {
 		if (handler == iter) {
 			AST_RWLIST_REMOVE_CURRENT(next);
@@ -2539,22 +2720,31 @@ void ast_sip_unregister_subscription_han
 		}
 	}
 	AST_RWLIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&subscription_handlers);
 }
 
-static struct ast_sip_pubsub_body_generator *find_body_generator_type_subtype(const char *content_type,
-		const char *content_subtype)
+static struct ast_sip_pubsub_body_generator *find_body_generator_type_subtype_nolock(const char *type, const char *subtype)
 {
-	struct ast_sip_pubsub_body_generator *iter;
-	SCOPED_LOCK(lock, &body_generators, AST_RWLIST_RDLOCK, AST_RWLIST_UNLOCK);
+	struct ast_sip_pubsub_body_generator *gen;
 
-	AST_LIST_TRAVERSE(&body_generators, iter, list) {
-		if (!strcmp(iter->type, content_type) &&
-				!strcmp(iter->subtype, content_subtype)) {
+	AST_LIST_TRAVERSE(&body_generators, gen, list) {
+		if (!strcmp(gen->type, type)
+			&& !strcmp(gen->subtype, subtype)) {
 			break;
 		}
-	};
+	}
 
-	return iter;
+	return gen;
+}
+
+static struct ast_sip_pubsub_body_generator *find_body_generator_type_subtype(const char *type, const char *subtype)
+{
+	struct ast_sip_pubsub_body_generator *gen;
+
+	AST_RWLIST_RDLOCK(&body_generators);
+	gen = find_body_generator_type_subtype_nolock(type, subtype);
+	AST_RWLIST_UNLOCK(&body_generators);
+	return gen;
 }
 
 static struct ast_sip_pubsub_body_generator *find_body_generator_accept(const char *accept)
@@ -2635,21 +2825,45 @@ static int generate_initial_notify(struc
 	return res;
 }
 
+static int pubsub_on_refresh_timeout(void *userdata);
+
 static int initial_notify_task(void * obj)
 {
-	struct sip_subscription_tree *sub_tree;
+	struct initial_notify_data *ind = obj;
 
-	sub_tree = obj;
-	if (generate_initial_notify(sub_tree->root)) {
-		pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
+	if (generate_initial_notify(ind->sub_tree->root)) {
+		pjsip_evsub_terminate(ind->sub_tree->evsub, PJ_TRUE);
 	} else {
-		send_notify(sub_tree, 1);
+		send_notify(ind->sub_tree, 1);
 		ast_test_suite_event_notify("SUBSCRIPTION_ESTABLISHED",
 			"Resource: %s",
-			sub_tree->root->resource);
+			ind->sub_tree->root->resource);
 	}
 
-	ao2_ref(sub_tree, -1);
+	if (ind->expires > -1) {
+		char *name = ast_alloca(strlen("->/ ") +
+			strlen(ind->sub_tree->persistence->endpoint) +
+			strlen(ind->sub_tree->root->resource) +
+			strlen(ind->sub_tree->root->handler->event_name) +
+			ind->sub_tree->dlg->call_id->id.slen + 1);
+
+		sprintf(name, "%s->%s/%s %.*s", ind->sub_tree->persistence->endpoint,
+			ind->sub_tree->root->resource, ind->sub_tree->root->handler->event_name,
+			(int)ind->sub_tree->dlg->call_id->id.slen, ind->sub_tree->dlg->call_id->id.ptr);
+
+		ast_debug(3, "Scheduling timer: %s\n", name);
+		ind->sub_tree->expiration_task = ast_sip_schedule_task(ind->sub_tree->serializer,
+			ind->expires * 1000, pubsub_on_refresh_timeout, name,
+			ind->sub_tree, AST_SIP_SCHED_TASK_FIXED | AST_SIP_SCHED_TASK_DATA_AO2);
+		if (!ind->sub_tree->expiration_task) {
+			ast_log(LOG_ERROR, "Unable to create expiration timer of %d seconds for %s\n",
+				ind->expires, name);
+		}
+	}
+
+	ao2_ref(ind->sub_tree, -1);
+	ast_free(ind);
+
 	return 0;
 }
 
@@ -2693,8 +2907,13 @@ static pj_bool_t pubsub_on_rx_subscribe_
 	resource = ast_alloca(resource_size);
 	ast_copy_pj_str(resource, &request_uri_sip->user, resource_size);
 
-	expires_header = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES, rdata->msg_info.msg->hdr.next);
+	/*
+	 * We may want to match without any user options getting
+	 * in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource);
 
+	expires_header = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES, rdata->msg_info.msg->hdr.next);
 	if (expires_header) {
 		if (expires_header->ivalue == 0) {
 			ast_log(LOG_WARNING, "Subscription request from endpoint %s rejected. Expiration of 0 is invalid\n",
@@ -2737,12 +2956,25 @@ static pj_bool_t pubsub_on_rx_subscribe_
 			pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);
 		}
 	} else {
+		struct initial_notify_data *ind = ast_malloc(sizeof(*ind));
+
+		if (!ind) {
+			pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
+			resource_tree_destroy(&tree);
+			return PJ_TRUE;
+		}
+
+		ind->sub_tree = ao2_bump(sub_tree);
+		/* Since this is a normal subscribe, pjproject takes care of the timer */
+		ind->expires = -1;
+
 		sub_tree->persistence = subscription_persistence_create(sub_tree);
-		subscription_persistence_update(sub_tree, rdata);
+		subscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_CREATED);
 		sip_subscription_accept(sub_tree, rdata, resp);
-		if (ast_sip_push_task(sub_tree->serializer, initial_notify_task, ao2_bump(sub_tree))) {
+		if (ast_sip_push_task(sub_tree->serializer, initial_notify_task, ind)) {
 			pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
 			ao2_ref(sub_tree, -1);
+			ast_free(ind);
 		}
 	}
 
@@ -2753,8 +2985,8 @@ static pj_bool_t pubsub_on_rx_subscribe_
 static struct ast_sip_publish_handler *find_pub_handler(const char *event)
 {
 	struct ast_sip_publish_handler *iter = NULL;
-	SCOPED_LOCK(lock, &publish_handlers, AST_RWLIST_RDLOCK, AST_RWLIST_UNLOCK);
 
+	AST_RWLIST_RDLOCK(&publish_handlers);
 	AST_RWLIST_TRAVERSE(&publish_handlers, iter, next) {
 		if (strcmp(event, iter->event_name)) {
 			ast_debug(3, "Event %s does not match %s\n", event, iter->event_name);
@@ -2763,6 +2995,7 @@ static struct ast_sip_publish_handler *f
 		ast_debug(3, "Event name match: %s = %s\n", event, iter->event_name);
 		break;
 	}
+	AST_RWLIST_UNLOCK(&publish_handlers);
 
 	return iter;
 }
@@ -2843,7 +3076,6 @@ static struct ast_sip_publication *sip_c
 static int sip_publication_respond(struct ast_sip_publication *pub, int status_code,
 		pjsip_rx_data *rdata)
 {
-	pj_status_t status;
 	pjsip_tx_data *tdata;
 	pjsip_transaction *tsx;
 
@@ -2852,26 +3084,24 @@ static int sip_publication_respond(struc
 	}
 
 	if (PJSIP_IS_STATUS_IN_CLASS(status_code, 200)) {
-		RAII_VAR(char *, entity_tag, NULL, ast_free_ptr);
-		RAII_VAR(char *, expires, NULL, ast_free_ptr);
+		char buf[30];
 
-		if ((ast_asprintf(&entity_tag, "%d", pub->entity_tag) < 0) ||
-			(ast_asprintf(&expires, "%d", pub->expires) < 0)) {
-			pjsip_tx_data_dec_ref(tdata);
-			return -1;
-		}
+		snprintf(buf, sizeof(buf), "%d", pub->entity_tag);
+		ast_sip_add_header(tdata, "SIP-ETag", buf);
 
-		ast_sip_add_header(tdata, "SIP-ETag", entity_tag);
-		ast_sip_add_header(tdata, "Expires", expires);
+		snprintf(buf, sizeof(buf), "%d", pub->expires);
+		ast_sip_add_header(tdata, "Expires", buf);
 	}
 
-	if ((status = pjsip_tsx_create_uas(&pubsub_module, rdata, &tsx)) != PJ_SUCCESS) {
+	if (pjsip_tsx_create_uas(&pubsub_module, rdata, &tsx) != PJ_SUCCESS) {
+		pjsip_tx_data_dec_ref(tdata);
 		return -1;
 	}
 
 	pjsip_tsx_recv_msg(tsx, rdata);
 
 	if (pjsip_tsx_send_msg(tsx, tdata) != PJ_SUCCESS) {
+		pjsip_tx_data_dec_ref(tdata);
 		return -1;
 	}
 
@@ -2906,13 +3136,22 @@ static struct ast_sip_publication *publi
 	resource_name = ast_alloca(resource_size);
 	ast_copy_pj_str(resource_name, &request_uri_sip->user, resource_size);
 
+	/*
+	 * We may want to match without any user options getting
+	 * in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource_name);
+
 	resource = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "inbound-publication", resource_name);
 	if (!resource) {
+		ast_debug(1, "No 'inbound-publication' defined for resource '%s'\n", resource_name);
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 404, NULL, NULL, NULL);
 		return NULL;
 	}
 
 	if (!ast_strlen_zero(resource->endpoint) && strcmp(resource->endpoint, ast_sorcery_object_get_id(endpoint))) {
+		ast_debug(1, "Resource %s has a defined endpoint '%s', but does not match endpoint '%s' that received the request\n",
+			resource_name, resource->endpoint, ast_sorcery_object_get_id(endpoint));
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
 		return NULL;
 	}
@@ -2924,6 +3163,7 @@ static struct ast_sip_publication *publi
 	}
 
 	if (!event_configuration_name) {
+		ast_debug(1, "Event '%s' is not configured for '%s'\n", handler->event_name, resource_name);
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 404, NULL, NULL, NULL);
 		return NULL;
 	}
@@ -3092,14 +3332,14 @@ int ast_sip_pubsub_register_body_generat
 	pj_str_t accept;
 	pj_size_t accept_len;
 
-	existing = find_body_generator_type_subtype(generator->type, generator->subtype);
+	AST_RWLIST_WRLOCK(&body_generators);
+	existing = find_body_generator_type_subtype_nolock(generator->type, generator->subtype);
 	if (existing) {
-		ast_log(LOG_WARNING, "Cannot register body generator of %s/%s."
-				"One is already registered.\n", generator->type, generator->subtype);
+		AST_RWLIST_UNLOCK(&body_generators);
+		ast_log(LOG_WARNING, "A body generator for %s/%s is already registered.\n",
+			generator->type, generator->subtype);
 		return -1;
 	}
-
-	AST_RWLIST_WRLOCK(&body_generators);
 	AST_LIST_INSERT_HEAD(&body_generators, generator, list);
 	AST_RWLIST_UNLOCK(&body_generators);
 
@@ -3119,8 +3359,8 @@ int ast_sip_pubsub_register_body_generat
 void ast_sip_pubsub_unregister_body_generator(struct ast_sip_pubsub_body_generator *generator)
 {
 	struct ast_sip_pubsub_body_generator *iter;
-	SCOPED_LOCK(lock, &body_generators, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
 
+	AST_RWLIST_WRLOCK(&body_generators);
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&body_generators, iter, list) {
 		if (iter == generator) {
 			AST_LIST_REMOVE_CURRENT(list);
@@ -3128,6 +3368,7 @@ void ast_sip_pubsub_unregister_body_gene
 		}
 	}
 	AST_RWLIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&body_generators);
 }
 
 int ast_sip_pubsub_register_body_supplement(struct ast_sip_pubsub_body_supplement *supplement)
@@ -3142,8 +3383,8 @@ int ast_sip_pubsub_register_body_supplem
 void ast_sip_pubsub_unregister_body_supplement(struct ast_sip_pubsub_body_supplement *supplement)
 {
 	struct ast_sip_pubsub_body_supplement *iter;
-	SCOPED_LOCK(lock, &body_supplements, AST_RWLIST_WRLOCK, AST_RWLIST_UNLOCK);
 
+	AST_RWLIST_WRLOCK(&body_supplements);
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&body_supplements, iter, list) {
 		if (iter == supplement) {
 			AST_LIST_REMOVE_CURRENT(list);
@@ -3151,6 +3392,7 @@ void ast_sip_pubsub_unregister_body_supp
 		}
 	}
 	AST_RWLIST_TRAVERSE_SAFE_END;
+	AST_RWLIST_UNLOCK(&body_supplements);
 }
 
 const char *ast_sip_subscription_get_body_type(struct ast_sip_subscription *sub)
@@ -3179,14 +3421,15 @@ int ast_sip_pubsub_generate_body_content
 	}
 
 	if (strcmp(data->body_type, generator->body_type)) {
-		ast_log(LOG_WARNING, "Body generator does not accept the type of data provided\n");
+		ast_log(LOG_WARNING, "%s/%s body generator does not accept the type of data provided\n",
+			type, subtype);
 		return -1;
 	}
 
 	body = generator->allocate_body(data->body_data);
 	if (!body) {
-		ast_log(LOG_WARNING, "Unable to allocate a NOTIFY body of type %s/%s\n",
-				type, subtype);
+		ast_log(LOG_WARNING, "%s/%s body generator could not to allocate a body\n",
+			type, subtype);
 		return -1;
 	}
 
@@ -3240,131 +3483,175 @@ static void set_state_terminated(struct
 	}
 }
 
-/* XXX This function and serialized_pubsub_on_rx_refresh are nearly identical */
-static int serialized_pubsub_on_server_timeout(void *userdata)
-{
-	struct sip_subscription_tree *sub_tree = userdata;
-	pjsip_dialog *dlg = sub_tree->dlg;
-
-	pjsip_dlg_inc_lock(dlg);
-	if (!sub_tree->evsub) {
-		pjsip_dlg_dec_lock(dlg);
-		return 0;
-	}
-	set_state_terminated(sub_tree->root);
-	send_notify(sub_tree, 1);
-	ast_test_suite_event_notify("SUBSCRIPTION_TERMINATED",
-			"Resource: %s",
-			sub_tree->root->resource);
-
-	pjsip_dlg_dec_lock(dlg);
-	ao2_cleanup(sub_tree);
-	return 0;
-}
+/*!
+ * \brief Callback sequence for subscription terminate:
+ *
+ * * Client initiated:
+ *     pjproject receives SUBSCRIBE on the subscription's serializer thread
+ *         calls pubsub_on_rx_refresh with dialog locked
+ *             pubsub_on_rx_refresh sets TERMINATE_PENDING
+ *             pushes serialized_pubsub_on_refresh_timeout
+ *             returns to pjproject
+ *         pjproject calls pubsub_on_evsub_state
+ *             pubsub_evsub_set_state checks state == TERMINATE_IN_PROGRESS (no)
+ *             ignore and return
+ *         pjproject unlocks dialog
+ *     serialized_pubsub_on_refresh_timeout starts (1)
+ *       locks dialog
+ *       checks state == TERMINATE_PENDING
+ *       sets TERMINATE_IN_PROGRESS
+ *       calls send_notify (2)
+ *           send_notify ultimately calls pjsip_evsub_send_request
+ *               pjsip_evsub_send_request calls evsub's set_state
+ *                   set_state calls pubsub_evsub_set_state
+ *                       pubsub_on_evsub_state checks state == TERMINATE_IN_PROGRESS
+ *                       removes the subscriptions
+ *                       cleans up references to evsub
+ *                       sets state = TERMINATED
+ *       serialized_pubsub_on_refresh_timeout unlocks dialog
+ *
+ * * Subscription timer expires:
+ *     pjproject timer expires
+ *         locks dialog
+ *         calls pubsub_on_server_timeout
+ *             pubsub_on_server_timeout checks state == NORMAL
+ *             sets TERMINATE_PENDING
+ *             pushes serialized_pubsub_on_refresh_timeout
+ *             returns to pjproject
+ *         pjproject unlocks dialog
+ *     serialized_pubsub_on_refresh_timeout starts
+ *         See (1) Above
+ *
+ * * Transmission failure sending NOTIFY or error response from client
+ *     pjproject transaction timer expires or non OK response
+ *         pjproject locks dialog
+ *         calls pubsub_on_evsub_state with event TSX_STATE
+ *             pubsub_on_evsub_state checks event == TSX_STATE
+ *             removes the subscriptions
+ *             cleans up references to evsub
+ *             sets state = TERMINATED
+ *         pjproject unlocks dialog
+ *
+ * * ast_sip_subscription_notify is called
+ *       checks state == NORMAL
+ *       if not batched...
+ *           sets TERMINATE_IN_PROGRESS (if terminate is requested)
+ *           calls send_notify
+ *               See (2) Above
+ *       if batched...
+ *           sets TERMINATE_PENDING
+ *           schedules task
+ *       scheduler runs sched_task
+ *           sched_task pushes serialized_send_notify
+ *       serialized_send_notify starts
+ *           checks state <= TERMINATE_PENDING
+ *           if state == TERMINATE_PENDING set state = TERMINATE_IN_PROGRESS
+ *           call send_notify
+ *               See (2) Above
+ *
+ */
 
 /*!
  * \brief PJSIP callback when underlying SIP subscription changes state
  *
- * This callback is a bit of a mess, because it's not always called when
- * you might expect it to be, and it can be called multiple times for the
- * same state.
- *
- * For instance, this function is not called at all when an incoming SUBSCRIBE
- * arrives to refresh a subscription. That makes sense in a way, since the
- * subscription state has not made a change; it was active and remains active.
- *
- * However, if an incoming SUBSCRIBE arrives to end a subscription, then this
- * will be called into once upon receiving the SUBSCRIBE (after the call to
- * pubsub_on_rx_refresh) and again when sending a NOTIFY to end the subscription.
- * In both cases, the apparent state of the subscription is "terminated".
- *
- * However, the double-terminated state changes don't happen in all cases. For
- * instance, if a subscription expires, then the only time this callback is
- * called is when we send the NOTIFY to end the subscription.
- *
- * As far as state changes are concerned, we only ever care about transitions
- * to the "terminated" state. The action we take here is dependent on the
- * conditions behind why the state change to "terminated" occurred. If the
- * state change has occurred because we are sending a NOTIFY to end the
- * subscription, we consider this to be the final hurrah of the subscription
- * and take measures to start shutting things down. If the state change to
- * terminated occurs for a different reason (e.g. transaction timeout,
- * incoming SUBSCRIBE to end the subscription), then we push a task to
- * send out a NOTIFY. When that NOTIFY is sent, this callback will be
- * called again and we will actually shut down the subscription. The
- * subscription tree's last_notify field let's us know if this is being
- * called as a result of a terminating NOTIFY or not.
- *
- * There is no guarantee that this function will be called from a serializer
- * thread since it can be called due to a transaction timeout. Therefore
- * synchronization primitives are necessary to ensure that no operations
- * step on each others' toes. The dialog lock is always held when this
- * callback is called, so we ensure that relevant structures that may
- * be touched in this function are always protected by the dialog lock
- * elsewhere as well. The dialog lock in particular protects
- *
- * \li The subscription tree's last_notify field
- * \li The subscription tree's evsub pointer
+ * Although this function is called for every state change, we only care
+ * about the TERMINATED state, and only when we're actually processing the final
+ * notify (SIP_SUB_TREE_TERMINATE_IN_PROGRESS) OR when a transmission failure
+ * occurs (PJSIP_EVENT_TSX_STATE).  In this case, we do all the subscription tree
+ * cleanup tasks and decrement the evsub reference.
  */
 static void pubsub_on_evsub_state(pjsip_evsub *evsub, pjsip_event *event)
 {
-	struct sip_subscription_tree *sub_tree;
+	struct sip_subscription_tree *sub_tree =
+		pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
 
-	ast_debug(3, "on_evsub_state called with state %s\n", pjsip_evsub_get_state_name(evsub));
+	ast_debug(3, "evsub %p state %s event %s sub_tree %p sub_tree state %s\n", evsub,
+		pjsip_evsub_get_state_name(evsub), pjsip_event_str(event->type), sub_tree,
+		(sub_tree ? sub_tree_state_description[sub_tree->state] : "UNKNOWN"));
 
-	if (pjsip_evsub_get_state(evsub) != PJSIP_EVSUB_STATE_TERMINATED) {
+	if (!sub_tree || pjsip_evsub_get_state(evsub) != PJSIP_EVSUB_STATE_TERMINATED) {
 		return;
 	}
 
-	sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
-	if (!sub_tree) {
+	/* It's easier to write this as what we WANT to process, then negate it. */
+	if (!(sub_tree->state == SIP_SUB_TREE_TERMINATE_IN_PROGRESS
+		|| (event->type == PJSIP_EVENT_TSX_STATE && sub_tree->state == SIP_SUB_TREE_NORMAL)
+		)) {
+		ast_debug(3, "Do nothing.\n");
 		return;
 	}
 
-	if (!sub_tree->last_notify) {
-		if (ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_server_timeout, ao2_bump(sub_tree))) {
-			ast_log(LOG_ERROR, "Failed to push task to send final NOTIFY.\n");
-			ao2_ref(sub_tree, -1);
-		} else {
-			return;
-		}
+	if (sub_tree->expiration_task) {
+		char task_name[256];
+
+		ast_sip_sched_task_get_name(sub_tree->expiration_task, task_name, sizeof(task_name));
+		ast_debug(3, "Cancelling timer: %s\n", task_name);
+		ast_sip_sched_task_cancel(sub_tree->expiration_task);
+		ao2_cleanup(sub_tree->expiration_task);
+		sub_tree->expiration_task = NULL;
 	}
 
 	remove_subscription(sub_tree);
+
 	pjsip_evsub_set_mod_data(evsub, pubsub_module.id, NULL);
+
+#ifdef HAVE_PJSIP_EVSUB_GRP_LOCK
+	pjsip_evsub_dec_ref(sub_tree->evsub);
+#endif
+
 	sub_tree->evsub = NULL;
+
 	ast_sip_dialog_set_serializer(sub_tree->dlg, NULL);
 	ast_sip_dialog_set_endpoint(sub_tree->dlg, NULL);
+
 	subscription_persistence_remove(sub_tree);
 	shutdown_subscriptions(sub_tree->root);
 
+	sub_tree->state = SIP_SUB_TREE_TERMINATED;
 	/* Remove evsub's reference to the sub_tree */
 	ao2_ref(sub_tree, -1);
 }
 
-static int serialized_pubsub_on_rx_refresh(void *userdata)
+static int pubsub_on_refresh_timeout(void *userdata)
 {
 	struct sip_subscription_tree *sub_tree = userdata;
 	pjsip_dialog *dlg = sub_tree->dlg;
 
+	ast_debug(3, "sub_tree %p sub_tree state %s\n", sub_tree,
+		(sub_tree ? sub_tree_state_description[sub_tree->state] : "UNKNOWN"));
+
 	pjsip_dlg_inc_lock(dlg);
-	if (!sub_tree->evsub) {
+	if (sub_tree->state >= SIP_SUB_TREE_TERMINATE_IN_PROGRESS) {
 		pjsip_dlg_dec_lock(dlg);
 		return 0;
 	}
 
-	if (pjsip_evsub_get_state(sub_tree->evsub) == PJSIP_EVSUB_STATE_TERMINATED) {
+	if (sub_tree->state == SIP_SUB_TREE_TERMINATE_PENDING) {
+		sub_tree->state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;
 		set_state_terminated(sub_tree->root);
 	}
 
 	send_notify(sub_tree, 1);
 
 	ast_test_suite_event_notify(sub_tree->root->subscription_state == PJSIP_EVSUB_STATE_TERMINATED ?
-			"SUBSCRIPTION_TERMINATED" : "SUBSCRIPTION_REFRESHED",
-			"Resource: %s", sub_tree->root->resource);
+				"SUBSCRIPTION_TERMINATED" : "SUBSCRIPTION_REFRESHED",
+				"Resource: %s", sub_tree->root->resource);
 
 	pjsip_dlg_dec_lock(dlg);
+
+	return 0;
+}
+
+static int serialized_pubsub_on_refresh_timeout(void *userdata)
+{
+	struct sip_subscription_tree *sub_tree = userdata;
+
+	ast_debug(3, "sub_tree %p sub_tree state %s\n", sub_tree,
+		(sub_tree ? sub_tree_state_description[sub_tree->state] : "UNKNOWN"));
+
+	pubsub_on_refresh_timeout(userdata);
 	ao2_cleanup(sub_tree);
+
 	return 0;
 }
 
@@ -3374,10 +3661,8 @@ static int serialized_pubsub_on_rx_refre
  * This includes both SUBSCRIBE requests that actually refresh the subscription
  * as well as SUBSCRIBE requests that end the subscription.
  *
- * In the case where the SUBSCRIBE is actually refreshing the subscription we
- * push a task to send an appropriate NOTIFY request. In the case where the
- * SUBSCRIBE is ending the subscription, we let the pubsub_on_evsub_state
- * callback take care of sending the terminal NOTIFY request instead.
+ * In either case we push serialized_pubsub_on_refresh_timeout to send an
+ * appropriate NOTIFY request.
  */
 static void pubsub_on_rx_refresh(pjsip_evsub *evsub, pjsip_rx_data *rdata,
 		int *p_st_code, pj_str_t **p_st_text, pjsip_hdr *res_hdr, pjsip_msg_body **p_body)
@@ -3385,18 +3670,38 @@ static void pubsub_on_rx_refresh(pjsip_e
 	struct sip_subscription_tree *sub_tree;
 
 	sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
-	if (!sub_tree) {
+	ast_debug(3, "evsub %p sub_tree %p sub_tree state %s\n", evsub, sub_tree,
+		(sub_tree ? sub_tree_state_description[sub_tree->state] : "UNKNOWN"));
+
+	if (!sub_tree || sub_tree->state != SIP_SUB_TREE_NORMAL) {
 		return;
 	}
 
+	if (sub_tree->expiration_task) {
+		char task_name[256];
+
+		ast_sip_sched_task_get_name(sub_tree->expiration_task, task_name, sizeof(task_name));
+		ast_debug(3, "Cancelling timer: %s\n", task_name);
+		ast_sip_sched_task_cancel(sub_tree->expiration_task);
+		ao2_cleanup(sub_tree->expiration_task);
+		sub_tree->expiration_task = NULL;
+	}
+
 	/* PJSIP will set the evsub's state to terminated before calling into this function
 	 * if the Expires value of the incoming SUBSCRIBE is 0.
 	 */
-	if (pjsip_evsub_get_state(sub_tree->evsub) != PJSIP_EVSUB_STATE_TERMINATED) {
-		if (ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_rx_refresh, ao2_bump(sub_tree))) {
-			/* If we can't push the NOTIFY refreshing task...we'll just go with it. */
-			ao2_ref(sub_tree, -1);
-		}
+
+	if (pjsip_evsub_get_state(sub_tree->evsub) == PJSIP_EVSUB_STATE_TERMINATED) {
+		sub_tree->state = SIP_SUB_TREE_TERMINATE_PENDING;
+	}
+
+	subscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_REFRESHED);
+
+	if (ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_refresh_timeout, ao2_bump(sub_tree))) {
+		/* If we can't push the NOTIFY refreshing task...we'll just go with it. */
+		ast_log(LOG_ERROR, "Failed to push task to send NOTIFY.\n");
+		sub_tree->state = SIP_SUB_TREE_NORMAL;
+		ao2_ref(sub_tree, -1);
 	}
 
 	if (sub_tree->is_list) {
@@ -3407,9 +3712,9 @@ static void pubsub_on_rx_refresh(pjsip_e
 static void pubsub_on_rx_notify(pjsip_evsub *evsub, pjsip_rx_data *rdata, int *p_st_code,
 		pj_str_t **p_st_text, pjsip_hdr *res_hdr, pjsip_msg_body **p_body)
 {
-	struct ast_sip_subscription *sub = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
+	struct ast_sip_subscription *sub;
 
-	if (!sub) {
+	if (!(sub = pjsip_evsub_get_mod_data(evsub, pubsub_module.id))) {
 		return;
 	}
 
@@ -3422,45 +3727,61 @@ static int serialized_pubsub_on_client_r
 	struct sip_subscription_tree *sub_tree = userdata;
 	pjsip_tx_data *tdata;
 
+	if (!sub_tree->evsub) {
+		ao2_cleanup(sub_tree);
+		return 0;
+	}
+
 	if (pjsip_evsub_initiate(sub_tree->evsub, NULL, -1, &tdata) == PJ_SUCCESS) {
 		pjsip_evsub_send_request(sub_tree->evsub, tdata);
 	} else {
 		pjsip_evsub_terminate(sub_tree->evsub, PJ_TRUE);
 	}
+
 	ao2_cleanup(sub_tree);
 	return 0;
 }
 
 static void pubsub_on_client_refresh(pjsip_evsub *evsub)
 {
-	struct sip_subscription_tree *sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
+	struct sip_subscription_tree *sub_tree;
 
-	ao2_ref(sub_tree, +1);
-	ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_client_refresh, sub_tree);
+	if (!(sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id))) {
+		return;
+	}
+
+	if (ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_client_refresh, ao2_bump(sub_tree))) {
+		ao2_cleanup(sub_tree);
+	}
 }
 
 static void pubsub_on_server_timeout(pjsip_evsub *evsub)
 {
+	struct sip_subscription_tree *sub_tree;
 
-	struct sip_subscription_tree *sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
-	if (!sub_tree) {
-		/* PJSIP does not terminate the server timeout timer when a SUBSCRIBE
-		 * with Expires: 0 arrives to end a subscription, nor does it terminate
-		 * this timer when we send a NOTIFY request in response to receiving such
-		 * a SUBSCRIBE. PJSIP does not stop the server timeout timer until the
-		 * NOTIFY transaction has finished (either through receiving a response
-		 * or through a transaction timeout).
-		 *
-		 * Therefore, it is possible that we can be told that a server timeout
-		 * occurred after we already thought that the subscription had been
-		 * terminated. In such a case, we will have already removed the sub_tree
-		 * from the evsub's mod_data array.
-		 */
+	/* PJSIP does not terminate the server timeout timer when a SUBSCRIBE
+	 * with Expires: 0 arrives to end a subscription, nor does it terminate
+	 * this timer when we send a NOTIFY request in response to receiving such
+	 * a SUBSCRIBE. PJSIP does not stop the server timeout timer until the
+	 * NOTIFY transaction has finished (either through receiving a response
+	 * or through a transaction timeout).
+	 *
+	 * Therefore, it is possible that we can be told that a server timeout
+	 * occurred after we already thought that the subscription had been
+	 * terminated. In such a case, we will have already removed the sub_tree
+	 * from the evsub's mod_data array.
+	 */
+
+	sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);
+	if (!sub_tree || sub_tree->state != SIP_SUB_TREE_NORMAL) {
         return;
 	}
 
-	ao2_ref(sub_tree, +1);
-	ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_server_timeout, sub_tree);
+	sub_tree->state = SIP_SUB_TREE_TERMINATE_PENDING;
+	if (ast_sip_push_task(sub_tree->serializer, serialized_pubsub_on_refresh_timeout, ao2_bump(sub_tree))) {
+		sub_tree->state = SIP_SUB_TREE_NORMAL;
+		ao2_cleanup(sub_tree);
+	}
 }
 
 static int ami_subscription_detail(struct sip_subscription_tree *sub_tree,
@@ -3477,6 +3798,8 @@ static int ami_subscription_detail(struc
 	sip_subscription_to_ami(sub_tree, &buf);
 	astman_append(ami->s, "%s\r\n", ast_str_buffer(buf));
 	ast_free(buf);
+
+	++ami->count;
 	return 0;
 }
 
@@ -3495,14 +3818,13 @@ static int ami_subscription_detail_outbo
 static int ami_show_subscriptions_inbound(struct mansession *s, const struct message *m)
 {
 	struct ast_sip_ami ami = { .s = s, .m = m, .action_id = astman_get_header(m, "ActionID"), };
-	int num;
 
-	astman_send_listack(s, m, "Following are Events for "
-			    "each inbound Subscription", "start");
+	astman_send_listack(s, m, "Following are Events for each inbound Subscription",
+		"start");
 
-	num = for_each_subscription(ami_subscription_detail_inbound, &ami);
+	for_each_subscription(ami_subscription_detail_inbound, &ami);
 
-	astman_send_list_complete_start(s, m, "InboundSubscriptionDetailComplete", num);
+	astman_send_list_complete_start(s, m, "InboundSubscriptionDetailComplete", ami.count);
 	astman_send_list_complete_end(s);
 	return 0;
 }
@@ -3510,14 +3832,13 @@ static int ami_show_subscriptions_inboun
 static int ami_show_subscriptions_outbound(struct mansession *s, const struct message *m)
 {
 	struct ast_sip_ami ami = { .s = s, .m = m, .action_id = astman_get_header(m, "ActionID"), };
-	int num;
 
-	astman_send_listack(s, m, "Following are Events for "
-			    "each outbound Subscription", "start");
+	astman_send_listack(s, m, "Following are Events for each outbound Subscription",
+		"start");
 
-	num = for_each_subscription(ami_subscription_detail_outbound, &ami);
+	for_each_subscription(ami_subscription_detail_outbound, &ami);
 
-	astman_send_list_complete_start(s, m, "OutboundSubscriptionDetailComplete", num);
+	astman_send_list_complete_start(s, m, "OutboundSubscriptionDetailComplete", ami.count);
 	astman_send_list_complete_end(s);
 	return 0;
 }
@@ -3538,31 +3859,31 @@ static int format_ami_resource_lists(voi
 		return CMP_STOP;
 	}
 	astman_append(ami->s, "%s\r\n", ast_str_buffer(buf));
-
 	ast_free(buf);
+
+	++ami->count;
 	return 0;
 }
 
 static int ami_show_resource_lists(struct mansession *s, const struct message *m)
 {
 	struct ast_sip_ami ami = { .s = s, .m = m, .action_id = astman_get_header(m, "ActionID"), };
-	int num;
 	struct ao2_container *lists;
 
 	lists = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(), "resource_list",
 			AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
 
-	if (!lists || !(num = ao2_container_count(lists))) {
+	if (!lists || !ao2_container_count(lists)) {
 		astman_send_error(s, m, "No resource lists found\n");
 		return 0;
 	}
 
-	astman_send_listack(s, m, "A listing of resource lists follows, "
-			    "presented as ResourceListDetail events", "start");
+	astman_send_listack(s, m, "A listing of resource lists follows, presented as ResourceListDetail events",
+		"start");
 
 	ao2_callback(lists, OBJ_NODATA, format_ami_resource_lists, &ami);
 
-	astman_send_list_complete_start(s, m, "ResourceListDetailComplete", num);
+	astman_send_list_complete_start(s, m, "ResourceListDetailComplete", ami.count);
 	astman_send_list_complete_end(s);
 	return 0;
 }
@@ -3570,6 +3891,541 @@ static int ami_show_resource_lists(struc
 #define AMI_SHOW_SUBSCRIPTIONS_INBOUND "PJSIPShowSubscriptionsInbound"
 #define AMI_SHOW_SUBSCRIPTIONS_OUTBOUND "PJSIPShowSubscriptionsOutbound"
 
+#define MAX_REGEX_ERROR_LEN 128
+
+struct cli_sub_parms {
+	/*! CLI handler entry e parameter */
+	struct ast_cli_entry *e;
+	/*! CLI handler entry a parameter */
+	struct ast_cli_args *a;
+	/*! CLI subscription entry output line(s) */
+	struct ast_str *buf;
+	/*! Compiled regular expression to select if buf is written to CLI when not NULL. */
+	regex_t *like;
+	int count;
+};
+
+struct cli_sub_complete_parms {
+	struct ast_cli_args *a;
+	/*! Found callid for search position */
+	char *callid;
+	int wordlen;
+	int which;
+};
+
+static int cli_complete_subscription_common(struct sip_subscription_tree *sub_tree, struct cli_sub_complete_parms *cli)
+{
+	pj_str_t *callid;
+
+	if (!sub_tree->dlg) {
+		return 0;
+	}
+
+	callid = &sub_tree->dlg->call_id->id;
+	if (cli->wordlen <= pj_strlen(callid)
+		&& !strncasecmp(cli->a->word, pj_strbuf(callid), cli->wordlen)
+		&& (++cli->which > cli->a->n)) {
+		cli->callid = ast_malloc(pj_strlen(callid) + 1);
+		if (cli->callid) {
+			ast_copy_pj_str(cli->callid, callid, pj_strlen(callid) + 1);
+		}
+		return -1;
+	}
+	return 0;
+}
+
+static int cli_complete_subscription_inbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_NOTIFIER
+		? cli_complete_subscription_common(sub_tree, arg) : 0;
+}
+
+static int cli_complete_subscription_outbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_SUBSCRIBER
+		? cli_complete_subscription_common(sub_tree, arg) : 0;
+}
+
+static char *cli_complete_subscription_callid(struct ast_cli_args *a)
+{
+	struct cli_sub_complete_parms cli;
+	on_subscription_t on_subscription;
+
+	if (a->pos != 4) {
+		return NULL;
+	}
+
+	if (!strcasecmp(a->argv[3], "inbound")) {
+		on_subscription = cli_complete_subscription_inbound;
+	} else if (!strcasecmp(a->argv[3], "outbound")) {
+		on_subscription = cli_complete_subscription_outbound;
+	} else {
+		/* Should never get here */
+		ast_assert(0);
+		return NULL;
+	}
+
+	cli.a = a;
+	cli.callid = NULL;
+	cli.wordlen = strlen(a->word);
+	cli.which = 0;
+	for_each_subscription(on_subscription, &cli);
+
+	return cli.callid;
+}
+
+static int cli_subscription_expiry(struct sip_subscription_tree *sub_tree)
+{
+	int expiry;
+
+	expiry = sub_tree->persistence
+		? ast_tvdiff_ms(sub_tree->persistence->expires, ast_tvnow()) / 1000
+		: 0;
+	if (expiry < 0) {
+		/* Subscription expired */
+		expiry = 0;
+	}
+	return expiry;
+}
+
+static int cli_show_subscription_common(struct sip_subscription_tree *sub_tree, struct cli_sub_parms *cli)
+{
+	const char *callid = (const char *) cli->buf;/* Member repurposed to pass in callid */
+	pj_str_t *sub_callid;
+	struct ast_str *buf;
+	char *src;
+	char *dest;
+	char *key;
+	char *value;
+	char *value_end;
+	int key_len;
+	int key_filler_width;
+	int value_len;
+
+	if (!sub_tree->dlg) {
+		return 0;
+	}
+	sub_callid = &sub_tree->dlg->call_id->id;
+	if (pj_strcmp2(sub_callid, callid)) {
+		return 0;
+	}
+
+	buf = ast_str_create(512);
+	if (!buf) {
+		return -1;
+	}
+
+	ast_cli(cli->a->fd,
+		"%-20s: %s\n"
+		"===========================================================================\n",
+		"ParameterName", "ParameterValue");
+
+	ast_str_append(&buf, 0, "Resource: %s\n", sub_tree->root->resource);
+	ast_str_append(&buf, 0, "Event: %s\n", sub_tree->root->handler->event_name);
+	ast_str_append(&buf, 0, "Expiry: %d\n", cli_subscription_expiry(sub_tree));
+
+	sip_subscription_to_ami(sub_tree, &buf);
+
+	/* Convert AMI \r\n to \n line terminators. */
+	src = strchr(ast_str_buffer(buf), '\r');
+	if (src) {
+		dest = src;
+		++src;
+		while (*src) {
+			if (*src == '\r') {
+				++src;
+				continue;
+			}
+			*dest++ = *src++;
+		}
+		*dest = '\0';
+		ast_str_update(buf);
+	}
+
+	/* Reformat AMI key value pairs to pretty columns */
+	key = ast_str_buffer(buf);
+	do {
+		value = strchr(key, ':');
+		if (!value) {
+			break;
+		}
+		value_end = strchr(value, '\n');
+		if (!value_end) {
+			break;
+		}
+
+		/* Calculate field lengths */
+		key_len = value - key;
+		key_filler_width = 20 - key_len;
+		if (key_filler_width < 0) {
+			key_filler_width = 0;
+		}
+		value_len = value_end - value;
+
+		ast_cli(cli->a->fd, "%.*s%*s%.*s\n",
+			key_len, key, key_filler_width, "",
+			value_len, value);
+
+		key = value_end + 1;
+	} while (*key);
+	ast_cli(cli->a->fd, "\n");
+
+	ast_free(buf);
+
+	return -1;
+}
+
+static int cli_show_subscription_inbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_NOTIFIER
+		? cli_show_subscription_common(sub_tree, arg) : 0;
+}
+
+static int cli_show_subscription_outbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_SUBSCRIBER
+		? cli_show_subscription_common(sub_tree, arg) : 0;
+}
+
+static char *cli_show_subscription_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	on_subscription_t on_subscription;
+	struct cli_sub_parms cli;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pjsip show subscription {inbound|outbound}";
+		e->usage = "Usage:\n"
+				   "   pjsip show subscription inbound <call-id>\n"
+				   "   pjsip show subscription outbound <call-id>\n"
+				   "      Show active subscription with the dialog call-id\n";
+		return NULL;
+	case CLI_GENERATE:
+		return cli_complete_subscription_callid(a);
+	}
+
+	if (a->argc != 5) {
+		return CLI_SHOWUSAGE;
+	}
+
+	if (!strcasecmp(a->argv[3], "inbound")) {
+		on_subscription = cli_show_subscription_inbound;
+	} else if (!strcasecmp(a->argv[3], "outbound")) {
+		on_subscription = cli_show_subscription_outbound;
+	} else {
+		/* Should never get here */
+		ast_assert(0);
+		return NULL;
+	}
+
+	/* Find the subscription with the specified call-id */
+	cli.a = a;
+	cli.e = e;
+	cli.buf = (void *) a->argv[4];/* Repurpose the buf member to pass in callid */
+	for_each_subscription(on_subscription, &cli);
+
+	return CLI_SUCCESS;
+}
+
+#define CLI_SHOW_SUB_FORMAT_HEADER \
+	"Endpoint: <Endpoint/Caller-ID.............................................>\n" \
+	"Resource: <Resource/Event.................................................>\n" \
+	"  Expiry: <Expiry>  <Call-id..............................................>\n" \
+	"===========================================================================\n\n"
+#define CLI_SHOW_SUB_FORMAT_ENTRY  \
+	"Endpoint: %s/%s\n" \
+	"Resource: %s/%s\n" \
+	"  Expiry: %8d  %s\n\n"
+
+static int cli_show_subscriptions_detail(struct sip_subscription_tree *sub_tree, struct cli_sub_parms *cli)
+{
+	char caller_id[256];
+	char callid[256];
+
+	ast_callerid_merge(caller_id, sizeof(caller_id),
+		S_COR(sub_tree->endpoint->id.self.name.valid,
+			sub_tree->endpoint->id.self.name.str, NULL),
+		S_COR(sub_tree->endpoint->id.self.number.valid,
+			sub_tree->endpoint->id.self.number.str, NULL),
+		"<none>");
+
+	/* Call-id */
+	if (sub_tree->dlg) {
+		ast_copy_pj_str(callid, &sub_tree->dlg->call_id->id, sizeof(callid));
+	} else {
+		ast_copy_string(callid, "<unknown>", sizeof(callid));
+	}
+
+	ast_str_set(&cli->buf, 0, CLI_SHOW_SUB_FORMAT_ENTRY,
+		ast_sorcery_object_get_id(sub_tree->endpoint), caller_id,
+		sub_tree->root->resource, sub_tree->root->handler->event_name,
+		cli_subscription_expiry(sub_tree), callid);
+
+	if (cli->like) {
+		if (regexec(cli->like, ast_str_buffer(cli->buf), 0, NULL, 0)) {
+			/* Output line did not match the regex */
+			return 0;
+		}
+	}
+
+	ast_cli(cli->a->fd, "%s", ast_str_buffer(cli->buf));
+	++cli->count;
+
+	return 0;
+}
+
+static int cli_show_subscriptions_inbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_NOTIFIER
+		? cli_show_subscriptions_detail(sub_tree, arg) : 0;
+}
+
+static int cli_show_subscriptions_outbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_SUBSCRIBER
+		? cli_show_subscriptions_detail(sub_tree, arg) : 0;
+}
+
+static char *cli_show_subscriptions_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	on_subscription_t on_subscription;
+	struct cli_sub_parms cli;
+	regex_t like;
+	const char *regex;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pjsip show subscriptions {inbound|outbound} [like]";
+		e->usage = "Usage:\n"
+				   "   pjsip show subscriptions inbound [like <regex>]\n"
+				   "      Show active inbound subscriptions\n"
+				   "   pjsip show subscriptions outbound [like <regex>]\n"
+				   "      Show active outbound subscriptions\n"
+				   "\n"
+				   "   The regex selects a subscriptions output that matches.\n"
+				   "   i.e.,  All output lines for a subscription are checked\n"
+				   "   as a block by the regex.\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc != 4 && a->argc != 6) {
+		return CLI_SHOWUSAGE;
+	}
+	if (!strcasecmp(a->argv[3], "inbound")) {
+		on_subscription = cli_show_subscriptions_inbound;
+	} else if (!strcasecmp(a->argv[3], "outbound")) {
+		on_subscription = cli_show_subscriptions_outbound;
+	} else {
+		/* Should never get here */
+		ast_assert(0);
+		return CLI_SHOWUSAGE;
+	}
+	if (a->argc == 6) {
+		int rc;
+
+		if (strcasecmp(a->argv[4], "like")) {
+			return CLI_SHOWUSAGE;
+		}
+
+		/* Setup regular expression */
+		memset(&like, 0, sizeof(like));
+		cli.like = &like;
+		regex = a->argv[5];
+		rc = regcomp(cli.like, regex, REG_EXTENDED | REG_NOSUB);
+		if (rc) {
+			char *regerr = ast_alloca(MAX_REGEX_ERROR_LEN);
+
+			regerror(rc, cli.like, regerr, MAX_REGEX_ERROR_LEN);
+			ast_cli(a->fd, "Regular expression '%s' failed to compile: %s\n",
+				regex, regerr);
+			return CLI_FAILURE;
+		}
+	} else {
+		cli.like = NULL;
+		regex = NULL;
+	}
+
+	cli.a = a;
+	cli.e = e;
+	cli.count = 0;
+	cli.buf = ast_str_create(256);
+	if (!cli.buf) {
+		if (cli.like) {
+			regfree(cli.like);
+		}
+		return CLI_FAILURE;
+	}
+
+	ast_cli(a->fd, CLI_SHOW_SUB_FORMAT_HEADER);
+	for_each_subscription(on_subscription, &cli);
+	ast_cli(a->fd, "%d active subscriptions%s%s%s\n",
+		cli.count,
+		regex ? " matched \"" : "",
+		regex ?: "",
+		regex ? "\"" : "");
+
+	ast_free(cli.buf);
+	if (cli.like) {
+		regfree(cli.like);
+	}
+
+	return CLI_SUCCESS;
+}
+
+#define CLI_LIST_SUB_FORMAT_HEADER "%-30.30s %-30.30s %6.6s %s\n"
+#define CLI_LIST_SUB_FORMAT_ENTRY  "%-30.30s %-30.30s %6d %s\n"
+
+static int cli_list_subscriptions_detail(struct sip_subscription_tree *sub_tree, struct cli_sub_parms *cli)
+{
+	char ep_cid_buf[50];
+	char res_evt_buf[50];
+	char callid[256];
+
+	/* Endpoint/CID column */
+	snprintf(ep_cid_buf, sizeof(ep_cid_buf), "%s/%s",
+		ast_sorcery_object_get_id(sub_tree->endpoint),
+		S_COR(sub_tree->endpoint->id.self.name.valid, sub_tree->endpoint->id.self.name.str,
+			S_COR(sub_tree->endpoint->id.self.number.valid,
+				sub_tree->endpoint->id.self.number.str, "<none>")));
+
+	/* Resource/Event column */
+	snprintf(res_evt_buf, sizeof(res_evt_buf), "%s/%s",
+		sub_tree->root->resource,
+		sub_tree->root->handler->event_name);
+
+	/* Call-id column */
+	if (sub_tree->dlg) {
+		ast_copy_pj_str(callid, &sub_tree->dlg->call_id->id, sizeof(callid));
+	} else {
+		ast_copy_string(callid, "<unknown>", sizeof(callid));
+	}
+
+	ast_str_set(&cli->buf, 0, CLI_LIST_SUB_FORMAT_ENTRY,
+		ep_cid_buf,
+		res_evt_buf,
+		cli_subscription_expiry(sub_tree),
+		callid);
+
+	if (cli->like) {
+		if (regexec(cli->like, ast_str_buffer(cli->buf), 0, NULL, 0)) {
+			/* Output line did not match the regex */
+			return 0;
+		}
+	}
+
+	ast_cli(cli->a->fd, "%s", ast_str_buffer(cli->buf));
+	++cli->count;
+
+	return 0;
+}
+
+static int cli_list_subscriptions_inbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_NOTIFIER
+		? cli_list_subscriptions_detail(sub_tree, arg) : 0;
+}
+
+static int cli_list_subscriptions_outbound(struct sip_subscription_tree *sub_tree, void *arg)
+{
+	return sub_tree->role == AST_SIP_SUBSCRIBER
+		? cli_list_subscriptions_detail(sub_tree, arg) : 0;
+}
+
+static char *cli_list_subscriptions_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	on_subscription_t on_subscription;
+	struct cli_sub_parms cli;
+	regex_t like;
+	const char *regex;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pjsip list subscriptions {inbound|outbound} [like]";
+		e->usage = "Usage:\n"
+				   "   pjsip list subscriptions inbound [like <regex>]\n"
+				   "      List active inbound subscriptions\n"
+				   "   pjsip list subscriptions outbound [like <regex>]\n"
+				   "      List active outbound subscriptions\n"
+				   "\n"
+				   "   The regex selects output lines that match.\n";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	if (a->argc != 4 && a->argc != 6) {
+		return CLI_SHOWUSAGE;
+	}
+	if (!strcasecmp(a->argv[3], "inbound")) {
+		on_subscription = cli_list_subscriptions_inbound;
+	} else if (!strcasecmp(a->argv[3], "outbound")) {
+		on_subscription = cli_list_subscriptions_outbound;
+	} else {
+		/* Should never get here */
+		ast_assert(0);
+		return CLI_SHOWUSAGE;
+	}
+	if (a->argc == 6) {
+		int rc;
+
+		if (strcasecmp(a->argv[4], "like")) {
+			return CLI_SHOWUSAGE;
+		}
+
+		/* Setup regular expression */
+		memset(&like, 0, sizeof(like));
+		cli.like = &like;
+		regex = a->argv[5];
+		rc = regcomp(cli.like, regex, REG_EXTENDED | REG_NOSUB);
+		if (rc) {
+			char *regerr = ast_alloca(MAX_REGEX_ERROR_LEN);
+
+			regerror(rc, cli.like, regerr, MAX_REGEX_ERROR_LEN);
+			ast_cli(a->fd, "Regular expression '%s' failed to compile: %s\n",
+				regex, regerr);
+			return CLI_FAILURE;
+		}
+	} else {
+		cli.like = NULL;
+		regex = NULL;
+	}
+
+	cli.a = a;
+	cli.e = e;
+	cli.count = 0;
+	cli.buf = ast_str_create(256);
+	if (!cli.buf) {
+		if (cli.like) {
+			regfree(cli.like);
+		}
+		return CLI_FAILURE;
+	}
+
+	ast_cli(a->fd, CLI_LIST_SUB_FORMAT_HEADER,
+		"Endpoint/CLI", "Resource/Event", "Expiry", "Call-id");
+	for_each_subscription(on_subscription, &cli);
+	ast_cli(a->fd, "\n%d active subscriptions%s%s%s\n",
+		cli.count,
+		regex ? " matched \"" : "",
+		regex ?: "",
+		regex ? "\"" : "");
+
+	ast_free(cli.buf);
+	if (cli.like) {
+		regfree(cli.like);
+	}
+
+	return CLI_SUCCESS;
+}
+
+static struct ast_cli_entry cli_commands[] = {
+	AST_CLI_DEFINE(cli_list_subscriptions_inout, "List active inbound/outbound subscriptions"),
+	AST_CLI_DEFINE(cli_show_subscription_inout, "Show active subscription details"),
+	AST_CLI_DEFINE(cli_show_subscriptions_inout, "Show active inbound/outbound subscriptions"),
+};
+
 static int persistence_endpoint_str2struct(const struct aco_option *opt, struct ast_variable *var, void *obj)
 {
 	struct subscription_persistence *persistence = obj;
@@ -4431,13 +5287,13 @@ static int load_module(void)
 
 	if (!(sched = ast_sched_context_create())) {
 		ast_log(LOG_ERROR, "Could not create scheduler for publication expiration\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_sched_start_thread(sched)) {
 		ast_log(LOG_ERROR, "Could not start scheduler thread for publication expiration\n");
 		ast_sched_context_destroy(sched);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	pjsip_endpt_add_capability(ast_sip_get_pjsip_endpoint(), NULL, PJSIP_H_ALLOW, NULL, 1, &str_PUBLISH);
@@ -4445,7 +5301,7 @@ static int load_module(void)
 	if (ast_sip_register_service(&pubsub_module)) {
 		ast_log(LOG_ERROR, "Could not register pubsub service\n");
 		ast_sched_context_destroy(sched);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	ast_sorcery_apply_config(sorcery, "res_pjsip_pubsub");
@@ -4455,7 +5311,7 @@ static int load_module(void)
 		ast_log(LOG_ERROR, "Could not register subscription persistence object support\n");
 		ast_sip_unregister_service(&pubsub_module);
 		ast_sched_context_destroy(sched);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_sorcery_object_field_register(sorcery, "subscription_persistence", "packet", "", OPT_CHAR_ARRAY_T, 0,
 		CHARFLDSET(struct subscription_persistence, packet));
@@ -4477,11 +5333,13 @@ static int load_module(void)
 		persistence_tag_str2struct, persistence_tag_struct2str, NULL, 0, 0);
 	ast_sorcery_object_field_register_custom(sorcery, "subscription_persistence", "expires", "",
 		persistence_expires_str2struct, persistence_expires_struct2str, NULL, 0, 0);
+	ast_sorcery_object_field_register(sorcery, "subscription_persistence", "contact_uri", "", OPT_CHAR_ARRAY_T, 0,
+		CHARFLDSET(struct subscription_persistence, contact_uri));
 
 	if (apply_list_configuration(sorcery)) {
 		ast_sip_unregister_service(&pubsub_module);
 		ast_sched_context_destroy(sched);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	ast_sorcery_apply_default(sorcery, "inbound-publication", "config", "pjsip.conf,criteria=type=inbound-publication");
@@ -4490,7 +5348,7 @@ static int load_module(void)
 		ast_log(LOG_ERROR, "Could not register subscription persistence object support\n");
 		ast_sip_unregister_service(&pubsub_module);
 		ast_sched_context_destroy(sched);
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	ast_sorcery_object_field_register(sorcery, "inbound-publication", "type", "", OPT_NOOP_T, 0, 0);
 	ast_sorcery_object_field_register_custom(sorcery, "inbound-publication", "endpoint", "",
@@ -4511,6 +5369,8 @@ static int load_module(void)
 	ast_manager_register_xml("PJSIPShowResourceLists", EVENT_FLAG_SYSTEM,
 			ami_show_resource_lists);
 
+	ast_cli_register_multiple(cli_commands, ARRAY_LEN(cli_commands));
+
 	AST_TEST_REGISTER(resource_tree);
 	AST_TEST_REGISTER(complex_resource_tree);
 	AST_TEST_REGISTER(bad_resource);
@@ -4524,6 +5384,16 @@ static int load_module(void)
 
 static int unload_module(void)
 {
+	AST_TEST_UNREGISTER(resource_tree);
+	AST_TEST_UNREGISTER(complex_resource_tree);
+	AST_TEST_UNREGISTER(bad_resource);
+	AST_TEST_UNREGISTER(bad_branch);
+	AST_TEST_UNREGISTER(duplicate_resource);
+	AST_TEST_UNREGISTER(loop);
+	AST_TEST_UNREGISTER(bad_event);
+
+	ast_cli_unregister_multiple(cli_commands, ARRAY_LEN(cli_commands));
+
 	ast_manager_unregister(AMI_SHOW_SUBSCRIPTIONS_OUTBOUND);
 	ast_manager_unregister(AMI_SHOW_SUBSCRIPTIONS_INBOUND);
 	ast_manager_unregister("PJSIPShowResourceLists");
@@ -4533,14 +5403,6 @@ static int unload_module(void)
 		ast_sched_context_destroy(sched);
 	}
 
-	AST_TEST_UNREGISTER(resource_tree);
-	AST_TEST_UNREGISTER(complex_resource_tree);
-	AST_TEST_UNREGISTER(bad_resource);
-	AST_TEST_UNREGISTER(bad_branch);
-	AST_TEST_UNREGISTER(duplicate_resource);
-	AST_TEST_UNREGISTER(loop);
-	AST_TEST_UNREGISTER(bad_event);
-
 	return 0;
 }
 
diff -urpN asterisk-13.9.1/res/res_pjsip_refer.c asterisk-13.17.0/res/res_pjsip_refer.c
--- asterisk-13.9.1/res/res_pjsip_refer.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_refer.c	2017-07-12 13:12:08.000000000 +0200
@@ -61,6 +61,8 @@ struct refer_progress {
 	char *transferee;
 	/*! \brief Non-zero if the 100 notify has been sent */
 	int sent_100;
+	/*! \brief Whether to notifies all the progress details on blind transfer */
+	unsigned int refer_blind_progress;
 };
 
 /*! \brief REFER Progress notification structure */
@@ -372,6 +374,8 @@ static int refer_progress_alloc(struct a
 	ast_debug(3, "Created progress monitor '%p' for transfer occurring from channel '%s' and endpoint '%s'\n",
 		progress, ast_channel_name(session->channel), ast_sorcery_object_get_id(session->endpoint));
 
+	(*progress)->refer_blind_progress = session->endpoint->refer_blind_progress;
+
 	(*progress)->framehook = -1;
 
 	/* To prevent a potential deadlock we need the dialog so we can lock/unlock */
@@ -539,6 +543,7 @@ static int refer_attended_task(void *dat
 		}
 	}
 
+	ast_sip_session_end_if_deferred(attended->transferer);
 	if (response != 200) {
 		if (!ast_sip_push_task(attended->transferer->serializer,
 			defer_termination_cancel, attended->transferer)) {
@@ -563,6 +568,8 @@ struct refer_blind {
 	pjsip_replaces_hdr *replaces;
 	/*! \brief Optional Refer-To header */
 	pjsip_sip_uri *refer_to;
+	/*! \brief Attended transfer flag */
+	unsigned int attended:1;
 };
 
 /*! \brief Blind transfer callback function */
@@ -573,11 +580,20 @@ static void refer_blind_callback(struct
 	pjsip_generic_string_hdr *referred_by;
 
 	static const pj_str_t str_referred_by = { "Referred-By", 11 };
+	static const pj_str_t str_referred_by_s = { "b", 1 };
 
 	pbx_builtin_setvar_helper(chan, "SIPTRANSFER", "yes");
 
-	/* If progress monitoring is being done attach a frame hook so we can monitor it */
-	if (refer->progress) {
+	if (refer->progress && !refer->attended && !refer->progress->refer_blind_progress) {
+		/* If blind transfer and endpoint doesn't want to receive all the progress details */
+		struct refer_progress_notification *notification = refer_progress_notification_alloc(refer->progress, 200,
+			PJSIP_EVSUB_STATE_TERMINATED);
+
+		if (notification) {
+			refer_progress_notify(notification);
+		}
+	} else if (refer->progress) {
+		/* If attended transfer and progress monitoring is being done attach a frame hook so we can monitor it */
 		struct ast_framehook_interface hook = {
 			.version = AST_FRAMEHOOK_INTERFACE_VERSION,
 			.event_cb = refer_progress_framehook,
@@ -607,7 +623,10 @@ static void refer_blind_callback(struct
 		ao2_ref(refer->progress, +1);
 
 		/* If we can't attach a frame hook for whatever reason send a notification of success immediately */
-		if ((refer->progress->framehook = ast_framehook_attach(chan, &hook)) < 0) {
+		ast_channel_lock(chan);
+		refer->progress->framehook = ast_framehook_attach(chan, &hook);
+		ast_channel_unlock(chan);
+		if (refer->progress->framehook < 0) {
 			struct refer_progress_notification *notification = refer_progress_notification_alloc(refer->progress, 200,
 				PJSIP_EVSUB_STATE_TERMINATED);
 
@@ -638,7 +657,9 @@ static void refer_blind_callback(struct
 				refer_progress_notify(notification);
 			}
 
+			ast_channel_lock(chan);
 			ast_framehook_detach(chan, refer->progress->framehook);
+			ast_channel_unlock(chan);
 
 			ao2_cleanup(refer->progress);
 		}
@@ -646,8 +667,8 @@ static void refer_blind_callback(struct
 
 	pbx_builtin_setvar_helper(chan, "SIPREFERRINGCONTEXT", S_OR(refer->context, NULL));
 
-	referred_by = pjsip_msg_find_hdr_by_name(refer->rdata->msg_info.msg,
-		&str_referred_by, NULL);
+	referred_by = pjsip_msg_find_hdr_by_names(refer->rdata->msg_info.msg,
+		&str_referred_by, &str_referred_by_s, NULL);
 	if (referred_by) {
 		size_t uri_size = pj_strlen(&referred_by->hvalue) + 1;
 		char *uri = ast_alloca(uri_size);
@@ -752,6 +773,7 @@ static int refer_incoming_attended_reque
 
 		/* Push it to the other session, which will have both channels with minimal locking */
 		if (ast_sip_push_task(other_session->serializer, refer_attended_task, attended)) {
+			ast_sip_session_end_if_deferred(session);
 			ast_sip_session_defer_termination_cancel(session);
 			ao2_cleanup(attended);
 			return 500;
@@ -779,6 +801,7 @@ static int refer_incoming_attended_reque
 		refer.rdata = rdata;
 		refer.replaces = replaces;
 		refer.refer_to = target_uri;
+		refer.attended = 1;
 
 		if (ast_sip_session_defer_termination(session)) {
 			ast_log(LOG_ERROR, "Received REFER for remote session on channel '%s' from endpoint '%s' but could not defer termination, rejecting\n",
@@ -789,9 +812,12 @@ static int refer_incoming_attended_reque
 
 		response = xfer_response_code2sip(ast_bridge_transfer_blind(1, session->channel,
 			"external_replaces", context, refer_blind_callback, &refer));
+
+		ast_sip_session_end_if_deferred(session);
 		if (response != 200) {
 			ast_sip_session_defer_termination_cancel(session);
 		}
+
 		return response;
 	}
 }
@@ -809,6 +835,20 @@ static int refer_incoming_blind_request(
 
 	/* Using the user portion of the target URI see if it exists as a valid extension in their context */
 	ast_copy_pj_str(exten, &target->user, sizeof(exten));
+
+	/*
+	 * We may want to match in the dialplan without any user
+	 * options getting in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(exten);
+
+	/* Uri without exten */
+	if (ast_strlen_zero(exten)) {
+		ast_copy_string(exten, "s", sizeof(exten));
+		ast_debug(3, "Channel '%s' from endpoint '%s' attempted blind transfer to a target without extension. Target was set to 's@%s'\n",
+			ast_channel_name(session->channel), ast_sorcery_object_get_id(session->endpoint), context);
+	}
+
 	if (!ast_exists_extension(NULL, context, exten, 1, NULL)) {
 		ast_log(LOG_ERROR, "Channel '%s' from endpoint '%s' attempted blind transfer to '%s@%s' but target does not exist\n",
 			ast_channel_name(session->channel), ast_sorcery_object_get_id(session->endpoint), exten, context);
@@ -819,6 +859,7 @@ static int refer_incoming_blind_request(
 	refer.progress = progress;
 	refer.rdata = rdata;
 	refer.refer_to = target;
+	refer.attended = 0;
 
 	if (ast_sip_session_defer_termination(session)) {
 		ast_log(LOG_ERROR, "Channel '%s' from endpoint '%s' attempted blind transfer but could not defer termination, rejecting\n",
@@ -829,9 +870,12 @@ static int refer_incoming_blind_request(
 
 	response = xfer_response_code2sip(ast_bridge_transfer_blind(1, session->channel,
 		exten, context, refer_blind_callback, &refer));
+
+	ast_sip_session_end_if_deferred(session);
 	if (response != 200) {
 		ast_sip_session_defer_termination_cancel(session);
 	}
+
 	return response;
 }
 
@@ -969,7 +1013,8 @@ inv_replace_failed:
 		session->defer_terminate = 1;
 		ast_hangup(session->channel);
 
-		if (pjsip_inv_end_session(session->inv_session, response, NULL, &packet) == PJ_SUCCESS) {
+		if (pjsip_inv_end_session(session->inv_session, response, NULL, &packet) == PJ_SUCCESS
+			&& packet) {
 			ast_sip_session_send_response(session, packet);
 		}
 	} else {
@@ -993,6 +1038,7 @@ static int refer_incoming_refer_request(
 	int response;
 
 	static const pj_str_t str_refer_to = { "Refer-To", 8 };
+	static const pj_str_t str_refer_to_s = { "r", 1 };
 	static const pj_str_t str_replaces = { "Replaces", 8 };
 
 	if (!session->channel) {
@@ -1011,7 +1057,7 @@ static int refer_incoming_refer_request(
 	}
 
 	/* A Refer-To header is required */
-	refer_to = pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &str_refer_to, NULL);
+	refer_to = pjsip_msg_find_hdr_by_names(rdata->msg_info.msg, &str_refer_to, &str_refer_to_s, NULL);
 	if (!refer_to) {
 		pjsip_dlg_respond(session->inv_session->dlg, rdata, 400, NULL, NULL, NULL);
 		ast_debug(3, "Received a REFER without Refer-To on channel '%s' from endpoint '%s'\n",
diff -urpN asterisk-13.9.1/res/res_pjsip_registrar.c asterisk-13.17.0/res/res_pjsip_registrar.c
--- asterisk-13.9.1/res/res_pjsip_registrar.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_registrar.c	2017-07-12 13:12:08.000000000 +0200
@@ -30,6 +30,7 @@
 
 #include "asterisk/res_pjsip.h"
 #include "asterisk/module.h"
+#include "asterisk/paths.h"
 #include "asterisk/test.h"
 #include "asterisk/taskprocessor.h"
 #include "asterisk/manager.h"
@@ -45,11 +46,32 @@
 		<syntax />
 		<description>
 			<para>
-			In response <literal>InboundRegistrationDetail</literal> events showing configuration and status
-			information are raised for each inbound registration object.  As well as <literal>AuthDetail</literal>
-			events for each associated auth object.  Once all events are completed an
-			<literal>InboundRegistrationDetailComplete</literal> is issued.
-                        </para>
+			In response, <literal>InboundRegistrationDetail</literal> events showing configuration
+			and status information are raised for all contacts, static or dynamic.  Once all events
+			are completed an <literal>InboundRegistrationDetailComplete</literal> is issued.
+			</para>
+			<warning><para>
+				This command just dumps all coonfigured AORs with contacts, even if the contact
+				is a permanent one.  To really get just inbound registrations, use
+				<literal>PJSIPShowRegistrationInboundContactStatuses</literal>.
+			</para>
+			</warning>
+		</description>
+		<see-also>
+			<ref type="manager" module="res_pjsip_registrar">PJSIPShowRegistrationInboundContactStatuses</ref>
+		</see-also>
+	</manager>
+	<manager name="PJSIPShowRegistrationInboundContactStatuses" language="en_US">
+		<synopsis>
+			Lists ContactStatuses for PJSIP inbound registrations.
+		</synopsis>
+		<syntax />
+		<description>
+			<para>
+			In response, <literal>ContactStatusDetail</literal> events showing status information
+			are raised for each inbound registration (dynamic contact) object.  Once all events
+			are completed a <literal>ContactStatusDetailComplete</literal> event is issued.
+			</para>
 		</description>
 	</manager>
  ***/
@@ -230,155 +252,11 @@ static void registrar_add_date_header(pj
 	ast_sip_add_header(tdata, "Date", date);
 }
 
-#define SERIALIZER_BUCKETS 59
-
-static struct ao2_container *serializers;
-
-/*! \brief Serializer with associated aor key */
-struct serializer {
-	/* Serializer to distribute tasks to */
-	struct ast_taskprocessor *serializer;
-	/* The name of the aor to associate with the serializer */
-	char aor_name[0];
-};
-
-static void serializer_destroy(void *obj)
-{
-	struct serializer *ser = obj;
-
-	ast_taskprocessor_unreference(ser->serializer);
-}
-
-static struct serializer *serializer_create(const char *aor_name)
-{
-	char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
-	size_t size = strlen(aor_name) + 1;
-	struct serializer *ser = ao2_alloc(
-		sizeof(*ser) + size, serializer_destroy);
-
-	if (!ser) {
-		return NULL;
-	}
-
-	/* Create name with seq number appended. */
-	ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/aor/%s",
-		aor_name);
-
-	if (!(ser->serializer = ast_sip_create_serializer_named(tps_name))) {
-		ao2_ref(ser, -1);
-		return NULL;
-	}
-
-	strcpy(ser->aor_name, aor_name);
-	return ser;
-}
-
-static struct serializer *serializer_find_or_create(const char *aor_name)
-{
-	struct serializer *ser = ao2_find(serializers, aor_name, OBJ_SEARCH_KEY);
-
-	if (ser) {
-		return ser;
-	}
-
-	if (!(ser = serializer_create(aor_name))) {
-		return NULL;
-	}
-
-	ao2_link(serializers, ser);
-	return ser;
-}
-
-static int serializer_hash(const void *obj, const int flags)
-{
-	const struct serializer *object;
-	const char *key;
-
-	switch (flags & OBJ_SEARCH_MASK) {
-	case OBJ_SEARCH_KEY:
-		key = obj;
-		return ast_str_hash(key);
-	case OBJ_SEARCH_OBJECT:
-		object = obj;
-		return ast_str_hash(object->aor_name);
-	default:
-		/* Hash can only work on something with a full key. */
-		ast_assert(0);
-		return 0;
-	}
-}
-
-static int serializer_cmp(void *obj_left, void *obj_right, int flags)
-{
-	const struct serializer *object_left = obj_left;
-	const struct serializer *object_right = obj_right;
-	const char *right_key = obj_right;
-	int cmp;
-
-	switch (flags & OBJ_SEARCH_MASK) {
-	case OBJ_SEARCH_OBJECT:
-		right_key = object_right->aor_name;
-		/* Fall through */
-	case OBJ_SEARCH_KEY:
-		cmp = strcmp(object_left->aor_name, right_key);
-		break;
-	case OBJ_SEARCH_PARTIAL_KEY:
-		/*
-		 * We could also use a partial key struct containing a length
-		 * so strlen() does not get called for every comparison instead.
-		 */
-		cmp = strncmp(object_left->aor_name, right_key, strlen(right_key));
-		break;
-	default:
-		cmp = 0;
-		break;
-	}
-
-	return cmp ? 0 : CMP_MATCH;
-}
-
-struct rx_task_data {
-	pjsip_rx_data *rdata;
-	struct ast_sip_endpoint *endpoint;
-	struct ast_sip_aor *aor;
-};
-
-static void rx_task_data_destroy(void *obj)
-{
-	struct rx_task_data *task_data = obj;
-
-	pjsip_rx_data_free_cloned(task_data->rdata);
-	ao2_cleanup(task_data->endpoint);
-	ao2_cleanup(task_data->aor);
-}
-
-static struct rx_task_data *rx_task_data_create(pjsip_rx_data *rdata,
-						struct ast_sip_endpoint *endpoint,
-						struct ast_sip_aor *aor)
-{
-	struct rx_task_data *task_data = ao2_alloc(
-		sizeof(*task_data), rx_task_data_destroy);
-
-	if (!task_data) {
-		return NULL;
-	}
-
-	pjsip_rx_data_clone(rdata, 0, &task_data->rdata);
-
-	task_data->endpoint = endpoint;
-	ao2_ref(task_data->endpoint, +1);
-
-	task_data->aor = aor;
-	ao2_ref(task_data->aor, +1);
-
-	return task_data;
-}
-
 static const pj_str_t path_hdr_name = { "Path", 4 };
 
-static int build_path_data(struct rx_task_data *task_data, struct ast_str **path_str)
+static int build_path_data(pjsip_rx_data *rdata, struct ast_str **path_str)
 {
-	pjsip_generic_string_hdr *path_hdr = pjsip_msg_find_hdr_by_name(task_data->rdata->msg_info.msg, &path_hdr_name, NULL);
+	pjsip_generic_string_hdr *path_hdr = pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &path_hdr_name, NULL);
 
 	if (!path_hdr) {
 		return 0;
@@ -391,24 +269,24 @@ static int build_path_data(struct rx_tas
 
 	ast_str_set(path_str, 0, "%.*s", (int)path_hdr->hvalue.slen, path_hdr->hvalue.ptr);
 
-	while ((path_hdr = (pjsip_generic_string_hdr *) pjsip_msg_find_hdr_by_name(task_data->rdata->msg_info.msg, &path_hdr_name, path_hdr->next))) {
+	while ((path_hdr = (pjsip_generic_string_hdr *) pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &path_hdr_name, path_hdr->next))) {
 		ast_str_append(path_str, 0, ",%.*s", (int)path_hdr->hvalue.slen, path_hdr->hvalue.ptr);
 	}
 
 	return 0;
 }
 
-static int registrar_validate_path(struct rx_task_data *task_data, struct ast_str **path_str)
+static int registrar_validate_path(pjsip_rx_data *rdata, struct ast_sip_aor *aor, struct ast_str **path_str)
 {
 	const pj_str_t path_supported_name = { "path", 4 };
 	pjsip_supported_hdr *supported_hdr;
 	int i;
 
-	if (!task_data->aor->support_path) {
+	if (!aor->support_path) {
 		return 0;
 	}
 
-	if (build_path_data(task_data, path_str)) {
+	if (build_path_data(rdata, path_str)) {
 		return -1;
 	}
 
@@ -416,7 +294,7 @@ static int registrar_validate_path(struc
 		return 0;
 	}
 
-	supported_hdr = pjsip_msg_find_hdr(task_data->rdata->msg_info.msg, PJSIP_H_SUPPORTED, NULL);
+	supported_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_SUPPORTED, NULL);
 	if (!supported_hdr) {
 		return -1;
 	}
@@ -432,8 +310,11 @@ static int registrar_validate_path(struc
 	return -1;
 }
 
-static int rx_task_core(struct rx_task_data *task_data, struct ao2_container *contacts,
-	const char *aor_name)
+static int register_aor_core(pjsip_rx_data *rdata,
+	struct ast_sip_endpoint *endpoint,
+	struct ast_sip_aor *aor,
+	const char *aor_name,
+	struct ao2_container *contacts)
 {
 	static const pj_str_t USER_AGENT = { "User-Agent", 10 };
 
@@ -446,50 +327,78 @@ static int rx_task_core(struct rx_task_d
 	char *user_agent = NULL;
 	pjsip_user_agent_hdr *user_agent_hdr;
 	pjsip_expires_hdr *expires_hdr;
+	pjsip_via_hdr *via_hdr;
+	pjsip_via_hdr *via_hdr_last;
+	char *via_addr = NULL;
+	int via_port = 0;
+	pjsip_cid_hdr *call_id_hdr;
+	char *call_id = NULL;
+	size_t alloc_size;
 
 	/* So we don't count static contacts against max_contacts we prune them out from the container */
 	ao2_callback(contacts, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, registrar_prune_static, NULL);
 
-	if (registrar_validate_contacts(task_data->rdata, contacts, task_data->aor, &added, &updated, &deleted)) {
+	if (registrar_validate_contacts(rdata, contacts, aor, &added, &updated, &deleted)) {
 		/* The provided Contact headers do not conform to the specification */
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), task_data->rdata, 400, NULL, NULL, NULL);
-		ast_sip_report_failed_acl(task_data->endpoint, task_data->rdata, "registrar_invalid_contacts_provided");
+		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 400, NULL, NULL, NULL);
+		ast_sip_report_failed_acl(endpoint, rdata, "registrar_invalid_contacts_provided");
 		ast_log(LOG_WARNING, "Failed to validate contacts in REGISTER request from '%s'\n",
-				ast_sorcery_object_get_id(task_data->endpoint));
+				ast_sorcery_object_get_id(endpoint));
 		return PJ_TRUE;
 	}
 
-	if (registrar_validate_path(task_data, &path_str)) {
+	if (registrar_validate_path(rdata, aor, &path_str)) {
 		/* Ensure that intervening proxies did not make invalid modifications to the request */
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), task_data->rdata, 420, NULL, NULL, NULL);
+		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 420, NULL, NULL, NULL);
 		ast_log(LOG_WARNING, "Invalid modifications made to REGISTER request from '%s' by intervening proxy\n",
-				ast_sorcery_object_get_id(task_data->endpoint));
+				ast_sorcery_object_get_id(endpoint));
 		return PJ_TRUE;
 	}
 
-	if ((MAX(added - deleted, 0) + (!task_data->aor->remove_existing ? ao2_container_count(contacts) : 0)) > task_data->aor->max_contacts) {
+	if ((MAX(added - deleted, 0) + (!aor->remove_existing ? ao2_container_count(contacts) : 0)) > aor->max_contacts) {
 		/* Enforce the maximum number of contacts */
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), task_data->rdata, 403, NULL, NULL, NULL);
-		ast_sip_report_failed_acl(task_data->endpoint, task_data->rdata, "registrar_attempt_exceeds_maximum_configured_contacts");
+		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
+		ast_sip_report_failed_acl(endpoint, rdata, "registrar_attempt_exceeds_maximum_configured_contacts");
 		ast_log(LOG_WARNING, "Registration attempt from endpoint '%s' to AOR '%s' will exceed max contacts of %u\n",
-				ast_sorcery_object_get_id(task_data->endpoint), ast_sorcery_object_get_id(task_data->aor), task_data->aor->max_contacts);
+				ast_sorcery_object_get_id(endpoint), aor_name, aor->max_contacts);
 		return PJ_TRUE;
 	}
 
 	if (!(details.pool = pjsip_endpt_create_pool(ast_sip_get_pjsip_endpoint(), "Contact Comparison", 256, 256))) {
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), task_data->rdata, 500, NULL, NULL, NULL);
+		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);
 		return PJ_TRUE;
 	}
 
-	user_agent_hdr = pjsip_msg_find_hdr_by_name(task_data->rdata->msg_info.msg, &USER_AGENT, NULL);
+	user_agent_hdr = pjsip_msg_find_hdr_by_name(rdata->msg_info.msg, &USER_AGENT, NULL);
 	if (user_agent_hdr) {
-		size_t alloc_size = pj_strlen(&user_agent_hdr->hvalue) + 1;
+		alloc_size = pj_strlen(&user_agent_hdr->hvalue) + 1;
 		user_agent = ast_alloca(alloc_size);
 		ast_copy_pj_str(user_agent, &user_agent_hdr->hvalue, alloc_size);
 	}
 
+	/* Find the first Via header */
+	via_hdr = via_hdr_last = (pjsip_via_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_VIA, NULL);
+	if (via_hdr) {
+		/* Find the last Via header */
+		while ( (via_hdr = (pjsip_via_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,
+				PJSIP_H_VIA, via_hdr->next)) != NULL) {
+			via_hdr_last = via_hdr;
+		}
+		alloc_size = pj_strlen(&via_hdr_last->sent_by.host) + 1;
+		via_addr = ast_alloca(alloc_size);
+		ast_copy_pj_str(via_addr, &via_hdr_last->sent_by.host, alloc_size);
+		via_port=via_hdr_last->sent_by.port;
+	}
+
+	call_id_hdr = (pjsip_cid_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CALL_ID, NULL);
+	if (call_id_hdr) {
+		alloc_size = pj_strlen(&call_id_hdr->id) + 1;
+		call_id = ast_alloca(alloc_size);
+		ast_copy_pj_str(call_id, &call_id_hdr->id, alloc_size);
+	}
+
 	/* Iterate each provided Contact header and add, update, or delete */
-	while ((contact_hdr = pjsip_msg_find_hdr(task_data->rdata->msg_info.msg, PJSIP_H_CONTACT, contact_hdr ? contact_hdr->next : NULL))) {
+	while ((contact_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, contact_hdr ? contact_hdr->next : NULL))) {
 		int expiration;
 		char contact_uri[pjsip_max_url_size];
 		RAII_VAR(struct ast_sip_contact *, contact, NULL, ao2_cleanup);
@@ -505,7 +414,7 @@ static int rx_task_core(struct rx_task_d
 			continue;
 		}
 
-		expiration = registrar_get_expiration(task_data->aor, contact_hdr, task_data->rdata);
+		expiration = registrar_get_expiration(aor, contact_hdr, rdata);
 		details.uri = pjsip_uri_get_uri(contact_hdr->uri);
 		pjsip_uri_print(PJSIP_URI_IN_CONTACT_HDR, details.uri, contact_uri, sizeof(contact_uri));
 
@@ -517,9 +426,9 @@ static int rx_task_core(struct rx_task_d
 				continue;
 			}
 
-			if (ast_sip_location_add_contact_nolock(task_data->aor, contact_uri, ast_tvadd(ast_tvnow(),
+			if (ast_sip_location_add_contact_nolock(aor, contact_uri, ast_tvadd(ast_tvnow(),
 				ast_samp2tv(expiration, 1)), path_str ? ast_str_buffer(path_str) : NULL,
-					user_agent, task_data->endpoint)) {
+					user_agent, via_addr, via_port, call_id, endpoint)) {
 				ast_log(LOG_ERROR, "Unable to bind contact '%s' to AOR '%s'\n",
 						contact_uri, aor_name);
 				continue;
@@ -547,14 +456,17 @@ static int rx_task_core(struct rx_task_d
 			}
 
 			contact_update->expiration_time = ast_tvadd(ast_tvnow(), ast_samp2tv(expiration, 1));
-			contact_update->qualify_frequency = task_data->aor->qualify_frequency;
-			contact_update->authenticate_qualify = task_data->aor->authenticate_qualify;
+			contact_update->qualify_frequency = aor->qualify_frequency;
+			contact_update->authenticate_qualify = aor->authenticate_qualify;
 			if (path_str) {
 				ast_string_field_set(contact_update, path, ast_str_buffer(path_str));
 			}
 			if (user_agent) {
 				ast_string_field_set(contact_update, user_agent, user_agent);
 			}
+			if (!ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {
+				ast_string_field_set(contact_update, reg_server, ast_config_AST_SYSTEM_NAME);
+			}
 
 			if (ast_sip_location_update_contact(contact_update)) {
 				ast_log(LOG_ERROR, "Failed to update contact '%s' expiration time to %d seconds.\n",
@@ -593,16 +505,16 @@ static int rx_task_core(struct rx_task_d
 	/* If the AOR is configured to remove any existing contacts that have not been updated/added as a result of this REGISTER
 	 * do so
 	 */
-	if (task_data->aor->remove_existing) {
+	if (aor->remove_existing) {
 		ao2_callback(contacts, OBJ_NODATA | OBJ_MULTIPLE, registrar_delete_contact, NULL);
 	}
 
 	/* Re-retrieve contacts.  Caller will clean up the original container. */
-	contacts = ast_sip_location_retrieve_aor_contacts_nolock(task_data->aor);
+	contacts = ast_sip_location_retrieve_aor_contacts_nolock(aor);
 	response_contact = ao2_callback(contacts, 0, NULL, NULL);
 
 	/* Send a response containing all of the contacts (including static) that are present on this AOR */
-	if (ast_sip_create_response(task_data->rdata, 200, response_contact, &tdata) != PJ_SUCCESS) {
+	if (ast_sip_create_response(rdata, 200, response_contact, &tdata) != PJ_SUCCESS) {
 		ao2_cleanup(response_contact);
 		ao2_cleanup(contacts);
 		return PJ_TRUE;
@@ -615,112 +527,167 @@ static int rx_task_core(struct rx_task_d
 	ao2_callback(contacts, 0, registrar_add_contact, tdata);
 	ao2_cleanup(contacts);
 
-	if ((expires_hdr = pjsip_msg_find_hdr(task_data->rdata->msg_info.msg, PJSIP_H_EXPIRES, NULL))) {
-		expires_hdr = pjsip_expires_hdr_create(tdata->pool, registrar_get_expiration(task_data->aor, NULL, task_data->rdata));
+	if ((expires_hdr = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_EXPIRES, NULL))) {
+		expires_hdr = pjsip_expires_hdr_create(tdata->pool, registrar_get_expiration(aor, NULL, rdata));
 		pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)expires_hdr);
 	}
 
-	ast_sip_send_stateful_response(task_data->rdata, tdata, task_data->endpoint);
+	ast_sip_send_stateful_response(rdata, tdata, endpoint);
 
 	return PJ_TRUE;
 }
 
-static int rx_task(void *data)
+static int register_aor(pjsip_rx_data *rdata,
+	struct ast_sip_endpoint *endpoint,
+	struct ast_sip_aor *aor,
+	const char *aor_name)
 {
 	int res;
-	struct rx_task_data *task_data = data;
 	struct ao2_container *contacts = NULL;
 	struct ast_named_lock *lock;
-	const char *aor_name = ast_sorcery_object_get_id(task_data->aor);
 
-	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_RWLOCK, "aor", aor_name);
+	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_MUTEX, "aor", aor_name);
 	if (!lock) {
-		ao2_cleanup(task_data);
 		return PJ_TRUE;
 	}
 
-	ao2_wrlock(lock);
-	contacts = ast_sip_location_retrieve_aor_contacts_nolock(task_data->aor);
+	ao2_lock(lock);
+	contacts = ast_sip_location_retrieve_aor_contacts_nolock(aor);
 	if (!contacts) {
 		ao2_unlock(lock);
 		ast_named_lock_put(lock);
-		ao2_cleanup(task_data);
 		return PJ_TRUE;
 	}
 
-	res = rx_task_core(task_data, contacts, aor_name);
+	res = register_aor_core(rdata, endpoint, aor, aor_name, contacts);
 	ao2_cleanup(contacts);
 	ao2_unlock(lock);
 	ast_named_lock_put(lock);
-	ao2_cleanup(task_data);
 
 	return res;
 }
 
-static pj_bool_t registrar_on_rx_request(struct pjsip_rx_data *rdata)
+static int match_aor(const char *aor_name, const char *id)
 {
-	RAII_VAR(struct serializer *, ser, NULL, ao2_cleanup);
-	struct rx_task_data *task_data;
-
-	RAII_VAR(struct ast_sip_endpoint *, endpoint,
-		 ast_pjsip_rdata_get_endpoint(rdata), ao2_cleanup);
-	RAII_VAR(struct ast_sip_aor *, aor, NULL, ao2_cleanup);
-	pjsip_sip_uri *uri;
-	char *domain_name;
-	char *configured_aors, *aor_name;
-	RAII_VAR(struct ast_str *, id, NULL, ast_free);
-
-	if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_register_method) || !endpoint) {
-		return PJ_FALSE;
+	if (ast_strlen_zero(aor_name)) {
+		return 0;
 	}
 
-	if (ast_strlen_zero(endpoint->aors)) {
-		/* Short circuit early if the endpoint has no AORs configured on it, which means no registration possible */
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
-		ast_sip_report_failed_acl(endpoint, rdata, "registrar_attempt_without_configured_aors");
-		ast_log(LOG_WARNING, "Endpoint '%s' has no configured AORs\n", ast_sorcery_object_get_id(endpoint));
-		return PJ_TRUE;
+	if (!strcmp(aor_name, id)) {
+		ast_debug(3, "Matched id '%s' to aor '%s'\n", id, aor_name);
+		return 1;
 	}
 
-	if (!PJSIP_URI_SCHEME_IS_SIP(rdata->msg_info.to->uri) && !PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.to->uri)) {
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 416, NULL, NULL, NULL);
-		ast_sip_report_failed_acl(endpoint, rdata, "registrar_invalid_uri_in_to_received");
-		ast_log(LOG_WARNING, "Endpoint '%s' attempted to register to an AOR with a non-SIP URI\n", ast_sorcery_object_get_id(endpoint));
-		return PJ_TRUE;
-	}
+	return 0;
+}
 
-	uri = pjsip_uri_get_uri(rdata->msg_info.to->uri);
-	domain_name = ast_alloca(uri->host.slen + 1);
-	ast_copy_pj_str(domain_name, &uri->host, uri->host.slen + 1);
+static char *find_aor_name(const char *username, const char *domain, const char *aors)
+{
+	char *configured_aors;
+	char *aors_buf;
+	char *aor_name;
+	char *id_domain;
+	struct ast_sip_domain_alias *alias;
 
-	configured_aors = ast_strdupa(endpoint->aors);
+	id_domain = ast_alloca(strlen(username) + strlen(domain) + 2);
+	sprintf(id_domain, "%s@%s", username, domain);
 
-	/* Iterate the configured AORs to see if the user or the user+domain match */
-	while ((aor_name = ast_strip(strsep(&configured_aors, ",")))) {
-		struct ast_sip_domain_alias *alias = NULL;
+	aors_buf = ast_strdupa(aors);
 
-		if (ast_strlen_zero(aor_name)) {
-			continue;
+	/* Look for exact match on username@domain */
+	configured_aors = aors_buf;
+	while ((aor_name = ast_strip(strsep(&configured_aors, ",")))) {
+		if (match_aor(aor_name, id_domain)) {
+			return ast_strdup(aor_name);
 		}
+	}
 
-		if (!pj_strcmp2(&uri->user, aor_name)) {
-			break;
+	/* If there's a domain alias, look for exact match on username@domain_alias */
+	alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain);
+	if (alias) {
+		char *id_domain_alias = ast_alloca(strlen(username) + strlen(alias->domain) + 2);
+
+		sprintf(id_domain, "%s@%s", username, alias->domain);
+		ao2_cleanup(alias);
+
+		configured_aors = strcpy(aors_buf, aors);/* Safe */
+		while ((aor_name = ast_strip(strsep(&configured_aors, ",")))) {
+			if (match_aor(aor_name, id_domain_alias)) {
+				return ast_strdup(aor_name);
+			}
 		}
+	}
 
-		if (!id && !(id = ast_str_create(uri->user.slen + uri->host.slen + 2))) {
-			return PJ_TRUE;
+	if (ast_strlen_zero(username)) {
+		/* No username, no match */
+		return NULL;
+	}
+
+	/* Look for exact match on username only */
+	configured_aors = strcpy(aors_buf, aors);/* Safe */
+	while ((aor_name = ast_strip(strsep(&configured_aors, ",")))) {
+		if (match_aor(aor_name, username)) {
+			return ast_strdup(aor_name);
 		}
+	}
 
-		ast_str_set(&id, 0, "%.*s@", (int)uri->user.slen, uri->user.ptr);
-		if ((alias = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "domain_alias", domain_name))) {
-			ast_str_append(&id, 0, "%s", alias->domain);
-			ao2_cleanup(alias);
-		} else {
-			ast_str_append(&id, 0, "%s", domain_name);
+	return NULL;
+}
+
+static struct ast_sip_aor *find_registrar_aor(struct pjsip_rx_data *rdata, struct ast_sip_endpoint *endpoint)
+{
+	struct ast_sip_aor *aor = NULL;
+	char *aor_name = NULL;
+	char *domain_name;
+	char *username = NULL;
+	int i;
+
+	for (i = 0; i < AST_VECTOR_SIZE(&endpoint->ident_method_order); ++i) {
+		pjsip_sip_uri *uri;
+		pjsip_authorization_hdr *header = NULL;
+
+		switch (AST_VECTOR_GET(&endpoint->ident_method_order, i)) {
+		case AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME:
+			uri = pjsip_uri_get_uri(rdata->msg_info.to->uri);
+
+			domain_name = ast_alloca(uri->host.slen + 1);
+			ast_copy_pj_str(domain_name, &uri->host, uri->host.slen + 1);
+			username = ast_alloca(uri->user.slen + 1);
+			ast_copy_pj_str(username, &uri->user, uri->user.slen + 1);
+
+			/*
+			 * We may want to match without any user options getting
+			 * in the way.
+			 */
+			AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(username);
+
+			aor_name = find_aor_name(username, domain_name, endpoint->aors);
+			if (aor_name) {
+				ast_debug(3, "Matched aor '%s' by To username\n", aor_name);
+			}
+			break;
+		case AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME:
+			while ((header = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_AUTHORIZATION,
+				header ? header->next : NULL))) {
+				if (header && !pj_stricmp2(&header->scheme, "digest")) {
+					username = ast_alloca(header->credential.digest.username.slen + 1);
+					ast_copy_pj_str(username, &header->credential.digest.username, header->credential.digest.username.slen + 1);
+					domain_name = ast_alloca(header->credential.digest.realm.slen + 1);
+					ast_copy_pj_str(domain_name, &header->credential.digest.realm, header->credential.digest.realm.slen + 1);
+
+					aor_name = find_aor_name(username, domain_name, endpoint->aors);
+					if (aor_name) {
+						ast_debug(3, "Matched aor '%s' by Authentication username\n", aor_name);
+						break;
+					}
+				}
+			}
+			break;
+		default:
+			continue;
 		}
 
-		if (!strcmp(aor_name, ast_str_buffer(id))) {
-			ast_free(id);
+		if (aor_name) {
 			break;
 		}
 	}
@@ -729,42 +696,57 @@ static pj_bool_t registrar_on_rx_request
 		/* The provided AOR name was not found (be it within the configuration or sorcery itself) */
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 404, NULL, NULL, NULL);
 		ast_sip_report_req_no_support(endpoint, rdata, "registrar_requested_aor_not_found");
-		ast_log(LOG_WARNING, "AOR '%.*s' not found for endpoint '%s'\n", (int)uri->user.slen, uri->user.ptr, ast_sorcery_object_get_id(endpoint));
-		return PJ_TRUE;
+		ast_log(LOG_WARNING, "AOR '%s' not found for endpoint '%s'\n",
+			username ?: "", ast_sorcery_object_get_id(endpoint));
 	}
+	ast_free(aor_name);
+	return aor;
+}
 
-	if (!aor->max_contacts) {
-		/* Registration is not permitted for this AOR */
+static pj_bool_t registrar_on_rx_request(struct pjsip_rx_data *rdata)
+{
+	RAII_VAR(struct ast_sip_endpoint *, endpoint,
+		 ast_pjsip_rdata_get_endpoint(rdata), ao2_cleanup);
+	struct ast_sip_aor *aor;
+	const char *aor_name;
+
+	if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, &pjsip_register_method) || !endpoint) {
+		return PJ_FALSE;
+	}
+
+	if (ast_strlen_zero(endpoint->aors)) {
+		/* Short circuit early if the endpoint has no AORs configured on it, which means no registration possible */
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
-		ast_sip_report_req_no_support(endpoint, rdata, "registrar_attempt_without_registration_permitted");
-		ast_log(LOG_WARNING, "AOR '%s' has no configured max_contacts. Endpoint '%s' unable to register\n",
-				ast_sorcery_object_get_id(aor), ast_sorcery_object_get_id(endpoint));
+		ast_sip_report_failed_acl(endpoint, rdata, "registrar_attempt_without_configured_aors");
+		ast_log(LOG_WARNING, "Endpoint '%s' has no configured AORs\n", ast_sorcery_object_get_id(endpoint));
 		return PJ_TRUE;
 	}
 
-	if (!(ser = serializer_find_or_create(aor_name))) {
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
-		ast_sip_report_mem_limit(endpoint, rdata);
-		ast_log(LOG_WARNING, "Endpoint '%s' unable to register on AOR '%s' - could not get serializer\n",
-			ast_sorcery_object_get_id(endpoint), ast_sorcery_object_get_id(aor));
+	if (!PJSIP_URI_SCHEME_IS_SIP(rdata->msg_info.to->uri) && !PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.to->uri)) {
+		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 416, NULL, NULL, NULL);
+		ast_sip_report_failed_acl(endpoint, rdata, "registrar_invalid_uri_in_to_received");
+		ast_log(LOG_WARNING, "Endpoint '%s' attempted to register to an AOR with a non-SIP URI\n", ast_sorcery_object_get_id(endpoint));
 		return PJ_TRUE;
 	}
 
-	if (!(task_data = rx_task_data_create(rdata, endpoint, aor))) {
-		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
-		ast_sip_report_mem_limit(endpoint, rdata);
-		ast_log(LOG_WARNING, "Endpoint '%s' unable to register on AOR '%s' - could not create rx_task_data\n",
-			ast_sorcery_object_get_id(endpoint), ast_sorcery_object_get_id(aor));
+	aor = find_registrar_aor(rdata, endpoint);
+	if (!aor) {
+		/* We've already responded about not finding an AOR. */
 		return PJ_TRUE;
 	}
 
-	if (ast_sip_push_task(ser->serializer, rx_task, task_data)) {
+	aor_name = ast_sorcery_object_get_id(aor);
+
+	if (!aor->max_contacts) {
+		/* Registration is not permitted for this AOR */
 		pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);
-		ast_sip_report_mem_limit(endpoint, rdata);
-		ast_log(LOG_WARNING, "Endpoint '%s' unable to register on AOR '%s' - could not serialize task\n",
-			ast_sorcery_object_get_id(endpoint), ast_sorcery_object_get_id(aor));
-		ao2_ref(task_data, -1);
+		ast_sip_report_req_no_support(endpoint, rdata, "registrar_attempt_without_registration_permitted");
+		ast_log(LOG_WARNING, "AOR '%s' has no configured max_contacts. Endpoint '%s' unable to register\n",
+			aor_name, ast_sorcery_object_get_id(endpoint));
+	} else {
+		register_aor(rdata, endpoint, aor, aor_name);
 	}
+	ao2_ref(aor, -1);
 	return PJ_TRUE;
 }
 
@@ -832,6 +814,42 @@ static int ami_show_registrations(struct
 	return 0;
 }
 
+static int ami_show_registration_contact_statuses(struct mansession *s, const struct message *m)
+{
+	int count = 0;
+	struct ast_sip_ami ami = { .s = s, .m = m, .arg = NULL, .action_id = astman_get_header(m, "ActionID"), };
+	struct ao2_container *contacts = ast_sorcery_retrieve_by_fields(
+		ast_sip_get_sorcery(), "contact", AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
+	struct ao2_iterator i;
+	struct ast_sip_contact *contact;
+
+	astman_send_listack(s, m, "Following are ContactStatusEvents for each Inbound "
+			    "registration", "start");
+
+	if (contacts) {
+		i = ao2_iterator_init(contacts, 0);
+		while ((contact = ao2_iterator_next(&i))) {
+			struct ast_sip_contact_wrapper wrapper;
+
+			wrapper.aor_id = (char *)contact->aor;
+			wrapper.contact = contact;
+			wrapper.contact_id = (char *)ast_sorcery_object_get_id(contact);
+
+			ast_sip_format_contact_ami(&wrapper, &ami, 0);
+			count++;
+
+			ao2_ref(contact, -1);
+		}
+		ao2_iterator_destroy(&i);
+		ao2_ref(contacts, -1);
+	}
+
+	astman_send_list_complete_start(s, m, "ContactStatusDetailComplete", count);
+	astman_send_list_complete_end(s);
+	return 0;
+}
+
+#define AMI_SHOW_REGISTRATION_CONTACT_STATUSES "PJSIPShowRegistrationInboundContactStatuses"
 #define AMI_SHOW_REGISTRATIONS "PJSIPShowRegistrationsInbound"
 
 static pjsip_module registrar_module = {
@@ -853,11 +871,6 @@ static int load_module(void)
 
 	CHECK_PJSIP_MODULE_LOADED();
 
-	if (!(serializers = ao2_container_alloc(
-		      SERIALIZER_BUCKETS, serializer_hash, serializer_cmp))) {
-		return AST_MODULE_LOAD_DECLINE;
-	}
-
 	if (ast_sip_register_service(&registrar_module)) {
 		return AST_MODULE_LOAD_DECLINE;
 	}
@@ -869,6 +882,8 @@ static int load_module(void)
 
 	ast_manager_register_xml(AMI_SHOW_REGISTRATIONS, EVENT_FLAG_SYSTEM,
 				 ami_show_registrations);
+	ast_manager_register_xml(AMI_SHOW_REGISTRATION_CONTACT_STATUSES, EVENT_FLAG_SYSTEM,
+				 ami_show_registration_contact_statuses);
 
 	return AST_MODULE_LOAD_SUCCESS;
 }
@@ -876,9 +891,8 @@ static int load_module(void)
 static int unload_module(void)
 {
 	ast_manager_unregister(AMI_SHOW_REGISTRATIONS);
+	ast_manager_unregister(AMI_SHOW_REGISTRATION_CONTACT_STATUSES);
 	ast_sip_unregister_service(&registrar_module);
-
-	ao2_cleanup(serializers);
 	return 0;
 }
 
@@ -886,5 +900,5 @@ AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MO
 		.support_level = AST_MODULE_SUPPORT_CORE,
 		.load = load_module,
 		.unload = unload_module,
-		.load_pri = AST_MODPRI_APP_DEPEND,
+		.load_pri = AST_MODPRI_CHANNEL_DEPEND - 3,
 	       );
diff -urpN asterisk-13.9.1/res/res_pjsip_registrar_expire.c asterisk-13.17.0/res/res_pjsip_registrar_expire.c
--- asterisk-13.9.1/res/res_pjsip_registrar_expire.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_registrar_expire.c	2017-07-12 13:12:08.000000000 +0200
@@ -44,7 +44,7 @@ static int expire_contact(void *obj, voi
 	struct ast_sip_contact *contact = obj;
 	struct ast_named_lock *lock;
 
-	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_RWLOCK, "aor", contact->aor);
+	lock = ast_named_lock_get(AST_NAMED_LOCK_TYPE_MUTEX, "aor", contact->aor);
 	if (!lock) {
 		return 0;
 	}
@@ -53,7 +53,7 @@ static int expire_contact(void *obj, voi
 	 * We need to check the expiration again with the aor lock held
 	 * in case another thread is attempting to renew the contact.
 	 */
-	ao2_wrlock(lock);
+	ao2_lock(lock);
 	if (ast_tvdiff_ms(ast_tvnow(), contact->expiration_time) > 0) {
 		ast_sip_location_delete_contact(contact);
 	}
@@ -82,7 +82,7 @@ static void *check_expiration_thread(voi
 
 		ast_variables_destroy(var);
 		if (contacts) {
-			ast_debug(3, "Expiring %d contacts\n\n", ao2_container_count(contacts));
+			ast_debug(3, "Expiring %d contacts\n", ao2_container_count(contacts));
 			ao2_callback(contacts, OBJ_NODATA, expire_contact, NULL);
 			ao2_ref(contacts, -1);
 		}
diff -urpN asterisk-13.9.1/res/res_pjsip_sdp_rtp.c asterisk-13.17.0/res/res_pjsip_sdp_rtp.c
--- asterisk-13.9.1/res/res_pjsip_sdp_rtp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_sdp_rtp.c	2017-07-12 13:12:08.000000000 +0200
@@ -51,6 +51,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/acl.h"
 #include "asterisk/sdp_srtp.h"
 #include "asterisk/dsp.h"
+#include "asterisk/utils.h"
 
 #include "asterisk/res_pjsip.h"
 #include "asterisk/res_pjsip_session.h"
@@ -58,11 +59,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 /*! \brief Scheduler for RTCP purposes */
 static struct ast_sched_context *sched;
 
-/*! \brief Address for IPv4 RTP */
-static struct ast_sockaddr address_ipv4;
-
-/*! \brief Address for IPv6 RTP */
-static struct ast_sockaddr address_ipv6;
+/*! \brief Address for RTP */
+static struct ast_sockaddr address_rtp;
 
 static const char STR_AUDIO[] = "audio";
 static const int FD_AUDIO = 0;
@@ -165,22 +163,76 @@ static int rtp_check_timeout(const void
 	ast_log(LOG_NOTICE, "Disconnecting channel '%s' for lack of RTP activity in %d seconds\n",
 		ast_channel_name(chan), elapsed);
 
+	ast_channel_lock(chan);
+	ast_channel_hangupcause_set(chan, AST_CAUSE_REQUESTED_CHAN_UNAVAIL);
+	ast_channel_unlock(chan);
+
 	ast_softhangup(chan, AST_SOFTHANGUP_DEV);
 	ast_channel_unref(chan);
 
 	return 0;
 }
 
+/*!
+ * \brief Enable RTCP on an RTP session.
+ */
+static void enable_rtcp(struct ast_sip_session *session, struct ast_sip_session_media *session_media,
+	const struct pjmedia_sdp_media *remote_media)
+{
+	enum ast_rtp_instance_rtcp rtcp_type;
+
+	if (session->endpoint->rtcp_mux && session_media->remote_rtcp_mux) {
+		rtcp_type = AST_RTP_INSTANCE_RTCP_MUX;
+	} else {
+		rtcp_type = AST_RTP_INSTANCE_RTCP_STANDARD;
+	}
+
+	ast_rtp_instance_set_prop(session_media->rtp, AST_RTP_PROPERTY_RTCP, rtcp_type);
+}
+
 /*! \brief Internal function which creates an RTP instance */
-static int create_rtp(struct ast_sip_session *session, struct ast_sip_session_media *session_media, unsigned int ipv6)
+static int create_rtp(struct ast_sip_session *session, struct ast_sip_session_media *session_media)
 {
 	struct ast_rtp_engine_ice *ice;
 	struct ast_sockaddr temp_media_address;
-	struct ast_sockaddr *media_address =  ipv6 ? &address_ipv6 : &address_ipv4;
+	struct ast_sockaddr *media_address =  &address_rtp;
 
 	if (session->endpoint->media.bind_rtp_to_media_address && !ast_strlen_zero(session->endpoint->media.address)) {
-		ast_sockaddr_parse(&temp_media_address, session->endpoint->media.address, 0);
-		media_address = &temp_media_address;
+		if (ast_sockaddr_parse(&temp_media_address, session->endpoint->media.address, 0)) {
+			ast_debug(1, "Endpoint %s: Binding RTP media to %s\n",
+				ast_sorcery_object_get_id(session->endpoint),
+				session->endpoint->media.address);
+			media_address = &temp_media_address;
+		} else {
+			ast_debug(1, "Endpoint %s: RTP media address invalid: %s\n",
+				ast_sorcery_object_get_id(session->endpoint),
+				session->endpoint->media.address);
+		}
+	} else {
+		struct ast_sip_transport *transport;
+
+		transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport",
+			session->endpoint->transport);
+		if (transport) {
+			struct ast_sip_transport_state *trans_state;
+
+			trans_state = ast_sip_get_transport_state(ast_sorcery_object_get_id(transport));
+			if (trans_state) {
+				char hoststr[PJ_INET6_ADDRSTRLEN];
+
+				pj_sockaddr_print(&trans_state->host, hoststr, sizeof(hoststr), 0);
+				if (ast_sockaddr_parse(&temp_media_address, hoststr, 0)) {
+					ast_debug(1, "Transport %s bound to %s: Using it for RTP media.\n",
+						session->endpoint->transport, hoststr);
+					media_address = &temp_media_address;
+				} else {
+					ast_debug(1, "Transport %s bound to %s: Invalid for RTP media.\n",
+						session->endpoint->transport, hoststr);
+				}
+				ao2_ref(trans_state, -1);
+			}
+			ao2_ref(transport, -1);
+		}
 	}
 
 	if (!(session_media->rtp = ast_rtp_instance_new(session->endpoint->media.rtp.engine, sched, media_address, NULL))) {
@@ -188,14 +240,13 @@ static int create_rtp(struct ast_sip_ses
 		return -1;
 	}
 
-	ast_rtp_instance_set_prop(session_media->rtp, AST_RTP_PROPERTY_RTCP, 1);
 	ast_rtp_instance_set_prop(session_media->rtp, AST_RTP_PROPERTY_NAT, session->endpoint->media.rtp.symmetric);
 
 	if (!session->endpoint->media.rtp.ice_support && (ice = ast_rtp_instance_get_ice(session_media->rtp))) {
 		ice->stop(session_media->rtp);
 	}
 
-	if (session->endpoint->dtmf == AST_SIP_DTMF_RFC_4733 || session->endpoint->dtmf == AST_SIP_DTMF_AUTO) {
+	if (session->endpoint->dtmf == AST_SIP_DTMF_RFC_4733 || session->endpoint->dtmf == AST_SIP_DTMF_AUTO || session->endpoint->dtmf == AST_SIP_DTMF_AUTO_INFO) {
 		ast_rtp_instance_dtmf_mode_set(session_media->rtp, AST_RTP_DTMF_MODE_RFC2833);
 		ast_rtp_instance_set_prop(session_media->rtp, AST_RTP_PROPERTY_DTMF, 1);
 	} else if (session->endpoint->dtmf == AST_SIP_DTMF_INBAND) {
@@ -203,7 +254,7 @@ static int create_rtp(struct ast_sip_ses
 	}
 
 	if (!strcmp(session_media->stream_type, STR_AUDIO) &&
-			(session->endpoint->media.tos_audio || session->endpoint->media.cos_video)) {
+			(session->endpoint->media.tos_audio || session->endpoint->media.cos_audio)) {
 		ast_rtp_instance_set_qos(session_media->rtp, session->endpoint->media.tos_audio,
 				session->endpoint->media.cos_audio, "SIP RTP Audio");
 	} else if (!strcmp(session_media->stream_type, STR_VIDEO) &&
@@ -218,7 +269,7 @@ static int create_rtp(struct ast_sip_ses
 }
 
 static void get_codecs(struct ast_sip_session *session, const struct pjmedia_sdp_media *stream, struct ast_rtp_codecs *codecs,
-       struct ast_sip_session_media *session_media)
+	struct ast_sip_session_media *session_media)
 {
 	pjmedia_sdp_attr *attr;
 	pjmedia_sdp_rtpmap *rtpmap;
@@ -284,6 +335,16 @@ static void get_codecs(struct ast_sip_se
 	if (!tel_event && (session->endpoint->dtmf == AST_SIP_DTMF_AUTO)) {
 		ast_rtp_instance_dtmf_mode_set(session_media->rtp, AST_RTP_DTMF_MODE_INBAND);
 	}
+
+	if (session->endpoint->dtmf == AST_SIP_DTMF_AUTO_INFO) {
+		if  (tel_event) {
+			ast_rtp_instance_dtmf_mode_set(session_media->rtp, AST_RTP_DTMF_MODE_RFC2833);
+		} else {
+			ast_rtp_instance_dtmf_mode_set(session_media->rtp, AST_RTP_DTMF_MODE_NONE);
+		}
+	}
+
+
 	/* Get the packetization, if it exists */
 	if ((attr = pjmedia_sdp_media_find_attr2(stream, "ptime", NULL))) {
 		unsigned long framing = pj_strtoul(pj_strltrim(&attr->value));
@@ -350,7 +411,24 @@ static int set_caps(struct ast_sip_sessi
 		ast_format_cap_append_from_cap(caps, ast_channel_nativeformats(session->channel),
 			AST_MEDIA_TYPE_UNKNOWN);
 		ast_format_cap_remove_by_type(caps, media_type);
-		ast_format_cap_append_from_cap(caps, joint, media_type);
+
+		/*
+		 * If we don't allow the sending codec to be changed on our side
+		 * then get the best codec from the joint capabilities of the media
+		 * type and use only that. This ensures the core won't start sending
+		 * out a format that we aren't currently sending.
+		 */
+		if (!session->endpoint->asymmetric_rtp_codec) {
+			struct ast_format *best;
+
+			best = ast_format_cap_get_best_by_type(joint, media_type);
+			if (best) {
+				ast_format_cap_append(caps, best, ast_format_cap_get_framing(joint));
+				ao2_ref(best, -1);
+			}
+		} else {
+			ast_format_cap_append_from_cap(caps, joint, media_type);
+		}
 
 		/*
 		 * Apply the new formats to the channel, potentially changing
@@ -361,7 +439,8 @@ static int set_caps(struct ast_sip_sessi
 			ast_set_read_format(session->channel, ast_channel_readformat(session->channel));
 			ast_set_write_format(session->channel, ast_channel_writeformat(session->channel));
 		}
-		if ((session->endpoint->dtmf == AST_SIP_DTMF_AUTO)
+
+		if ( ((session->endpoint->dtmf == AST_SIP_DTMF_AUTO) || (session->endpoint->dtmf == AST_SIP_DTMF_AUTO_INFO) )
 		    && (ast_rtp_instance_dtmf_mode_get(session_media->rtp) == AST_RTP_DTMF_MODE_RFC2833)
 		    && (session->dsp)) {
 			dsp_features = ast_dsp_get_features(session->dsp);
@@ -373,6 +452,11 @@ static int set_caps(struct ast_sip_sessi
 				session->dsp = NULL;
 			}
 		}
+
+		if (ast_channel_is_bridged(session->channel)) {
+			ast_channel_set_unbridged_nolock(session->channel, 1);
+		}
+
 		ast_channel_unlock(session->channel);
 	}
 
@@ -420,7 +504,7 @@ static pjmedia_sdp_attr* generate_fmtp_a
 		*++tmp = '\0';
 		/* ast...generate gives us everything, just need value */
 		tmp = strchr(ast_str_buffer(fmtp0), ':');
-		if (tmp && tmp + 1) {
+		if (tmp && tmp[1] != '\0') {
 			fmtp1 = pj_str(tmp + 1);
 		} else {
 			fmtp1 = pj_str(ast_str_buffer(fmtp0));
@@ -552,6 +636,13 @@ static void process_ice_attributes(struc
 			continue;
 		}
 
+		if (session->endpoint->rtcp_mux && session_media->remote_rtcp_mux && candidate.id > 1) {
+			/* Remote side may have offered RTP and RTCP candidates. However, if we're using RTCP MUX,
+			 * then we should ignore RTCP candidates.
+			 */
+			continue;
+		}
+
 		candidate.foundation = foundation;
 		candidate.transport = transport;
 
@@ -723,7 +814,7 @@ static void apply_dtls_attrib(struct ast
 	struct ast_rtp_engine_dtls *dtls = ast_rtp_instance_get_dtls(session_media->rtp);
 	pj_str_t *value;
 
-	if (!attr->value.ptr) {
+	if (!attr->value.ptr || !dtls) {
 		return;
 	}
 
@@ -848,6 +939,26 @@ static int setup_media_encryption(struct
 	return 0;
 }
 
+static void set_ice_components(struct ast_sip_session *session, struct ast_sip_session_media *session_media)
+{
+	struct ast_rtp_engine_ice *ice;
+
+	ast_assert(session_media->rtp != NULL);
+
+	ice = ast_rtp_instance_get_ice(session_media->rtp);
+	if (!session->endpoint->media.rtp.ice_support || !ice) {
+		return;
+	}
+
+	if (session->endpoint->rtcp_mux && session_media->remote_rtcp_mux) {
+		/* We both support RTCP mux. Only one ICE component necessary */
+		ice->change_components(session_media->rtp, 1);
+	} else {
+		/* They either don't support RTCP mux or we don't know if they do yet. */
+		ice->change_components(session_media->rtp, 2);
+	}
+}
+
 /*! \brief Function which negotiates an incoming media stream */
 static int negotiate_incoming_sdp_stream(struct ast_sip_session *session, struct ast_sip_session_media *session_media,
 					 const struct pjmedia_sdp_session *sdp, const struct pjmedia_sdp_media *stream)
@@ -888,15 +999,22 @@ static int negotiate_incoming_sdp_stream
 	}
 
 	/* Using the connection information create an appropriate RTP instance */
-	if (!session_media->rtp && create_rtp(session, session_media, ast_sockaddr_is_ipv6(addrs))) {
+	if (!session_media->rtp && create_rtp(session, session_media)) {
 		return -1;
 	}
 
+	session_media->remote_rtcp_mux = (pjmedia_sdp_media_find_attr2(stream, "rtcp-mux", NULL) != NULL);
+	set_ice_components(session, session_media);
+
+	enable_rtcp(session, session_media, stream);
+
 	res = setup_media_encryption(session, session_media, sdp, stream);
 	if (res) {
-		if (!session->endpoint->media.rtp.encryption_optimistic) {
+		if (!session->endpoint->media.rtp.encryption_optimistic ||
+			!pj_strncmp2(&stream->desc.transport, "RTP/SAVP", 8)) {
 			/* If optimistic encryption is disabled and crypto should have been enabled
-			 * but was not this session must fail.
+			 * but was not this session must fail. This must also fail if crypto was
+			 * required in the offer but could not be set up.
 			 */
 			return -1;
 		}
@@ -1042,7 +1160,7 @@ static int create_outgoing_sdp_stream(st
 	pj_str_t stmp;
 	pjmedia_sdp_attr *attr;
 	int index = 0;
-	int noncodec = (session->endpoint->dtmf == AST_SIP_DTMF_RFC_4733 || session->endpoint->dtmf == AST_SIP_DTMF_AUTO) ? AST_RTP_DTMF : 0;
+	int noncodec = (session->endpoint->dtmf == AST_SIP_DTMF_RFC_4733 || session->endpoint->dtmf == AST_SIP_DTMF_AUTO || session->endpoint->dtmf == AST_SIP_DTMF_AUTO_INFO) ? AST_RTP_DTMF : 0;
 	int min_packet_size = 0, max_packet_size = 0;
 	int rtp_code;
 	RAII_VAR(struct ast_format_cap *, caps, NULL, ao2_cleanup);
@@ -1056,10 +1174,13 @@ static int create_outgoing_sdp_stream(st
 	    (!use_override_prefs && !ast_format_cap_has_type(session->endpoint->media.codecs, media_type))) {
 		/* If no type formats are configured don't add a stream */
 		return 0;
-	} else if (!session_media->rtp && create_rtp(session, session_media, session->endpoint->media.rtp.ipv6)) {
+	} else if (!session_media->rtp && create_rtp(session, session_media)) {
 		return -1;
 	}
 
+	set_ice_components(session, session_media);
+	enable_rtcp(session, session_media, NULL);
+
 	if (!(media = pj_pool_zalloc(pool, sizeof(struct pjmedia_sdp_media))) ||
 		!(media->conn = pj_pool_zalloc(pool, sizeof(struct pjmedia_sdp_conn)))) {
 		return -1;
@@ -1097,8 +1218,19 @@ static int create_outgoing_sdp_stream(st
 	}
 
 	media->conn->net_type = STR_IN;
-	media->conn->addr_type = session->endpoint->media.rtp.ipv6 ? STR_IP6 : STR_IP4;
+	/* Assume that the connection will use IPv4 until proven otherwise */
+	media->conn->addr_type = STR_IP4;
 	pj_strdup2(pool, &media->conn->addr, hostip);
+
+	if (!ast_strlen_zero(session->endpoint->media.address)) {
+		pj_sockaddr ip;
+
+		if ((pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &media->conn->addr, &ip) == PJ_SUCCESS) &&
+			(ip.addr.sa_family == pj_AF_INET6())) {
+			media->conn->addr_type = STR_IP6;
+		}
+	}
+
 	ast_rtp_instance_get_local_address(session_media->rtp, &addr);
 	media->desc.port = direct_media_enabled ? ast_sockaddr_port(&session_media->direct_media_addr) : (pj_uint16_t) ast_sockaddr_port(&addr);
 	media->desc.port_count = 1;
@@ -1149,10 +1281,14 @@ static int create_outgoing_sdp_stream(st
 			max_packet_size = ast_format_get_maximum_ms(format);
 		}
 		ao2_ref(format, -1);
+
+		if (media->desc.fmt_count == PJMEDIA_MAX_SDP_FMT) {
+			break;
+		}
 	}
 
 	/* Add non-codec formats */
-	if (media_type != AST_MEDIA_TYPE_VIDEO) {
+	if (media_type != AST_MEDIA_TYPE_VIDEO && media->desc.fmt_count < PJMEDIA_MAX_SDP_FMT) {
 		for (index = 1LL; index <= AST_RTP_MAX; index <<= 1) {
 			if (!(noncodec & index)) {
 				continue;
@@ -1174,6 +1310,10 @@ static int create_outgoing_sdp_stream(st
 				attr = pjmedia_sdp_attr_create(pool, "fmtp", pj_cstr(&stmp, tmp));
 				media->attr[media->attr_count++] = attr;
 			}
+
+			if (media->desc.fmt_count == PJMEDIA_MAX_SDP_FMT) {
+				break;
+			}
 		}
 	}
 
@@ -1204,6 +1344,12 @@ static int create_outgoing_sdp_stream(st
 	attr->name = STR_SENDRECV;
 	media->attr[media->attr_count++] = attr;
 
+	/* If we've got rtcp-mux enabled, just unconditionally offer it in all SDPs */
+	if (session->endpoint->rtcp_mux) {
+		attr = pjmedia_sdp_attr_create(pool, "rtcp-mux", NULL);
+		pjmedia_sdp_attr_add(&media->attr_count, media->attr, attr);
+	}
+
 	/* Add the media stream to the SDP */
 	sdp->media[sdp->media_count++] = media;
 
@@ -1234,10 +1380,15 @@ static int apply_negotiated_sdp_stream(s
 	}
 
 	/* Create an RTP instance if need be */
-	if (!session_media->rtp && create_rtp(session, session_media, session->endpoint->media.rtp.ipv6)) {
+	if (!session_media->rtp && create_rtp(session, session_media)) {
 		return -1;
 	}
 
+	session_media->remote_rtcp_mux = (pjmedia_sdp_media_find_attr2(remote_stream, "rtcp-mux", NULL) != NULL);
+	set_ice_components(session, session_media);
+
+	enable_rtcp(session, session_media, remote_stream);
+
 	res = setup_media_encryption(session, session_media, remote, remote_stream);
 	if (!session->endpoint->media.rtp.encryption_optimistic && res) {
 		/* If optimistic encryption is disabled and crypto should have been enabled but was not
@@ -1269,7 +1420,9 @@ static int apply_negotiated_sdp_stream(s
 		return -1;
 	}
 	ast_channel_set_fd(session->channel, fdno, ast_rtp_instance_fd(session_media->rtp, 0));
-	ast_channel_set_fd(session->channel, fdno + 1, ast_rtp_instance_fd(session_media->rtp, 1));
+	if (!session->endpoint->rtcp_mux || !session_media->remote_rtcp_mux) {
+		ast_channel_set_fd(session->channel, fdno + 1, ast_rtp_instance_fd(session_media->rtp, 1));
+	}
 
 	/* If ICE support is enabled find all the needed attributes */
 	process_ice_attributes(session, session_media, remote, remote_stream);
@@ -1363,10 +1516,11 @@ static void change_outgoing_sdp_stream_m
 	ast_sockaddr_parse(&addr, host, PARSE_PORT_FORBID);
 
 	/* Is the address within the SDP inside the same network? */
-	if (ast_apply_ha(transport_state->localnet, &addr) == AST_SENSE_ALLOW) {
+	if (transport_state->localnet
+		&& ast_apply_ha(transport_state->localnet, &addr) == AST_SENSE_ALLOW) {
 		return;
 	}
-
+	ast_debug(5, "Setting media address to %s\n", transport->external_media_address);
 	pj_strdup2(tdata->pool, &stream->conn->addr, transport->external_media_address);
 }
 
@@ -1470,8 +1624,11 @@ static int load_module(void)
 {
 	CHECK_PJSIP_SESSION_MODULE_LOADED();
 
-	ast_sockaddr_parse(&address_ipv4, "0.0.0.0", 0);
-	ast_sockaddr_parse(&address_ipv6, "::", 0);
+	if (ast_check_ipv6()) {
+		ast_sockaddr_parse(&address_rtp, "::", 0);
+	} else {
+		ast_sockaddr_parse(&address_rtp, "0.0.0.0", 0);
+	}
 
 	if (!(sched = ast_sched_context_create())) {
 		ast_log(LOG_ERROR, "Unable to create scheduler context.\n");
@@ -1499,7 +1656,7 @@ static int load_module(void)
 end:
 	unload_module();
 
-	return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_DECLINE;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP SDP RTP/AVP stream handler",
diff -urpN asterisk-13.9.1/res/res_pjsip_send_to_voicemail.c asterisk-13.17.0/res/res_pjsip_send_to_voicemail.c
--- asterisk-13.9.1/res/res_pjsip_send_to_voicemail.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_send_to_voicemail.c	2017-07-12 13:12:08.000000000 +0200
@@ -219,7 +219,7 @@ static int load_module(void)
 
 	if (ast_sip_session_register_supplement(&refer_supplement)) {
 		ast_log(LOG_ERROR, "Unable to register Send to Voicemail supplement\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_pjsip_session.c asterisk-13.17.0/res/res_pjsip_session.c
--- asterisk-13.9.1/res/res_pjsip_session.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_session.c	2017-07-12 13:12:08.000000000 +0200
@@ -46,6 +46,7 @@
 #include "asterisk/acl.h"
 #include "asterisk/features_config.h"
 #include "asterisk/pickup.h"
+#include "asterisk/test.h"
 
 #define SDP_HANDLER_BUCKETS 11
 
@@ -53,14 +54,13 @@
 #define MOD_DATA_NAT_HOOK "nat_hook"
 
 /* Some forward declarations */
-static void handle_incoming_request(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_event_id_e type);
-static void handle_incoming_response(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_event_id_e type,
+static void handle_incoming_request(struct ast_sip_session *session, pjsip_rx_data *rdata);
+static void handle_incoming_response(struct ast_sip_session *session, pjsip_rx_data *rdata,
 		enum ast_sip_session_response_priority response_priority);
-static int handle_incoming(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_event_id_e type,
+static int handle_incoming(struct ast_sip_session *session, pjsip_rx_data *rdata,
 		enum ast_sip_session_response_priority response_priority);
 static void handle_outgoing_request(struct ast_sip_session *session, pjsip_tx_data *tdata);
 static void handle_outgoing_response(struct ast_sip_session *session, pjsip_tx_data *tdata);
-static void handle_outgoing(struct ast_sip_session *session, pjsip_tx_data *tdata);
 
 /*! \brief NAT hook for modifying outgoing messages with SDP */
 static struct ast_sip_nat_hook *nat_hook;
@@ -212,6 +212,11 @@ static int handle_incoming_sdp(struct as
 	int i;
 	int handled = 0;
 
+	if (session->inv_session && session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Failed to handle incoming SDP. Session has been already disconnected\n");
+		return -1;
+	}
+
 	for (i = 0; i < sdp->media_count; ++i) {
 		/* See if there are registered handlers for this media stream type */
 		char media[20];
@@ -791,12 +796,14 @@ static int delay_request(struct ast_sip_
 static pjmedia_sdp_session *generate_session_refresh_sdp(struct ast_sip_session *session)
 {
 	pjsip_inv_session *inv_session = session->inv_session;
-	const pjmedia_sdp_session *previous_sdp;
+	const pjmedia_sdp_session *previous_sdp = NULL;
 
-	if (pjmedia_sdp_neg_was_answer_remote(inv_session->neg)) {
-		pjmedia_sdp_neg_get_active_remote(inv_session->neg, &previous_sdp);
-	} else {
-		pjmedia_sdp_neg_get_active_local(inv_session->neg, &previous_sdp);
+	if (inv_session->neg) {
+		if (pjmedia_sdp_neg_was_answer_remote(inv_session->neg)) {
+			pjmedia_sdp_neg_get_active_remote(inv_session->neg, &previous_sdp);
+		} else {
+			pjmedia_sdp_neg_get_active_local(inv_session->neg, &previous_sdp);
+		}
 	}
 	return create_local_sdp(inv_session, session, previous_sdp);
 }
@@ -916,7 +923,9 @@ int ast_sip_session_refresh(struct ast_s
 
 	if (generate_new_sdp) {
 		/* SDP can only be generated if current negotiation has already completed */
-		if (pjmedia_sdp_neg_get_state(inv_session->neg) != PJMEDIA_SDP_NEG_STATE_DONE) {
+		if (inv_session->neg
+			&& pjmedia_sdp_neg_get_state(inv_session->neg)
+				!= PJMEDIA_SDP_NEG_STATE_DONE) {
 			ast_debug(3, "Delay session refresh with new SDP to %s because SDP negotiation is not yet done...\n",
 				ast_sorcery_object_get_id(session->endpoint));
 			return delay_request(session, on_request_creation, on_sdp_creation,
@@ -937,11 +946,6 @@ int ast_sip_session_refresh(struct ast_s
 		}
 	}
 
-	/*
-	 * We MUST call set_from_header() before pjsip_inv_(reinvite|update).  If we don't, the
-	 * From in the reINVITE/UPDATE will be wrong but the rest of the messages will be OK.
-	 */
-	set_from_header(session);
 
 	if (method == AST_SIP_SESSION_REFRESH_METHOD_INVITE) {
 		if (pjsip_inv_reinvite(inv_session, NULL, new_sdp, &tdata)) {
@@ -964,32 +968,10 @@ int ast_sip_session_refresh(struct ast_s
 	return 0;
 }
 
-/*!
- * \internal
- * \brief Wrapper for pjsip_inv_send_msg
- *
- * This function (re)sets the transport before sending to catch cases
- * where the transport might have changed.
- *
- * If pjproject gives us the ability to resend, we'll only reset the transport
- * if PJSIP_ETPNOTAVAIL is returned from send.
- *
- * \returns pj_status_t
- */
-static pj_status_t internal_pjsip_inv_send_msg(pjsip_inv_session *inv, const char *transport_name, pjsip_tx_data *tdata)
-{
-	pjsip_tpselector selector = { .type = PJSIP_TPSELECTOR_NONE, };
-
-	ast_sip_set_tpselector_from_transport_name(transport_name, &selector);
-	pjsip_dlg_set_transport(inv->dlg, &selector);
-
-	return pjsip_inv_send_msg(inv, tdata);
-}
-
 void ast_sip_session_send_response(struct ast_sip_session *session, pjsip_tx_data *tdata)
 {
 	handle_outgoing_response(session, tdata);
-	internal_pjsip_inv_send_msg(session->inv_session, session->endpoint->transport, tdata);
+	pjsip_inv_send_msg(session->inv_session, tdata);
 	return;
 }
 
@@ -1211,8 +1193,13 @@ void ast_sip_session_send_request_with_c
 {
 	pjsip_inv_session *inv_session = session->inv_session;
 
-	if (inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
-		/* Don't try to do anything with a hung-up call */
+	/* For every request except BYE we disallow sending of the message when
+	 * the session has been disconnected. A BYE request is special though
+	 * because it can be sent again after the session is disconnected except
+	 * with credentials.
+	 */
+	if (inv_session->state == PJSIP_INV_STATE_DISCONNECTED &&
+		tdata->msg->line.req.method.id != PJSIP_BYE_METHOD) {
 		return;
 	}
 
@@ -1220,7 +1207,7 @@ void ast_sip_session_send_request_with_c
 			     MOD_DATA_ON_RESPONSE, on_response);
 
 	handle_outgoing_request(session, tdata);
-	internal_pjsip_inv_send_msg(session->inv_session, session->endpoint->transport, tdata);
+	pjsip_inv_send_msg(session->inv_session, tdata);
 
 	return;
 }
@@ -1308,9 +1295,19 @@ static void session_destructor(void *obj
 	struct ast_sip_session *session = obj;
 	struct ast_sip_session_supplement *supplement;
 	struct ast_sip_session_delayed_request *delay;
+	const char *endpoint_name = session->endpoint ?
+		ast_sorcery_object_get_id(session->endpoint) : "<none>";
+
+	ast_debug(3, "Destroying SIP session with endpoint %s\n", endpoint_name);
 
-	ast_debug(3, "Destroying SIP session with endpoint %s\n",
-		session->endpoint ? ast_sorcery_object_get_id(session->endpoint) : "<none>");
+	ast_test_suite_event_notify("SESSION_DESTROYING",
+		"Endpoint: %s\r\n"
+		"AOR: %s\r\n"
+		"Contact: %s"
+		, endpoint_name
+		, session->aor ? ast_sorcery_object_get_id(session->aor) : "<none>"
+		, session->contact ? ast_sorcery_object_get_id(session->contact) : "<none>"
+		);
 
 	while ((supplement = AST_LIST_REMOVE_HEAD(&session->supplements, next))) {
 		if (supplement->session_destroy) {
@@ -1334,13 +1331,13 @@ static void session_destructor(void *obj
 	ao2_cleanup(session->req_caps);
 	ao2_cleanup(session->direct_media_cap);
 
-	if (session->dsp) {
-		ast_dsp_free(session->dsp);
-	}
+	ast_dsp_free(session->dsp);
 
 	if (session->inv_session) {
 		pjsip_dlg_dec_session(session->inv_session->dlg, &session_module);
 	}
+
+	ast_test_suite_event_notify("SESSION_DESTROYED", "Endpoint: %s", endpoint_name);
 }
 
 static int add_supplements(struct ast_sip_session *session)
@@ -1403,23 +1400,50 @@ struct ast_sip_channel_pvt *ast_sip_chan
 }
 
 struct ast_sip_session *ast_sip_session_alloc(struct ast_sip_endpoint *endpoint,
-	struct ast_sip_contact *contact, pjsip_inv_session *inv_session)
+	struct ast_sip_contact *contact, pjsip_inv_session *inv_session, pjsip_rx_data *rdata)
 {
 	RAII_VAR(struct ast_sip_session *, session, NULL, ao2_cleanup);
+	struct ast_sip_session *ret_session;
 	struct ast_sip_session_supplement *iter;
 	int dsp_features = 0;
-	char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
 
 	session = ao2_alloc(sizeof(*session), session_destructor);
 	if (!session) {
 		return NULL;
 	}
+
 	AST_LIST_HEAD_INIT(&session->supplements);
+	AST_LIST_HEAD_INIT_NOLOCK(&session->delayed_requests);
+	ast_party_id_init(&session->id);
+
+	session->direct_media_cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!session->direct_media_cap) {
+		return NULL;
+	}
+	session->req_caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!session->req_caps) {
+		return NULL;
+	}
 	session->datastores = ao2_container_alloc(DATASTORE_BUCKETS, datastore_hash, datastore_cmp);
 	if (!session->datastores) {
 		return NULL;
 	}
 
+	if (endpoint->dtmf == AST_SIP_DTMF_INBAND || endpoint->dtmf == AST_SIP_DTMF_AUTO) {
+		dsp_features |= DSP_FEATURE_DIGIT_DETECT;
+	}
+	if (endpoint->faxdetect) {
+		dsp_features |= DSP_FEATURE_FAX_DETECT;
+	}
+	if (dsp_features) {
+		session->dsp = ast_dsp_new();
+		if (!session->dsp) {
+			return NULL;
+		}
+
+		ast_dsp_set_features(session->dsp, dsp_features);
+	}
+
 	session->endpoint = ao2_bump(endpoint);
 
 	session->media = ao2_container_alloc(MEDIA_BUCKETS, session_media_hash, session_media_cmp);
@@ -1429,11 +1453,24 @@ struct ast_sip_session *ast_sip_session_
 	/* fill session->media with available types */
 	ao2_callback(sdp_handlers, OBJ_NODATA, add_session_media, session);
 
-	/* Create name with seq number appended. */
-	ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/session/%s",
-		ast_sorcery_object_get_id(endpoint));
+	if (rdata) {
+		/*
+		 * We must continue using the serializer that the original
+		 * INVITE came in on for the dialog.  There may be
+		 * retransmissions already enqueued in the original
+		 * serializer that can result in reentrancy and message
+		 * sequencing problems.
+		 */
+		session->serializer = ast_sip_get_distributor_serializer(rdata);
+	} else {
+		char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
+
+		/* Create name with seq number appended. */
+		ast_taskprocessor_build_name(tps_name, sizeof(tps_name), "pjsip/outsess/%s",
+			ast_sorcery_object_get_id(endpoint));
 
-	session->serializer = ast_sip_create_serializer_named(tps_name);
+		session->serializer = ast_sip_create_serializer_named(tps_name);
+	}
 	if (!session->serializer) {
 		return NULL;
 	}
@@ -1443,30 +1480,6 @@ struct ast_sip_session *ast_sip_session_
 	inv_session->mod_data[session_module.id] = ao2_bump(session);
 	session->contact = ao2_bump(contact);
 	session->inv_session = inv_session;
-	session->req_caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
-	if (!session->req_caps) {
-		/* Release the ref held by session->inv_session */
-		ao2_ref(session, -1);
-		return NULL;
-	}
-
-	if ((endpoint->dtmf == AST_SIP_DTMF_INBAND) || (endpoint->dtmf == AST_SIP_DTMF_AUTO)) {
-		dsp_features |= DSP_FEATURE_DIGIT_DETECT;
-	}
-
-	if (endpoint->faxdetect) {
-		dsp_features |= DSP_FEATURE_FAX_DETECT;
-	}
-
-	if (dsp_features) {
-		if (!(session->dsp = ast_dsp_new())) {
-			/* Release the ref held by session->inv_session */
-			ao2_ref(session, -1);
-			return NULL;
-		}
-
-		ast_dsp_set_features(session->dsp, dsp_features);
-	}
 
 	if (add_supplements(session)) {
 		/* Release the ref held by session->inv_session */
@@ -1478,11 +1491,11 @@ struct ast_sip_session *ast_sip_session_
 			iter->session_begin(session);
 		}
 	}
-	session->direct_media_cap = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
-	AST_LIST_HEAD_INIT_NOLOCK(&session->delayed_requests);
-	ast_party_id_init(&session->id);
-	ao2_ref(session, +1);
-	return session;
+
+	/* Avoid unnecessary ref manipulation to return a session */
+	ret_session = session;
+	session = NULL;
+	return ret_session;
 }
 
 /*! \brief struct controlling the suspension of the session's serializer. */
@@ -1542,6 +1555,11 @@ void ast_sip_session_suspend(struct ast_
 		return;
 	}
 
+	if (ast_taskprocessor_is_suspended(session->serializer)) {
+		/* The serializer already suspended. */
+		return;
+	}
+
 	suspender = ao2_alloc(sizeof(*suspender), sip_session_suspender_dtor);
 	if (!suspender) {
 		/* We will just have to hope that the system does not deadlock */
@@ -1566,6 +1584,8 @@ void ast_sip_session_suspend(struct ast_
 		ast_cond_wait(&suspender->cond_suspended, ao2_object_get_lockaddr(suspender));
 	}
 	ao2_unlock(suspender);
+
+	ast_taskprocessor_suspend(session->serializer);
 }
 
 void ast_sip_session_unsuspend(struct ast_sip_session *session)
@@ -1585,6 +1605,8 @@ void ast_sip_session_unsuspend(struct as
 	ao2_unlock(suspender);
 
 	ao2_ref(suspender, -1);
+
+	ast_taskprocessor_unsuspend(session->serializer);
 }
 
 /*!
@@ -1689,12 +1711,14 @@ struct ast_sip_session *ast_sip_session_
 	pjsip_dialog *dlg;
 	struct pjsip_inv_session *inv_session;
 	RAII_VAR(struct ast_sip_session *, session, NULL, ao2_cleanup);
+	struct ast_sip_session *ret_session;
 
 	/* If no location has been provided use the AOR list from the endpoint itself */
 	if (location || !contact) {
 		location = S_OR(location, endpoint->aors);
 
-		ast_sip_location_retrieve_contact_and_aor_from_list(location, &found_aor, &found_contact);
+		ast_sip_location_retrieve_contact_and_aor_from_list_filtered(location, AST_SIP_CONTACT_FILTER_REACHABLE,
+			&found_aor, &found_contact);
 		if (!found_contact || ast_strlen_zero(found_contact->uri)) {
 			uri = location;
 		} else {
@@ -1706,6 +1730,8 @@ struct ast_sip_session *ast_sip_session_
 
 	/* If we still have no URI to dial fail to create the session */
 	if (ast_strlen_zero(uri)) {
+		ast_log(LOG_ERROR, "Endpoint '%s': No URI available.  Is endpoint registered?\n",
+			ast_sorcery_object_get_id(endpoint));
 		return NULL;
 	}
 
@@ -1731,7 +1757,9 @@ struct ast_sip_session *ast_sip_session_
 	timer.sess_expires = endpoint->extensions.timer.sess_expires;
 	pjsip_timer_init_session(inv_session, &timer);
 
-	if (!(session = ast_sip_session_alloc(endpoint, found_contact ? found_contact : contact, inv_session))) {
+	session = ast_sip_session_alloc(endpoint, found_contact ? found_contact : contact,
+		inv_session, NULL);
+	if (!session) {
 		pjsip_inv_terminate(inv_session, 500, PJ_FALSE);
 		return NULL;
 	}
@@ -1741,14 +1769,17 @@ struct ast_sip_session *ast_sip_session_
 	if (ast_format_cap_count(req_caps)) {
 		/* get joint caps between req_caps and endpoint caps */
 		struct ast_format_cap *joint_caps = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
-		ast_format_cap_get_compatible(req_caps, session->endpoint->media.codecs, joint_caps);
+
+		ast_format_cap_get_compatible(req_caps, endpoint->media.codecs, joint_caps);
 
 		/* if joint caps */
 		if (ast_format_cap_count(joint_caps)) {
 			/* copy endpoint caps into session->req_caps */
-			ast_format_cap_append_from_cap(session->req_caps, session->endpoint->media.codecs, AST_MEDIA_TYPE_UNKNOWN);
+			ast_format_cap_append_from_cap(session->req_caps,
+				endpoint->media.codecs, AST_MEDIA_TYPE_UNKNOWN);
 			/* replace instances of joint caps equivalents in session->req_caps */
-			ast_format_cap_replace_from_cap(session->req_caps, joint_caps, AST_MEDIA_TYPE_UNKNOWN);
+			ast_format_cap_replace_from_cap(session->req_caps, joint_caps,
+				AST_MEDIA_TYPE_UNKNOWN);
 		}
 		ao2_cleanup(joint_caps);
 	}
@@ -1762,10 +1793,15 @@ struct ast_sip_session *ast_sip_session_
 		return NULL;
 	}
 
-	ao2_ref(session, +1);
-	return session;
+	/* Avoid unnecessary ref manipulation to return a session */
+	ret_session = session;
+	session = NULL;
+	return ret_session;
 }
 
+static int session_end(void *vsession);
+static int session_end_completion(void *vsession);
+
 void ast_sip_session_terminate(struct ast_sip_session *session, int response)
 {
 	pj_status_t status;
@@ -1780,29 +1816,56 @@ void ast_sip_session_terminate(struct as
 		response = 603;
 	}
 
-	if ((session->inv_session->state == PJSIP_INV_STATE_CONFIRMED) && session->inv_session->invite_tsx) {
-		ast_debug(3, "Delay sending BYE to %s because of outstanding transaction...\n",
-				ast_sorcery_object_get_id(session->endpoint));
-		/* If this is delayed the only thing that will happen is a BYE request so we don't
-		 * actually need to store the response code for when it happens.
-		 */
-		delay_request(session, NULL, NULL, NULL, 0, DELAYED_METHOD_BYE);
-	} else if (session->inv_session->state == PJSIP_INV_STATE_NULL) {
-		pjsip_inv_terminate(session->inv_session, response, PJ_TRUE);
-	} else if (((status = pjsip_inv_end_session(session->inv_session, response, NULL, &packet)) == PJ_SUCCESS)
-		&& packet) {
-		struct ast_sip_session_delayed_request *delay;
-
-		/* Flush any delayed requests so they cannot overlap this transaction. */
-		while ((delay = AST_LIST_REMOVE_HEAD(&session->delayed_requests, next))) {
-			ast_free(delay);
+	switch (session->inv_session->state) {
+	case PJSIP_INV_STATE_NULL:
+		if (!session->inv_session->invite_tsx) {
+			/*
+			 * Normally, it's pjproject's transaction cleanup that ultimately causes the
+			 * final session reference to be released but if both STATE and invite_tsx are NULL,
+			 * we never created a transaction in the first place.  In this case, we need to
+			 * do the cleanup ourselves.
+			 */
+			/* Transfer the inv_session session reference to the session_end_task */
+			session->inv_session->mod_data[session_module.id] = NULL;
+			pjsip_inv_terminate(session->inv_session, response, PJ_TRUE);
+			session_end(session);
+			/*
+			 * session_end_completion will cleanup the final session reference unless
+			 * ast_sip_session_terminate's caller is holding one.
+			 */
+			session_end_completion(session);
+		} else {
+			pjsip_inv_terminate(session->inv_session, response, PJ_TRUE);
 		}
+		break;
+	case PJSIP_INV_STATE_CONFIRMED:
+		if (session->inv_session->invite_tsx) {
+			ast_debug(3, "Delay sending BYE to %s because of outstanding transaction...\n",
+					ast_sorcery_object_get_id(session->endpoint));
+			/* If this is delayed the only thing that will happen is a BYE request so we don't
+			 * actually need to store the response code for when it happens.
+			 */
+			delay_request(session, NULL, NULL, NULL, 0, DELAYED_METHOD_BYE);
+			break;
+		}
+		/* Fall through */
+	default:
+		status = pjsip_inv_end_session(session->inv_session, response, NULL, &packet);
+		if (status == PJ_SUCCESS && packet) {
+			struct ast_sip_session_delayed_request *delay;
+
+			/* Flush any delayed requests so they cannot overlap this transaction. */
+			while ((delay = AST_LIST_REMOVE_HEAD(&session->delayed_requests, next))) {
+				ast_free(delay);
+			}
 
-		if (packet->msg->type == PJSIP_RESPONSE_MSG) {
-			ast_sip_session_send_response(session, packet);
-		} else {
-			ast_sip_session_send_request(session, packet);
+			if (packet->msg->type == PJSIP_RESPONSE_MSG) {
+				ast_sip_session_send_response(session, packet);
+			} else {
+				ast_sip_session_send_request(session, packet);
+			}
 		}
+		break;
 	}
 }
 
@@ -1840,6 +1903,9 @@ int ast_sip_session_defer_termination(st
 
 	session->defer_terminate = 1;
 
+	session->defer_end = 1;
+	session->ended_while_deferred = 0;
+
 	session->scheduled_termination.id = 0;
 	ao2_ref(session, +1);
 	session->scheduled_termination.user_data = session;
@@ -1877,6 +1943,7 @@ void ast_sip_session_defer_termination_c
 		/* Already canceled or timer fired. */
 		return;
 	}
+
 	session->defer_terminate = 0;
 
 	if (session->terminate_while_deferred) {
@@ -1888,6 +1955,22 @@ void ast_sip_session_defer_termination_c
 	sip_session_defer_termination_stop_timer(session);
 }
 
+void ast_sip_session_end_if_deferred(struct ast_sip_session *session)
+{
+	if (!session->defer_end) {
+		return;
+	}
+
+	session->defer_end = 0;
+
+	if (session->ended_while_deferred) {
+		/* Complete the session end started by the remote hangup. */
+		ast_debug(3, "Ending session (%p) after being deferred\n", session);
+		session->ended_while_deferred = 0;
+		session_end(session);
+	}
+}
+
 struct ast_sip_session *ast_sip_dialog_get_session(pjsip_dialog *dlg)
 {
 	pjsip_inv_session *inv_session = pjsip_dlg_get_inv_session(dlg);
@@ -1938,6 +2021,12 @@ static enum sip_get_destination_result g
 	sip_ruri = pjsip_uri_get_uri(ruri);
 	ast_copy_pj_str(session->exten, &sip_ruri->user, sizeof(session->exten));
 
+	/*
+	 * We may want to match in the dialplan without any user
+	 * options getting in the way.
+	 */
+	AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(session->exten);
+
 	pickup_cfg = ast_get_chan_features_pickup_config(session->channel);
 	if (!pickup_cfg) {
 		ast_log(LOG_ERROR, "Unable to retrieve pickup configuration options. Unable to detect call pickup extension\n");
@@ -1949,12 +2038,25 @@ static enum sip_get_destination_result g
 
 	if (!strcmp(session->exten, pickupexten) ||
 		ast_exists_extension(NULL, session->endpoint->context, session->exten, 1, NULL)) {
+		size_t size = pj_strlen(&sip_ruri->host) + 1;
+		char *domain = ast_alloca(size);
+
+		ast_copy_pj_str(domain, &sip_ruri->host, size);
+		pbx_builtin_setvar_helper(session->channel, "SIPDOMAIN", domain);
+
 		return SIP_GET_DEST_EXTEN_FOUND;
 	}
-	/* XXX In reality, we'll likely have further options so that partial matches
-	 * can be indicated here, but for getting something up and running, we're going
-	 * to return a "not exists" error here.
+
+	/*
+	 * Check for partial match via overlap dialling (if enabled)
 	 */
+	if (session->endpoint->allow_overlap && (
+		!strncmp(session->exten, pickupexten, strlen(session->exten)) ||
+		ast_canmatch_extension(NULL, session->endpoint->context, session->exten, 1, NULL))) {
+		/* Overlap partial match */
+		return SIP_GET_DEST_EXTEN_PARTIAL;
+	}
+
 	return SIP_GET_DEST_EXTEN_NOT_FOUND;
 }
 
@@ -1994,7 +2096,7 @@ static pjsip_inv_session *pre_session_se
 		if (pjsip_inv_initial_answer(inv_session, rdata, 500, NULL, NULL, &tdata) != PJ_SUCCESS) {
 			pjsip_inv_terminate(inv_session, 500, PJ_FALSE);
 		}
-		internal_pjsip_inv_send_msg(inv_session, endpoint->transport, tdata);
+		pjsip_inv_send_msg(inv_session, tdata);
 		return NULL;
 	}
 	return inv_session;
@@ -2008,39 +2110,8 @@ struct new_invite {
 	pjsip_rx_data *rdata;
 };
 
-static void new_invite_destroy(void *obj)
-{
-	struct new_invite *invite = obj;
-
-	ao2_cleanup(invite->session);
-
-	if (invite->rdata) {
-		pjsip_rx_data_free_cloned(invite->rdata);
-	}
-}
-
-static struct new_invite *new_invite_alloc(struct ast_sip_session *session, pjsip_rx_data *rdata)
+static int new_invite(struct new_invite *invite)
 {
-	struct new_invite *invite = ao2_alloc(sizeof(*invite), new_invite_destroy);
-
-	if (!invite) {
-		return NULL;
-	}
-
-	ao2_ref(session, +1);
-	invite->session = session;
-
-	if (pjsip_rx_data_clone(rdata, 0, &invite->rdata) != PJ_SUCCESS) {
-		ao2_ref(invite, -1);
-		return NULL;
-	}
-
-	return invite;
-}
-
-static int new_invite(void *data)
-{
-	RAII_VAR(struct new_invite *, invite, data, ao2_cleanup);
 	pjsip_tx_data *tdata = NULL;
 	pjsip_timer_setting timer;
 	pjsip_rdata_sdp_info *sdp_info;
@@ -2050,6 +2121,16 @@ static int new_invite(void *data)
 	 * so that we will be notified so we can destroy the session properly
 	 */
 
+	if (invite->session->inv_session->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Session already DISCONNECTED [reason=%d (%s)]\n",
+			invite->session->inv_session->cause,
+			pjsip_get_status_text(invite->session->inv_session->cause)->ptr);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(invite->session->inv_session);
+#endif
+		return -1;
+	}
+
 	switch (get_destination(invite->session, invite->rdata)) {
 	case SIP_GET_DEST_EXTEN_FOUND:
 		/* Things worked. Keep going */
@@ -2060,9 +2141,18 @@ static int new_invite(void *data)
 		} else  {
 			pjsip_inv_terminate(invite->session->inv_session, 416, PJ_TRUE);
 		}
-		return 0;
-	case SIP_GET_DEST_EXTEN_NOT_FOUND:
+		goto end;
 	case SIP_GET_DEST_EXTEN_PARTIAL:
+		ast_debug(1, "Call from '%s' (%s:%s:%d) to extension '%s' - partial match\n", ast_sorcery_object_get_id(invite->session->endpoint),
+			invite->rdata->tp_info.transport->type_name, invite->rdata->pkt_info.src_name, invite->rdata->pkt_info.src_port, invite->session->exten);
+
+		if (pjsip_inv_initial_answer(invite->session->inv_session, invite->rdata, 484, NULL, NULL, &tdata) == PJ_SUCCESS) {
+			ast_sip_session_send_response(invite->session, tdata);
+		} else  {
+			pjsip_inv_terminate(invite->session->inv_session, 484, PJ_TRUE);
+		}
+		goto end;
+	case SIP_GET_DEST_EXTEN_NOT_FOUND:
 	default:
 		ast_log(LOG_NOTICE, "Call from '%s' (%s:%s:%d) to extension '%s' rejected because extension not found in context '%s'.\n",
 			ast_sorcery_object_get_id(invite->session->endpoint), invite->rdata->tp_info.transport->type_name, invite->rdata->pkt_info.src_name,
@@ -2073,17 +2163,34 @@ static int new_invite(void *data)
 		} else  {
 			pjsip_inv_terminate(invite->session->inv_session, 404, PJ_TRUE);
 		}
-		return 0;
+		goto end;
 	};
 
-	if ((sdp_info = pjsip_rdata_get_sdp_info(invite->rdata)) && (sdp_info->sdp_err == PJ_SUCCESS) && sdp_info->sdp) {
+	pjsip_timer_setting_default(&timer);
+	timer.min_se = invite->session->endpoint->extensions.timer.min_se;
+	timer.sess_expires = invite->session->endpoint->extensions.timer.sess_expires;
+	pjsip_timer_init_session(invite->session->inv_session, &timer);
+
+	/*
+	 * At this point, we've verified what we can that won't take awhile,
+	 * so let's go ahead and send a 100 Trying out to stop any
+	 * retransmissions.
+	 */
+	if (pjsip_inv_initial_answer(invite->session->inv_session, invite->rdata, 100, NULL, NULL, &tdata) != PJ_SUCCESS) {
+		pjsip_inv_terminate(invite->session->inv_session, 500, PJ_TRUE);
+		goto end;
+	}
+	ast_sip_session_send_response(invite->session, tdata);
+
+	sdp_info = pjsip_rdata_get_sdp_info(invite->rdata);
+	if (sdp_info && (sdp_info->sdp_err == PJ_SUCCESS) && sdp_info->sdp) {
 		if (handle_incoming_sdp(invite->session, sdp_info->sdp)) {
-			if (pjsip_inv_initial_answer(invite->session->inv_session, invite->rdata, 488, NULL, NULL, &tdata) == PJ_SUCCESS) {
+			tdata = NULL;
+			if (pjsip_inv_end_session(invite->session->inv_session, 488, NULL, &tdata) == PJ_SUCCESS
+				&& tdata) {
 				ast_sip_session_send_response(invite->session, tdata);
-			} else  {
-				pjsip_inv_terminate(invite->session->inv_session, 488, PJ_TRUE);
 			}
-			return 0;
+			goto end;
 		}
 		/* We are creating a local SDP which is an answer to their offer */
 		local = create_local_sdp(invite->session->inv_session, invite->session, sdp_info->sdp);
@@ -2094,34 +2201,26 @@ static int new_invite(void *data)
 
 	/* If we were unable to create a local SDP terminate the session early, it won't go anywhere */
 	if (!local) {
-		if (pjsip_inv_initial_answer(invite->session->inv_session, invite->rdata, 500, NULL, NULL, &tdata) == PJ_SUCCESS) {
+		tdata = NULL;
+		if (pjsip_inv_end_session(invite->session->inv_session, 500, NULL, &tdata) == PJ_SUCCESS
+			&& tdata) {
 			ast_sip_session_send_response(invite->session, tdata);
-		} else  {
-			pjsip_inv_terminate(invite->session->inv_session, 500, PJ_TRUE);
 		}
-		return 0;
-	} else {
-		pjsip_inv_set_local_sdp(invite->session->inv_session, local);
-		pjmedia_sdp_neg_set_prefer_remote_codec_order(invite->session->inv_session->neg, PJ_FALSE);
-#ifdef PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS
-		pjmedia_sdp_neg_set_answer_multiple_codecs(invite->session->inv_session->neg, PJ_TRUE);
-#endif
+		goto end;
 	}
 
-	pjsip_timer_setting_default(&timer);
-	timer.min_se = invite->session->endpoint->extensions.timer.min_se;
-	timer.sess_expires = invite->session->endpoint->extensions.timer.sess_expires;
-	pjsip_timer_init_session(invite->session->inv_session, &timer);
-
-	/* At this point, we've verified what we can, so let's go ahead and send a 100 Trying out */
-	if (pjsip_inv_initial_answer(invite->session->inv_session, invite->rdata, 100, NULL, NULL, &tdata) != PJ_SUCCESS) {
-		pjsip_inv_terminate(invite->session->inv_session, 500, PJ_TRUE);
-		return 0;
-	}
-	ast_sip_session_send_response(invite->session, tdata);
+	pjsip_inv_set_local_sdp(invite->session->inv_session, local);
+	pjmedia_sdp_neg_set_prefer_remote_codec_order(invite->session->inv_session->neg, PJ_FALSE);
+#ifdef PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS
+	pjmedia_sdp_neg_set_answer_multiple_codecs(invite->session->inv_session->neg, PJ_TRUE);
+#endif
 
-	handle_incoming_request(invite->session, invite->rdata, PJSIP_EVENT_RX_MSG);
+	handle_incoming_request(invite->session, invite->rdata);
 
+end:
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	pjsip_inv_dec_ref(invite->session->inv_session);
+#endif
 	return 0;
 }
 
@@ -2132,7 +2231,7 @@ static void handle_new_invite_request(pj
 	pjsip_tx_data *tdata = NULL;
 	pjsip_inv_session *inv_session = NULL;
 	struct ast_sip_session *session;
-	struct new_invite *invite;
+	struct new_invite invite;
 
 	ast_assert(endpoint != NULL);
 
@@ -2142,25 +2241,44 @@ static void handle_new_invite_request(pj
 		return;
 	}
 
-	session = ast_sip_session_alloc(endpoint, NULL, inv_session);
-	if (!session) {
-		if (pjsip_inv_initial_answer(inv_session, rdata, 500, NULL, NULL, &tdata) == PJ_SUCCESS) {
-			pjsip_inv_terminate(inv_session, 500, PJ_FALSE);
-		} else {
-			internal_pjsip_inv_send_msg(inv_session, endpoint->transport, tdata);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+	if (pjsip_inv_add_ref(inv_session) != PJ_SUCCESS) {
+		ast_log(LOG_ERROR, "Can't increase the session reference counter\n");
+		if (inv_session->state != PJSIP_INV_STATE_DISCONNECTED) {
+			if (pjsip_inv_initial_answer(inv_session, rdata, 500, NULL, NULL, &tdata) == PJ_SUCCESS) {
+				pjsip_inv_terminate(inv_session, 500, PJ_FALSE);
+			} else {
+				pjsip_inv_send_msg(inv_session, tdata);
+			}
 		}
 		return;
 	}
+#endif
 
-	invite = new_invite_alloc(session, rdata);
-	if (!invite || ast_sip_push_task(session->serializer, new_invite, invite)) {
+	session = ast_sip_session_alloc(endpoint, NULL, inv_session, rdata);
+	if (!session) {
 		if (pjsip_inv_initial_answer(inv_session, rdata, 500, NULL, NULL, &tdata) == PJ_SUCCESS) {
 			pjsip_inv_terminate(inv_session, 500, PJ_FALSE);
 		} else {
-			internal_pjsip_inv_send_msg(inv_session, endpoint->transport, tdata);
+			pjsip_inv_send_msg(inv_session, tdata);
 		}
-		ao2_cleanup(invite);
+#ifdef HAVE_PJSIP_INV_SESSION_REF
+		pjsip_inv_dec_ref(inv_session);
+#endif
+		return;
 	}
+
+	/*
+	 * The current thread is supposed be the session serializer to prevent
+	 * any initial INVITE retransmissions from trying to setup the same
+	 * call again.
+	 */
+	ast_assert(ast_taskprocessor_is_task(session->serializer));
+
+	invite.session = session;
+	invite.rdata = rdata;
+	new_invite(&invite);
+
 	ao2_ref(session, -1);
 }
 
@@ -2201,13 +2319,14 @@ static pj_bool_t has_supplement(const st
  * 2) An in-dialog request that the inv_session layer does not
  *    handle is received (such as an in-dialog INFO)
  *
- * In all cases, there is very little we actually do in this function
+ * Except for INVITEs, there is very little we actually do in this function
  * 1) For requests we don't handle, we return PJ_FALSE
- * 2) For new INVITEs, throw the work into the SIP threadpool to be done
- *    there to free up the thread(s) handling incoming requests
- * 3) For in-dialog requests we handle, we defer handling them until the
- *    on_inv_state_change() callback instead (where we will end up putting
- *    them into the threadpool).
+ * 2) For new INVITEs, handle them now to prevent retransmissions from
+ *    trying to setup the same call again.
+ * 3) For in-dialog requests we handle, we process them in the
+ *    .on_state_changed = session_inv_on_state_changed or
+ *    .on_tsx_state_changed = session_inv_on_tsx_state_changed
+ *    callbacks instead.
  */
 static pj_bool_t session_on_rx_request(pjsip_rx_data *rdata)
 {
@@ -2292,7 +2411,8 @@ static void reschedule_reinvite(struct a
 
 static void __print_debug_details(const char *function, pjsip_inv_session *inv, pjsip_transaction *tsx, pjsip_event *e)
 {
-	struct ast_sip_session *session;
+	int id = session_module.id;
+	struct ast_sip_session *session = NULL;
 
 	if (!DEBUG_ATLEAST(5)) {
 		/* Debug not spamy enough */
@@ -2307,7 +2427,9 @@ static void __print_debug_details(const
 			pjsip_tsx_state_str(tsx->state));
 		return;
 	}
-	session = inv->mod_data[session_module.id];
+	if (id > -1) {
+		session = inv->mod_data[session_module.id];
+	}
 	if (!session) {
 		ast_log(LOG_DEBUG, "inv_session %p has no ast session\n", inv);
 	} else {
@@ -2338,7 +2460,7 @@ static void __print_debug_details(const
 
 #define print_debug_details(inv, tsx, e) __print_debug_details(__PRETTY_FUNCTION__, (inv), (tsx), (e))
 
-static void handle_incoming_request(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_event_id_e type)
+static void handle_incoming_request(struct ast_sip_session *session, pjsip_rx_data *rdata)
 {
 	struct ast_sip_session_supplement *supplement;
 	struct pjsip_request_line req = rdata->msg_info.msg->line.req;
@@ -2353,7 +2475,7 @@ static void handle_incoming_request(stru
 	}
 }
 
-static void handle_incoming_response(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_event_id_e type,
+static void handle_incoming_response(struct ast_sip_session *session, pjsip_rx_data *rdata,
 		enum ast_sip_session_response_priority response_priority)
 {
 	struct ast_sip_session_supplement *supplement;
@@ -2372,16 +2494,16 @@ static void handle_incoming_response(str
 	}
 }
 
-static int handle_incoming(struct ast_sip_session *session, pjsip_rx_data *rdata, pjsip_event_id_e type,
+static int handle_incoming(struct ast_sip_session *session, pjsip_rx_data *rdata,
 		enum ast_sip_session_response_priority response_priority)
 {
 	ast_debug(3, "Received %s\n", rdata->msg_info.msg->type == PJSIP_REQUEST_MSG ?
 			"request" : "response");
 
 	if (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG) {
-		handle_incoming_request(session, rdata, type);
+		handle_incoming_request(session, rdata);
 	} else {
-		handle_incoming_response(session, rdata, type, response_priority);
+		handle_incoming_response(session, rdata, response_priority);
 	}
 
 	return 0;
@@ -2416,19 +2538,9 @@ static void handle_outgoing_response(str
 	}
 }
 
-static void handle_outgoing(struct ast_sip_session *session, pjsip_tx_data *tdata)
-{
-	ast_debug(3, "Sending %s\n", tdata->msg->type == PJSIP_REQUEST_MSG ?
-			"request" : "response");
-	if (tdata->msg->type == PJSIP_REQUEST_MSG) {
-		handle_outgoing_request(session, tdata);
-	} else {
-		handle_outgoing_response(session, tdata);
-	}
-}
-
-static void session_end(struct ast_sip_session *session)
+static int session_end(void *vsession)
 {
+	struct ast_sip_session *session = vsession;
 	struct ast_sip_session_supplement *iter;
 
 	/* Stop the scheduled termination */
@@ -2440,6 +2552,7 @@ static void session_end(struct ast_sip_s
 			iter->session_end(session);
 		}
 	}
+	return 0;
 }
 
 /*!
@@ -2464,6 +2577,36 @@ static int session_end_completion(void *
 	return 0;
 }
 
+static void handle_incoming_before_media(pjsip_inv_session *inv,
+	struct ast_sip_session *session, pjsip_rx_data *rdata)
+{
+	pjsip_msg *msg;
+
+	handle_incoming(session, rdata, AST_SIP_SESSION_BEFORE_MEDIA);
+	msg = rdata->msg_info.msg;
+	if (msg->type == PJSIP_REQUEST_MSG
+		&& msg->line.req.method.id == PJSIP_ACK_METHOD
+		&& pjmedia_sdp_neg_get_state(inv->neg) != PJMEDIA_SDP_NEG_STATE_DONE) {
+		pjsip_tx_data *tdata;
+
+		/*
+		 * SDP negotiation failed on an incoming call that delayed
+		 * negotiation and then gave us an invalid SDP answer.  We
+		 * need to send a BYE to end the call because of the invalid
+		 * SDP answer.
+		 */
+		ast_debug(1,
+			"Endpoint '%s(%s)': Ending session due to incomplete SDP negotiation.  %s\n",
+			ast_sorcery_object_get_id(session->endpoint),
+			session->channel ? ast_channel_name(session->channel) : "",
+			pjsip_rx_data_get_info(rdata));
+		if (pjsip_inv_end_session(inv, 400, NULL, &tdata) == PJ_SUCCESS
+			&& tdata) {
+			ast_sip_session_send_request(session, tdata);
+		}
+	}
+}
+
 static void session_inv_on_state_changed(pjsip_inv_session *inv, pjsip_event *e)
 {
 	struct ast_sip_session *session = inv->mod_data[session_module.id];
@@ -2482,22 +2625,18 @@ static void session_inv_on_state_changed
 
 	switch(type) {
 	case PJSIP_EVENT_TX_MSG:
-		handle_outgoing(session, e->body.tx_msg.tdata);
 		break;
 	case PJSIP_EVENT_RX_MSG:
-		handle_incoming(session, e->body.rx_msg.rdata, type,
-				AST_SIP_SESSION_BEFORE_MEDIA);
+		handle_incoming_before_media(inv, session, e->body.rx_msg.rdata);
 		break;
 	case PJSIP_EVENT_TSX_STATE:
 		ast_debug(3, "Source of transaction state change is %s\n", pjsip_event_str(e->body.tsx_state.type));
 		/* Transaction state changes are prompted by some other underlying event. */
 		switch(e->body.tsx_state.type) {
 		case PJSIP_EVENT_TX_MSG:
-			handle_outgoing(session, e->body.tsx_state.src.tdata);
 			break;
 		case PJSIP_EVENT_RX_MSG:
-			handle_incoming(session, e->body.tsx_state.src.rdata, type,
-					AST_SIP_SESSION_BEFORE_MEDIA);
+			handle_incoming_before_media(inv, session, e->body.tsx_state.src.rdata);
 			break;
 		case PJSIP_EVENT_TRANSPORT_ERROR:
 		case PJSIP_EVENT_TIMER:
@@ -2517,7 +2656,16 @@ static void session_inv_on_state_changed
 	}
 
 	if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
-		session_end(session);
+		if (session->defer_end) {
+			ast_debug(3, "Deferring session (%p) end\n", session);
+			session->ended_while_deferred = 1;
+			return;
+		}
+
+		if (ast_sip_push_task(session->serializer, session_end, session)) {
+			/* Do it anyway even though this is not the right thread. */
+			session_end(session);
+		}
 	}
 }
 
@@ -2529,9 +2677,22 @@ static void session_inv_on_new_session(p
 static void session_inv_on_tsx_state_changed(pjsip_inv_session *inv, pjsip_transaction *tsx, pjsip_event *e)
 {
 	ast_sip_session_response_cb cb;
-	struct ast_sip_session *session = inv->mod_data[session_module.id];
+	int id = session_module.id;
+	struct ast_sip_session *session;
 	pjsip_tx_data *tdata;
 
+	/*
+	 * A race condition exists at shutdown where the res_pjsip_session can be
+	 * unloaded but this callback may still get called afterwards. In this case
+	 * the id may end up being -1 which is useless to us. To work around this
+	 * we store the current value and check/use it.
+	 */
+	if (id < 0) {
+		return;
+	}
+
+	session = inv->mod_data[id];
+
 	print_debug_details(inv, tsx, e);
 	if (!session) {
 		/* The session has ended.  Ignore the transaction change. */
@@ -2539,16 +2700,15 @@ static void session_inv_on_tsx_state_cha
 	}
 	switch (e->body.tsx_state.type) {
 	case PJSIP_EVENT_TX_MSG:
-		handle_outgoing(session, e->body.tsx_state.src.tdata);
 		/* When we create an outgoing request, we do not have access to the transaction that
 		 * is created. Instead, We have to place transaction-specific data in the tdata. Here,
 		 * we transfer the data into the transaction. This way, when we receive a response, we
 		 * can dig this data out again
 		 */
-		tsx->mod_data[session_module.id] = e->body.tsx_state.src.tdata->mod_data[session_module.id];
+		tsx->mod_data[id] = e->body.tsx_state.src.tdata->mod_data[id];
 		break;
 	case PJSIP_EVENT_RX_MSG:
-		cb = ast_sip_mod_data_get(tsx->mod_data, session_module.id, MOD_DATA_ON_RESPONSE);
+		cb = ast_sip_mod_data_get(tsx->mod_data, id, MOD_DATA_ON_RESPONSE);
 		/* As the PJSIP invite session implementation responds with a 200 OK before we have a
 		 * chance to be invoked session supplements for BYE requests actually end up executing
 		 * in the invite session state callback as well. To prevent session supplements from
@@ -2556,8 +2716,8 @@ static void session_inv_on_tsx_state_cha
 		 */
 		if ((e->body.tsx_state.src.rdata->msg_info.msg->type != PJSIP_REQUEST_MSG) ||
 			(tsx->method.id != PJSIP_BYE_METHOD)) {
-			handle_incoming(session, e->body.tsx_state.src.rdata, e->type,
-							AST_SIP_SESSION_AFTER_MEDIA);
+			handle_incoming(session, e->body.tsx_state.src.rdata,
+				AST_SIP_SESSION_AFTER_MEDIA);
 		}
 		if (tsx->method.id == PJSIP_INVITE_METHOD) {
 			if (tsx->role == PJSIP_ROLE_UAC) {
@@ -2580,20 +2740,57 @@ static void session_inv_on_tsx_state_cha
 						}
 						if (tsx->status_code != 488) {
 							/* Other reinvite failures (except 488) result in destroying the session. */
-							if (pjsip_inv_end_session(inv, 500, NULL, &tdata) == PJ_SUCCESS) {
+							if (pjsip_inv_end_session(inv, 500, NULL, &tdata) == PJ_SUCCESS
+								&& tdata) {
 								ast_sip_session_send_request(session, tdata);
 							}
 						}
 					}
 				} else if (tsx->state == PJSIP_TSX_STATE_TERMINATED) {
 					if (inv->cancelling && tsx->status_code == PJSIP_SC_OK) {
-						/* This is a race condition detailed in RFC 5407 section 3.1.2.
-						 * We sent a CANCEL at the same time that the UAS sent us a 200 OK for
-						 * the original INVITE. As a result, we have now received a 200 OK for
-						 * a cancelled call. Our role is to immediately send a BYE to end the
-						 * dialog.
+						int sdp_negotiation_done =
+							pjmedia_sdp_neg_get_state(inv->neg) == PJMEDIA_SDP_NEG_STATE_DONE;
+
+						/*
+						 * We can get here for the following reasons.
+						 *
+						 * 1) The race condition detailed in RFC5407 section 3.1.2.
+						 * We sent a CANCEL at the same time that the UAS sent us a
+						 * 200 OK with a valid SDP for the original INVITE.  As a
+						 * result, we have now received a 200 OK for a cancelled
+						 * call and the SDP negotiation is complete.  We need to
+						 * immediately send a BYE to end the dialog.
+						 *
+						 * 2) We sent a CANCEL and hit the race condition but the
+						 * UAS sent us an invalid SDP with the 200 OK.  In this case
+						 * the SDP negotiation is incomplete and PJPROJECT has
+						 * already sent the BYE for us because of the invalid SDP.
+						 *
+						 * 3) We didn't send a CANCEL but the UAS sent us an invalid
+						 * SDP with the 200 OK.  In this case the SDP negotiation is
+						 * incomplete and PJPROJECT has already sent the BYE for us
+						 * because of the invalid SDP.
 						 */
-						if (pjsip_inv_end_session(inv, 500, NULL, &tdata) == PJ_SUCCESS) {
+						ast_test_suite_event_notify("PJSIP_SESSION_CANCELED",
+							"Endpoint: %s\r\n"
+							"Channel: %s\r\n"
+							"Message: %s\r\n"
+							"SDP: %s",
+							ast_sorcery_object_get_id(session->endpoint),
+							session->channel ? ast_channel_name(session->channel) : "",
+							pjsip_rx_data_get_info(e->body.tsx_state.src.rdata),
+							sdp_negotiation_done ? "complete" : "incomplete");
+						if (!sdp_negotiation_done) {
+							ast_debug(1, "Endpoint '%s(%s)': Incomplete SDP negotiation cancelled session.  %s\n",
+								ast_sorcery_object_get_id(session->endpoint),
+								session->channel ? ast_channel_name(session->channel) : "",
+								pjsip_rx_data_get_info(e->body.tsx_state.src.rdata));
+						} else if (pjsip_inv_end_session(inv, 500, NULL, &tdata) == PJ_SUCCESS
+							&& tdata) {
+							ast_debug(1, "Endpoint '%s(%s)': Ending session due to RFC5407 race condition.  %s\n",
+								ast_sorcery_object_get_id(session->endpoint),
+								session->channel ? ast_channel_name(session->channel) : "",
+								pjsip_rx_data_get_info(e->body.tsx_state.src.rdata));
 							ast_sip_session_send_request(session, tdata);
 						}
 					}
@@ -2623,22 +2820,25 @@ static void session_inv_on_tsx_state_cha
 		}
 		break;
 	case PJSIP_EVENT_TRANSPORT_ERROR:
-		/*
-		 * Clear the module data now to block session_inv_on_state_changed()
-		 * from calling session_end() if it hasn't already done so.
-		 */
-		inv->mod_data[session_module.id] = NULL;
+		if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
+			/*
+			 * Clear the module data now to block session_inv_on_state_changed()
+			 * from calling session_end() if it hasn't already done so.
+			 */
+			inv->mod_data[id] = NULL;
 
-		if (inv->state != PJSIP_INV_STATE_DISCONNECTED) {
-			session_end(session);
+			/*
+			 * Pass the session ref held by session->inv_session to
+			 * session_end_completion().
+			 */
+			if (session
+				&& ast_sip_push_task(session->serializer, session_end_completion, session)) {
+				/* Do it anyway even though this is not the right thread. */
+				session_end_completion(session);
+			}
+			return;
 		}
-
-		/*
-		 * Pass the session ref held by session->inv_session to
-		 * session_end_completion().
-		 */
-		session_end_completion(session);
-		return;
+		break;
 	case PJSIP_EVENT_TIMER:
 		/*
 		 * The timer event is run by the pjsip monitor thread and not
@@ -2650,15 +2850,16 @@ static void session_inv_on_tsx_state_cha
 			 * the dialog locked to get the session by other threads.
 			 */
 			pjsip_dlg_inc_lock(inv->dlg);
-			session = inv->mod_data[session_module.id];
-			inv->mod_data[session_module.id] = NULL;
+			session = inv->mod_data[id];
+			inv->mod_data[id] = NULL;
 			pjsip_dlg_dec_lock(inv->dlg);
 
 			/*
 			 * Pass the session ref held by session->inv_session to
 			 * session_end_completion().
 			 */
-			if (ast_sip_push_task(session->serializer, session_end_completion, session)) {
+			if (session
+				&& ast_sip_push_task(session->serializer, session_end_completion, session)) {
 				/* Do it anyway even though this is not the right thread. */
 				session_end_completion(session);
 			}
@@ -2759,7 +2960,12 @@ static struct pjmedia_sdp_session *creat
 	static const pj_str_t STR_IP6 = { "IP6", 3 };
 	pjmedia_sdp_session *local;
 
-	if (!(local = PJ_POOL_ZALLOC_T(inv->pool_prov, pjmedia_sdp_session))) {
+	if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
+		ast_log(LOG_ERROR, "Failed to create session SDP. Session has been already disconnected\n");
+		return NULL;
+	}
+
+	if (!inv->pool_prov || !(local = PJ_POOL_ZALLOC_T(inv->pool_prov, pjmedia_sdp_session))) {
 		return NULL;
 	}
 
@@ -2880,8 +3086,7 @@ static pjsip_redirect_op session_inv_on_
 		return PJSIP_REDIRECT_STOP;
 	}
 
-	handle_incoming(session, e->body.rx_msg.rdata, PJSIP_EVENT_RX_MSG,
-			AST_SIP_SESSION_BEFORE_REDIRECTING);
+	handle_incoming(session, e->body.rx_msg.rdata, AST_SIP_SESSION_BEFORE_REDIRECTING);
 
 	uri = pjsip_uri_get_uri(target);
 
@@ -2889,6 +3094,13 @@ static pjsip_redirect_op session_inv_on_
 		char exten[AST_MAX_EXTENSION];
 
 		ast_copy_pj_str(exten, &uri->user, sizeof(exten));
+
+		/*
+		 * We may want to match in the dialplan without any user
+		 * options getting in the way.
+		 */
+		AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(exten);
+
 		ast_channel_call_forward_set(session->channel, exten);
 	} else if (session->endpoint->redirect_method == AST_SIP_REDIRECT_URI_CORE) {
 		char target_uri[PJSIP_MAX_URL_SIZE];
@@ -2936,7 +3148,9 @@ static void session_outgoing_nat_hook(pj
 		ast_copy_pj_str(host, &sdp->conn->addr, sizeof(host));
 		ast_sockaddr_parse(&addr, host, PARSE_PORT_FORBID);
 
-		if (ast_apply_ha(transport_state->localnet, &addr) != AST_SENSE_ALLOW) {
+		if (!transport_state->localnet
+			|| ast_apply_ha(transport_state->localnet, &addr) != AST_SENSE_ALLOW) {
+			ast_debug(5, "Setting external media address to %s\n", transport->external_media_address);
 			pj_strdup2(tdata->pool, &sdp->conn->addr, transport->external_media_address);
 		}
 	}
diff -urpN asterisk-13.9.1/res/res_pjsip_session.exports.in asterisk-13.17.0/res/res_pjsip_session.exports.in
--- asterisk-13.9.1/res/res_pjsip_session.exports.in	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_session.exports.in	2017-07-12 13:12:08.000000000 +0200
@@ -3,6 +3,7 @@
 		LINKER_SYMBOL_PREFIXast_sip_session_terminate;
 		LINKER_SYMBOL_PREFIXast_sip_session_defer_termination;
 		LINKER_SYMBOL_PREFIXast_sip_session_defer_termination_cancel;
+		LINKER_SYMBOL_PREFIXast_sip_session_end_if_deferred;
 		LINKER_SYMBOL_PREFIXast_sip_session_register_sdp_handler;
 		LINKER_SYMBOL_PREFIXast_sip_session_unregister_sdp_handler;
 		LINKER_SYMBOL_PREFIXast_sip_session_register_supplement;
diff -urpN asterisk-13.9.1/res/res_pjsip_t38.c asterisk-13.17.0/res/res_pjsip_t38.c
--- asterisk-13.9.1/res/res_pjsip_t38.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_t38.c	2017-07-12 13:12:08.000000000 +0200
@@ -44,6 +44,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/netsock2.h"
 #include "asterisk/channel.h"
 #include "asterisk/acl.h"
+#include "asterisk/utils.h"
 
 #include "asterisk/res_pjsip.h"
 #include "asterisk/res_pjsip_session.h"
@@ -51,11 +52,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 /*! \brief The number of seconds after receiving a T.38 re-invite before automatically rejecting it */
 #define T38_AUTOMATIC_REJECTION_SECONDS 5
 
-/*! \brief Address for IPv4 UDPTL */
-static struct ast_sockaddr address_ipv4;
-
-/*! \brief Address for IPv6 UDPTL */
-static struct ast_sockaddr address_ipv6;
+/*! \brief Address for UDPTL */
+static struct ast_sockaddr address;
 
 /*! \brief T.38 state information */
 struct t38_state {
@@ -259,8 +257,7 @@ static int t38_initialize_session(struct
 		return 0;
 	}
 
-	if (!(session_media->udptl = ast_udptl_new_with_bindaddr(NULL, NULL, 0,
-		session->endpoint->media.t38.ipv6 ? &address_ipv6 : &address_ipv4))) {
+	if (!(session_media->udptl = ast_udptl_new_with_bindaddr(NULL, NULL, 0, &address))) {
 		return -1;
 	}
 
@@ -281,7 +278,7 @@ static int t38_reinvite_sdp_cb(struct as
 	/* Move the image media stream to the front and have it as the only stream, pjmedia will fill in
 	 * dummy streams for the rest
 	 */
-	for (stream = 0; stream < sdp->media_count++; ++stream) {
+	for (stream = 0; stream < sdp->media_count; ++stream) {
 		if (!pj_strcmp2(&sdp->media[stream]->desc.media, "image")) {
 			sdp->media[0] = sdp->media[stream];
 			sdp->media_count = 1;
@@ -361,7 +358,9 @@ static int t38_interpret_parameters(void
 			ast_udptl_set_local_max_ifp(session_media->udptl, state->our_parms.max_ifp);
 			t38_change_state(data->session, session_media, state, T38_ENABLED);
 			ast_sip_session_resume_reinvite(data->session);
-		} else if (data->session->t38state != T38_ENABLED) {
+		} else if ((data->session->t38state != T38_ENABLED) ||
+				((data->session->t38state == T38_ENABLED) &&
+                                (parameters->request_response == AST_T38_REQUEST_NEGOTIATE))) {
 			if (t38_initialize_session(data->session, session_media)) {
 				break;
 			}
@@ -401,7 +400,8 @@ static int t38_interpret_parameters(void
 }
 
 /*! \brief Frame hook callback for writing */
-static struct ast_frame *t38_framehook_write(struct ast_sip_session *session, struct ast_frame *f)
+static struct ast_frame *t38_framehook_write(struct ast_channel *chan,
+	struct ast_sip_session *session, struct ast_frame *f)
 {
 	if (f->frametype == AST_FRAME_CONTROL && f->subclass.integer == AST_CONTROL_T38_PARAMETERS &&
 		session->endpoint->media.t38.enabled) {
@@ -415,27 +415,36 @@ static struct ast_frame *t38_framehook_w
 			ao2_ref(data, -1);
 		}
 	} else if (f->frametype == AST_FRAME_MODEM) {
-		RAII_VAR(struct ast_sip_session_media *, session_media, NULL, ao2_cleanup);
+		struct ast_sip_session_media *session_media;
 
-		if ((session_media = ao2_find(session->media, "image", OBJ_KEY)) &&
-			session_media->udptl) {
+		/* Avoid deadlock between chan and the session->media container lock */
+		ast_channel_unlock(chan);
+		session_media = ao2_find(session->media, "image", OBJ_SEARCH_KEY);
+		ast_channel_lock(chan);
+		if (session_media && session_media->udptl) {
 			ast_udptl_write(session_media->udptl, f);
 		}
+		ao2_cleanup(session_media);
 	}
 
 	return f;
 }
 
 /*! \brief Frame hook callback for reading */
-static struct ast_frame *t38_framehook_read(struct ast_sip_session *session, struct ast_frame *f)
+static struct ast_frame *t38_framehook_read(struct ast_channel *chan,
+	struct ast_sip_session *session, struct ast_frame *f)
 {
 	if (ast_channel_fdno(session->channel) == 5) {
-		RAII_VAR(struct ast_sip_session_media *, session_media, NULL, ao2_cleanup);
+		struct ast_sip_session_media *session_media;
 
-		if ((session_media = ao2_find(session->media, "image", OBJ_KEY)) &&
-			session_media->udptl) {
+		/* Avoid deadlock between chan and the session->media container lock */
+		ast_channel_unlock(chan);
+		session_media = ao2_find(session->media, "image", OBJ_SEARCH_KEY);
+		ast_channel_lock(chan);
+		if (session_media && session_media->udptl) {
 			f = ast_udptl_read(session_media->udptl);
 		}
+		ao2_cleanup(session_media);
 	}
 
 	return f;
@@ -448,9 +457,9 @@ static struct ast_frame *t38_framehook(s
 	struct ast_sip_channel_pvt *channel = ast_channel_tech_pvt(chan);
 
 	if (event == AST_FRAMEHOOK_EVENT_READ) {
-		f = t38_framehook_read(channel->session, f);
+		f = t38_framehook_read(chan, channel->session, f);
 	} else if (event == AST_FRAMEHOOK_EVENT_WRITE) {
-		f = t38_framehook_write(channel->session, f);
+		f = t38_framehook_write(chan, channel->session, f);
 	}
 
 	return f;
@@ -499,25 +508,27 @@ static void t38_attach_framehook(struct
 		return;
 	}
 
-	/* Skip attaching the framehook if the T.38 datastore already exists for the channel */
 	ast_channel_lock(session->channel);
-	if ((datastore = ast_channel_datastore_find(session->channel, &t38_framehook_datastore, NULL))) {
+
+	/* Skip attaching the framehook if the T.38 datastore already exists for the channel */
+	datastore = ast_channel_datastore_find(session->channel, &t38_framehook_datastore,
+		NULL);
+	if (datastore) {
 		ast_channel_unlock(session->channel);
 		return;
 	}
-	ast_channel_unlock(session->channel);
 
 	framehook_id = ast_framehook_attach(session->channel, &hook);
 	if (framehook_id < 0) {
-		ast_log(LOG_WARNING, "Could not attach T.38 Frame hook to channel, T.38 will be unavailable on '%s'\n",
+		ast_log(LOG_WARNING, "Could not attach T.38 Frame hook, T.38 will be unavailable on '%s'\n",
 			ast_channel_name(session->channel));
+		ast_channel_unlock(session->channel);
 		return;
 	}
 
-	ast_channel_lock(session->channel);
 	datastore = ast_datastore_alloc(&t38_framehook_datastore, NULL);
 	if (!datastore) {
-		ast_log(LOG_ERROR, "Could not attach T.38 Frame hook to channel, T.38 will be unavailable on '%s'\n",
+		ast_log(LOG_ERROR, "Could not alloc T.38 Frame hook datastore, T.38 will be unavailable on '%s'\n",
 			ast_channel_name(session->channel));
 		ast_framehook_detach(session->channel, framehook_id);
 		ast_channel_unlock(session->channel);
@@ -868,10 +879,11 @@ static void change_outgoing_sdp_stream_m
 	ast_sockaddr_parse(&addr, host, PARSE_PORT_FORBID);
 
 	/* Is the address within the SDP inside the same network? */
-	if (ast_apply_ha(transport_state->localnet, &addr) == AST_SENSE_ALLOW) {
+	if (transport_state->localnet
+		&& ast_apply_ha(transport_state->localnet, &addr) == AST_SENSE_ALLOW) {
 		return;
 	}
-
+	ast_debug(5, "Setting media address to %s\n", transport->external_media_address);
 	pj_strdup2(tdata->pool, &stream->conn->addr, transport->external_media_address);
 }
 
@@ -918,8 +930,11 @@ static int load_module(void)
 {
 	CHECK_PJSIP_SESSION_MODULE_LOADED();
 
-	ast_sockaddr_parse(&address_ipv4, "0.0.0.0", 0);
-	ast_sockaddr_parse(&address_ipv6, "::", 0);
+	if (ast_check_ipv6()) {
+		ast_sockaddr_parse(&address, "::", 0);
+	} else {
+		ast_sockaddr_parse(&address, "0.0.0.0", 0);
+	}
 
 	if (ast_sip_session_register_supplement(&t38_supplement)) {
 		ast_log(LOG_ERROR, "Unable to register T.38 session supplement\n");
@@ -935,7 +950,7 @@ static int load_module(void)
 end:
 	unload_module();
 
-	return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_DECLINE;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP T.38 UDPTL Support",
diff -urpN asterisk-13.9.1/res/res_pjsip_transport_management.c asterisk-13.17.0/res/res_pjsip_transport_management.c
--- asterisk-13.9.1/res/res_pjsip_transport_management.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_transport_management.c	2017-07-12 13:12:08.000000000 +0200
@@ -42,7 +42,7 @@
 static const pj_str_t keepalive_packet = { "\r\n\r\n", 4 };
 
 /*! \brief Global container of active transports */
-static struct ao2_container *transports;
+static AO2_GLOBAL_OBJ_STATIC(monitored_transports);
 
 /*! \brief Scheduler context for timing out connections with no data received */
 static struct ast_sched_context *sched;
@@ -84,6 +84,7 @@ static int keepalive_transport_cb(void *
 /*! \brief Thread which sends keepalives to all active connection-oriented transports */
 static void *keepalive_transport_thread(void *data)
 {
+	struct ao2_container *transports;
 	pj_thread_desc desc;
 	pj_thread_t *thread;
 
@@ -92,6 +93,11 @@ static void *keepalive_transport_thread(
 		return NULL;
 	}
 
+	transports = ao2_global_obj_ref(monitored_transports);
+	if (!transports) {
+		return NULL;
+	}
+
 	/* Once loaded this module just keeps on going as it is unsafe to stop and change the underlying
 	 * callback for the transport manager.
 	 */
@@ -100,6 +106,7 @@ static void *keepalive_transport_thread(
 		ao2_callback(transports, OBJ_NODATA, keepalive_transport_cb, NULL);
 	}
 
+	ao2_ref(transports, -1);
 	return NULL;
 }
 
@@ -108,7 +115,6 @@ AST_THREADSTORAGE(desc_storage);
 static int idle_sched_cb(const void *data)
 {
 	struct monitored_transport *keepalive = (struct monitored_transport *) data;
-	int sip_received = ast_atomic_fetchadd_int(&keepalive->sip_received, 0);
 
 	if (!pj_thread_is_registered()) {
 		pj_thread_t *thread;
@@ -126,9 +132,9 @@ static int idle_sched_cb(const void *dat
 		pj_thread_register("Transport Monitor", *desc, &thread);
 	}
 
-	if (!sip_received) {
+	if (!keepalive->sip_received) {
 		ast_log(LOG_NOTICE, "Shutting down transport '%s' since no request was received in %d seconds\n",
-				keepalive->transport->info, IDLE_TIMEOUT);
+				keepalive->transport->info, IDLE_TIMEOUT / 1000);
 		pjsip_transport_shutdown(keepalive->transport);
 	}
 
@@ -148,23 +154,30 @@ static void monitored_transport_destroy(
 static void monitored_transport_state_callback(pjsip_transport *transport, pjsip_transport_state state,
 	const pjsip_transport_state_info *info)
 {
+	struct ao2_container *transports;
+
 	/* We only care about reliable transports */
-	if (PJSIP_TRANSPORT_IS_RELIABLE(transport) &&
-			(transport->dir == PJSIP_TP_DIR_INCOMING || keepalive_interval)) {
+	if (PJSIP_TRANSPORT_IS_RELIABLE(transport)
+		&& (transport->dir == PJSIP_TP_DIR_INCOMING || keepalive_interval)
+		&& (transports = ao2_global_obj_ref(monitored_transports))) {
 		struct monitored_transport *monitored;
 
 		switch (state) {
 		case PJSIP_TP_STATE_CONNECTED:
-			monitored = ao2_alloc(sizeof(*monitored), monitored_transport_destroy);
+			monitored = ao2_alloc_options(sizeof(*monitored),
+				monitored_transport_destroy, AO2_ALLOC_OPT_LOCK_NOLOCK);
 			if (!monitored) {
 				break;
 			}
 			monitored->transport = transport;
 			pjsip_transport_add_ref(monitored->transport);
+
 			ao2_link(transports, monitored);
+
 			if (transport->dir == PJSIP_TP_DIR_INCOMING) {
 				/* Let the scheduler inherit the reference from allocation */
 				if (ast_sched_add_variable(sched, IDLE_TIMEOUT, idle_sched_cb, monitored, 1) < 0) {
+					/* Uh Oh.  Could not schedule the idle check.  Kill the transport. */
 					ao2_unlink(transports, monitored);
 					ao2_ref(monitored, -1);
 					pjsip_transport_shutdown(transport);
@@ -181,6 +194,8 @@ static void monitored_transport_state_ca
 		default:
 			break;
 		}
+
+		ao2_ref(transports, -1);
 	}
 
 	/* Forward to the old state callback if present */
@@ -242,7 +257,7 @@ static int monitored_transport_cmp_fn(vo
 		break;
 	}
 
-	return !cmp ? CMP_MATCH | CMP_STOP : 0;
+	return !cmp ? CMP_MATCH : 0;
 }
 
 static void keepalive_global_loaded(const char *object_type)
@@ -265,8 +280,8 @@ static void keepalive_global_loaded(cons
 
 	if (ast_pthread_create(&keepalive_thread, NULL, keepalive_transport_thread, NULL)) {
 		ast_log(LOG_ERROR, "Could not create thread for sending keepalive messages.\n");
-		ao2_ref(transports, -1);
-		return;
+		keepalive_thread = AST_PTHREADT_NULL;
+		keepalive_interval = 0;
 	}
 }
 
@@ -283,14 +298,21 @@ static struct ast_sorcery_observer keepa
  */
 static pj_bool_t idle_monitor_on_rx_request(pjsip_rx_data *rdata)
 {
+	struct ao2_container *transports;
 	struct monitored_transport *idle_trans;
 
+	transports = ao2_global_obj_ref(monitored_transports);
+	if (!transports) {
+		return PJ_FALSE;
+	}
+
 	idle_trans = ao2_find(transports, rdata->tp_info.transport->obj_name, OBJ_SEARCH_KEY);
+	ao2_ref(transports, -1);
 	if (!idle_trans) {
 		return PJ_FALSE;
 	}
 
-	ast_atomic_fetchadd_int(&idle_trans->sip_received, +1);
+	idle_trans->sip_received = 1;
 	ao2_ref(idle_trans, -1);
 
 	return PJ_FALSE;
@@ -304,35 +326,38 @@ static pjsip_module idle_monitor_module
 
 static int load_module(void)
 {
+	struct ao2_container *transports;
 	pjsip_tpmgr *tpmgr;
 
 	CHECK_PJSIP_MODULE_LOADED();
 
+	tpmgr = pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint());
+	if (!tpmgr) {
+		ast_log(LOG_ERROR, "No transport manager to attach keepalive functionality to.\n");
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
 	transports = ao2_container_alloc(TRANSPORTS_BUCKETS, monitored_transport_hash_fn,
 		monitored_transport_cmp_fn);
 	if (!transports) {
 		ast_log(LOG_ERROR, "Could not create container for transports to perform keepalive on.\n");
 		return AST_MODULE_LOAD_DECLINE;
 	}
-
-	tpmgr = pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint());
-	if (!tpmgr) {
-		ast_log(LOG_ERROR, "No transport manager to attach keepalive functionality to.\n");
-		ao2_ref(transports, -1);
-		return AST_MODULE_LOAD_DECLINE;
-	}
+	ao2_global_obj_replace_unref(monitored_transports, transports);
+	ao2_ref(transports, -1);
 
 	sched = ast_sched_context_create();
 	if (!sched) {
 		ast_log(LOG_ERROR, "Failed to create keepalive scheduler context.\n");
-		ao2_ref(transports, -1);
+		ao2_global_obj_release(monitored_transports);
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_sched_start_thread(sched)) {
 		ast_log(LOG_ERROR, "Failed to start keepalive scheduler thread\n");
 		ast_sched_context_destroy(sched);
-		ao2_ref(transports, -1);
+		sched = NULL;
+		ao2_global_obj_release(monitored_transports);
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -343,25 +368,38 @@ static int load_module(void)
 
 	ast_sorcery_observer_add(ast_sip_get_sorcery(), "global", &keepalive_global_observer);
 	ast_sorcery_reload_object(ast_sip_get_sorcery(), "global");
+
 	ast_module_shutdown_ref(ast_module_info->self);
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
 static int unload_module(void)
 {
-	pjsip_tpmgr *tpmgr = pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint());
+	pjsip_tpmgr *tpmgr;
 
 	if (keepalive_interval) {
 		keepalive_interval = 0;
-		pthread_kill(keepalive_thread, SIGURG);
-		pthread_join(keepalive_thread, NULL);
+		if (keepalive_thread != AST_PTHREADT_NULL) {
+			pthread_kill(keepalive_thread, SIGURG);
+			pthread_join(keepalive_thread, NULL);
+			keepalive_thread = AST_PTHREADT_NULL;
+		}
 	}
 
-	ast_sched_context_destroy(sched);
-	ao2_ref(transports, -1);
+	ast_sorcery_observer_remove(ast_sip_get_sorcery(), "global", &keepalive_global_observer);
+
+	tpmgr = pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint());
+	if (tpmgr) {
+		pjsip_tpmgr_set_state_cb(tpmgr, tpmgr_state_callback);
+	}
 
 	ast_sip_unregister_service(&idle_monitor_module);
-	pjsip_tpmgr_set_state_cb(tpmgr, tpmgr_state_callback);
+
+	ast_sched_context_destroy(sched);
+	sched = NULL;
+
+	ao2_global_obj_release(monitored_transports);
+
 	return 0;
 }
 
@@ -372,9 +410,9 @@ static int reload_module(void)
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP Reliable Transport Management",
-		.support_level = AST_MODULE_SUPPORT_CORE,
-		.load = load_module,
-		.reload = reload_module,
-		.unload = unload_module,
-		.load_pri = AST_MODPRI_CHANNEL_DEPEND - 4,
-		   );
+	.support_level = AST_MODULE_SUPPORT_CORE,
+	.load = load_module,
+	.reload = reload_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_CHANNEL_DEPEND - 4,
+);
diff -urpN asterisk-13.9.1/res/res_pjsip_transport_websocket.c asterisk-13.17.0/res/res_pjsip_transport_websocket.c
--- asterisk-13.9.1/res/res_pjsip_transport_websocket.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_transport_websocket.c	2017-07-12 13:12:08.000000000 +0200
@@ -38,8 +38,8 @@
 #include "asterisk/res_pjsip_session.h"
 #include "asterisk/taskprocessor.h"
 
-static int transport_type_ws;
 static int transport_type_wss;
+static int transport_type_wss_ipv6;
 
 /*!
  * \brief Wrapper for pjsip_transport, for storing the WebSocket session
@@ -149,6 +149,7 @@ static int transport_create(void *data)
 	pjsip_endpoint *endpt = ast_sip_get_pjsip_endpoint();
 	struct pjsip_tpmgr *tpmgr = pjsip_endpt_get_tpmgr(endpt);
 
+	char *ws_addr_str;
 	pj_pool_t *pool;
 	pj_str_t buf;
 	pj_status_t status;
@@ -183,20 +184,38 @@ static int transport_create(void *data)
 		goto on_error;
 	}
 
-	pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&buf, ast_sockaddr_stringify(ast_websocket_remote_address(newtransport->ws_session))), &newtransport->transport.key.rem_addr);
-	newtransport->transport.key.rem_addr.addr.sa_family = pj_AF_INET();
-	newtransport->transport.key.type = ast_websocket_is_secure(newtransport->ws_session) ? transport_type_wss : transport_type_ws;
+	/*
+	 * The type_name here is mostly used by log messages eihter in
+	 * pjproject or Asterisk.  Other places are reconstituting subscriptions
+	 * after a restart (which could never work for a websocket connection anyway),
+	 * received MESSAGE requests to set PJSIP_TRANSPORT, and most importantly
+	 * by pjproject when generating the Via header.
+	 */
+	newtransport->transport.type_name = ast_websocket_is_secure(newtransport->ws_session)
+		? "WSS" : "WS";
+
+	ws_addr_str = ast_sockaddr_stringify(ast_websocket_remote_address(newtransport->ws_session));
+	ast_debug(4, "Creating websocket transport for %s:%s\n",
+		newtransport->transport.type_name, ws_addr_str);
+
+	pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&buf, ws_addr_str), &newtransport->transport.key.rem_addr);
+	if (newtransport->transport.key.rem_addr.addr.sa_family == pj_AF_INET6()) {
+		newtransport->transport.key.type = transport_type_wss_ipv6;
+		newtransport->transport.local_name.host.ptr = (char *)pj_pool_alloc(pool, PJ_INET6_ADDRSTRLEN);
+		pj_sockaddr_print(&newtransport->transport.key.rem_addr, newtransport->transport.local_name.host.ptr, PJ_INET6_ADDRSTRLEN, 0);
+	} else {
+		newtransport->transport.key.type = transport_type_wss;
+		newtransport->transport.local_name.host.ptr = (char *)pj_pool_alloc(pool, PJ_INET_ADDRSTRLEN);
+		pj_sockaddr_print(&newtransport->transport.key.rem_addr, newtransport->transport.local_name.host.ptr, PJ_INET_ADDRSTRLEN, 0);
+	}
 
 	newtransport->transport.addr_len = pj_sockaddr_get_len(&newtransport->transport.key.rem_addr);
 
 	pj_sockaddr_cp(&newtransport->transport.local_addr, &newtransport->transport.key.rem_addr);
 
-	newtransport->transport.local_name.host.ptr = (char *)pj_pool_alloc(pool, newtransport->transport.addr_len+4);
-	pj_sockaddr_print(&newtransport->transport.key.rem_addr, newtransport->transport.local_name.host.ptr, newtransport->transport.addr_len+4, 0);
 	newtransport->transport.local_name.host.slen = pj_ansi_strlen(newtransport->transport.local_name.host.ptr);
 	newtransport->transport.local_name.port = pj_sockaddr_get_port(&newtransport->transport.key.rem_addr);
 
-	newtransport->transport.type_name = (char *)pjsip_transport_get_type_name(newtransport->transport.key.type);
 	newtransport->transport.flag = pjsip_transport_get_flag_from_type((pjsip_transport_type_e)newtransport->transport.key.type);
 	newtransport->transport.info = (char *)pj_pool_alloc(newtransport->transport.pool, 64);
 
@@ -258,8 +277,6 @@ static int transport_read(void *data)
 	rdata->pkt_info.zero = 0;
 
 	pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&buf, ast_sockaddr_stringify(ast_websocket_remote_address(session))), &rdata->pkt_info.src_addr);
-	rdata->pkt_info.src_addr.addr.sa_family = pj_AF_INET();
-
 	rdata->pkt_info.src_addr_len = sizeof(rdata->pkt_info.src_addr);
 
 	pj_ansi_strcpy(rdata->pkt_info.src_name, ast_sockaddr_stringify_host(ast_websocket_remote_address(session)));
@@ -285,10 +302,14 @@ static int get_write_timeout(void)
 
 		for (; (transport_state = ao2_iterator_next(&it_transport_states)); ao2_cleanup(transport_state)) {
 			struct ast_sip_transport *transport;
+
 			if (transport_state->type != AST_TRANSPORT_WS && transport_state->type != AST_TRANSPORT_WSS) {
 				continue;
 			}
 			transport = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "transport", transport_state->id);
+			if (!transport) {
+				continue;
+			}
 			ast_debug(5, "Found %s transport with write timeout: %d\n",
 				transport->type == AST_TRANSPORT_WS ? "WS" : "WSS",
 				transport->write_timeout);
@@ -378,24 +399,31 @@ static void websocket_cb(struct ast_webs
 static pj_bool_t websocket_on_rx_msg(pjsip_rx_data *rdata)
 {
 	static const pj_str_t STR_WS = { "ws", 2 };
-	static const pj_str_t STR_WSS = { "wss", 3 };
 	pjsip_contact_hdr *contact;
 
 	long type = rdata->tp_info.transport->key.type;
 
-	if (type != (long)transport_type_ws && type != (long)transport_type_wss) {
+	if (type != (long) transport_type_wss && type != (long) transport_type_wss_ipv6) {
 		return PJ_FALSE;
 	}
 
-	if ((contact = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL)) && !contact->star &&
-		(PJSIP_URI_SCHEME_IS_SIP(contact->uri) || PJSIP_URI_SCHEME_IS_SIPS(contact->uri))) {
+	contact = pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT, NULL);
+	if (contact
+		&& !contact->star
+		&& (PJSIP_URI_SCHEME_IS_SIP(contact->uri) || PJSIP_URI_SCHEME_IS_SIPS(contact->uri))) {
 		pjsip_sip_uri *uri = pjsip_uri_get_uri(contact->uri);
+		const pj_str_t *txp_str = &STR_WS;
+
+		ast_debug(4, "%s re-writing Contact URI from %.*s:%d%s%.*s to %s:%d;transport=%s\n",
+			pjsip_rx_data_get_info(rdata),
+			(int)pj_strlen(&uri->host), pj_strbuf(&uri->host), uri->port,
+			pj_strlen(&uri->transport_param) ? ";transport=" : "",
+			(int)pj_strlen(&uri->transport_param), pj_strbuf(&uri->transport_param),
+			rdata->pkt_info.src_name ?: "", rdata->pkt_info.src_port, pj_strbuf(txp_str));
 
 		pj_cstr(&uri->host, rdata->pkt_info.src_name);
 		uri->port = rdata->pkt_info.src_port;
-		ast_debug(4, "Re-wrote Contact URI host/port to %.*s:%d\n",
-			(int)pj_strlen(&uri->host), pj_strbuf(&uri->host), uri->port);
-		pj_strdup(rdata->tp_info.pool, &uri->transport_param, (type == (long)transport_type_ws) ? &STR_WS : &STR_WSS);
+		pj_strdup(rdata->tp_info.pool, &uri->transport_param, txp_str);
 	}
 
 	rdata->msg_info.via->rport_param = 0;
@@ -430,8 +458,18 @@ static int load_module(void)
 {
 	CHECK_PJSIP_MODULE_LOADED();
 
-	pjsip_transport_register_type(PJSIP_TRANSPORT_RELIABLE, "WS", 5060, &transport_type_ws);
-	pjsip_transport_register_type(PJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE, "WSS", 5060, &transport_type_wss);
+	/*
+	 * We only need one transport type name (ws) defined.  Firefox
+	 * and Chrome do not support anything other than secure websockets
+	 * anymore.
+	 *
+	 * Also we really cannot have two transports with the same name
+	 * and address family because it would be ambiguous.  Outgoing
+	 * requests may try to find the transport by name and pjproject
+	 * only finds the first one registered.
+	 */
+	pjsip_transport_register_type(PJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE, "ws", 5060, &transport_type_wss);
+	pjsip_transport_register_type(PJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE | PJSIP_TRANSPORT_IPV6, "ws", 5060, &transport_type_wss_ipv6);
 
 	if (ast_sip_register_service(&websocket_module) != PJ_SUCCESS) {
 		return AST_MODULE_LOAD_DECLINE;
diff -urpN asterisk-13.9.1/res/res_pjsip_xpidf_body_generator.c asterisk-13.17.0/res/res_pjsip_xpidf_body_generator.c
--- asterisk-13.9.1/res/res_pjsip_xpidf_body_generator.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_pjsip_xpidf_body_generator.c	2017-07-12 13:12:08.000000000 +0200
@@ -63,7 +63,7 @@ static int xpidf_generate_body_content(v
 	pj_xml_node *msnsubstatus;
 
 	ast_sip_presence_exten_state_to_str(state_data->exten_state, &statestring,
-			&pidfstate, &pidfnote, &local_state);
+			&pidfstate, &pidfnote, &local_state, 0);
 
 	ast_sip_presence_xml_find_node_attr(state_data->pool, pres, "atom", "id",
 			&atom, &attr);
diff -urpN asterisk-13.9.1/res/res_rtp_asterisk.c asterisk-13.17.0/res/res_rtp_asterisk.c
--- asterisk-13.9.1/res/res_rtp_asterisk.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_rtp_asterisk.c	2017-07-12 13:12:08.000000000 +0200
@@ -51,8 +51,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include <pjlib.h>
 #include <pjlib-util.h>
 #include <pjnath.h>
+#include <ifaddrs.h>
 #endif
 
+#include "asterisk/options.h"
 #include "asterisk/stun.h"
 #include "asterisk/pbx.h"
 #include "asterisk/frame.h"
@@ -131,13 +133,13 @@ static int rtcpstats;			/*!< Are we debu
 static int rtcpinterval = RTCP_DEFAULT_INTERVALMS; /*!< Time between rtcp reports in millisecs */
 static struct ast_sockaddr rtpdebugaddr;	/*!< Debug packets to/from this host */
 static struct ast_sockaddr rtcpdebugaddr;	/*!< Debug RTCP packets to/from this host */
-static int rtpdebugport;		/*< Debug only RTP packets from IP or IP+Port if port is > 0 */
-static int rtcpdebugport;		/*< Debug only RTCP packets from IP or IP+Port if port is > 0 */
+static int rtpdebugport;		/*!< Debug only RTP packets from IP or IP+Port if port is > 0 */
+static int rtcpdebugport;		/*!< Debug only RTCP packets from IP or IP+Port if port is > 0 */
 #ifdef SO_NO_CHECK
 static int nochecksums;
 #endif
-static int strictrtp = DEFAULT_STRICT_RTP; /*< Only accept RTP frames from a defined source. If we receive an indication of a changing source, enter learning mode. */
-static int learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL; /*< Number of sequential RTP frames needed from a single source during learning mode to accept new source. */
+static int strictrtp = DEFAULT_STRICT_RTP; /*!< Only accept RTP frames from a defined source. If we receive an indication of a changing source, enter learning mode. */
+static int learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL; /*!< Number of sequential RTP frames needed from a single source during learning mode to accept new source. */
 #ifdef HAVE_PJPROJECT
 static int icesupport = DEFAULT_ICESUPPORT;
 static struct sockaddr_in stunaddr;
@@ -146,6 +148,14 @@ static int turnport = DEFAULT_TURN_PORT;
 static pj_str_t turnusername;
 static pj_str_t turnpassword;
 
+static struct ast_ha *ice_blacklist = NULL;    /*!< Blacklisted ICE networks */
+static ast_rwlock_t ice_blacklist_lock = AST_RWLOCK_INIT_VALUE;
+
+/*! Blacklisted networks for STUN requests */
+static struct ast_ha *stun_blacklist = NULL;
+static ast_rwlock_t stun_blacklist_lock = AST_RWLOCK_INIT_VALUE;
+
+
 /*! \brief Pool factory used by pjlib to allocate memory. */
 static pj_caching_pool cachingpool;
 
@@ -214,7 +224,6 @@ struct rtp_learning_info {
 
 #ifdef HAVE_OPENSSL_SRTP
 struct dtls_details {
-	ast_mutex_t lock; /*!< Lock for timeout timer synchronization */
 	SSL *ssl;         /*!< SSL session */
 	BIO *read_bio;    /*!< Memory buffer for reading */
 	BIO *write_bio;   /*!< Memory buffer for writing */
@@ -224,9 +233,17 @@ struct dtls_details {
 };
 #endif
 
+#ifdef HAVE_PJPROJECT
+/*! An ao2 wrapper protecting the PJPROJECT ice structure with ref counting. */
+struct ice_wrap {
+	pj_ice_sess *real_ice;           /*!< ICE session */
+};
+#endif
+
 /*! \brief RTP session description */
 struct ast_rtp {
 	int s;
+	/*! \note The f.subclass.format holds a ref. */
 	struct ast_frame f;
 	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
 	unsigned int ssrc;		/*!< Synchronization source, RFC 3550, page 10. */
@@ -298,11 +315,11 @@ struct ast_rtp {
 
 	struct rtp_red *red;
 
-	ast_mutex_t lock;           /*!< Lock for synchronization purposes */
-	ast_cond_t cond;            /*!< Condition for signaling */
-
 #ifdef HAVE_PJPROJECT
-	pj_ice_sess *ice;           /*!< ICE session */
+	ast_cond_t cond;            /*!< ICE/TURN condition for signaling */
+
+	struct ice_wrap *ice;       /*!< ao2 wrapped ICE session */
+	enum ast_rtp_ice_role role; /*!< Our role in ICE negotiation */
 	pj_turn_sock *turn_rtp;     /*!< RTP TURN relay */
 	pj_turn_sock *turn_rtcp;    /*!< RTCP TURN relay */
 	pj_turn_state_t turn_state; /*!< Current state of the TURN relay session */
@@ -325,6 +342,7 @@ struct ast_rtp {
 	struct ao2_container *ice_active_remote_candidates;   /*!< The remote ICE candidates */
 	struct ao2_container *ice_proposed_remote_candidates; /*!< Incoming remote ICE candidates for new session */
 	struct ast_sockaddr ice_original_rtp_addr;            /*!< rtp address that ICE started on first session */
+	unsigned int ice_num_components; /*!< The number of ICE components */
 #endif
 
 #ifdef HAVE_OPENSSL_SRTP
@@ -407,6 +425,13 @@ struct ast_rtcp {
 #ifdef HAVE_OPENSSL_SRTP
 	struct dtls_details dtls; /*!< DTLS state information */
 #endif
+
+	/* Cached local address string allows us to generate
+	 * RTCP stasis messages without having to look up our
+	 * own address every time
+	 */
+	char *local_addr_str;
+	enum ast_rtp_instance_rtcp type;
 };
 
 struct rtp_red {
@@ -458,7 +483,7 @@ static void dtls_srtp_start_timeout_time
 static void dtls_srtp_stop_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp);
 #endif
 
-static int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *ice, int use_srtp);
+static int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *via_ice, int use_srtp);
 
 #ifdef HAVE_PJPROJECT
 /*! \brief Helper function which clears the ICE host candidate mapping */
@@ -494,17 +519,20 @@ static void host_candidate_overrides_app
 }
 
 /*! \brief Helper function which updates an ast_sockaddr with the candidate used for the component */
-static void update_address_with_ice_candidate(struct ast_rtp *rtp, enum ast_rtp_ice_component_type component,
+static void update_address_with_ice_candidate(pj_ice_sess *ice, enum ast_rtp_ice_component_type component,
 	struct ast_sockaddr *cand_address)
 {
 	char address[PJ_INET6_ADDRSTRLEN];
 
-	if (!rtp->ice || (component < 1) || !rtp->ice->comp[component - 1].valid_check) {
+	if (component < 1 || !ice->comp[component - 1].valid_check) {
 		return;
 	}
 
-	ast_sockaddr_parse(cand_address, pj_sockaddr_print(&rtp->ice->comp[component - 1].valid_check->rcand->addr, address, sizeof(address), 0), 0);
-	ast_sockaddr_set_port(cand_address, pj_sockaddr_get_port(&rtp->ice->comp[component - 1].valid_check->rcand->addr));
+	ast_sockaddr_parse(cand_address,
+		pj_sockaddr_print(&ice->comp[component - 1].valid_check->rcand->addr, address,
+			sizeof(address), 0), 0);
+	ast_sockaddr_set_port(cand_address,
+		pj_sockaddr_get_port(&ice->comp[component - 1].valid_check->rcand->addr));
 }
 
 /*! \brief Destructor for locally created ICE candidates */
@@ -521,6 +549,7 @@ static void ast_rtp_ice_candidate_destro
 	}
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_set_authentication(struct ast_rtp_instance *instance, const char *ufrag, const char *password)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -540,14 +569,15 @@ static int ice_candidate_cmp(void *obj,
 
 	if (strcmp(candidate1->foundation, candidate2->foundation) ||
 			candidate1->id != candidate2->id ||
-			ast_sockaddr_cmp(&candidate1->address, &candidate2->address) ||
-			candidate1->type != candidate1->type) {
+			candidate1->type != candidate2->type ||
+			ast_sockaddr_cmp(&candidate1->address, &candidate2->address)) {
 		return 0;
 	}
 
 	return CMP_MATCH | CMP_STOP;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_add_remote_candidate(struct ast_rtp_instance *instance, const struct ast_rtp_engine_ice_candidate *candidate)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -612,40 +642,78 @@ static void pj_thread_register_check(voi
 static int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,
 	int port, int replace);
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_stop(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ice_wrap *ice;
 
-	if (!rtp->ice) {
-		return;
+	ice = rtp->ice;
+	rtp->ice = NULL;
+	if (ice) {
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ao2_unlock(instance);
+		ao2_ref(ice, -1);
+		ao2_lock(instance);
 	}
+}
 
-	pj_thread_register_check();
+/*!
+ * \brief ao2 ICE wrapper object destructor.
+ *
+ * \param vdoomed Object being destroyed.
+ *
+ * \note The associated struct ast_rtp_instance object must not
+ * be locked when unreffing the object.  Otherwise we could
+ * deadlock trying to destroy the PJPROJECT ICE structure.
+ */
+static void ice_wrap_dtor(void *vdoomed)
+{
+	struct ice_wrap *ice = vdoomed;
 
-	pj_ice_sess_destroy(rtp->ice);
-	rtp->ice = NULL;
+	if (ice->real_ice) {
+		pj_thread_register_check();
+
+		pj_ice_sess_destroy(ice->real_ice);
+	}
 }
 
+/*! \pre instance is locked */
 static int ice_reset_session(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
-	pj_ice_sess_role role = rtp->ice->role;
 	int res;
 
 	ast_debug(3, "Resetting ICE for RTP instance '%p'\n", instance);
-	if (!rtp->ice->is_nominating && !rtp->ice->is_complete) {
+	if (!rtp->ice->real_ice->is_nominating && !rtp->ice->real_ice->is_complete) {
 		ast_debug(3, "Nevermind. ICE isn't ready for a reset\n");
 		return 0;
 	}
 
-	ast_debug(3, "Stopping ICE for RTP instance '%p'\n", instance);
-	ast_rtp_ice_stop(instance);
-
 	ast_debug(3, "Recreating ICE session %s (%d) for RTP instance '%p'\n", ast_sockaddr_stringify(&rtp->ice_original_rtp_addr), rtp->ice_port, instance);
 	res = ice_create(instance, &rtp->ice_original_rtp_addr, rtp->ice_port, 1);
 	if (!res) {
-		/* Preserve the role that the old ICE session used */
-		pj_ice_sess_change_role(rtp->ice, role);
+		/* Use the current expected role for the ICE session */
+		pj_ice_sess_change_role(rtp->ice->real_ice, rtp->role == AST_RTP_ICE_ROLE_CONTROLLED ?
+			PJ_ICE_SESS_ROLE_CONTROLLED : PJ_ICE_SESS_ROLE_CONTROLLING);
+	}
+
+	/* If we only have one component now, and we previously set up TURN for RTCP,
+	 * we need to destroy that TURN socket.
+	 */
+	if (rtp->ice_num_components == 1 && rtp->turn_rtcp) {
+		struct timeval wait = ast_tvadd(ast_tvnow(), ast_samp2tv(TURN_STATE_WAIT_TIME, 1000));
+		struct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };
+
+		rtp->turn_state = PJ_TURN_STATE_NULL;
+
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ao2_unlock(instance);
+		pj_turn_sock_destroy(rtp->turn_rtcp);
+		ao2_lock(instance);
+		while (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {
+			ast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);
+		}
 	}
 
 	return res;
@@ -678,6 +746,7 @@ static int ice_candidates_compare(struct
 	return 0;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_start(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -697,6 +766,8 @@ static void ast_rtp_ice_start(struct ast
 		ast_debug(3, "Proposed == active candidates for RTP instance '%p'\n", instance);
 		ao2_cleanup(rtp->ice_proposed_remote_candidates);
 		rtp->ice_proposed_remote_candidates = NULL;
+		/* If this ICE session is being preserved then go back to the role it currently is */
+		rtp->role = rtp->ice->real_ice->role;
 		return;
 	}
 
@@ -722,7 +793,8 @@ static void ast_rtp_ice_start(struct ast
 		has_rtp |= candidate->id == AST_RTP_ICE_COMPONENT_RTP;
 		has_rtcp |= candidate->id == AST_RTP_ICE_COMPONENT_RTCP;
 
-		pj_strdup2(rtp->ice->pool, &candidates[cand_cnt].foundation, candidate->foundation);
+		pj_strdup2(rtp->ice->real_ice->pool, &candidates[cand_cnt].foundation,
+			candidate->foundation);
 		candidates[cand_cnt].comp_id = candidate->id;
 		candidates[cand_cnt].prio = candidate->priority;
 
@@ -742,10 +814,16 @@ static void ast_rtp_ice_start(struct ast
 
 		if (candidate->id == AST_RTP_ICE_COMPONENT_RTP && rtp->turn_rtp) {
 			ast_debug(3, "RTP candidate %s (%p)\n", ast_sockaddr_stringify(&candidate->address), instance);
+			/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+			ao2_unlock(instance);
 			pj_turn_sock_set_perm(rtp->turn_rtp, 1, &candidates[cand_cnt].addr, 1);
+			ao2_lock(instance);
 		} else if (candidate->id == AST_RTP_ICE_COMPONENT_RTCP && rtp->turn_rtcp) {
 			ast_debug(3, "RTCP candidate %s (%p)\n", ast_sockaddr_stringify(&candidate->address), instance);
+			/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+			ao2_unlock(instance);
 			pj_turn_sock_set_perm(rtp->turn_rtcp, 1, &candidates[cand_cnt].addr, 1);
+			ao2_lock(instance);
 		}
 
 		cand_cnt++;
@@ -763,22 +841,33 @@ static void ast_rtp_ice_start(struct ast
 		ast_log(LOG_WARNING, "No RTP candidates; skipping ICE checklist (%p)\n", instance);
 	}
 
-	if (!has_rtcp) {
+	/* If we're only dealing with one ICE component, then we don't care about the lack of RTCP candidates */
+	if (!has_rtcp && rtp->ice_num_components > 1) {
 		ast_log(LOG_WARNING, "No RTCP candidates; skipping ICE checklist (%p)\n", instance);
 	}
 
-	if (has_rtp && has_rtcp) {
-		pj_status_t res = pj_ice_sess_create_check_list(rtp->ice, &ufrag, &passwd, cand_cnt, &candidates[0]);
+	if (rtp->ice && has_rtp && (has_rtcp || rtp->ice_num_components == 1)) {
+		pj_status_t res;
 		char reason[80];
+		struct ice_wrap *ice;
 
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ice = rtp->ice;
+		ao2_ref(ice, +1);
+		ao2_unlock(instance);
+		res = pj_ice_sess_create_check_list(ice->real_ice, &ufrag, &passwd, cand_cnt, &candidates[0]);
 		if (res == PJ_SUCCESS) {
 			ast_debug(3, "Successfully created ICE checklist (%p)\n", instance);
 			ast_test_suite_event_notify("ICECHECKLISTCREATE", "Result: SUCCESS");
-			pj_ice_sess_start_check(rtp->ice);
+			pj_ice_sess_start_check(ice->real_ice);
 			pj_timer_heap_poll(timer_heap, NULL);
+			ao2_ref(ice, -1);
+			ao2_lock(instance);
 			rtp->strict_rtp_state = STRICT_RTP_OPEN;
 			return;
 		}
+		ao2_ref(ice, -1);
+		ao2_lock(instance);
 
 		pj_strerror(res, reason, sizeof(reason));
 		ast_log(LOG_WARNING, "Failed to create ICE session check list: %s (%p)\n", reason, instance);
@@ -792,9 +881,12 @@ static void ast_rtp_ice_start(struct ast
 	   this function may be re-entered */
 	ao2_ref(rtp->ice_active_remote_candidates, -1);
 	rtp->ice_active_remote_candidates = NULL;
-	rtp->ice->rcand_cnt = rtp->ice->clist.count = 0;
+	if (rtp->ice) {
+		rtp->ice->real_ice->rcand_cnt = rtp->ice->real_ice->clist.count = 0;
+	}
 }
 
+/*! \pre instance is locked */
 static const char *ast_rtp_ice_get_ufrag(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -802,6 +894,7 @@ static const char *ast_rtp_ice_get_ufrag
 	return rtp->local_ufrag;
 }
 
+/*! \pre instance is locked */
 static const char *ast_rtp_ice_get_password(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -809,6 +902,7 @@ static const char *ast_rtp_ice_get_passw
 	return rtp->local_passwd;
 }
 
+/*! \pre instance is locked */
 static struct ao2_container *ast_rtp_ice_get_local_candidates(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -820,6 +914,7 @@ static struct ao2_container *ast_rtp_ice
 	return rtp->ice_local_candidates;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_lite(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -830,9 +925,10 @@ static void ast_rtp_ice_lite(struct ast_
 
 	pj_thread_register_check();
 
-	pj_ice_sess_change_role(rtp->ice, PJ_ICE_SESS_ROLE_CONTROLLING);
+	pj_ice_sess_change_role(rtp->ice->real_ice, PJ_ICE_SESS_ROLE_CONTROLLING);
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_set_role(struct ast_rtp_instance *instance, enum ast_rtp_ice_role role)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -845,22 +941,28 @@ static void ast_rtp_ice_set_role(struct
 		return;
 	}
 
-	pj_thread_register_check();
-
-	pj_ice_sess_change_role(rtp->ice, role == AST_RTP_ICE_ROLE_CONTROLLED ?
-		PJ_ICE_SESS_ROLE_CONTROLLED : PJ_ICE_SESS_ROLE_CONTROLLING);
+	rtp->role = role;
 }
 
-static void ast_rtp_ice_add_cand(struct ast_rtp *rtp, unsigned comp_id, unsigned transport_id, pj_ice_cand_type type, pj_uint16_t local_pref,
-					const pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr, int addr_len)
+/*! \pre instance is locked */
+static void ast_rtp_ice_add_cand(struct ast_rtp_instance *instance, struct ast_rtp *rtp,
+	unsigned comp_id, unsigned transport_id, pj_ice_cand_type type, pj_uint16_t local_pref,
+	const pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr,
+	int addr_len)
 {
 	pj_str_t foundation;
 	struct ast_rtp_engine_ice_candidate *candidate, *existing;
+	struct ice_wrap *ice;
 	char address[PJ_INET6_ADDRSTRLEN];
+	pj_status_t status;
+
+	if (!rtp->ice) {
+		return;
+	}
 
 	pj_thread_register_check();
 
-	pj_ice_calc_foundation(rtp->ice->pool, &foundation, type, addr);
+	pj_ice_calc_foundation(rtp->ice->real_ice->pool, &foundation, type, addr);
 
 	if (!rtp->ice_local_candidates && !(rtp->ice_local_candidates = ao2_container_alloc(1, NULL, ice_candidate_cmp))) {
 		return;
@@ -896,42 +998,60 @@ static void ast_rtp_ice_add_cand(struct
 		return;
 	}
 
-	if (pj_ice_sess_add_cand(rtp->ice, comp_id, transport_id, type, local_pref, &foundation, addr, base_addr, rel_addr, addr_len, NULL) != PJ_SUCCESS) {
+	/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+	ice = rtp->ice;
+	ao2_ref(ice, +1);
+	ao2_unlock(instance);
+	status = pj_ice_sess_add_cand(ice->real_ice, comp_id, transport_id, type, local_pref,
+		&foundation, addr, base_addr, rel_addr, addr_len, NULL);
+	ao2_ref(ice, -1);
+	ao2_lock(instance);
+	if (!rtp->ice || status != PJ_SUCCESS) {
 		ao2_ref(candidate, -1);
 		return;
 	}
 
 	/* By placing the candidate into the ICE session it will have produced the priority, so update the local candidate with it */
-	candidate->priority = rtp->ice->lcand[rtp->ice->lcand_cnt - 1].prio;
+	candidate->priority = rtp->ice->real_ice->lcand[rtp->ice->real_ice->lcand_cnt - 1].prio;
 
 	ao2_link(rtp->ice_local_candidates, candidate);
 	ao2_ref(candidate, -1);
 }
 
+/* PJPROJECT TURN callback */
 static void ast_rtp_on_turn_rx_rtp_data(pj_turn_sock *turn_sock, void *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)
 {
 	struct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ice_wrap *ice;
 	pj_status_t status;
 
-	status = pj_ice_sess_on_rx_pkt(rtp->ice, AST_RTP_ICE_COMPONENT_RTP, TRANSPORT_TURN_RTP, pkt, pkt_len, peer_addr,
-		addr_len);
-	if (status != PJ_SUCCESS) {
-		char buf[100];
+	ao2_lock(instance);
+	ice = ao2_bump(rtp->ice);
+	ao2_unlock(instance);
+
+	if (ice) {
+		status = pj_ice_sess_on_rx_pkt(ice->real_ice, AST_RTP_ICE_COMPONENT_RTP,
+			TRANSPORT_TURN_RTP, pkt, pkt_len, peer_addr, addr_len);
+		ao2_ref(ice, -1);
+		if (status != PJ_SUCCESS) {
+			char buf[100];
 
-		pj_strerror(status, buf, sizeof(buf));
-		ast_log(LOG_WARNING, "PJ ICE Rx error status code: %d '%s'.\n",
-			(int)status, buf);
-		return;
-	}
-	if (!rtp->rtp_passthrough) {
-		return;
+			pj_strerror(status, buf, sizeof(buf));
+			ast_log(LOG_WARNING, "PJ ICE Rx error status code: %d '%s'.\n",
+				(int)status, buf);
+			return;
+		}
+		if (!rtp->rtp_passthrough) {
+			return;
+		}
+		rtp->rtp_passthrough = 0;
 	}
-	rtp->rtp_passthrough = 0;
 
 	ast_sendto(rtp->s, pkt, pkt_len, 0, &rtp->rtp_loop);
 }
 
+/* PJPROJECT TURN callback */
 static void ast_rtp_on_turn_rtp_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state, pj_turn_state_t new_state)
 {
 	struct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);
@@ -944,8 +1064,9 @@ static void ast_rtp_on_turn_rtp_state(pj
 
 	rtp = ast_rtp_instance_get_data(instance);
 
+	ao2_lock(instance);
+
 	/* We store the new state so the other thread can actually handle it */
-	ast_mutex_lock(&rtp->lock);
 	rtp->turn_state = new_state;
 	ast_cond_signal(&rtp->cond);
 
@@ -954,7 +1075,7 @@ static void ast_rtp_on_turn_rtp_state(pj
 		rtp->turn_rtp = NULL;
 	}
 
-	ast_mutex_unlock(&rtp->lock);
+	ao2_unlock(instance);
 }
 
 /* RTP TURN Socket interface declaration */
@@ -963,34 +1084,44 @@ static pj_turn_sock_cb ast_rtp_turn_rtp_
 	.on_state = ast_rtp_on_turn_rtp_state,
 };
 
+/* PJPROJECT TURN callback */
 static void ast_rtp_on_turn_rx_rtcp_data(pj_turn_sock *turn_sock, void *pkt, unsigned pkt_len, const pj_sockaddr_t *peer_addr, unsigned addr_len)
 {
 	struct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ice_wrap *ice;
 	pj_status_t status;
 
-	status = pj_ice_sess_on_rx_pkt(rtp->ice, AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_TURN_RTCP, pkt, pkt_len, peer_addr,
-		addr_len);
-	if (status != PJ_SUCCESS) {
-		char buf[100];
+	ao2_lock(instance);
+	ice = ao2_bump(rtp->ice);
+	ao2_unlock(instance);
+
+	if (ice) {
+		status = pj_ice_sess_on_rx_pkt(ice->real_ice, AST_RTP_ICE_COMPONENT_RTCP,
+			TRANSPORT_TURN_RTCP, pkt, pkt_len, peer_addr, addr_len);
+		ao2_ref(ice, -1);
+		if (status != PJ_SUCCESS) {
+			char buf[100];
 
-		pj_strerror(status, buf, sizeof(buf));
-		ast_log(LOG_WARNING, "PJ ICE Rx error status code: %d '%s'.\n",
-			(int)status, buf);
-		return;
-	}
-	if (!rtp->rtcp_passthrough) {
-		return;
+			pj_strerror(status, buf, sizeof(buf));
+			ast_log(LOG_WARNING, "PJ ICE Rx error status code: %d '%s'.\n",
+				(int)status, buf);
+			return;
+		}
+		if (!rtp->rtcp_passthrough) {
+			return;
+		}
+		rtp->rtcp_passthrough = 0;
 	}
-	rtp->rtcp_passthrough = 0;
 
 	ast_sendto(rtp->rtcp->s, pkt, pkt_len, 0, &rtp->rtcp_loop);
 }
 
+/* PJPROJECT TURN callback */
 static void ast_rtp_on_turn_rtcp_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state, pj_turn_state_t new_state)
 {
 	struct ast_rtp_instance *instance = pj_turn_sock_get_user_data(turn_sock);
-	struct ast_rtp *rtp = NULL;
+	struct ast_rtp *rtp;
 
 	/* If this is a leftover from an already destroyed RTP instance just ignore the state change */
 	if (!instance) {
@@ -999,8 +1130,9 @@ static void ast_rtp_on_turn_rtcp_state(p
 
 	rtp = ast_rtp_instance_get_data(instance);
 
+	ao2_lock(instance);
+
 	/* We store the new state so the other thread can actually handle it */
-	ast_mutex_lock(&rtp->lock);
 	rtp->turn_state = new_state;
 	ast_cond_signal(&rtp->cond);
 
@@ -1009,7 +1141,7 @@ static void ast_rtp_on_turn_rtcp_state(p
 		rtp->turn_rtcp = NULL;
 	}
 
-	ast_mutex_unlock(&rtp->lock);
+	ao2_unlock(instance);
 }
 
 /* RTCP TURN Socket interface declaration */
@@ -1043,7 +1175,16 @@ static void rtp_ioqueue_thread_destroy(s
 		pj_thread_destroy(ioqueue->thread);
 	}
 
-	pj_pool_release(ioqueue->pool);
+	if (ioqueue->pool) {
+		/* This mimics the behavior of pj_pool_safe_release
+		 * which was introduced in pjproject 2.6.
+		 */
+		pj_pool_t *temp_pool = ioqueue->pool;
+
+		ioqueue->pool = NULL;
+		pj_pool_release(temp_pool);
+	}
+
 	ast_free(ioqueue);
 }
 
@@ -1132,6 +1273,7 @@ end:
 	return ioqueue;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_ice_turn_request(struct ast_rtp_instance *instance, enum ast_rtp_ice_component_type component,
 		enum ast_transport transport, const char *server, unsigned int port, const char *username, const char *password)
 {
@@ -1148,6 +1290,7 @@ static void ast_rtp_ice_turn_request(str
 	struct timespec ts = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000, };
 	pj_turn_session_info info;
 	struct ast_sockaddr local, loop;
+	pj_status_t status;
 
 	ast_rtp_instance_get_local_address(instance, &local);
 	if (ast_sockaddr_is_ipv4(&local)) {
@@ -1182,18 +1325,27 @@ static void ast_rtp_ice_turn_request(str
 
 	ast_sockaddr_parse(&addr, server, PARSE_PORT_FORBID);
 
-	ast_mutex_lock(&rtp->lock);
 	if (*turn_sock) {
-		pj_turn_sock_destroy(*turn_sock);
 		rtp->turn_state = PJ_TURN_STATE_NULL;
+
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ao2_unlock(instance);
+		pj_turn_sock_destroy(*turn_sock);
+		ao2_lock(instance);
 		while (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {
-			ast_cond_timedwait(&rtp->cond, &rtp->lock, &ts);
+			ast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);
 		}
 	}
-	ast_mutex_unlock(&rtp->lock);
 
 	if (component == AST_RTP_ICE_COMPONENT_RTP && !rtp->ioqueue) {
+		/*
+		 * We cannot hold the instance lock because we could wait
+		 * for the ioqueue thread to die and we might deadlock as
+		 * a result.
+		 */
+		ao2_unlock(instance);
 		rtp->ioqueue = rtp_ioqueue_thread_get_or_create();
+		ao2_lock(instance);
 		if (!rtp->ioqueue) {
 			return;
 		}
@@ -1201,9 +1353,14 @@ static void ast_rtp_ice_turn_request(str
 
 	pj_stun_config_init(&stun_config, &cachingpool.factory, 0, rtp->ioqueue->ioqueue, rtp->ioqueue->timerheap);
 
-	if (pj_turn_sock_create(&stun_config, ast_sockaddr_is_ipv4(&addr) ? pj_AF_INET() : pj_AF_INET6(), conn_type,
-		turn_cb, NULL, instance, turn_sock) != PJ_SUCCESS) {
+	/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+	ao2_unlock(instance);
+	status = pj_turn_sock_create(&stun_config,
+		ast_sockaddr_is_ipv4(&addr) ? pj_AF_INET() : pj_AF_INET6(), conn_type,
+		turn_cb, NULL, instance, turn_sock);
+	if (status != PJ_SUCCESS) {
 		ast_log(LOG_WARNING, "Could not create a TURN client socket\n");
+		ao2_lock(instance);
 		return;
 	}
 
@@ -1212,13 +1369,16 @@ static void ast_rtp_ice_turn_request(str
 	cred.data.static_cred.data_type = PJ_STUN_PASSWD_PLAIN;
 	pj_strset2(&cred.data.static_cred.data, (char*)password);
 
-	/* Because the TURN socket is asynchronous but we are synchronous we need to wait until it is done */
-	ast_mutex_lock(&rtp->lock);
 	pj_turn_sock_alloc(*turn_sock, pj_cstr(&turn_addr, server), port, NULL, &cred, NULL);
+	ao2_lock(instance);
+
+	/*
+	 * Because the TURN socket is asynchronous and we are synchronous we need to
+	 * wait until it is done
+	 */
 	while (rtp->turn_state < PJ_TURN_STATE_READY) {
-		ast_cond_timedwait(&rtp->cond, &rtp->lock, &ts);
+		ast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);
 	}
-	ast_mutex_unlock(&rtp->lock);
 
 	/* If a TURN session was allocated add it as a candidate */
 	if (rtp->turn_state != PJ_TURN_STATE_READY) {
@@ -1227,8 +1387,9 @@ static void ast_rtp_ice_turn_request(str
 
 	pj_turn_sock_get_info(*turn_sock, &info);
 
-	ast_rtp_ice_add_cand(rtp, component, conn_transport, PJ_ICE_CAND_TYPE_RELAYED, 65535, &info.relay_addr,
-		&info.relay_addr, &info.mapped_addr, pj_sockaddr_get_len(&info.relay_addr));
+	ast_rtp_ice_add_cand(instance, rtp, component, conn_transport,
+		PJ_ICE_CAND_TYPE_RELAYED, 65535, &info.relay_addr, &info.relay_addr,
+		&info.mapped_addr, pj_sockaddr_get_len(&info.relay_addr));
 
 	if (component == AST_RTP_ICE_COMPONENT_RTP) {
 		ast_sockaddr_copy(&rtp->rtp_loop, &loop);
@@ -1250,6 +1411,22 @@ static char *generate_random_string(char
         return buf;
 }
 
+/*! \pre instance is locked */
+static void ast_rtp_ice_change_components(struct ast_rtp_instance *instance, int num_components)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	/* Don't do anything if ICE is unsupported or if we're not changing the
+	 * number of components
+	 */
+	if (!icesupport || !rtp->ice || rtp->ice_num_components == num_components) {
+		return;
+	}
+
+	rtp->ice_num_components = num_components;
+	ice_reset_session(instance);
+}
+
 /* ICE RTP Engine interface declaration */
 static struct ast_rtp_engine_ice ast_rtp_ice = {
 	.set_authentication = ast_rtp_ice_set_authentication,
@@ -1262,6 +1439,7 @@ static struct ast_rtp_engine_ice ast_rtp
 	.ice_lite = ast_rtp_ice_lite,
 	.set_role = ast_rtp_ice_set_role,
 	.turn_request = ast_rtp_ice_turn_request,
+	.change_components = ast_rtp_ice_change_components,
 };
 #endif
 
@@ -1303,8 +1481,6 @@ static int dtls_details_initialize(struc
 	}
 	dtls->connection = AST_RTP_DTLS_CONNECTION_NEW;
 
-	ast_mutex_init(&dtls->lock);
-
 	return 0;
 
 error:
@@ -1336,11 +1512,12 @@ static int dtls_setup_rtcp(struct ast_rt
 	return dtls_details_initialize(&rtp->rtcp->dtls, rtp->ssl_ctx, rtp->dtls.dtls_setup);
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtls_set_configuration(struct ast_rtp_instance *instance, const struct ast_rtp_dtls_cfg *dtls_cfg)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	int res;
-#ifndef HAVE_OPENSSL_ECDH_AUTO
+#ifdef HAVE_OPENSSL_EC
 	EC_KEY *ecdh;
 #endif
 
@@ -1357,21 +1534,53 @@ static int ast_rtp_dtls_set_configuratio
 		return 0;
 	}
 
-	if (!(rtp->ssl_ctx = SSL_CTX_new(DTLSv1_method()))) {
+#if OPENSSL_VERSION_NUMBER < 0x10002000L || defined(LIBRESSL_VERSION_NUMBER)
+	rtp->ssl_ctx = SSL_CTX_new(DTLSv1_method());
+#else
+	rtp->ssl_ctx = SSL_CTX_new(DTLS_method());
+#endif
+	if (!rtp->ssl_ctx) {
 		return -1;
 	}
 
 	SSL_CTX_set_read_ahead(rtp->ssl_ctx, 1);
 
-#ifdef HAVE_OPENSSL_ECDH_AUTO
-	SSL_CTX_set_ecdh_auto(rtp->ssl_ctx, 1);
-#else
+#ifdef HAVE_OPENSSL_EC
+
+	if (!ast_strlen_zero(dtls_cfg->pvtfile)) {
+		BIO *bio = BIO_new_file(dtls_cfg->pvtfile, "r");
+		if (bio != NULL) {
+			DH *dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
+			if (dh != NULL) {
+				if (SSL_CTX_set_tmp_dh(rtp->ssl_ctx, dh)) {
+					long options = SSL_OP_CIPHER_SERVER_PREFERENCE |
+						SSL_OP_SINGLE_DH_USE | SSL_OP_SINGLE_ECDH_USE;
+					options = SSL_CTX_set_options(rtp->ssl_ctx, options);
+					ast_verb(2, "DTLS DH initialized, PFS enabled\n");
+				}
+				DH_free(dh);
+			}
+			BIO_free(bio);
+		}
+	}
+	/* enables AES-128 ciphers, to get AES-256 use NID_secp384r1 */
 	ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
-	if (ecdh) {
-		SSL_CTX_set_tmp_ecdh(rtp->ssl_ctx, ecdh);
+	if (ecdh != NULL) {
+		if (SSL_CTX_set_tmp_ecdh(rtp->ssl_ctx, ecdh)) {
+			#ifndef SSL_CTRL_SET_ECDH_AUTO
+				#define SSL_CTRL_SET_ECDH_AUTO 94
+			#endif
+			/* SSL_CTX_set_ecdh_auto(rtp->ssl_ctx, on); requires OpenSSL 1.0.2 which wraps: */
+			if (SSL_CTX_ctrl(rtp->ssl_ctx, SSL_CTRL_SET_ECDH_AUTO, 1, NULL)) {
+				ast_verb(2, "DTLS ECDH initialized (automatic), faster PFS enabled\n");
+			} else {
+				ast_verb(2, "DTLS ECDH initialized (secp256r1), faster PFS enabled\n");
+			}
+		}
 		EC_KEY_free(ecdh);
 	}
-#endif
+
+#endif /* #ifdef HAVE_OPENSSL_EC */
 
 	rtp->dtls_verify = dtls_cfg->verify;
 
@@ -1393,7 +1602,7 @@ static int ast_rtp_dtls_set_configuratio
 	if (!ast_strlen_zero(dtls_cfg->certfile)) {
 		char *private = ast_strlen_zero(dtls_cfg->pvtfile) ? dtls_cfg->certfile : dtls_cfg->pvtfile;
 		BIO *certbio;
-		X509 *cert;
+		X509 *cert = NULL;
 		const EVP_MD *type;
 		unsigned int size, i;
 		unsigned char fingerprint[EVP_MAX_MD_SIZE];
@@ -1412,12 +1621,6 @@ static int ast_rtp_dtls_set_configuratio
 			return -1;
 		}
 
-		if (!(certbio = BIO_new(BIO_s_file()))) {
-			ast_log(LOG_ERROR, "Failed to allocate memory for certificate fingerprinting on RTP instance '%p'\n",
-				instance);
-			return -1;
-		}
-
 		if (rtp->local_hash == AST_RTP_DTLS_HASH_SHA1) {
 			type = EVP_sha1();
 		} else if (rtp->local_hash == AST_RTP_DTLS_HASH_SHA256) {
@@ -1428,6 +1631,12 @@ static int ast_rtp_dtls_set_configuratio
 			return -1;
 		}
 
+		if (!(certbio = BIO_new(BIO_s_file()))) {
+			ast_log(LOG_ERROR, "Failed to allocate memory for certificate fingerprinting on RTP instance '%p'\n",
+				instance);
+			return -1;
+		}
+
 		if (!BIO_read_filename(certbio, dtls_cfg->certfile) ||
 		    !(cert = PEM_read_bio_X509(certbio, NULL, 0, NULL)) ||
 		    !X509_digest(cert, type, fingerprint, &size) ||
@@ -1435,6 +1644,9 @@ static int ast_rtp_dtls_set_configuratio
 			ast_log(LOG_ERROR, "Could not produce fingerprint from certificate '%s' for RTP instance '%p'\n",
 				dtls_cfg->certfile, instance);
 			BIO_free_all(certbio);
+			if (cert) {
+				X509_free(cert);
+			}
 			return -1;
 		}
 
@@ -1446,6 +1658,7 @@ static int ast_rtp_dtls_set_configuratio
 		*(local_fingerprint-1) = 0;
 
 		BIO_free_all(certbio);
+		X509_free(cert);
 	}
 
 	if (!ast_strlen_zero(dtls_cfg->cipher)) {
@@ -1475,6 +1688,7 @@ static int ast_rtp_dtls_set_configuratio
 	return res;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtls_active(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1482,11 +1696,15 @@ static int ast_rtp_dtls_active(struct as
 	return !rtp->ssl_ctx ? 0 : 1;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_dtls_stop(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	SSL *ssl = rtp->dtls.ssl;
 
+	ao2_unlock(instance);
 	dtls_srtp_stop_timeout_timer(instance, rtp, 0);
+	ao2_lock(instance);
 
 	if (rtp->ssl_ctx) {
 		SSL_CTX_free(rtp->ssl_ctx);
@@ -1496,20 +1714,23 @@ static void ast_rtp_dtls_stop(struct ast
 	if (rtp->dtls.ssl) {
 		SSL_free(rtp->dtls.ssl);
 		rtp->dtls.ssl = NULL;
-		ast_mutex_destroy(&rtp->dtls.lock);
 	}
 
 	if (rtp->rtcp) {
+		ao2_unlock(instance);
 		dtls_srtp_stop_timeout_timer(instance, rtp, 1);
+		ao2_lock(instance);
 
 		if (rtp->rtcp->dtls.ssl) {
-			SSL_free(rtp->rtcp->dtls.ssl);
+			if (rtp->rtcp->dtls.ssl != ssl) {
+				SSL_free(rtp->rtcp->dtls.ssl);
+			}
 			rtp->rtcp->dtls.ssl = NULL;
-			ast_mutex_destroy(&rtp->rtcp->dtls.lock);
 		}
 	}
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_dtls_reset(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1525,6 +1746,7 @@ static void ast_rtp_dtls_reset(struct as
 	}
 }
 
+/*! \pre instance is locked */
 static enum ast_rtp_dtls_connection ast_rtp_dtls_get_connection(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1532,6 +1754,7 @@ static enum ast_rtp_dtls_connection ast_
 	return rtp->dtls.connection;
 }
 
+/*! \pre instance is locked */
 static enum ast_rtp_dtls_setup ast_rtp_dtls_get_setup(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1583,6 +1806,7 @@ static void dtls_set_setup(enum ast_rtp_
 	}
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_dtls_set_setup(struct ast_rtp_instance *instance, enum ast_rtp_dtls_setup setup)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1596,6 +1820,7 @@ static void ast_rtp_dtls_set_setup(struc
 	}
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_dtls_set_fingerprint(struct ast_rtp_instance *instance, enum ast_rtp_dtls_hash hash, const char *fingerprint)
 {
 	char *tmp = ast_strdupa(fingerprint), *value;
@@ -1613,6 +1838,7 @@ static void ast_rtp_dtls_set_fingerprint
 	}
 }
 
+/*! \pre instance is locked */
 static enum ast_rtp_dtls_hash ast_rtp_dtls_get_fingerprint_hash(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1620,6 +1846,7 @@ static enum ast_rtp_dtls_hash ast_rtp_dt
 	return rtp->local_hash;
 }
 
+/*! \pre instance is locked */
 static const char *ast_rtp_dtls_get_fingerprint(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1679,6 +1906,7 @@ static struct ast_rtp_engine asterisk_rt
 };
 
 #ifdef HAVE_OPENSSL_SRTP
+/*! \pre instance is locked */
 static void dtls_perform_handshake(struct ast_rtp_instance *instance, struct dtls_details *dtls, int rtcp)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1693,56 +1921,70 @@ static void dtls_perform_handshake(struc
 
 	SSL_do_handshake(dtls->ssl);
 
-	/* Since the handshake is started in a thread outside of the channel thread it's possible
-	 * for the response to be handled in the channel thread before we start the timeout timer.
-	 * To ensure this doesn't actually happen we hold the DTLS lock. The channel thread will
-	 * block until we're done at which point the timeout timer will be immediately stopped.
+	/*
+	 * A race condition is prevented between this function and __rtp_recvfrom()
+	 * because both functions have to get the instance lock before they can do
+	 * anything.  Without holding the instance lock, this function could start
+	 * the SSL handshake above in one thread and the __rtp_recvfrom() function
+	 * called by the channel thread could read the response and stop the timeout
+	 * timer before we have a chance to even start it.
 	 */
-	ast_mutex_lock(&dtls->lock);
-	dtls_srtp_check_pending(instance, rtp, rtcp);
 	dtls_srtp_start_timeout_timer(instance, rtp, rtcp);
-	ast_mutex_unlock(&dtls->lock);
+
+	/*
+	 * We must call dtls_srtp_check_pending() after starting the timer.
+	 * Otherwise we won't prevent the race condition.
+	 */
+	dtls_srtp_check_pending(instance, rtp, rtcp);
 }
 #endif
 
 #ifdef HAVE_PJPROJECT
 static void rtp_learning_seq_init(struct rtp_learning_info *info, uint16_t seq);
 
+/* PJPROJECT ICE callback */
 static void ast_rtp_on_ice_complete(pj_ice_sess *ice, pj_status_t status)
 {
 	struct ast_rtp_instance *instance = ice->user_data;
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 
+	ao2_lock(instance);
 	if (status == PJ_SUCCESS) {
 		struct ast_sockaddr remote_address;
 
-		/* Symmetric RTP must be disabled for the remote address to not get overwritten */
-		ast_rtp_instance_set_prop(instance, AST_RTP_PROPERTY_NAT, 0);
+		ast_sockaddr_setnull(&remote_address);
+		update_address_with_ice_candidate(ice, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
+		if (!ast_sockaddr_isnull(&remote_address)) {
+			/* Symmetric RTP must be disabled for the remote address to not get overwritten */
+			ast_rtp_instance_set_prop(instance, AST_RTP_PROPERTY_NAT, 0);
 
-		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
-		ast_rtp_instance_set_remote_address(instance, &remote_address);
+			ast_rtp_instance_set_remote_address(instance, &remote_address);
+		}
 
 		if (rtp->rtcp) {
-			update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTCP, &rtp->rtcp->them);
+			update_address_with_ice_candidate(ice, AST_RTP_ICE_COMPONENT_RTCP, &rtp->rtcp->them);
 		}
 	}
- 
+
 #ifdef HAVE_OPENSSL_SRTP
 	dtls_perform_handshake(instance, &rtp->dtls, 0);
 
-	if (rtp->rtcp) {
+	if (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
 		dtls_perform_handshake(instance, &rtp->rtcp->dtls, 1);
 	}
 #endif
 
 	if (!strictrtp) {
+		ao2_unlock(instance);
 		return;
 	}
 
 	rtp->strict_rtp_state = STRICT_RTP_LEARN;
 	rtp_learning_seq_init(&rtp->rtp_source_learn, (uint16_t)rtp->seqno);
+	ao2_unlock(instance);
 }
 
+/* PJPROJECT ICE callback */
 static void ast_rtp_on_ice_rx_data(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, void *pkt, pj_size_t size, const pj_sockaddr_t *src_addr, unsigned src_addr_len)
 {
 	struct ast_rtp_instance *instance = ice->user_data;
@@ -1759,6 +2001,7 @@ static void ast_rtp_on_ice_rx_data(pj_ic
 	}
 }
 
+/* PJPROJECT ICE callback */
 static pj_status_t ast_rtp_on_ice_tx_pkt(pj_ice_sess *ice, unsigned comp_id, unsigned transport_id, const void *pkt, pj_size_t size, const pj_sockaddr_t *dst_addr, unsigned dst_addr_len)
 {
 	struct ast_rtp_instance *instance = ice->user_data;
@@ -1855,6 +2098,7 @@ static inline int rtcp_debug_test_addr(s
 }
 
 #ifdef HAVE_OPENSSL_SRTP
+/*! \pre instance is locked */
 static int dtls_srtp_handle_timeout(struct ast_rtp_instance *instance, int rtcp)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -1873,13 +2117,15 @@ static int dtls_srtp_handle_timeout(stru
 	return dtls_timeout.tv_sec * 1000 + dtls_timeout.tv_usec / 1000;
 }
 
+/* Scheduler callback */
 static int dtls_srtp_handle_rtp_timeout(const void *data)
 {
 	struct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;
 	int reschedule;
 
+	ao2_lock(instance);
 	reschedule = dtls_srtp_handle_timeout(instance, 0);
-
+	ao2_unlock(instance);
 	if (!reschedule) {
 		ao2_ref(instance, -1);
 	}
@@ -1887,13 +2133,15 @@ static int dtls_srtp_handle_rtp_timeout(
 	return reschedule;
 }
 
+/* Scheduler callback */
 static int dtls_srtp_handle_rtcp_timeout(const void *data)
 {
 	struct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;
 	int reschedule;
 
+	ao2_lock(instance);
 	reschedule = dtls_srtp_handle_timeout(instance, 1);
-
+	ao2_unlock(instance);
 	if (!reschedule) {
 		ao2_ref(instance, -1);
 	}
@@ -1921,6 +2169,7 @@ static void dtls_srtp_start_timeout_time
 	}
 }
 
+/*! \pre Must not be called with the instance locked. */
 static void dtls_srtp_stop_timeout_timer(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp)
 {
 	struct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;
@@ -1928,6 +2177,7 @@ static void dtls_srtp_stop_timeout_timer
 	AST_SCHED_DEL_UNREF(rtp->sched, dtls->timeout_timer, ao2_ref(instance, -1));
 }
 
+/*! \pre instance is locked */
 static void dtls_srtp_check_pending(struct ast_rtp_instance *instance, struct ast_rtp *rtp, int rtcp)
 {
 	struct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;
@@ -1961,22 +2211,27 @@ static void dtls_srtp_check_pending(stru
 	}
 }
 
+/* Scheduler callback */
 static int dtls_srtp_renegotiate(const void *data)
 {
 	struct ast_rtp_instance *instance = (struct ast_rtp_instance *)data;
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 
+	ao2_lock(instance);
+
 	SSL_renegotiate(rtp->dtls.ssl);
 	SSL_do_handshake(rtp->dtls.ssl);
 	dtls_srtp_check_pending(instance, rtp, 0);
 
-	if (rtp->rtcp && rtp->rtcp->dtls.ssl) {
+	if (rtp->rtcp && rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {
 		SSL_renegotiate(rtp->rtcp->dtls.ssl);
 		SSL_do_handshake(rtp->rtcp->dtls.ssl);
 		dtls_srtp_check_pending(instance, rtp, 1);
 	}
 
 	rtp->rekeyid = -1;
+
+	ao2_unlock(instance);
 	ao2_ref(instance, -1);
 
 	return 0;
@@ -2118,6 +2373,40 @@ error:
 }
 #endif
 
+static int rtcp_mux(struct ast_rtp *rtp, const unsigned char *packet)
+{
+	uint8_t version;
+	uint8_t pt;
+	uint8_t m;
+
+	if (!rtp->rtcp || rtp->rtcp->type != AST_RTP_INSTANCE_RTCP_MUX) {
+		return 0;
+	}
+
+	version = (packet[0] & 0XC0) >> 6;
+	if (version == 0) {
+		/* version 0 indicates this is a STUN packet and shouldn't
+		 * be interpreted as a possible RTCP packet
+		 */
+		return 0;
+	}
+
+	/* The second octet of a packet will be one of the following:
+	 * For RTP: The marker bit (1 bit) and the RTP payload type (7 bits)
+	 * For RTCP: The payload type (8)
+	 *
+	 * RTP has a forbidden range of payload types (64-95) since these
+	 * will conflict with RTCP payload numbers if the marker bit is set.
+	 */
+	m = packet[1] & 0x80;
+	pt = packet[1] & 0x7F;
+	if (m && pt >= 64 && pt <= 95) {
+		return 1;
+	}
+	return 0;
+}
+
+/*! \pre instance is locked */
 static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)
 {
 	int len;
@@ -2146,14 +2435,18 @@ static int __rtp_recvfrom(struct ast_rtp
 			return -1;
 		}
 
-		/* This mutex is locked so that this thread blocks until the dtls_perform_handshake function
-		 * completes.
+		/*
+		 * A race condition is prevented between dtls_perform_handshake()
+		 * and this function because both functions have to get the
+		 * instance lock before they can do anything.  The
+		 * dtls_perform_handshake() function needs to start the timer
+		 * before we stop it below.
 		 */
-		ast_mutex_lock(&dtls->lock);
-		ast_mutex_unlock(&dtls->lock);
 
 		/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */
+		ao2_unlock(instance);
 		dtls_srtp_stop_timeout_timer(instance, rtp, rtcp);
+		ao2_lock(instance);
 
 		/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */
 		if (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {
@@ -2204,14 +2497,22 @@ static int __rtp_recvfrom(struct ast_rtp
 		pj_str_t combined = pj_str(ast_sockaddr_stringify(sa));
 		pj_sockaddr address;
 		pj_status_t status;
+		struct ice_wrap *ice;
 
 		pj_thread_register_check();
 
 		pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);
 
-		status = pj_ice_sess_on_rx_pkt(rtp->ice, rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ice = rtp->ice;
+		ao2_ref(ice, +1);
+		ao2_unlock(instance);
+		status = pj_ice_sess_on_rx_pkt(ice->real_ice,
+			rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,
 			rtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,
 			pj_sockaddr_get_len(&address));
+		ao2_ref(ice, -1);
+		ao2_lock(instance);
 		if (status != PJ_SUCCESS) {
 			char buf[100];
 
@@ -2221,30 +2522,45 @@ static int __rtp_recvfrom(struct ast_rtp
 			return -1;
 		}
 		if (!rtp->passthrough) {
+			/* If a unidirectional ICE negotiation occurs then lock on to the source of the
+			 * ICE traffic and use it as the target. This will occur if the remote side only
+			 * wants to receive media but never send to us.
+			 */
+			if (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {
+				if (rtcp) {
+					ast_sockaddr_copy(&rtp->rtcp->them, sa);
+				} else {
+					ast_rtp_instance_set_remote_address(instance, sa);
+				}
+			}
 			return 0;
 		}
 		rtp->passthrough = 0;
 	}
 #endif
 
-	if ((*in & 0xC0) && res_srtp && srtp && res_srtp->unprotect(srtp, buf, &len, rtcp) < 0) {
+	if ((*in & 0xC0) && res_srtp && srtp && res_srtp->unprotect(
+		    srtp, buf, &len, rtcp || rtcp_mux(rtp, buf)) < 0) {
 	   return -1;
 	}
 
 	return len;
 }
 
+/*! \pre instance is locked */
 static int rtcp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa)
 {
 	return __rtp_recvfrom(instance, buf, size, flags, sa, 1);
 }
 
+/*! \pre instance is locked */
 static int rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa)
 {
 	return __rtp_recvfrom(instance, buf, size, flags, sa, 0);
 }
 
-static int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *ice, int use_srtp)
+/*! \pre instance is locked */
+static int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *via_ice, int use_srtp)
 {
 	int len = size;
 	void *temp = buf;
@@ -2252,7 +2568,7 @@ static int __rtp_sendto(struct ast_rtp_i
 	struct ast_srtp *srtp = ast_rtp_instance_get_srtp(instance, rtcp);
 	int res;
 
-	*ice = 0;
+	*via_ice = 0;
 
 	if (use_srtp && res_srtp && srtp && res_srtp->protect(srtp, &temp, &len, rtcp) < 0) {
 		return -1;
@@ -2260,10 +2576,21 @@ static int __rtp_sendto(struct ast_rtp_i
 
 #ifdef HAVE_PJPROJECT
 	if (rtp->ice) {
+		pj_status_t status;
+		struct ice_wrap *ice;
+
 		pj_thread_register_check();
 
-		if (pj_ice_sess_send_data(rtp->ice, rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP, temp, len) == PJ_SUCCESS) {
-			*ice = 1;
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ice = rtp->ice;
+		ao2_ref(ice, +1);
+		ao2_unlock(instance);
+		status = pj_ice_sess_send_data(ice->real_ice,
+			rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP, temp, len);
+		ao2_ref(ice, -1);
+		ao2_lock(instance);
+		if (status == PJ_SUCCESS) {
+			*via_ice = 1;
 			return len;
 		}
 	}
@@ -2277,11 +2604,13 @@ static int __rtp_sendto(struct ast_rtp_i
 	return res;
 }
 
+/*! \pre instance is locked */
 static int rtcp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int *ice)
 {
 	return __rtp_sendto(instance, buf, size, flags, sa, 1, ice, 1);
 }
 
+/*! \pre instance is locked */
 static int rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int *ice)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2404,11 +2733,65 @@ static int rtp_learning_rtp_seq_update(s
 }
 
 #ifdef HAVE_PJPROJECT
+/*!
+ * \internal
+ * \brief Checks an address against the ICE blacklist
+ * \note If there is no ice_blacklist list, always returns 0
+ *
+ * \param address The address to consider
+ * \retval 0 if address is not ICE blacklisted
+ * \retval 1 if address is ICE blacklisted
+ */
+static int rtp_address_is_ice_blacklisted(const pj_sockaddr_t *address)
+{
+	char buf[PJ_INET6_ADDRSTRLEN];
+	struct ast_sockaddr saddr;
+	int result = 1;
+
+	ast_sockaddr_parse(&saddr, pj_sockaddr_print(address, buf, sizeof(buf), 0), 0);
+
+	ast_rwlock_rdlock(&ice_blacklist_lock);
+	if (!ice_blacklist || (ast_apply_ha(ice_blacklist, &saddr) == AST_SENSE_ALLOW)) {
+		result = 0;
+	}
+	ast_rwlock_unlock(&ice_blacklist_lock);
+
+	return result;
+}
+
+/*!
+ * \internal
+ * \brief Checks an address against the STUN blacklist
+ * \since 13.16.0
+ *
+ * \note If there is no stun_blacklist list, always returns 0
+ *
+ * \param addr The address to consider
+ *
+ * \retval 0 if address is not STUN blacklisted
+ * \retval 1 if address is STUN blacklisted
+ */
+static int stun_address_is_blacklisted(const struct ast_sockaddr *addr)
+{
+	int result = 1;
+
+	ast_rwlock_rdlock(&stun_blacklist_lock);
+	if (!stun_blacklist
+		|| ast_apply_ha(stun_blacklist, addr) == AST_SENSE_ALLOW) {
+		result = 0;
+	}
+	ast_rwlock_unlock(&stun_blacklist_lock);
+
+	return result;
+}
+
+/*! \pre instance is locked */
 static void rtp_add_candidates_to_ice(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *addr, int port, int component,
 				      int transport)
 {
-	pj_sockaddr address[16];
+	pj_sockaddr address[PJ_ICE_MAX_CAND];
 	unsigned int count = PJ_ARRAY_SIZE(address), pos = 0;
+	int basepos = -1;
 
 	/* Add all the local interface IP addresses */
 	if (ast_sockaddr_is_ipv4(addr)) {
@@ -2422,26 +2805,59 @@ static void rtp_add_candidates_to_ice(st
 	host_candidate_overrides_apply(count, address);
 
 	for (pos = 0; pos < count; pos++) {
-		pj_sockaddr_set_port(&address[pos], port);
-		ast_rtp_ice_add_cand(rtp, component, transport, PJ_ICE_CAND_TYPE_HOST, 65535, &address[pos], &address[pos], NULL,
-				     pj_sockaddr_get_len(&address[pos]));
+		if (!rtp_address_is_ice_blacklisted(&address[pos])) {
+			if (basepos == -1) {
+				basepos = pos;
+			}
+			pj_sockaddr_set_port(&address[pos], port);
+			ast_rtp_ice_add_cand(instance, rtp, component, transport,
+				PJ_ICE_CAND_TYPE_HOST, 65535, &address[pos], &address[pos], NULL,
+				pj_sockaddr_get_len(&address[pos]));
+		}
+	}
+	if (basepos == -1) {
+		/* start with first address unless excluded above */
+		basepos = 0;
 	}
 
 	/* If configured to use a STUN server to get our external mapped address do so */
-	if (stunaddr.sin_addr.s_addr && ast_sockaddr_is_ipv4(addr) && count) {
+	if (stunaddr.sin_addr.s_addr && count && ast_sockaddr_is_ipv4(addr)
+		&& !stun_address_is_blacklisted(addr)) {
 		struct sockaddr_in answer;
+		int rsp;
 
-		if (!ast_stun_request(component == AST_RTP_ICE_COMPONENT_RTCP ? rtp->rtcp->s : rtp->s, &stunaddr, NULL, &answer)) {
+		/*
+		 * The instance should not be locked because we can block
+		 * waiting for a STUN respone.
+		 */
+		ao2_unlock(instance);
+		rsp = ast_stun_request(component == AST_RTP_ICE_COMPONENT_RTCP
+			? rtp->rtcp->s : rtp->s, &stunaddr, NULL, &answer);
+		ao2_lock(instance);
+		if (!rsp) {
 			pj_sockaddr base;
+			pj_sockaddr ext;
 			pj_str_t mapped = pj_str(ast_strdupa(ast_inet_ntoa(answer.sin_addr)));
+			int srflx = 1;
 
 			/* Use the first local host candidate as the base */
-			pj_sockaddr_cp(&base, &address[0]);
+			pj_sockaddr_cp(&base, &address[basepos]);
 
-			pj_sockaddr_init(pj_AF_INET(), &address[0], &mapped, ntohs(answer.sin_port));
+			pj_sockaddr_init(pj_AF_INET(), &ext, &mapped, ntohs(answer.sin_port));
+
+			/* If the returned address is the same as one of our host candidates, don't send the srflx */
+			for (pos = 0; pos < count; pos++) {
+				if ((pj_sockaddr_cmp(&address[pos], &ext) == 0) && !rtp_address_is_ice_blacklisted(&address[pos])) {
+					srflx = 0;
+					break;
+				}
+			}
 
-			ast_rtp_ice_add_cand(rtp, component, transport, PJ_ICE_CAND_TYPE_SRFLX, 65535, &address[0], &base,
-					     &base, pj_sockaddr_get_len(&address[0]));
+			if (srflx) {
+				ast_rtp_ice_add_cand(instance, rtp, component, transport,
+					PJ_ICE_CAND_TYPE_SRFLX, 65535, &ext, &base, &base,
+					pj_sockaddr_get_len(&ext));
+			}
 		}
 	}
 
@@ -2492,6 +2908,8 @@ static unsigned int calc_txstamp(struct
  * \param port port to use for adding RTP candidates to the ICE session
  * \param replace 0 when creating a new session, 1 when replacing a destroyed session
  *
+ * \pre instance is locked
+ *
  * \retval 0 on success
  * \retval -1 on failure
  */
@@ -2500,11 +2918,21 @@ static int ice_create(struct ast_rtp_ins
 {
 	pj_stun_config stun_config;
 	pj_str_t ufrag, passwd;
+	pj_status_t status;
+	struct ice_wrap *ice_old;
+	struct ice_wrap *ice;
+	pj_ice_sess *real_ice = NULL;
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 
 	ao2_cleanup(rtp->ice_local_candidates);
 	rtp->ice_local_candidates = NULL;
 
+	ice = ao2_alloc_options(sizeof(*ice), ice_wrap_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);
+	if (!ice) {
+		ast_rtp_ice_stop(instance);
+		return -1;
+	}
+
 	pj_thread_register_check();
 
 	pj_stun_config_init(&stun_config, &cachingpool.factory, 0, NULL, timer_heap);
@@ -2512,19 +2940,32 @@ static int ice_create(struct ast_rtp_ins
 	ufrag = pj_str(rtp->local_ufrag);
 	passwd = pj_str(rtp->local_passwd);
 
+	/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+	ao2_unlock(instance);
 	/* Create an ICE session for ICE negotiation */
-	if (pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN, 2,
-			&ast_rtp_ice_sess_cb, &ufrag, &passwd, NULL, &rtp->ice) == PJ_SUCCESS) {
-		/* Make this available for the callbacks */
-		rtp->ice->user_data = instance;
+	status = pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN,
+		rtp->ice_num_components, &ast_rtp_ice_sess_cb, &ufrag, &passwd, NULL, &real_ice);
+	ao2_lock(instance);
+	if (status == PJ_SUCCESS) {
+		/* Safely complete linking the ICE session into the instance */
+		real_ice->user_data = instance;
+		ice->real_ice = real_ice;
+		ice_old = rtp->ice;
+		rtp->ice = ice;
+		if (ice_old) {
+			ao2_unlock(instance);
+			ao2_ref(ice_old, -1);
+			ao2_lock(instance);
+		}
 
 		/* Add all of the available candidates to the ICE session */
 		rtp_add_candidates_to_ice(instance, rtp, addr, port, AST_RTP_ICE_COMPONENT_RTP,
 			TRANSPORT_SOCKET_RTP);
 
-		/* Only add the RTCP candidates to ICE when replacing the session. New sessions
+		/* Only add the RTCP candidates to ICE when replacing the session and if
+		 * the ICE session contains more than just an RTP component. New sessions
 		 * handle this in a separate part of the setup phase */
-		if (replace && rtp->rtcp) {
+		if (replace && rtp->rtcp && rtp->ice_num_components > 1) {
 			rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us,
 				ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP,
 				TRANSPORT_SOCKET_RTCP);
@@ -2533,11 +2974,19 @@ static int ice_create(struct ast_rtp_ins
 		return 0;
 	}
 
+	/*
+	 * It is safe to unref this while instance is locked here.
+	 * It was not initialized with a real_ice pointer.
+	 */
+	ao2_ref(ice, -1);
+
+	ast_rtp_ice_stop(instance);
 	return -1;
 
 }
 #endif
 
+/*! \pre instance is locked */
 static int ast_rtp_new(struct ast_rtp_instance *instance,
 		       struct ast_sched_context *sched, struct ast_sockaddr *addr,
 		       void *data)
@@ -2550,13 +2999,9 @@ static int ast_rtp_new(struct ast_rtp_in
 		return -1;
 	}
 
-	/* Initialize synchronization aspects */
-	ast_mutex_init(&rtp->lock);
-	ast_cond_init(&rtp->cond, NULL);
-
 	/* Set default parameters on the newly created RTP structure */
 	rtp->ssrc = ast_random();
-	rtp->seqno = ast_random() & 0xffff;
+	rtp->seqno = ast_random() & 0x7fff;
 	rtp->strict_rtp_state = (strictrtp ? STRICT_RTP_LEARN : STRICT_RTP_OPEN);
 	if (strictrtp) {
 		rtp_learning_seq_init(&rtp->rtp_source_learn, (uint16_t)rtp->seqno);
@@ -2602,6 +3047,9 @@ static int ast_rtp_new(struct ast_rtp_in
 	}
 
 #ifdef HAVE_PJPROJECT
+	/* Initialize synchronization aspects */
+	ast_cond_init(&rtp->cond, NULL);
+
 	generate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));
 	generate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));
 #endif
@@ -2609,16 +3057,16 @@ static int ast_rtp_new(struct ast_rtp_in
 #ifdef HAVE_PJPROJECT
 	/* Create an ICE session for ICE negotiation */
 	if (icesupport) {
+		rtp->ice_num_components = 2;
 		ast_debug(3, "Creating ICE session %s (%d) for RTP instance '%p'\n", ast_sockaddr_stringify(addr), x, instance);
 		if (ice_create(instance, addr, x, 0)) {
-			ast_log(LOG_NOTICE, "Failed to start ICE session\n");
+			ast_log(LOG_NOTICE, "Failed to create ICE session\n");
 		} else {
 			rtp->ice_port = x;
 			ast_sockaddr_copy(&rtp->ice_original_rtp_addr, addr);
 		}
 	}
 #endif
-
 	/* Record any information we may need */
 	rtp->sched = sched;
 
@@ -2634,6 +3082,7 @@ static int ast_rtp_new(struct ast_rtp_in
 	return 0;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_destroy(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2664,46 +3113,54 @@ static int ast_rtp_destroy(struct ast_rt
 		 * RTP instance while it's active.
 		 */
 		close(rtp->rtcp->s);
+		ast_free(rtp->rtcp->local_addr_str);
 		ast_free(rtp->rtcp);
 	}
 
 	/* Destroy RED if it was being used */
 	if (rtp->red) {
+		ao2_unlock(instance);
 		AST_SCHED_DEL(rtp->sched, rtp->red->schedid);
+		ao2_lock(instance);
 		ast_free(rtp->red);
+		rtp->red = NULL;
 	}
 
 #ifdef HAVE_PJPROJECT
 	pj_thread_register_check();
 
-	/* Destroy the RTP TURN relay if being used */
-	ast_mutex_lock(&rtp->lock);
+	/*
+	 * The instance lock is already held.
+	 *
+	 * Destroy the RTP TURN relay if being used
+	 */
 	if (rtp->turn_rtp) {
-		pj_turn_sock_destroy(rtp->turn_rtp);
 		rtp->turn_state = PJ_TURN_STATE_NULL;
+
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ao2_unlock(instance);
+		pj_turn_sock_destroy(rtp->turn_rtp);
+		ao2_lock(instance);
 		while (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {
-			ast_cond_timedwait(&rtp->cond, &rtp->lock, &ts);
+			ast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);
 		}
 	}
 
 	/* Destroy the RTCP TURN relay if being used */
 	if (rtp->turn_rtcp) {
-		pj_turn_sock_destroy(rtp->turn_rtcp);
 		rtp->turn_state = PJ_TURN_STATE_NULL;
+
+		/* Release the instance lock to avoid deadlock with PJPROJECT group lock */
+		ao2_unlock(instance);
+		pj_turn_sock_destroy(rtp->turn_rtcp);
+		ao2_lock(instance);
 		while (rtp->turn_state != PJ_TURN_STATE_DESTROYING) {
-			ast_cond_timedwait(&rtp->cond, &rtp->lock, &ts);
+			ast_cond_timedwait(&rtp->cond, ao2_object_get_lockaddr(instance), &ts);
 		}
 	}
-	ast_mutex_unlock(&rtp->lock);
 
-	if (rtp->ioqueue) {
-		rtp_ioqueue_thread_remove(rtp->ioqueue);
-	}
-
-	/* Destroy the ICE session if being used */
-	if (rtp->ice) {
-		pj_ice_sess_destroy(rtp->ice);
-	}
+	/* Destroy any ICE session */
+	ast_rtp_ice_stop(instance);
 
 	/* Destroy any candidates */
 	if (rtp->ice_local_candidates) {
@@ -2713,15 +3170,27 @@ static int ast_rtp_destroy(struct ast_rt
 	if (rtp->ice_active_remote_candidates) {
 		ao2_ref(rtp->ice_active_remote_candidates, -1);
 	}
+
+	if (rtp->ioqueue) {
+		/*
+		 * We cannot hold the instance lock because we could wait
+		 * for the ioqueue thread to die and we might deadlock as
+		 * a result.
+		 */
+		ao2_unlock(instance);
+		rtp_ioqueue_thread_remove(rtp->ioqueue);
+		ao2_lock(instance);
+	}
 #endif
 
 	ao2_cleanup(rtp->lasttxformat);
 	ao2_cleanup(rtp->lastrxformat);
 	ao2_cleanup(rtp->f.subclass.format);
 
+#ifdef HAVE_PJPROJECT
 	/* Destroy synchronization items */
-	ast_mutex_destroy(&rtp->lock);
 	ast_cond_destroy(&rtp->cond);
+#endif
 
 	/* Finally destroy ourselves */
 	ast_free(rtp);
@@ -2729,6 +3198,7 @@ static int ast_rtp_destroy(struct ast_rt
 	return 0;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtmf_mode_set(struct ast_rtp_instance *instance, enum ast_rtp_dtmf_mode dtmf_mode)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2736,12 +3206,14 @@ static int ast_rtp_dtmf_mode_set(struct
 	return 0;
 }
 
+/*! \pre instance is locked */
 static enum ast_rtp_dtmf_mode ast_rtp_dtmf_mode_get(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	return rtp->dtmfmode;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtmf_begin(struct ast_rtp_instance *instance, char digit)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2816,6 +3288,7 @@ static int ast_rtp_dtmf_begin(struct ast
 	return 0;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtmf_continuation(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2861,6 +3334,7 @@ static int ast_rtp_dtmf_continuation(str
 	return 0;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtmf_end_with_duration(struct ast_rtp_instance *instance, char digit, unsigned int duration)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2940,11 +3414,13 @@ cleanup:
 	return res;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_dtmf_end(struct ast_rtp_instance *instance, char digit)
 {
 	return ast_rtp_dtmf_end_with_duration(instance, digit, 0);
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_update_source(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2956,6 +3432,7 @@ static void ast_rtp_update_source(struct
 	return;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_change_source(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -2977,7 +3454,7 @@ static void ast_rtp_change_source(struct
 		ast_debug(3, "Changing ssrc for SRTP from %u to %u\n", rtp->ssrc, ssrc);
 		res_srtp->change_source(srtp, rtp->ssrc, ssrc);
 		if (rtcp_srtp != srtp) {
-			res_srtp->change_source(srtp, rtp->ssrc, ssrc);
+			res_srtp->change_source(rtcp_srtp, rtp->ssrc, ssrc);
 		}
 	}
 
@@ -2991,7 +3468,26 @@ static void timeval2ntp(struct timeval t
 	unsigned int sec, usec, frac;
 	sec = tv.tv_sec + 2208988800u; /* Sec between 1900 and 1970 */
 	usec = tv.tv_usec;
-	frac = (usec << 12) + (usec << 8) - ((usec * 3650) >> 6);
+	/*
+	 * Convert usec to 0.32 bit fixed point without overflow.
+	 *
+	 * = usec * 2^32 / 10^6
+	 * = usec * 2^32 / (2^6 * 5^6)
+	 * = usec * 2^26 / 5^6
+	 *
+	 * The usec value needs 20 bits to represent 999999 usec.  So
+	 * splitting the 2^26 to get the most precision using 32 bit
+	 * values gives:
+	 *
+	 * = ((usec * 2^12) / 5^6) * 2^14
+	 *
+	 * Splitting the division into two stages preserves all the
+	 * available significant bits of usec over doing the division
+	 * all at once.
+	 *
+	 * = ((((usec * 2^12) / 5^3) * 2^7) / 5^3) * 2^7
+	 */
+	frac = ((((usec << 12) / 125) << 7) / 125) << 7;
 	*msw = sec;
 	*lsw = frac;
 }
@@ -2999,7 +3495,8 @@ static void timeval2ntp(struct timeval t
 static void ntp2timeval(unsigned int msw, unsigned int lsw, struct timeval *tv)
 {
 	tv->tv_sec = msw - 2208988800u;
-	tv->tv_usec = ((lsw << 6) / 3650) - (lsw >> 12) - (lsw >> 8);
+	/* Reverse the sequence in timeval2ntp() */
+	tv->tv_usec = ((((lsw >> 7) * 125) >> 7) * 125) >> 12;
 }
 
 static void calculate_lost_packet_statistics(struct ast_rtp *rtp,
@@ -3058,7 +3555,11 @@ static void calculate_lost_packet_statis
 	rtp->rtcp->rxlost_count++;
 }
 
-/*! \brief Send RTCP SR or RR report */
+/*!
+ * \brief Send RTCP SR or RR report
+ *
+ * \pre instance is locked
+ */
 static int ast_rtcp_write_report(struct ast_rtp_instance *instance, int sr)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -3076,12 +3577,7 @@ static int ast_rtcp_write_report(struct
 	int rate = rtp_get_rate(rtp->f.subclass.format);
 	int ice;
 	int header_offset = 0;
-	char *str_remote_address;
-	char *str_local_address;
 	struct ast_sockaddr remote_address = { { 0, } };
-	struct ast_sockaddr local_address = { { 0, } };
-	struct ast_sockaddr real_remote_address = { { 0, } };
-	struct ast_sockaddr real_local_address = { { 0, } };
 	struct ast_rtp_rtcp_report_block *report_block = NULL;
 	RAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report,
 			ast_rtp_rtcp_report_alloc(rtp->themssrc ? 1 : 0),
@@ -3189,9 +3685,9 @@ static int ast_rtcp_write_report(struct
 				ast_sockaddr_stringify(&remote_address), ice ? " (via ICE)" : "");
 		ast_verbose("  Our SSRC: %u\n", rtcp_report->ssrc);
 		if (sr) {
-			ast_verbose("  Sent(NTP): %u.%010u\n",
+			ast_verbose("  Sent(NTP): %u.%06u\n",
 				(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,
-				(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec * 4096);
+				(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);
 			ast_verbose("  Sent(RTP): %u\n", rtcp_report->sender_information.rtp_timestamp);
 			ast_verbose("  Sent packets: %u\n", rtcp_report->sender_information.packet_count);
 			ast_verbose("  Sent octets: %u\n", rtcp_report->sender_information.octet_count);
@@ -3208,31 +3704,23 @@ static int ast_rtcp_write_report(struct
 		}
 	}
 
-	ast_rtp_instance_get_local_address(instance, &local_address);
-	if (!ast_find_ourip(&real_local_address, &local_address, 0)) {
-		str_local_address = ast_strdupa(ast_sockaddr_stringify(&real_local_address));
-	} else {
-		str_local_address = ast_strdupa(ast_sockaddr_stringify(&local_address));
-	}
-
-	if (!ast_find_ourip(&real_remote_address, &remote_address, 0)) {
-		str_remote_address = ast_strdupa(ast_sockaddr_stringify(&real_remote_address));
-	} else {
-		str_remote_address = ast_strdupa(ast_sockaddr_stringify(&remote_address));
-	}
-
 	message_blob = ast_json_pack("{s: s, s: s}",
-			"to", str_remote_address,
-			"from", str_local_address);
+			"to", ast_sockaddr_stringify(&remote_address),
+			"from", rtp->rtcp->local_addr_str);
 	ast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_sent_type(),
 			rtcp_report,
 			message_blob);
 	return res;
 }
 
-/*! \brief Write and RTCP packet to the far end
+/*!
+ * \brief Write a RTCP packet to the far end
+ *
  * \note Decide if we are going to send an SR (with Reception Block) or RR
- * RR is sent if we have not sent any rtp packets in the previous interval */
+ * RR is sent if we have not sent any rtp packets in the previous interval
+ *
+ * Scheduler callback
+ */
 static int ast_rtcp_write(const void *data)
 {
 	struct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;
@@ -3244,6 +3732,7 @@ static int ast_rtcp_write(const void *da
 		return 0;
 	}
 
+	ao2_lock(instance);
 	if (rtp->txcount > rtp->rtcp->lastsrtxcount) {
 		/* Send an SR */
 		res = ast_rtcp_write_report(instance, 1);
@@ -3251,6 +3740,7 @@ static int ast_rtcp_write(const void *da
 		/* Send an RR */
 		res = ast_rtcp_write_report(instance, 0);
 	}
+	ao2_unlock(instance);
 
 	if (!res) {
 		/*
@@ -3263,7 +3753,8 @@ static int ast_rtcp_write(const void *da
 	return res;
 }
 
-static int ast_rtp_raw_write(struct ast_rtp_instance *instance, struct ast_frame *frame, int codec)
+/*! \pre instance is locked */
+static int rtp_raw_write(struct ast_rtp_instance *instance, struct ast_frame *frame, int codec)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	int pred, mark = 0;
@@ -3389,7 +3880,8 @@ static int ast_rtp_raw_write(struct ast_
 	return 0;
 }
 
-static struct ast_frame *red_t140_to_red(struct rtp_red *red) {
+static struct ast_frame *red_t140_to_red(struct rtp_red *red)
+{
 	unsigned char *data = red->t140red.data.ptr;
 	int len = 0;
 	int i;
@@ -3428,6 +3920,7 @@ static struct ast_frame *red_t140_to_red
 	return &red->t140red;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -3456,7 +3949,7 @@ static int ast_rtp_write(struct ast_rtp_
 			return 0;
 		}
 
-		if (ast_sockaddr_isnull(&rtp->rtcp->them)) {
+		if (ast_sockaddr_isnull(&rtp->rtcp->them) || rtp->rtcp->schedid < 0) {
 			/*
 			 * RTCP was stopped.
 			 */
@@ -3532,8 +4025,13 @@ static int ast_rtp_write(struct ast_rtp_
 
 	/* If no smoother is present see if we have to set one up */
 	if (!rtp->smoother && ast_format_can_be_smoothed(format)) {
+		unsigned int smoother_flags = ast_format_get_smoother_flags(format);
 		unsigned int framing_ms = ast_rtp_codecs_get_framing(ast_rtp_instance_get_codecs(instance));
 
+		if (!framing_ms && (smoother_flags & AST_SMOOTHER_FLAG_FORCED)) {
+			framing_ms = ast_format_get_default_ms(format);
+		}
+
 		if (framing_ms) {
 			rtp->smoother = ast_smoother_new((framing_ms * ast_format_get_minimum_bytes(format)) / ast_format_get_minimum_ms(format));
 			if (!rtp->smoother) {
@@ -3541,6 +4039,7 @@ static int ast_rtp_write(struct ast_rtp_
 					ast_format_get_name(format), framing_ms, ast_format_get_minimum_bytes(format));
 				return -1;
 			}
+			ast_smoother_set_flags(rtp->smoother, smoother_flags);
 		}
 	}
 
@@ -3555,7 +4054,7 @@ static int ast_rtp_write(struct ast_rtp_
 		}
 
 		while ((f = ast_smoother_read(rtp->smoother)) && (f->data.ptr)) {
-				ast_rtp_raw_write(instance, f, codec);
+				rtp_raw_write(instance, f, codec);
 		}
 	} else {
 		int hdrlen = 12;
@@ -3567,7 +4066,7 @@ static int ast_rtp_write(struct ast_rtp_
 			f = frame;
 		}
 		if (f->data.ptr) {
-			ast_rtp_raw_write(instance, f, codec);
+			rtp_raw_write(instance, f, codec);
 		}
 		if (f != frame) {
 			ast_frfree(f);
@@ -3943,9 +4442,22 @@ static int update_rtt_stats(struct ast_r
 	lsr_a = ((msw & 0x0000ffff) << 16) | ((lsw & 0xffff0000) >> 16);
 	rtt = lsr_a - lsr - dlsr;
 	rtt_msw = (rtt & 0xffff0000) >> 16;
-	rtt_lsw = (rtt & 0x0000ffff) << 16;
+	rtt_lsw = (rtt & 0x0000ffff);
 	rtt_tv.tv_sec = rtt_msw;
-	rtt_tv.tv_usec = ((rtt_lsw << 6) / 3650) - (rtt_lsw >> 12) - (rtt_lsw >> 8);
+	/*
+	 * Convert 16.16 fixed point rtt_lsw to usec without
+	 * overflow.
+	 *
+	 * = rtt_lsw * 10^6 / 2^16
+	 * = rtt_lsw * (2^6 * 5^6) / 2^16
+	 * = rtt_lsw * 5^6 / 2^10
+	 *
+	 * The rtt_lsw value is in 16.16 fixed point format and 5^6
+	 * requires 14 bits to represent.  We have enough space to
+	 * directly do the conversion because there is no integer
+	 * component in rtt_lsw.
+	 */
+	rtt_tv.tv_usec = (rtt_lsw * 15625) >> 10;
 	rtp->rtcp->rtt = (double)rtt_tv.tv_sec + ((double)rtt_tv.tv_usec / 1000000);
 	if (lsr_a - dlsr < lsr) {
 		return 1;
@@ -4023,68 +4535,21 @@ static void update_lost_stats(struct ast
 	rtp->rtcp->reported_normdev_lost = reported_normdev_lost_current;
 }
 
-static struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance)
+static struct ast_frame *ast_rtcp_interpret(struct ast_rtp_instance *instance, const unsigned char *rtcpdata, size_t size, struct ast_sockaddr *addr)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
-	struct ast_sockaddr addr;
-	unsigned char rtcpdata[8192 + AST_FRIENDLY_OFFSET];
-	unsigned int *rtcpheader = (unsigned int *)(rtcpdata + AST_FRIENDLY_OFFSET);
-	int res, packetwords, position = 0;
+	unsigned int *rtcpheader = (unsigned int *)(rtcpdata);
+	int packetwords, position = 0;
 	int report_counter = 0;
 	struct ast_rtp_rtcp_report_block *report_block;
 	struct ast_frame *f = &ast_null_frame;
-	char *str_local_address;
-	char *str_remote_address;
-	struct ast_sockaddr local_address = { { 0,} };
-	struct ast_sockaddr real_local_address = { { 0, } };
-	struct ast_sockaddr real_remote_address = { { 0, } };
 
-	/* Read in RTCP data from the socket */
-	if ((res = rtcp_recvfrom(instance, rtcpdata + AST_FRIENDLY_OFFSET,
-				sizeof(rtcpdata) - AST_FRIENDLY_OFFSET,
-				0, &addr)) < 0) {
-		ast_assert(errno != EBADF);
-		if (errno != EAGAIN) {
-			ast_log(LOG_WARNING, "RTCP Read error: %s.  Hanging up.\n",
-				(errno) ? strerror(errno) : "Unspecified");
-			return NULL;
-		}
-		return &ast_null_frame;
-	}
-
-	/* If this was handled by the ICE session don't do anything further */
-	if (!res) {
-		return &ast_null_frame;
-	}
-
-	if (!*(rtcpdata + AST_FRIENDLY_OFFSET)) {
-		struct sockaddr_in addr_tmp;
-		struct ast_sockaddr addr_v4;
-
-		if (ast_sockaddr_is_ipv4(&addr)) {
-			ast_sockaddr_to_sin(&addr, &addr_tmp);
-		} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {
-			ast_debug(1, "Using IPv6 mapped address %s for STUN\n",
-				  ast_sockaddr_stringify(&addr));
-			ast_sockaddr_to_sin(&addr_v4, &addr_tmp);
-		} else {
-			ast_debug(1, "Cannot do STUN for non IPv4 address %s\n",
-				  ast_sockaddr_stringify(&addr));
-			return &ast_null_frame;
-		}
-		if ((ast_stun_handle_packet(rtp->rtcp->s, &addr_tmp, rtcpdata + AST_FRIENDLY_OFFSET, res, NULL, NULL) == AST_STUN_ACCEPT)) {
-			ast_sockaddr_from_sin(&addr, &addr_tmp);
-			ast_sockaddr_copy(&rtp->rtcp->them, &addr);
-		}
-		return &ast_null_frame;
-	}
-
-	packetwords = res / 4;
+	packetwords = size / 4;
 
 	if (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {
 		/* Send to whoever sent to us */
-		if (ast_sockaddr_cmp(&rtp->rtcp->them, &addr)) {
-			ast_sockaddr_copy(&rtp->rtcp->them, &addr);
+		if (ast_sockaddr_cmp(&rtp->rtcp->them, addr)) {
+			ast_sockaddr_copy(&rtp->rtcp->them, addr);
 			if (rtpdebug) {
 				ast_debug(0, "RTCP NAT: Got RTCP from other end. Now sending to address %s\n",
 					  ast_sockaddr_stringify(&rtp->rtcp->them));
@@ -4092,9 +4557,7 @@ static struct ast_frame *ast_rtcp_read(s
 		}
 	}
 
-	ast_debug(1, "Got RTCP report of %d bytes\n", res);
-
-	ast_rtp_instance_get_local_address(instance, &local_address);
+	ast_debug(1, "Got RTCP report of %zu bytes\n", size);
 
 	while (position < packetwords) {
 		int i, pt, rc;
@@ -4122,9 +4585,9 @@ static struct ast_frame *ast_rtcp_read(s
 			return &ast_null_frame;
 		}
 
-		if (rtcp_debug_test_addr(&addr)) {
+		if (rtcp_debug_test_addr(addr)) {
 			ast_verbose("\n\nGot RTCP from %s\n",
-				    ast_sockaddr_stringify(&addr));
+				    ast_sockaddr_stringify(addr));
 			ast_verbose("PT: %d(%s)\n", pt, (pt == RTCP_PT_SR) ? "Sender Report" :
 							(pt == RTCP_PT_RR) ? "Receiver Report" :
 							(pt == RTCP_PT_FUR) ? "H.261 FUR" : "Unknown");
@@ -4147,10 +4610,10 @@ static struct ast_frame *ast_rtcp_read(s
 					(unsigned int)ntohl(rtcpheader[i + 1]),
 					&rtcp_report->sender_information.ntp_timestamp);
 			rtcp_report->sender_information.rtp_timestamp = ntohl(rtcpheader[i + 2]);
-			if (rtcp_debug_test_addr(&addr)) {
-				ast_verbose("NTP timestamp: %u.%010u\n",
+			if (rtcp_debug_test_addr(addr)) {
+				ast_verbose("NTP timestamp: %u.%06u\n",
 						(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,
-						(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec * 4096);
+						(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);
 				ast_verbose("RTP timestamp: %u\n", rtcp_report->sender_information.rtp_timestamp);
 				ast_verbose("SPC: %u\tSOC: %u\n",
 						rtcp_report->sender_information.packet_count,
@@ -4179,7 +4642,7 @@ static struct ast_frame *ast_rtcp_read(s
 				report_block->dlsr = ntohl(rtcpheader[i + 5]);
 				if (report_block->lsr
 					&& update_rtt_stats(rtp, report_block->lsr, report_block->dlsr)
-					&& rtcp_debug_test_addr(&addr)) {
+					&& rtcp_debug_test_addr(addr)) {
 					struct timeval now;
 					unsigned int lsr_now, lsw, msw;
 					gettimeofday(&now, NULL);
@@ -4196,7 +4659,7 @@ static struct ast_frame *ast_rtcp_read(s
 				update_lost_stats(rtp, report_block->lost_count.packets);
 				rtp->rtcp->reported_jitter_count++;
 
-				if (rtcp_debug_test_addr(&addr)) {
+				if (rtcp_debug_test_addr(addr)) {
 					ast_verbose("  Fraction lost: %d\n", report_block->lost_count.fraction);
 					ast_verbose("  Packets lost so far: %u\n", report_block->lost_count.packets);
 					ast_verbose("  Highest sequence number: %u\n", report_block->highest_seq_no & 0x0000ffff);
@@ -4211,21 +4674,10 @@ static struct ast_frame *ast_rtcp_read(s
 			/* If and when we handle more than one report block, this should occur outside
 			 * this loop.
 			 */
-			if (!ast_find_ourip(&real_local_address, &local_address, 0)) {
-				str_local_address = ast_strdupa(ast_sockaddr_stringify(&real_local_address));
-			} else {
-				str_local_address = ast_strdupa(ast_sockaddr_stringify(&local_address));
-			}
-
-			if (!ast_find_ourip(&real_remote_address, &addr, 0)) {
-				str_remote_address = ast_strdupa(ast_sockaddr_stringify(&real_remote_address));
-			} else {
-				str_remote_address = ast_strdupa(ast_sockaddr_stringify(&addr));
-			}
 
 			message_blob = ast_json_pack("{s: s, s: s, s: f}",
-					"from", str_remote_address,
-					"to", str_local_address,
+					"from", ast_sockaddr_stringify(&rtp->rtcp->them),
+					"to", rtp->rtcp->local_addr_str,
 					"rtt", rtp->rtcp->rtt);
 			ast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_received_type(),
 					rtcp_report,
@@ -4235,7 +4687,7 @@ static struct ast_frame *ast_rtcp_read(s
 		case RTCP_PT_FUR:
 		/* Handle RTCP FIR as FUR */
 		case RTCP_PT_PSFB:
-			if (rtcp_debug_test_addr(&addr)) {
+			if (rtcp_debug_test_addr(addr)) {
 				ast_verbose("Received an RTCP Fast Update Request\n");
 			}
 			rtp->f.frametype = AST_FRAME_CONTROL;
@@ -4247,13 +4699,13 @@ static struct ast_frame *ast_rtcp_read(s
 			f = &rtp->f;
 			break;
 		case RTCP_PT_SDES:
-			if (rtcp_debug_test_addr(&addr)) {
+			if (rtcp_debug_test_addr(addr)) {
 				ast_verbose("Received an SDES from %s\n",
 					    ast_sockaddr_stringify(&rtp->rtcp->them));
 			}
 			break;
 		case RTCP_PT_BYE:
-			if (rtcp_debug_test_addr(&addr)) {
+			if (rtcp_debug_test_addr(addr)) {
 				ast_verbose("Received a BYE from %s\n",
 					    ast_sockaddr_stringify(&rtp->rtcp->them));
 			}
@@ -4268,17 +4720,73 @@ static struct ast_frame *ast_rtcp_read(s
 	rtp->rtcp->rtcp_info = 1;
 
 	return f;
+
+}
+
+/*! \pre instance is locked */
+static struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ast_sockaddr addr;
+	unsigned char rtcpdata[8192 + AST_FRIENDLY_OFFSET];
+	unsigned char *read_area = rtcpdata + AST_FRIENDLY_OFFSET;
+	size_t read_area_size = sizeof(rtcpdata) - AST_FRIENDLY_OFFSET;
+	int res;
+
+	/* Read in RTCP data from the socket */
+	if ((res = rtcp_recvfrom(instance, read_area, read_area_size,
+				0, &addr)) < 0) {
+		ast_assert(errno != EBADF);
+		if (errno != EAGAIN) {
+			ast_log(LOG_WARNING, "RTCP Read error: %s.  Hanging up.\n",
+				(errno) ? strerror(errno) : "Unspecified");
+			return NULL;
+		}
+		return &ast_null_frame;
+	}
+
+	/* If this was handled by the ICE session don't do anything further */
+	if (!res) {
+		return &ast_null_frame;
+	}
+
+	if (!*read_area) {
+		struct sockaddr_in addr_tmp;
+		struct ast_sockaddr addr_v4;
+
+		if (ast_sockaddr_is_ipv4(&addr)) {
+			ast_sockaddr_to_sin(&addr, &addr_tmp);
+		} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {
+			ast_debug(1, "Using IPv6 mapped address %s for STUN\n",
+				  ast_sockaddr_stringify(&addr));
+			ast_sockaddr_to_sin(&addr_v4, &addr_tmp);
+		} else {
+			ast_debug(1, "Cannot do STUN for non IPv4 address %s\n",
+				  ast_sockaddr_stringify(&addr));
+			return &ast_null_frame;
+		}
+		if ((ast_stun_handle_packet(rtp->rtcp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT)) {
+			ast_sockaddr_from_sin(&addr, &addr_tmp);
+			ast_sockaddr_copy(&rtp->rtcp->them, &addr);
+		}
+		return &ast_null_frame;
+	}
+
+	return ast_rtcp_interpret(instance, read_area, res, &addr);
 }
 
-static int bridge_p2p_rtp_write(struct ast_rtp_instance *instance, unsigned int *rtpheader, int len, int hdrlen)
+/*! \pre instance is locked */
+static int bridge_p2p_rtp_write(struct ast_rtp_instance *instance,
+	struct ast_rtp_instance *instance1, unsigned int *rtpheader, int len, int hdrlen)
 {
-	struct ast_rtp_instance *instance1 = ast_rtp_instance_get_bridged(instance);
-	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance), *bridged = ast_rtp_instance_get_data(instance1);
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ast_rtp *bridged = ast_rtp_instance_get_data(instance1);
 	int res = 0, payload = 0, bridged_payload = 0, mark;
 	RAII_VAR(struct ast_rtp_payload_type *, payload_type, NULL, ao2_cleanup);
 	int reconstruct = ntohl(rtpheader[0]);
 	struct ast_sockaddr remote_address = { {0,} };
 	int ice;
+	unsigned int timestamp = ntohl(rtpheader[1]);
 
 	/* Get fields from packet */
 	payload = (reconstruct & 0x7f0000) >> 16;
@@ -4307,6 +4815,22 @@ static int bridge_p2p_rtp_write(struct a
 		return -1;
 	}
 
+	/* If bridged peer is in dtmf, feed all packets to core until it finishes to avoid infinite dtmf */
+	if (bridged->sending_digit) {
+		ast_debug(1, "Feeding packets to core until DTMF finishes\n");
+		return -1;
+	}
+
+	/*
+	 * Even if we are no longer in dtmf, we could still be receiving
+	 * re-transmissions of the last dtmf end still.  Feed those to the
+	 * core so they can be filtered accordingly.
+	 */
+	if (rtp->last_end_timestamp == timestamp) {
+		ast_debug(1, "Feeding packet with duplicate timestamp to core\n");
+		return -1;
+	}
+
 	/* If the marker bit has been explicitly set turn it on */
 	if (ast_test_flag(rtp, FLAG_NEED_MARKER_BIT)) {
 		mark = 1;
@@ -4319,10 +4843,27 @@ static int bridge_p2p_rtp_write(struct a
 	reconstruct |= (mark << 23);
 	rtpheader[0] = htonl(reconstruct);
 
+	/*
+	 * We have now determined that we need to send the RTP packet
+	 * out the bridged instance to do local bridging so we must unlock
+	 * the receiving instance to prevent deadlock with the bridged
+	 * instance.
+	 *
+	 * Technically we should grab a ref to instance1 so it won't go
+	 * away on us.  However, we should be safe because the bridged
+	 * instance won't change without both channels involved being
+	 * locked and we currently have the channel lock for the receiving
+	 * instance.
+	 */
+	ao2_unlock(instance);
+	ao2_lock(instance1);
+
 	ast_rtp_instance_get_remote_address(instance1, &remote_address);
 
 	if (ast_sockaddr_isnull(&remote_address)) {
 		ast_debug(5, "Remote address is null, most likely RTP has been stopped\n");
+		ao2_unlock(instance1);
+		ao2_lock(instance);
 		return 0;
 	}
 
@@ -4344,6 +4885,8 @@ static int bridge_p2p_rtp_write(struct a
 			}
 			ast_set_flag(bridged, FLAG_NAT_INACTIVE_NOWARN);
 		}
+		ao2_unlock(instance1);
+		ao2_lock(instance);
 		return 0;
 	}
 
@@ -4354,22 +4897,28 @@ static int bridge_p2p_rtp_write(struct a
 			    bridged_payload, len - hdrlen);
 	}
 
+	ao2_unlock(instance1);
+	ao2_lock(instance);
 	return 0;
 }
 
+/*! \pre instance is locked */
 static struct ast_frame *ast_rtp_read(struct ast_rtp_instance *instance, int rtcp)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ast_rtp_instance *instance1;
 	struct ast_sockaddr addr;
 	int res, hdrlen = 12, version, payloadtype, padding, mark, ext, cc, prev_seqno;
-	unsigned int *rtpheader = (unsigned int*)(rtp->rawdata + AST_FRIENDLY_OFFSET), seqno, ssrc, timestamp;
+	unsigned char *read_area = rtp->rawdata + AST_FRIENDLY_OFFSET;
+	size_t read_area_size = sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET;
+	unsigned int *rtpheader = (unsigned int*)(read_area), seqno, ssrc, timestamp;
 	RAII_VAR(struct ast_rtp_payload_type *, payload, NULL, ao2_cleanup);
 	struct ast_sockaddr remote_address = { {0,} };
 	struct frame_list frames;
 
 	/* If this is actually RTCP let's hop on over and handle it */
 	if (rtcp) {
-		if (rtp->rtcp) {
+		if (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
 			return ast_rtcp_read(instance);
 		}
 		return &ast_null_frame;
@@ -4381,8 +4930,7 @@ static struct ast_frame *ast_rtp_read(st
 	}
 
 	/* Actually read in the data from the socket */
-	if ((res = rtp_recvfrom(instance, rtp->rawdata + AST_FRIENDLY_OFFSET,
-				sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET, 0,
+	if ((res = rtp_recvfrom(instance, read_area, read_area_size, 0,
 				&addr)) < 0) {
 		ast_assert(errno != EBADF);
 		if (errno != EAGAIN) {
@@ -4398,12 +4946,17 @@ static struct ast_frame *ast_rtp_read(st
 		return &ast_null_frame;
 	}
 
+	/* This could be a multiplexed RTCP packet. If so, be sure to interpret it correctly */
+	if (rtcp_mux(rtp, read_area)) {
+		return ast_rtcp_interpret(instance, read_area, res, &addr);
+	}
+
 	/* Make sure the data that was read in is actually enough to make up an RTP packet */
 	if (res < hdrlen) {
 		/* If this is a keepalive containing only nulls, don't bother with a warning */
 		int i;
 		for (i = 0; i < res; ++i) {
-			if (rtp->rawdata[AST_FRIENDLY_OFFSET + i] != '\0') {
+			if (read_area[i] != '\0') {
 				ast_log(LOG_WARNING, "RTP Read too short\n");
 				return &ast_null_frame;
 			}
@@ -4430,7 +4983,7 @@ static struct ast_frame *ast_rtp_read(st
 				  ast_sockaddr_stringify(&addr));
 			return &ast_null_frame;
 		}
-		if ((ast_stun_handle_packet(rtp->s, &addr_tmp, rtp->rawdata + AST_FRIENDLY_OFFSET, res, NULL, NULL) == AST_STUN_ACCEPT) &&
+		if ((ast_stun_handle_packet(rtp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT) &&
 		    ast_sockaddr_isnull(&remote_address)) {
 			ast_sockaddr_from_sin(&addr, &addr_tmp);
 			ast_rtp_instance_set_remote_address(instance, &addr);
@@ -4479,7 +5032,7 @@ static struct ast_frame *ast_rtp_read(st
 			/* do not update the originally given address, but only the remote */
 			ast_rtp_instance_set_incoming_source_address(instance, &addr);
 			ast_sockaddr_copy(&remote_address, &addr);
-			if (rtp->rtcp) {
+			if (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
 				ast_sockaddr_copy(&rtp->rtcp->them, &addr);
 				ast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(&addr) + 1);
 			}
@@ -4492,7 +5045,9 @@ static struct ast_frame *ast_rtp_read(st
 	}
 
 	/* If we are directly bridged to another instance send the audio directly out */
-	if (ast_rtp_instance_get_bridged(instance) && !bridge_p2p_rtp_write(instance, rtpheader, res, hdrlen)) {
+	instance1 = ast_rtp_instance_get_bridged(instance);
+	if (instance1
+		&& !bridge_p2p_rtp_write(instance, instance1, rtpheader, res, hdrlen)) {
 		return &ast_null_frame;
 	}
 
@@ -4546,7 +5101,7 @@ static struct ast_frame *ast_rtp_read(st
 
 	/* Remove any padding bytes that may be present */
 	if (padding) {
-		res -= rtp->rawdata[AST_FRIENDLY_OFFSET + res - 1];
+		res -= read_area[res - 1];
 	}
 
 	/* Skip over any CSRC fields */
@@ -4620,11 +5175,11 @@ static struct ast_frame *ast_rtp_read(st
 			 * by passing the pointer to the frame list to it so that the method
 			 * can append frames to the list as needed.
 			 */
-			process_dtmf_rfc2833(instance, rtp->rawdata + AST_FRIENDLY_OFFSET + hdrlen, res - hdrlen, seqno, timestamp, &addr, payloadtype, mark, &frames);
+			process_dtmf_rfc2833(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, &addr, payloadtype, mark, &frames);
 		} else if (payload->rtp_code == AST_RTP_CISCO_DTMF) {
-			f = process_dtmf_cisco(instance, rtp->rawdata + AST_FRIENDLY_OFFSET + hdrlen, res - hdrlen, seqno, timestamp, &addr, payloadtype, mark);
+			f = process_dtmf_cisco(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, &addr, payloadtype, mark);
 		} else if (payload->rtp_code == AST_RTP_CN) {
-			f = process_cn_rfc3389(instance, rtp->rawdata + AST_FRIENDLY_OFFSET + hdrlen, res - hdrlen, seqno, timestamp, &addr, payloadtype, mark);
+			f = process_cn_rfc3389(instance, read_area + hdrlen, res - hdrlen, seqno, timestamp, &addr, payloadtype, mark);
 		} else {
 			ast_log(LOG_NOTICE, "Unknown RTP codec %d received from '%s'\n",
 				payloadtype,
@@ -4680,7 +5235,7 @@ static struct ast_frame *ast_rtp_read(st
 	rtp->f.src = "RTP";
 	rtp->f.mallocd = 0;
 	rtp->f.datalen = res - hdrlen;
-	rtp->f.data.ptr = rtp->rawdata + hdrlen + AST_FRIENDLY_OFFSET;
+	rtp->f.data.ptr = read_area + hdrlen;
 	rtp->f.offset = hdrlen + AST_FRIENDLY_OFFSET;
 	rtp->f.seqno = seqno;
 
@@ -4757,6 +5312,8 @@ static struct ast_frame *ast_rtp_read(st
 		/* Video -- samples is # of samples vs. 90000 */
 		if (!rtp->lastividtimestamp)
 			rtp->lastividtimestamp = timestamp;
+		ast_set_flag(&rtp->f, AST_FRFLAG_HAS_TIMING_INFO);
+		rtp->f.ts = timestamp / (rtp_get_rate(rtp->f.subclass.format) / 1000);
 		rtp->f.samples = timestamp - rtp->lastividtimestamp;
 		rtp->lastividtimestamp = timestamp;
 		rtp->f.delivery.tv_sec = 0;
@@ -4781,91 +5338,155 @@ static struct ast_frame *ast_rtp_read(st
 	return AST_LIST_FIRST(&frames);
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_prop_set(struct ast_rtp_instance *instance, enum ast_rtp_property property, int value)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 
 	if (property == AST_RTP_PROPERTY_RTCP) {
 		if (value) {
-			if (rtp->rtcp) {
+			struct ast_sockaddr local_addr;
+
+			if (rtp->rtcp && rtp->rtcp->type == value) {
 				ast_debug(1, "Ignoring duplicate RTCP property on RTP instance '%p'\n", instance);
 				return;
 			}
-			/* Setup RTCP to be activated on the next RTP write */
-			if (!(rtp->rtcp = ast_calloc(1, sizeof(*rtp->rtcp)))) {
-				return;
+
+			if (!rtp->rtcp) {
+				rtp->rtcp = ast_calloc(1, sizeof(*rtp->rtcp));
+				if (!rtp->rtcp) {
+					return;
+				}
+				rtp->rtcp->s = -1;
+#ifdef HAVE_OPENSSL_SRTP
+				rtp->rtcp->dtls.timeout_timer = -1;
+#endif
+				rtp->rtcp->schedid = -1;
 			}
 
+			rtp->rtcp->type = value;
+
 			/* Grab the IP address and port we are going to use */
 			ast_rtp_instance_get_local_address(instance, &rtp->rtcp->us);
-			ast_sockaddr_set_port(&rtp->rtcp->us,
-					      ast_sockaddr_port(&rtp->rtcp->us) + 1);
+			if (value == AST_RTP_INSTANCE_RTCP_STANDARD) {
+				ast_sockaddr_set_port(&rtp->rtcp->us,
+					ast_sockaddr_port(&rtp->rtcp->us) + 1);
+			}
 
-			if ((rtp->rtcp->s =
-			     create_new_socket("RTCP",
-					       ast_sockaddr_is_ipv4(&rtp->rtcp->us) ?
-					       AF_INET :
-					       ast_sockaddr_is_ipv6(&rtp->rtcp->us) ?
-					       AF_INET6 : -1)) < 0) {
-				ast_debug(1, "Failed to create a new socket for RTCP on instance '%p'\n", instance);
-				ast_free(rtp->rtcp);
-				rtp->rtcp = NULL;
-				return;
+			ast_sockaddr_copy(&local_addr, &rtp->rtcp->us);
+			if (!ast_find_ourip(&local_addr, &rtp->rtcp->us, 0)) {
+				ast_sockaddr_set_port(&local_addr, ast_sockaddr_port(&rtp->rtcp->us));
+			} else {
+				/* Failed to get local address reset to use default. */
+				ast_sockaddr_copy(&local_addr, &rtp->rtcp->us);
 			}
 
-			/* Try to actually bind to the IP address and port we are going to use for RTCP, if this fails we have to bail out */
-			if (ast_bind(rtp->rtcp->s, &rtp->rtcp->us)) {
-				ast_debug(1, "Failed to setup RTCP on RTP instance '%p'\n", instance);
-				close(rtp->rtcp->s);
+			ast_free(rtp->rtcp->local_addr_str);
+			rtp->rtcp->local_addr_str = ast_strdup(ast_sockaddr_stringify(&local_addr));
+			if (!rtp->rtcp->local_addr_str) {
 				ast_free(rtp->rtcp);
 				rtp->rtcp = NULL;
 				return;
 			}
 
-			ast_debug(1, "Setup RTCP on RTP instance '%p'\n", instance);
-			rtp->rtcp->schedid = -1;
+			if (value == AST_RTP_INSTANCE_RTCP_STANDARD) {
+				/* We're either setting up RTCP from scratch or
+				 * switching from MUX. Either way, we won't have
+				 * a socket set up, and we need to set it up
+				 */
+				if ((rtp->rtcp->s =
+				     create_new_socket("RTCP",
+						       ast_sockaddr_is_ipv4(&rtp->rtcp->us) ?
+						       AF_INET :
+						       ast_sockaddr_is_ipv6(&rtp->rtcp->us) ?
+						       AF_INET6 : -1)) < 0) {
+					ast_debug(1, "Failed to create a new socket for RTCP on instance '%p'\n", instance);
+					ast_free(rtp->rtcp->local_addr_str);
+					ast_free(rtp->rtcp);
+					rtp->rtcp = NULL;
+					return;
+				}
 
+				/* Try to actually bind to the IP address and port we are going to use for RTCP, if this fails we have to bail out */
+				if (ast_bind(rtp->rtcp->s, &rtp->rtcp->us)) {
+					ast_debug(1, "Failed to setup RTCP on RTP instance '%p'\n", instance);
+					close(rtp->rtcp->s);
+					ast_free(rtp->rtcp->local_addr_str);
+					ast_free(rtp->rtcp);
+					rtp->rtcp = NULL;
+					return;
+				}
 #ifdef HAVE_PJPROJECT
-			if (rtp->ice) {
-				rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP);
-			}
+				if (rtp->ice) {
+					rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP);
+				}
 #endif
-
 #ifdef HAVE_OPENSSL_SRTP
-			rtp->rtcp->dtls.timeout_timer = -1;
-			dtls_setup_rtcp(instance);
+				dtls_setup_rtcp(instance);
 #endif
+			} else {
+				struct ast_sockaddr addr;
+				/* RTCPMUX uses the same socket as RTP. If we were previously using standard RTCP
+				 * then close the socket we previously created.
+				 *
+				 * It may seem as though there is a possible race condition here where we might try
+				 * to close the RTCP socket while it is being used to send data. However, this is not
+				 * a problem in practice since setting and adjusting of RTCP properties happens prior
+				 * to activating RTP. It is not until RTP is activated that timers start for RTCP
+				 * transmission
+				 */
+				if (rtp->rtcp->s > -1 && rtp->rtcp->s != rtp->s) {
+					close(rtp->rtcp->s);
+				}
+				rtp->rtcp->s = rtp->s;
+				ast_rtp_instance_get_remote_address(instance, &addr);
+				ast_sockaddr_copy(&rtp->rtcp->them, &addr);
+#ifdef HAVE_OPENSSL_SRTP
+				if (rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {
+					SSL_free(rtp->rtcp->dtls.ssl);
+				}
+				rtp->rtcp->dtls.ssl = rtp->dtls.ssl;
+#endif
+			}
 
-			return;
+			ast_debug(1, "Setup RTCP on RTP instance '%p'\n", instance);
 		} else {
 			if (rtp->rtcp) {
 				if (rtp->rtcp->schedid > -1) {
+					ao2_unlock(instance);
 					if (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {
 						/* Successfully cancelled scheduler entry. */
 						ao2_ref(instance, -1);
 					} else {
 						/* Unable to cancel scheduler entry */
 						ast_debug(1, "Failed to tear down RTCP on RTP instance '%p'\n", instance);
+						ao2_lock(instance);
 						return;
 					}
+					ao2_lock(instance);
 					rtp->rtcp->schedid = -1;
 				}
-				close(rtp->rtcp->s);
+				if (rtp->rtcp->s > -1 && rtp->rtcp->s != rtp->s) {
+					close(rtp->rtcp->s);
+				}
 #ifdef HAVE_OPENSSL_SRTP
-				if (rtp->rtcp->dtls.ssl) {
+				ao2_unlock(instance);
+				dtls_srtp_stop_timeout_timer(instance, rtp, 1);
+				ao2_lock(instance);
+
+				if (rtp->rtcp->dtls.ssl && rtp->rtcp->dtls.ssl != rtp->dtls.ssl) {
 					SSL_free(rtp->rtcp->dtls.ssl);
 				}
 #endif
+				ast_free(rtp->rtcp->local_addr_str);
 				ast_free(rtp->rtcp);
 				rtp->rtcp = NULL;
 			}
-			return;
 		}
 	}
-
-	return;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_fd(struct ast_rtp_instance *instance, int rtcp)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -4873,17 +5494,37 @@ static int ast_rtp_fd(struct ast_rtp_ins
 	return rtcp ? (rtp->rtcp ? rtp->rtcp->s : -1) : rtp->s;
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_remote_address_set(struct ast_rtp_instance *instance, struct ast_sockaddr *addr)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	struct ast_sockaddr local;
 
-	if (rtp->rtcp) {
+	ast_rtp_instance_get_local_address(instance, &local);
+	if (!ast_sockaddr_isnull(addr)) {
+		/* Update the local RTP address with what is being used */
+		if (ast_ouraddrfor(addr, &local)) {
+			/* Failed to update our address so reuse old local address */
+			ast_rtp_instance_get_local_address(instance, &local);
+		} else {
+			ast_rtp_instance_set_local_address(instance, &local);
+		}
+	}
+
+	if (rtp->rtcp && !ast_sockaddr_isnull(addr)) {
 		ast_debug(1, "Setting RTCP address on RTP instance '%p'\n", instance);
 		ast_sockaddr_copy(&rtp->rtcp->them, addr);
-		if (!ast_sockaddr_isnull(addr)) {
-			ast_sockaddr_set_port(&rtp->rtcp->them,
-					      ast_sockaddr_port(addr) + 1);
+
+		if (rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
+			ast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(addr) + 1);
+
+			/* Update the local RTCP address with what is being used */
+			ast_sockaddr_set_port(&local, ast_sockaddr_port(&local) + 1);
 		}
+		ast_sockaddr_copy(&rtp->rtcp->us, &local);
+
+		ast_free(rtp->rtcp->local_addr_str);
+		rtp->rtcp->local_addr_str = ast_strdup(ast_sockaddr_stringify(&local));
 	}
 
 	rtp->rxseqno = 0;
@@ -4892,44 +5533,48 @@ static void ast_rtp_remote_address_set(s
 		rtp->strict_rtp_state = STRICT_RTP_LEARN;
 		rtp_learning_seq_init(&rtp->rtp_source_learn, rtp->seqno);
 	}
-
-	return;
 }
 
-/*! \brief Write t140 redundacy frame
+/*!
+ * \brief Write t140 redundacy frame
+ *
  * \param data primary data to be buffered
+ *
+ * Scheduler callback
  */
 static int red_write(const void *data)
 {
 	struct ast_rtp_instance *instance = (struct ast_rtp_instance*) data;
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 
+	ao2_lock(instance);
 	ast_rtp_write(instance, &rtp->red->t140);
+	ao2_unlock(instance);
 
 	return 1;
 }
 
+/*! \pre instance is locked */
 static int rtp_red_init(struct ast_rtp_instance *instance, int buffer_time, int *payloads, int generations)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	int x;
 
-	if (!(rtp->red = ast_calloc(1, sizeof(*rtp->red)))) {
+	rtp->red = ast_calloc(1, sizeof(*rtp->red));
+	if (!rtp->red) {
 		return -1;
 	}
 
 	rtp->red->t140.frametype = AST_FRAME_TEXT;
-	ao2_replace(rtp->red->t140.subclass.format, ast_format_t140_red);
+	rtp->red->t140.subclass.format = ast_format_t140_red;
 	rtp->red->t140.data.ptr = &rtp->red->buf_data;
 
-	rtp->red->t140.ts = 0;
 	rtp->red->t140red = rtp->red->t140;
 	rtp->red->t140red.data.ptr = &rtp->red->t140red_data;
-	rtp->red->t140red.datalen = 0;
+
 	rtp->red->ti = buffer_time;
 	rtp->red->num_gen = generations;
 	rtp->red->hdrlen = generations * 4 + 1;
-	rtp->red->prev_ts = 0;
 
 	for (x = 0; x < generations; x++) {
 		rtp->red->pt[x] = payloads[x];
@@ -4939,11 +5584,10 @@ static int rtp_red_init(struct ast_rtp_i
 	rtp->red->t140red_data[x*4] = rtp->red->pt[x] = payloads[x]; /* primary pt */
 	rtp->red->schedid = ast_sched_add(rtp->sched, generations, red_write, instance);
 
-	rtp->red->t140.datalen = 0;
-
 	return 0;
 }
 
+/*! \pre instance is locked */
 static int rtp_red_buffer(struct ast_rtp_instance *instance, struct ast_frame *frame)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -4958,15 +5602,19 @@ static int rtp_red_buffer(struct ast_rtp
 	return 0;
 }
 
+/*! \pre Neither instance0 nor instance1 are locked */
 static int ast_rtp_local_bridge(struct ast_rtp_instance *instance0, struct ast_rtp_instance *instance1)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance0);
 
+	ao2_lock(instance0);
 	ast_set_flag(rtp, FLAG_NEED_MARKER_BIT);
+	ao2_unlock(instance0);
 
 	return 0;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_get_stat(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -5018,6 +5666,7 @@ static int ast_rtp_get_stat(struct ast_r
 	return 0;
 }
 
+/*! \pre Neither instance0 nor instance1 are locked */
 static int ast_rtp_dtmf_compatible(struct ast_channel *chan0, struct ast_rtp_instance *instance0, struct ast_channel *chan1, struct ast_rtp_instance *instance1)
 {
 	/* If both sides are not using the same method of DTMF transmission
@@ -5034,52 +5683,62 @@ static int ast_rtp_dtmf_compatible(struc
 		 (!ast_channel_tech(chan0)->send_digit_begin != !ast_channel_tech(chan1)->send_digit_begin)) ? 0 : 1);
 }
 
+/*! \pre instance is NOT locked */
 static void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	struct sockaddr_in suggestion_tmp;
 
+	/*
+	 * The instance should not be locked because we can block
+	 * waiting for a STUN respone.
+	 */
 	ast_sockaddr_to_sin(suggestion, &suggestion_tmp);
 	ast_stun_request(rtp->s, &suggestion_tmp, username, NULL);
 	ast_sockaddr_from_sin(suggestion, &suggestion_tmp);
 }
 
+/*! \pre instance is locked */
 static void ast_rtp_stop(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	struct ast_sockaddr addr = { {0,} };
 
 #ifdef HAVE_OPENSSL_SRTP
+	ao2_unlock(instance);
 	AST_SCHED_DEL_UNREF(rtp->sched, rtp->rekeyid, ao2_ref(instance, -1));
 
 	dtls_srtp_stop_timeout_timer(instance, rtp, 0);
 	if (rtp->rtcp) {
 		dtls_srtp_stop_timeout_timer(instance, rtp, 1);
 	}
+	ao2_lock(instance);
 #endif
 
 	if (rtp->rtcp && rtp->rtcp->schedid > -1) {
+		ao2_unlock(instance);
 		if (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {
 			/* successfully cancelled scheduler entry. */
 			ao2_ref(instance, -1);
 		}
+		ao2_lock(instance);
 		rtp->rtcp->schedid = -1;
 	}
 
 	if (rtp->red) {
+		ao2_unlock(instance);
 		AST_SCHED_DEL(rtp->sched, rtp->red->schedid);
-		free(rtp->red);
+		ao2_lock(instance);
+		ast_free(rtp->red);
 		rtp->red = NULL;
 	}
 
 	ast_rtp_instance_set_remote_address(instance, &addr);
-	if (rtp->rtcp) {
-		ast_sockaddr_setnull(&rtp->rtcp->them);
-	}
 
 	ast_set_flag(rtp, FLAG_NEED_MARKER_BIT);
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char *desc)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -5087,7 +5746,11 @@ static int ast_rtp_qos_set(struct ast_rt
 	return ast_set_qos(rtp->s, tos, cos, desc);
 }
 
-/*! \brief generate comfort noice (CNG) */
+/*!
+ * \brief generate comfort noice (CNG)
+ *
+ * \pre instance is locked
+ */
 static int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level)
 {
 	unsigned int *rtpheader;
@@ -5152,6 +5815,7 @@ static void dtls_perform_setup(struct dt
 	dtls->connection = AST_RTP_DTLS_CONNECTION_NEW;
 }
 
+/*! \pre instance is locked */
 static int ast_rtp_activate(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -5171,7 +5835,7 @@ static int ast_rtp_activate(struct ast_r
 
 	dtls_perform_handshake(instance, &rtp->dtls, 0);
 
-	if (rtp->rtcp) {
+	if (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
 		dtls_perform_handshake(instance, &rtp->rtcp->dtls, 1);
 	}
 
@@ -5312,6 +5976,66 @@ static struct ast_cli_entry cli_rtp[] =
 	AST_CLI_DEFINE(handle_cli_rtcp_set_stats, "Enable/Disable RTCP stats"),
 };
 
+#ifdef HAVE_PJPROJECT
+/*!
+ * \internal
+ * \brief Clear the configured blacklist.
+ * \since 13.16.0
+ *
+ * \param lock R/W lock protecting the blacklist
+ * \param blacklist List to clear
+ *
+ * \return Nothing
+ */
+static void blacklist_clear(ast_rwlock_t *lock, struct ast_ha **blacklist)
+{
+	ast_rwlock_wrlock(lock);
+	ast_free_ha(*blacklist);
+	*blacklist = NULL;
+	ast_rwlock_unlock(lock);
+}
+
+/*!
+ * \internal
+ * \brief Load the blacklist configuration.
+ * \since 13.16.0
+ *
+ * \param cfg Raw config file options.
+ * \param option_name Blacklist option name
+ * \param lock R/W lock protecting the blacklist
+ * \param blacklist List to load
+ *
+ * \return Nothing
+ */
+static void blacklist_config_load(struct ast_config *cfg, const char *option_name,
+	ast_rwlock_t *lock, struct ast_ha **blacklist)
+{
+	struct ast_variable *var;
+
+	ast_rwlock_wrlock(lock);
+	for (var = ast_variable_browse(cfg, "general"); var; var = var->next) {
+		if (!strcasecmp(var->name, option_name)) {
+			struct ast_ha *na;
+			int ha_error = 0;
+
+			na = ast_append_ha("d", var->value, *blacklist, &ha_error);
+			if (!na) {
+				ast_log(LOG_WARNING, "Invalid %s value: %s\n",
+					option_name, var->value);
+			} else {
+				*blacklist = na;
+			}
+			if (ha_error) {
+				ast_log(LOG_ERROR,
+					"Bad %s configuration value line %d: %s\n",
+					option_name, var->lineno, var->value);
+			}
+		}
+	}
+	ast_rwlock_unlock(lock);
+}
+#endif
+
 static int rtp_reload(int reload)
 {
 	struct ast_config *cfg;
@@ -5324,7 +6048,7 @@ static int rtp_reload(int reload)
 #endif
 
 	cfg = ast_config_load2("rtp.conf", "rtp", config_flags);
-	if (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {
+	if (!cfg || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {
 		return 0;
 	}
 
@@ -5350,118 +6074,126 @@ static int rtp_reload(int reload)
 	turnusername = pj_str(NULL);
 	turnpassword = pj_str(NULL);
 	host_candidate_overrides_clear();
+	blacklist_clear(&ice_blacklist_lock, &ice_blacklist);
+	blacklist_clear(&stun_blacklist_lock, &stun_blacklist);
 #endif
 
-	if (cfg) {
-		if ((s = ast_variable_retrieve(cfg, "general", "rtpstart"))) {
-			rtpstart = atoi(s);
-			if (rtpstart < MINIMUM_RTP_PORT)
-				rtpstart = MINIMUM_RTP_PORT;
-			if (rtpstart > MAXIMUM_RTP_PORT)
-				rtpstart = MAXIMUM_RTP_PORT;
-		}
-		if ((s = ast_variable_retrieve(cfg, "general", "rtpend"))) {
-			rtpend = atoi(s);
-			if (rtpend < MINIMUM_RTP_PORT)
-				rtpend = MINIMUM_RTP_PORT;
-			if (rtpend > MAXIMUM_RTP_PORT)
-				rtpend = MAXIMUM_RTP_PORT;
-		}
-		if ((s = ast_variable_retrieve(cfg, "general", "rtcpinterval"))) {
-			rtcpinterval = atoi(s);
-			if (rtcpinterval == 0)
-				rtcpinterval = 0; /* Just so we're clear... it's zero */
-			if (rtcpinterval < RTCP_MIN_INTERVALMS)
-				rtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */
-			if (rtcpinterval > RTCP_MAX_INTERVALMS)
-				rtcpinterval = RTCP_MAX_INTERVALMS;
-		}
-		if ((s = ast_variable_retrieve(cfg, "general", "rtpchecksums"))) {
+	if ((s = ast_variable_retrieve(cfg, "general", "rtpstart"))) {
+		rtpstart = atoi(s);
+		if (rtpstart < MINIMUM_RTP_PORT)
+			rtpstart = MINIMUM_RTP_PORT;
+		if (rtpstart > MAXIMUM_RTP_PORT)
+			rtpstart = MAXIMUM_RTP_PORT;
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "rtpend"))) {
+		rtpend = atoi(s);
+		if (rtpend < MINIMUM_RTP_PORT)
+			rtpend = MINIMUM_RTP_PORT;
+		if (rtpend > MAXIMUM_RTP_PORT)
+			rtpend = MAXIMUM_RTP_PORT;
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "rtcpinterval"))) {
+		rtcpinterval = atoi(s);
+		if (rtcpinterval == 0)
+			rtcpinterval = 0; /* Just so we're clear... it's zero */
+		if (rtcpinterval < RTCP_MIN_INTERVALMS)
+			rtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */
+		if (rtcpinterval > RTCP_MAX_INTERVALMS)
+			rtcpinterval = RTCP_MAX_INTERVALMS;
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "rtpchecksums"))) {
 #ifdef SO_NO_CHECK
-			nochecksums = ast_false(s) ? 1 : 0;
+		nochecksums = ast_false(s) ? 1 : 0;
 #else
-			if (ast_false(s))
-				ast_log(LOG_WARNING, "Disabling RTP checksums is not supported on this operating system!\n");
+		if (ast_false(s))
+			ast_log(LOG_WARNING, "Disabling RTP checksums is not supported on this operating system!\n");
 #endif
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "dtmftimeout"))) {
+		dtmftimeout = atoi(s);
+		if ((dtmftimeout < 0) || (dtmftimeout > 64000)) {
+			ast_log(LOG_WARNING, "DTMF timeout of '%d' outside range, using default of '%d' instead\n",
+				dtmftimeout, DEFAULT_DTMF_TIMEOUT);
+			dtmftimeout = DEFAULT_DTMF_TIMEOUT;
+		};
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "strictrtp"))) {
+		strictrtp = ast_true(s);
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "probation"))) {
+		if ((sscanf(s, "%d", &learning_min_sequential) <= 0) || learning_min_sequential <= 0) {
+			ast_log(LOG_WARNING, "Value for 'probation' could not be read, using default of '%d' instead\n",
+				DEFAULT_LEARNING_MIN_SEQUENTIAL);
 		}
-		if ((s = ast_variable_retrieve(cfg, "general", "dtmftimeout"))) {
-			dtmftimeout = atoi(s);
-			if ((dtmftimeout < 0) || (dtmftimeout > 64000)) {
-				ast_log(LOG_WARNING, "DTMF timeout of '%d' outside range, using default of '%d' instead\n",
-					dtmftimeout, DEFAULT_DTMF_TIMEOUT);
-				dtmftimeout = DEFAULT_DTMF_TIMEOUT;
-			};
-		}
-		if ((s = ast_variable_retrieve(cfg, "general", "strictrtp"))) {
-			strictrtp = ast_true(s);
-		}
-		if ((s = ast_variable_retrieve(cfg, "general", "probation"))) {
-			if ((sscanf(s, "%d", &learning_min_sequential) <= 0) || learning_min_sequential <= 0) {
-				ast_log(LOG_WARNING, "Value for 'probation' could not be read, using default of '%d' instead\n",
-					DEFAULT_LEARNING_MIN_SEQUENTIAL);
-			}
-		}
+	}
 #ifdef HAVE_PJPROJECT
-		if ((s = ast_variable_retrieve(cfg, "general", "icesupport"))) {
-			icesupport = ast_true(s);
-		}
-		if ((s = ast_variable_retrieve(cfg, "general", "stunaddr"))) {
-			stunaddr.sin_port = htons(STANDARD_STUN_PORT);
-			if (ast_parse_arg(s, PARSE_INADDR, &stunaddr)) {
-				ast_log(LOG_WARNING, "Invalid STUN server address: %s\n", s);
-			}
+	if ((s = ast_variable_retrieve(cfg, "general", "icesupport"))) {
+		icesupport = ast_true(s);
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "stunaddr"))) {
+		stunaddr.sin_port = htons(STANDARD_STUN_PORT);
+		if (ast_parse_arg(s, PARSE_INADDR, &stunaddr)) {
+			ast_log(LOG_WARNING, "Invalid STUN server address: %s\n", s);
 		}
-		if ((s = ast_variable_retrieve(cfg, "general", "turnaddr"))) {
-			struct sockaddr_in addr;
-			addr.sin_port = htons(DEFAULT_TURN_PORT);
-			if (ast_parse_arg(s, PARSE_INADDR, &addr)) {
-				ast_log(LOG_WARNING, "Invalid TURN server address: %s\n", s);
-			} else {
-				pj_strdup2_with_null(pool, &turnaddr, ast_inet_ntoa(addr.sin_addr));
-				/* ntohs() is not a bug here. The port number is used in host byte order with
-				 * a pjnat API. */
-				turnport = ntohs(addr.sin_port);
-			}
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "turnaddr"))) {
+		struct sockaddr_in addr;
+		addr.sin_port = htons(DEFAULT_TURN_PORT);
+		if (ast_parse_arg(s, PARSE_INADDR, &addr)) {
+			ast_log(LOG_WARNING, "Invalid TURN server address: %s\n", s);
+		} else {
+			pj_strdup2_with_null(pool, &turnaddr, ast_inet_ntoa(addr.sin_addr));
+			/* ntohs() is not a bug here. The port number is used in host byte order with
+			 * a pjnat API. */
+			turnport = ntohs(addr.sin_port);
 		}
-		if ((s = ast_variable_retrieve(cfg, "general", "turnusername"))) {
-			pj_strdup2_with_null(pool, &turnusername, s);
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "turnusername"))) {
+		pj_strdup2_with_null(pool, &turnusername, s);
+	}
+	if ((s = ast_variable_retrieve(cfg, "general", "turnpassword"))) {
+		pj_strdup2_with_null(pool, &turnpassword, s);
+	}
+
+	AST_RWLIST_WRLOCK(&host_candidates);
+	for (var = ast_variable_browse(cfg, "ice_host_candidates"); var; var = var->next) {
+		struct ast_sockaddr local_addr, advertised_addr;
+		pj_str_t address;
+
+		ast_sockaddr_setnull(&local_addr);
+		ast_sockaddr_setnull(&advertised_addr);
+
+		if (ast_parse_arg(var->name, PARSE_ADDR | PARSE_PORT_IGNORE, &local_addr)) {
+			ast_log(LOG_WARNING, "Invalid local ICE host address: %s\n", var->name);
+			continue;
 		}
-		if ((s = ast_variable_retrieve(cfg, "general", "turnpassword"))) {
-			pj_strdup2_with_null(pool, &turnpassword, s);
+
+		if (ast_parse_arg(var->value, PARSE_ADDR | PARSE_PORT_IGNORE, &advertised_addr)) {
+			ast_log(LOG_WARNING, "Invalid advertised ICE host address: %s\n", var->value);
+			continue;
 		}
 
-		AST_RWLIST_WRLOCK(&host_candidates);
-		for (var = ast_variable_browse(cfg, "ice_host_candidates"); var; var = var->next) {
-			struct ast_sockaddr local_addr, advertised_addr;
-			pj_str_t address;
+		if (!(candidate = ast_calloc(1, sizeof(*candidate)))) {
+			ast_log(LOG_ERROR, "Failed to allocate ICE host candidate mapping.\n");
+			break;
+		}
 
-			ast_sockaddr_setnull(&local_addr);
-			ast_sockaddr_setnull(&advertised_addr);
+		pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&local_addr)), &candidate->local);
+		pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&advertised_addr)), &candidate->advertised);
 
-			if (ast_parse_arg(var->name, PARSE_ADDR | PARSE_PORT_IGNORE, &local_addr)) {
-				ast_log(LOG_WARNING, "Invalid local ICE host address: %s\n", var->name);
-				continue;
-			}
+		AST_RWLIST_INSERT_TAIL(&host_candidates, candidate, next);
+	}
+	AST_RWLIST_UNLOCK(&host_candidates);
 
-			if (ast_parse_arg(var->value, PARSE_ADDR | PARSE_PORT_IGNORE, &advertised_addr)) {
-				ast_log(LOG_WARNING, "Invalid advertised ICE host address: %s\n", var->value);
-				continue;
-			}
+	/* Read ICE blacklist configuration lines */
+	blacklist_config_load(cfg, "ice_blacklist", &ice_blacklist_lock, &ice_blacklist);
 
-			if (!(candidate = ast_calloc(1, sizeof(*candidate)))) {
-				ast_log(LOG_ERROR, "Failed to allocate ICE host candidate mapping.\n");
-				break;
-			}
+	/* Read STUN blacklist configuration lines */
+	blacklist_config_load(cfg, "stun_blacklist", &stun_blacklist_lock, &stun_blacklist);
+#endif
 
-			pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&local_addr)), &candidate->local);
-			pj_sockaddr_parse(pj_AF_UNSPEC(), 0, pj_cstr(&address, ast_sockaddr_stringify(&advertised_addr)), &candidate->advertised);
+	ast_config_destroy(cfg);
 
-			AST_RWLIST_INSERT_TAIL(&host_candidates, candidate, next);
-		}
-		AST_RWLIST_UNLOCK(&host_candidates);
-#endif
-		ast_config_destroy(cfg);
-	}
 	if (rtpstart >= rtpend) {
 		ast_log(LOG_WARNING, "Unreasonable values for RTP start/end port in rtp.conf\n");
 		rtpstart = DEFAULT_RTP_START;
@@ -5498,6 +6230,7 @@ static int load_module(void)
 #ifdef HAVE_PJPROJECT
 	pj_lock_t *lock;
 
+	AST_PJPROJECT_INIT_LOG_LEVEL();
 	if (pj_init() != PJ_SUCCESS) {
 		return AST_MODULE_LOAD_DECLINE;
 	}
diff -urpN asterisk-13.9.1/res/res_rtp_multicast.c asterisk-13.17.0/res/res_rtp_multicast.c
--- asterisk-13.9.1/res/res_rtp_multicast.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_rtp_multicast.c	2017-07-12 13:12:08.000000000 +0200
@@ -54,6 +54,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/module.h"
 #include "asterisk/rtp_engine.h"
 #include "asterisk/format_cache.h"
+#include "asterisk/multicast_rtp.h"
+#include "asterisk/app.h"
+#include "asterisk/smoother.h"
 
 /*! Command value used for Linksys paging to indicate we are starting */
 #define LINKSYS_MCAST_STARTCMD 6
@@ -63,8 +66,10 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 /*! \brief Type of paging to do */
 enum multicast_type {
+	/*! Type has not been set yet */
+	MULTICAST_TYPE_UNSPECIFIED = 0,
 	/*! Simple multicast enabled client/receiver paging like Snom and Barix uses */
-	MULTICAST_TYPE_BASIC = 0,
+	MULTICAST_TYPE_BASIC,
 	/*! More advanced Linksys type paging which requires a start and stop packet */
 	MULTICAST_TYPE_LINKSYS,
 };
@@ -93,8 +98,97 @@ struct multicast_rtp {
 	uint16_t seqno;
 	unsigned int lastts;	
 	struct timeval txcore;
+	struct ast_smoother *smoother;
 };
 
+#define MAX_TIMESTAMP_SKEW 640
+
+enum {
+	OPT_CODEC = (1 << 0),
+	OPT_LOOP =  (1 << 1),
+	OPT_TTL =   (1 << 2),
+	OPT_IF =    (1 << 3),
+};
+
+enum {
+	OPT_ARG_CODEC = 0,
+	OPT_ARG_LOOP,
+	OPT_ARG_TTL,
+	OPT_ARG_IF,
+	OPT_ARG_ARRAY_SIZE,
+};
+
+AST_APP_OPTIONS(multicast_rtp_options, BEGIN_OPTIONS
+	/*! Set the codec to be used for multicast RTP */
+	AST_APP_OPTION_ARG('c', OPT_CODEC, OPT_ARG_CODEC),
+	/*! Set whether multicast RTP is looped back to the sender */
+	AST_APP_OPTION_ARG('l', OPT_LOOP, OPT_ARG_LOOP),
+	/*! Set the hop count for multicast RTP */
+	AST_APP_OPTION_ARG('t', OPT_TTL, OPT_ARG_TTL),
+	/*! Set the interface from which multicast RTP is sent */
+	AST_APP_OPTION_ARG('i', OPT_IF, OPT_ARG_IF),
+END_OPTIONS );
+
+struct ast_multicast_rtp_options {
+	char *type;
+	char *options;
+	struct ast_format *fmt;
+	struct ast_flags opts;
+	char *opt_args[OPT_ARG_ARRAY_SIZE];
+	/*! The type and options are stored in this buffer */
+	char buf[0];
+};
+
+struct ast_multicast_rtp_options *ast_multicast_rtp_create_options(const char *type,
+	const char *options)
+{
+	struct ast_multicast_rtp_options *mcast_options;
+	char *pos;
+
+	mcast_options = ast_calloc(1, sizeof(*mcast_options)
+			+ strlen(type)
+			+ strlen(S_OR(options, "")) + 2);
+	if (!mcast_options) {
+		return NULL;
+	}
+
+	pos = mcast_options->buf;
+
+	/* Safe */
+	strcpy(pos, type);
+	mcast_options->type = pos;
+	pos += strlen(type) + 1;
+
+	if (!ast_strlen_zero(options)) {
+		strcpy(pos, options); /* Safe */
+	}
+	mcast_options->options = pos;
+
+	if (ast_app_parse_options(multicast_rtp_options, &mcast_options->opts,
+		mcast_options->opt_args, mcast_options->options)) {
+		ast_log(LOG_WARNING, "Error parsing multicast RTP options\n");
+		ast_multicast_rtp_free_options(mcast_options);
+		return NULL;
+	}
+
+	return mcast_options;
+}
+
+void ast_multicast_rtp_free_options(struct ast_multicast_rtp_options *mcast_options)
+{
+	ast_free(mcast_options);
+}
+
+struct ast_format *ast_multicast_rtp_options_get_format(struct ast_multicast_rtp_options *mcast_options)
+{
+	if (ast_test_flag(&mcast_options->opts, OPT_CODEC)
+		&& !ast_strlen_zero(mcast_options->opt_args[OPT_ARG_CODEC])) {
+		return ast_format_cache_get(mcast_options->opt_args[OPT_ARG_CODEC]);
+	}
+
+	return NULL;
+}
+
 /* Forward Declarations */
 static int multicast_rtp_new(struct ast_rtp_instance *instance, struct ast_sched_context *sched, struct ast_sockaddr *addr, void *data);
 static int multicast_rtp_activate(struct ast_rtp_instance *instance);
@@ -112,21 +206,93 @@ static struct ast_rtp_engine multicast_r
 	.read = multicast_rtp_read,
 };
 
+static int set_type(struct multicast_rtp *multicast, const char *type)
+{
+	if (!strcasecmp(type, "basic")) {
+		multicast->type = MULTICAST_TYPE_BASIC;
+	} else if (!strcasecmp(type, "linksys")) {
+		multicast->type = MULTICAST_TYPE_LINKSYS;
+	} else {
+		ast_log(LOG_WARNING, "Unrecognized multicast type '%s' specified.\n", type);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void set_ttl(int sock, const char *ttl_str)
+{
+	int ttl;
+
+	if (ast_strlen_zero(ttl_str)) {
+		return;
+	}
+
+	ast_debug(3, "Setting multicast TTL to %s\n", ttl_str);
+
+	if (sscanf(ttl_str, "%30d", &ttl) < 1) {
+		ast_log(LOG_WARNING, "Invalid multicast ttl option '%s'\n", ttl_str);
+		return;
+	}
+
+	if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl)) < 0) {
+		ast_log(LOG_WARNING, "Could not set multicast ttl to '%s': %s\n",
+			ttl_str, strerror(errno));
+	}
+}
+
+static void set_loop(int sock, const char *loop_str)
+{
+	unsigned char loop;
+
+	if (ast_strlen_zero(loop_str)) {
+		return;
+	}
+
+	ast_debug(3, "Setting multicast loop to %s\n", loop_str);
+
+	if (sscanf(loop_str, "%30hhu", &loop) < 1) {
+		ast_log(LOG_WARNING, "Invalid multicast loop option '%s'\n", loop_str);
+		return;
+	}
+
+	if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, sizeof(loop)) < 0) {
+		ast_log(LOG_WARNING, "Could not set multicast loop to '%s': %s\n",
+			loop_str, strerror(errno));
+	}
+}
+
+static void set_if(int sock, const char *if_str)
+{
+	struct in_addr iface;
+
+	if (ast_strlen_zero(if_str)) {
+		return;
+	}
+
+	ast_debug(3, "Setting multicast if to %s\n", if_str);
+
+	if (!inet_aton(if_str, &iface)) {
+		ast_log(LOG_WARNING, "Cannot parse if option '%s'\n", if_str);
+	}
+
+	if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, &iface, sizeof(iface)) < 0) {
+		ast_log(LOG_WARNING, "Could not set multicast if to '%s': %s\n",
+			if_str, strerror(errno));
+	}
+}
+
 /*! \brief Function called to create a new multicast instance */
 static int multicast_rtp_new(struct ast_rtp_instance *instance, struct ast_sched_context *sched, struct ast_sockaddr *addr, void *data)
 {
 	struct multicast_rtp *multicast;
-	const char *type = data;
+	struct ast_multicast_rtp_options *mcast_options = data;
 
 	if (!(multicast = ast_calloc(1, sizeof(*multicast)))) {
 		return -1;
 	}
 
-	if (!strcasecmp(type, "basic")) {
-		multicast->type = MULTICAST_TYPE_BASIC;
-	} else if (!strcasecmp(type, "linksys")) {
-		multicast->type = MULTICAST_TYPE_LINKSYS;
-	} else {
+	if (set_type(multicast, mcast_options->type)) {
 		ast_free(multicast);
 		return -1;
 	}
@@ -136,6 +302,18 @@ static int multicast_rtp_new(struct ast_
 		return -1;
 	}
 
+	if (ast_test_flag(&mcast_options->opts, OPT_LOOP)) {
+		set_loop(multicast->socket, mcast_options->opt_args[OPT_ARG_LOOP]);
+	}
+
+	if (ast_test_flag(&mcast_options->opts, OPT_TTL)) {
+		set_ttl(multicast->socket, mcast_options->opt_args[OPT_ARG_TTL]);
+	}
+
+	if (ast_test_flag(&mcast_options->opts, OPT_IF)) {
+		set_if(multicast->socket, mcast_options->opt_args[OPT_ARG_IF]);
+	}
+
 	multicast->ssrc = ast_random();
 
 	ast_rtp_instance_set_data(instance, multicast);
@@ -223,6 +401,10 @@ static int multicast_rtp_destroy(struct
 		multicast_send_control_packet(instance, multicast, LINKSYS_MCAST_STOPCMD);
 	}
 
+	if (multicast->smoother) {
+		ast_smoother_free(multicast->smoother);
+	}
+
 	close(multicast->socket);
 
 	ast_free(multicast);
@@ -230,45 +412,43 @@ static int multicast_rtp_destroy(struct
 	return 0;
 }
 
-/*! \brief Function called to broadcast some audio on a multicast instance */
-static int multicast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame)
+static int rtp_raw_write(struct ast_rtp_instance *instance, struct ast_frame *frame, int codec)
 {
 	struct multicast_rtp *multicast = ast_rtp_instance_get_data(instance);
-	struct ast_frame *f = frame;
-	struct ast_sockaddr remote_address;
-	int hdrlen = 12, res = 0, codec;
-	unsigned char *rtpheader;
 	unsigned int ms = calc_txstamp(multicast, &frame->delivery);
+	unsigned char *rtpheader;
+	struct ast_sockaddr remote_address = { {0,} };
 	int rate = rtp_get_rate(frame->subclass.format) / 1000;
+	int hdrlen = 12, mark = 0;
 
-	/* We only accept audio, nothing else */
-	if (frame->frametype != AST_FRAME_VOICE) {
-		return 0;
+	if (ast_format_cmp(frame->subclass.format, ast_format_g722) == AST_FORMAT_CMP_EQUAL) {
+		frame->samples /= 2;
 	}
 
-	/* Grab the actual payload number for when we create the RTP packet */
-	if ((codec = ast_rtp_codecs_payload_code(ast_rtp_instance_get_codecs(instance), 1, frame->subclass.format, 0)) < 0) {
-		return -1;
+	if (ast_test_flag(frame, AST_FRFLAG_HAS_TIMING_INFO)) {
+		multicast->lastts = frame->ts * rate;
+	} else {
+		/* Try to predict what our timestamp should be */
+		int pred = multicast->lastts + frame->samples;
+
+		/* Calculate last TS */
+		multicast->lastts = multicast->lastts + ms * rate;
+		if (ast_tvzero(frame->delivery)) {
+			int delta = abs((int) multicast->lastts - pred);
+			if (delta < MAX_TIMESTAMP_SKEW) {
+				multicast->lastts = pred;
+			} else {
+				ast_debug(3, "Difference is %d, ms is %u\n", delta, ms);
+				mark = 1;
+			}
+		}
 	}
 
-	/* If we do not have space to construct an RTP header duplicate the frame so we get some */
-	if (frame->offset < hdrlen) {
-		f = ast_frdup(frame);
-	}
-	
-	/* Calucate last TS */
-	multicast->lastts = multicast->lastts + ms * rate;
-	
 	/* Construct an RTP header for our packet */
-	rtpheader = (unsigned char *)(f->data.ptr - hdrlen);
-	put_unaligned_uint32(rtpheader, htonl((2 << 30) | (codec << 16) | (multicast->seqno)));
-	
-	if (ast_test_flag(f, AST_FRFLAG_HAS_TIMING_INFO)) {
-		put_unaligned_uint32(rtpheader + 4, htonl(f->ts * 8));
-	} else {
-		put_unaligned_uint32(rtpheader + 4, htonl(multicast->lastts));
-	}
+	rtpheader = (unsigned char *)(frame->data.ptr - hdrlen);
 
+	put_unaligned_uint32(rtpheader, htonl((2 << 30) | (codec << 16) | (multicast->seqno) | (mark << 23)));
+	put_unaligned_uint32(rtpheader + 4, htonl(multicast->lastts));
 	put_unaligned_uint32(rtpheader + 8, htonl(multicast->ssrc));
 
 	/* Increment sequence number and wrap to 0 if it overflows 16 bits. */
@@ -277,19 +457,84 @@ static int multicast_rtp_write(struct as
 	/* Finally send it out to the eager phones listening for us */
 	ast_rtp_instance_get_remote_address(instance, &remote_address);
 
-	if (ast_sendto(multicast->socket, (void *) rtpheader, f->datalen + hdrlen, 0, &remote_address) < 0) {
+	if (ast_sendto(multicast->socket, (void *) rtpheader, frame->datalen + hdrlen, 0, &remote_address) < 0) {
 		ast_log(LOG_ERROR, "Multicast RTP Transmission error to %s: %s\n",
 			ast_sockaddr_stringify(&remote_address),
 			strerror(errno));
-		res = -1;
+		return -1;
 	}
 
-	/* If we were forced to duplicate the frame free the new one */
-	if (frame != f) {
-		ast_frfree(f);
+	return 0;
+}
+
+/*! \brief Function called to broadcast some audio on a multicast instance */
+static int multicast_rtp_write(struct ast_rtp_instance *instance, struct ast_frame *frame)
+{
+	struct multicast_rtp *multicast = ast_rtp_instance_get_data(instance);
+	struct ast_format *format;
+	struct ast_frame *f;
+	int codec;
+
+	/* We only accept audio, nothing else */
+	if (frame->frametype != AST_FRAME_VOICE) {
+		return 0;
+	}
+
+	/* Grab the actual payload number for when we create the RTP packet */
+	if ((codec = ast_rtp_codecs_payload_code(ast_rtp_instance_get_codecs(instance), 1, frame->subclass.format, 0)) < 0) {
+		return -1;
 	}
 
-	return res;
+	format = frame->subclass.format;
+	if (!multicast->smoother && ast_format_can_be_smoothed(format)) {
+		unsigned int smoother_flags = ast_format_get_smoother_flags(format);
+		unsigned int framing_ms = ast_rtp_codecs_get_framing(ast_rtp_instance_get_codecs(instance));
+
+		if (!framing_ms && (smoother_flags & AST_SMOOTHER_FLAG_FORCED)) {
+			framing_ms = ast_format_get_default_ms(format);
+		}
+
+		if (framing_ms) {
+			multicast->smoother = ast_smoother_new((framing_ms * ast_format_get_minimum_bytes(format)) / ast_format_get_minimum_ms(format));
+			if (!multicast->smoother) {
+				ast_log(LOG_WARNING, "Unable to create smoother: format %s ms: %u len %u\n",
+						ast_format_get_name(format), framing_ms, ast_format_get_minimum_bytes(format));
+				return -1;
+			}
+			ast_smoother_set_flags(multicast->smoother, smoother_flags);
+		}
+	}
+
+	if (multicast->smoother) {
+		if (ast_smoother_test_flag(multicast->smoother, AST_SMOOTHER_FLAG_BE)) {
+			ast_smoother_feed_be(multicast->smoother, frame);
+		} else {
+			ast_smoother_feed(multicast->smoother, frame);
+		}
+
+		while ((f = ast_smoother_read(multicast->smoother)) && f->data.ptr) {
+			rtp_raw_write(instance, f, codec);
+		}
+	} else {
+		int hdrlen = 12;
+
+		/* If we do not have space to construct an RTP header duplicate the frame so we get some */
+		if (frame->offset < hdrlen) {
+			f = ast_frdup(frame);
+		} else {
+			f = frame;
+		}
+
+		if (f->data.ptr) {
+			rtp_raw_write(instance, f, codec);
+		}
+
+		if (f != frame) {
+			ast_frfree(f);
+		}
+	}
+
+	return 0;
 }
 
 /*! \brief Function called to read from a multicast instance */
@@ -314,7 +559,7 @@ static int unload_module(void)
 	return 0;
 }
 
-AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Multicast RTP Engine",
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, "Multicast RTP Engine",
 	.support_level = AST_MODULE_SUPPORT_CORE,
 	.load = load_module,
 	.unload = unload_module,
diff -urpN asterisk-13.9.1/res/res_rtp_multicast.exports.in asterisk-13.17.0/res/res_rtp_multicast.exports.in
--- asterisk-13.9.1/res/res_rtp_multicast.exports.in	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/res_rtp_multicast.exports.in	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,6 @@
+{
+	global:
+		LINKER_SYMBOL_PREFIXast_multicast_rtp*;
+	local:
+		*;
+};
diff -urpN asterisk-13.9.1/res/res_smdi.c asterisk-13.17.0/res/res_smdi.c
--- asterisk-13.9.1/res/res_smdi.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_smdi.c	2017-07-12 13:12:08.000000000 +0200
@@ -1128,7 +1128,7 @@ static int smdi_load(int reload)
 	if (!AST_LIST_EMPTY(&mwi_monitor.mailbox_mappings) && mwi_monitor.thread == AST_PTHREADT_NULL
 		&& ast_pthread_create_background(&mwi_monitor.thread, NULL, mwi_monitor_handler, NULL)) {
 		ast_log(LOG_ERROR, "Failed to start MWI monitoring thread.  This module will not operate.\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return -1;
 	}
 
 	if (ao2_container_count(new_ifaces)) {
@@ -1371,7 +1371,7 @@ static int load_module(void)
 	res = smdi_load(0);
 	if (res < 0) {
 		_unload_module(1);
-		return res;
+		return AST_MODULE_LOAD_DECLINE;
 	} else if (res == 1) {
 		_unload_module(1);
 		ast_log(LOG_NOTICE, "No SMDI interfaces are available to listen on, not starting SMDI listener.\n");
diff -urpN asterisk-13.9.1/res/res_sorcery_astdb.c asterisk-13.17.0/res/res_sorcery_astdb.c
--- asterisk-13.9.1/res/res_sorcery_astdb.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_sorcery_astdb.c	2017-07-12 13:12:08.000000000 +0200
@@ -79,6 +79,58 @@ static int sorcery_astdb_create(const st
 	return ast_db_put(family, ast_sorcery_object_get_id(object), value);
 }
 
+/*! \brief Internal helper function which returns a filtered objectset.
+ *
+ * The following are filtered out of the objectset:
+ * \li Fields that are not registered with sorcery.
+ *
+ * \param objectset Objectset to filter.
+ * \param sorcery The sorcery instance that is requesting an objectset.
+ * \param type The object type
+ *
+ * \return The filtered objectset
+ */
+static struct ast_variable *sorcery_astdb_filter_objectset(struct ast_variable *objectset, const struct ast_sorcery *sorcery,
+	const char *type)
+{
+	struct ast_variable *previous = NULL, *field = objectset;
+	struct ast_sorcery_object_type *object_type;
+
+	object_type = ast_sorcery_get_object_type(sorcery, type);
+	if (!object_type) {
+		ast_log(LOG_WARNING, "Unknown sorcery object type %s. Expect errors\n", type);
+		return objectset;
+	}
+
+	while (field) {
+		struct ast_variable *removed;
+
+		if (ast_sorcery_is_object_field_registered(object_type, field->name)) {
+			previous = field;
+			field = field->next;
+			continue;
+		}
+
+		ast_debug(1, "Filtering out astdb field '%s' from retrieval\n", field->name);
+
+		if (previous) {
+			previous->next = field->next;
+		} else {
+			objectset = field->next;
+		}
+
+		removed = field;
+		field = field->next;
+		removed->next = NULL;
+
+		ast_variables_destroy(removed);
+	}
+
+	ao2_cleanup(object_type);
+
+	return objectset;
+}
+
 /*! \brief Internal helper function which retrieves an object, or multiple objects, using fields for criteria */
 static void *sorcery_astdb_retrieve_fields_common(const struct ast_sorcery *sorcery, void *data, const char *type, const struct ast_variable *fields, struct ao2_container *objects)
 {
@@ -103,10 +155,13 @@ static void *sorcery_astdb_retrieve_fiel
 		if (!(json = ast_json_load_string(entry->data, &error))) {
 			return NULL;
 		}
+
 		if (ast_json_to_ast_variables(json, &existing) != AST_JSON_TO_AST_VARS_CODE_SUCCESS) {
 			return NULL;
 		}
 
+		existing = sorcery_astdb_filter_objectset(existing, sorcery, type);
+
 		if (fields && !ast_variable_lists_match(existing, fields, 0)) {
 			continue;
 		}
@@ -148,6 +203,7 @@ static void *sorcery_astdb_retrieve_id(c
 	if (ast_db_get_allocated(family, id, &value)
 		|| !(json = ast_json_load_string(value, &error))
 		|| (ast_json_to_ast_variables(json, &objset) != AST_JSON_TO_AST_VARS_CODE_SUCCESS)
+		|| !(objset = sorcery_astdb_filter_objectset(objset, sorcery, type))
 		|| !(object = ast_sorcery_alloc(sorcery, type, id))
 		|| ast_sorcery_objectset_apply(sorcery, object, objset)) {
 		ast_debug(3, "Failed to retrieve object '%s' from astdb\n", id);
@@ -260,6 +316,7 @@ static void sorcery_astdb_retrieve_regex
 			continue;
 		} else if (!(json = ast_json_load_string(entry->data, &error))
 			|| (ast_json_to_ast_variables(json, &objset) != AST_JSON_TO_AST_VARS_CODE_SUCCESS)
+			|| !(objset = sorcery_astdb_filter_objectset(objset, sorcery, type))
 			|| !(object = ast_sorcery_alloc(sorcery, type, key))
 			|| ast_sorcery_objectset_apply(sorcery, object, objset)) {
 			regfree(&expression);
diff -urpN asterisk-13.9.1/res/res_sorcery_config.c asterisk-13.17.0/res/res_sorcery_config.c
--- asterisk-13.9.1/res/res_sorcery_config.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_sorcery_config.c	2017-07-12 13:12:08.000000000 +0200
@@ -109,22 +109,6 @@ static void sorcery_config_destructor(vo
 	ast_variables_destroy(config->criteria);
 }
 
-/*! \brief Hashing function for sorcery objects */
-static int sorcery_config_hash(const void *obj, const int flags)
-{
-	const char *id = obj;
-
-	return ast_str_hash(flags & OBJ_KEY ? id : ast_sorcery_object_get_id(obj));
-}
-
-/*! \brief Comparator function for sorcery objects */
-static int sorcery_config_cmp(void *obj, void *arg, int flags)
-{
-	const char *id = arg;
-
-	return !strcmp(ast_sorcery_object_get_id(obj), flags & OBJ_KEY ? id : ast_sorcery_object_get_id(arg)) ? CMP_MATCH | CMP_STOP : 0;
-}
-
 static int sorcery_config_fields_cmp(void *obj, void *arg, int flags)
 {
 	const struct sorcery_config_fields_cmp_params *params = arg;
@@ -145,14 +129,16 @@ static int sorcery_config_fields_cmp(voi
 		return 0;
 	}
 
+	/* We want this object */
 	if (params->container) {
+		/*
+		 * We are putting the found objects into the given container instead
+		 * of the normal container traversal return mechanism.
+		 */
 		ao2_link(params->container, obj);
-
-		/* As multiple objects are being returned keep going */
 		return 0;
 	} else {
-		/* Immediately stop and return, we only want a single object */
-		return CMP_MATCH | CMP_STOP;
+		return CMP_MATCH;
 	}
 }
 
@@ -179,7 +165,7 @@ static void *sorcery_config_retrieve_id(
 	struct sorcery_config *config = data;
 	RAII_VAR(struct ao2_container *, objects, ao2_global_obj_ref(config->objects), ao2_cleanup);
 
-	return objects ? ao2_find(objects, id, OBJ_KEY) : NULL;
+	return objects ? ao2_find(objects, id, OBJ_SEARCH_KEY) : NULL;
 }
 
 static void sorcery_config_retrieve_multiple(const struct ast_sorcery *sorcery, void *data, const char *type, struct ao2_container *objects, const struct ast_variable *fields)
@@ -196,7 +182,7 @@ static void sorcery_config_retrieve_mult
 		return;
 	}
 
-	ao2_callback(config_objects, 0, sorcery_config_fields_cmp, &params);
+	ao2_callback(config_objects, OBJ_NODATA | OBJ_MULTIPLE, sorcery_config_fields_cmp, &params);
 }
 
 static void sorcery_config_retrieve_regex(const struct ast_sorcery *sorcery, void *data, const char *type, struct ao2_container *objects, const char *regex)
@@ -210,11 +196,15 @@ static void sorcery_config_retrieve_rege
 		.regex = &expression,
 	};
 
+	if (ast_strlen_zero(regex)) {
+		regex = ".";
+	}
+
 	if (!config_objects || regcomp(&expression, regex, REG_EXTENDED | REG_NOSUB)) {
 		return;
 	}
 
-	ao2_callback(config_objects, 0, sorcery_config_fields_cmp, &params);
+	ao2_callback(config_objects, OBJ_NODATA | OBJ_MULTIPLE, sorcery_config_fields_cmp, &params);
 	regfree(&expression);
 }
 
@@ -276,8 +266,9 @@ static void sorcery_config_internal_load
 	ast_debug(2, "Using bucket size of '%d' for objects of type '%s' from '%s'\n",
 		buckets, type, config->filename);
 
-	if (!(objects = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, buckets,
-		sorcery_config_hash, sorcery_config_cmp))) {
+	objects = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_NOLOCK, 0, buckets,
+		ast_sorcery_object_id_hash, NULL, ast_sorcery_object_id_compare);
+	if (!objects) {
 		ast_log(LOG_ERROR, "Could not create bucket for new objects from '%s', keeping existing objects\n",
 			config->filename);
 		ast_config_destroy(cfg);
@@ -296,8 +287,7 @@ static void sorcery_config_internal_load
 		/*  Confirm an object with this id does not already exist in the bucket.
 		 *  If it exists, however, the configuration is invalid so stop
 		 *  processing and destroy it. */
-		obj = ao2_find(objects, id, OBJ_KEY);
-
+		obj = ao2_find(objects, id, OBJ_SEARCH_KEY);
 		if (obj) {
 			ast_log(LOG_ERROR, "Config file '%s' could not be loaded; configuration contains a duplicate object: '%s' of type '%s'\n",
 				config->filename, id, type);
diff -urpN asterisk-13.9.1/res/res_sorcery_memory.c asterisk-13.17.0/res/res_sorcery_memory.c
--- asterisk-13.9.1/res/res_sorcery_memory.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_sorcery_memory.c	2017-07-12 13:12:08.000000000 +0200
@@ -188,6 +188,10 @@ static void sorcery_memory_retrieve_rege
 		.regex = &expression,
 	};
 
+	if (ast_strlen_zero(regex)) {
+		regex = ".";
+	}
+
 	if (regcomp(&expression, regex, REG_EXTENDED | REG_NOSUB)) {
 		return;
 	}
diff -urpN asterisk-13.9.1/res/res_sorcery_memory_cache.c asterisk-13.17.0/res/res_sorcery_memory_cache.c
--- asterisk-13.9.1/res/res_sorcery_memory_cache.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_sorcery_memory_cache.c	2017-07-12 13:12:08.000000000 +0200
@@ -83,6 +83,9 @@
 			<parameter name="Object" required="true">
 				<para>The name of the object to mark as stale.</para>
 			</parameter>
+			<parameter name="Reload" required="false">
+				<para>If true, then immediately reload the object from the backend cache instead of waiting for the next retrieval</para>
+			</parameter>
 		</syntax>
 		<description>
 			<para>Marks an object as stale within a sorcery memory cache.</para>
@@ -1394,10 +1397,8 @@ static void sorcery_memory_cache_load(vo
 	ast_debug(1, "Memory cache '%s' associated with sorcery instance '%p' of module '%s' with object type '%s'\n",
 		cache->name, sorcery, ast_sorcery_get_module(sorcery), type);
 
-	if (cache->full_backend_cache) {
-		cache->sorcery = sorcery;
-		cache->object_type = ast_strdup(type);
-	}
+	cache->sorcery = sorcery;
+	cache->object_type = ast_strdup(type);
 }
 
 /*!
@@ -1555,7 +1556,7 @@ static int sorcery_memory_cache_delete(c
 	ao2_unlock(cache->objects);
 
 	if (res) {
-		ast_log(LOG_ERROR, "Unable to delete object '%s' from sorcery cache\n", ast_sorcery_object_get_id(object));
+		ast_debug(1, "Unable to delete object '%s' from sorcery cache\n", ast_sorcery_object_get_id(object));
 	}
 
 	return res;
@@ -1865,28 +1866,42 @@ static char *sorcery_memory_cache_expire
 static char *sorcery_memory_cache_stale(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	struct sorcery_memory_cache *cache;
+	int reload = 0;
 
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "sorcery memory cache stale";
 		e->usage =
-		    "Usage: sorcery memory cache stale <cache name> [object name]\n"
-		    "       Mark a specific object or ALL objects as stale in a sorcery memory cache.\n";
+		    "Usage: sorcery memory cache stale <cache name> [object name [reload]]\n"
+		    "       Mark a specific object or ALL objects as stale in a sorcery memory cache.\n"
+		    "       If \"reload\" is specified, then the object is marked stale and immediately\n"
+		    "       retrieved from backend storage to repopulate the cache\n";
 		return NULL;
 	case CLI_GENERATE:
 		if (a->pos == 4) {
 			return sorcery_memory_cache_complete_name(a->word, a->n);
 		} else if (a->pos == 5) {
 			return sorcery_memory_cache_complete_object_name(a->argv[4], a->word, a->n);
+		} else if (a->pos == 6) {
+			static const char * const completions[] = { "reload", NULL };
+			return ast_cli_complete(a->word, completions, a->n);
 		} else {
 			return NULL;
 		}
 	}
 
-	if (a->argc < 5 || a->argc > 6) {
+	if (a->argc < 5 || a->argc > 7) {
 		return CLI_SHOWUSAGE;
 	}
 
+	if (a->argc == 7) {
+		if (!strcasecmp(a->argv[6], "reload")) {
+			reload = 1;
+		} else {
+			return CLI_SHOWUSAGE;
+		}
+	}
+
 	cache = ao2_find(caches, a->argv[4], OBJ_SEARCH_KEY);
 	if (!cache) {
 		ast_cli(a->fd, "Specified sorcery memory cache '%s' does not exist\n", a->argv[4]);
@@ -1907,6 +1922,15 @@ static char *sorcery_memory_cache_stale(
 		if (!mark_object_as_stale_in_cache(cache, a->argv[5])) {
 			ast_cli(a->fd, "Successfully marked object '%s' in memory cache '%s' as stale\n",
 				a->argv[5], a->argv[4]);
+			if (reload) {
+				struct sorcery_memory_cached_object *cached;
+
+				cached = ao2_find(cache->objects, a->argv[5], OBJ_SEARCH_KEY | OBJ_NOLOCK);
+				if (cached) {
+					memory_cache_stale_update_object(cache->sorcery, cache, cached);
+					ao2_ref(cached, -1);
+				}
+			}
 		} else {
 			ast_cli(a->fd, "Object '%s' in sorcery memory cache '%s' could not be marked as stale as it was not found\n",
 				a->argv[5], a->argv[4]);
@@ -2066,6 +2090,7 @@ static int sorcery_memory_cache_ami_stal
 {
 	const char *cache_name = astman_get_header(m, "Cache");
 	const char *object_name = astman_get_header(m, "Object");
+	const char *reload = astman_get_header(m, "Reload");
 	struct sorcery_memory_cache *cache;
 	int res;
 
@@ -2084,7 +2109,19 @@ static int sorcery_memory_cache_ami_stal
 	}
 
 	ao2_rdlock(cache->objects);
+
 	res = mark_object_as_stale_in_cache(cache, object_name);
+
+	if (ast_true(reload)) {
+		struct sorcery_memory_cached_object *cached;
+
+		cached = ao2_find(cache->objects, object_name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
+		if (cached) {
+			memory_cache_stale_update_object(cache->sorcery, cache, cached);
+			ao2_ref(cached, -1);
+		}
+	}
+
 	ao2_unlock(cache->objects);
 
 	ao2_ref(cache, -1);
diff -urpN asterisk-13.9.1/res/res_sorcery_realtime.c asterisk-13.17.0/res/res_sorcery_realtime.c
--- asterisk-13.9.1/res/res_sorcery_realtime.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_sorcery_realtime.c	2017-07-12 13:12:08.000000000 +0200
@@ -271,7 +271,7 @@ static int sorcery_realtime_update(const
 		return -1;
 	}
 
-	return (ast_update_realtime_fields(config->family, UUID_FIELD, ast_sorcery_object_get_id(object), fields) <= 0) ? -1 : 0;
+	return (ast_update_realtime_fields(config->family, UUID_FIELD, ast_sorcery_object_get_id(object), fields) < 0) ? -1 : 0;
 }
 
 static int sorcery_realtime_delete(const struct ast_sorcery *sorcery, void *data, void *object)
diff -urpN asterisk-13.9.1/res/res_srtp.c asterisk-13.17.0/res/res_srtp.c
--- asterisk-13.9.1/res/res_srtp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_srtp.c	2017-07-12 13:12:08.000000000 +0200
@@ -39,8 +39,19 @@
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
-#include <srtp/srtp.h>
-#include <srtp/crypto_kernel.h>
+#if HAVE_SRTP_VERSION > 1
+# include <srtp2/srtp.h>
+# include <srtp2/crypto_types.h>
+# include "srtp/srtp_compat.h"
+# include <openssl/rand.h>
+#else
+# include <srtp/srtp.h>
+# ifdef HAVE_OPENSSL
+#  include <openssl/rand.h>
+# else
+#  include <srtp/crypto_kernel.h>
+# endif
+#endif
 
 #include "asterisk/lock.h"
 #include "asterisk/sched.h"
@@ -305,7 +316,11 @@ static int ast_srtp_policy_set_master_ke
 
 static int ast_srtp_get_random(unsigned char *key, size_t len)
 {
+#ifdef HAVE_OPENSSL
+	return RAND_bytes(key, len) > 0 ? 0: -1;
+#else
 	return crypto_get_random(key, len) != err_status_ok ? -1: 0;
+#endif
 }
 
 static void ast_srtp_set_cb(struct ast_srtp *srtp, const struct ast_srtp_cb *cb, void *data)
diff -urpN asterisk-13.9.1/res/res_stasis.c asterisk-13.17.0/res/res_stasis.c
--- asterisk-13.9.1/res/res_stasis.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_stasis.c	2017-07-12 13:12:08.000000000 +0200
@@ -177,11 +177,6 @@ static struct ast_json *stasis_start_to_
 STASIS_MESSAGE_TYPE_DEFN_LOCAL(start_message_type,
 	.to_json = stasis_start_to_json);
 
-const char *stasis_app_name(const struct stasis_app *app)
-{
-	return app_name(app);
-}
-
 /*! AO2 hash function for \ref app */
 static int app_hash(const void *obj, const int flags)
 {
@@ -713,6 +708,22 @@ int stasis_app_bridge_playback_channel_a
 	return 0;
 }
 
+void stasis_app_bridge_playback_channel_remove(char *bridge_id,
+	struct stasis_app_control *control)
+{
+	struct stasis_app_bridge_channel_wrapper *wrapper;
+
+	wrapper = ao2_find(app_bridges_playback, bridge_id, OBJ_SEARCH_KEY | OBJ_UNLINK);
+	if (wrapper) {
+		/* If wrapper is not found, then that means the after bridge callback has been
+		 * called or is in progress. No need to unlink the control here since that has
+		 * been done or is about to be done in the after bridge callback
+		 */
+		ao2_unlink(app_controls, control);
+		ao2_ref(wrapper, -1);
+	}
+}
+
 struct ast_channel *stasis_app_bridge_playback_channel_find(struct ast_bridge *bridge)
 {
 	struct stasis_app_bridge_channel_wrapper *playback_wrapper;
@@ -781,6 +792,7 @@ struct ast_bridge *stasis_app_bridge_cre
 
 	bridge = bridge_stasis_new(capabilities, flags, name, id);
 	if (bridge) {
+		ast_bridge_set_talker_src_video_mode(bridge);
 		if (!ao2_link(app_bridges, bridge)) {
 			ast_bridge_destroy(bridge, 0);
 			bridge = NULL;
@@ -926,7 +938,7 @@ static int send_start_msg_snapshots(stru
 
 	if (app_subscribe_channel(app, chan)) {
 		ast_log(LOG_ERROR, "Error subscribing app '%s' to channel '%s'\n",
-			app_name(app), ast_channel_name(chan));
+			stasis_app_name(app), ast_channel_name(chan));
 		return -1;
 	}
 
@@ -940,7 +952,7 @@ static int send_start_msg_snapshots(stru
 	payload->replace_channel = ao2_bump(replace_channel_snapshot);
 
 	json_blob = ast_json_pack("{s: s, s: o, s: []}",
-		"app", app_name(app),
+		"app", stasis_app_name(app),
 		"timestamp", ast_json_timeval(ast_tvnow(), NULL),
 		"args");
 	if (!json_blob) {
@@ -1010,7 +1022,7 @@ int app_send_end_msg(struct stasis_app *
 		return 0;
 	}
 
-	blob = ast_json_pack("{s: s}", "app", app_name(app));
+	blob = ast_json_pack("{s: s}", "app", stasis_app_name(app));
 	if (!blob) {
 		ast_log(LOG_ERROR, "Error packing JSON for StasisEnd message\n");
 		return -1;
@@ -1045,8 +1057,18 @@ static void channel_stolen_cb(void *data
 {
 	struct stasis_app_control *control;
 
-	/* find control */
-	control = ao2_callback(app_controls, 0, masq_match_cb, old_chan);
+	/*
+	 * At this point, old_chan is the channel pointer that is in Stasis() and
+	 * has the unknown channel's name in it while new_chan is the channel pointer
+	 * that is not in Stasis(), but has the guts of the channel that Stasis() knows
+	 * about.
+	 *
+	 * Find and unlink control since the channel has a new name/uniqueid
+	 * and its hash has changed.  Since the channel is leaving stasis don't
+	 * bother putting it back into the container.  Nobody is going to
+	 * remove it from the container later.
+	 */
+	control = ao2_callback(app_controls, OBJ_UNLINK, masq_match_cb, old_chan);
 	if (!control) {
 		ast_log(LOG_ERROR, "Could not find control for masqueraded channel\n");
 		return;
@@ -1087,8 +1109,10 @@ static void channel_replaced_cb(void *da
 		return;
 	}
 
-	/* find, unlink, and relink control since the channel has a new name and
-	 * its hash has likely changed */
+	/*
+	 * Find, unlink, and relink control since the channel has a new
+	 * name/uniqueid and its hash has changed.
+	 */
 	control = ao2_callback(app_controls, OBJ_UNLINK, masq_match_cb, new_chan);
 	if (!control) {
 		ast_log(LOG_ERROR, "Could not find control for masquerading channel\n");
@@ -1298,7 +1322,9 @@ int stasis_app_exec(struct ast_channel *
 		bridge = ao2_bump(stasis_app_get_bridge(control));
 
 		if (bridge != last_bridge) {
-			app_unsubscribe_bridge(app, last_bridge);
+			if (last_bridge) {
+				app_unsubscribe_bridge(app, last_bridge);
+			}
 			if (bridge) {
 				app_subscribe_bridge(app, bridge);
 			}
@@ -1359,7 +1385,9 @@ int stasis_app_exec(struct ast_channel *
 		ast_bridge_depart(chan);
 	}
 
-	app_unsubscribe_bridge(app, stasis_app_get_bridge(control));
+	if (stasis_app_get_bridge(control)) {
+		app_unsubscribe_bridge(app, stasis_app_get_bridge(control));
+	}
 	ao2_cleanup(bridge);
 
 	/* Only publish a stasis_end event if it hasn't already been published */
@@ -1452,13 +1480,14 @@ static struct stasis_app *find_app_by_na
 		res = ao2_find(apps_registry, app_name, OBJ_SEARCH_KEY);
 	}
 
-	if (!res) {
-		ast_log(LOG_WARNING, "Could not find app '%s'\n",
-			app_name ? : "(null)");
-	}
 	return res;
 }
 
+struct stasis_app *stasis_app_get_by_name(const char *name)
+{
+	return find_app_by_name(name);
+}
+
 static int append_name(void *obj, void *arg, int flags)
 {
 	struct stasis_app *app = obj;
@@ -2080,12 +2109,12 @@ static int load_module(void)
 		37, bridges_channel_hash_fn, bridges_channel_sort_fn, NULL);
 	if (!apps_registry || !app_controls || !app_bridges || !app_bridges_moh || !app_bridges_playback) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (messaging_init()) {
 		unload_module();
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	bridge_stasis_init();
diff -urpN asterisk-13.9.1/res/res_stasis_device_state.c asterisk-13.17.0/res/res_stasis_device_state.c
--- asterisk-13.9.1/res/res_stasis_device_state.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_stasis_device_state.c	2017-07-12 13:12:08.000000000 +0200
@@ -148,13 +148,13 @@ static struct device_state_subscription
 		.device_name = name
 	};
 
-	return ao2_find(device_state_subscriptions, &dummy_sub, OBJ_SEARCH_OBJECT);
+	return ao2_find(device_state_subscriptions, &dummy_sub, OBJ_SEARCH_OBJECT | OBJ_NOLOCK);
 }
 
 static void remove_device_state_subscription(
 	struct device_state_subscription *sub)
 {
-	ao2_unlink(device_state_subscriptions, sub);
+	ao2_unlink_flags(device_state_subscriptions, sub, OBJ_NOLOCK);
 }
 
 struct ast_json *stasis_app_device_state_to_json(
@@ -346,6 +346,17 @@ static int is_subscribed_device_state(st
 	return 0;
 }
 
+static int is_subscribed_device_state_lock(struct stasis_app *app, const char *name)
+{
+	int is_subscribed;
+
+	ao2_lock(device_state_subscriptions);
+	is_subscribed = is_subscribed_device_state(app, name);
+	ao2_unlock(device_state_subscriptions);
+
+	return is_subscribed;
+}
+
 static int subscribe_device_state(struct stasis_app *app, void *obj)
 {
 	struct device_state_subscription *sub = obj;
@@ -364,7 +375,10 @@ static int subscribe_device_state(struct
 		topic = ast_device_state_topic_all();
 	}
 
+	ao2_lock(device_state_subscriptions);
+
 	if (is_subscribed_device_state(app, sub->device_name)) {
+		ao2_unlock(device_state_subscriptions);
 		ast_debug(3, "App %s is already subscribed to %s\n", stasis_app_name(app), sub->device_name);
 		return 0;
 	}
@@ -373,6 +387,7 @@ static int subscribe_device_state(struct
 
 	sub->sub = stasis_subscribe_pool(topic, device_state_cb, ao2_bump(sub));
 	if (!sub->sub) {
+		ao2_unlock(device_state_subscriptions);
 		ast_log(LOG_ERROR, "Unable to subscribe to device %s\n",
 			sub->device_name);
 		/* Reference we added when attempting to stasis_subscribe_pool */
@@ -380,15 +395,25 @@ static int subscribe_device_state(struct
 		return -1;
 	}
 
-	ao2_link(device_state_subscriptions, sub);
+	ao2_link_flags(device_state_subscriptions, sub, OBJ_NOLOCK);
+	ao2_unlock(device_state_subscriptions);
+
 	return 0;
 }
 
 static int unsubscribe_device_state(struct stasis_app *app, const char *name)
 {
-	RAII_VAR(struct device_state_subscription *, sub,
-		 find_device_state_subscription(app, name), ao2_cleanup);
-	remove_device_state_subscription(sub);
+	struct device_state_subscription *sub;
+
+	ao2_lock(device_state_subscriptions);
+	sub = find_device_state_subscription(app, name);
+	if (sub) {
+		remove_device_state_subscription(sub);
+	}
+	ao2_unlock(device_state_subscriptions);
+
+	ao2_cleanup(sub);
+
 	return 0;
 }
 
@@ -421,7 +446,7 @@ struct stasis_app_event_source device_st
 	.find = find_device_state,
 	.subscribe = subscribe_device_state,
 	.unsubscribe = unsubscribe_device_state,
-	.is_subscribed = is_subscribed_device_state,
+	.is_subscribed = is_subscribed_device_state_lock,
 	.to_json = devices_to_json
 };
 
@@ -430,13 +455,14 @@ static int load_module(void)
 	populate_cache();
 	if (ast_devstate_prov_add(DEVICE_STATE_PROVIDER_STASIS,
 				  stasis_device_state_cb)) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (!(device_state_subscriptions = ao2_container_alloc(
 		      DEVICE_STATE_BUCKETS, device_state_subscriptions_hash,
 		      device_state_subscriptions_cmp))) {
-		return AST_MODULE_LOAD_FAILURE;
+		ast_devstate_prov_del(DEVICE_STATE_PROVIDER_STASIS);
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	stasis_app_register_event_source(&device_state_event_source);
diff -urpN asterisk-13.9.1/res/res_stasis_playback.c asterisk-13.17.0/res/res_stasis_playback.c
--- asterisk-13.9.1/res/res_stasis_playback.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_stasis_playback.c	2017-07-12 13:12:08.000000000 +0200
@@ -664,13 +664,14 @@ static int load_module(void)
 
 	r = STASIS_MESSAGE_TYPE_INIT(stasis_app_playback_snapshot_type);
 	if (r != 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	playbacks = ao2_container_alloc(PLAYBACK_BUCKETS, playback_hash,
 		playback_cmp);
 	if (!playbacks) {
-		return AST_MODULE_LOAD_FAILURE;
+		STASIS_MESSAGE_TYPE_CLEANUP(stasis_app_playback_snapshot_type);
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/res/res_stasis_recording.c asterisk-13.17.0/res/res_stasis_recording.c
--- asterisk-13.9.1/res/res_stasis_recording.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_stasis_recording.c	2017-07-12 13:12:08.000000000 +0200
@@ -633,13 +633,14 @@ static int load_module(void)
 
 	r = STASIS_MESSAGE_TYPE_INIT(stasis_app_recording_snapshot_type);
 	if (r != 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	recordings = ao2_container_alloc(RECORDING_BUCKETS, recording_hash,
 		recording_cmp);
 	if (!recordings) {
-		return AST_MODULE_LOAD_FAILURE;
+		STASIS_MESSAGE_TYPE_CLEANUP(stasis_app_recording_snapshot_type);
+		return AST_MODULE_LOAD_DECLINE;
 	}
 	return AST_MODULE_LOAD_SUCCESS;
 }
diff -urpN asterisk-13.9.1/res/res_stasis_test.c asterisk-13.17.0/res/res_stasis_test.c
--- asterisk-13.9.1/res/res_stasis_test.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_stasis_test.c	2017-07-12 13:12:08.000000000 +0200
@@ -273,7 +273,7 @@ static int unload_module(void)
 static int load_module(void)
 {
 	if (STASIS_MESSAGE_TYPE_INIT(stasis_test_message_type) != 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_statsd.c asterisk-13.17.0/res/res_statsd.c
--- asterisk-13.9.1/res/res_statsd.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_statsd.c	2017-07-12 13:12:08.000000000 +0200
@@ -351,7 +351,8 @@ static int load_module(void)
 	}
 
 	if (statsd_init() != 0) {
-		return AST_MODULE_LOAD_FAILURE;
+		aco_info_destroy(&cfg_info);
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	return AST_MODULE_LOAD_SUCCESS;
diff -urpN asterisk-13.9.1/res/res_stun_monitor.c asterisk-13.17.0/res/res_stun_monitor.c
--- asterisk-13.9.1/res/res_stun_monitor.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_stun_monitor.c	2017-07-12 13:12:08.000000000 +0200
@@ -271,7 +271,7 @@ static int stun_start_monitor(void)
  * \retval 0 on success.
  * \retval -1 on error.
  */
-static int setup_stunaddr(const char *value)
+static int setup_stunaddr(const char *value, int reload)
 {
 	char *val;
 	char *host_str;
@@ -307,8 +307,12 @@ static int setup_stunaddr(const char *va
 	stun_addr.ss.ss_family = AF_INET;
 	if (ast_get_ip(&stun_addr, host_str)) {
 		ast_log(LOG_WARNING, "Unable to lookup STUN server '%s'\n", host_str);
-		ast_free(host_str);
-		return -1;
+
+		/* Only treat this as fatal if we are reloading */
+		if (reload) {
+			ast_free(host_str);
+			return -1;
+		}
 	}
 
 	/* Save STUN server information. */
@@ -350,7 +354,7 @@ static int load_config(int startup)
 
 	for (v = ast_variable_browse(cfg, "general"); v; v = v->next) {
 		if (!strcasecmp(v->name, "stunaddr")) {
-			if (setup_stunaddr(v->value)) {
+			if (setup_stunaddr(v->value, !startup)) {
 				ast_log(LOG_WARNING, "Invalid STUN server address: %s at line %d\n",
 					v->value, v->lineno);
 			}
diff -urpN asterisk-13.9.1/res/res_xmpp.c asterisk-13.17.0/res/res_xmpp.c
--- asterisk-13.9.1/res/res_xmpp.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/res_xmpp.c	2017-07-12 13:12:08.000000000 +0200
@@ -278,11 +278,11 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 			<para>Sends a message to a Jabber Client.</para>
 		</description>
 	</manager>
-	<info name="XMPPMessageToInfo" language="en_US" tech="XMPP">
+	<info name="MessageToInfo" language="en_US" tech="XMPP">
 		<para>Specifying a prefix of <literal>xmpp:</literal> will send the
 		message as an XMPP chat message.</para>
 	</info>
-	<info name="XMPPMessageFromInfo" language="en_US" tech="XMPP">
+	<info name="MessageFromInfo" language="en_US" tech="XMPP">
 		<para>Specifying a prefix of <literal>xmpp:</literal> will specify the
 		account defined in <literal>xmpp.conf</literal> to send the message from.
 		Note that this field is required for XMPP messages.</para>
@@ -561,7 +561,6 @@ static void xmpp_client_destructor(void
 	ast_xmpp_client_disconnect(client);
 
 	ast_endpoint_shutdown(client->endpoint);
-	ao2_cleanup(client->endpoint);
 	client->endpoint = NULL;
 
 	if (client->filter) {
@@ -1632,6 +1631,35 @@ static int xmpp_resource_immediate(void
 	return CMP_MATCH | CMP_STOP;
 }
 
+#define BUDDY_OFFLINE 6
+#define BUDDY_NOT_IN_ROSTER 7
+
+static int get_buddy_status(struct ast_xmpp_client_config *clientcfg, char *screenname, char *resource)
+{
+	int status = BUDDY_OFFLINE;
+	struct ast_xmpp_resource *res;
+	struct ast_xmpp_buddy *buddy = ao2_find(clientcfg->client->buddies, screenname, OBJ_KEY);
+
+	if (!buddy) {
+		return BUDDY_NOT_IN_ROSTER;
+	}
+
+	res = ao2_callback(
+		buddy->resources,
+		0,
+		ast_strlen_zero(resource) ? xmpp_resource_immediate : xmpp_resource_cmp,
+		resource);
+
+	if (res) {
+		status = res->status;
+	}
+
+	ao2_cleanup(res);
+	ao2_cleanup(buddy);
+
+	return status;
+}
+
 /*
  * \internal
  * \brief Dial plan function status(). puts the status of watched user
@@ -1645,10 +1673,7 @@ static int xmpp_status_exec(struct ast_c
 {
 	RAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);
 	RAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);
-	struct ast_xmpp_buddy *buddy;
-	struct ast_xmpp_resource *resource;
 	char *s = NULL, status[2];
-	int stat = 7;
 	static int deprecation_warning = 0;
 	AST_DECLARE_APP_ARGS(args,
 			     AST_APP_ARG(sender);
@@ -1687,25 +1712,7 @@ static int xmpp_status_exec(struct ast_c
 		return -1;
 	}
 
-	if (!(buddy = ao2_find(clientcfg->client->buddies, jid.screenname, OBJ_KEY))) {
-		ast_log(LOG_WARNING, "Could not find buddy in list: '%s'\n", jid.screenname);
-		return -1;
-	}
-
-	if (ast_strlen_zero(jid.resource) || !(resource = ao2_callback(buddy->resources, 0, xmpp_resource_cmp, jid.resource))) {
-		resource = ao2_callback(buddy->resources, OBJ_NODATA, xmpp_resource_immediate, NULL);
-	}
-
-	ao2_ref(buddy, -1);
-
-	if (resource) {
-		stat = resource->status;
-		ao2_ref(resource, -1);
-	} else {
-		ast_log(LOG_NOTICE, "Resource '%s' of buddy '%s' was not found\n", jid.resource, jid.screenname);
-	}
-
-	snprintf(status, sizeof(status), "%d", stat);
+	snprintf(status, sizeof(status), "%d", get_buddy_status(clientcfg, jid.screenname, jid.resource));
 	pbx_builtin_setvar_helper(chan, args.variable, status);
 
 	return 0;
@@ -1724,9 +1731,6 @@ static int acf_jabberstatus_read(struct
 {
 	RAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);
 	RAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);
-	struct ast_xmpp_buddy *buddy;
-	struct ast_xmpp_resource *resource;
-	int stat = 7;
 	AST_DECLARE_APP_ARGS(args,
 			     AST_APP_ARG(sender);
 			     AST_APP_ARG(jid);
@@ -1758,25 +1762,7 @@ static int acf_jabberstatus_read(struct
 		return -1;
 	}
 
-	if (!(buddy = ao2_find(clientcfg->client->buddies, jid.screenname, OBJ_KEY))) {
-		ast_log(LOG_WARNING, "Could not find buddy in list: '%s'\n", jid.screenname);
-		return -1;
-	}
-
-	if (ast_strlen_zero(jid.resource) || !(resource = ao2_callback(buddy->resources, 0, xmpp_resource_cmp, jid.resource))) {
-		resource = ao2_callback(buddy->resources, OBJ_NODATA, xmpp_resource_immediate, NULL);
-	}
-
-	ao2_ref(buddy, -1);
-
-	if (resource) {
-		stat = resource->status;
-		ao2_ref(resource, -1);
-	} else {
-		ast_log(LOG_NOTICE, "Resource %s of buddy %s was not found.\n", jid.resource, jid.screenname);
-	}
-
-	snprintf(buf, buflen, "%d", stat);
+	snprintf(buf, buflen, "%d", get_buddy_status(clientcfg, jid.screenname, jid.resource));
 
 	return 0;
 }
@@ -2564,10 +2550,16 @@ static void xmpp_log_hook(void *data, co
 static int xmpp_client_send_raw_message(struct ast_xmpp_client *client, const char *message)
 {
 	int ret;
-#ifdef HAVE_OPENSSL
-	int len = strlen(message);
 
+	if (client->state == XMPP_STATE_DISCONNECTED) {
+		/* iks_send_raw will crash without a connection */
+		return IKS_NET_NOCONN;
+	}
+
+#ifdef HAVE_OPENSSL
 	if (xmpp_is_secure(client)) {
+		int len = strlen(message);
+
 		ret = SSL_write(client->ssl_session, message, len);
 		if (ret) {
 			/* Log the message here, because iksemel's logHook is
@@ -2631,12 +2623,31 @@ static int xmpp_client_request_tls(struc
 #endif
 }
 
+#ifdef HAVE_OPENSSL
+static char *openssl_error_string(void)
+{
+	char *buf = NULL, *ret;
+	size_t len;
+	BIO *bio = BIO_new(BIO_s_mem());
+
+	ERR_print_errors(bio);
+	len = BIO_get_mem_data(bio, &buf);
+	ret = ast_calloc(1, len + 1);
+	if (ret) {
+		memcpy(ret, buf, len);
+	}
+	BIO_free(bio);
+	return ret;
+}
+#endif
+
 /*! \brief Internal function called when we receive a response to our TLS initiation request */
 static int xmpp_client_requested_tls(struct ast_xmpp_client *client, struct ast_xmpp_client_config *cfg, int type, iks *node)
 {
 #ifdef HAVE_OPENSSL
 	int sock;
 	long ssl_opts;
+	char *err;
 #endif
 
 	if (!strcmp(iks_name(node), "success")) {
@@ -2672,7 +2683,7 @@ static int xmpp_client_requested_tls(str
 		goto failure;
 	}
 
-	if (!SSL_connect(client->ssl_session)) {
+	if (SSL_connect(client->ssl_session) <= 0) {
 		goto failure;
 	}
 
@@ -2692,7 +2703,10 @@ static int xmpp_client_requested_tls(str
 	return 0;
 
 failure:
-	ast_log(LOG_ERROR, "TLS connection for client '%s' cannot be established. OpenSSL initialization failed.\n", client->name);
+	err = openssl_error_string();
+	ast_log(LOG_ERROR, "TLS connection for client '%s' cannot be established. "
+		"OpenSSL initialization failed: %s\n", client->name, err);
+	ast_free(err);
 	return -1;
 #endif
 }
@@ -3567,6 +3581,7 @@ int ast_xmpp_client_disconnect(struct as
 {
 	if ((client->thread != AST_PTHREADT_NULL) && !pthread_equal(pthread_self(), client->thread)) {
 		xmpp_client_change_state(client, XMPP_STATE_DISCONNECTING);
+		pthread_cancel(client->thread);
 		pthread_join(client->thread, NULL);
 		client->thread = AST_PTHREADT_NULL;
 	}
@@ -3746,22 +3761,37 @@ static int xmpp_client_receive(struct as
 	return IKS_OK;
 }
 
+static void sleep_with_backoff(unsigned int *sleep_time)
+{
+	/* We're OK with our thread dying here */
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+
+	sleep(*sleep_time);
+	*sleep_time = MIN(60, *sleep_time * 2);
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+}
+
 /*! \brief XMPP client connection thread */
 static void *xmpp_client_thread(void *data)
 {
 	struct ast_xmpp_client *client = data;
 	int res = IKS_NET_RWERR;
+	unsigned int sleep_time = 1;
+
+	/* We only allow cancellation while sleeping */
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 
 	do {
 		if (client->state == XMPP_STATE_DISCONNECTING) {
-			ast_debug(1, "JABBER: Disconnecting client '%s'\n", client->name);
+			ast_debug(1, "[%s] Disconnecting\n", client->name);
 			break;
 		}
 
 		if (res == IKS_NET_RWERR || client->timeout == 0) {
-			ast_debug(3, "Connecting client '%s'\n", client->name);
+			ast_debug(3, "[%s] Connecting\n", client->name);
 			if ((res = xmpp_client_reconnect(client)) != IKS_OK) {
-				sleep(4);
+				sleep_with_backoff(&sleep_time);
 				res = IKS_NET_RWERR;
 			}
 			continue;
@@ -3776,9 +3806,9 @@ static void *xmpp_client_thread(void *da
 		}
 
 		if (res == IKS_HOOK) {
-			ast_debug(2, "JABBER: Got hook event.\n");
+			ast_debug(2, "[%s] Got hook event\n", client->name);
 		} else if (res == IKS_NET_TLSFAIL) {
-			ast_log(LOG_ERROR, "JABBER:  Failure in TLS.\n");
+			ast_log(LOG_ERROR, "[%s] TLS failure\n", client->name);
 		} else if (!client->timeout && client->state == XMPP_STATE_CONNECTED) {
 			RAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);
 			RAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);
@@ -3796,22 +3826,26 @@ static void *xmpp_client_thread(void *da
 			if (res == IKS_OK) {
 				client->timeout = 50;
 			} else {
-				ast_log(LOG_WARNING, "JABBER: Network Timeout\n");
+				ast_log(LOG_WARNING, "[%s] Network timeout\n", client->name);
 			}
 		} else if (res == IKS_NET_RWERR) {
-			ast_log(LOG_WARNING, "JABBER: socket read error\n");
+			ast_log(LOG_WARNING, "[%s] Socket read error\n", client->name);
+			ast_xmpp_client_disconnect(client);
+			sleep_with_backoff(&sleep_time);
 		} else if (res == IKS_NET_NOSOCK) {
-			ast_log(LOG_WARNING, "JABBER: No Socket\n");
+			ast_log(LOG_WARNING, "[%s] No socket\n", client->name);
 		} else if (res == IKS_NET_NOCONN) {
-			ast_log(LOG_WARNING, "JABBER: No Connection\n");
+			ast_log(LOG_WARNING, "[%s] No connection\n", client->name);
 		} else if (res == IKS_NET_NODNS) {
-			ast_log(LOG_WARNING, "JABBER: No DNS\n");
+			ast_log(LOG_WARNING, "[%s] No DNS\n", client->name);
 		} else if (res == IKS_NET_NOTSUPP) {
-			ast_log(LOG_WARNING, "JABBER: Not Supported\n");
+			ast_log(LOG_WARNING, "[%s] Not supported\n", client->name);
 		} else if (res == IKS_NET_DROPPED) {
-			ast_log(LOG_WARNING, "JABBER: Dropped?\n");
+			ast_log(LOG_WARNING, "[%s] Dropped?\n", client->name);
 		} else if (res == IKS_NET_UNKNOWN) {
-			ast_debug(5, "JABBER: Unknown\n");
+			ast_debug(5, "[%s] Unknown\n", client->name);
+		} else if (res == IKS_OK) {
+			sleep_time = 1;
 		}
 
 	} while (1);
@@ -4652,6 +4686,10 @@ static int load_module(void)
 	ast_mutex_init(&messagelock);
 	ast_cond_init(&message_received_condition, NULL);
 
+	if (ast_eid_is_empty(&ast_eid_default)) {
+		ast_log(LOG_WARNING, "Entity ID is not set. The distributing device state or MWI will not work.\n");
+	}
+
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/res/srtp/srtp_compat.h asterisk-13.17.0/res/srtp/srtp_compat.h
--- asterisk-13.9.1/res/srtp/srtp_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/res/srtp/srtp_compat.h	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,29 @@
+#ifndef AST_SRTP_COMPAT_H
+#define AST_SRTP_COMPAT_H
+
+/* Compatibility for libsrtp 2.x */
+
+#define crypto_policy_t srtp_crypto_policy_t
+
+#define AES_128_ICM SRTP_AES_ICM
+#define HMAC_SHA1 SRTP_HMAC_SHA1
+
+#define err_status_t srtp_err_status_t
+#define err_status_ok srtp_err_status_ok
+#define err_status_fail srtp_err_status_fail
+#define err_status_bad_param srtp_err_status_bad_param
+#define err_status_alloc_fail srtp_err_status_alloc_fail
+#define err_status_dealloc_fail srtp_err_status_dealloc_fail
+#define err_status_init_fail srtp_err_status_init_fail
+#define err_status_terminus srtp_err_status_terminus
+#define err_status_auth_fail srtp_err_status_auth_fail
+#define err_status_cipher_fail srtp_err_status_cipher_fail
+#define err_status_replay_fail srtp_err_status_replay_fail
+#define err_status_replay_old srtp_err_status_replay_old
+#define err_status_algo_fail srtp_err_status_algo_fail
+#define err_status_no_such_op srtp_err_status_no_such_op
+#define err_status_no_ctx srtp_err_status_no_ctx
+#define err_status_cant_check srtp_err_status_cant_check
+#define err_status_key_expired srtp_err_status_key_expired
+
+#endif /* AST_SRTP_COMPAT_H */
diff -urpN asterisk-13.9.1/res/stasis/app.c asterisk-13.17.0/res/stasis/app.c
--- asterisk-13.9.1/res/stasis/app.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/stasis/app.c	2017-07-12 13:12:08.000000000 +0200
@@ -32,6 +32,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "messaging.h"
 
 #include "asterisk/callerid.h"
+#include "asterisk/cli.h"
 #include "asterisk/stasis_app.h"
 #include "asterisk/stasis_bridges.h"
 #include "asterisk/stasis_channels.h"
@@ -42,6 +43,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #define CHANNEL_ALL "__AST_CHANNEL_ALL_TOPIC"
 #define ENDPOINT_ALL "__AST_ENDPOINT_ALL_TOPIC"
 
+/*! Global debug flag.  No need for locking */
+int global_debug;
+
 static int unsubscribe(struct stasis_app *app, const char *kind, const char *id, int terminate);
 
 struct stasis_app {
@@ -61,6 +65,8 @@ struct stasis_app {
 	void *data;
 	/*! Subscription model for the application */
 	enum stasis_app_subscription_model subscription_model;
+	/*! Whether or not someone wants to see debug messages about this app */
+	int debug;
 	/*! Name of the Stasis application */
 	char name[];
 };
@@ -456,7 +462,7 @@ static struct ast_json *channel_dialplan
 		"type", "ChannelDialplan",
 		"timestamp", ast_json_timeval(*tv, NULL),
 		"dialplan_app", new_snapshot->appl,
-		"dialplan_app_data", new_snapshot->data,
+		"dialplan_app_data", AST_JSON_UTF8_VALIDATE(new_snapshot->data),
 		"channel", json_channel);
 }
 
@@ -698,6 +704,13 @@ static void sub_bridge_update_handler(vo
 		json = simple_bridge_event("BridgeDestroyed", old_snapshot, tv);
 	} else if (!old_snapshot) {
 		json = simple_bridge_event("BridgeCreated", new_snapshot, tv);
+	} else if (new_snapshot && old_snapshot
+		&& strcmp(new_snapshot->video_source_id, old_snapshot->video_source_id)) {
+		json = simple_bridge_event("BridgeVideoSourceChanged", new_snapshot, tv);
+		if (json && !ast_strlen_zero(old_snapshot->video_source_id)) {
+			ast_json_object_set(json, "old_video_source_id",
+				ast_json_string_create(old_snapshot->video_source_id));
+		}
 	}
 
 	if (json) {
@@ -833,6 +846,67 @@ static void bridge_default_handler(void
 	}
 }
 
+void stasis_app_set_debug(struct stasis_app *app, int debug)
+{
+	if (!app) {
+		return;
+	}
+
+	app->debug = debug;
+}
+
+void stasis_app_set_debug_by_name(const char *app_name, int debug)
+{
+	struct stasis_app *app = stasis_app_get_by_name(app_name);
+
+	if (!app) {
+		return;
+	}
+
+	app->debug = debug;
+	ao2_cleanup(app);
+}
+
+int stasis_app_get_debug(struct stasis_app *app)
+{
+	return (app ? app->debug : 0) || global_debug;
+}
+
+int stasis_app_get_debug_by_name(const char *app_name)
+{
+	RAII_VAR(struct stasis_app *, app, stasis_app_get_by_name(app_name), ao2_cleanup);
+
+	return (app ? app->debug : 0) || global_debug;
+}
+
+void stasis_app_set_global_debug(int debug)
+{
+	global_debug = debug;
+	if (!global_debug) {
+		struct ao2_container *app_names = stasis_app_get_all();
+		struct ao2_iterator it_app_names;
+		char *app_name;
+		struct stasis_app *app;
+
+		if (!app_names || !ao2_container_count(app_names)) {
+			ao2_cleanup(app_names);
+			return;
+		}
+
+		it_app_names = ao2_iterator_init(app_names, 0);
+		while ((app_name = ao2_iterator_next(&it_app_names))) {
+			if ((app = stasis_app_get_by_name(app_name))) {
+				stasis_app_set_debug(app, 0);
+			}
+
+			ao2_cleanup(app_name);
+			ao2_cleanup(app);
+		}
+		ao2_iterator_cleanup(&it_app_names);
+		ao2_cleanup(app_names);
+	}
+}
+
 struct stasis_app *app_create(const char *name, stasis_app_cb handler, void *data, enum stasis_app_subscription_model subscription_model)
 {
 	RAII_VAR(struct stasis_app *, app, NULL, ao2_cleanup);
@@ -930,8 +1004,15 @@ struct stasis_topic *ast_app_get_topic(s
 void app_send(struct stasis_app *app, struct ast_json *message)
 {
 	stasis_app_cb handler;
+	char eid[20];
 	RAII_VAR(void *, data, NULL, ao2_cleanup);
 
+	if (ast_json_object_set(message, "asterisk_id", ast_json_string_create(
+			ast_eid_to_str(eid, sizeof(eid), &ast_eid_default)))) {
+		ast_log(AST_LOG_WARNING, "Failed to append EID to outgoing event %s\n",
+			ast_json_string_get(ast_json_object_get(message, "type")));
+	}
+
 	/* Copy off mutable state with lock held */
 	{
 		SCOPED_AO2LOCK(lock, app);
@@ -1015,11 +1096,78 @@ void app_update(struct stasis_app *app,
 	app->data = data;
 }
 
-const char *app_name(const struct stasis_app *app)
+const char *stasis_app_name(const struct stasis_app *app)
 {
 	return app->name;
 }
 
+static int forwards_filter_by_type(void *obj, void *arg, int flags)
+{
+	struct app_forwards *forward = obj;
+	enum forward_type *forward_type = arg;
+
+	if (forward->forward_type == *forward_type) {
+		return CMP_MATCH;
+	}
+
+	return 0;
+}
+
+void stasis_app_to_cli(const struct stasis_app *app, struct ast_cli_args *a)
+{
+	struct ao2_iterator *channels;
+	struct ao2_iterator *endpoints;
+	struct ao2_iterator *bridges;
+	struct app_forwards *forward;
+	enum forward_type forward_type;
+
+	ast_cli(a->fd, "Name: %s\n"
+		"  Debug: %s\n"
+		"  Subscription Model: %s\n",
+		app->name,
+		app->debug ? "Yes" : "No",
+		app->subscription_model == STASIS_APP_SUBSCRIBE_ALL ?
+			"Global Resource Subscription" :
+			"Application/Explicit Resource Subscription");
+	ast_cli(a->fd, "  Subscriptions: %d\n", ao2_container_count(app->forwards));
+
+	ast_cli(a->fd, "    Channels:\n");
+	forward_type = FORWARD_CHANNEL;
+	channels = ao2_callback(app->forwards, OBJ_MULTIPLE,
+		forwards_filter_by_type, &forward_type);
+	if (channels) {
+		while ((forward = ao2_iterator_next(channels))) {
+			ast_cli(a->fd, "      %s (%d)\n", forward->id, forward->interested);
+			ao2_ref(forward, -1);
+		}
+		ao2_iterator_destroy(channels);
+	}
+
+	ast_cli(a->fd, "    Bridges:\n");
+	forward_type = FORWARD_BRIDGE;
+	bridges = ao2_callback(app->forwards, OBJ_MULTIPLE,
+		forwards_filter_by_type, &forward_type);
+	if (bridges) {
+		while ((forward = ao2_iterator_next(bridges))) {
+			ast_cli(a->fd, "      %s (%d)\n", forward->id, forward->interested);
+			ao2_ref(forward, -1);
+		}
+		ao2_iterator_destroy(bridges);
+	}
+
+	ast_cli(a->fd, "    Endpoints:\n");
+	forward_type = FORWARD_ENDPOINT;
+	endpoints = ao2_callback(app->forwards, OBJ_MULTIPLE,
+		forwards_filter_by_type, &forward_type);
+	if (endpoints) {
+		while ((forward = ao2_iterator_next(endpoints))) {
+			ast_cli(a->fd, "      %s (%d)\n", forward->id, forward->interested);
+			ao2_ref(forward, -1);
+		}
+		ao2_iterator_destroy(endpoints);
+	}
+}
+
 struct ast_json *app_to_json(const struct stasis_app *app)
 {
 	RAII_VAR(struct ast_json *, json, NULL, ast_json_unref);
diff -urpN asterisk-13.9.1/res/stasis/app.h asterisk-13.17.0/res/stasis/app.h
--- asterisk-13.9.1/res/stasis/app.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/stasis/app.h	2017-07-12 13:12:08.000000000 +0200
@@ -109,15 +109,6 @@ int app_is_finished(struct stasis_app *a
 void app_update(struct stasis_app *app, stasis_app_cb handler, void *data);
 
 /*!
- * \brief Return an application's name.
- *
- * \param app Application.
- * \return Name of the application.
- * \return \c NULL is \a app is \c NULL.
- */
-const char *app_name(const struct stasis_app *app);
-
-/*!
  * \brief Send a message to an application.
  *
  * \param app Application.
@@ -127,6 +118,14 @@ void app_send(struct stasis_app *app, st
 
 struct app_forwards;
 
+/*!
+ * \brief Create a JSON representation of a \c stasis_app
+ *
+ * \param app The application
+ *
+ * \return \c JSON blob on success
+ * \return \c NULL on error
+ */
 struct ast_json *app_to_json(const struct stasis_app *app);
 
 /*!
diff -urpN asterisk-13.9.1/res/stasis/stasis_bridge.c asterisk-13.17.0/res/stasis/stasis_bridge.c
--- asterisk-13.9.1/res/stasis/stasis_bridge.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/stasis/stasis_bridge.c	2017-07-12 13:12:08.000000000 +0200
@@ -157,13 +157,13 @@ static int bridge_stasis_push_peek(struc
 	}
 	to_be_replaced = ast_channel_snapshot_get_latest(ast_channel_uniqueid(swap->chan));
 
-	ast_debug(3, "Copying stasis app name %s from %s to %s\n", app_name(control_app(swap_control)),
+	ast_debug(3, "Copying stasis app name %s from %s to %s\n", stasis_app_name(control_app(swap_control)),
 		ast_channel_name(swap->chan), ast_channel_name(bridge_channel->chan));
 
 	ast_channel_lock(bridge_channel->chan);
 
 	/* copy the app name from the swap channel */
-	app_set_replace_channel_app(bridge_channel->chan, app_name(control_app(swap_control)));
+	app_set_replace_channel_app(bridge_channel->chan, stasis_app_name(control_app(swap_control)));
 
 	/* set the replace channel snapshot */
 	app_set_replace_channel_snapshot(bridge_channel->chan, to_be_replaced);
@@ -217,6 +217,7 @@ static int bridge_stasis_push(struct ast
 		 */
 		return -1;
 	}
+	ao2_cleanup(control);
 
 	/*
 	 * If going into a holding bridge, default the role to participant, if
@@ -236,7 +237,6 @@ static int bridge_stasis_push(struct ast
 		}
 	}
 
-	ao2_cleanup(control);
 	if (self->allowed_capabilities & STASIS_BRIDGE_MIXING_CAPABILITIES) {
 		ast_bridge_channel_update_linkedids(bridge_channel, swap);
 		if (ast_test_flag(&self->feature_flags, AST_BRIDGE_FLAG_SMART)) {
diff -urpN asterisk-13.9.1/res/stasis_recording/stored.c asterisk-13.17.0/res/stasis_recording/stored.c
--- asterisk-13.9.1/res/stasis_recording/stored.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/res/stasis_recording/stored.c	2017-07-12 13:12:08.000000000 +0200
@@ -31,7 +31,6 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/paths.h"
 #include "asterisk/stasis_app_recording.h"
 
-#include <dirent.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -122,12 +121,47 @@ static int split_path(const char *path,
 	return 0;
 }
 
-static void safe_closedir(DIR *dirp)
+struct match_recording_data {
+	const char *file;
+	char *file_with_ext;
+};
+
+static int is_recording(const char *filename)
 {
-	if (!dirp) {
-		return;
+	const char *ext = strrchr(filename, '.');
+
+	if (!ext) {
+		/* No file extension; not us */
+		return 0;
 	}
-	closedir(dirp);
+	++ext;
+
+	if (!ast_get_format_for_file_ext(ext)) {
+		ast_debug(5, "Recording %s: unrecognized format %s\n",
+			filename, ext);
+		/* Keep looking */
+		return 0;
+	}
+
+	/* Return the index to the .ext */
+	return ext - filename - 1;
+}
+
+static int handle_find_recording(const char *dir_name, const char *filename, void *obj)
+{
+	struct match_recording_data *data = obj;
+	int num;
+
+	/* If not a recording or the names do not match the keep searching */
+	if (!(num = is_recording(filename)) || strncmp(data->file, filename, num)) {
+		return 0;
+	}
+
+	if (ast_asprintf(&data->file_with_ext, "%s/%s", dir_name, filename) < 0) {
+		return -1;
+	}
+
+	return 1;
 }
 
 /*!
@@ -143,46 +177,15 @@ static void safe_closedir(DIR *dirp)
  */
 static char *find_recording(const char *dir_name, const char *file)
 {
-	RAII_VAR(DIR *, dir, NULL, safe_closedir);
-	struct dirent entry;
-	struct dirent *result = NULL;
-	char *ext = NULL;
-	char *file_with_ext = NULL;
-
-	dir = opendir(dir_name);
-	if (!dir) {
-		return NULL;
-	}
-
-	while (readdir_r(dir, &entry, &result) == 0 && result != NULL) {
-		ext = strrchr(result->d_name, '.');
-
-		if (!ext) {
-			/* No file extension; not us */
-			continue;
-		}
-		*ext++ = '\0';
-
-		if (strcmp(file, result->d_name) == 0) {
-			if (!ast_get_format_for_file_ext(ext)) {
-				ast_log(LOG_WARNING,
-					"Recording %s: unrecognized format %s\n",
-					result->d_name,
-					ext);
-				/* Keep looking */
-				continue;
-			}
-			/* We have a winner! */
-			break;
-		}
-	}
+	struct match_recording_data data = {
+		.file = file,
+		.file_with_ext = NULL
+	};
 
-	if (!result) {
-		return NULL;
-	}
+	ast_file_read_dir(dir_name, handle_find_recording, &data);
 
-	ast_asprintf(&file_with_ext, "%s/%s.%s", dir_name, file, ext);
-	return file_with_ext;
+	/* Note, string potentially allocated in handle_file_recording */
+	return data.file_with_ext;
 }
 
 /*!
@@ -238,43 +241,33 @@ static int recording_sort(const void *ob
 	return cmp;
 }
 
-static int scan(struct ao2_container *recordings,
-	const char *base_dir, const char *subdir, struct dirent *entry);
-
-static int scan_file(struct ao2_container *recordings,
-	const char *base_dir, const char *subdir, const char *filename,
-	const char *path)
+static int handle_scan_file(const char *dir_name, const char *filename, void *obj)
 {
-	RAII_VAR(struct stasis_app_stored_recording *, recording, NULL,
-		ao2_cleanup);
-	const char *ext;
-	char *dot;
+	struct ao2_container *recordings = obj;
+	struct stasis_app_stored_recording *recording;
+	char *dot, *filepath;
 
-	ext = strrchr(filename, '.');
-
-	if (!ext) {
-		ast_verb(4, "  Ignore file without extension: %s\n",
-			filename);
-		/* No file extension; not us */
+	/* Skip if it is not a recording */
+	if (!is_recording(filename)) {
 		return 0;
 	}
-	++ext;
 
-	if (!ast_get_format_for_file_ext(ext)) {
-		ast_verb(4, "  Not a media file: %s\n", filename);
-		/* Not a media file */
-		return 0;
+	if (ast_asprintf(&filepath, "%s/%s", dir_name, filename) < 0) {
+		return -1;
 	}
 
 	recording = recording_alloc();
 	if (!recording) {
+		ast_free(filepath);
 		return -1;
 	}
 
-	ast_string_field_set(recording, file_with_ext, path);
-
+	ast_string_field_set(recording, file_with_ext, filepath);
 	/* Build file and format from full path */
-	ast_string_field_set(recording, file, path);
+	ast_string_field_set(recording, file, filepath);
+
+	ast_free(filepath);
+
 	dot = strrchr(recording->file, '.');
 	*dot = '\0';
 	recording->format = dot + 1;
@@ -285,92 +278,14 @@ static int scan_file(struct ao2_containe
 
 	/* Add it to the recordings container */
 	ao2_link(recordings, recording);
-
-	return 0;
-}
-
-static int scan_dir(struct ao2_container *recordings,
-	const char *base_dir, const char *subdir, const char *dirname,
-	const char *path)
-{
-	RAII_VAR(DIR *, dir, NULL, safe_closedir);
-	RAII_VAR(struct ast_str *, rel_dirname, NULL, ast_free);
-	struct dirent entry;
-	struct dirent *result = NULL;
-
-	if (strcmp(dirname, ".") == 0 ||
-		strcmp(dirname, "..") == 0) {
-		ast_verb(4, "  Ignoring self/parent dir\n");
-		return 0;
-	}
-
-	/* Build relative dirname */
-	rel_dirname = ast_str_create(80);
-	if (!rel_dirname) {
-		return -1;
-	}
-	if (!ast_strlen_zero(subdir)) {
-		ast_str_append(&rel_dirname, 0, "%s/", subdir);
-	}
-	if (!ast_strlen_zero(dirname)) {
-		ast_str_append(&rel_dirname, 0, "%s", dirname);
-	}
-
-	/* Read the directory */
-	dir = opendir(path);
-	if (!dir) {
-		ast_log(LOG_WARNING, "Error reading dir '%s'\n", path);
-		return -1;
-	}
-	while (readdir_r(dir, &entry, &result) == 0 && result != NULL) {
-		scan(recordings, base_dir, ast_str_buffer(rel_dirname), result);
-	}
-
-	return 0;
-}
-
-static int scan(struct ao2_container *recordings,
-	const char *base_dir, const char *subdir, struct dirent *entry)
-{
-	RAII_VAR(struct ast_str *, path, NULL, ast_free);
-
-	path = ast_str_create(255);
-	if (!path) {
-		return -1;
-	}
-
-	/* Build file path */
-	ast_str_append(&path, 0, "%s", base_dir);
-	if (!ast_strlen_zero(subdir)) {
-		ast_str_append(&path, 0, "/%s", subdir);
-	}
-	if (entry) {
-		ast_str_append(&path, 0, "/%s", entry->d_name);
-	}
-	ast_verb(4, "Scanning '%s'\n", ast_str_buffer(path));
-
-	/* Handle this file */
-	switch (entry->d_type) {
-	case DT_REG:
-		scan_file(recordings, base_dir, subdir, entry->d_name,
-			ast_str_buffer(path));
-		break;
-	case DT_DIR:
-		scan_dir(recordings, base_dir, subdir, entry->d_name,
-			ast_str_buffer(path));
-		break;
-	default:
-		ast_log(LOG_WARNING, "Skipping %s: not a regular file\n",
-			ast_str_buffer(path));
-		break;
-	}
+	ao2_ref(recording, -1);
 
 	return 0;
 }
 
 struct ao2_container *stasis_app_stored_recording_find_all(void)
 {
-	RAII_VAR(struct ao2_container *, recordings, NULL, ao2_cleanup);
+	struct ao2_container *recordings;
 	int res;
 
 	recordings = ao2_container_alloc_rbtree(AO2_ALLOC_OPT_LOCK_NOLOCK,
@@ -379,13 +294,13 @@ struct ao2_container *stasis_app_stored_
 		return NULL;
 	}
 
-	res = scan_dir(recordings, ast_config_AST_RECORDING_DIR, "", "",
-		ast_config_AST_RECORDING_DIR);
-	if (res != 0) {
+	res = ast_file_read_dirs(ast_config_AST_RECORDING_DIR,
+				 handle_scan_file, recordings, -1);
+	if (res) {
+		ao2_ref(recordings, -1);
 		return NULL;
 	}
 
-	ao2_ref(recordings, +1);
 	return recordings;
 }
 
diff -urpN asterisk-13.9.1/rest-api/api-docs/applications.json asterisk-13.17.0/rest-api/api-docs/applications.json
--- asterisk-13.9.1/rest-api/api-docs/applications.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/applications.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/applications.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/asterisk.json asterisk-13.17.0/rest-api/api-docs/asterisk.json
--- asterisk-13.9.1/rest-api/api-docs/asterisk.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/asterisk.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/asterisk.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/bridges.json asterisk-13.17.0/rest-api/api-docs/bridges.json
--- asterisk-13.9.1/rest-api/api-docs/bridges.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/bridges.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/bridges.{format}",
@@ -241,6 +241,78 @@
 			]
 		},
 		{
+			"path": "/bridges/{bridgeId}/videoSource/{channelId}",
+			"description": "Set a channel as the video source in a multi-party bridge",
+			"operations": [
+				{
+					"httpMethod": "POST",
+					"summary": "Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.",
+					"nickname": "setVideoSource",
+					"responseClass": "void",
+					"parameters": [
+						{
+							"name": "bridgeId",
+							"description": "Bridge's id",
+							"paramType": "path",
+							"required": true,
+							"allowMultiple": false,
+							"dataType": "string"
+						},
+						{
+							"name": "channelId",
+							"description": "Channel's id",
+							"paramType": "path",
+							"required": true,
+							"allowMultiple": false,
+							"dataType": "string"
+						}
+					],
+					"errorResponses": [
+						{
+							"code": 404,
+							"reason": "Bridge or Channel not found"
+						},
+						{
+							"code": 409,
+							"reason": "Channel not in Stasis application"
+						},
+						{
+							"code": 422,
+							"reason": "Channel not in this Bridge"
+						}
+					]
+				}
+			]
+		},
+		{
+			"path": "/bridges/{bridgeId}/videoSource",
+			"description": "Removes any explicit video source",
+			"operations": [
+				{
+					"httpMethod": "DELETE",
+					"summary": "Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.",
+					"nickname": "clearVideoSource",
+					"responseClass": "void",
+					"parameters": [
+						{
+							"name": "bridgeId",
+							"description": "Bridge's id",
+							"paramType": "path",
+							"required": true,
+							"allowMultiple": false,
+							"dataType": "string"
+						}
+					],
+					"errorResponses": [
+						{
+							"code": 404,
+							"reason": "Bridge not found"
+						}
+					]
+				}
+			]
+		},
+		{
 			"path": "/bridges/{bridgeId}/moh",
 			"description": "Play music on hold to a bridge",
 			"operations": [
@@ -649,6 +721,16 @@
 					"type": "List[string]",
 					"description": "Ids of channels participating in this bridge",
 					"required": true
+				},
+				"video_mode": {
+					"type": "string",
+					"description": "The video mode the bridge is using. One of 'none', 'talker', or 'single'.",
+					"required": false
+				},
+				"video_source_id": {
+					"type": "string",
+					"description": "The ID of the channel that is the source of video in this bridge, if one exists.",
+					"required": false
 				}
 			}
 		}
diff -urpN asterisk-13.9.1/rest-api/api-docs/channels.json asterisk-13.17.0/rest-api/api-docs/channels.json
--- asterisk-13.9.1/rest-api/api-docs/channels.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/channels.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/channels.{format}",
@@ -128,12 +128,24 @@
 							"required": false,
 							"allowMultiple": false,
 							"dataType": "string"
+						},
+						{
+							"name": "formats",
+							"description": "The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".",
+							"paramType": "query",
+							"required": false,
+							"allowMultiple": false,
+							"dataType": "string"
 						}
 					],
 					"errorResponses": [
 						{
 							"code": 400,
 							"reason": "Invalid parameters for originating a channel."
+						},
+						{
+							"code": 409,
+							"reason": "Channel with given unique ID already exists."
 						}
 					]
 				}
@@ -276,15 +288,26 @@
 							"required": false,
 							"allowMultiple": false,
 							"dataType": "string"
+						},
+						{
+							"name": "formats",
+							"description": "The format name capability list to use if originator is not specified. Ex. \"ulaw,slin16\".  Format names can be found with \"core show codecs\".",
+							"paramType": "query",
+							"required": false,
+							"allowMultiple": false,
+							"dataType": "string"
 						}
 					],
 					"errorResponses": [
 						{
 							"code": 400,
 							"reason": "Invalid parameters for originating a channel."
+						},
+						{
+							"code": 409,
+							"reason": "Channel with given unique ID already exists."
 						}
 					]
-
 				},
 				{
 					"httpMethod": "DELETE",
diff -urpN asterisk-13.9.1/rest-api/api-docs/deviceStates.json asterisk-13.17.0/rest-api/api-docs/deviceStates.json
--- asterisk-13.9.1/rest-api/api-docs/deviceStates.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/deviceStates.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "Kevin Harwell <kharwell@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/deviceStates.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/endpoints.json asterisk-13.17.0/rest-api/api-docs/endpoints.json
--- asterisk-13.9.1/rest-api/api-docs/endpoints.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/endpoints.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/endpoints.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/events.json asterisk-13.17.0/rest-api/api-docs/events.json
--- asterisk-13.9.1/rest-api/api-docs/events.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/events.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.2",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/events.{format}",
@@ -110,6 +110,11 @@
 					"type": "string",
 					"required": true,
 					"description": "Indicates the type of this message."
+				},
+				"asterisk_id": {
+					"type": "string",
+					"required": false,
+					"description": "The unique ID for the Asterisk instance that raised this event."
 				}
 			},
 			"subTypes": [
@@ -156,6 +161,7 @@
 				"BridgeMerged",
 				"BridgeBlindTransfer",
 				"BridgeAttendedTransfer",
+				"BridgeVideoSourceChanged",
 				"ChannelCreated",
 				"ChannelDestroyed",
 				"ChannelEnteredBridge",
@@ -353,6 +359,20 @@
 				}
 			}
 		},
+		"BridgeVideoSourceChanged": {
+			"id": "BridgeVideoSourceChanged",
+			"description": "Notification that the source of video in a bridge has changed.",
+			"properties": {
+				"bridge": {
+					"required": true,
+					"type": "Bridge"
+				},
+				"old_video_source_id": {
+					"required": false,
+					"type": "string"
+				}
+			}
+		},
 		"BridgeBlindTransfer": {
 			"id": "BridgeBlindTransfer",
 			"description": "Notification that a blind transfer has occurred.",
diff -urpN asterisk-13.9.1/rest-api/api-docs/mailboxes.json asterisk-13.17.0/rest-api/api-docs/mailboxes.json
--- asterisk-13.9.1/rest-api/api-docs/mailboxes.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/mailboxes.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2013, Digium, Inc.",
 	"_author": "Jonathan Rose <jrose@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/mailboxes.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/playbacks.json asterisk-13.17.0/rest-api/api-docs/playbacks.json
--- asterisk-13.9.1/rest-api/api-docs/playbacks.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/playbacks.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/playbacks.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/recordings.json asterisk-13.17.0/rest-api/api-docs/recordings.json
--- asterisk-13.9.1/rest-api/api-docs/recordings.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/recordings.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/recordings.{format}",
diff -urpN asterisk-13.9.1/rest-api/api-docs/sounds.json asterisk-13.17.0/rest-api/api-docs/sounds.json
--- asterisk-13.9.1/rest-api/api-docs/sounds.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/api-docs/sounds.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"resourcePath": "/api-docs/sounds.{format}",
diff -urpN asterisk-13.9.1/rest-api/resources.json asterisk-13.17.0/rest-api/resources.json
--- asterisk-13.9.1/rest-api/resources.json	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api/resources.json	2017-07-12 13:12:08.000000000 +0200
@@ -2,7 +2,7 @@
 	"_copyright": "Copyright (C) 2012 - 2013, Digium, Inc.",
 	"_author": "David M. Lee, II <dlee@digium.com>",
 	"_svn_revision": "$Revision$",
-	"apiVersion": "1.9.0",
+	"apiVersion": "1.10.0",
 	"swaggerVersion": "1.1",
 	"basePath": "http://localhost:8088/ari",
 	"apis": [
diff -urpN asterisk-13.9.1/rest-api-templates/api.wiki.mustache asterisk-13.17.0/rest-api-templates/api.wiki.mustache
--- asterisk-13.9.1/rest-api-templates/api.wiki.mustache	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api-templates/api.wiki.mustache	2017-07-12 13:12:08.000000000 +0200
@@ -1,7 +1,8 @@
 {{#api_declaration}}
 h1. {{name_title}}
 
-|| Method || Path || Return Model || Summary ||
+|| Method || Path<br>h5. Parameters are case-sensitive || Return Model || Summary ||
+
 {{#apis}}
 {{#operations}}
 | {{http_method}} | [{{wiki_path}}|#{{nickname}}] | {{#response_class}}{{#is_primitive}}{{name}}{{/is_primitive}}{{^is_primitive}}[{{wiki_name}}|{{wiki_prefix}} REST Data Models#{{singular_name}}]{{/is_primitive}}{{/response_class}} | {{summary}} |
@@ -17,6 +18,7 @@ h2. {{nickname}}: {{http_method}} {{wiki
 {{#has_path_parameters}}
 
 h3. Path parameters
+Parameters are case-sensitive.
 {{#path_parameters}}
 * {{name}}: _{{data_type}}_ - {{{wiki_description}}}
 {{#default_value}}
diff -urpN asterisk-13.9.1/rest-api-templates/param_parsing.mustache asterisk-13.17.0/rest-api-templates/param_parsing.mustache
--- asterisk-13.9.1/rest-api-templates/param_parsing.mustache	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api-templates/param_parsing.mustache	2017-07-12 13:12:08.000000000 +0200
@@ -85,21 +85,6 @@
 {{/has_path_parameters}}
 {{^is_websocket}}
 {{#parse_body}}
-	/* Look for a JSON request entity */
-	body = ast_http_get_json(ser, headers);
-	if (!body) {
-		switch (errno) {
-		case EFBIG:
-			ast_ari_response_error(response, 413, "Request Entity Too Large", "Request body too large");
-			goto fin;
-		case ENOMEM:
-			ast_ari_response_error(response, 500, "Internal Server Error", "Error processing request");
-			goto fin;
-		case EIO:
-			ast_ari_response_error(response, 400, "Bad Request", "Error parsing request body");
-			goto fin;
-		}
-	}
 {{#body_parameter}}
 	args.{{c_name}} = body;
 {{/body_parameter}}
diff -urpN asterisk-13.9.1/rest-api-templates/res_ari_resource.c.mustache asterisk-13.17.0/rest-api-templates/res_ari_resource.c.mustache
--- asterisk-13.9.1/rest-api-templates/res_ari_resource.c.mustache	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api-templates/res_ari_resource.c.mustache	2017-07-12 13:12:08.000000000 +0200
@@ -78,13 +78,12 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 static void ast_ari_{{c_name}}_{{c_nickname}}_cb(
 	struct ast_tcptls_session_instance *ser,
 	struct ast_variable *get_params, struct ast_variable *path_vars,
-	struct ast_variable *headers, struct ast_ari_response *response)
+	struct ast_variable *headers, struct ast_json *body, struct ast_ari_response *response)
 {
 	struct ast_ari_{{c_name}}_{{c_nickname}}_args args = {};
 {{#has_parameters}}
 	struct ast_variable *i;
 {{/has_parameters}}
-	RAII_VAR(struct ast_json *, body, NULL, ast_json_unref);
 #if defined(AST_DEVMODE)
 	int is_valid;
 	int code;
@@ -247,49 +246,61 @@ fin: __attribute__((unused))
 {{> rest_handler}}
 {{/root_path}}
 
+static int unload_module(void)
+{
+	ast_ari_remove_handler(&{{root_full_name}});
+{{#apis}}
+{{#has_websocket}}
+	ao2_cleanup({{full_name}}.ws_server);
+	{{full_name}}.ws_server = NULL;
+{{/has_websocket}}
+{{/apis}}
+	stasis_app_unref();
+	return 0;
+}
+
 static int load_module(void)
 {
 	int res = 0;
+
+	CHECK_ARI_MODULE_LOADED();
+
 {{#apis}}
 {{#operations}}
 {{#has_websocket}}
-	struct ast_websocket_protocol *protocol;
-
-	{{full_name}}.ws_server = ast_websocket_server_create();
-	if (!{{full_name}}.ws_server) {
-		return AST_MODULE_LOAD_FAILURE;
-	}
+	/* This is scoped to not conflict with CHECK_ARI_MODULE_LOADED */
+	{
+		struct ast_websocket_protocol *protocol;
+
+		{{full_name}}.ws_server = ast_websocket_server_create();
+		if (!{{full_name}}.ws_server) {
+			return AST_MODULE_LOAD_DECLINE;
+		}
 
-	protocol = ast_websocket_sub_protocol_alloc("{{websocket_protocol}}");
-	if (!protocol) {
-		ao2_ref({{full_name}}.ws_server, -1);
-		{{full_name}}.ws_server = NULL;
-		return AST_MODULE_LOAD_FAILURE;
-	}
-	protocol->session_attempted = ast_ari_{{c_name}}_{{c_nickname}}_ws_attempted_cb;
-	protocol->session_established = ast_ari_{{c_name}}_{{c_nickname}}_ws_established_cb;
+		protocol = ast_websocket_sub_protocol_alloc("{{websocket_protocol}}");
+		if (!protocol) {
+			ao2_ref({{full_name}}.ws_server, -1);
+			{{full_name}}.ws_server = NULL;
+			return AST_MODULE_LOAD_DECLINE;
+		}
+		protocol->session_attempted = ast_ari_{{c_name}}_{{c_nickname}}_ws_attempted_cb;
+		protocol->session_established = ast_ari_{{c_name}}_{{c_nickname}}_ws_established_cb;
 {{/has_websocket}}
 {{#is_websocket}}
-	res |= ast_websocket_server_add_protocol2({{full_name}}.ws_server, protocol);
+		res |= ast_websocket_server_add_protocol2({{full_name}}.ws_server, protocol);
+	}
 {{/is_websocket}}
 {{/operations}}
 {{/apis}}
+
 	stasis_app_ref();
 	res |= ast_ari_add_handler(&{{root_full_name}});
-	return res;
-}
+	if (res) {
+		unload_module();
+		return AST_MODULE_LOAD_DECLINE;
+	}
 
-static int unload_module(void)
-{
-	ast_ari_remove_handler(&{{root_full_name}});
-{{#apis}}
-{{#has_websocket}}
-	ao2_cleanup({{full_name}}.ws_server);
-	{{full_name}}.ws_server = NULL;
-{{/has_websocket}}
-{{/apis}}
-	stasis_app_unref();
-	return 0;
+	return AST_MODULE_LOAD_SUCCESS;
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "RESTful API module - {{{description}}}",
diff -urpN asterisk-13.9.1/rest-api-templates/swagger_model.py asterisk-13.17.0/rest-api-templates/swagger_model.py
--- asterisk-13.9.1/rest-api-templates/swagger_model.py	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/rest-api-templates/swagger_model.py	2017-07-12 13:12:08.000000000 +0200
@@ -688,7 +688,7 @@ class ResourceApi(Stringify):
     def load(self, api_json, processor, context):
         context = context.next_stack(api_json, 'path')
         validate_required_fields(api_json, self.required_fields, context)
-        self.path = api_json['path']
+        self.path = api_json['path'].replace('{format}', 'json')
         self.description = api_json['description']
 
         if not self.path or self.path[0] != '/':
@@ -697,7 +697,7 @@ class ResourceApi(Stringify):
         return self
 
     def load_api_declaration(self, base_dir, processor):
-        self.file = (base_dir + self.path).replace('{format}', 'json')
+        self.file = (base_dir + self.path)
         self.api_declaration = ApiDeclaration().load_file(self.file, processor)
         processor.process_resource_api(self, [self.file])
 
diff -urpN asterisk-13.9.1/tests/test_ari.c asterisk-13.17.0/tests/test_ari.c
--- asterisk-13.9.1/tests/test_ari.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_ari.c	2017-07-12 13:12:08.000000000 +0200
@@ -62,6 +62,7 @@ static void handler(const char *name,
 		    struct ast_variable *get_params,
 		    struct ast_variable *path_vars,
 		    struct ast_variable *headers,
+		    struct ast_json *body,
 		    struct ast_ari_response *response)
 {
 	struct ast_json *message = ast_json_pack("{s: s, s: {}, s: {}, s: {}}",
@@ -99,9 +100,10 @@ static void handler(const char *name,
 		struct ast_variable *get_params,			\
 		struct ast_variable *path_vars,				\
 		struct ast_variable *headers,				\
+		struct ast_json *body,						\
 		struct ast_ari_response *response)			\
 	{								\
-		handler(#name, response_code, get_params, path_vars, headers, response); \
+		handler(#name, response_code, get_params, path_vars, headers, body, response); \
 	}
 
 HANDLER(bang_get, 200)
@@ -217,7 +219,7 @@ AST_TEST_DEFINE(get_docs)
 
 	response = response_alloc();
 	headers = ast_variable_new("Host", "stasis.asterisk.org", __FILE__);
-	ast_ari_get_docs("resources.json", headers, response);
+	ast_ari_get_docs("resources.json", "", headers, response);
 	ast_test_validate(test, 200 == response->response_code);
 
 	/* basePath should be relative to the Host header */
@@ -247,7 +249,7 @@ AST_TEST_DEFINE(get_docs_nohost)
 	}
 
 	response = response_alloc();
-	ast_ari_get_docs("resources.json", headers, response);
+	ast_ari_get_docs("resources.json",  "", headers, response);
 	ast_test_validate(test, 200 == response->response_code);
 
 	/* basePath should be relative to the Host header */
@@ -274,7 +276,7 @@ AST_TEST_DEFINE(get_docs_notfound)
 	}
 
 	response = response_alloc();
-	ast_ari_get_docs("i-am-not-a-resource.json", headers, response);
+	ast_ari_get_docs("i-am-not-a-resource.json", "", headers, response);
 	ast_test_validate(test, 404 == response->response_code);
 
 	return AST_TEST_PASS;
@@ -297,7 +299,7 @@ AST_TEST_DEFINE(get_docs_hackerz)
 	}
 
 	response = response_alloc();
-	ast_ari_get_docs("../../../../sbin/asterisk", headers, response);
+	ast_ari_get_docs("../../../../sbin/asterisk", "", headers, response);
 	ast_test_validate(test, 404 == response->response_code);
 
 	return AST_TEST_PASS;
@@ -344,7 +346,8 @@ AST_TEST_DEFINE(invoke_get)
 				 "head2", "head-two",
 				 "path_vars");
 
-	ast_ari_invoke(NULL, "foo", AST_HTTP_GET, get_params, headers, response);
+	ast_ari_invoke(NULL, "foo", AST_HTTP_GET, get_params, headers,
+		ast_json_null(), response);
 
 	ast_test_validate(test, 1 == invocation_count);
 	ast_test_validate(test, 200 == response->response_code);
@@ -381,7 +384,8 @@ AST_TEST_DEFINE(invoke_wildcard)
 				 "path_vars",
 				 "bam", "foshizzle");
 
-	ast_ari_invoke(NULL, "foo/foshizzle", AST_HTTP_GET, get_params, headers, response);
+	ast_ari_invoke(NULL, "foo/foshizzle", AST_HTTP_GET, get_params, headers,
+		ast_json_null(), response);
 
 	ast_test_validate(test, 1 == invocation_count);
 	ast_test_validate(test, 200 == response->response_code);
@@ -418,7 +422,8 @@ AST_TEST_DEFINE(invoke_delete)
 				 "path_vars",
 				 "bam", "foshizzle");
 
-	ast_ari_invoke(NULL, "foo/foshizzle/bang", AST_HTTP_DELETE, get_params, headers, response);
+	ast_ari_invoke(NULL, "foo/foshizzle/bang", AST_HTTP_DELETE, get_params, headers,
+		ast_json_null(), response);
 
 	ast_test_validate(test, 1 == invocation_count);
 	ast_test_validate(test, 204 == response->response_code);
@@ -468,7 +473,8 @@ AST_TEST_DEFINE(invoke_post)
 				 "head2", "head-two",
 				 "path_vars");
 
-	ast_ari_invoke(NULL, "foo/bar", AST_HTTP_POST, get_params, headers, response);
+	ast_ari_invoke(NULL, "foo/bar", AST_HTTP_POST, get_params, headers,
+		ast_json_null(), response);
 
 	ast_test_validate(test, 1 == invocation_count);
 	ast_test_validate(test, 200 == response->response_code);
@@ -497,7 +503,8 @@ AST_TEST_DEFINE(invoke_bad_post)
 
 	fixture = setup_invocation_test();
 	response = response_alloc();
-	ast_ari_invoke(NULL, "foo", AST_HTTP_POST, get_params, headers, response);
+	ast_ari_invoke(NULL, "foo", AST_HTTP_POST, get_params, headers,
+		ast_json_null(), response);
 
 	ast_test_validate(test, 0 == invocation_count);
 	ast_test_validate(test, 405 == response->response_code);
@@ -525,7 +532,8 @@ AST_TEST_DEFINE(invoke_not_found)
 
 	fixture = setup_invocation_test();
 	response = response_alloc();
-	ast_ari_invoke(NULL, "foo/fizzle/i-am-not-a-resource", AST_HTTP_GET, get_params, headers, response);
+	ast_ari_invoke(NULL, "foo/fizzle/i-am-not-a-resource", AST_HTTP_GET, get_params, headers,
+		ast_json_null(), response);
 
 	ast_test_validate(test, 0 == invocation_count);
 	ast_test_validate(test, 404 == response->response_code);
diff -urpN asterisk-13.9.1/tests/test_astobj2_thrash.c asterisk-13.17.0/tests/test_astobj2_thrash.c
--- asterisk-13.9.1/tests/test_astobj2_thrash.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_astobj2_thrash.c	2017-07-12 13:12:08.000000000 +0200
@@ -46,6 +46,13 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/utils.h"
 
 #define MAX_HASH_ENTRIES 15000
+/*
+ * Use one of the online calculators to find the first prime number
+ * greater than MAX_HASH_ENTRIES / 100.
+ */
+#define HASH_BUCKETS 151
+
+#define COUNT_SLEEP_US 500
 #define MAX_TEST_SECONDS 60
 
 struct hash_test {
@@ -207,7 +214,7 @@ static void *hash_test_count(void *d)
 
 		if (last_count == count) {
 			/* Allow other threads to run. */
-			sched_yield();
+			usleep(COUNT_SLEEP_US);
 		} else if (last_count > count) {
 			/* Make sure the ao2 container never shrinks */
 			return "ao2 container unexpectedly shrank";
@@ -261,7 +268,7 @@ AST_TEST_DEFINE(hash_test)
 	data.preload = MAX_HASH_ENTRIES / 2;
 	data.max_grow = MAX_HASH_ENTRIES - data.preload;
 	data.deadline = ast_tvadd(ast_tvnow(), ast_tv(MAX_TEST_SECONDS, 0));
-	data.to_be_thrashed = ao2_container_alloc(MAX_HASH_ENTRIES / 100, hash_string,
+	data.to_be_thrashed = ao2_container_alloc(HASH_BUCKETS, hash_string,
 		compare_strings);
 
 	if (data.to_be_thrashed == NULL) {
diff -urpN asterisk-13.9.1/tests/test_bridging.c asterisk-13.17.0/tests/test_bridging.c
--- asterisk-13.9.1/tests/test_bridging.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/tests/test_bridging.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,292 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2017, Digium, Inc.
+ *
+ * Joshua Colp <jcolp@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*!
+ * \file
+ * \brief Bridging unit tests
+ *
+ * \author Joshua Colp <jcolp@digium.com>
+ *
+ */
+
+/*** MODULEINFO
+	<depend>TEST_FRAMEWORK</depend>
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include "asterisk/module.h"
+#include "asterisk/test.h"
+#include "asterisk/channel.h"
+#include "asterisk/time.h"
+#include "asterisk/bridge.h"
+#include "asterisk/bridge_basic.h"
+#include "asterisk/features.h"
+#include "asterisk/format_cache.h"
+
+#define TEST_CATEGORY "/main/bridging/"
+
+#define CHANNEL_TECH_NAME "BridgingTestChannel"
+
+#define TEST_CHANNEL_FORMAT		ast_format_slin
+
+/*! \brief A private structure for the test channel */
+struct test_bridging_chan_pvt {
+	/* \brief The expected indication */
+	int condition;
+	/*! \brief The number of indicated things */
+	unsigned int indicated;
+};
+
+/*! \brief Callback function for when a frame is written to a channel */
+static int test_bridging_chan_indicate(struct ast_channel *chan, int condition, const void *data, size_t datalen)
+{
+	struct test_bridging_chan_pvt *test_pvt = ast_channel_tech_pvt(chan);
+
+	if (condition == test_pvt->condition) {
+		test_pvt->indicated++;
+	}
+
+	return 0;
+}
+
+/*! \brief Callback function for when a channel is hung up */
+static int test_bridging_chan_hangup(struct ast_channel *chan)
+{
+	struct test_bridging_chan_pvt *test_pvt = ast_channel_tech_pvt(chan);
+
+	ast_free(test_pvt);
+	ast_channel_tech_pvt_set(chan, NULL);
+
+	return 0;
+}
+
+/*! \brief A channel technology used for the unit tests */
+static struct ast_channel_tech test_bridging_chan_tech = {
+	.type = CHANNEL_TECH_NAME,
+	.description = "Mock channel technology for bridge tests",
+	.indicate = test_bridging_chan_indicate,
+	.hangup = test_bridging_chan_hangup,
+	.properties = AST_CHAN_TP_INTERNAL,
+};
+
+static void test_nanosleep(int secs, long nanosecs)
+{
+	struct timespec sleep_time = {secs, nanosecs};
+
+	while ((nanosleep(&sleep_time, &sleep_time) == -1) && (errno == EINTR)) {
+	}
+}
+
+/*! \brief Wait until a channel is bridged */
+static void wait_for_bridged(struct ast_channel *channel)
+{
+	ast_channel_lock(channel);
+	while (!ast_channel_is_bridged(channel)) {
+		ast_channel_unlock(channel);
+		test_nanosleep(0, 1000000);
+		ast_channel_lock(channel);
+	}
+	ast_channel_unlock(channel);
+}
+
+/*! \brief Wait until a channel is not bridged */
+static void wait_for_unbridged(struct ast_channel *channel)
+{
+	ast_channel_lock(channel);
+	while (ast_channel_is_bridged(channel)) {
+		ast_channel_unlock(channel);
+		test_nanosleep(0, 1000000);
+		ast_channel_lock(channel);
+	}
+	ast_channel_unlock(channel);
+}
+
+/*! \brief Wait until a channel has no frames on its read queue */
+static void wait_for_empty_queue(struct ast_channel *channel)
+{
+	ast_channel_lock(channel);
+	while (!AST_LIST_EMPTY(ast_channel_readq(channel))) {
+		ast_channel_unlock(channel);
+		test_nanosleep(0, 1000000);
+		ast_channel_lock(channel);
+	}
+	ast_channel_unlock(channel);
+}
+
+/*! \brief Create a \ref test_bridging_chan_tech for Alice. */
+#define START_ALICE(channel, pvt) START_CHANNEL(channel, pvt, "Alice", "100")
+
+/*! \brief Create a \ref test_bridging_chan_tech for Bob. */
+#define START_BOB(channel, pvt) START_CHANNEL(channel, pvt, "Bob", "200")
+
+#define START_CHANNEL(channel, pvt, name, number) do { \
+	channel = ast_channel_alloc(0, AST_STATE_UP, number, name, number, number, \
+		"default", NULL, NULL, 0, CHANNEL_TECH_NAME "/" name); \
+	pvt = ast_calloc(1, sizeof(*pvt)); \
+	ast_channel_tech_pvt_set(channel, pvt); \
+	ast_channel_nativeformats_set(channel, test_bridging_chan_tech.capabilities); \
+	ast_channel_set_rawwriteformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_set_rawreadformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_set_writeformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_set_readformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_unlock(channel); \
+	} while (0)
+
+/*! \brief Hang up a test channel safely */
+#define HANGUP_CHANNEL(channel) do { \
+	ao2_ref(channel, +1); \
+	ast_hangup((channel)); \
+	ao2_cleanup(channel); \
+	channel = NULL; \
+	} while (0)
+
+static void safe_channel_release(struct ast_channel *chan)
+{
+	if (!chan) {
+		return;
+	}
+	ast_channel_release(chan);
+}
+
+static void safe_bridge_destroy(struct ast_bridge *bridge)
+{
+	if (!bridge) {
+		return;
+	}
+	ast_bridge_destroy(bridge, 0);
+}
+
+static void stream_periodic_frames(struct ast_channel *chan, int ms, int interval_ms)
+{
+	long nanosecs;
+
+	ast_assert(chan != NULL);
+	ast_assert(0 < ms);
+	ast_assert(0 < interval_ms);
+
+	nanosecs = interval_ms * 1000000L;
+	while (0 < ms) {
+		ast_queue_frame(chan, &ast_null_frame);
+
+		if (interval_ms < ms) {
+			ms -= interval_ms;
+		} else {
+			nanosecs = ms * 1000000L;
+			ms = 0;
+		}
+		test_nanosleep(0, nanosecs);
+	}
+}
+
+AST_TEST_DEFINE(test_bridging_deferred_queue)
+{
+	RAII_VAR(struct ast_channel *, chan_alice, NULL, safe_channel_release);
+	struct test_bridging_chan_pvt *alice_pvt;
+		struct ast_control_t38_parameters t38_parameters = {
+			.request_response = AST_T38_REQUEST_NEGOTIATE,
+		};
+		struct ast_frame frame = {
+			.frametype = AST_FRAME_CONTROL,
+			.subclass.integer = AST_CONTROL_T38_PARAMETERS,
+			.data.ptr = &t38_parameters,
+			.datalen = sizeof(t38_parameters),
+		};
+	RAII_VAR(struct ast_channel *, chan_bob, NULL, safe_channel_release);
+	struct test_bridging_chan_pvt *bob_pvt;
+	RAII_VAR(struct ast_bridge *, bridge1, NULL, safe_bridge_destroy);
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = __func__;
+		info->category = TEST_CATEGORY;
+		info->summary = "Test that deferred frames from a channel in a bridge get written";
+		info->description =
+			"This test creates two channels, queues a deferrable frame on one, places it into\n"
+			"a bridge, confirms the frame was read by the bridge, adds the second channel to the\n"
+			"bridge, and makes sure the deferred frame is written to it.";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	/* Create the bridges */
+	bridge1 = ast_bridge_basic_new();
+	ast_test_validate(test, bridge1 != NULL);
+
+	/* Create channels that will go into the bridge */
+	START_ALICE(chan_alice, alice_pvt);
+	START_BOB(chan_bob, bob_pvt);
+	bob_pvt->condition = AST_CONTROL_T38_PARAMETERS;
+
+	/* Bridge alice and wait for the frame to be deferred */
+	ast_test_validate(test, !ast_bridge_impart(bridge1, chan_alice, NULL, NULL, AST_BRIDGE_IMPART_CHAN_DEPARTABLE));
+	wait_for_bridged(chan_alice);
+	ast_queue_frame(chan_alice, &frame);
+	wait_for_empty_queue(chan_alice);
+
+	/* Bridge bob for a second so it can receive the deferred T.38 request negotiate frame */
+	ast_test_validate(test, !ast_bridge_impart(bridge1, chan_bob, NULL, NULL, AST_BRIDGE_IMPART_CHAN_DEPARTABLE));
+	wait_for_bridged(chan_bob);
+	stream_periodic_frames(chan_alice, 1000, 20);
+	ast_test_validate(test, !ast_bridge_depart(chan_bob));
+	wait_for_unbridged(chan_bob);
+
+	/* Ensure that we received the expected indications while it was in there (request to negotiate, and to terminate) */
+	ast_test_validate(test, bob_pvt->indicated == 2);
+
+	/* Now remove alice since we are done */
+	ast_test_validate(test, !ast_bridge_depart(chan_alice));
+	wait_for_unbridged(chan_alice);
+
+	/* Hangup the channels */
+	HANGUP_CHANNEL(chan_alice);
+	HANGUP_CHANNEL(chan_bob);
+
+	return AST_TEST_PASS;
+}
+
+static int unload_module(void)
+{
+	AST_TEST_UNREGISTER(test_bridging_deferred_queue);
+
+	ast_channel_unregister(&test_bridging_chan_tech);
+	ao2_cleanup(test_bridging_chan_tech.capabilities);
+	test_bridging_chan_tech.capabilities = NULL;
+
+	return 0;
+}
+
+static int load_module(void)
+{
+	test_bridging_chan_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!test_bridging_chan_tech.capabilities) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+	ast_format_cap_append(test_bridging_chan_tech.capabilities, TEST_CHANNEL_FORMAT, 0);
+	ast_channel_register(&test_bridging_chan_tech);
+
+	AST_TEST_REGISTER(test_bridging_deferred_queue);
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "Bridging Unit Tests");
diff -urpN asterisk-13.9.1/tests/test_bucket.c asterisk-13.17.0/tests/test_bucket.c
--- asterisk-13.9.1/tests/test_bucket.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_bucket.c	2017-07-12 13:12:08.000000000 +0200
@@ -848,7 +848,7 @@ static int load_module(void)
 	if (ast_bucket_scheme_register("test", &bucket_test_wizard, &bucket_file_test_wizard,
 		ast_bucket_file_temporary_create, ast_bucket_file_temporary_destroy)) {
 		ast_log(LOG_ERROR, "Failed to register Bucket test wizard scheme implementation\n");
-		return AST_MODULE_LOAD_FAILURE;
+		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	AST_TEST_REGISTER(bucket_scheme_register);
diff -urpN asterisk-13.9.1/tests/test_cel.c asterisk-13.17.0/tests/test_cel.c
--- asterisk-13.9.1/tests/test_cel.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_cel.c	2017-07-12 13:12:08.000000000 +0200
@@ -1610,7 +1610,7 @@ AST_TEST_DEFINE(test_cel_dial_pickup)
 
 	ast_channel_publish_dial(chan_caller, chan_callee, NULL, "ANSWER");
 
-	HANGUP_CHANNEL(chan_caller, AST_CAUSE_NORMAL, "CANCEL");
+	HANGUP_CHANNEL(chan_caller, AST_CAUSE_NORMAL, "ANSWER");
 	HANGUP_CHANNEL(chan_callee, AST_CAUSE_NORMAL, "");
 
 	return AST_TEST_PASS;
diff -urpN asterisk-13.9.1/tests/test_channel_feature_hooks.c asterisk-13.17.0/tests/test_channel_feature_hooks.c
--- asterisk-13.9.1/tests/test_channel_feature_hooks.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_channel_feature_hooks.c	2017-07-12 13:12:08.000000000 +0200
@@ -40,6 +40,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/bridge.h"
 #include "asterisk/bridge_basic.h"
 #include "asterisk/features.h"
+#include "asterisk/format_cache.h"
 
 #define TEST_CATEGORY "/channels/features/"
 
@@ -47,6 +48,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 #define TEST_BACKEND_NAME "Features Test Logging"
 
+#define TEST_CHANNEL_FORMAT		ast_format_slin
+
 /*! \brief A channel technology used for the unit tests */
 static struct ast_channel_tech test_features_chan_tech = {
 	.type = CHANNEL_TECH_NAME,
@@ -94,6 +97,11 @@ static void wait_for_unbridged(struct as
 #define START_CHANNEL(channel, name, number) do { \
 	channel = ast_channel_alloc(0, AST_STATE_UP, number, name, number, number, \
 		"default", NULL, NULL, 0, CHANNEL_TECH_NAME "/" name); \
+	ast_channel_nativeformats_set(channel, test_features_chan_tech.capabilities); \
+	ast_channel_set_rawwriteformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_set_rawreadformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_set_writeformat(channel, TEST_CHANNEL_FORMAT); \
+	ast_channel_set_readformat(channel, TEST_CHANNEL_FORMAT); \
 	ast_channel_unlock(channel); \
 	} while (0)
 
@@ -329,12 +337,19 @@ static int unload_module(void)
 	AST_TEST_UNREGISTER(test_features_channel_interval);
 
 	ast_channel_unregister(&test_features_chan_tech);
+	ao2_cleanup(test_features_chan_tech.capabilities);
+	test_features_chan_tech.capabilities = NULL;
 
 	return 0;
 }
 
 static int load_module(void)
 {
+	test_features_chan_tech.capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);
+	if (!test_features_chan_tech.capabilities) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+	ast_format_cap_append(test_features_chan_tech.capabilities, TEST_CHANNEL_FORMAT, 0);
 	ast_channel_register(&test_features_chan_tech);
 
 	AST_TEST_REGISTER(test_features_channel_dtmf);
diff -urpN asterisk-13.9.1/tests/test_config.c asterisk-13.17.0/tests/test_config.c
--- asterisk-13.9.1/tests/test_config.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_config.c	2017-07-12 13:12:08.000000000 +0200
@@ -34,6 +34,7 @@
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$");
 
 #include <math.h> /* HUGE_VAL */
+#include <sys/stat.h>
 
 #include "asterisk/config.h"
 #include "asterisk/module.h"
@@ -49,6 +50,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/format_cap.h"
 
 #define CONFIG_FILE "test_config.conf"
+#define CONFIG_INCLUDE_FILE "test_config_include.conf"
 
 /*
  * This builds the folowing config:
@@ -881,6 +883,77 @@ static int hook_cb(struct ast_config *cf
 	return 0;
 }
 
+AST_TEST_DEFINE(config_save)
+{
+	enum ast_test_result_state res = AST_TEST_FAIL;
+	struct ast_flags config_flags = { 0 };
+	struct ast_config *cfg;
+	char config_filename[PATH_MAX];
+	char include_filename[PATH_MAX];
+	struct stat config_stat;
+	off_t before_save;
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = "config_save";
+		info->category = "/main/config/";
+		info->summary = "Test config save";
+		info->description =
+			"Test configuration save.";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	if (write_config_file()) {
+		ast_test_status_update(test, "Could not write initial config files\n");
+		return res;
+	}
+
+	snprintf(config_filename, PATH_MAX, "%s/%s", ast_config_AST_CONFIG_DIR, CONFIG_FILE);
+	snprintf(include_filename, PATH_MAX, "%s/%s", ast_config_AST_CONFIG_DIR, CONFIG_INCLUDE_FILE);
+
+	cfg = ast_config_load(CONFIG_FILE, config_flags);
+	if (!cfg) {
+		ast_test_status_update(test, "Could not load config\n");
+		goto out;
+	}
+
+	/* We need to re-save to get the generator header */
+	if (ast_config_text_file_save(CONFIG_FILE, cfg, "TEST")) {
+		ast_test_status_update(test, "Unable to write files\n");
+		goto out;
+	}
+
+	stat(config_filename, &config_stat);
+	before_save = config_stat.st_size;
+
+	if (!ast_include_new(cfg, CONFIG_FILE, CONFIG_INCLUDE_FILE, 0, NULL, 4, include_filename, PATH_MAX)) {
+		ast_test_status_update(test, "Could not create include\n");
+		goto out;
+	}
+
+	if (ast_config_text_file_save(CONFIG_FILE, cfg, "TEST")) {
+		ast_test_status_update(test, "Unable to write files\n");
+		goto out;
+	}
+
+	stat(config_filename, &config_stat);
+	if (config_stat.st_size <= before_save) {
+		ast_test_status_update(test, "Did not save config file with #include\n");
+		goto out;
+	}
+
+	res = AST_TEST_PASS;
+
+out:
+	ast_config_destroy(cfg);
+	unlink(config_filename);
+	unlink(include_filename);
+
+	return res;
+}
+
 AST_TEST_DEFINE(config_hook)
 {
 	enum ast_test_result_state res = AST_TEST_FAIL;
@@ -1734,6 +1807,7 @@ AST_TEST_DEFINE(variable_lists_match)
 
 static int unload_module(void)
 {
+	AST_TEST_UNREGISTER(config_save);
 	AST_TEST_UNREGISTER(config_basic_ops);
 	AST_TEST_UNREGISTER(config_filtered_ops);
 	AST_TEST_UNREGISTER(config_template_ops);
@@ -1748,6 +1822,7 @@ static int unload_module(void)
 
 static int load_module(void)
 {
+	AST_TEST_REGISTER(config_save);
 	AST_TEST_REGISTER(config_basic_ops);
 	AST_TEST_REGISTER(config_filtered_ops);
 	AST_TEST_REGISTER(config_template_ops);
diff -urpN asterisk-13.9.1/tests/test_file.c asterisk-13.17.0/tests/test_file.c
--- asterisk-13.9.1/tests/test_file.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/tests/test_file.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,197 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc.
+ *
+ * Kevin Harwell <kharwell@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*** MODULEINFO
+	<depend>TEST_FRAMEWORK</depend>
+	<support_level>core</support_level>
+ ***/
+
+
+#include "asterisk.h"
+#include <sys/stat.h>
+#include <stdio.h>
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include "asterisk/file.h"
+#include "asterisk/paths.h"
+#include "asterisk/test.h"
+#include "asterisk/module.h"
+#include "asterisk/strings.h"
+#include "asterisk/vector.h"
+
+#define FOUND -7
+
+AST_VECTOR(_filenames, struct ast_str *);
+
+static void rm_file(struct ast_str *filename)
+{
+	if (unlink(ast_str_buffer(filename))) {
+		ast_log(LOG_ERROR, "Unable to remove file: %s\n", ast_str_buffer(filename));
+	}
+
+	ast_free(filename);
+}
+
+static int test_files_destroy(struct ast_test *test, char *dir_name,
+			      struct _filenames *filenames)
+{
+	int res;
+
+	if (filenames) {
+		AST_VECTOR_CALLBACK_VOID(filenames, rm_file);
+		AST_VECTOR_FREE(filenames);
+	}
+
+	if ((res = rmdir(dir_name)) < 0) {
+		ast_test_status_update(test, "Failed to remove directory: %s\n", dir_name);
+	}
+
+	return res;
+}
+
+static int test_files_create(struct ast_test *test, char *dir_name,
+			     struct _filenames *filenames, int num)
+{
+	int i;
+
+	if (!(mkdtemp(dir_name))) {
+		ast_test_status_update(test, "Failed to create directory: %s\n", dir_name);
+		return -1;
+	}
+
+
+	AST_VECTOR_INIT(filenames, num);
+
+	/*
+	 * Create "num" files under the specified directory
+	 */
+	for (i = 0; i < num; ++i) {
+		int fd;
+		struct ast_str *filename = ast_str_create(32);
+
+		if (!filename) {
+			break;
+		}
+
+		ast_str_set(&filename, 0, "%s/XXXXXX", dir_name);
+
+		fd = mkstemp(ast_str_buffer(filename));
+		if (fd < 0) {
+			ast_test_status_update(test, "Failed to create file: %s\n",
+					       ast_str_buffer(filename));
+			ast_free(filename);
+			break;
+		}
+		close(fd);
+
+		AST_VECTOR_APPEND(filenames, filename);
+	}
+
+	if (i != num) {
+		test_files_destroy(test, dir_name, filenames);
+		return -1;
+	}
+
+	return 0;
+}
+
+static char *test_files_get_one(struct _filenames *filenames, int num)
+{
+	/* Every file is in a directory and contains a '/' so okay to do this */
+	return strrchr(ast_str_buffer(
+		       AST_VECTOR_GET(filenames, ast_random() % (num - 1))), '/') + 1;
+}
+
+static int handle_find_file(const char *dir_name, const char *filename, void *obj)
+{
+	struct stat statbuf;
+	char *full_path = ast_alloca(strlen(dir_name) + strlen(filename) + 2);
+
+	sprintf(full_path, "%s/%s", dir_name, filename);
+
+	errno = 0;
+	if (stat(full_path, &statbuf)) {
+		ast_log(LOG_ERROR, "Error reading path stats - %s: %s\n",
+			full_path, strerror(errno));
+		return 0;
+	}
+	/* obj contains the name of the file we are looking for */
+	return strcmp(obj, filename) ? 0 : FOUND;
+}
+
+AST_TEST_DEFINE(read_dirs_test)
+{
+	char tmp_dir[] = "/tmp/tmpdir.XXXXXX";
+	struct ast_str *tmp_sub_dir;
+	struct _filenames filenames;
+	enum ast_test_result_state res;
+	const int num_files = 10 + (ast_random() % 10); /* 10-19 random files */
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = "read_dir_test";
+		info->category = "/main/file/";
+		info->summary = "Read a directory's content";
+		info->description = "Iterate over directories looking for a file.";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	/*
+	 * We want to test recursively searching into a subdirectory, so
+	 * create a top level tmp directory where we will start the search.
+	 */
+	if (!(mkdtemp(tmp_dir))) {
+		ast_test_status_update(test, "Failed to create directory: %s\n", tmp_dir);
+		return AST_TEST_FAIL;
+	}
+
+	tmp_sub_dir = ast_str_alloca(32);
+	ast_str_set(&tmp_sub_dir, 0, "%s/XXXXXX", tmp_dir);
+
+	if (test_files_create(test, ast_str_buffer(tmp_sub_dir), &filenames, num_files)) {
+		test_files_destroy(test, tmp_dir, NULL);
+		return AST_TEST_FAIL;
+	}
+
+	res = ast_file_read_dirs(tmp_dir, handle_find_file, test_files_get_one(
+		 &filenames, num_files), 2) == FOUND ? AST_TEST_PASS : AST_TEST_FAIL;
+
+	if (test_files_destroy(test, ast_str_buffer(tmp_sub_dir), &filenames) ||
+	    test_files_destroy(test, tmp_dir, NULL)) {
+		res = AST_TEST_FAIL;
+	}
+
+	return res;
+}
+
+static int unload_module(void)
+{
+	AST_TEST_UNREGISTER(read_dirs_test);
+	return 0;
+}
+
+static int load_module(void)
+{
+	AST_TEST_REGISTER(read_dirs_test);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "File test module");
diff -urpN asterisk-13.9.1/tests/test_json.c asterisk-13.17.0/tests/test_json.c
--- asterisk-13.9.1/tests/test_json.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_json.c	2017-07-12 13:12:08.000000000 +0200
@@ -99,7 +99,7 @@ AST_TEST_DEFINE(json_test_false)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "false";
+		info->name = "type_false";
 		info->category = CATEGORY;
 		info->summary = "Testing fundamental JSON false value.";
 		info->description = "Test JSON abstraction library.";
@@ -124,7 +124,7 @@ AST_TEST_DEFINE(json_test_true)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "true";
+		info->name = "type_true";
 		info->category = CATEGORY;
 		info->summary = "Testing JSON true value.";
 		info->description = "Test JSON abstraction library.";
@@ -149,7 +149,7 @@ AST_TEST_DEFINE(json_test_bool0)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "bool0";
+		info->name = "type_bool0";
 		info->category = CATEGORY;
 		info->summary = "Testing JSON boolean function (false).";
 		info->description = "Test JSON abstraction library.";
@@ -176,7 +176,7 @@ AST_TEST_DEFINE(json_test_bool1)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "bool1";
+		info->name = "type_bool1";
 		info->category = CATEGORY;
 		info->summary = "Testing JSON boolean function (true).";
 		info->description = "Test JSON abstraction library.";
@@ -203,7 +203,7 @@ AST_TEST_DEFINE(json_test_null)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "null";
+		info->name = "type_null";
 		info->category = CATEGORY;
 		info->summary = "Testing JSON null value.";
 		info->description = "Test JSON abstraction library.";
@@ -255,7 +255,7 @@ AST_TEST_DEFINE(json_test_string)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "string";
+		info->name = "type_string";
 		info->category = CATEGORY;
 		info->summary = "Basic string tests.";
 		info->description = "Test JSON abstraction library.";
@@ -360,7 +360,7 @@ AST_TEST_DEFINE(json_test_int)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "int";
+		info->name = "type_int";
 		info->category = CATEGORY;
 		info->summary = "Basic JSON integer tests.";
 		info->description = "Test JSON abstraction library.";
@@ -1597,11 +1597,26 @@ AST_TEST_DEFINE(json_test_clever_circle)
 	return AST_TEST_PASS;
 }
 
-AST_TEST_DEFINE(json_test_name_number)
+static int test_name_number(const char *name, const char *number)
 {
-	RAII_VAR(struct ast_json *, uut, NULL, ast_json_unref);
-	RAII_VAR(struct ast_json *, expected, NULL, ast_json_unref);
+	int res;
+	struct ast_json *uut;
+	struct ast_json *expected;
+
+	expected = ast_json_pack("{s: s, s: s}",
+		"name", name ?: "",
+		"number", number ?: "");
+	uut = ast_json_name_number(name, number);
+
+	res = ast_json_equal(expected, uut);
+
+	ast_json_unref(expected);
+	ast_json_unref(uut);
+	return res;
+}
 
+AST_TEST_DEFINE(json_test_name_number)
+{
 	switch (cmd) {
 	case TEST_INIT:
 		info->name = "name_number";
@@ -1613,15 +1628,10 @@ AST_TEST_DEFINE(json_test_name_number)
 		break;
 	}
 
-	ast_test_validate(test, NULL == ast_json_name_number("name", NULL));
-	ast_test_validate(test, NULL == ast_json_name_number(NULL, "1234"));
-	ast_test_validate(test, NULL == ast_json_name_number(NULL, NULL));
-
-	expected = ast_json_pack("{s: s, s: s}",
-				 "name", "Jenny",
-				 "number", "867-5309");
-	uut = ast_json_name_number("Jenny", "867-5309");
-	ast_test_validate(test, ast_json_equal(expected, uut));
+	ast_test_validate(test, test_name_number("name", NULL));
+	ast_test_validate(test, test_name_number(NULL, "1234"));
+	ast_test_validate(test, test_name_number(NULL, NULL));
+	ast_test_validate(test, test_name_number("Jenny", "867-5309"));
 
 	return AST_TEST_PASS;
 }
@@ -1634,7 +1644,7 @@ AST_TEST_DEFINE(json_test_timeval)
 
 	switch (cmd) {
 	case TEST_INIT:
-		info->name = "timeval";
+		info->name = "type_timeval";
 		info->category = CATEGORY;
 		info->summary = "JSON encoding of timevals.";
 		info->description = "Test JSON abstraction library.";
diff -urpN asterisk-13.9.1/tests/test_logger.c asterisk-13.17.0/tests/test_logger.c
--- asterisk-13.9.1/tests/test_logger.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_logger.c	2017-07-12 13:12:08.000000000 +0200
@@ -190,9 +190,76 @@ static char *handle_cli_performance_test
 	return CLI_SUCCESS;
 }
 
+static char *handle_cli_queue_test(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	unsigned int level;
+	int current_queue_limit;
+	unsigned int x;
+	struct timeval start, end;
+	int elapsed;
+	char tmppath[] = "/tmp/asterisk_logger_queue.XXXXXX";
+	int fd;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "logger test queue";
+		e->usage = ""
+			"Usage: logger test queue\n"
+			"";
+		return NULL;
+	case CLI_GENERATE:
+		return NULL;
+	}
+
+	fd = mkstemp(tmppath);
+	if (fd < 0) {
+		ast_cli(a->fd, "Test: Failed, could not create temporary log file '%s'.\n", tmppath);
+		return CLI_SUCCESS;
+	}
+
+	level = ast_logger_register_level("queuetest");
+	if (level < 0) {
+		ast_cli(a->fd, "Test: Failed, could not register level 'queuetest'.\n");
+		return CLI_SUCCESS;
+	}
+	ast_cli(a->fd, "Test: got level %u for 'queuetest'.\n", level);
+
+	if (ast_logger_create_channel(tmppath, "queuetest") != AST_LOGGER_SUCCESS) {
+		ast_cli(a->fd, "Test: Unable to create logger channel '%s'\n", tmppath);
+		goto error;
+	}
+
+	current_queue_limit = ast_logger_get_queue_limit();
+	ast_cli(a->fd, "Test: Current queue limit: %d.  Setting to 100 for test.\n", current_queue_limit);
+	ast_logger_set_queue_limit(100);
+
+	ast_cli(a->fd, "Test: You should see SOME 'exceeded' and 'resumed' messages after the test "
+		"is completed.  How many is dependent on system resources.\n");
+
+	start = ast_tvnow();
+	for (x = 0; x < 10000; x++) {
+		ast_log_dynamic_level(level, "Performance test log message %2d\n", x);
+	}
+	end = ast_tvnow();
+	elapsed = ast_tvdiff_ms(end, start);
+	ast_cli(a->fd, "Test: 10,000 messages in %f seconds.\n", (float) elapsed / 1000);
+	ast_cli(a->fd, "Test: Completed.  Resetting queue limit to %d.\n", current_queue_limit);
+	ast_logger_set_queue_limit(current_queue_limit);
+
+error:
+
+	ast_logger_remove_channel(tmppath);
+	ast_logger_unregister_level("queuetest");
+	close(fd);
+	unlink(tmppath);
+
+	return CLI_SUCCESS;
+}
+
 static struct ast_cli_entry cli_logger[] = {
 	AST_CLI_DEFINE(handle_cli_dynamic_level_test, "Test the dynamic logger level implementation"),
 	AST_CLI_DEFINE(handle_cli_performance_test, "Test the logger performance"),
+	AST_CLI_DEFINE(handle_cli_queue_test, "Test the logger queue"),
 };
 
 static int unload_module(void)
diff -urpN asterisk-13.9.1/tests/test_message.c asterisk-13.17.0/tests/test_message.c
--- asterisk-13.9.1/tests/test_message.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_message.c	2017-07-12 13:12:08.000000000 +0200
@@ -232,8 +232,8 @@ static int user_event_hook_cb(int catego
 static int handler_wait_for_message(struct ast_test *test)
 {
 	int error = 0;
-	struct timeval wait_now = ast_tvnow();
-	struct timespec wait_time = { .tv_sec = wait_now.tv_sec + 1, .tv_nsec = wait_now.tv_usec * 1000 };
+	struct timeval wait = ast_tvadd(ast_tvnow(), ast_tv(5 /* seconds */, 0));
+	struct timespec wait_time = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000 };
 
 	ast_mutex_lock(&handler_lock);
 	while (!handler_received_message) {
@@ -253,8 +253,8 @@ static int handler_wait_for_message(stru
 static int user_event_wait_for_events(struct ast_test *test, int expected_events)
 {
 	int error;
-	struct timeval wait_now = ast_tvnow();
-	struct timespec wait_time = { .tv_sec = wait_now.tv_sec + 1, .tv_nsec = wait_now.tv_usec * 1000 };
+	struct timeval wait = ast_tvadd(ast_tvnow(), ast_tv(5 /* seconds */, 0));
+	struct timespec wait_time = { .tv_sec = wait.tv_sec, .tv_nsec = wait.tv_usec * 1000 };
 
 	expected_user_events = expected_events;
 
diff -urpN asterisk-13.9.1/tests/test_netsock2.c asterisk-13.17.0/tests/test_netsock2.c
--- asterisk-13.9.1/tests/test_netsock2.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_netsock2.c	2017-07-12 13:12:08.000000000 +0200
@@ -75,7 +75,7 @@ AST_TEST_DEFINE(parsing)
 	};
 
 	size_t x;
-	struct ast_sockaddr addr = { { 0, 0, } };
+	struct ast_sockaddr addr;
 	int parse_result;
 
 	switch (cmd) {
@@ -91,15 +91,17 @@ AST_TEST_DEFINE(parsing)
 	}
 
 	for (x = 0; x < ARRAY_LEN(test_vals); x++) {
+		memset(&addr, 0, sizeof(addr));
 		if ((parse_result = ast_sockaddr_parse(&addr, test_vals[x].address, 0)) != test_vals[x].expected_result) {
 			ast_test_status_update(test, "On '%s' expected %d but got %d\n", test_vals[x].address, test_vals[x].expected_result, parse_result);
 			res = AST_TEST_FAIL;
 		}
 		if (parse_result) {
-			struct ast_sockaddr tmp_addr = { { 0, 0, } };
+			struct ast_sockaddr tmp_addr;
 			const char *tmp;
 
 			tmp = ast_sockaddr_stringify(&addr);
+			memset(&tmp_addr, 0, sizeof(tmp_addr));
 			ast_sockaddr_parse(&tmp_addr, tmp, 0);
 			if (ast_sockaddr_cmp_addr(&addr, &tmp_addr)) {
 				char buf[64];
diff -urpN asterisk-13.9.1/tests/test_pbx.c asterisk-13.17.0/tests/test_pbx.c
--- asterisk-13.9.1/tests/test_pbx.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_pbx.c	2017-07-12 13:12:08.000000000 +0200
@@ -323,8 +323,29 @@ cleanup:
 	return res;
 }
 
+AST_TEST_DEFINE(segv)
+{
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = "RAISE_SEGV";
+		info->category = "/DO_NOT_RUN/";
+		info->summary = "RAISES SEGV!!! (will only be run if explicitly called)";
+		info->description = "RAISES SEGV!!! (will only be run if explicitly called). "
+			"This test is mainly used for testing CI and tool failure scenarios.";
+		info->explicit_only = 1;
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	raise(SIGSEGV);
+
+	return AST_TEST_FAIL;
+}
+
 static int unload_module(void)
 {
+	AST_TEST_UNREGISTER(segv);
 	AST_TEST_UNREGISTER(pattern_match_test);
 	return 0;
 }
@@ -332,6 +353,7 @@ static int unload_module(void)
 static int load_module(void)
 {
 	AST_TEST_REGISTER(pattern_match_test);
+	AST_TEST_REGISTER(segv);
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
diff -urpN asterisk-13.9.1/tests/test_res_pjsip_scheduler.c asterisk-13.17.0/tests/test_res_pjsip_scheduler.c
--- asterisk-13.9.1/tests/test_res_pjsip_scheduler.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/tests/test_res_pjsip_scheduler.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,401 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Fairview 5 Engineering, LLC
+ *
+ * George Joseph <george.joseph@fairview5.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*!
+ * \file
+ * \brief res_pjsip scheduler tests
+ *
+ * \author George Joseph <george.joseph@fairview5.com>
+ *
+ */
+
+/*** MODULEINFO
+	<depend>TEST_FRAMEWORK</depend>
+	<depend>pjproject</depend>
+	<depend>res_pjsip</depend>
+	<support_level>core</support_level>
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_REGISTER_FILE()
+
+#include <pjsip.h>
+#include "asterisk/test.h"
+#include "asterisk/module.h"
+#include "asterisk/taskprocessor.h"
+#include "asterisk/res_pjsip.h"
+#include "asterisk/utils.h"
+
+#define CATEGORY "/res/res_pjsip/scheduler/"
+
+struct test_data {
+	ast_mutex_t lock;
+	ast_cond_t cond;
+	pthread_t tid;
+	struct timeval test_start;
+	struct timeval task_start;
+	struct timeval task_end;
+	int is_servant;
+	int interval;
+	int sleep;
+	int done;
+	struct ast_test *test;
+};
+
+#define S2U(x) (long int)(x * 1000 * 1000)
+#define M2U(x) (long int)(x * 1000)
+
+static int task_1(void *data)
+{
+	struct test_data *test = data;
+
+	test->done = 0;
+	test->task_start = ast_tvnow();
+	test->tid = pthread_self();
+	test->is_servant = ast_sip_thread_is_servant();
+	usleep(M2U(test->sleep));
+	test->task_end = ast_tvnow();
+
+	ast_mutex_lock(&test->lock);
+	test->done = 1;
+	ast_mutex_unlock(&test->lock);
+	ast_cond_signal(&test->cond);
+
+	return test->interval;
+}
+
+
+static void data_cleanup(void *data)
+{
+	struct test_data *test_data = data;
+	ast_mutex_destroy(&test_data->lock);
+	ast_cond_destroy(&test_data->cond);
+}
+
+#define waitfor(x) \
+{ \
+	ast_mutex_lock(&(x)->lock); \
+	while (!(x)->done) { \
+		ast_cond_wait(&(x)->cond, &(x)->lock); \
+	} \
+	(x)->done = 0; \
+	ast_mutex_unlock(&(x)->lock); \
+}
+
+static int scheduler(struct ast_test *test, int serialized)
+{
+	RAII_VAR(struct ast_taskprocessor *, tp1, NULL, ast_taskprocessor_unreference);
+	RAII_VAR(struct test_data *, test_data1, ao2_alloc(sizeof(*test_data1), data_cleanup), ao2_cleanup);
+	RAII_VAR(struct test_data *, test_data2, ao2_alloc(sizeof(*test_data2), data_cleanup), ao2_cleanup);
+	RAII_VAR(struct ast_sip_sched_task *, task1, NULL, ao2_cleanup);
+	RAII_VAR(struct ast_sip_sched_task *, task2, NULL, ao2_cleanup);
+	int duration;
+	int delay;
+	struct timeval task1_start;
+
+	ast_test_validate(test, test_data1 != NULL);
+	ast_test_validate(test, test_data2 != NULL);
+
+	test_data1->test = test;
+	test_data1->test_start = ast_tvnow();
+	test_data1->interval = 2000;
+	test_data1->sleep = 1000;
+	ast_mutex_init(&test_data1->lock);
+	ast_cond_init(&test_data1->cond, NULL);
+
+	test_data2->test = test;
+	test_data2->test_start = ast_tvnow();
+	test_data2->interval = 2000;
+	test_data2->sleep = 1000;
+	ast_mutex_init(&test_data2->lock);
+	ast_cond_init(&test_data2->cond, NULL);
+
+	if (serialized) {
+		ast_test_status_update(test, "This test will take about %3.1f seconds\n",
+			(test_data1->interval + test_data1->sleep + (MAX(test_data1->interval - test_data2->interval, 0)) + test_data2->sleep) / 1000.0);
+		tp1 = ast_sip_create_serializer();
+		ast_test_validate(test, (tp1 != NULL));
+	} else {
+		ast_test_status_update(test, "This test will take about %3.1f seconds\n",
+			((MAX(test_data1->interval, test_data2->interval) + MAX(test_data1->sleep, test_data2->sleep)) / 1000.0));
+	}
+
+	task1 = ast_sip_schedule_task(tp1, test_data1->interval, task_1, NULL, test_data1, AST_SIP_SCHED_TASK_FIXED);
+	ast_test_validate(test, task1 != NULL);
+
+	task2 = ast_sip_schedule_task(tp1, test_data2->interval, task_1, NULL, test_data2, AST_SIP_SCHED_TASK_FIXED);
+	ast_test_validate(test, task2 != NULL);
+
+	waitfor(test_data1);
+	ast_sip_sched_task_cancel(task1);
+	ast_test_validate(test, test_data1->is_servant);
+
+	duration = ast_tvdiff_ms(test_data1->task_end, test_data1->test_start);
+	ast_test_validate(test, (duration > ((test_data1->interval + test_data1->sleep) * 0.9))
+		&& (duration < ((test_data1->interval + test_data1->sleep) * 1.1)));
+
+	ast_sip_sched_task_get_times(task1, NULL, &task1_start, NULL);
+	delay = ast_tvdiff_ms(task1_start, test_data1->test_start);
+	ast_test_validate(test, (delay > (test_data1->interval * 0.9)
+		&& (delay < (test_data1->interval * 1.1))));
+
+	waitfor(test_data2);
+	ast_sip_sched_task_cancel(task2);
+	ast_test_validate(test, test_data2->is_servant);
+
+	if (serialized) {
+		ast_test_validate(test, test_data1->tid == test_data2->tid);
+		ast_test_validate(test, ast_tvdiff_ms(test_data2->task_start, test_data1->task_end) >= 0);
+	} else {
+		ast_test_validate(test, test_data1->tid != test_data2->tid);
+	}
+
+	return AST_TEST_PASS;
+}
+
+AST_TEST_DEFINE(serialized_scheduler)
+{
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = __func__;
+		info->category = CATEGORY;
+		info->summary = "Test res_pjsip serialized scheduler";
+		info->description = "Test res_pjsip serialized scheduler";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	return scheduler(test, 1);
+}
+
+AST_TEST_DEFINE(unserialized_scheduler)
+{
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = __func__;
+		info->category = CATEGORY;
+		info->summary = "Test res_pjsip unserialized scheduler";
+		info->description = "Test res_pjsip unserialized scheduler";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	return scheduler(test, 0);
+}
+
+static int run_count;
+static int destruct_count;
+
+static int dummy_task(void *data)
+{
+	int *sleep = data;
+
+	usleep(M2U(*sleep));
+	run_count++;
+
+	return 0;
+}
+
+static void test_destructor(void *data)
+{
+	destruct_count++;
+}
+
+AST_TEST_DEFINE(scheduler_cleanup)
+{
+	RAII_VAR(int *, sleep, NULL, ao2_cleanup);
+	RAII_VAR(struct ast_sip_sched_task *, task, NULL, ao2_cleanup);
+	int interval;
+	int when;
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = __func__;
+		info->category = CATEGORY;
+		info->summary = "Test res_pjsip scheduler cleanup";
+		info->description = "Test res_pjsip scheduler cleanup";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	destruct_count = 0;
+	interval = 1000;
+
+	sleep = ao2_alloc(sizeof(*sleep), test_destructor);
+	ast_test_validate(test, sleep != NULL);
+	*sleep = 500;
+
+	ast_test_status_update(test, "This test will take about %3.1f seconds\n",
+		((interval * 1.1) + *sleep) / 1000.0);
+
+	task = ast_sip_schedule_task(NULL, interval, dummy_task, "dummy", sleep,
+		AST_SIP_SCHED_TASK_DATA_AO2 | AST_SIP_SCHED_TASK_DATA_FREE);
+	ast_test_validate(test, task != NULL);
+	usleep(M2U(interval * 0.5));
+	when = ast_sip_sched_task_get_next_run(task);
+	ast_test_validate(test, (when > (interval * 0.4) && when < (interval * 0.6)));
+	usleep(M2U(interval * 0.6));
+	ast_test_validate(test, ast_sip_sched_is_task_running(task));
+
+	usleep(M2U(*sleep));
+
+	ast_test_validate(test, (ast_sip_sched_is_task_running(task) == 0));
+	when = ast_sip_sched_task_get_next_run(task);
+	ast_test_validate(test, (when < 0), res, error);
+	ast_test_validate(test, (ao2_ref(task, 0) == 1));
+	ao2_ref(task, -1);
+	task = NULL;
+	ast_test_validate(test, (destruct_count == 1));
+	sleep = NULL;
+
+	return AST_TEST_PASS;
+}
+
+AST_TEST_DEFINE(scheduler_cancel)
+{
+	RAII_VAR(int *, sleep, NULL, ao2_cleanup);
+	RAII_VAR(struct ast_sip_sched_task *, task, NULL, ao2_cleanup);
+	int interval;
+	int when;
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = __func__;
+		info->category = CATEGORY;
+		info->summary = "Test res_pjsip scheduler cancel task";
+		info->description = "Test res_pjsip scheduler cancel task";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	destruct_count = 0;
+	interval = 1000;
+
+	sleep = ao2_alloc(sizeof(*sleep), test_destructor);
+	ast_test_validate(test, sleep != NULL);
+	*sleep = 500;
+
+	ast_test_status_update(test, "This test will take about %3.1f seconds\n",
+		(interval + *sleep) / 1000.0);
+
+	task = ast_sip_schedule_task(NULL, interval, dummy_task, "dummy", sleep, AST_SIP_SCHED_TASK_DATA_NO_CLEANUP);
+	ast_test_validate(test, task != NULL);
+
+	usleep(M2U(interval * 0.5));
+	when = ast_sip_sched_task_get_next_run_by_name("dummy");
+	ast_test_validate(test, (when > (interval * 0.4) && when < (interval * 0.6)));
+	ast_test_validate(test, !ast_sip_sched_is_task_running_by_name("dummy"));
+	ast_test_validate(test, ao2_ref(task, 0) == 2);
+
+	ast_sip_sched_task_cancel_by_name("dummy");
+
+	when = ast_sip_sched_task_get_next_run(task);
+	ast_test_validate(test, when < 0);
+
+	usleep(M2U(interval));
+	ast_test_validate(test, run_count == 0);
+	ast_test_validate(test, destruct_count == 0);
+	ast_test_validate(test, ao2_ref(task, 0) == 1);
+
+	return AST_TEST_PASS;
+}
+
+AST_TEST_DEFINE(scheduler_policy)
+{
+	RAII_VAR(struct test_data *, test_data1, ao2_alloc(sizeof(*test_data1), data_cleanup), ao2_cleanup);
+	RAII_VAR(struct ast_sip_sched_task *, task, NULL, ao2_cleanup);
+	int when;
+
+	switch (cmd) {
+	case TEST_INIT:
+		info->name = __func__;
+		info->category = CATEGORY;
+		info->summary = "Test res_pjsip scheduler cancel task";
+		info->description = "Test res_pjsip scheduler cancel task";
+		return AST_TEST_NOT_RUN;
+	case TEST_EXECUTE:
+		break;
+	}
+
+	ast_test_validate(test, test_data1 != NULL);
+
+	destruct_count = 0;
+	run_count = 0;
+	test_data1->test = test;
+	test_data1->test_start = ast_tvnow();
+	test_data1->interval = 1000;
+	test_data1->sleep = 500;
+	ast_mutex_init(&test_data1->lock);
+	ast_cond_init(&test_data1->cond, NULL);
+
+	ast_test_status_update(test, "This test will take about %3.1f seconds\n",
+		((test_data1->interval * 3) + test_data1->sleep) / 1000.0);
+
+	task = ast_sip_schedule_task(NULL, test_data1->interval, task_1, "test_1", test_data1,
+		AST_SIP_SCHED_TASK_DATA_NO_CLEANUP | AST_SIP_SCHED_TASK_PERIODIC);
+	ast_test_validate(test, task != NULL);
+
+	waitfor(test_data1);
+	when = ast_tvdiff_ms(test_data1->task_start, test_data1->test_start);
+	ast_test_validate(test, when > test_data1->interval * 0.9 && when < test_data1->interval * 1.1);
+
+	waitfor(test_data1);
+	when = ast_tvdiff_ms(test_data1->task_start, test_data1->test_start);
+	ast_test_validate(test, when > test_data1->interval * 2 * 0.9 && when < test_data1->interval * 2 * 1.1);
+
+	waitfor(test_data1);
+	when = ast_tvdiff_ms(test_data1->task_start, test_data1->test_start);
+	ast_test_validate(test, when > test_data1->interval * 3 * 0.9 && when < test_data1->interval * 3 * 1.1);
+
+	ast_sip_sched_task_cancel(task);
+	ao2_ref(task, -1);
+	task = NULL;
+
+	return AST_TEST_PASS;
+}
+
+static int load_module(void)
+{
+	CHECK_PJSIP_MODULE_LOADED();
+
+	AST_TEST_REGISTER(serialized_scheduler);
+	AST_TEST_REGISTER(unserialized_scheduler);
+	AST_TEST_REGISTER(scheduler_cleanup);
+	AST_TEST_REGISTER(scheduler_cancel);
+	AST_TEST_REGISTER(scheduler_policy);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	AST_TEST_UNREGISTER(scheduler_cancel);
+	AST_TEST_UNREGISTER(scheduler_cleanup);
+	AST_TEST_UNREGISTER(unserialized_scheduler);
+	AST_TEST_UNREGISTER(serialized_scheduler);
+	AST_TEST_UNREGISTER(scheduler_policy);
+	return 0;
+}
+
+AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "res_pjsip scheduler test module");
diff -urpN asterisk-13.9.1/tests/test_res_stasis.c asterisk-13.17.0/tests/test_res_stasis.c
--- asterisk-13.9.1/tests/test_res_stasis.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_res_stasis.c	2017-07-12 13:12:08.000000000 +0200
@@ -137,6 +137,7 @@ AST_TEST_DEFINE(app_replaced)
 	RAII_VAR(struct ast_json *, expected_message1, NULL, ast_json_unref);
 	RAII_VAR(struct ast_json *, message, NULL, ast_json_unref);
 	RAII_VAR(struct ast_json *, expected_message2, NULL, ast_json_unref);
+	char eid[20];
 	int res;
 
 	switch (cmd) {
@@ -157,9 +158,10 @@ AST_TEST_DEFINE(app_replaced)
 
 	stasis_app_register(app_name, test_handler, app_data1);
 	stasis_app_register(app_name, test_handler, app_data2);
-	expected_message1 = ast_json_pack("[{s: s, s: s}]",
+	expected_message1 = ast_json_pack("[{s: s, s: s, s: s}]",
 		"type", "ApplicationReplaced",
-		"application", app_name);
+		"application", app_name,
+		"asterisk_id", ast_eid_to_str(eid, sizeof(eid), &ast_eid_default));
 	message = ast_json_pack("{ s: o }", "test-message", ast_json_null());
 	expected_message2 = ast_json_pack("[o]", ast_json_ref(message));
 
diff -urpN asterisk-13.9.1/tests/test_sorcery_realtime.c asterisk-13.17.0/tests/test_sorcery_realtime.c
--- asterisk-13.9.1/tests/test_sorcery_realtime.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_sorcery_realtime.c	2017-07-12 13:12:08.000000000 +0200
@@ -711,41 +711,6 @@ AST_TEST_DEFINE(object_update)
 	return AST_TEST_PASS;
 }
 
-AST_TEST_DEFINE(object_update_uncreated)
-{
-	RAII_VAR(struct ast_sorcery *, sorcery, NULL, deinitialize_sorcery);
-	RAII_VAR(struct test_sorcery_object *, obj, NULL, ao2_cleanup);
-
-	switch (cmd) {
-	case TEST_INIT:
-		info->name = "object_update_uncreated";
-		info->category = "/res/sorcery_realtime/";
-		info->summary = "sorcery object update unit test";
-		info->description =
-			"Test updating of an uncreated object in sorcery using realtime wizard";
-		return AST_TEST_NOT_RUN;
-	case TEST_EXECUTE:
-		break;
-	}
-
-	if (!(sorcery = alloc_and_initialize_sorcery("sorcery_realtime_test"))) {
-		ast_test_status_update(test, "Failed to open sorcery structure\n");
-		return AST_TEST_FAIL;
-	}
-
-	if (!(obj = ast_sorcery_alloc(sorcery, "test", "blah"))) {
-		ast_test_status_update(test, "Failed to allocate a known object type\n");
-		return AST_TEST_FAIL;
-	}
-
-	if (!ast_sorcery_update(sorcery, obj)) {
-		ast_test_status_update(test, "Successfully updated an object which has not been created yet\n");
-		return AST_TEST_FAIL;
-	}
-
-	return AST_TEST_PASS;
-}
-
 AST_TEST_DEFINE(object_delete)
 {
 	RAII_VAR(struct ast_sorcery *, sorcery, NULL, deinitialize_sorcery);
@@ -942,7 +907,6 @@ static int unload_module(void)
 	AST_TEST_UNREGISTER(object_retrieve_regex);
 	AST_TEST_UNREGISTER(object_retrieve_regex_nofetch);
 	AST_TEST_UNREGISTER(object_update);
-	AST_TEST_UNREGISTER(object_update_uncreated);
 	AST_TEST_UNREGISTER(object_delete);
 	AST_TEST_UNREGISTER(object_delete_uncreated);
 	AST_TEST_UNREGISTER(object_allocate_on_retrieval);
@@ -964,7 +928,6 @@ static int load_module(void)
 	AST_TEST_REGISTER(object_retrieve_regex);
 	AST_TEST_REGISTER(object_retrieve_regex_nofetch);
 	AST_TEST_REGISTER(object_update);
-	AST_TEST_REGISTER(object_update_uncreated);
 	AST_TEST_REGISTER(object_delete);
 	AST_TEST_REGISTER(object_delete_uncreated);
 	AST_TEST_REGISTER(object_allocate_on_retrieval);
diff -urpN asterisk-13.9.1/tests/test_substitution.c asterisk-13.17.0/tests/test_substitution.c
--- asterisk-13.9.1/tests/test_substitution.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_substitution.c	2017-07-12 13:12:08.000000000 +0200
@@ -287,7 +287,16 @@ AST_TEST_DEFINE(test_substitution)
 	TEST(test_expected_result(test, c, "A${${baz}o:-2:1}A", "A2A"));
 	TEST(test_expected_result(test, c, "A${${baz}o:-2:-1}A", "A2A"));
 	pbx_builtin_setvar_helper(c, "list1", "ab&cd&ef");
+	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,ab)}", "cd&ef"));
 	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,cd)}", "ab&ef"));
+	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,ef)}", "ab&cd"));
+	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,gh)}", "ab&cd&ef"));
+	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,c)}", "ab&cd&ef"));
+	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,d)}", "ab&cd&ef"));
+	pbx_builtin_setvar_helper(c, "list2", "ab");
+	TEST(test_expected_result(test, c, "${LISTFILTER(list2,&,ab)}", ""));
+	pbx_builtin_setvar_helper(c, "list_empty", "");
+	TEST(test_expected_result(test, c, "${LISTFILTER(list_empty,&,ab)}", ""));
 	TEST(test_expected_result(test, c, "${SHELL(printf '%d' 123)},${SHELL(printf '%d' 456)}", "123,456"));
 	TEST(test_expected_result(test, c, "${foo},${CDR(answer)},${SHELL(printf '%d' 456)}", "123,,456"));
 	TEST(test_expected_result(test, c, "${foo},${CDR(answer,u)},${SHELL(printf '%d' 456)}", "123,0.000000,456"));
diff -urpN asterisk-13.9.1/tests/test_vector.c asterisk-13.17.0/tests/test_vector.c
--- asterisk-13.9.1/tests/test_vector.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_vector.c	2017-07-12 13:12:08.000000000 +0200
@@ -282,6 +282,25 @@ AST_TEST_DEFINE(basic_ops_integer)
 	ast_test_validate_cleanup(test, *(int *)AST_VECTOR_GET_CMP(&sv1, AAA,  AST_VECTOR_ELEM_DEFAULT_CMP) == AAA, rc, cleanup);
 	ast_test_validate_cleanup(test, *(int *)AST_VECTOR_GET_CMP(&sv1, ZZZ, AST_VECTOR_ELEM_DEFAULT_CMP) == ZZZ, rc, cleanup);
 
+	/* Default first value */
+	ast_test_validate_cleanup(test, AST_VECTOR_DEFAULT(&sv1, 1, CCC) == 0, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 0) == CCC, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 1) == ZZZ, rc, cleanup);
+	/* Default all values */
+	ast_test_validate_cleanup(test, AST_VECTOR_DEFAULT(&sv1, 0, AAA) == 0, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 0) == AAA, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 1) == AAA, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 2) == AAA, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 3) == AAA, rc, cleanup);
+	/* Default more values than are currently in the vector */
+	ast_test_validate_cleanup(test, AST_VECTOR_DEFAULT(&sv1, 5, BBB) == 0, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET(&sv1, 4) == BBB, rc, cleanup);
+
+	/* Check getting index(es) */
+	ast_test_validate_cleanup(test, AST_VECTOR_GET_INDEX(&sv1, BBB, AST_VECTOR_ELEM_DEFAULT_CMP) == 0, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET_INDEX_NTH(&sv1, 2, BBB, AST_VECTOR_ELEM_DEFAULT_CMP) == 1, rc, cleanup);
+	ast_test_validate_cleanup(test, AST_VECTOR_GET_INDEX_NTH(&sv1, 4, BBB, AST_VECTOR_ELEM_DEFAULT_CMP) == 3, rc, cleanup);
+
 	AST_VECTOR_FREE(&sv1);
 	ast_test_validate(test, sv1.elems == NULL);
 	ast_test_validate(test, sv1.current == 0);
diff -urpN asterisk-13.9.1/tests/test_voicemail_api.c asterisk-13.17.0/tests/test_voicemail_api.c
--- asterisk-13.9.1/tests/test_voicemail_api.c	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/tests/test_voicemail_api.c	2017-07-12 13:12:08.000000000 +0200
@@ -242,7 +242,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 		return AST_TEST_FAIL; \
 	} \
 	VM_API_SNAPSHOT_CREATE((mailbox), (context), (folder), 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0); \
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 0); \
+	VM_API_INT_VERIFY(0, test_mbox_snapshot->total_msg_num); \
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot); \
 } while (0)
 
@@ -462,7 +462,7 @@ static int test_vm_api_create_voicemail_
 		folder_path, snapshot->msg_number);
 	snprintf(snd_path, sizeof(snd_path), "%s/msg%04u.gsm",
 		folder_path, snapshot->msg_number);
-	snprintf(beep_path, sizeof(beep_path), "%s/sounds/en/beep.gsm", ast_config_AST_VAR_DIR);
+	snprintf(beep_path, sizeof(beep_path), "%s/sounds/en/beep.gsm", ast_config_AST_DATA_DIR);
 
 	if (test_vm_api_create_voicemail_folder(folder_path)) {
 		return 1;
@@ -1004,10 +1004,10 @@ AST_TEST_DEFINE(voicemail_api_nominal_mo
 	test_vm_api_update_test_snapshots(test_mbox_snapshot);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
-	VM_API_STRING_FIELD_VERIFY(test_snapshots[0]->folder_name, "Family");
-	VM_API_STRING_FIELD_VERIFY(test_snapshots[1]->folder_name, "Family");
-	VM_API_INT_VERIFY(test_snapshots[1]->msg_number, 0);
-	VM_API_INT_VERIFY(test_snapshots[0]->msg_number, 1);
+	VM_API_STRING_FIELD_VERIFY("Family", test_snapshots[0]->folder_name);
+	VM_API_STRING_FIELD_VERIFY("Family", test_snapshots[1]->folder_name);
+	VM_API_INT_VERIFY(0, test_snapshots[1]->msg_number);
+	VM_API_INT_VERIFY(1, test_snapshots[0]->msg_number);
 
 	/* Move both of the 2345 messages to Family */
 	ast_test_status_update(test, "Test move of test_vm_api_2345 messages from Inbox to Family\n");
@@ -1018,8 +1018,8 @@ AST_TEST_DEFINE(voicemail_api_nominal_mo
 	test_vm_api_update_test_snapshots(test_mbox_snapshot);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
-	VM_API_STRING_FIELD_VERIFY(test_snapshots[2]->folder_name, "Family");
-	VM_API_STRING_FIELD_VERIFY(test_snapshots[3]->folder_name, "Family");
+	VM_API_STRING_FIELD_VERIFY("Family", test_snapshots[2]->folder_name);
+	VM_API_STRING_FIELD_VERIFY("Family", test_snapshots[3]->folder_name);
 
 	ast_test_status_update(test, "Test move of test_vm_api_2345 message from Family to INBOX\n");
 	VM_API_MOVE_MESSAGE("test_vm_api_2345", "default", 2, "Family", multi_msg_ids, "INBOX");
@@ -1028,8 +1028,8 @@ AST_TEST_DEFINE(voicemail_api_nominal_mo
 	test_vm_api_update_test_snapshots(test_mbox_snapshot);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
-	VM_API_STRING_FIELD_VERIFY(test_snapshots[2]->folder_name, "INBOX");
-	VM_API_STRING_FIELD_VERIFY(test_snapshots[3]->folder_name, "INBOX");
+	VM_API_STRING_FIELD_VERIFY("INBOX", test_snapshots[2]->folder_name);
+	VM_API_STRING_FIELD_VERIFY("INBOX", test_snapshots[3]->folder_name);
 
 	VM_API_TEST_CLEANUP;
 
@@ -1250,12 +1250,12 @@ AST_TEST_DEFINE(voicemail_api_nominal_fo
 
 	/* Make sure we didn't delete the message */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 1);
+	VM_API_INT_VERIFY(1, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	/* We should now have a total of 3 messages in test_vm_api_2345 INBOX */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 3);
+	VM_API_INT_VERIFY(3, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	ast_test_status_update(test, "Test forwarding message 0 from test_vm_api_1234 INBOX with default context to test_vm_api_2345 INBOX\n");
@@ -1263,12 +1263,12 @@ AST_TEST_DEFINE(voicemail_api_nominal_fo
 
 	/* Make sure we didn't delete the message */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 1);
+	VM_API_INT_VERIFY(1, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	/* We should now have a total of 4 messages in test_vm_api_2345 INBOX */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 4);
+	VM_API_INT_VERIFY(4, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	ast_test_status_update(test, "Test forwarding message 0 from test_vm_api_1234 INBOX to test_vm_api_2345 INBOX with default context\n");
@@ -1276,12 +1276,12 @@ AST_TEST_DEFINE(voicemail_api_nominal_fo
 
 	/* Make sure we didn't delete the message */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 1);
+	VM_API_INT_VERIFY(1, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	/* We should now have a total of 5 messages in test_vm_api_2345 INBOX */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 5);
+	VM_API_INT_VERIFY(5, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	ast_test_status_update(test, "Test forwarding message 0 from test_vm_api_1234 INBOX to test_vm_api_2345 INBOX, deleting original\n");
@@ -1289,12 +1289,12 @@ AST_TEST_DEFINE(voicemail_api_nominal_fo
 
 	/* Make sure we deleted the message */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 0);
+	VM_API_INT_VERIFY(0, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	/* We should now have a total of 6 messages in test_vm_api_2345 INBOX */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 6);
+	VM_API_INT_VERIFY(6, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	ast_test_status_update(test, "Test forwarding 2 messages from test_vm_api_2345 INBOX to test_vm_api_1234 INBOX");
@@ -1302,24 +1302,24 @@ AST_TEST_DEFINE(voicemail_api_nominal_fo
 
 	/* Make sure we didn't delete the messages */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 6);
+	VM_API_INT_VERIFY(6, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	/* We should now have a total of 2 messages in test_vm_api_1234 INBOX */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 2);
+	VM_API_INT_VERIFY(2, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	ast_test_status_update(test, "Test forwarding 2 messages from test_vm_api_2345 INBOX to test_vm_api_1234 Family, deleting original\n");
 	VM_API_FORWARD_MESSAGE("test_vm_api_2345", "default", "INBOX", "test_vm_api_1234", "default", "Family", 2, multi_msg_ids, 1);
 	/* Make sure we deleted the messages */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "INBOX", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 4);
+	VM_API_INT_VERIFY(4, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	/* We should now have a total of 2 messages in test_vm_api_1234 Family */
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "Family", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 2);
+	VM_API_INT_VERIFY(2, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	VM_API_TEST_CLEANUP;
@@ -1449,20 +1449,20 @@ AST_TEST_DEFINE(voicemail_api_nominal_ms
 
 	ast_test_status_update(test, "Playing back message from test_vm_api_2345 to callback function\n");
 	VM_API_PLAYBACK_MESSAGE(test_channel, "test_vm_api_2345", "default", "INBOX", message_id_2345[0], &message_playback_callback_fn);
-	VM_API_INT_VERIFY(global_entered_playback_callback, 1);
+	VM_API_INT_VERIFY(1, global_entered_playback_callback);
 	global_entered_playback_callback = 0;
 
 	ast_test_status_update(test, "Playing back message from test_vm_api_2345 to callback function with default context\n");
 	VM_API_PLAYBACK_MESSAGE(test_channel, "test_vm_api_2345", NULL, "INBOX", message_id_2345[1], &message_playback_callback_fn);
-	VM_API_INT_VERIFY(global_entered_playback_callback, 1);
+	VM_API_INT_VERIFY(1, global_entered_playback_callback);
 	global_entered_playback_callback = 0;
 
 	VM_API_SNAPSHOT_CREATE("test_vm_api_1234", "default", "Old", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 2);
+	VM_API_INT_VERIFY(2, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	VM_API_SNAPSHOT_CREATE("test_vm_api_2345", "default", "Old", 0, AST_VM_SNAPSHOT_SORT_BY_TIME, 0);
-	VM_API_INT_VERIFY(test_mbox_snapshot->total_msg_num, 2);
+	VM_API_INT_VERIFY(2, test_mbox_snapshot->total_msg_num);
 	test_mbox_snapshot = ast_vm_mailbox_snapshot_destroy(test_mbox_snapshot);
 
 	ast_hangup(test_channel);
diff -urpN asterisk-13.9.1/third-party/Makefile asterisk-13.17.0/third-party/Makefile
--- asterisk-13.9.1/third-party/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -6,14 +6,14 @@ TP_SUBDIRS := pjproject
 # to prevent accidentally running the package's default install target.
 TP_INSTALL_SUBDIRS := pjproject
 
-.PHONY: all dist-clean distclean install clean moduleinfo makeopts uninstall __embed_libs __embed_ldscript __embed_ldflags $(TP_SUBDIRS)
+.PHONY: all dist-clean distclean install clean moduleinfo makeopts uninstall $(TP_SUBDIRS)
 
 override MAKECMDGOALS?=all
 
 MAKECMDGOALS:=$(subst dist-clean,distclean,$(MAKECMDGOALS))
 MAKECMDGOALS:=$(subst tpclean,clean,$(MAKECMDGOALS))
 
-all distclean dist-clean install tpclean : $(TP_SUBDIRS)
+all distclean dist-clean install uninstall tpclean : $(TP_SUBDIRS)
 install uninstall: $(TP_INSTALL_SUBDIRS)
 
 $(TP_SUBDIRS):
diff -urpN asterisk-13.9.1/third-party/Makefile.rules asterisk-13.17.0/third-party/Makefile.rules
--- asterisk-13.9.1/third-party/Makefile.rules	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/Makefile.rules	2017-07-12 13:12:08.000000000 +0200
@@ -4,7 +4,7 @@ SUBMAKE?=$(MAKE) --quiet --no-print-dire
 ECHO_PREFIX?=@
 CMD_PREFIX?=@
 QUIET_CONFIGURE=-q
-REALLY_QUIET=&>/dev/null
+REALLY_QUIET=>/dev/null 2>&1
 else
 SUBMAKE?=$(MAKE)
 ECHO_PREFIX?=@\#
@@ -13,18 +13,6 @@ QUIET_CONFIGURE=
 REALLY_QUIET=
 endif
 
-DOWNLOAD := $(shell which wget 2>/dev/null)
-DOWNLOAD := $(if $(DOWNLOAD),$(DOWNLOAD) -O- ,)
-
-ifeq ($(DOWNLOAD),)
-DOWNLOAD := $(shell which curl 2>/dev/null)
-DOWNLOAD := $(if $(DOWNLOAD), $(DOWNLOAD) -L ,)
-endif
-
-ifeq ($(DOWNLOAD),)
-DOWNLOAD := echo "No download program available" ; exit 1;
-endif
-
 export SUBMAKE
 export ECHO_PREFIX
 export CMD_PREFIX
@@ -34,3 +22,12 @@ export ASTTOPDIR
 export ASTSBINDIR
 export DESTDIR
 export ASTDATADIR
+export TAR
+export PATCH
+export SED
+export NM
+export MD5
+export CAT
+export DOWNLOAD
+export DOWNLOAD_TO_STDOUT
+export DOWNLOAD_TIMEOUT
diff -urpN asterisk-13.9.1/third-party/configure.m4 asterisk-13.17.0/third-party/configure.m4
--- asterisk-13.9.1/third-party/configure.m4	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/configure.m4	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,10 @@
+#
+# If this file is changed, be sure to run ASTTOPDIR/bootstrap.sh
+# before committing.
+#
+
+AC_DEFUN([THIRD_PARTY_CONFIGURE],
+[
+	PJPROJECT_CONFIGURE()
+])
+
diff -urpN asterisk-13.9.1/third-party/pjproject/.gitignore asterisk-13.17.0/third-party/pjproject/.gitignore
--- asterisk-13.9.1/third-party/pjproject/.gitignore	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/.gitignore	2017-07-12 13:12:08.000000000 +0200
@@ -2,3 +2,4 @@ source/
 **.bz2
 build.mak
 pjproject.symbols
+.rebuild_needed
diff -urpN asterisk-13.9.1/third-party/pjproject/Makefile asterisk-13.17.0/third-party/pjproject/Makefile
--- asterisk-13.9.1/third-party/pjproject/Makefile	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/Makefile	2017-07-12 13:12:08.000000000 +0200
@@ -1,15 +1,15 @@
-.SUFFIXES:
 .PHONY: _all all _install install clean distclean echo_cflags configure
 
+.NOTPARALLEL:
+
 include ../versions.mak
+export PJDIR := $(shell pwd -P)/source
 
 SPECIAL_TARGETS :=
 
 ifneq ($(findstring configure,$(MAKECMDGOALS))$(findstring echo_cflags,$(MAKECMDGOALS)),)
 # Run from $(ASTTOPDIR)/configure
     SPECIAL_TARGETS += configure
-    include ../Makefile.rules
-    include Makefile.rules
 endif
 
 ifeq ($(findstring echo_cflags,$(MAKECMDGOALS)),echo_cflags)
@@ -20,115 +20,201 @@ endif
 ifeq ($(findstring clean,$(MAKECMDGOALS)),clean)
 # clean or distclean
     SPECIAL_TARGETS += clean
-    include ../Makefile.rules
-    include Makefile.rules
 endif
 
+ifeq ($(findstring uninstall,$(MAKECMDGOALS)),uninstall)
+    SPECIAL_TARGETS += uninstall
+endif
+
+
+ifneq ($(wildcard ../../makeopts),)
+    include ../../makeopts
+endif
+
+TARGETS = build.mak
+
 ifeq ($(SPECIAL_TARGETS),)
 # Run locally or from $(ASTTOPDIR)/Makefile.  All include files should be present
     ifeq ($(wildcard ../../makeopts),)
         $(error ASTTOPDIR/configure hasn't been run)
     endif
-    include ../../makeopts
 
     ifeq ($(PJPROJECT_BUNDLED),yes)
-        -include ../../menuselect.makeopts
-        include ../Makefile.rules
+        ifneq ($(wildcard ../../menuselect.makeopts),)
+            include ../../menuselect.makeopts
+        else
+            $(warning ASTTOPDIR/menuselect hasn't been run yet.  Can't find debug options.)
+        endif
 
         all: _all
         install: _install
 
-        include ../../Makefile.rules
-        include Makefile.rules
-        include build.mak
+        include source/user.mak
+        include source/version.mak
+        include source/build.mak
         CF := $(filter-out -W%,$(CC_CFLAGS))
         CF := $(filter-out -I%,$(CF))
-        export CFLAGS += $(CF)
+        ifeq ($(findstring TEST_FRAMEWORK,$(MENUSELECT_CFLAGS)),TEST_FRAMEWORK)
+            apps := source/pjsip-apps/bin/pjsua-$(TARGET_NAME) source/pjsip-apps/bin/pjsystest-$(TARGET_NAME)
+            TARGETS += $(apps)
+            ifneq ($(PYTHONDEV_LIB),)
+                TARGETS += source/pjsip-apps/src/python/_pjsua.so
+            endif
+        endif
+        ifeq ($(findstring MALLOC_DEBUG,$(MENUSELECT_CFLAGS)),MALLOC_DEBUG)
+            CF += -DMALLOC_DEBUG
+            MALLOC_DEBUG_LIBS = source/pjsip-apps/lib/libasterisk_malloc_debug.a
+            MALLOC_DEBUG_LDFLAGS = -L$(PJDIR)/pjsip-apps/lib -Wl,-whole-archive -lasterisk_malloc_debug -Wl,-no-whole-archive
+        endif
+        ifeq ($(findstring DONT_OPTIMIZE,$(MENUSELECT_CFLAGS)),)
+            CF += -O3
+        endif
+        export CFLAGS += $(CF) -g3
         export LDFLAGS += $(CC_LDFLAGS)
+        TARGETS += pjproject.symbols
     else
         all install:
     endif
 endif
 
-ECHO_PREFIX := $(ECHO_PREFIX) echo '[pjproject] '
+include ../../Makefile.rules
+include ../Makefile.rules
+include Makefile.rules
 
-ifndef $(TMPDIR)
-    ifneq ($(wildcard /tmp),)
-        TMPDIR=/tmp
-    else
-        TMPDIR=.
-    endif
-endif
+ECHO_PREFIX := $(ECHO_PREFIX) echo '[pjproject] '
+SHELL_ECHO_PREFIX := echo '[pjproject] '
 
-$(TMPDIR)/pjproject-$(PJPROJECT_VERSION).tar.bz2 : ../versions.mak
-	$(ECHO_PREFIX) Downloading $@ with $(DOWNLOAD)
-	$(CMD_PREFIX) $(DOWNLOAD) $(PJPROJECT_URL)/$(@F) > $@
+_all: $(TARGETS)
 
-source/.unpacked: $(TMPDIR)/pjproject-$(PJPROJECT_VERSION).tar.bz2
+define verify_tarball
+	($(SHELL_ECHO_PREFIX) Verifying $(TARBALL) &&\
+	tarball_sum=$$($(CAT) $(TARBALL) | $(MD5) | $(SED) -n -r -e "s/^([^ ]+)\s+.*/\1/gp") ;\
+	required_sum=$$($(SED) -n -r -e "s/^([^ ]+)\s+$(TARBALL_FILE)/\1/gp" $(PJMD5SUM)) ;\
+	if [ "$$tarball_sum" != "$$required_sum" ] ; then $(SHELL_ECHO_PREFIX) Verify failed ; exit 1 ;\
+	else $(SHELL_ECHO_PREFIX) Verify successful ; exit 0 ; fi; )
+endef
+
+define download_from_pjproject
+	($(SHELL_ECHO_PREFIX) Downloading $(TARBALL_URL) to $(TARBALL) ;\
+	$(DOWNLOAD_TO_STDOUT) $(call DOWNLOAD_TIMEOUT,5,60) $(TARBALL_URL) > $(TARBALL) &&\
+	$(SHELL_ECHO_PREFIX) Downloading $(PJPROJECT_URL)/MD5SUM.TXT to $(PJMD5SUM) &&\
+	$(DOWNLOAD_TO_STDOUT) $(call DOWNLOAD_TIMEOUT,5,60) $(PJPROJECT_URL)/MD5SUM.TXT > $(PJMD5SUM) &&\
+	$(verify_tarball))
+endef
+
+.DELETE_ON_ERROR:
+
+DOWNLOAD_DIR := $(or $(EXTERNALS_CACHE_DIR),$(TMPDIR),$(wildcard /tmp),.)
+TARBALL_FILE = pjproject-$(PJPROJECT_VERSION).tar.bz2
+TARBALL = $(DOWNLOAD_DIR)/$(TARBALL_FILE)
+TARBALL_URL = $(PJPROJECT_URL)/$(TARBALL_FILE)
+PJMD5SUM = $(patsubst %.tar.bz2,%.md5,$(TARBALL))
+
+$(TARBALL): ../versions.mak
+	$(CMD_PREFIX) $(download_from_pjproject) || (rm -rf $@ ;\
+	$(SHELL_ECHO_PREFIX) Retrying download ; $(download_from_pjproject))
+
+source/.unpacked: $(DOWNLOAD_DIR)/pjproject-$(PJPROJECT_VERSION).tar.bz2
+	($(verify_tarball)) || (rm -rf $@ ;\
+	$(SHELL_ECHO_PREFIX) Retrying download ; $(download_from_pjproject))
 	$(ECHO_PREFIX) Unpacking $<
-	-@rm -rf source &>/dev/null
-	-@mkdir source &>/dev/null
-	$(CMD_PREFIX) tar --strip-components=1 -C source -xjf $<
+	-@rm -rf source pjproject-* >/dev/null 2>&1
+	$(CMD_PREFIX) $(TAR) -xjf $<
+	@mv pjproject-$(PJPROJECT_VERSION) source
 	$(ECHO_PREFIX) Applying patches
-	$(CMD_PREFIX) ./apply_patches $(QUIET_CONFIGURE) ./patches ./source
+	$(CMD_PREFIX) ./apply_patches $(QUIET_CONFIGURE) patches source
 	-@touch source/.unpacked
 
-source/user.mak: source/.unpacked ./patches/user.mak
-	$(ECHO_PREFIX) Applying user.mak
-	$(CMD_PREFIX) cp -f ./patches/user.mak ./source/
+source/version.mak: source/.unpacked
 
-source/pjlib/include/pj/config_site.h: source/.unpacked ./patches/config_site.h
-	$(ECHO_PREFIX) Applying config_site.h
-	$(CMD_PREFIX) cp -f ./patches/config_site.h ./source/pjlib/include/pj/
+source/user.mak: source/.unpacked patches/user.mak
+	$(ECHO_PREFIX) Applying user.mak
+	$(CMD_PREFIX) cp -f patches/user.mak source/
 
-build.mak: source/.unpacked source/pjlib/include/pj/config_site.h source/user.mak Makefile.rules
-	$(ECHO_PREFIX) Configuring with $(PJPROJECT_CONFIG_OPTS)
-	$(CMD_PREFIX) (cd source ; autoconf aconfigure.ac > aconfigure && ./aconfigure $(QUIET_CONFIGURE) $(PJPROJECT_CONFIG_OPTS))
-	@sed -r -e "/prefix|export PJ_SHARED_LIBRARIES|MACHINE_NAME|OS_NAME|HOST_NAME|CC_NAME|CROSS_COMPILE|LINUX_POLL/d" source/build.mak > build.mak
+source/pjlib/include/pj/%.h: patches/%.h
+	$(ECHO_PREFIX) Applying custom include file $<
+	$(CMD_PREFIX) cp -f $< source/pjlib/include/pj/
 
-configure: build.mak
+.rebuild_needed: $(wildcard ../../.lastclean)
+	$(ECHO_PREFIX) Rebuilding
+	$(CMD_PREFIX) $(MAKE) clean $(REALLY_QUIET)
 
-echo_cflags: build.mak
-	@echo $(PJ_CFLAGS)
+source/build.mak: Makefile.rules source/version.mak source/user.mak $(addprefix source/pjlib/include/pj/,$(notdir $(wildcard patches/*.h))) .rebuild_needed
+	$(ECHO_PREFIX) Configuring with $(PJPROJECT_CONFIG_OPTS)
+	$(CMD_PREFIX) (cd source ; ./aconfigure $(QUIET_CONFIGURE) $(PJPROJECT_CONFIG_OPTS))
 
-source/pjlib/build/.pjlib-$(TARGET_NAME).depend: build.mak
-	$(ECHO_PREFIX) "Making dependencies"
-	+$(CMD_PREFIX) $(SUBMAKE) -C source dep
+build.mak: source/build.mak
+	$(CMD_PREFIX) $(SED) -r -e "/prefix|export PJ_SHARED_LIBRARIES|MACHINE_NAME|OS_NAME|HOST_NAME|CC_NAME|CROSS_COMPILE|LINUX_POLL/d" source/build.mak > build.mak
 
+configure: source/build.mak
 
-menuselect: ../../menuselect.makeopts ../../makeopts
-	-$(CMD_PREFIX) test -d source && ($(SUBMAKE) -C source clean ; find source -name *.a -delete ; rm -rf source/pjsip-apps/src/python/build) || :
-	-$(CMD_PREFIX) rm -rf pjproject.symbols
+echo_cflags: source/build.mak
+	@echo $(PJ_CFLAGS)
 
+libpj%.a: source/build.mak
+	$(ECHO_PREFIX) Compiling lib $(@F)
+	$(CMD_PREFIX) $(MAKE) -C $(dir $(shell dirname $@))/build $(@F) $(REALLY_QUIET)
+
+# pjsua needs resample and g711 to successfully run the testsuite
+libresample%.a: source/build.mak
+	$(ECHO_PREFIX) Compiling lib $(@F)
+	$(CMD_PREFIX) $(MAKE) -C $(dir $(shell dirname $@))/build/resample all $(REALLY_QUIET)
+
+# We need to compile pjlib, then pjlib-util, then the rest
+# so we separate them out and create the dependencies
+PJLIB_LIB_FILES = $(foreach lib,$(PJ_LIB_FILES),$(if $(findstring libpj-,$(lib)),$(lib),))
+PJLIB_UTIL_LIB_FILES = $(foreach lib,$(PJ_LIB_FILES),$(if $(findstring libpjlib-util,$(lib)),$(lib),))
+PJSIP_LIB_FILES = $(filter-out $(PJLIB_LIB_FILES) $(PJLIB_UTIL_LIB_FILES) $(APP_THIRD_PARTY_LIB_FILES),$(PJ_LIB_FILES))
+ALL_LIB_FILES = $(PJLIB_LIB_FILES) $(PJLIB_UTIL_LIB_FILES) $(PJSIP_LIB_FILES)
 
-source/pjlib/lib/libpj-$(TARGET_NAME).a: menuselect source/pjlib/build/.pjlib-$(TARGET_NAME).depend
-	$(ECHO_PREFIX) Compiling libs
-	+$(CMD_PREFIX) $(SUBMAKE) -C source lib $(REALLY_QUIET)
+$(PJLIB_UTIL_LIB_FILES): $(PJLIB_LIB_FILES)
+$(PJSIP_LIB_FILES): $(PJLIB_UTIL_LIB_FILES)
 
-pjproject.symbols: source/pjlib/lib/libpj-$(TARGET_NAME).a
+pjproject.symbols: $(ALL_LIB_FILES)
 	$(ECHO_PREFIX) Generating symbols
-	$(CMD_PREFIX) nm -Pog $(PJ_LIB_FILES) | sed -n -r -e "s/.+: ([pP][jJ][^ ]+) .+/\1/gp" | sort -u > pjproject.symbols
+	$(CMD_PREFIX) $(NM) -Pog $(ALL_LIB_FILES) | $(SED) -n -r -e "s/.+: ([pP][jJ][^ ]+) .+/\1/gp" | sort -u > pjproject.symbols
 
-source/pjsip-apps/bin/pjsua-$(TARGET_NAME): source/pjlib/lib/libpj-$(TARGET_NAME).a
-	$(ECHO_PREFIX) Compiling apps
-	$(CMD_PREFIX) $(SUBMAKE) -C source/pjsip-apps/build pjsua pjsystest $(REALLY_QUIET)
+source/pjsip-apps/src/asterisk_malloc_debug.c: patches/asterisk_malloc_debug.c
+	$(ECHO_PREFIX) Copying $< to $@
+	$(CMD_PREFIX) cp -f $< $@
+
+source/pjsip-apps/lib/asterisk_malloc_debug.o: source/pjsip-apps/src/asterisk_malloc_debug.c .rebuild_needed
+	$(ECHO_PREFIX) Compiling asterisk debug malloc stubs
+	$(CMD_PREFIX) $(CC) -fPIC  $(PJ_CFLAGS) -c $< -o $@
+
+source/pjsip-apps/lib/libasterisk_malloc_debug.a: source/pjsip-apps/lib/asterisk_malloc_debug.o
+	$(ECHO_PREFIX) Creating archive $(@F)
+	$(CMD_PREFIX) ar qs $@ $< >/dev/null 2>&1
+
+$(apps): APP = $(filter pj%,$(subst -, ,$(notdir $@)))
+$(apps): LDFLAGS += $(MALLOC_DEBUG_LDFLAGS)
+$(apps): $(MALLOC_DEBUG_LIBS) pjproject.symbols $(APP_THIRD_PARTY_LIB_FILES)
+	$(ECHO_PREFIX) Compiling $(APP)
+	$(CMD_PREFIX) +$(MAKE) -C source/pjsip-apps/build $(filter pj%,$(subst -, ,$(notdir $@))) $(REALLY_QUIET)
 
-source/pjsip-apps/src/python/build/_pjsua.so: source/pjlib/lib/libpj-$(TARGET_NAME).a
+source/pjsip-apps/src/python/_pjsua.o: source/pjsip-apps/src/python/_pjsua.c $(apps)
 	$(ECHO_PREFIX) Compiling python bindings
-	$(CMD_PREFIX) (cd source/pjsip-apps/src/python ; python setup.py build --build-platlib=./build $(REALLY_QUIET))
-
+	$(CMD_PREFIX) $(CC) -o $@ -c $< $(PYTHONDEV_INCLUDE) $(CFLAGS) $(PJ_CFLAGS)
 
-_all: pjproject.symbols source/pjsip-apps/bin/pjsua-$(TARGET_NAME) source/pjsip-apps/src/python/build/_pjsua.so
+source/pjsip-apps/src/python/_pjsua.so: LDFLAGS += $(MALLOC_DEBUG_LDFLAGS)
+source/pjsip-apps/src/python/_pjsua.so: source/pjsip-apps/src/python/_pjsua.o
+	$(ECHO_PREFIX) Linking python bindings $(@F)
+	$(CMD_PREFIX) gcc -shared -pthread -o $@ $< $(LDFLAGS) $(PJ_LDFLAGS) $(APP_LDLIBS) $(PYTHONDEV_LIB) $(REALLY_QUIET)
 
 _install: _all
-	$(ECHO_PREFIX) Installing apps and python bindings
 	@if [ ! -d "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject" ]; then \
 		$(INSTALL) -d "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject"; \
 	fi;
+ifneq ($(findstring source/pjsip-apps/bin/pjsua-$(TARGET_NAME),$(TARGETS)),)
+	$(ECHO_PREFIX) Installing apps
 	$(CMD_PREFIX) $(INSTALL) -m 755 source/pjsip-apps/bin/pjsua-$(TARGET_NAME) "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject/pjsua"
 	$(CMD_PREFIX) $(INSTALL) -m 755 source/pjsip-apps/bin/pjsystest-$(TARGET_NAME) "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject/pjsystest"
-	$(CMD_PREFIX) $(INSTALL) -m 755 source/pjsip-apps/src/python/build/_pjsua.so "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject/"
-	$(CMD_PREFIX) $(INSTALL) -m 644 source/pjsip-apps/src/python/build/pjsua.py "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject/"
+endif
+ifneq ($(findstring _pjsua.so,$(TARGETS)),)
+	$(ECHO_PREFIX) Installing python bindings
+	$(CMD_PREFIX) $(INSTALL) -m 755 source/pjsip-apps/src/python/_pjsua.so "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject/"
+	$(CMD_PREFIX) $(INSTALL) -m 644 source/pjsip-apps/src/python/pjsua.py "$(DESTDIR)$(ASTDATADIR)/third-party/pjproject/"
+endif
 
 uninstall:
 	$(ECHO_PREFIX) Uninstalling apps and python bindings
@@ -136,10 +222,13 @@ uninstall:
 
 clean:
 	$(ECHO_PREFIX) Cleaning
-	-$(CMD_PREFIX) test -d source && ($(SUBMAKE) -C source clean ; find source -name *.a -delete ; rm -rf source/pjsip-apps/src/python/build) || :
+	+-$(CMD_PREFIX) test -d source && ($(SUBMAKE) -C source clean || : ;\
+		rm -rf source/pjsip-apps/bin/* || : ;\
+		find source -name *.a | xargs rm -rf  ;\
+		find source -name *.o | xargs rm -rf  ;\
+		find source -name *.so  | xargs rm -rf ; ) || :
 	-$(CMD_PREFIX) rm -rf pjproject.symbols
 
 distclean:
 	$(ECHO_PREFIX) Distcleaning
-	-$(CMD_PREFIX) rm -rf source pjproject.symbols pjproject-*.tar.bz2 build.mak
-
+	-$(CMD_PREFIX) rm -rf source pjproject.symbols pjproject-*.tar.bz2 build.mak .rebuild_needed
diff -urpN asterisk-13.9.1/third-party/pjproject/Makefile.rules asterisk-13.17.0/third-party/pjproject/Makefile.rules
--- asterisk-13.9.1/third-party/pjproject/Makefile.rules	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/Makefile.rules	2017-07-12 13:12:08.000000000 +0200
@@ -1,7 +1,41 @@
-PJPROJECT_URL = http://www.pjsip.org/release/$(PJPROJECT_VERSION)
+PJPROJECT_URL ?= https://raw.githubusercontent.com/asterisk/third-party/master/pjproject/$(PJPROJECT_VERSION)
 
+# PJPROJECT_CONFIGURE_OPTS could come from the command line or could be
+# set/modified by configure.m4 if the build or host tuples aren't the same
+# as the current build environment (cross-compile).
 # Even though we're not installing pjproject, we're setting prefix to /opt/pjproject to be safe
-PJPROJECT_CONFIG_OPTS = --prefix=/opt/pjproject --with-external-speex --with-external-gsm --with-external-srtp \
-	--disable-video --disable-v4l2 --disable-sound --disable-opencore-amr --disable-ilbc-codec \
-	--without-libyuv --disable-g7221-codec \
-	--enable-epoll
+
+PJPROJECT_CONFIG_OPTS = $(PJPROJECT_CONFIGURE_OPTS) --prefix=/opt/pjproject \
+	--disable-speex-codec \
+	--disable-speex-aec \
+	--disable-speex-aec \
+	--disable-gsm-codec \
+	--disable-ilbc-codec \
+	--disable-l16-codec \
+	--disable-g722-codec \
+	--disable-g7221-codec \
+	--disable-opencore-amr \
+	--disable-silk \
+	--disable-opus \
+	--disable-video \
+	--disable-v4l2 \
+	--disable-sound \
+	--disable-ext-sound \
+	--disable-oss \
+	--disable-sdl \
+	--disable-libyuv \
+	--disable-ffmpeg \
+	--disable-openh264 \
+	--disable-ipp \
+	--disable-libwebrtc \
+	--without-external-pa \
+	--without-external-srtp \
+	--without-external-webrtc
+
+ifeq ($(findstring TEST_FRAMEWORK,$(MENUSELECT_CFLAGS)),)
+    PJPROJECT_CONFIG_OPTS += --disable-resample --disable-g711-codec
+endif
+
+ifeq ($(shell uname -s),Linux)
+    PJPROJECT_CONFIG_OPTS +=  --enable-epoll
+endif
diff -urpN asterisk-13.9.1/third-party/pjproject/apply_patches asterisk-13.17.0/third-party/pjproject/apply_patches
--- asterisk-13.9.1/third-party/pjproject/apply_patches	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/apply_patches	2017-07-12 13:12:08.000000000 +0200
@@ -1,10 +1,12 @@
-#!/bin/bash
+#!/bin/sh
 
 if [ "$1" = "-q" ] ; then
 	quiet=1
 	shift
 fi
 
+PATCH=${PATCH:-patch}
+
 patchdir=${1:?You must supply a patches directory}
 sourcedir=${2?:You must supply a source directory}
 
@@ -26,13 +28,9 @@ if [ ! "$(ls -A $patchdir/*.patch 2>/dev
 	exit 0
 fi
 
-for patchfile in $patchdir/*.patch ; do
-	patch -d $sourcedir -p1 -s -r- -f -N --dry-run -i "$patchfile" || (echo "Patchfile $(basename $patchfile) failed to apply >&2" ; exit 1) || exit 1
-done
-
 for patchfile in "$patchdir"/*.patch ; do
 	[ -z $quiet ] && echo "Applying patch $(basename $patchfile)"
-	patch -d "$sourcedir" -p1 -s -i "$patchfile" || exit 1
+	${PATCH} -d "$sourcedir" -p1 -s -i "$patchfile" || exit 1
 done
 
 exit 0
diff -urpN asterisk-13.9.1/third-party/pjproject/configure.m4 asterisk-13.17.0/third-party/pjproject/configure.m4
--- asterisk-13.9.1/third-party/pjproject/configure.m4	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/configure.m4	2017-07-12 13:12:08.000000000 +0200
@@ -1,47 +1,99 @@
-AC_DEFUN([PJPROJECT_SYMBOL_CHECK],
-[
-	$1_INCLUDE="$PJPROJECT_INCLUDE"
-    AC_MSG_CHECKING([for $2 declared in $3])
+#
+# If this file is changed, be sure to run ASTTOPDIR/bootstrap.sh
+# before committing.
+#
 
-	saved_cpp="$CPPFLAGS"
-	CPPFLAGS="$PJPROJECT_INCLUDE"
-	AC_EGREP_HEADER($2, $3, [
-		AC_MSG_RESULT(yes)
-		PBX_$1=1
-		AC_DEFINE([HAVE_$1], 1, [Define if your system has $2 declared.])
-	], [
-		AC_MSG_RESULT(no)
-	])
+AC_DEFUN([_PJPROJECT_CONFIGURE],
+[
+	if test "${ac_mandatory_list#*PJPROJECT*}" != "$ac_mandatory_list" ; then
+		AC_MSG_ERROR(--with-pjproject and --with-pjproject-bundled can't both be specified)
+	fi
 
-	CPPGLAGS="$saved_cpp"
-	$1_INCLUDE="$PJPROJECT_INCLUDE"
-])
+	ac_mandatory_list="$ac_mandatory_list PJPROJECT"
+	PJPROJECT_DIR="${ac_top_build_prefix}third-party/pjproject"
 
-AC_DEFUN([PJPROJECT_CONFIGURE],
-[
 	AC_MSG_CHECKING(for embedded pjproject (may have to download))
 	AC_MSG_RESULT(configuring)
-	make --quiet --no-print-directory -C $1 configure
+
+	if test "x${DOWNLOAD_TO_STDOUT}" = "x" ; then
+		AC_MSG_ERROR(A download utility (wget, curl or fetch) is required to download bundled pjproject)
+	fi
+	if test "${BZIP2}" = ":" ; then
+		AC_MSG_ERROR(bzip2 is required to extract the pjproject tar file)
+	fi
+	if test "${TAR}" = ":" ; then
+		AC_MSG_ERROR(tar is required to extract the pjproject tar file)
+	fi
+	if test "${PATCH}" = ":" ; then
+		AC_MSG_ERROR(patch is required to configure bundled pjproject)
+	fi
+	if test "${SED}" = ":" ; then
+		AC_MSG_ERROR(sed is required to configure bundled pjproject)
+	fi
+	if test "${NM}" = ":" ; then
+		AC_MSG_ERROR(nm is required to build bundled pjproject)
+	fi
+	if test "${MD5}" = ":" ; then
+		AC_MSG_ERROR(md5sum is required to build bundled pjproject)
+	fi
+	if test "${CAT}" = ":" ; then
+		AC_MSG_ERROR(cat is required to build bundled pjproject)
+	fi
+
+	AC_ARG_VAR([PJPROJECT_CONFIGURE_OPTS],[Additional configure options to pass to bundled pjproject])
+	this_host=$(./config.sub $(./config.guess))
+	if test "$build" != "$this_host" ; then
+		PJPROJECT_CONFIGURE_OPTS+=" --build=$build"
+	fi
+	if test "$host" != "$this_host" ; then
+		PJPROJECT_CONFIGURE_OPTS+=" --host=$host"
+	fi
+
+	export TAR PATCH SED NM EXTERNALS_CACHE_DIR DOWNLOAD_TO_STDOUT DOWNLOAD_TIMEOUT DOWNLOAD MD5 CAT
+	export NOISY_BUILD
+	${GNU_MAKE} --quiet --no-print-directory -C ${PJPROJECT_DIR} \
+		PJPROJECT_CONFIGURE_OPTS="$PJPROJECT_CONFIGURE_OPTS" \
+		EXTERNALS_CACHE_DIR="${EXTERNALS_CACHE_DIR}" \
+		configure
 	if test $? -ne 0 ; then
 		AC_MSG_RESULT(failed)
-		AC_MSG_NOTICE(Unable to configure $1)
-		AC_MSG_ERROR(Run "make -C $1 NOISY_BUILD=yes configure" to see error details.)
+		AC_MSG_NOTICE(Unable to configure ${PJPROJECT_DIR})
+		AC_MSG_ERROR(Re-run the ./configure command with 'NOISY_BUILD=yes' appended to see error details.)
 	fi
 
-	PJPROJECT_INCLUDE=$(make --quiet --no-print-directory -C $1 echo_cflags)
+	AC_MSG_CHECKING(for bundled pjproject)
+
+	PJPROJECT_INCLUDE=$(${GNU_MAKE} --quiet --no-print-directory -C ${PJPROJECT_DIR} PJPROJECT_CONFIGURE_OPTS="$PJPROJECT_CONFIGURE_OPTS" EXTERNALS_CACHE_DIR="${EXTERNALS_CACHE_DIR}" echo_cflags)
 	PJPROJECT_CFLAGS="$PJPROJECT_INCLUDE"
 	PBX_PJPROJECT=1
-	PJPROJECT_BUNDLED=yes
+
 	AC_DEFINE([HAVE_PJPROJECT], 1, [Define if your system has PJPROJECT])
 	AC_DEFINE([HAVE_PJPROJECT_BUNDLED], 1, [Define if your system has PJPROJECT_BUNDLED])
-	AC_MSG_CHECKING(for embedded pjproject)
-	AC_MSG_RESULT(yes)
 
-	PJPROJECT_SYMBOL_CHECK([PJSIP_DLG_CREATE_UAS_AND_INC_LOCK], [pjsip_dlg_create_uas_and_inc_lock], [pjsip.h])
-	PJPROJECT_SYMBOL_CHECK([PJ_TRANSACTION_GRP_LOCK], [pjsip_tsx_create_uac2], [pjsip.h])
-	PJPROJECT_SYMBOL_CHECK([PJSIP_REPLACE_MEDIA_STREAM], [PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE], [pjmedia.h])
-	PJPROJECT_SYMBOL_CHECK([PJSIP_GET_DEST_INFO], [pjsip_get_dest_info], [pjsip.h])
-	PJPROJECT_SYMBOL_CHECK([PJ_SSL_CERT_LOAD_FROM_FILES2], [pj_ssl_cert_load_from_files2], [pjlib.h])
-	PJPROJECT_SYMBOL_CHECK([PJSIP_EXTERNAL_RESOLVER], [pjsip_endpt_set_ext_resolver], [pjsip.h])
+	AC_DEFINE([HAVE_PJSIP_DLG_CREATE_UAS_AND_INC_LOCK], 1, [Define if your system has pjsip_dlg_create_uas_and_inc_lock declared.])
+	AC_DEFINE([HAVE_PJ_TRANSACTION_GRP_LOCK], 1, [Define if your system has pjsip_tsx_create_uac2 declared.])
+	AC_DEFINE([HAVE_PJSIP_REPLACE_MEDIA_STREAM], 1, [Define if your system has PJSIP_REPLACE_MEDIA_STREAM declared])
+	AC_DEFINE([HAVE_PJSIP_GET_DEST_INFO], 1, [Define if your system has pjsip_get_dest_info declared.])
+	AC_DEFINE([HAVE_PJ_SSL_CERT_LOAD_FROM_FILES2], 1, [Define if your system has pj_ssl_cert_load_from_files2 declared.])
+	AC_DEFINE([HAVE_PJSIP_EXTERNAL_RESOLVER], 1, [Define if your system has pjsip_endpt_set_ext_resolver declared.])
 	AC_DEFINE([HAVE_PJSIP_TLS_TRANSPORT_PROTO], 1, [Define if your system has PJSIP_TLS_TRANSPORT_PROTO])
+	AC_DEFINE([HAVE_PJSIP_EVSUB_GRP_LOCK], 1, [Define if your system has PJSIP_EVSUB_GRP_LOCK])
+	AC_DEFINE([HAVE_PJSIP_INV_SESSION_REF], 1, [Define if your system has PJSIP_INV_SESSION_REF])
+	AC_DEFINE([HAVE_PJSIP_AUTH_CLT_DEINIT], 1, [Define if your system has pjsip_auth_clt_deinit declared.])
+	AC_DEFINE([HAVE_PJSIP_EVSUB_SET_UAS_TIMEOUT], 1, [Define if your system has pjsip_evsub_set_uas_timeout declared.])
+	AC_DEFINE([HAVE_PJSIP_TSX_LAYER_FIND_TSX2], 1, [Define if your system has pjsip_tsx_layer_find_tsx2 declared.])
+
+	AC_SUBST([PJPROJECT_BUNDLED])
+	AC_SUBST([PJPROJECT_DIR])
+	AC_SUBST([PBX_PJPROJECT])
+	AC_SUBST([PJPROJECT_LIB])
+	AC_SUBST([PJPROJECT_INCLUDE])
+	AC_MSG_RESULT(yes)
+])
+
+AC_DEFUN([PJPROJECT_CONFIGURE],
+[
+	if test "$PJPROJECT_BUNDLED" = "yes" ; then
+		_PJPROJECT_CONFIGURE()
+	fi
 ])
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0000-remove-third-party.patch asterisk-13.17.0/third-party/pjproject/patches/0000-remove-third-party.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0000-remove-third-party.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0000-remove-third-party.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,131 @@
+diff --git a/build.mak.in b/build.mak.in
+index eb28663..83024ef 100644
+--- a/build.mak.in
++++ b/build.mak.in
+@@ -1,6 +1,5 @@
+-export PJDIR := @ac_pjdir@
+ include $(PJDIR)/version.mak
+ export PJ_DIR := $(PJDIR)
+ 
+ # @configure_input@
+ export MACHINE_NAME := auto
+@@ -28,19 +27,6 @@ export APP_THIRD_PARTY_EXT :=
+ export APP_THIRD_PARTY_LIBS :=
+ export APP_THIRD_PARTY_LIB_FILES :=
+ 
+-ifeq (@ac_external_srtp@,1)
+-# External SRTP library
+-APP_THIRD_PARTY_EXT += -lsrtp
+-else
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libsrtp-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lsrtp-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lsrtp
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libsrtp.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libsrtp.$(SHLIB_SUFFIX)
+-endif
+-endif
+-
+ ifeq (@ac_pjmedia_resample@,libresample)
+ APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libresample-$(LIB_SUFFIX)
+ ifeq ($(PJ_SHARED_LIBRARIES),)
+@@ -57,99 +43,6 @@ APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libresample.$(SHLIB_SUFFI
+ endif
+ endif
+ 
+-ifneq (@ac_no_gsm_codec@,1)
+-ifeq (@ac_external_gsm@,1)
+-# External GSM library
+-APP_THIRD_PARTY_EXT += -lgsm
+-else
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libgsmcodec-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lgsmcodec-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lgsmcodec
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libgsmcodec.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libgsmcodec.$(SHLIB_SUFFIX)
+-endif
+-endif
+-endif
+-
+-ifneq (@ac_no_speex_codec@,1)
+-ifeq (@ac_external_speex@,1)
+-APP_THIRD_PARTY_EXT += -lspeex -lspeexdsp
+-else
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libspeex-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lspeex-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lspeex
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libspeex.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libspeex.$(SHLIB_SUFFIX)
+-endif
+-endif
+-endif
+-
+-ifneq (@ac_no_ilbc_codec@,1)
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libilbccodec-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lilbccodec-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lilbccodec
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libilbccodec.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libilbccodec.$(SHLIB_SUFFIX)
+-endif
+-endif
+-
+-ifneq (@ac_no_g7221_codec@,1)
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libg7221codec-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lg7221codec-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lg7221codec
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libg7221codec.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libg7221codec.$(SHLIB_SUFFIX)
+-endif
+-endif
+-
+-ifneq ($(findstring pa,@ac_pjmedia_snd@),)
+-ifeq (@ac_external_pa@,1)
+-# External PA
+-APP_THIRD_PARTY_EXT += -lportaudio
+-else
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libportaudio-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lportaudio-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lportaudio
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libportaudio.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libportaudio.$(SHLIB_SUFFIX)
+-endif
+-endif
+-endif
+-
+-ifneq (@ac_no_yuv@,1)
+-ifeq (@ac_external_yuv@,1)
+-APP_THIRD_PARTY_EXT += -lyuv
+-else
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libyuv-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lyuv-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lyuv
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libyuv.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libyuv.$(SHLIB_SUFFIX)
+-endif
+-endif
+-endif
+-
+-ifneq (@ac_no_webrtc@,1)
+-ifeq (@ac_external_webrtc@,1)
+-APP_THIRD_PARTY_EXT += -lwebrtc
+-else
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libwebrtc-$(LIB_SUFFIX)
+-ifeq ($(PJ_SHARED_LIBRARIES),)
+-APP_THIRD_PARTY_LIBS += -lwebrtc-$(TARGET_NAME)
+-else
+-APP_THIRD_PARTY_LIBS += -lwebrtc
+-APP_THIRD_PARTY_LIB_FILES += $(PJ_DIR)/third_party/lib/libwebrtc.$(SHLIB_SUFFIX).$(PJ_VERSION_MAJOR) $(PJ_DIR)/third_party/lib/libwebrtc.$(SHLIB_SUFFIX)
+-endif
+-endif
+-endif
+-
+-
+ # Additional flags
+ @ac_build_mak_vars@
+ 
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0000-set_apps_initial_log_level.patch asterisk-13.17.0/third-party/pjproject/patches/0000-set_apps_initial_log_level.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0000-set_apps_initial_log_level.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0000-set_apps_initial_log_level.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,39 @@
+diff --git a/pjsip-apps/src/pjsua/main.c b/pjsip-apps/src/pjsua/main.c
+index 2baaf82..11831f2 100644
+--- a/pjsip-apps/src/pjsua/main.c
++++ b/pjsip-apps/src/pjsua/main.c
+@@ -126,5 +126,7 @@ int main_func(int argc, char *argv[])
+ 
+ int main(int argc, char *argv[])
+ {
++    pj_log_set_level(1);
++
+     return pj_run_app(&main_func, argc, argv, 0);
+ }
+diff --git a/pjsip-apps/src/pjsystest/main_console.c b/pjsip-apps/src/pjsystest/main_console.c
+index 122cdc7..dc79eab 100644
+--- a/pjsip-apps/src/pjsystest/main_console.c
++++ b/pjsip-apps/src/pjsystest/main_console.c
+@@ -133,6 +133,8 @@ void gui_sleep(unsigned sec)
+ 
+ int main()
+ {
++    pj_log_set_level(1);
++
+     if (systest_init() != PJ_SUCCESS)
+ 	return 1;
+ 
+diff --git a/pjsip-apps/src/python/_pjsua.c b/pjsip-apps/src/python/_pjsua.c
+index fb80e23..c9b21d8 100644
+--- a/pjsip-apps/src/python/_pjsua.c
++++ b/pjsip-apps/src/python/_pjsua.c
+@@ -4437,7 +4437,8 @@ init_pjsua(void)
+     PyObject* m = NULL;
+ #define ADD_CONSTANT(mod,name)	PyModule_AddIntConstant(mod,#name,name)
+ 
+-    
++    pj_log_set_level(1);
++
+     PyEval_InitThreads();
+ 
+     if (PyType_Ready(&PyTyp_pjsua_callback) < 0)
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0001-2.4.5-fix-for-tls-async-ops.patch asterisk-13.17.0/third-party/pjproject/patches/0001-2.4.5-fix-for-tls-async-ops.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0001-2.4.5-fix-for-tls-async-ops.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0001-2.4.5-fix-for-tls-async-ops.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,224 +0,0 @@
-diff --git a/pjlib/include/pj/ssl_sock.h b/pjlib/include/pj/ssl_sock.h
-index 1682bda..a69af32 100644
---- a/pjlib/include/pj/ssl_sock.h
-+++ b/pjlib/include/pj/ssl_sock.h
-@@ -864,6 +864,18 @@ PJ_DECL(void) pj_ssl_sock_param_default(pj_ssl_sock_param *param);
- 
- 
- /**
-+ * Duplicate pj_ssl_sock_param.
-+ *
-+ * @param pool	Pool to allocate memory.
-+ * @param dst	Destination parameter.
-+ * @param src	Source parameter.
-+ */
-+PJ_DECL(void) pj_ssl_sock_param_copy(pj_pool_t *pool, 
-+				     pj_ssl_sock_param *dst,
-+				     const pj_ssl_sock_param *src);
-+
-+
-+/**
-  * Create secure socket instance.
-  *
-  * @param pool		The pool for allocating secure socket instance.
-@@ -1115,6 +1127,30 @@ PJ_DECL(pj_status_t) pj_ssl_sock_start_accept(pj_ssl_sock_t *ssock,
- 
- 
- /**
-+ * Same as #pj_ssl_sock_start_accept(), but application can provide
-+ * a secure socket parameter, which will be used to create a new secure
-+ * socket reported in \a on_accept_complete() callback when there is
-+ * an incoming connection.
-+ *
-+ * @param ssock		The secure socket.
-+ * @param pool		Pool used to allocate some internal data for the
-+ *			operation.
-+ * @param localaddr	Local address to bind on.
-+ * @param addr_len	Length of buffer containing local address.
-+ * @param newsock_param	Secure socket parameter for new accepted sockets.
-+ *
-+ * @return		PJ_SUCCESS if the operation has been successful,
-+ *			or the appropriate error code on failure.
-+ */
-+PJ_DECL(pj_status_t)
-+pj_ssl_sock_start_accept2(pj_ssl_sock_t *ssock,
-+			  pj_pool_t *pool,
-+			  const pj_sockaddr_t *local_addr,
-+			  int addr_len,
-+			  const pj_ssl_sock_param *newsock_param);
-+
-+
-+/**
-  * Starts asynchronous socket connect() operation and SSL/TLS handshaking 
-  * for this socket. Once the connection is done (either successfully or not),
-  * the \a on_connect_complete() callback will be called.
-diff --git a/pjlib/src/pj/ssl_sock_common.c b/pjlib/src/pj/ssl_sock_common.c
-index 913efee..717ab1d 100644
---- a/pjlib/src/pj/ssl_sock_common.c
-+++ b/pjlib/src/pj/ssl_sock_common.c
-@@ -19,6 +19,7 @@
- #include <pj/ssl_sock.h>
- #include <pj/assert.h>
- #include <pj/errno.h>
-+#include <pj/pool.h>
- #include <pj/string.h>
- 
- /*
-@@ -48,6 +49,31 @@ PJ_DEF(void) pj_ssl_sock_param_default(pj_ssl_sock_param *param)
- }
- 
- 
-+/*
-+ * Duplicate SSL socket parameter.
-+ */
-+PJ_DEF(void) pj_ssl_sock_param_copy( pj_pool_t *pool, 
-+				     pj_ssl_sock_param *dst,
-+				     const pj_ssl_sock_param *src)
-+{
-+    /* Init secure socket param */
-+    pj_memcpy(dst, src, sizeof(*dst));
-+    if (src->ciphers_num > 0) {
-+	unsigned i;
-+	dst->ciphers = (pj_ssl_cipher*)
-+			pj_pool_calloc(pool, src->ciphers_num, 
-+				       sizeof(pj_ssl_cipher));
-+	for (i = 0; i < src->ciphers_num; ++i)
-+	    dst->ciphers[i] = src->ciphers[i];
-+    }
-+
-+    if (src->server_name.slen) {
-+        /* Server name must be null-terminated */
-+        pj_strdup_with_null(pool, &dst->server_name, &src->server_name);
-+    }
-+}
-+
-+
- PJ_DEF(pj_status_t) pj_ssl_cert_get_verify_status_strings(
- 						pj_uint32_t verify_status, 
- 						const char *error_strings[],
-diff --git a/pjlib/src/pj/ssl_sock_ossl.c b/pjlib/src/pj/ssl_sock_ossl.c
-index 40a5a1e..6a701b7 100644
---- a/pjlib/src/pj/ssl_sock_ossl.c
-+++ b/pjlib/src/pj/ssl_sock_ossl.c
-@@ -141,6 +141,7 @@ struct pj_ssl_sock_t
-     pj_pool_t		 *pool;
-     pj_ssl_sock_t	 *parent;
-     pj_ssl_sock_param	  param;
-+    pj_ssl_sock_param	  newsock_param;
-     pj_ssl_cert_t	 *cert;
-     
-     pj_ssl_cert_info	  local_cert_info;
-@@ -1757,11 +1758,9 @@ static pj_bool_t asock_on_accept_complete (pj_activesock_t *asock,
-     unsigned i;
-     pj_status_t status;
- 
--    PJ_UNUSED_ARG(src_addr_len);
--
-     /* Create new SSL socket instance */
--    status = pj_ssl_sock_create(ssock_parent->pool, &ssock_parent->param,
--				&ssock);
-+    status = pj_ssl_sock_create(ssock_parent->pool,
-+    				&ssock_parent->newsock_param, &ssock);
-     if (status != PJ_SUCCESS)
- 	goto on_return;
- 
-@@ -2183,20 +2182,8 @@ PJ_DEF(pj_status_t) pj_ssl_sock_create (pj_pool_t *pool,
- 	return status;
- 
-     /* Init secure socket param */
--    ssock->param = *param;
-+    pj_ssl_sock_param_copy(pool, &ssock->param, param);
-     ssock->param.read_buffer_size = ((ssock->param.read_buffer_size+7)>>3)<<3;
--    if (param->ciphers_num > 0) {
--	unsigned i;
--	ssock->param.ciphers = (pj_ssl_cipher*)
--			       pj_pool_calloc(pool, param->ciphers_num, 
--					      sizeof(pj_ssl_cipher));
--	for (i = 0; i < param->ciphers_num; ++i)
--	    ssock->param.ciphers[i] = param->ciphers[i];
--    }
--
--    /* Server name must be null-terminated */
--    pj_strdup_with_null(pool, &ssock->param.server_name, 
--			&param->server_name);
- 
-     /* Finally */
-     *p_ssock = ssock;
-@@ -2617,12 +2604,36 @@ PJ_DEF(pj_status_t) pj_ssl_sock_start_accept (pj_ssl_sock_t *ssock,
- 					      const pj_sockaddr_t *localaddr,
- 					      int addr_len)
- {
-+    return pj_ssl_sock_start_accept2(ssock, pool, localaddr, addr_len,
-+    				     &ssock->param);
-+}
-+
-+
-+/**
-+ * Same as #pj_ssl_sock_start_accept(), but application provides parameter
-+ * for new accepted secure sockets.
-+ */
-+PJ_DEF(pj_status_t)
-+pj_ssl_sock_start_accept2(pj_ssl_sock_t *ssock,
-+			  pj_pool_t *pool,
-+			  const pj_sockaddr_t *localaddr,
-+			  int addr_len,
-+			  const pj_ssl_sock_param *newsock_param)
-+{
-     pj_activesock_cb asock_cb;
-     pj_activesock_cfg asock_cfg;
-     pj_status_t status;
- 
-     PJ_ASSERT_RETURN(ssock && pool && localaddr && addr_len, PJ_EINVAL);
- 
-+    /* Verify new socket parameters */
-+    if (newsock_param->grp_lock != ssock->param.grp_lock ||
-+        newsock_param->sock_af != ssock->param.sock_af ||
-+        newsock_param->sock_type != ssock->param.sock_type)
-+    {
-+        return PJ_EINVAL;
-+    }
-+
-     /* Create socket */
-     status = pj_sock_socket(ssock->param.sock_af, ssock->param.sock_type, 0, 
- 			    &ssock->sock);
-@@ -2691,6 +2702,7 @@ PJ_DEF(pj_status_t) pj_ssl_sock_start_accept (pj_ssl_sock_t *ssock,
- 	goto on_error;
- 
-     /* Start accepting */
-+    pj_ssl_sock_param_copy(pool, &ssock->newsock_param, newsock_param);
-     status = pj_activesock_start_accept(ssock->asock, pool);
-     if (status != PJ_SUCCESS)
- 	goto on_error;
-diff --git a/pjsip/src/pjsip/sip_transport_tls.c b/pjsip/src/pjsip/sip_transport_tls.c
-index a9e95fb..91d99a7 100644
---- a/pjsip/src/pjsip/sip_transport_tls.c
-+++ b/pjsip/src/pjsip/sip_transport_tls.c
-@@ -314,7 +314,7 @@ PJ_DEF(pj_status_t) pjsip_tls_transport_start2( pjsip_endpoint *endpt,
-     int af, sip_ssl_method;
-     pj_uint32_t sip_ssl_proto;
-     struct tls_listener *listener;
--    pj_ssl_sock_param ssock_param;
-+    pj_ssl_sock_param ssock_param, newsock_param;
-     pj_sockaddr *listener_addr;
-     pj_bool_t has_listener;
-     pj_status_t status;
-@@ -473,9 +473,14 @@ PJ_DEF(pj_status_t) pjsip_tls_transport_start2( pjsip_endpoint *endpt,
-      */
-     has_listener = PJ_FALSE;
- 
--    status = pj_ssl_sock_start_accept(listener->ssock, pool, 
-+    pj_memcpy(&newsock_param, &ssock_param, sizeof(newsock_param));
-+    newsock_param.async_cnt = 1;
-+    newsock_param.cb.on_data_read = &on_data_read;
-+    newsock_param.cb.on_data_sent = &on_data_sent;
-+    status = pj_ssl_sock_start_accept2(listener->ssock, pool, 
- 			  (pj_sockaddr_t*)listener_addr, 
--			  pj_sockaddr_get_len((pj_sockaddr_t*)listener_addr));
-+			  pj_sockaddr_get_len((pj_sockaddr_t*)listener_addr),
-+			  &newsock_param);
-     if (status == PJ_SUCCESS || status == PJ_EPENDING) {
- 	pj_ssl_sock_info info;
- 	has_listener = PJ_TRUE;
--- 
-cgit v0.11.2
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0001-Bump-tcp-tls-and-transaction-log-levels-from-1-to-3.patch asterisk-13.17.0/third-party/pjproject/patches/0001-Bump-tcp-tls-and-transaction-log-levels-from-1-to-3.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0001-Bump-tcp-tls-and-transaction-log-levels-from-1-to-3.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0001-Bump-tcp-tls-and-transaction-log-levels-from-1-to-3.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-From a147b72df1ec150c1d733e882225db86142fb339 Mon Sep 17 00:00:00 2001
-From: George Joseph <george.joseph@fairview5.com>
-Date: Sun, 21 Feb 2016 10:01:53 -0700
-Subject: [PATCH] Bump tcp/tls and transaction log levels from 1 to 3
-
-sip_transport_tcp, sip_transport_tls and sip_transaction are printing messages
-at log level 1 or 2 for things that are transient, recoverable, possibly
-expected, or are handled with return codes. A good example of this is if we're
-trying to send an OPTIONS message to a TCP client that has disappeared.  Both
-sip_transport_tcp and sip_transaction are printing "connection refused"
-messages because the remote client isn't listening.  This is generally expected
-behavior and it should be up to the app caller to determine if an error message
-is warranted.
----
- pjsip/src/pjsip/sip_transaction.c   | 4 ++--
- pjsip/src/pjsip/sip_transport_tcp.c | 2 +-
- pjsip/src/pjsip/sip_transport_tls.c | 2 +-
- 3 files changed, 4 insertions(+), 4 deletions(-)
-
-diff --git a/pjsip/src/pjsip/sip_transaction.c b/pjsip/src/pjsip/sip_transaction.c
-index 46bd971..1b4fdb7 100644
---- a/pjsip/src/pjsip/sip_transaction.c
-+++ b/pjsip/src/pjsip/sip_transaction.c
-@@ -1898,7 +1898,7 @@ static void send_msg_callback( pjsip_send_state *send_state,
- 
- 	    err =pj_strerror((pj_status_t)-sent, errmsg, sizeof(errmsg));
- 
--	    PJ_LOG(2,(tsx->obj_name,
-+	    PJ_LOG(3,(tsx->obj_name,
- 		      "Failed to send %s! err=%d (%s)",
- 		      pjsip_tx_data_get_info(send_state->tdata), -sent,
- 		      errmsg));
-@@ -1938,7 +1938,7 @@ static void send_msg_callback( pjsip_send_state *send_state,
- 	    }
- 
- 	} else {
--	    PJ_PERROR(2,(tsx->obj_name, (pj_status_t)-sent,
-+	    PJ_PERROR(3,(tsx->obj_name, (pj_status_t)-sent,
- 		         "Temporary failure in sending %s, "
- 		         "will try next server",
- 		         pjsip_tx_data_get_info(send_state->tdata)));
-diff --git a/pjsip/src/pjsip/sip_transport_tcp.c b/pjsip/src/pjsip/sip_transport_tcp.c
-index 222cb13..1bbb324 100644
---- a/pjsip/src/pjsip/sip_transport_tcp.c
-+++ b/pjsip/src/pjsip/sip_transport_tcp.c
-@@ -164,7 +164,7 @@ static void tcp_perror(const char *sender, const char *title,
- 
-     pj_strerror(status, errmsg, sizeof(errmsg));
- 
--    PJ_LOG(1,(sender, "%s: %s [code=%d]", title, errmsg, status));
-+    PJ_LOG(3,(sender, "%s: %s [code=%d]", title, errmsg, status));
- }
- 
- 
-diff --git a/pjsip/src/pjsip/sip_transport_tls.c b/pjsip/src/pjsip/sip_transport_tls.c
-index 617d7f5..a83ac32 100644
---- a/pjsip/src/pjsip/sip_transport_tls.c
-+++ b/pjsip/src/pjsip/sip_transport_tls.c
-@@ -170,7 +170,7 @@ static void tls_perror(const char *sender, const char *title,
- 
-     pj_strerror(status, errmsg, sizeof(errmsg));
- 
--    PJ_LOG(1,(sender, "%s: %s [code=%d]", title, errmsg, status));
-+    PJ_LOG(3,(sender, "%s: %s [code=%d]", title, errmsg, status));
- }
- 
- 
--- 
-2.5.0
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0001-ioqueue-Enable-epoll-in-aconfigure.ac.patch asterisk-13.17.0/third-party/pjproject/patches/0001-ioqueue-Enable-epoll-in-aconfigure.ac.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0001-ioqueue-Enable-epoll-in-aconfigure.ac.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0001-ioqueue-Enable-epoll-in-aconfigure.ac.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-From b5c0bc905911f75e08987e6833075481fe16dab2 Mon Sep 17 00:00:00 2001
-From: George Joseph <george.joseph@fairview5.com>
-Date: Mon, 22 Feb 2016 13:05:59 -0700
-Subject: [PATCH] ioqueue:  Enable epoll in aconfigure.ac
-
-Although the --enable-epoll option was being accepted, the result
-was always forced to select.  This patch updates aconfigure.ac
-to properly set the value of ac_linux_poll if --enable-epoll is
-specified.
----
- README.txt                           |  1 +
- aconfigure                           | 11 +++++++----
- aconfigure.ac                        |  7 +++++--
- pjlib/include/pj/compat/os_auto.h.in |  3 +++
- 4 files changed, 16 insertions(+), 6 deletions(-)
-
-diff --git a/README.txt b/README.txt
-index bc45da8..48415fd 100644
---- a/README.txt
-+++ b/README.txt
-@@ -463,6 +463,7 @@ Using Default Settings
-    $ ./configure --help
-    ...
-    Optional Features:
-+   --enable-epoll           Use epoll on Linux instead of select
-    --disable-floating-point	Disable floating point where possible
-    --disable-sound 		Exclude sound (i.e. use null sound)
-    --disable-small-filter 	Exclude small filter in resampling
-diff --git a/aconfigure.ac b/aconfigure.ac
-index 2f71abb..3e88124 100644
---- a/aconfigure.ac
-+++ b/aconfigure.ac
-@@ -410,6 +410,7 @@ dnl ######################
- dnl # ioqueue selection
- dnl # 
- AC_SUBST(ac_os_objs)
-+AC_SUBST(ac_linux_poll)
- AC_MSG_CHECKING([ioqueue backend])
- AC_ARG_ENABLE(epoll,
- 	      AC_HELP_STRING([--enable-epoll],
-@@ -417,10 +418,13 @@ AC_ARG_ENABLE(epoll,
- 	      [
- 		ac_os_objs=ioqueue_epoll.o
- 		AC_MSG_RESULT([/dev/epoll])
-+		AC_DEFINE(PJ_HAS_LINUX_EPOLL,1)
-+		ac_linux_poll=epoll
- 	      ],
- 	      [
- 		ac_os_objs=ioqueue_select.o
--	        AC_MSG_RESULT([select()]) 
-+		AC_MSG_RESULT([select()])
-+		ac_linux_poll=select
- 	      ])
- 
- AC_SUBST(ac_shared_libraries)
-@@ -1879,7 +1883,6 @@ esac
- 
- 
- AC_SUBST(target)
--AC_SUBST(ac_linux_poll,select)
- AC_SUBST(ac_host,unix)
- AC_SUBST(ac_main_obj)
- case $target in
-diff --git a/pjlib/include/pj/compat/os_auto.h.in b/pjlib/include/pj/compat/os_auto.h.in
-index 77980d3..c8e73b2 100644
---- a/pjlib/include/pj/compat/os_auto.h.in
-+++ b/pjlib/include/pj/compat/os_auto.h.in
-@@ -128,6 +128,9 @@
-  */
- #undef PJ_SELECT_NEEDS_NFDS
- 
-+/* Was Linux epoll support enabled */
-+#undef PJ_HAS_LINUX_EPOLL
-+
- /* Is errno a good way to retrieve OS errors?
-  */
- #undef PJ_HAS_ERRNO_VAR
--- 
-2.5.0
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0001-sip_parser.c-Fix-pjsip_VIA_PARAM_SPEC_ESC.patch asterisk-13.17.0/third-party/pjproject/patches/0001-sip_parser.c-Fix-pjsip_VIA_PARAM_SPEC_ESC.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0001-sip_parser.c-Fix-pjsip_VIA_PARAM_SPEC_ESC.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0001-sip_parser.c-Fix-pjsip_VIA_PARAM_SPEC_ESC.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-From 0fc7ef5f01be9cc74d184c3ca3a973ff1ef44c93 Mon Sep 17 00:00:00 2001
-From: George Joseph <george.joseph@fairview5.com>
-Date: Sun, 10 Apr 2016 12:54:06 -0600
-Subject: [PATCH] sip_parser.c: Fix pjsip_VIA_PARAM_SPEC_ESC
-
-pjsip_VIA_PARAM_SPEC_ESC should have been pjsip_TOKEN_SPEC_ESC + ":" but
-instead of appending ":" to pjsip_VIA_PARAM_SPEC_ESC it was being appended
-to pjsip_VIA_PARAM_SPEC again.  This was causing parsing of Via headers
-to fail when an ipv6 address was in a "received" param and
-PJSIP_UNESCAPE_IN_PLACE was used.  Probably just a copy/paste error.
----
- pjsip/src/pjsip/sip_parser.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/pjsip/src/pjsip/sip_parser.c b/pjsip/src/pjsip/sip_parser.c
-index 378c22f..c18faa3 100644
---- a/pjsip/src/pjsip/sip_parser.c
-+++ b/pjsip/src/pjsip/sip_parser.c
-@@ -327,7 +327,7 @@ static pj_status_t init_parser()
- 
-     status = pj_cis_dup(&pconst.pjsip_VIA_PARAM_SPEC_ESC, &pconst.pjsip_TOKEN_SPEC_ESC);
-     PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);
--    pj_cis_add_str(&pconst.pjsip_VIA_PARAM_SPEC, ":");
-+    pj_cis_add_str(&pconst.pjsip_VIA_PARAM_SPEC_ESC, ":");
- 
-     status = pj_cis_dup(&pconst.pjsip_HOST_SPEC, &pconst.pjsip_ALNUM_SPEC);
-     PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);
--- 
-2.5.5
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0001-sip_parser.c-Remove-wholesale-strip-from-parse_param.patch asterisk-13.17.0/third-party/pjproject/patches/0001-sip_parser.c-Remove-wholesale-strip-from-parse_param.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0001-sip_parser.c-Remove-wholesale-strip-from-parse_param.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0001-sip_parser.c-Remove-wholesale-strip-from-parse_param.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-From ce426249ec1270f27560919791f3e13eaeea9152 Mon Sep 17 00:00:00 2001
-From: George Joseph <george.joseph@fairview5.com>
-Date: Tue, 12 Apr 2016 14:09:53 -0600
-Subject: [PATCH] sip_parser.c:  Remove wholesale '[]' strip from
- parse_param_impl
-
-The wholesale stripping of '[]' from header parameters causes issues if
-something (like a port) occurrs after the final ']'.
-
-'[2001:a::b]' will correctly parse to '2001:a::b'
-'[2001:a::b]:8080' will correctly parse to '2001:a::b' but the scanner is left
-with ':8080' and parsing stops with a syntax error.
-
-I can't even find a case where stripping the '[]' is a good thing anyway.  Even
-if you continued to parse and resulted in a string that looks like this...
-'2001:a::b:8080', it's not valid.
-
-This came up in Asterisk because Kamailio sends us a Contact with an alias
-URI parameter that has an IPv6 address in it like this:
-Contact: <sip:1171@127.0.0.1:5080;alias=[2001:1:2::3]~43691~6>
-which should be legal but causes a syntax error because of the characters
-after the final ']'.  Even if it didn't, the '[]' should still not be stripped.
-
-I've run the Asterisk Test Suite for PJSIP (252 tests) many of which are IPv6
-enabled.  No issues were caused by removing the code that strips the '[]'.
-
-I tried running 'make pjsip-test' but that fails even without my change. :)
-
-The Asterisk ticket is: https://issues.asterisk.org/jira/browse/ASTERISK-25123
----
- pjsip/src/pjsip/sip_parser.c | 8 --------
- 1 file changed, 8 deletions(-)
-
-diff --git a/pjsip/src/pjsip/sip_parser.c b/pjsip/src/pjsip/sip_parser.c
-index c18faa3..98eb5ea 100644
---- a/pjsip/src/pjsip/sip_parser.c
-+++ b/pjsip/src/pjsip/sip_parser.c
-@@ -1149,14 +1149,6 @@ static void parse_param_imp( pj_scanner *scanner, pj_pool_t *pool,
- 		    pvalue->ptr++;
- 		    pvalue->slen -= 2;
- 		}
--	    } else if (*scanner->curptr == '[') {
--		/* pvalue can be a quoted IPv6; in this case, the
--		 * '[' and ']' quote characters are to be removed
--		 * from the pvalue. 
--		 */
--		pj_scan_get_char(scanner);
--		pj_scan_get_until_ch(scanner, ']', pvalue);
--		pj_scan_get_char(scanner);
- 	    } else if(pj_cis_match(spec, *scanner->curptr)) {
- 		parser_get_and_unescape(scanner, pool, spec, esc_spec, pvalue);
- 	    }
--- 
-2.5.5
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0001-sip_transport-Search-for-transport-even-if-listener-.patch asterisk-13.17.0/third-party/pjproject/patches/0001-sip_transport-Search-for-transport-even-if-listener-.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0001-sip_transport-Search-for-transport-even-if-listener-.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0001-sip_transport-Search-for-transport-even-if-listener-.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-From 552194179eb6deae8326eb0fef446e69240ea41b Mon Sep 17 00:00:00 2001
-From: George Joseph <george.joseph@fairview5.com>
-Date: Fri, 19 Feb 2016 17:05:53 -0700
-Subject: [PATCH] sip_transport:  Search for transport even if listener was
- specified.
-
-If a listener was specified when calling pjsip_tpmgr_acquire_transport2,
-a new transport was always created instead of using an existing one.  This
-caused several issues mostly related to the remote end not expecting a new
-connection.  I.E.  A TCP client who registered to a server is not going to
-be listening for connections coming back from the server and refuses the
-connection.
-
-Now when pjsip_tpmgr_acquire_transport2 is called with a listener, the
-registry is still searched for an existing transport and the listener
-is used as a factory only if no existing transport can be found.
----
- pjsip/src/pjsip/sip_transport.c | 68 ++++++++++++++++++++---------------------
- 1 file changed, 34 insertions(+), 34 deletions(-)
-
-diff --git a/pjsip/src/pjsip/sip_transport.c b/pjsip/src/pjsip/sip_transport.c
-index 0410324..620b9c0 100644
---- a/pjsip/src/pjsip/sip_transport.c
-+++ b/pjsip/src/pjsip/sip_transport.c
-@@ -1999,29 +1999,11 @@ PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,
- 
- 	TRACE_((THIS_FILE, "Transport %s acquired", seltp->obj_name));
- 	return PJ_SUCCESS;
--
--
--    } else if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
--	       sel->u.listener)
--    {
--	/* Application has requested that a specific listener is to
--	 * be used. In this case, skip transport hash table lookup.
--	 */
--
--	/* Verify that the listener type matches the destination type */
--	if (sel->u.listener->type != type) {
--	    pj_lock_release(mgr->lock);
--	    return PJSIP_ETPNOTSUITABLE;
--	}
--
--	/* We'll use this listener to create transport */
--	factory = sel->u.listener;
--
-     } else {
- 
- 	/*
- 	 * This is the "normal" flow, where application doesn't specify
--	 * specific transport/listener to be used to send message to.
-+	 * specific transport to be used to send message to.
- 	 * In this case, lookup the transport from the hash table.
- 	 */
- 	pjsip_transport_key key;
-@@ -2081,22 +2063,40 @@ PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,
- 	    return PJ_SUCCESS;
- 	}
- 
--	/*
--	 * Transport not found!
--	 * Find factory that can create such transport.
--	 */
--	factory = mgr->factory_list.next;
--	while (factory != &mgr->factory_list) {
--	    if (factory->type == type)
--		break;
--	    factory = factory->next;
--	}
-+	if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
-+		sel->u.listener)
-+		{
-+		/* Application has requested that a specific listener is to
-+		 * be used.
-+		 */
-+
-+		/* Verify that the listener type matches the destination type */
-+		if (sel->u.listener->type != type) {
-+			pj_lock_release(mgr->lock);
-+			return PJSIP_ETPNOTSUITABLE;
-+		}
- 
--	if (factory == &mgr->factory_list) {
--	    /* No factory can create the transport! */
--	    pj_lock_release(mgr->lock);
--	    TRACE_((THIS_FILE, "No suitable factory was found either"));
--	    return PJSIP_EUNSUPTRANSPORT;
-+		/* We'll use this listener to create transport */
-+		factory = sel->u.listener;
-+
-+	} else {
-+		/*
-+		 * Transport not found!
-+		 * Find factory that can create such transport.
-+		 */
-+		factory = mgr->factory_list.next;
-+		while (factory != &mgr->factory_list) {
-+			if (factory->type == type)
-+				break;
-+			factory = factory->next;
-+		}
-+
-+		if (factory == &mgr->factory_list) {
-+			/* No factory can create the transport! */
-+			pj_lock_release(mgr->lock);
-+			TRACE_((THIS_FILE, "No suitable factory was found either"));
-+			return PJSIP_EUNSUPTRANSPORT;
-+		}
- 	}
-     }
- 
--- 
-2.5.0
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0002-aconfigure.ac-Fix-autoconf-issue-with-opencore-amrnb.patch asterisk-13.17.0/third-party/pjproject/patches/0002-aconfigure.ac-Fix-autoconf-issue-with-opencore-amrnb.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0002-aconfigure.ac-Fix-autoconf-issue-with-opencore-amrnb.patch	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/0002-aconfigure.ac-Fix-autoconf-issue-with-opencore-amrnb.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-From 1281b60a1807d1285b101b6eb61c6478f29785fe Mon Sep 17 00:00:00 2001
-From: George Joseph <george.joseph@fairview5.com>
-Date: Wed, 23 Mar 2016 07:48:52 -0600
-Subject: [PATCH] aconfigure.ac:  Fix autoconf issue with opencore-amrnb on
- older systems
-
-autoconf 2.63 on CentOS6 produces a bad ./aconfigure file related to
-opencore-amrnb.
-
-./aconfigure: line 15158: syntax error near unexpected token `fi'
-
-To get around this, a 'true;' needed to be added to the Ok case of
-AC_ARG_WITH(opencore-amrnb)
----
- aconfigure    | 3 +++
- aconfigure.ac | 2 +-
- 2 files changed, 4 insertions(+), 1 deletion(-)
-
-diff --git a/aconfigure b/aconfigure
-index 33a08f5..4c122c2 100755
---- a/aconfigure
-+++ b/aconfigure
-@@ -7908,6 +7908,9 @@ fi
- # Check whether --with-opencore-amrnb was given.
- if test "${with_opencore_amrnb+set}" = set; then :
-   withval=$with_opencore_amrnb; as_fn_error $? "This option is obsolete and replaced by --with-opencore-amr=DIR" "$LINENO" 5
-+else
-+  true;
-+
- fi
- 
- 
-diff --git a/aconfigure.ac b/aconfigure.ac
-index 3e88124..5d3e833 100644
---- a/aconfigure.ac
-+++ b/aconfigure.ac
-@@ -1631,7 +1631,7 @@ AC_ARG_WITH(opencore-amrnb,
-     AC_HELP_STRING([--with-opencore-amrnb=DIR],
- 		   [This option is obsolete and replaced by --with-opencore-amr=DIR]),
-     [AC_MSG_ERROR(This option is obsolete and replaced by --with-opencore-amr=DIR)],
--    []
-+    [true;]
-     )
- 
- dnl # opencore-amr alt prefix
--- 
-2.5.0
-
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0010-evsub-Add-pjsip_evsub_set_uas_timeout.patch asterisk-13.17.0/third-party/pjproject/patches/0010-evsub-Add-pjsip_evsub_set_uas_timeout.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0010-evsub-Add-pjsip_evsub_set_uas_timeout.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0010-evsub-Add-pjsip_evsub_set_uas_timeout.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,84 @@
+From b7af9e6639f29feb4db6d0866c98e552b025ec96 Mon Sep 17 00:00:00 2001
+From: George Joseph <gjoseph@digium.com>
+Date: Mon, 6 Feb 2017 15:39:29 -0700
+Subject: [PATCH] evsub:  Add pjsip_evsub_set_uas_timeout.
+
+A UAS which needs to recreate incoming subscriptions from a persistent
+store can call pjsip_dlg_create_uas_and_inc_lock and
+pjsip_evsub_create_uas as long as they've persisted the
+correct data but since the timer is triggered by an incoming subscribe,
+it's never set and the subscription never expires.
+
+* Add pjsip_evsub_set_uas_timeout which is just a wrapper around
+  evsub.c:set_timeout(sub, TIMER_TYPE_UAS_TIMEOUT, seconds)
+
+* Also, fixed copy-paste error in pjsip_sub_state_hdr_print when
+  printing retry-after parameter.
+---
+ pjsip/include/pjsip-simple/evsub.h | 14 ++++++++++++++
+ pjsip/src/pjsip-simple/evsub.c     | 10 ++++++++++
+ pjsip/src/pjsip-simple/evsub_msg.c |  2 +-
+ 3 files changed, 25 insertions(+), 1 deletion(-)
+
+diff --git a/pjsip/include/pjsip-simple/evsub.h b/pjsip/include/pjsip-simple/evsub.h
+index 82e0a7c..45e6411 100644
+--- a/pjsip/include/pjsip-simple/evsub.h
++++ b/pjsip/include/pjsip-simple/evsub.h
+@@ -511,6 +511,20 @@ PJ_DEF(pj_status_t) pjsip_evsub_add_ref(pjsip_evsub *sub);
+ PJ_DEF(pj_status_t) pjsip_evsub_dec_ref(pjsip_evsub *sub);
+ 
+ 
++/**
++ * Sets, resets or cancels the UAS subscription timeout.
++ *
++ * If there is an existing timer, it is cancelled before any
++ * other action.
++ *
++ * A timeout of 0 is ignored except that any existing timer
++ * is cancelled.
++ *
++ * @param sub           The server subscription instance.
++ * @param seconds       The new timeout.
++ */
++PJ_DEF(void) pjsip_evsub_set_uas_timeout(pjsip_evsub *sub, pj_int32_t seconds);
++
+ 
+ PJ_END_DECL
+ 
+diff --git a/pjsip/src/pjsip-simple/evsub.c b/pjsip/src/pjsip-simple/evsub.c
+index 3fe4b49..6918a8c 100644
+--- a/pjsip/src/pjsip-simple/evsub.c
++++ b/pjsip/src/pjsip-simple/evsub.c
+@@ -530,6 +530,16 @@ static void set_timer( pjsip_evsub *sub, int timer_id,
+ 
+ 
+ /*
++ * Set event subscription UAS timout.
++ */
++PJ_DEF(void) pjsip_evsub_set_uas_timeout(pjsip_evsub *sub, pj_int32_t seconds)
++{
++    PJ_ASSERT_RETURN(sub != NULL, PJ_EINVAL);
++    set_timer(sub, TIMER_TYPE_UAS_TIMEOUT, seconds);
++}
++
++
++/*
+  * Destructor.
+  */
+ static void evsub_on_destroy(void *obj)
+diff --git a/pjsip/src/pjsip-simple/evsub_msg.c b/pjsip/src/pjsip-simple/evsub_msg.c
+index b44a715..b37db1c 100644
+--- a/pjsip/src/pjsip-simple/evsub_msg.c
++++ b/pjsip/src/pjsip-simple/evsub_msg.c
+@@ -179,7 +179,7 @@ static int pjsip_sub_state_hdr_print(pjsip_sub_state_hdr *hdr,
+     }
+     if (hdr->retry_after >= 0) {
+ 	pj_memcpy(p, ";retry-after=", 13);
+-	p += 9;
++	p += 13;
+ 	printed = pj_utoa(hdr->retry_after, p);
+ 	p += printed;
+     }
+-- 
+2.9.3
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0011-r5554-svn-backport-Increase-SENDER_WIDTH-column-size.patch asterisk-13.17.0/third-party/pjproject/patches/0011-r5554-svn-backport-Increase-SENDER_WIDTH-column-size.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0011-r5554-svn-backport-Increase-SENDER_WIDTH-column-size.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0011-r5554-svn-backport-Increase-SENDER_WIDTH-column-size.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,77 @@
+From df1ceb301c8a17969c467e3cf00246cfc28d1732 Mon Sep 17 00:00:00 2001
+From: Richard Mudgett <rmudgett@digium.com>
+Date: Mon, 20 Feb 2017 12:19:05 -0600
+Subject: [PATCH 1/5] r5554 svn backport Increase SENDER_WIDTH column size for
+ 64-bit systems.
+
+Re #1994 (misc): Make the log's sender and thread width a compile-time configurable setting.
+
+Thanks to Richard Mudgett for the suggestion.
+---
+ pjlib/include/pj/config.h | 27 +++++++++++++++++++++++++++
+ pjlib/src/pj/log.c        |  4 ++--
+ 2 files changed, 29 insertions(+), 2 deletions(-)
+
+diff --git a/pjlib/include/pj/config.h b/pjlib/include/pj/config.h
+index 079d69b..3523f50 100644
+--- a/pjlib/include/pj/config.h
++++ b/pjlib/include/pj/config.h
+@@ -442,6 +442,33 @@
+ #endif
+ 
+ /**
++ * Log sender width.
++ *
++ * Default: 22 (for 64-bit machines), 14 otherwise
++ */
++#ifndef PJ_LOG_SENDER_WIDTH
++#   if PJ_HAS_STDINT_H
++#       include <stdint.h>
++#       if (UINTPTR_MAX == 0xffffffffffffffff)
++#           define PJ_LOG_SENDER_WIDTH  22
++#       else
++#           define PJ_LOG_SENDER_WIDTH  14
++#       endif
++#   else
++#       define PJ_LOG_SENDER_WIDTH  14
++#   endif
++#endif
++
++/**
++ * Log thread name width.
++ *
++ * Default: 12
++ */
++#ifndef PJ_LOG_THREAD_WIDTH
++#   define PJ_LOG_THREAD_WIDTH	    12
++#endif
++
++/**
+  * Colorfull terminal (for logging etc).
+  *
+  * Default: 1
+diff --git a/pjlib/src/pj/log.c b/pjlib/src/pj/log.c
+index 293ad46..cf7ac37 100644
+--- a/pjlib/src/pj/log.c
++++ b/pjlib/src/pj/log.c
+@@ -380,7 +380,7 @@ PJ_DEF(void) pj_log( const char *sender, int level,
+ 	pre += pj_utoa_pad(ptime.msec, pre, 3, '0');
+     }
+     if (log_decor & PJ_LOG_HAS_SENDER) {
+-	enum { SENDER_WIDTH = 14 };
++	enum { SENDER_WIDTH = PJ_LOG_SENDER_WIDTH };
+ 	pj_size_t sender_len = strlen(sender);
+ 	if (pre!=log_buffer) *pre++ = ' ';
+ 	if (sender_len <= SENDER_WIDTH) {
+@@ -395,7 +395,7 @@ PJ_DEF(void) pj_log( const char *sender, int level,
+ 	}
+     }
+     if (log_decor & PJ_LOG_HAS_THREAD_ID) {
+-	enum { THREAD_WIDTH = 12 };
++	enum { THREAD_WIDTH = PJ_LOG_THREAD_WIDTH };
+ 	const char *thread_name = pj_thread_get_name(pj_thread_this());
+ 	pj_size_t thread_len = strlen(thread_name);
+ 	*pre++ = ' ';
+-- 
+2.7.4
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0013-r5559-svn-backport-Fix-to-resolve-DNS-SRV-crashes.patch asterisk-13.17.0/third-party/pjproject/patches/0013-r5559-svn-backport-Fix-to-resolve-DNS-SRV-crashes.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0013-r5559-svn-backport-Fix-to-resolve-DNS-SRV-crashes.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0013-r5559-svn-backport-Fix-to-resolve-DNS-SRV-crashes.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,112 @@
+From d9d52f005f6d0242ea84e7c59ad6b25f052c8485 Mon Sep 17 00:00:00 2001
+From: Richard Mudgett <rmudgett@digium.com>
+Date: Mon, 20 Feb 2017 12:05:32 -0600
+Subject: [PATCH 3/5] r5559 svn backport Fix to resolve DNS SRV crashes.
+
+Re #1994 (misc): Don't try to resolve a DNS SRV query that is already considered resolved.
+Thanks to Richard Mudgett for the patch.
+
+srv_resolver.c: Don't try to send query if already considered resolved.
+
+* In resolve_hostnames() don't try to resolve a query that is already
+considered resolved.
+
+* In resolve_hostnames() fix DNS typo in comments.
+
+* In build_server_entries() move a common expression assigning to cnt
+earlier.
+
+sip_transport.c: Fix tdata object name to actually contain the pointer.
+
+It helps if the logs referencing a tdata object buffer actually have
+a name that includes the correct pointer as part of the name.  Also
+since the tdata has its own pool it helps if any logs referencing the
+pool have the same name as the tdata object.  This change brings tdata
+logging in line with how tsx objects are named.
+---
+ pjlib-util/src/pjlib-util/srv_resolver.c | 18 +++++++++++++-----
+ pjsip/src/pjsip/sip_transport.c          |  3 ++-
+ 2 files changed, 15 insertions(+), 6 deletions(-)
+
+diff --git a/pjlib-util/src/pjlib-util/srv_resolver.c b/pjlib-util/src/pjlib-util/srv_resolver.c
+index 8a2f7e1..84ad3f6 100644
+--- a/pjlib-util/src/pjlib-util/srv_resolver.c
++++ b/pjlib-util/src/pjlib-util/srv_resolver.c
+@@ -407,8 +407,9 @@ static void build_server_entries(pj_dns_srv_async_query *query_job,
+     for (i=0; i<query_job->srv_cnt; ++i) {
+ 	pj_in_addr addr;
+ 	pj_in6_addr addr6;
++	unsigned cnt = query_job->srv[i].addr_cnt;
+ 
+-	if (query_job->srv[i].addr_cnt != 0) {
++	if (cnt != 0) {
+ 	    /* IP address already resolved */
+ 	    continue;
+ 	}
+@@ -417,7 +418,6 @@ static void build_server_entries(pj_dns_srv_async_query *query_job,
+ 	    pj_inet_pton(pj_AF_INET(), &query_job->srv[i].target_name,
+ 			 &addr) == PJ_SUCCESS)
+ 	{
+-	    unsigned cnt = query_job->srv[i].addr_cnt;
+ 	    pj_sockaddr_init(pj_AF_INET(), &query_job->srv[i].addr[cnt],
+ 			     NULL, query_job->srv[i].port);
+ 	    query_job->srv[i].addr[cnt].ipv4.sin_addr = addr;
+@@ -427,7 +427,6 @@ static void build_server_entries(pj_dns_srv_async_query *query_job,
+ 		   pj_inet_pton(pj_AF_INET6(), &query_job->srv[i].target_name,
+ 				&addr6) == PJ_SUCCESS)
+ 	{
+-	    unsigned cnt = query_job->srv[i].addr_cnt;
+ 	    pj_sockaddr_init(pj_AF_INET6(), &query_job->srv[i].addr[cnt],
+ 			     NULL, query_job->srv[i].port);
+ 	    query_job->srv[i].addr[cnt].ipv6.sin6_addr = addr6;
+@@ -480,6 +479,15 @@ static pj_status_t resolve_hostnames(pj_dns_srv_async_query *query_job)
+     for (i=0; i<query_job->srv_cnt; ++i) {
+ 	struct srv_target *srv = &query_job->srv[i];
+ 
++	if (srv->addr_cnt != 0) {
++	    /*
++	     * This query is already counted as resolved because of the
++	     * additional records in the SRV response or the target name
++	     * is an IP address exception in build_server_entries().
++	     */
++	    continue;
++	}
++
+ 	PJ_LOG(5, (query_job->objname, 
+ 		   "Starting async DNS A query_job for %.*s",
+ 		   (int)srv->target_name.slen, 
+@@ -493,7 +501,7 @@ static pj_status_t resolve_hostnames(pj_dns_srv_async_query *query_job)
+ 
+ 	status = PJ_SUCCESS;
+ 
+-	/* Start DNA A record query */
++	/* Start DNS A record query */
+ 	if ((query_job->option & PJ_DNS_SRV_RESOLVE_AAAA_ONLY) == 0)
+ 	{
+ 	    if ((query_job->option & PJ_DNS_SRV_RESOLVE_AAAA) != 0) {
+@@ -511,7 +519,7 @@ static pj_status_t resolve_hostnames(pj_dns_srv_async_query *query_job)
+ 						 &srv->common, &srv->q_a);
+ 	}
+ 
+-	/* Start DNA AAAA record query */
++	/* Start DNS AAAA record query */
+ 	if (status == PJ_SUCCESS &&
+ 	    (query_job->option & PJ_DNS_SRV_RESOLVE_AAAA) != 0)
+ 	{
+diff --git a/pjsip/src/pjsip/sip_transport.c b/pjsip/src/pjsip/sip_transport.c
+index d672a6d..6dd14d1 100644
+--- a/pjsip/src/pjsip/sip_transport.c
++++ b/pjsip/src/pjsip/sip_transport.c
+@@ -422,7 +422,8 @@ PJ_DEF(pj_status_t) pjsip_tx_data_create( pjsip_tpmgr *mgr,
+     tdata = PJ_POOL_ZALLOC_T(pool, pjsip_tx_data);
+     tdata->pool = pool;
+     tdata->mgr = mgr;
+-    pj_memcpy(tdata->obj_name, pool->obj_name, PJ_MAX_OBJ_NAME);
++    pj_ansi_snprintf(tdata->obj_name, sizeof(tdata->obj_name), "tdta%p", tdata);
++    pj_memcpy(pool->obj_name, tdata->obj_name, sizeof(pool->obj_name));
+ 
+     status = pj_atomic_create(tdata->pool, 0, &tdata->ref_cnt);
+     if (status != PJ_SUCCESS) {
+-- 
+2.7.4
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0014-Add-pjsip-transport-register-type-ipv6.patch asterisk-13.17.0/third-party/pjproject/patches/0014-Add-pjsip-transport-register-type-ipv6.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0014-Add-pjsip-transport-register-type-ipv6.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0014-Add-pjsip-transport-register-type-ipv6.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,62 @@
+From daeb0956524606b597704a90b54d81340e10b3e4 Mon Sep 17 00:00:00 2001
+From: Joshua Colp <jcolp@digium.com>
+Date: Tue, 7 Mar 2017 12:32:49 +0000
+Subject: [PATCH] Add support for registering IPv6 transport type.
+
+This change allows an IPv6 transport type to be registered
+and used. The IPv4 transport is found (if available) and the
+IPv4 flag added to its type to match how the finding of
+IPv6 transport types works.
+---
+ pjsip/src/pjsip/sip_transport.c | 15 +++++++++++++--
+ 1 file changed, 13 insertions(+), 2 deletions(-)
+
+diff --git a/pjsip/src/pjsip/sip_transport.c b/pjsip/src/pjsip/sip_transport.c
+index 7df6138..ce72814 100644
+--- a/pjsip/src/pjsip/sip_transport.c
++++ b/pjsip/src/pjsip/sip_transport.c
+@@ -236,6 +236,7 @@ PJ_DEF(pj_status_t) pjsip_transport_register_type( unsigned tp_flag,
+ 						   int *p_tp_type)
+ {
+     unsigned i;
++    pjsip_transport_type_e parent = 0;
+ 
+     PJ_ASSERT_RETURN(tp_flag && tp_name && def_port, PJ_EINVAL);
+     PJ_ASSERT_RETURN(pj_ansi_strlen(tp_name) <
+@@ -243,6 +244,11 @@ PJ_DEF(pj_status_t) pjsip_transport_register_type( unsigned tp_flag,
+ 		     PJ_ENAMETOOLONG);
+ 
+     for (i=1; i<PJ_ARRAY_SIZE(transport_names); ++i) {
++        if (tp_flag & PJSIP_TRANSPORT_IPV6 &&
++            pj_stricmp2(&transport_names[i].name, tp_name) == 0)
++        {
++	    parent = transport_names[i].type;
++        }
+ 	if (transport_names[i].type == 0)
+ 	    break;
+     }
+@@ -250,14 +256,19 @@ PJ_DEF(pj_status_t) pjsip_transport_register_type( unsigned tp_flag,
+     if (i == PJ_ARRAY_SIZE(transport_names))
+ 	return PJ_ETOOMANY;
+ 
+-    transport_names[i].type = (pjsip_transport_type_e)i;
++    if (tp_flag & PJSIP_TRANSPORT_IPV6 && parent) {
++        transport_names[i].type = parent | PJSIP_TRANSPORT_IPV6;
++    } else {
++        transport_names[i].type = (pjsip_transport_type_e)i;
++    }
++
+     transport_names[i].port = (pj_uint16_t)def_port;
+     pj_ansi_strcpy(transport_names[i].name_buf, tp_name);
+     transport_names[i].name = pj_str(transport_names[i].name_buf);
+     transport_names[i].flag = tp_flag;
+ 
+     if (p_tp_type)
+-	*p_tp_type = i;
++	*p_tp_type = transport_names[i].type;
+ 
+     return PJ_SUCCESS;
+ }
+-- 
+2.7.4
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0025-fix-print-xml-crash.patch asterisk-13.17.0/third-party/pjproject/patches/0025-fix-print-xml-crash.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0025-fix-print-xml-crash.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0025-fix-print-xml-crash.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,24 @@
+From 1bc5ca699f523bd8e910203a3eb4dee58f366976 Mon Sep 17 00:00:00 2001
+From: Joshua Elson <joshelson@gmail.com>
+Date: Mon, 20 Mar 2017 19:28:47 -0600
+Subject: [PATCH] Prevent memory corruption on xml tag write
+
+---
+ pjlib-util/src/pjlib-util/xml.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/pjlib-util/src/pjlib-util/xml.c b/pjlib-util/src/pjlib-util/xml.c
+index 296b232..b0aad26 100644
+--- a/pjlib-util/src/pjlib-util/xml.c
++++ b/pjlib-util/src/pjlib-util/xml.c
+@@ -248,6 +248,7 @@ static int xml_print_node( const pj_xml_node *node, int indent,
+     if (node->content.slen==0 &&
+ 	node->node_head.next==(pj_xml_node*)&node->node_head)
+     {
++	if (SIZE_LEFT() < 3) return -1;
+ 	*p++ = ' ';
+ 	*p++ = '/';
+ 	*p++ = '>';
+-- 
+2.10.1 (Apple Git-78)
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0035-r5572-svn-backport-dialog-transaction-deadlock.patch asterisk-13.17.0/third-party/pjproject/patches/0035-r5572-svn-backport-dialog-transaction-deadlock.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0035-r5572-svn-backport-dialog-transaction-deadlock.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0035-r5572-svn-backport-dialog-transaction-deadlock.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+Index: trunk/pjsip/src/pjsip/sip_transaction.c
+===================================================================
+--- a/pjsip/src/pjsip/sip_transaction.c	(revision 5244)
++++ b/pjsip/src/pjsip/sip_transaction.c	(revision 5572)
+@@ -1231,5 +1231,27 @@
+ 	PJSIP_EVENT_INIT_TSX_STATE(e, tsx, event_src_type, event_src,
+ 				   prev_state);
++
++	/* For timer event, release lock to avoid deadlock.
++	 * This should be safe because:
++	 * 1. The tsx state just switches to TERMINATED or DESTROYED.
++  	 * 2. There should be no other processing taking place. All other
++  	 *    events, such as the ones handled by tsx_on_state_terminated()
++  	 *    should be ignored.
++         * 3. tsx_shutdown() hasn't been called.
++	 * Refer to ticket #2001 (https://trac.pjsip.org/repos/ticket/2001).
++	 */
++	if (event_src_type == PJSIP_EVENT_TIMER &&
++	    (pj_timer_entry *)event_src == &tsx->timeout_timer)
++	{
++	    pj_grp_lock_release(tsx->grp_lock);
++	}
++
+ 	(*tsx->tsx_user->on_tsx_state)(tsx, &e);
++
++	if (event_src_type == PJSIP_EVENT_TIMER &&
++	    (pj_timer_entry *)event_src == &tsx->timeout_timer)
++	{
++	    pj_grp_lock_acquire(tsx->grp_lock);
++	}
+     }
+     
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0036-r5573-svn-backport-ua-pjsua-transaction-deadlock.patch asterisk-13.17.0/third-party/pjproject/patches/0036-r5573-svn-backport-ua-pjsua-transaction-deadlock.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0036-r5573-svn-backport-ua-pjsua-transaction-deadlock.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0036-r5573-svn-backport-ua-pjsua-transaction-deadlock.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,119 @@
+Index: trunk/pjsip/include/pjsip/sip_transaction.h
+===================================================================
+--- a/pjsip/include/pjsip/sip_transaction.h	(revision 5572)
++++ b/pjsip/include/pjsip/sip_transaction.h	(revision 5573)
+@@ -180,4 +180,8 @@
+  * is created by calling #pjsip_tsx_create_key() from an incoming message.
+  *
++ * IMPORTANT: To prevent deadlock, application should use
++ * #pjsip_tsx_layer_find_tsx2() instead which only adds a reference to
++ * the transaction instead of locking it.
++ *
+  * @param key	    The key string to find the transaction.
+  * @param lock	    If non-zero, transaction will be locked before the
+@@ -190,4 +194,19 @@
+ PJ_DECL(pjsip_transaction*) pjsip_tsx_layer_find_tsx( const pj_str_t *key,
+ 						      pj_bool_t lock );
++
++/**
++ * Find a transaction with the specified key. The transaction key normally
++ * is created by calling #pjsip_tsx_create_key() from an incoming message.
++ *
++ * @param key	    The key string to find the transaction.
++ * @param add_ref   If non-zero, transaction's reference will be added
++ *		    by one before the function returns, to make sure that
++ * 		    it's not deleted by other threads.
++ *
++ * @return	    The matching transaction instance, or NULL if transaction
++ *		    can not be found.
++ */
++PJ_DECL(pjsip_transaction*) pjsip_tsx_layer_find_tsx2( const pj_str_t *key,
++						       pj_bool_t add_ref );
+ 
+ /**
+Index: trunk/pjsip/src/pjsip/sip_transaction.c
+===================================================================
+--- a/pjsip/src/pjsip/sip_transaction.c	(revision 5572)
++++ b/pjsip/src/pjsip/sip_transaction.c	(revision 5573)
+@@ -642,6 +642,6 @@
+  * Find a transaction.
+  */
+-PJ_DEF(pjsip_transaction*) pjsip_tsx_layer_find_tsx( const pj_str_t *key,
+-						     pj_bool_t lock )
++static pjsip_transaction* find_tsx( const pj_str_t *key, pj_bool_t lock,
++				    pj_bool_t add_ref )
+ {
+     pjsip_transaction *tsx;
+@@ -655,5 +655,5 @@
+     /* Prevent the transaction to get deleted before we have chance to lock it.
+      */
+-    if (tsx && lock)
++    if (tsx)
+         pj_grp_lock_add_ref(tsx->grp_lock);
+     
+@@ -667,10 +667,27 @@
+     PJ_RACE_ME(5);
+ 
+-    if (tsx && lock) {
+-	pj_grp_lock_acquire(tsx->grp_lock);
+-        pj_grp_lock_dec_ref(tsx->grp_lock);
++    if (tsx) {
++	if (lock)
++	    pj_grp_lock_acquire(tsx->grp_lock);
++
++        if (!add_ref)
++            pj_grp_lock_dec_ref(tsx->grp_lock);
+     }
+ 
+     return tsx;
++}
++
++
++PJ_DEF(pjsip_transaction*) pjsip_tsx_layer_find_tsx( const pj_str_t *key,
++						     pj_bool_t lock )
++{
++    return find_tsx(key, lock, PJ_FALSE);
++}
++
++
++PJ_DEF(pjsip_transaction*) pjsip_tsx_layer_find_tsx2( const pj_str_t *key,
++						      pj_bool_t add_ref )
++{
++    return find_tsx(key, PJ_FALSE, add_ref);
+ }
+ 
+Index: trunk/pjsip/src/pjsip/sip_ua_layer.c
+===================================================================
+--- a/pjsip/src/pjsip/sip_ua_layer.c	(revision 5572)
++++ b/pjsip/src/pjsip/sip_ua_layer.c	(revision 5573)
+@@ -552,10 +552,10 @@
+ 
+ 	/* Lookup the INVITE transaction */
+-	tsx = pjsip_tsx_layer_find_tsx(&key, PJ_TRUE);
++	tsx = pjsip_tsx_layer_find_tsx2(&key, PJ_TRUE);
+ 
+ 	/* We should find the dialog attached to the INVITE transaction */
+ 	if (tsx) {
+ 	    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];
+-	    pj_grp_lock_release(tsx->grp_lock);
++	    pj_grp_lock_dec_ref(tsx->grp_lock);
+ 
+ 	    /* Dlg may be NULL on some extreme condition
+Index: trunk/pjsip/src/pjsip-ua/sip_inv.c
+===================================================================
+--- a/pjsip/src/pjsip-ua/sip_inv.c	(revision 5572)
++++ b/pjsip/src/pjsip-ua/sip_inv.c	(revision 5573)
+@@ -3276,5 +3276,5 @@
+     pjsip_tsx_create_key(rdata->tp_info.pool, &key, PJSIP_ROLE_UAS,
+ 			 pjsip_get_invite_method(), rdata);
+-    invite_tsx = pjsip_tsx_layer_find_tsx(&key, PJ_TRUE);
++    invite_tsx = pjsip_tsx_layer_find_tsx2(&key, PJ_TRUE);
+ 
+     if (invite_tsx == NULL) {
+@@ -3325,5 +3325,5 @@
+ 
+     if (invite_tsx)
+-	pj_grp_lock_release(invite_tsx->grp_lock);
++	pj_grp_lock_dec_ref(invite_tsx->grp_lock);
+ }
+ 
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0037-r5576-svn-backport-session-timer-crash.patch asterisk-13.17.0/third-party/pjproject/patches/0037-r5576-svn-backport-session-timer-crash.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0037-r5576-svn-backport-session-timer-crash.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0037-r5576-svn-backport-session-timer-crash.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,72 @@
+Index: pjproject/trunk/pjsip/src/pjsip-ua/sip_timer.c
+===================================================================
+--- a/pjsip/src/pjsip-ua/sip_timer.c	(revision 5557)
++++ b/pjsip/src/pjsip-ua/sip_timer.c	(revision 5576)
+@@ -333,6 +333,8 @@
+     pjsip_tx_data *tdata = NULL;
+     pj_status_t status;
+     pj_bool_t as_refresher;
++    int entry_id;
++    char obj_name[PJ_MAX_OBJ_NAME];
+ 
+     pj_assert(inv);
+ 
+@@ -344,7 +346,10 @@
+     /* Check our role */
+     as_refresher =
+ 	(inv->timer->refresher == TR_UAC && inv->timer->role == PJSIP_ROLE_UAC) ||
+-	(inv->timer->refresher == TR_UAS && inv->timer->role == PJSIP_ROLE_UAS);    
++	(inv->timer->refresher == TR_UAS && inv->timer->role == PJSIP_ROLE_UAS);
++
++    entry_id = entry->id;
++    pj_ansi_strncpy(obj_name, inv->pool->obj_name, PJ_MAX_OBJ_NAME);
+ 
+     /* Do action based on role(refresher or refreshee). 
+      * As refresher:
+@@ -353,7 +358,7 @@
+      * As refreshee:
+      * - end session if there is no refresh request received.
+      */
+-    if (as_refresher && (entry->id != REFRESHER_EXPIRE_TIMER_ID)) {
++    if (as_refresher && (entry_id != REFRESHER_EXPIRE_TIMER_ID)) {
+ 	pj_time_val now;
+ 
+ 	/* As refresher, reshedule the refresh request on the following:
+@@ -414,7 +419,7 @@
+ 	}
+ 
+ 	pj_gettimeofday(&now);
+-	PJ_LOG(4, (inv->pool->obj_name,
++	PJ_LOG(4, (obj_name,
+ 		   "Refreshing session after %ds (expiration period=%ds)",
+ 		   (now.sec-inv->timer->last_refresh.sec),
+ 		   inv->timer->setting.sess_expires));
+@@ -432,7 +437,7 @@
+ 				       NULL, &tdata);
+ 
+ 	pj_gettimeofday(&now);
+-	PJ_LOG(3, (inv->pool->obj_name, 
++	PJ_LOG(3, (obj_name,
+ 		   "No session %s received after %ds "
+ 		   "(expiration period=%ds), stopping session now!",
+ 		   (as_refresher?"refresh response":"refresh"),
+@@ -451,11 +456,16 @@
+ 	status = pjsip_inv_send_msg(inv, tdata);	
+     }
+ 
++    /*
++     * At this point, dialog might have already been destroyed,
++     * including its pool used by the invite session.
++     */
++
+     /* Print error message, if any */
+     if (status != PJ_SUCCESS) {
+-	PJ_PERROR(2, (inv->pool->obj_name, status,
++	PJ_PERROR(2, (obj_name, status,
+ 		     "Error in %s session timer",
+-		     ((as_refresher && entry->id != REFRESHER_EXPIRE_TIMER_ID)? 
++		     ((as_refresher && entry_id != REFRESHER_EXPIRE_TIMER_ID)?
+ 		       "refreshing" : "terminating")));
+     }
+ }
+  
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0048-r5576-svn-backport-tls-crash.patch asterisk-13.17.0/third-party/pjproject/patches/0048-r5576-svn-backport-tls-crash.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0048-r5576-svn-backport-tls-crash.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0048-r5576-svn-backport-tls-crash.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,32 @@
+Index: /pjproject/trunk/pjlib/src/pj/ssl_sock_ossl.c
+===================================================================
+--- a/pjlib/src/pj/ssl_sock_ossl.c	(revision 5564)
++++ b/pjlib/src/pj/ssl_sock_ossl.c	(revision 5565)
+@@ -145,5 +145,6 @@
+     SSL_STATE_NULL,
+     SSL_STATE_HANDSHAKING,
+-    SSL_STATE_ESTABLISHED
++    SSL_STATE_ESTABLISHED,
++    SSL_STATE_ERROR
+ };
+ 
+@@ -1907,4 +1908,8 @@
+ 			buf->len += size_;
+     		
++                    if (status != PJ_SUCCESS) {
++                        ssock->ssl_state = SSL_STATE_ERROR;
++                    }
++
+ 		    ret = (*ssock->param.cb.on_data_read)(ssock, buf->data,
+ 							  buf->len, status,
+@@ -2658,5 +2663,9 @@
+ 	/* Current cipher */
+ 	cipher = SSL_get_current_cipher(ssock->ossl_ssl);
+-	info->cipher = (SSL_CIPHER_get_id(cipher) & 0x00FFFFFF);
++	if (cipher) {
++	    info->cipher = (SSL_CIPHER_get_id(cipher) & 0x00FFFFFF);
++	} else {
++	    info->cipher = PJ_TLS_UNKNOWN_CIPHER;
++	}
+ 
+ 	/* Remote address */
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0058-Parse-zero-length-multipart-body-parts-correctly.patch asterisk-13.17.0/third-party/pjproject/patches/0058-Parse-zero-length-multipart-body-parts-correctly.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0058-Parse-zero-length-multipart-body-parts-correctly.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0058-Parse-zero-length-multipart-body-parts-correctly.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,41 @@
+From f0c717463d569f87a16f9b014033c8ca8939a7b4 Mon Sep 17 00:00:00 2001
+From: Mark Michelson <mmichelson@digium.com>
+Date: Thu, 13 Apr 2017 16:59:40 -0500
+Subject: [PATCH] Parse zero-length multipart body parts correctly.
+
+The calculation of end_body could result in a negative length being
+passed to multipart_body_parse_part().
+---
+ pjsip/src/pjsip/sip_multipart.c | 16 +++++++++-------
+ 1 file changed, 9 insertions(+), 7 deletions(-)
+
+diff --git a/pjsip/src/pjsip/sip_multipart.c b/pjsip/src/pjsip/sip_multipart.c
+index 8351f7e..b302139 100644
+--- a/pjsip/src/pjsip/sip_multipart.c
++++ b/pjsip/src/pjsip/sip_multipart.c
+@@ -653,13 +653,15 @@ PJ_DEF(pjsip_msg_body*) pjsip_multipart_parse(pj_pool_t *pool,
+ 
+ 	end_body = curptr;
+ 
+-	/* The newline preceeding the delimiter is conceptually part of
+-	 * the delimiter, so trim it from the body.
+-	 */
+-	if (*(end_body-1) == '\n')
+-	    --end_body;
+-	if (*(end_body-1) == '\r')
+-	    --end_body;
++	if (end_body > start_body) {
++	    /* The newline preceeding the delimiter is conceptually part of
++	     * the delimiter, so trim it from the body.
++	     */
++	    if (*(end_body-1) == '\n')
++		--end_body;
++	    if (*(end_body-1) == '\r')
++		 --end_body;
++	}
+ 
+ 	/* Now that we have determined the part's boundary, parse it
+ 	 * to get the header and body part of the part.
+-- 
+1.9.1
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0059-Ensure-2543-transaction-key-buffer-is-large-enough.patch asterisk-13.17.0/third-party/pjproject/patches/0059-Ensure-2543-transaction-key-buffer-is-large-enough.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0059-Ensure-2543-transaction-key-buffer-is-large-enough.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0059-Ensure-2543-transaction-key-buffer-is-large-enough.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,29 @@
+From b5f0f8868363c482a2c4ce343e3ee6ad256b0708 Mon Sep 17 00:00:00 2001
+From: Mark Michelson <mmichelson@digium.com>
+Date: Thu, 13 Apr 2017 16:20:07 -0500
+Subject: [PATCH] Ensure 2543 transaction key buffer is large enough.
+
+The CSeq method length needs to be factored into the allocated buffer
+length. Otherwise, the buffer may not be large enough to accommodate the
+entire key.
+---
+ pjsip/src/pjsip/sip_transaction.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/pjsip/src/pjsip/sip_transaction.c b/pjsip/src/pjsip/sip_transaction.c
+index c1750dc..2200d8d 100644
+--- a/pjsip/src/pjsip/sip_transaction.c
++++ b/pjsip/src/pjsip/sip_transaction.c
+@@ -288,7 +288,8 @@ static pj_status_t create_tsx_key_2543( pj_pool_t *pool,
+     host = &rdata->msg_info.via->sent_by.host;
+ 
+     /* Calculate length required. */
+-    len_required = 9 +			    /* CSeq number */
++    len_required = method->name.slen +	    /* Method */
++		   9 +			    /* CSeq number */
+ 		   rdata->msg_info.from->tag.slen +   /* From tag. */
+ 		   rdata->msg_info.cid->id.slen +    /* Call-ID */
+ 		   host->slen +		    /* Via host. */
+-- 
+1.9.1
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/0070-Set-PJSIP_INV_SUPPORT_UPDATE-correctly-in-pjsip_inv_.patch asterisk-13.17.0/third-party/pjproject/patches/0070-Set-PJSIP_INV_SUPPORT_UPDATE-correctly-in-pjsip_inv_.patch
--- asterisk-13.9.1/third-party/pjproject/patches/0070-Set-PJSIP_INV_SUPPORT_UPDATE-correctly-in-pjsip_inv_.patch	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/0070-Set-PJSIP_INV_SUPPORT_UPDATE-correctly-in-pjsip_inv_.patch	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,29 @@
+From 1193681959816effa121c4470748d5faa3a59272 Mon Sep 17 00:00:00 2001
+From: George Joseph <gjoseph@digium.com>
+Date: Thu, 29 Jun 2017 13:42:10 -0600
+Subject: [PATCH] Set PJSIP_INV_SUPPORT_UPDATE correctly in
+ pjsip_inv_verify_request3
+
+pjsip_inv_verify_request3 was setting rem_options when UPDATE was
+detected in the Allow header.  That's just an internal variable and
+doesn't go anywhere.  It's '*options' that needs to be set.
+---
+ pjsip/src/pjsip-ua/sip_inv.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/pjsip/src/pjsip-ua/sip_inv.c b/pjsip/src/pjsip-ua/sip_inv.c
+index fbc8ebe..6db7e6b 100644
+--- a/pjsip/src/pjsip-ua/sip_inv.c
++++ b/pjsip/src/pjsip-ua/sip_inv.c
+@@ -1237,7 +1237,7 @@ PJ_DEF(pj_status_t) pjsip_inv_verify_request3(pjsip_rx_data *rdata,
+ 
+ 	if (i != allow->count) {
+ 	    /* UPDATE is present in Allow */
+-	    rem_option |= PJSIP_INV_SUPPORT_UPDATE;
++	    *options |= PJSIP_INV_SUPPORT_UPDATE;
+ 	}
+ 
+     }
+-- 
+2.9.4
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/README asterisk-13.17.0/third-party/pjproject/patches/README
--- asterisk-13.9.1/third-party/pjproject/patches/README	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/README	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,7 @@
+The 0000-* patches in this directory should not be removed or
+reordered when upgrading to a new version of pjproject.  They
+MAY need to be updated to apply cleanly however.
+
+New patches should be numbered in ascending order with no
+duplicates.  Leave 10 slots open after the last patch to
+allow others to be inserted.
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/asterisk_malloc_debug.c asterisk-13.17.0/third-party/pjproject/patches/asterisk_malloc_debug.c
--- asterisk-13.9.1/third-party/pjproject/patches/asterisk_malloc_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/asterisk_malloc_debug.c	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2016, Digium, Inc
+ *
+ * George Joseph <gjoseph@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+int __ast_asprintf(const char *file, int lineno, const char *func, char **strp, const char *format, ...)
+{
+	va_list ap;
+	int rc = 0;
+
+	va_start(ap, format);
+	rc = vasprintf(strp, format, ap);
+	va_end(ap);
+
+	return rc;
+}
+
+void *__ast_calloc(size_t nmemb, size_t size, const char *file, int lineno, const char *func)
+{
+	return calloc(nmemb, size);
+}
+
+void __ast_free(void *ptr, const char *file, int lineno, const char *func)
+{
+	free(ptr);
+}
+
+void *__ast_malloc(size_t size, const char *file, int lineno, const char *func)
+{
+	return malloc(size);
+}
+
+void *__ast_realloc(void *ptr, size_t size, const char *file, int lineno, const char *func)
+{
+	return realloc(ptr, size);
+}
+
+char *__ast_strdup(const char *s, const char *file, int lineno, const char *func)
+{
+	return strdup(s);
+}
+
+char *__ast_strndup(const char *s, size_t n, const char *file, int lineno, const char *func)
+{
+	return strndup(s, n);
+}
+
+int __ast_vasprintf(char **strp, const char *format, va_list ap, const char *file, int lineno, const char *func)
+{
+	return vasprintf(strp, format, ap);
+}
+
+
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/asterisk_malloc_debug.h asterisk-13.17.0/third-party/pjproject/patches/asterisk_malloc_debug.h
--- asterisk-13.9.1/third-party/pjproject/patches/asterisk_malloc_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-13.17.0/third-party/pjproject/patches/asterisk_malloc_debug.h	2017-07-12 13:12:08.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 George Joseph <gjoseph@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+#ifndef ASTERISK_MALLOC_DEBUG_H_
+#define ASTERISK_MALLOC_DEBUG_H_
+
+/* Include these now to prevent them from messing up MALLOC_DEBUG */
+#include <sys/types.h>
+#include <pj/compat/string.h>
+#include <pj/compat/stdarg.h>
+#include <pj/compat/malloc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int __ast_asprintf(const char *file, int lineno, const char *func, char **strp, const char *format, ...)
+	__attribute__((format(printf, 5, 6)));
+void *__ast_calloc(size_t nmemb, size_t size, const char *file, int lineno, const char *func);
+void __ast_free(void *ptr, const char *file, int lineno, const char *func);
+void *__ast_malloc(size_t size, const char *file, int lineno, const char *func);
+void *__ast_realloc(void *ptr, size_t size, const char *file, int lineno, const char *func);
+char *__ast_strdup(const char *s, const char *file, int lineno, const char *func);
+char *__ast_strndup(const char *s, size_t n, const char *file, int lineno, const char *func);
+int __ast_vasprintf(char **strp, const char *format, va_list ap, const char *file, int lineno, const char *func)
+	__attribute__((format(printf, 2, 0)));
+
+/* Undefine any macros */
+#undef asprintf
+#undef calloc
+#undef free
+#undef malloc
+#undef realloc
+#undef strdup
+#undef strndup
+#undef vasprintf
+
+ /* Provide our own definitions */
+#define asprintf(a, b, c...) \
+	__ast_asprintf(__FILE__, __LINE__, __PRETTY_FUNCTION__, a, b, c)
+
+#define calloc(a,b) \
+	__ast_calloc(a,b,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#define free(a) \
+	__ast_free(a,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#define malloc(a) \
+	__ast_malloc(a,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#define realloc(a,b) \
+	__ast_realloc(a,b,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#define strdup(a) \
+	__ast_strdup(a,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#define strndup(a,b) \
+	__ast_strndup(a,b,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#define vasprintf(a,b,c) \
+	__ast_vasprintf(a,b,c,__FILE__, __LINE__, __PRETTY_FUNCTION__)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ASTERISK_MALLOC_DEBUG_H_ */
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/config_site.h asterisk-13.17.0/third-party/pjproject/patches/config_site.h
--- asterisk-13.9.1/third-party/pjproject/patches/config_site.h	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/config_site.h	2017-07-12 13:12:08.000000000 +0200
@@ -4,6 +4,28 @@
 
 #include <sys/select.h>
 
+/*
+ * Since both pjproject and asterisk source files will include config_site.h,
+ * we need to make sure that only pjproject source files include asterisk_malloc_debug.h.
+ */
+#if defined(MALLOC_DEBUG) && !defined(_ASTERISK_ASTMM_H)
+#include "asterisk_malloc_debug.h"
+#endif
+
+/*
+ * Defining PJMEDIA_HAS_SRTP to 0 does NOT disable Asterisk's ability to use srtp.
+ * It only disables the pjmedia srtp transport which Asterisk doesn't use.
+ * The reason for the disable is that while Asterisk works fine with older libsrtp
+ * versions, newer versions of pjproject won't compile with them.
+ */
+#define PJMEDIA_HAS_SRTP 0
+
+/*
+ * Defining PJMEDIA_HAS_WEBRTC_AEC to 0 does NOT disable Asterisk's ability to use
+ * webrtc.  It only disables the pjmedia webrtc transport which Asterisk doesn't use.
+ */
+#define PJMEDIA_HAS_WEBRTC_AEC 0
+
 #define PJ_HAS_IPV6 1
 #define NDEBUG 1
 #define PJ_MAX_HOSTNAME (256)
@@ -18,8 +40,12 @@
 
 #define PJ_SCANNER_USE_BITWISE	0
 #define PJ_OS_HAS_CHECK_STACK	0
-#define PJ_LOG_MAX_LEVEL		3
-#define PJ_ENABLE_EXTRA_CHECK	0
+
+#ifndef PJ_LOG_MAX_LEVEL
+#define PJ_LOG_MAX_LEVEL		6
+#endif
+
+#define PJ_ENABLE_EXTRA_CHECK	1
 #define PJSIP_MAX_TSX_COUNT		((64*1024)-1)
 #define PJSIP_MAX_DIALOG_COUNT	((64*1024)-1)
 #define PJSIP_UDP_SO_SNDBUF_SIZE	(512*1024)
@@ -27,7 +53,16 @@
 #define PJ_DEBUG			0
 #define PJSIP_SAFE_MODULE		0
 #define PJ_HAS_STRICMP_ALNUM		0
-#define PJ_HASH_USE_OWN_TOLOWER		1
+
+/*
+ * Do not ever enable PJ_HASH_USE_OWN_TOLOWER because the algorithm is
+ * inconsistently used when calculating the hash value and doesn't
+ * convert the same characters as pj_tolower()/tolower().  Thus you
+ * can get different hash values if the string hashed has certain
+ * characters in it.  (ASCII '@', '[', '\\', ']', '^', and '_')
+ */
+#undef PJ_HASH_USE_OWN_TOLOWER
+
 /*
   It is imperative that PJSIP_UNESCAPE_IN_PLACE remain 0 or undefined.
   Enabling it will result in SEGFAULTS when URIs containing escape sequences are encountered.
@@ -37,3 +72,13 @@
 
 #undef PJ_TODO
 #define PJ_TODO(x)
+
+/* Defaults too low for WebRTC */
+#define PJ_ICE_MAX_CAND 32
+#define PJ_ICE_MAX_CHECKS (PJ_ICE_MAX_CAND * PJ_ICE_MAX_CAND)
+
+/* Increase limits to allow more formats */
+#define	PJMEDIA_MAX_SDP_FMT   64
+#define	PJMEDIA_MAX_SDP_BANDW   4
+#define	PJMEDIA_MAX_SDP_ATTR   (PJMEDIA_MAX_SDP_FMT*2 + 4)
+#define	PJMEDIA_MAX_SDP_MEDIA   16
diff -urpN asterisk-13.9.1/third-party/pjproject/patches/user.mak asterisk-13.17.0/third-party/pjproject/patches/user.mak
--- asterisk-13.9.1/third-party/pjproject/patches/user.mak	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/pjproject/patches/user.mak	2017-07-12 13:12:08.000000000 +0200
@@ -1,2 +1,4 @@
 
-CFLAGS += -fPIC -Wno-unused-but-set-variable -Wno-unused-variable -Wno-unused-label -Wno-unused-function -Wno-strict-aliasing
+NUBSV := $(shell gcc -Wno-unused-but-set-variable -o /dev/null -xc -c - </dev/null 2>/dev/null && echo -Wno-unused-but-set-variable)
+
+CFLAGS += -fPIC $(NUBSV) -Wno-unused-variable -Wno-unused-label -Wno-unused-function -Wno-strict-aliasing
diff -urpN asterisk-13.9.1/third-party/versions.mak asterisk-13.17.0/third-party/versions.mak
--- asterisk-13.9.1/third-party/versions.mak	2016-05-13 19:41:41.000000000 +0200
+++ asterisk-13.17.0/third-party/versions.mak	2017-07-12 13:12:08.000000000 +0200
@@ -1,2 +1,2 @@
 
-PJPROJECT_VERSION = 2.4.5
+PJPROJECT_VERSION = 2.6
