diff -urpN wireguard-tools.old/contrib/embeddable-wg-library/test.c wireguard-tools/contrib/embeddable-wg-library/test.c
diff -urpN wireguard-tools.old/contrib/embeddable-wg-library/wireguard.c wireguard-tools/contrib/embeddable-wg-library/wireguard.c
diff -urpN wireguard-tools.old/contrib/extract-handshakes/Makefile wireguard-tools/contrib/extract-handshakes/Makefile
diff -urpN wireguard-tools.old/contrib/extract-handshakes/offset-finder.c wireguard-tools/contrib/extract-handshakes/offset-finder.c
diff -urpN wireguard-tools.old/contrib/extract-keys/config.c wireguard-tools/contrib/extract-keys/config.c
diff -urpN wireguard-tools.old/contrib/extract-keys/Makefile wireguard-tools/contrib/extract-keys/Makefile
diff -urpN wireguard-tools.old/.git/FETCH_HEAD wireguard-tools/.git/FETCH_HEAD
Binary files wireguard-tools.old/.git/index and wireguard-tools/.git/index differ
diff -urpN wireguard-tools.old/.git/logs/HEAD wireguard-tools/.git/logs/HEAD
diff -urpN wireguard-tools.old/.git/logs/refs/heads/master wireguard-tools/.git/logs/refs/heads/master
diff -urpN wireguard-tools.old/.git/logs/refs/remotes/origin/master wireguard-tools/.git/logs/refs/remotes/origin/master
Binary files wireguard-tools.old/.git/objects/0b/f1f7a3e877aff8fb435c3ba8624f35ff985a7e and wireguard-tools/.git/objects/0b/f1f7a3e877aff8fb435c3ba8624f35ff985a7e differ
diff -urpN wireguard-tools.old/.git/objects/0d/c32bbeaf05c0ac7f4b6d131c0473434e12e25a wireguard-tools/.git/objects/0d/c32bbeaf05c0ac7f4b6d131c0473434e12e25a
\ No newline at end of file
diff -urpN wireguard-tools.old/.git/objects/0f/6ef2cc44855c70a7fb8e5d548fbc7bf39f0b67 wireguard-tools/.git/objects/0f/6ef2cc44855c70a7fb8e5d548fbc7bf39f0b67
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/17/39a9eb5713b94e3b1bf67fdbd6a069fe0b98d1 and wireguard-tools/.git/objects/17/39a9eb5713b94e3b1bf67fdbd6a069fe0b98d1 differ
Binary files wireguard-tools.old/.git/objects/19/fcc5a884b1a1980d4bb6cbb3b7029b7ffba97c and wireguard-tools/.git/objects/19/fcc5a884b1a1980d4bb6cbb3b7029b7ffba97c differ
Binary files wireguard-tools.old/.git/objects/1a/d6b17c35d98677459b32fdbeba1129b80c5995 and wireguard-tools/.git/objects/1a/d6b17c35d98677459b32fdbeba1129b80c5995 differ
Binary files wireguard-tools.old/.git/objects/1e/4d73b913509ae278260adebd8f0c8b7897a67e and wireguard-tools/.git/objects/1e/4d73b913509ae278260adebd8f0c8b7897a67e differ
Binary files wireguard-tools.old/.git/objects/1f/2bd75409c5d45a4a16bf05bc7046d4d60f98bc and wireguard-tools/.git/objects/1f/2bd75409c5d45a4a16bf05bc7046d4d60f98bc differ
Binary files wireguard-tools.old/.git/objects/24/1b0d5d4044b19b0dbd278dab5e143d8f53c1e9 and wireguard-tools/.git/objects/24/1b0d5d4044b19b0dbd278dab5e143d8f53c1e9 differ
Binary files wireguard-tools.old/.git/objects/27/860c8905bc42c2a556c3ae4c6b9ce163159f86 and wireguard-tools/.git/objects/27/860c8905bc42c2a556c3ae4c6b9ce163159f86 differ
diff -urpN wireguard-tools.old/.git/objects/27/c885ff0844c3391a8fc4ef1165edb354455ec5 wireguard-tools/.git/objects/27/c885ff0844c3391a8fc4ef1165edb354455ec5
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/2b/45ec81f5beb2d04233566a70aab3fdc662e0b1 and wireguard-tools/.git/objects/2b/45ec81f5beb2d04233566a70aab3fdc662e0b1 differ
Binary files wireguard-tools.old/.git/objects/2e/36369f2ecc425c12bf2af7c523c34cbb77d59c and wireguard-tools/.git/objects/2e/36369f2ecc425c12bf2af7c523c34cbb77d59c differ
diff -urpN wireguard-tools.old/.git/objects/2f/406150f4e66be81ecdea90bcc9dcacf6387d4f wireguard-tools/.git/objects/2f/406150f4e66be81ecdea90bcc9dcacf6387d4f
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/33/b5f9771b41cc7f85a8a0bf6f97cbef1e609461 and wireguard-tools/.git/objects/33/b5f9771b41cc7f85a8a0bf6f97cbef1e609461 differ
Binary files wireguard-tools.old/.git/objects/39/58c522c137419ace083da4286fe55464d3c6dd and wireguard-tools/.git/objects/39/58c522c137419ace083da4286fe55464d3c6dd differ
Binary files wireguard-tools.old/.git/objects/39/8205c1c351ce9a6b40cadedf12c65f7b1b721d and wireguard-tools/.git/objects/39/8205c1c351ce9a6b40cadedf12c65f7b1b721d differ
Binary files wireguard-tools.old/.git/objects/4c/1034175494b8ba1bbb4c52559832e0f878f2d5 and wireguard-tools/.git/objects/4c/1034175494b8ba1bbb4c52559832e0f878f2d5 differ
Binary files wireguard-tools.old/.git/objects/4c/5ec496f53b0e54f3555160d4503af5f4a60bdc and wireguard-tools/.git/objects/4c/5ec496f53b0e54f3555160d4503af5f4a60bdc differ
Binary files wireguard-tools.old/.git/objects/53/e77672a411a6d6f562517270b784f31746434e and wireguard-tools/.git/objects/53/e77672a411a6d6f562517270b784f31746434e differ
Binary files wireguard-tools.old/.git/objects/54/0e9fb1bef472ea64200a5b485d40a86f4379e1 and wireguard-tools/.git/objects/54/0e9fb1bef472ea64200a5b485d40a86f4379e1 differ
Binary files wireguard-tools.old/.git/objects/54/ea81cc0f9edcebf3f6e185f9be78c8a3d975a1 and wireguard-tools/.git/objects/54/ea81cc0f9edcebf3f6e185f9be78c8a3d975a1 differ
Binary files wireguard-tools.old/.git/objects/58/795f788a019d15f1949b687ad55d4587a6f66e and wireguard-tools/.git/objects/58/795f788a019d15f1949b687ad55d4587a6f66e differ
diff -urpN wireguard-tools.old/.git/objects/59/009ef9330be18eb7238af70746b3a1b403e211 wireguard-tools/.git/objects/59/009ef9330be18eb7238af70746b3a1b403e211
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/5a/4d035c3146847ef367dde91c3840e360cd7cfb and wireguard-tools/.git/objects/5a/4d035c3146847ef367dde91c3840e360cd7cfb differ
Binary files wireguard-tools.old/.git/objects/5f/809a8ce9b1166fc26e4091dba2464fdace012a and wireguard-tools/.git/objects/5f/809a8ce9b1166fc26e4091dba2464fdace012a differ
Binary files wireguard-tools.old/.git/objects/60/9c6bbe827d55b895f4ca11e57c5485bf1ad8ea and wireguard-tools/.git/objects/60/9c6bbe827d55b895f4ca11e57c5485bf1ad8ea differ
diff -urpN wireguard-tools.old/.git/objects/67/71c4454eab2661166c1c672db7b76ff3f18020 wireguard-tools/.git/objects/67/71c4454eab2661166c1c672db7b76ff3f18020
\ No newline at end of file
diff -urpN wireguard-tools.old/.git/objects/6f/abf9c2fbd056c8c6d5ee9ffd69685aab6baaeb wireguard-tools/.git/objects/6f/abf9c2fbd056c8c6d5ee9ffd69685aab6baaeb
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/8a/100520327bb0321eca76b026a5a52c1101a487 and wireguard-tools/.git/objects/8a/100520327bb0321eca76b026a5a52c1101a487 differ
Binary files wireguard-tools.old/.git/objects/8d/c82cb872fe743b07b6805bce2f6435cf73d179 and wireguard-tools/.git/objects/8d/c82cb872fe743b07b6805bce2f6435cf73d179 differ
Binary files wireguard-tools.old/.git/objects/94/26c1e5bf9c4b0a64cc1e42272c6cbf58ddb18f and wireguard-tools/.git/objects/94/26c1e5bf9c4b0a64cc1e42272c6cbf58ddb18f differ
Binary files wireguard-tools.old/.git/objects/9c/e0405bb402f61532ce2fd31b17be18f246d906 and wireguard-tools/.git/objects/9c/e0405bb402f61532ce2fd31b17be18f246d906 differ
Binary files wireguard-tools.old/.git/objects/9d/936c0480c04c0b49b4d34692df4836da3c7a4a and wireguard-tools/.git/objects/9d/936c0480c04c0b49b4d34692df4836da3c7a4a differ
Binary files wireguard-tools.old/.git/objects/a0/bf60773903e3de512ee05b0254d792d36730af and wireguard-tools/.git/objects/a0/bf60773903e3de512ee05b0254d792d36730af differ
Binary files wireguard-tools.old/.git/objects/a9/cda2041a8dc801dba38e7f1baa30eaa7627945 and wireguard-tools/.git/objects/a9/cda2041a8dc801dba38e7f1baa30eaa7627945 differ
Binary files wireguard-tools.old/.git/objects/aa/44c792e4df0e8d99a94dc71987ea9e5d59a247 and wireguard-tools/.git/objects/aa/44c792e4df0e8d99a94dc71987ea9e5d59a247 differ
Binary files wireguard-tools.old/.git/objects/aa/ac6e93fc1ed25e2836a377c34949cbc9fd31f1 and wireguard-tools/.git/objects/aa/ac6e93fc1ed25e2836a377c34949cbc9fd31f1 differ
Binary files wireguard-tools.old/.git/objects/ab/513f11acb195b1ac0f0fe282707b17a7082b77 and wireguard-tools/.git/objects/ab/513f11acb195b1ac0f0fe282707b17a7082b77 differ
Binary files wireguard-tools.old/.git/objects/b9/d25324c94b4ec6190c9087e46f7e817d37d899 and wireguard-tools/.git/objects/b9/d25324c94b4ec6190c9087e46f7e817d37d899 differ
Binary files wireguard-tools.old/.git/objects/c1/782f6500e492c05537b97dcad5f1a919971736 and wireguard-tools/.git/objects/c1/782f6500e492c05537b97dcad5f1a919971736 differ
Binary files wireguard-tools.old/.git/objects/c2/df57d1886790f83733c851e9125e094f340f15 and wireguard-tools/.git/objects/c2/df57d1886790f83733c851e9125e094f340f15 differ
Binary files wireguard-tools.old/.git/objects/c3/8c7d921a8c68d440a4632d80432af9332deccd and wireguard-tools/.git/objects/c3/8c7d921a8c68d440a4632d80432af9332deccd differ
diff -urpN wireguard-tools.old/.git/objects/ca/d8a5c74513d8bb26afe5a305cbb94e2bbaf329 wireguard-tools/.git/objects/ca/d8a5c74513d8bb26afe5a305cbb94e2bbaf329
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/ce/f2d629bcb125aed0b346e6660c70d1bb779428 and wireguard-tools/.git/objects/ce/f2d629bcb125aed0b346e6660c70d1bb779428 differ
Binary files wireguard-tools.old/.git/objects/d1/36813d46b7c68b051d96dee6eecf7178671626 and wireguard-tools/.git/objects/d1/36813d46b7c68b051d96dee6eecf7178671626 differ
diff -urpN wireguard-tools.old/.git/objects/d6/8b8b189c2671c261d0e49b02eaf2b86b5947fa wireguard-tools/.git/objects/d6/8b8b189c2671c261d0e49b02eaf2b86b5947fa
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/d9/2b016e21388cb54581e1c4d11a393f185a77cf and wireguard-tools/.git/objects/d9/2b016e21388cb54581e1c4d11a393f185a77cf differ
Binary files wireguard-tools.old/.git/objects/d9/8cb7f8ea204dd8995bbd961c0db6f0e37ffd03 and wireguard-tools/.git/objects/d9/8cb7f8ea204dd8995bbd961c0db6f0e37ffd03 differ
diff -urpN wireguard-tools.old/.git/objects/db/5cb4f15c053c250047cf83390c1ec0cbdcd07c wireguard-tools/.git/objects/db/5cb4f15c053c250047cf83390c1ec0cbdcd07c
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/e0/539e659467083b5e1ce8e46dee9e089831be88 and wireguard-tools/.git/objects/e0/539e659467083b5e1ce8e46dee9e089831be88 differ
Binary files wireguard-tools.old/.git/objects/e0/e9b12fec4f949a1079e1162519fc68a99a1fe4 and wireguard-tools/.git/objects/e0/e9b12fec4f949a1079e1162519fc68a99a1fe4 differ
diff -urpN wireguard-tools.old/.git/objects/e5/b08c2849256367fc6bf37be9e737bdb21ee66d wireguard-tools/.git/objects/e5/b08c2849256367fc6bf37be9e737bdb21ee66d
\ No newline at end of file
Binary files wireguard-tools.old/.git/objects/ec/5d3a6041616e89e3c3c523a07790d97b2791da and wireguard-tools/.git/objects/ec/5d3a6041616e89e3c3c523a07790d97b2791da differ
Binary files wireguard-tools.old/.git/objects/ef/117a91d1aa3caf02f89d0a824fee80a8f88b88 and wireguard-tools/.git/objects/ef/117a91d1aa3caf02f89d0a824fee80a8f88b88 differ
Binary files wireguard-tools.old/.git/objects/f5/edfecf2f7e8ff351773b4fec74005e3295cb6f and wireguard-tools/.git/objects/f5/edfecf2f7e8ff351773b4fec74005e3295cb6f differ
Binary files wireguard-tools.old/.git/objects/f9/729ee280f145513881dab71c9f9c325986919e and wireguard-tools/.git/objects/f9/729ee280f145513881dab71c9f9c325986919e differ
Binary files wireguard-tools.old/.git/objects/f9/a8bd4d7265701b5d67a095fab650af65eaab14 and wireguard-tools/.git/objects/f9/a8bd4d7265701b5d67a095fab650af65eaab14 differ
Binary files wireguard-tools.old/.git/objects/fa/0473b0ec00e6ae183cf0931ea1204f693bba8c and wireguard-tools/.git/objects/fa/0473b0ec00e6ae183cf0931ea1204f693bba8c differ
Binary files wireguard-tools.old/.git/objects/fa/142b93a0623d5e155b3b180ed23647890992a4 and wireguard-tools/.git/objects/fa/142b93a0623d5e155b3b180ed23647890992a4 differ
diff -urpN wireguard-tools.old/.git/ORIG_HEAD wireguard-tools/.git/ORIG_HEAD
diff -urpN wireguard-tools.old/.git/refs/heads/master wireguard-tools/.git/refs/heads/master
diff -urpN wireguard-tools.old/.git/refs/remotes/origin/master wireguard-tools/.git/refs/remotes/origin/master
diff -urpN wireguard-tools.old/.git/refs/tags/v1.0.20200206 wireguard-tools/.git/refs/tags/v1.0.20200206
diff -urpN wireguard-tools.old/README.md wireguard-tools/README.md
diff -urpN wireguard-tools.old/src/curve25519.c wireguard-tools/src/curve25519.c
--- wireguard-tools.old/src/curve25519.c	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/curve25519.c	2020-02-09 23:07:59.749543990 +0300
@@ -39,35 +39,39 @@ typedef int64_t s64;
 #define le32_to_cpup(a) (*(a))
 #define cpu_to_le64(a) (a)
 #endif
-static inline __le32 get_unaligned_le32(const u8 *a)
+#ifndef __unused
+#define __unused  __attribute__((unused))
+#endif
+#ifndef __always_inline
+#define __always_inline __inline __attribute__((__always_inline__))
+#endif
+#ifndef noinline
+#define noinline __attribute__((noinline))
+#endif
+#ifndef __aligned
+#define __aligned(x) __attribute__((aligned(x)))
+#endif
+#ifndef __force
+#define __force
+#endif
+
+static __always_inline __unused __le32 get_unaligned_le32(const u8 *a)
 {
 	__le32 l;
 	__builtin_memcpy(&l, a, sizeof(l));
 	return le32_to_cpup(&l);
 }
-static inline __le64 get_unaligned_le64(const u8 *a)
+static __always_inline __unused __le64 get_unaligned_le64(const u8 *a)
 {
 	__le64 l;
 	__builtin_memcpy(&l, a, sizeof(l));
 	return le64_to_cpup(&l);
 }
-static inline void put_unaligned_le64(u64 s, u8 *d)
+static __always_inline __unused void put_unaligned_le64(u64 s, u8 *d)
 {
 	__le64 l = cpu_to_le64(s);
 	__builtin_memcpy(d, &l, sizeof(l));
 }
-#ifndef __always_inline
-#define __always_inline __inline __attribute__((__always_inline__))
-#endif
-#ifndef noinline
-#define noinline __attribute__((noinline))
-#endif
-#ifndef __aligned
-#define __aligned(x) __attribute__((aligned(x)))
-#endif
-#ifndef __force
-#define __force
-#endif
 
 static noinline void memzero_explicit(void *s, size_t count)
 {
diff -urpN wireguard-tools.old/src/fuzz/Makefile wireguard-tools/src/fuzz/Makefile
--- wireguard-tools.old/src/fuzz/Makefile	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/fuzz/Makefile	2020-02-09 23:07:59.749543990 +0300
@@ -20,13 +20,13 @@ stringlist: stringlist.c ../ipc.c ../cur
 	$(CC) $(CFLAGS) -o $@ $<
 
 cmd: cmd.c $(wildcard ../*.c)
-	$(CC) $(CFLAGS) -D'RUNSTATEDIR="/var/empty"' -D'main(a,b)=wg_main(a,b)' -o $@ $^ -lmnl
+	$(CC) $(CFLAGS) -D'RUNSTATEDIR="/var/empty"' -D'main(a,b)=wg_main(a,b)' -o $@ $^
 
-set: set.c ../set.c ../ipc.c ../encoding.c ../mnlg.c ../curve25519.c ../config.c
-	$(CC) $(CFLAGS) -o $@ $< -lmnl
+set: set.c ../set.c ../ipc.c ../encoding.c ../curve25519.c ../config.c
+	$(CC) $(CFLAGS) -o $@ $<
 
-setconf: setconf.c ../setconf.c ../ipc.c ../encoding.c ../mnlg.c ../curve25519.c ../config.c
-	$(CC) $(CFLAGS) -o $@ $< -lmnl
+setconf: setconf.c ../setconf.c ../ipc.c ../encoding.c ../curve25519.c ../config.c
+	$(CC) $(CFLAGS) -o $@ $<
 
 clean:
 	$(RM) $(FUZZERS)
diff -urpN wireguard-tools.old/src/fuzz/set.c wireguard-tools/src/fuzz/set.c
--- wireguard-tools.old/src/fuzz/set.c	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/fuzz/set.c	2020-02-09 23:07:59.749543990 +0300
@@ -15,7 +15,6 @@
 static FILE *hacked_fopen(const char *pathname, const char *mode);
 #define fopen hacked_fopen
 #include "../config.c"
-#include "../mnlg.c"
 #include "../set.c"
 #undef stderr
 
diff -urpN wireguard-tools.old/src/fuzz/setconf.c wireguard-tools/src/fuzz/setconf.c
--- wireguard-tools.old/src/fuzz/setconf.c	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/fuzz/setconf.c	2020-02-09 23:07:59.749543990 +0300
@@ -13,7 +13,6 @@
 #undef parse_allowedips
 #include "../encoding.c"
 #include "../config.c"
-#include "../mnlg.c"
 static FILE *hacked_fopen(const char *pathname, const char *mode);
 #define fopen hacked_fopen
 #include "../setconf.c"
diff -urpN wireguard-tools.old/src/ipc.c wireguard-tools/src/ipc.c
--- wireguard-tools.old/src/ipc.c	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/ipc.c	2020-02-09 23:07:59.749543990 +0300
@@ -4,13 +4,10 @@
  */
 
 #ifdef __linux__
-#include <libmnl/libmnl.h>
 #include <linux/if_link.h>
-#include <linux/netlink.h>
 #include <linux/rtnetlink.h>
-#include <linux/genetlink.h>
 #include <linux/wireguard.h>
-#include "mnlg.h"
+#include "netlink.h"
 #endif
 #include <netinet/in.h>
 #include <sys/socket.h>
@@ -43,7 +40,7 @@
 #define SOCK_PATH RUNSTATEDIR "/wireguard/"
 #define SOCK_SUFFIX ".sock"
 #ifdef __linux__
-#define SOCKET_BUFFER_SIZE MNL_SOCKET_BUFFER_SIZE
+#define SOCKET_BUFFER_SIZE (mnl_ideal_socket_buffer_size())
 #else
 #define SOCKET_BUFFER_SIZE 8192
 #endif
diff -urpN wireguard-tools.old/src/Makefile wireguard-tools/src/Makefile
--- wireguard-tools.old/src/Makefile	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/Makefile	2020-02-09 23:07:59.749543990 +0300
@@ -50,12 +50,6 @@ WIREGUARD_TOOLS_VERSION = $(patsubst v%,
 ifneq ($(WIREGUARD_TOOLS_VERSION),)
 CFLAGS += -D'WIREGUARD_TOOLS_VERSION="$(WIREGUARD_TOOLS_VERSION)"'
 endif
-ifeq ($(PLATFORM),linux)
-LIBMNL_CFLAGS := $(shell $(PKG_CONFIG) --cflags libmnl 2>/dev/null)
-LIBMNL_LDLIBS := $(shell $(PKG_CONFIG) --libs libmnl 2>/dev/null || echo -lmnl)
-CFLAGS += $(LIBMNL_CFLAGS)
-LDLIBS += $(LIBMNL_LDLIBS)
-endif
 ifeq ($(PLATFORM),haiku)
 LDLIBS += -lnetwork -lbsd
 endif
diff -urpN wireguard-tools.old/src/man/wg.8 wireguard-tools/src/man/wg.8
--- wireguard-tools.old/src/man/wg.8	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/man/wg.8	2020-02-09 23:07:59.749543990 +0300
@@ -40,7 +40,7 @@ Sub-commands that take an INTERFACE must
 Shows current WireGuard configuration and runtime information of specified \fI<interface>\fP.
 If no \fI<interface>\fP is specified, \fI<interface>\fP defaults to \fIall\fP.
 If \fIinterfaces\fP is specified, prints a list of all WireGuard interfaces,
-one per line, and quit. If no options are given after the interface
+one per line, and quits. If no options are given after the interface
 specification, then prints a list of all attributes in a visually pleasing way
 meant for the terminal. Otherwise, prints specified information grouped by
 newlines and tabs, meant to be used in scripts. For this script-friendly display,
@@ -61,7 +61,7 @@ Sets configuration values for the specif
 for a peer, that peer is removed, not configured. If \fIlisten-port\fP
 is not specified, or set to 0, the port will be chosen randomly when the
 interface comes up. Both \fIprivate-key\fP and \fIpreshared-key\fP must
-be a files, because command line arguments are not considered private on
+be files, because command line arguments are not considered private on
 most systems but if you are using
 .BR bash (1),
 you may safely pass in a string by specifying as \fIprivate-key\fP or
@@ -212,6 +212,15 @@ are thus ignored.
 .br
     AllowedIPs = 10.10.10.230/32
 
+.SH DEBUGGING INFORMATION
+Sometimes it is useful to have information on the current runtime state of a tunnel. When using the Linux kernel module on a kernel that supports dynamic debugging, debugging information can be written into
+.BR dmesg (1)
+by running as root:
+
+\fB    # modprobe wireguard && echo module wireguard +p > /sys/kernel/debug/dynamic_debug/control\fP
+
+On userspace implementations, it is customary to set the \fILOG_LEVEL\fP environment variable to \fIdebug\fP.
+
 .SH ENVIRONMENT VARIABLES
 .TP
 .I WG_COLOR_MODE
diff -urpN wireguard-tools.old/src/man/wg-quick.8 wireguard-tools/src/man/wg-quick.8
--- wireguard-tools.old/src/man/wg-quick.8	2019-12-27 13:19:54.358654118 +0300
+++ wireguard-tools/src/man/wg-quick.8	2020-02-09 23:07:59.749543990 +0300
@@ -56,7 +56,7 @@ as usual.
 
 The configuration file adds a few extra configuration values to the format understood by
 .BR wg (8)
-in order to configure additional attribute of an interface. It handles the
+in order to configure additional attributes of an interface. It handles the
 values that it understands, and then it passes the remaining ones directly to
 .BR wg (8)
 for further processing.
diff -urpN wireguard-tools.old/src/mnlg.c wireguard-tools/src/mnlg.c
--- wireguard-tools.old/src/mnlg.c	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/mnlg.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,330 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * Original author: Jiri Pirko <jiri@mellanox.com>
- */
-
-#ifdef __linux__
-
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <errno.h>
-#include <unistd.h>
-#include <time.h>
-#include <libmnl/libmnl.h>
-#include <linux/genetlink.h>
-
-#include "mnlg.h"
-
-struct mnlg_socket {
-	struct mnl_socket *nl;
-	char *buf;
-	uint16_t id;
-	uint8_t version;
-	unsigned int seq;
-	unsigned int portid;
-};
-
-static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-					   uint16_t flags, uint16_t id,
-					   uint8_t version)
-{
-	struct nlmsghdr *nlh;
-	struct genlmsghdr *genl;
-
-	nlh = mnl_nlmsg_put_header(nlg->buf);
-	nlh->nlmsg_type	= id;
-	nlh->nlmsg_flags = flags;
-	nlg->seq = time(NULL);
-	nlh->nlmsg_seq = nlg->seq;
-
-	genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
-	genl->cmd = cmd;
-	genl->version = version;
-
-	return nlh;
-}
-
-struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-				  uint16_t flags)
-{
-	return __mnlg_msg_prepare(nlg, cmd, flags, nlg->id, nlg->version);
-}
-
-int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh)
-{
-	return mnl_socket_sendto(nlg->nl, nlh, nlh->nlmsg_len);
-}
-
-static int mnlg_cb_noop(const struct nlmsghdr *nlh, void *data)
-{
-	(void)nlh;
-	(void)data;
-	return MNL_CB_OK;
-}
-
-static int mnlg_cb_error(const struct nlmsghdr *nlh, void *data)
-{
-	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
-	(void)data;
-
-	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
-		errno = EBADMSG;
-		return MNL_CB_ERROR;
-	}
-	/* Netlink subsystems returns the errno value with different signess */
-	if (err->error < 0)
-		errno = -err->error;
-	else
-		errno = err->error;
-
-	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
-}
-
-static int mnlg_cb_stop(const struct nlmsghdr *nlh, void *data)
-{
-	(void)data;
-	if (nlh->nlmsg_flags & NLM_F_MULTI && nlh->nlmsg_len == mnl_nlmsg_size(sizeof(int))) {
-		int error = *(int *)mnl_nlmsg_get_payload(nlh);
-		/* Netlink subsystems returns the errno value with different signess */
-		if (error < 0)
-			errno = -error;
-		else
-			errno = error;
-
-		return error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
-	}
-	return MNL_CB_STOP;
-}
-
-static mnl_cb_t mnlg_cb_array[] = {
-	[NLMSG_NOOP]	= mnlg_cb_noop,
-	[NLMSG_ERROR]	= mnlg_cb_error,
-	[NLMSG_DONE]	= mnlg_cb_stop,
-	[NLMSG_OVERRUN]	= mnlg_cb_noop,
-};
-
-int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
-{
-	int err;
-
-	do {
-		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
-					  MNL_SOCKET_BUFFER_SIZE);
-		if (err <= 0)
-			break;
-		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
-				  data_cb, data, mnlg_cb_array, MNL_ARRAY_SIZE(mnlg_cb_array));
-	} while (err > 0);
-
-	return err;
-}
-
-struct group_info {
-	bool found;
-	uint32_t id;
-	const char *name;
-};
-
-static int parse_mc_grps_cb(const struct nlattr *attr, void *data)
-{
-	const struct nlattr **tb = data;
-	int type = mnl_attr_get_type(attr);
-
-	if (mnl_attr_type_valid(attr, CTRL_ATTR_MCAST_GRP_MAX) < 0)
-		return MNL_CB_OK;
-
-	switch (type) {
-	case CTRL_ATTR_MCAST_GRP_ID:
-		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
-			return MNL_CB_ERROR;
-		break;
-	case CTRL_ATTR_MCAST_GRP_NAME:
-		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
-			return MNL_CB_ERROR;
-		break;
-	}
-	tb[type] = attr;
-	return MNL_CB_OK;
-}
-
-static void parse_genl_mc_grps(struct nlattr *nested,
-			       struct group_info *group_info)
-{
-	struct nlattr *pos;
-	const char *name;
-
-	mnl_attr_for_each_nested(pos, nested) {
-		struct nlattr *tb[CTRL_ATTR_MCAST_GRP_MAX + 1] = {};
-
-		mnl_attr_parse_nested(pos, parse_mc_grps_cb, tb);
-		if (!tb[CTRL_ATTR_MCAST_GRP_NAME] ||
-		    !tb[CTRL_ATTR_MCAST_GRP_ID])
-			continue;
-
-		name = mnl_attr_get_str(tb[CTRL_ATTR_MCAST_GRP_NAME]);
-		if (strcmp(name, group_info->name) != 0)
-			continue;
-
-		group_info->id = mnl_attr_get_u32(tb[CTRL_ATTR_MCAST_GRP_ID]);
-		group_info->found = true;
-	}
-}
-
-static int get_group_id_attr_cb(const struct nlattr *attr, void *data)
-{
-	const struct nlattr **tb = data;
-	int type = mnl_attr_get_type(attr);
-
-	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
-		return MNL_CB_ERROR;
-
-	if (type == CTRL_ATTR_MCAST_GROUPS &&
-	    mnl_attr_validate(attr, MNL_TYPE_NESTED) < 0)
-		return MNL_CB_ERROR;
-	tb[type] = attr;
-	return MNL_CB_OK;
-}
-
-static int get_group_id_cb(const struct nlmsghdr *nlh, void *data)
-{
-	struct group_info *group_info = data;
-	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
-
-	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_group_id_attr_cb, tb);
-	if (!tb[CTRL_ATTR_MCAST_GROUPS])
-		return MNL_CB_ERROR;
-	parse_genl_mc_grps(tb[CTRL_ATTR_MCAST_GROUPS], group_info);
-	return MNL_CB_OK;
-}
-
-int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name)
-{
-	struct nlmsghdr *nlh;
-	struct group_info group_info;
-	int err;
-
-	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
-				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
-	mnl_attr_put_u16(nlh, CTRL_ATTR_FAMILY_ID, nlg->id);
-
-	err = mnlg_socket_send(nlg, nlh);
-	if (err < 0)
-		return err;
-
-	group_info.found = false;
-	group_info.name = group_name;
-	err = mnlg_socket_recv_run(nlg, get_group_id_cb, &group_info);
-	if (err < 0)
-		return err;
-
-	if (!group_info.found) {
-		errno = ENOENT;
-		return -1;
-	}
-
-	err = mnl_socket_setsockopt(nlg->nl, NETLINK_ADD_MEMBERSHIP,
-				    &group_info.id, sizeof(group_info.id));
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
-{
-	const struct nlattr **tb = data;
-	int type = mnl_attr_get_type(attr);
-
-	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
-		return MNL_CB_ERROR;
-
-	if (type == CTRL_ATTR_FAMILY_ID &&
-	    mnl_attr_validate(attr, MNL_TYPE_U16) < 0)
-		return MNL_CB_ERROR;
-	tb[type] = attr;
-	return MNL_CB_OK;
-}
-
-static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
-{
-	uint16_t *p_id = data;
-	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
-
-	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);
-	if (!tb[CTRL_ATTR_FAMILY_ID])
-		return MNL_CB_ERROR;
-	*p_id = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
-	return MNL_CB_OK;
-}
-
-struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version)
-{
-	struct mnlg_socket *nlg;
-	struct nlmsghdr *nlh;
-	int err;
-
-	nlg = malloc(sizeof(*nlg));
-	if (!nlg)
-		return NULL;
-
-	err = -ENOMEM;
-	nlg->buf = malloc(MNL_SOCKET_BUFFER_SIZE);
-	if (!nlg->buf)
-		goto err_buf_alloc;
-
-	nlg->nl = mnl_socket_open(NETLINK_GENERIC);
-	if (!nlg->nl) {
-		err = -errno;
-		goto err_mnl_socket_open;
-	}
-
-	if (mnl_socket_bind(nlg->nl, 0, MNL_SOCKET_AUTOPID) < 0) {
-		err = -errno;
-		goto err_mnl_socket_bind;
-	}
-
-	nlg->portid = mnl_socket_get_portid(nlg->nl);
-
-	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
-				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
-	mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);
-
-	if (mnlg_socket_send(nlg, nlh) < 0) {
-		err = -errno;
-		goto err_mnlg_socket_send;
-	}
-
-	errno = 0;
-	if (mnlg_socket_recv_run(nlg, get_family_id_cb, &nlg->id) < 0) {
-		errno = errno == ENOENT ? EPROTONOSUPPORT : errno;
-		err = errno ? -errno : -ENOSYS;
-		goto err_mnlg_socket_recv_run;
-	}
-
-	nlg->version = version;
-	errno = 0;
-	return nlg;
-
-err_mnlg_socket_recv_run:
-err_mnlg_socket_send:
-err_mnl_socket_bind:
-	mnl_socket_close(nlg->nl);
-err_mnl_socket_open:
-	free(nlg->buf);
-err_buf_alloc:
-	free(nlg);
-	errno = -err;
-	return NULL;
-}
-
-void mnlg_socket_close(struct mnlg_socket *nlg)
-{
-	mnl_socket_close(nlg->nl);
-	free(nlg->buf);
-	free(nlg);
-}
-
-#endif
diff -urpN wireguard-tools.old/src/mnlg.h wireguard-tools/src/mnlg.h
--- wireguard-tools.old/src/mnlg.h	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/mnlg.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
- *
- * Original author: Jiri Pirko <jiri@mellanox.com>
- */
-
-#ifndef MNLG_H
-#define MNLG_H
-#ifdef __linux__
-
-#include <libmnl/libmnl.h>
-
-struct mnlg_socket;
-
-struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
-				  uint16_t flags);
-int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh);
-int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data);
-int mnlg_socket_group_add(struct mnlg_socket *nlg, const char *group_name);
-struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version);
-void mnlg_socket_close(struct mnlg_socket *nlg);
-
-#endif
-#endif
diff -urpN wireguard-tools.old/src/netlink.h wireguard-tools/src/netlink.h
--- wireguard-tools.old/src/netlink.h	1970-01-01 03:00:00.000000000 +0300
+++ wireguard-tools/src/netlink.h	2020-02-09 23:07:59.749543990 +0300
@@ -0,0 +1,797 @@
+// SPDX-License-Identifier: LGPL-2.1+
+/*
+ * Copyright (C) 2015-2020 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ * Copyright (C) 2008-2012 Pablo Neira Ayuso <pablo@netfilter.org>.
+ */
+
+/* This is a minimized version of libmnl meant to be #include'd */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+
+#define MNL_SOCKET_AUTOPID 0
+#define MNL_ALIGNTO 4
+#define MNL_ALIGN(len) (((len)+MNL_ALIGNTO-1) & ~(MNL_ALIGNTO-1))
+#define MNL_NLMSG_HDRLEN MNL_ALIGN(sizeof(struct nlmsghdr))
+#define MNL_ATTR_HDRLEN MNL_ALIGN(sizeof(struct nlattr))
+
+enum mnl_attr_data_type {
+	MNL_TYPE_UNSPEC,
+	MNL_TYPE_U8,
+	MNL_TYPE_U16,
+	MNL_TYPE_U32,
+	MNL_TYPE_U64,
+	MNL_TYPE_STRING,
+	MNL_TYPE_FLAG,
+	MNL_TYPE_MSECS,
+	MNL_TYPE_NESTED,
+	MNL_TYPE_NESTED_COMPAT,
+	MNL_TYPE_NUL_STRING,
+	MNL_TYPE_BINARY,
+	MNL_TYPE_MAX,
+};
+
+#define mnl_attr_for_each(attr, nlh, offset) \
+	for ((attr) = mnl_nlmsg_get_payload_offset((nlh), (offset)); \
+	     mnl_attr_ok((attr), (char *)mnl_nlmsg_get_payload_tail(nlh) - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
+
+#define mnl_attr_for_each_nested(attr, nest) \
+	for ((attr) = mnl_attr_get_payload(nest); \
+	     mnl_attr_ok((attr), (char *)mnl_attr_get_payload(nest) + mnl_attr_get_payload_len(nest) - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
+
+#define mnl_attr_for_each_payload(payload, payload_size) \
+	for ((attr) = (payload); \
+	     mnl_attr_ok((attr), (char *)(payload) + payload_size - (char *)(attr)); \
+	     (attr) = mnl_attr_next(attr))
+
+#define MNL_CB_ERROR	-1
+#define MNL_CB_STOP	0
+#define MNL_CB_OK	1
+
+typedef int (*mnl_attr_cb_t)(const struct nlattr *attr, void *data);
+typedef int (*mnl_cb_t)(const struct nlmsghdr *nlh, void *data);
+
+#ifndef MNL_ARRAY_SIZE
+#define MNL_ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
+#endif
+
+static size_t mnl_ideal_socket_buffer_size(void)
+{
+	static size_t size = 0;
+
+	if (size)
+		return size;
+	size = (size_t)sysconf(_SC_PAGESIZE);
+	if (size > 8192)
+		size = 8192;
+	return size;
+}
+
+static size_t mnl_nlmsg_size(size_t len)
+{
+	return len + MNL_NLMSG_HDRLEN;
+}
+
+static struct nlmsghdr *mnl_nlmsg_put_header(void *buf)
+{
+	int len = MNL_ALIGN(sizeof(struct nlmsghdr));
+	struct nlmsghdr *nlh = buf;
+
+	memset(buf, 0, len);
+	nlh->nlmsg_len = len;
+	return nlh;
+}
+
+static void *mnl_nlmsg_put_extra_header(struct nlmsghdr *nlh, size_t size)
+{
+	char *ptr = (char *)nlh + nlh->nlmsg_len;
+	size_t len = MNL_ALIGN(size);
+	nlh->nlmsg_len += len;
+	memset(ptr, 0, len);
+	return ptr;
+}
+
+static void *mnl_nlmsg_get_payload(const struct nlmsghdr *nlh)
+{
+	return (void *)nlh + MNL_NLMSG_HDRLEN;
+}
+
+static void *mnl_nlmsg_get_payload_offset(const struct nlmsghdr *nlh, size_t offset)
+{
+	return (void *)nlh + MNL_NLMSG_HDRLEN + MNL_ALIGN(offset);
+}
+
+static bool mnl_nlmsg_ok(const struct nlmsghdr *nlh, int len)
+{
+	return len >= (int)sizeof(struct nlmsghdr) &&
+	       nlh->nlmsg_len >= sizeof(struct nlmsghdr) &&
+	       (int)nlh->nlmsg_len <= len;
+}
+
+static struct nlmsghdr *mnl_nlmsg_next(const struct nlmsghdr *nlh, int *len)
+{
+	*len -= MNL_ALIGN(nlh->nlmsg_len);
+	return (struct nlmsghdr *)((void *)nlh + MNL_ALIGN(nlh->nlmsg_len));
+}
+
+static void *mnl_nlmsg_get_payload_tail(const struct nlmsghdr *nlh)
+{
+	return (void *)nlh + MNL_ALIGN(nlh->nlmsg_len);
+}
+
+static bool mnl_nlmsg_seq_ok(const struct nlmsghdr *nlh, unsigned int seq)
+{
+	return nlh->nlmsg_seq && seq ? nlh->nlmsg_seq == seq : true;
+}
+
+static bool mnl_nlmsg_portid_ok(const struct nlmsghdr *nlh, unsigned int portid)
+{
+	return nlh->nlmsg_pid && portid ? nlh->nlmsg_pid == portid : true;
+}
+
+static uint16_t mnl_attr_get_type(const struct nlattr *attr)
+{
+	return attr->nla_type & NLA_TYPE_MASK;
+}
+
+static uint16_t mnl_attr_get_payload_len(const struct nlattr *attr)
+{
+	return attr->nla_len - MNL_ATTR_HDRLEN;
+}
+
+static void *mnl_attr_get_payload(const struct nlattr *attr)
+{
+	return (void *)attr + MNL_ATTR_HDRLEN;
+}
+
+static bool mnl_attr_ok(const struct nlattr *attr, int len)
+{
+	return len >= (int)sizeof(struct nlattr) &&
+	       attr->nla_len >= sizeof(struct nlattr) &&
+	       (int)attr->nla_len <= len;
+}
+
+static struct nlattr *mnl_attr_next(const struct nlattr *attr)
+{
+	return (struct nlattr *)((void *)attr + MNL_ALIGN(attr->nla_len));
+}
+
+static int mnl_attr_type_valid(const struct nlattr *attr, uint16_t max)
+{
+	if (mnl_attr_get_type(attr) > max) {
+		errno = EOPNOTSUPP;
+		return -1;
+	}
+	return 1;
+}
+
+static int __mnl_attr_validate(const struct nlattr *attr,
+			       enum mnl_attr_data_type type, size_t exp_len)
+{
+	uint16_t attr_len = mnl_attr_get_payload_len(attr);
+	const char *attr_data = mnl_attr_get_payload(attr);
+
+	if (attr_len < exp_len) {
+		errno = ERANGE;
+		return -1;
+	}
+	switch(type) {
+	case MNL_TYPE_FLAG:
+		if (attr_len > 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_NUL_STRING:
+		if (attr_len == 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		if (attr_data[attr_len-1] != '\0') {
+			errno = EINVAL;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_STRING:
+		if (attr_len == 0) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	case MNL_TYPE_NESTED:
+
+		if (attr_len == 0)
+			break;
+
+		if (attr_len < MNL_ATTR_HDRLEN) {
+			errno = ERANGE;
+			return -1;
+		}
+		break;
+	default:
+
+		break;
+	}
+	if (exp_len && attr_len > exp_len) {
+		errno = ERANGE;
+		return -1;
+	}
+	return 0;
+}
+
+static const size_t mnl_attr_data_type_len[MNL_TYPE_MAX] = {
+	[MNL_TYPE_U8]		= sizeof(uint8_t),
+	[MNL_TYPE_U16]		= sizeof(uint16_t),
+	[MNL_TYPE_U32]		= sizeof(uint32_t),
+	[MNL_TYPE_U64]		= sizeof(uint64_t),
+	[MNL_TYPE_MSECS]	= sizeof(uint64_t),
+};
+
+static int mnl_attr_validate(const struct nlattr *attr, enum mnl_attr_data_type type)
+{
+	int exp_len;
+
+	if (type >= MNL_TYPE_MAX) {
+		errno = EINVAL;
+		return -1;
+	}
+	exp_len = mnl_attr_data_type_len[type];
+	return __mnl_attr_validate(attr, type, exp_len);
+}
+
+static int mnl_attr_parse(const struct nlmsghdr *nlh, unsigned int offset,
+			  mnl_attr_cb_t cb, void *data)
+{
+	int ret = MNL_CB_OK;
+	const struct nlattr *attr;
+
+	mnl_attr_for_each(attr, nlh, offset)
+		if ((ret = cb(attr, data)) <= MNL_CB_STOP)
+			return ret;
+	return ret;
+}
+
+static int mnl_attr_parse_nested(const struct nlattr *nested, mnl_attr_cb_t cb,
+				 void *data)
+{
+	int ret = MNL_CB_OK;
+	const struct nlattr *attr;
+
+	mnl_attr_for_each_nested(attr, nested)
+		if ((ret = cb(attr, data)) <= MNL_CB_STOP)
+			return ret;
+	return ret;
+}
+
+static uint8_t mnl_attr_get_u8(const struct nlattr *attr)
+{
+	return *((uint8_t *)mnl_attr_get_payload(attr));
+}
+
+static uint16_t mnl_attr_get_u16(const struct nlattr *attr)
+{
+	return *((uint16_t *)mnl_attr_get_payload(attr));
+}
+
+static uint32_t mnl_attr_get_u32(const struct nlattr *attr)
+{
+	return *((uint32_t *)mnl_attr_get_payload(attr));
+}
+
+static uint64_t mnl_attr_get_u64(const struct nlattr *attr)
+{
+	uint64_t tmp;
+	memcpy(&tmp, mnl_attr_get_payload(attr), sizeof(tmp));
+	return tmp;
+}
+
+static const char *mnl_attr_get_str(const struct nlattr *attr)
+{
+	return mnl_attr_get_payload(attr);
+}
+
+static void mnl_attr_put(struct nlmsghdr *nlh, uint16_t type, size_t len,
+			 const void *data)
+{
+	struct nlattr *attr = mnl_nlmsg_get_payload_tail(nlh);
+	uint16_t payload_len = MNL_ALIGN(sizeof(struct nlattr)) + len;
+	int pad;
+
+	attr->nla_type = type;
+	attr->nla_len = payload_len;
+	memcpy(mnl_attr_get_payload(attr), data, len);
+	nlh->nlmsg_len += MNL_ALIGN(payload_len);
+	pad = MNL_ALIGN(len) - len;
+	if (pad > 0)
+		memset(mnl_attr_get_payload(attr) + len, 0, pad);
+}
+
+static void mnl_attr_put_u16(struct nlmsghdr *nlh, uint16_t type, uint16_t data)
+{
+	mnl_attr_put(nlh, type, sizeof(uint16_t), &data);
+}
+
+static void mnl_attr_put_u32(struct nlmsghdr *nlh, uint16_t type, uint32_t data)
+{
+	mnl_attr_put(nlh, type, sizeof(uint32_t), &data);
+}
+
+static void mnl_attr_put_strz(struct nlmsghdr *nlh, uint16_t type, const char *data)
+{
+	mnl_attr_put(nlh, type, strlen(data)+1, data);
+}
+
+static struct nlattr *mnl_attr_nest_start(struct nlmsghdr *nlh, uint16_t type)
+{
+	struct nlattr *start = mnl_nlmsg_get_payload_tail(nlh);
+
+	start->nla_type = NLA_F_NESTED | type;
+	nlh->nlmsg_len += MNL_ALIGN(sizeof(struct nlattr));
+	return start;
+}
+
+static bool mnl_attr_put_check(struct nlmsghdr *nlh, size_t buflen,
+			       uint16_t type, size_t len, const void *data)
+{
+	if (nlh->nlmsg_len + MNL_ATTR_HDRLEN + MNL_ALIGN(len) > buflen)
+		return false;
+	mnl_attr_put(nlh, type, len, data);
+	return true;
+}
+
+static bool mnl_attr_put_u8_check(struct nlmsghdr *nlh, size_t buflen,
+				  uint16_t type, uint8_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint8_t), &data);
+}
+
+static bool mnl_attr_put_u16_check(struct nlmsghdr *nlh, size_t buflen,
+				   uint16_t type, uint16_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint16_t), &data);
+}
+
+static bool mnl_attr_put_u32_check(struct nlmsghdr *nlh, size_t buflen,
+				   uint16_t type, uint32_t data)
+{
+	return mnl_attr_put_check(nlh, buflen, type, sizeof(uint32_t), &data);
+}
+
+static struct nlattr *mnl_attr_nest_start_check(struct nlmsghdr *nlh, size_t buflen,
+						uint16_t type)
+{
+	if (nlh->nlmsg_len + MNL_ATTR_HDRLEN > buflen)
+		return NULL;
+	return mnl_attr_nest_start(nlh, type);
+}
+
+static void mnl_attr_nest_end(struct nlmsghdr *nlh, struct nlattr *start)
+{
+	start->nla_len = mnl_nlmsg_get_payload_tail(nlh) - (void *)start;
+}
+
+static void mnl_attr_nest_cancel(struct nlmsghdr *nlh, struct nlattr *start)
+{
+	nlh->nlmsg_len -= mnl_nlmsg_get_payload_tail(nlh) - (void *)start;
+}
+
+static int mnl_cb_noop(__attribute__((unused)) const struct nlmsghdr *nlh, __attribute__((unused)) void *data)
+{
+	return MNL_CB_OK;
+}
+
+static int mnl_cb_error(const struct nlmsghdr *nlh, __attribute__((unused)) void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnl_cb_stop(__attribute__((unused)) const struct nlmsghdr *nlh, __attribute__((unused)) void *data)
+{
+	return MNL_CB_STOP;
+}
+
+static const mnl_cb_t default_cb_array[NLMSG_MIN_TYPE] = {
+	[NLMSG_NOOP]	= mnl_cb_noop,
+	[NLMSG_ERROR]	= mnl_cb_error,
+	[NLMSG_DONE]	= mnl_cb_stop,
+	[NLMSG_OVERRUN]	= mnl_cb_noop,
+};
+
+static int __mnl_cb_run(const void *buf, size_t numbytes,
+			unsigned int seq, unsigned int portid,
+			mnl_cb_t cb_data, void *data,
+			const mnl_cb_t *cb_ctl_array,
+			unsigned int cb_ctl_array_len)
+{
+	int ret = MNL_CB_OK, len = numbytes;
+	const struct nlmsghdr *nlh = buf;
+
+	while (mnl_nlmsg_ok(nlh, len)) {
+
+		if (!mnl_nlmsg_portid_ok(nlh, portid)) {
+			errno = ESRCH;
+			return -1;
+		}
+
+		if (!mnl_nlmsg_seq_ok(nlh, seq)) {
+			errno = EPROTO;
+			return -1;
+		}
+
+		if (nlh->nlmsg_flags & NLM_F_DUMP_INTR) {
+			errno = EINTR;
+			return -1;
+		}
+
+		if (nlh->nlmsg_type >= NLMSG_MIN_TYPE) {
+			if (cb_data){
+				ret = cb_data(nlh, data);
+				if (ret <= MNL_CB_STOP)
+					goto out;
+			}
+		} else if (nlh->nlmsg_type < cb_ctl_array_len) {
+			if (cb_ctl_array && cb_ctl_array[nlh->nlmsg_type]) {
+				ret = cb_ctl_array[nlh->nlmsg_type](nlh, data);
+				if (ret <= MNL_CB_STOP)
+					goto out;
+			}
+		} else if (default_cb_array[nlh->nlmsg_type]) {
+			ret = default_cb_array[nlh->nlmsg_type](nlh, data);
+			if (ret <= MNL_CB_STOP)
+				goto out;
+		}
+		nlh = mnl_nlmsg_next(nlh, &len);
+	}
+out:
+	return ret;
+}
+
+static int mnl_cb_run2(const void *buf, size_t numbytes, unsigned int seq,
+		       unsigned int portid, mnl_cb_t cb_data, void *data,
+		       const mnl_cb_t *cb_ctl_array, unsigned int cb_ctl_array_len)
+{
+	return __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data,
+			    cb_ctl_array, cb_ctl_array_len);
+}
+
+static int mnl_cb_run(const void *buf, size_t numbytes, unsigned int seq,
+		      unsigned int portid, mnl_cb_t cb_data, void *data)
+{
+	return __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data, NULL, 0);
+}
+
+struct mnl_socket {
+	int 			fd;
+	struct sockaddr_nl	addr;
+};
+
+static unsigned int mnl_socket_get_portid(const struct mnl_socket *nl)
+{
+	return nl->addr.nl_pid;
+}
+
+static struct mnl_socket *__mnl_socket_open(int bus, int flags)
+{
+	struct mnl_socket *nl;
+
+	nl = calloc(1, sizeof(struct mnl_socket));
+	if (nl == NULL)
+		return NULL;
+
+	nl->fd = socket(AF_NETLINK, SOCK_RAW | flags, bus);
+	if (nl->fd == -1) {
+		free(nl);
+		return NULL;
+	}
+
+	return nl;
+}
+
+static struct mnl_socket *mnl_socket_open(int bus)
+{
+	return __mnl_socket_open(bus, 0);
+}
+
+static int mnl_socket_bind(struct mnl_socket *nl, unsigned int groups, pid_t pid)
+{
+	int ret;
+	socklen_t addr_len;
+
+	nl->addr.nl_family = AF_NETLINK;
+	nl->addr.nl_groups = groups;
+	nl->addr.nl_pid = pid;
+
+	ret = bind(nl->fd, (struct sockaddr *) &nl->addr, sizeof (nl->addr));
+	if (ret < 0)
+		return ret;
+
+	addr_len = sizeof(nl->addr);
+	ret = getsockname(nl->fd, (struct sockaddr *) &nl->addr, &addr_len);
+	if (ret < 0)
+		return ret;
+
+	if (addr_len != sizeof(nl->addr)) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (nl->addr.nl_family != AF_NETLINK) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+static ssize_t mnl_socket_sendto(const struct mnl_socket *nl, const void *buf,
+				 size_t len)
+{
+	static const struct sockaddr_nl snl = {
+		.nl_family = AF_NETLINK
+	};
+	return sendto(nl->fd, buf, len, 0,
+		      (struct sockaddr *) &snl, sizeof(snl));
+}
+
+static ssize_t mnl_socket_recvfrom(const struct mnl_socket *nl, void *buf,
+				   size_t bufsiz)
+{
+	ssize_t ret;
+	struct sockaddr_nl addr;
+	struct iovec iov = {
+		.iov_base	= buf,
+		.iov_len	= bufsiz,
+	};
+	struct msghdr msg = {
+		.msg_name	= &addr,
+		.msg_namelen	= sizeof(struct sockaddr_nl),
+		.msg_iov	= &iov,
+		.msg_iovlen	= 1,
+		.msg_control	= NULL,
+		.msg_controllen	= 0,
+		.msg_flags	= 0,
+	};
+	ret = recvmsg(nl->fd, &msg, 0);
+	if (ret == -1)
+		return ret;
+
+	if (msg.msg_flags & MSG_TRUNC) {
+		errno = ENOSPC;
+		return -1;
+	}
+	if (msg.msg_namelen != sizeof(struct sockaddr_nl)) {
+		errno = EINVAL;
+		return -1;
+	}
+	return ret;
+}
+
+static int mnl_socket_close(struct mnl_socket *nl)
+{
+	int ret = close(nl->fd);
+	free(nl);
+	return ret;
+}
+
+/* This is a wrapper for generic netlink, originally from Jiri Pirko <jiri@mellanox.com>: */
+
+struct mnlg_socket {
+	struct mnl_socket *nl;
+	char *buf;
+	uint16_t id;
+	uint8_t version;
+	unsigned int seq;
+	unsigned int portid;
+};
+
+static struct nlmsghdr *__mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					   uint16_t flags, uint16_t id,
+					   uint8_t version)
+{
+	struct nlmsghdr *nlh;
+	struct genlmsghdr *genl;
+
+	nlh = mnl_nlmsg_put_header(nlg->buf);
+	nlh->nlmsg_type	= id;
+	nlh->nlmsg_flags = flags;
+	nlg->seq = time(NULL);
+	nlh->nlmsg_seq = nlg->seq;
+
+	genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
+	genl->cmd = cmd;
+	genl->version = version;
+
+	return nlh;
+}
+
+static struct nlmsghdr *mnlg_msg_prepare(struct mnlg_socket *nlg, uint8_t cmd,
+					 uint16_t flags)
+{
+	return __mnlg_msg_prepare(nlg, cmd, flags, nlg->id, nlg->version);
+}
+
+static int mnlg_socket_send(struct mnlg_socket *nlg, const struct nlmsghdr *nlh)
+{
+	return mnl_socket_sendto(nlg->nl, nlh, nlh->nlmsg_len);
+}
+
+static int mnlg_cb_noop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)nlh;
+	(void)data;
+	return MNL_CB_OK;
+}
+
+static int mnlg_cb_error(const struct nlmsghdr *nlh, void *data)
+{
+	const struct nlmsgerr *err = mnl_nlmsg_get_payload(nlh);
+	(void)data;
+
+	if (nlh->nlmsg_len < mnl_nlmsg_size(sizeof(struct nlmsgerr))) {
+		errno = EBADMSG;
+		return MNL_CB_ERROR;
+	}
+	/* Netlink subsystems returns the errno value with different signess */
+	if (err->error < 0)
+		errno = -err->error;
+	else
+		errno = err->error;
+
+	return err->error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+}
+
+static int mnlg_cb_stop(const struct nlmsghdr *nlh, void *data)
+{
+	(void)data;
+	if (nlh->nlmsg_flags & NLM_F_MULTI && nlh->nlmsg_len == mnl_nlmsg_size(sizeof(int))) {
+		int error = *(int *)mnl_nlmsg_get_payload(nlh);
+		/* Netlink subsystems returns the errno value with different signess */
+		if (error < 0)
+			errno = -error;
+		else
+			errno = error;
+
+		return error == 0 ? MNL_CB_STOP : MNL_CB_ERROR;
+	}
+	return MNL_CB_STOP;
+}
+
+static const mnl_cb_t mnlg_cb_array[] = {
+	[NLMSG_NOOP]	= mnlg_cb_noop,
+	[NLMSG_ERROR]	= mnlg_cb_error,
+	[NLMSG_DONE]	= mnlg_cb_stop,
+	[NLMSG_OVERRUN]	= mnlg_cb_noop,
+};
+
+static int mnlg_socket_recv_run(struct mnlg_socket *nlg, mnl_cb_t data_cb, void *data)
+{
+	int err;
+
+	do {
+		err = mnl_socket_recvfrom(nlg->nl, nlg->buf,
+					  mnl_ideal_socket_buffer_size());
+		if (err <= 0)
+			break;
+		err = mnl_cb_run2(nlg->buf, err, nlg->seq, nlg->portid,
+				  data_cb, data, mnlg_cb_array, MNL_ARRAY_SIZE(mnlg_cb_array));
+	} while (err > 0);
+
+	return err;
+}
+
+static int get_family_id_attr_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
+		return MNL_CB_ERROR;
+
+	if (type == CTRL_ATTR_FAMILY_ID &&
+	    mnl_attr_validate(attr, MNL_TYPE_U16) < 0)
+		return MNL_CB_ERROR;
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static int get_family_id_cb(const struct nlmsghdr *nlh, void *data)
+{
+	uint16_t *p_id = data;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1] = { 0 };
+
+	mnl_attr_parse(nlh, sizeof(struct genlmsghdr), get_family_id_attr_cb, tb);
+	if (!tb[CTRL_ATTR_FAMILY_ID])
+		return MNL_CB_ERROR;
+	*p_id = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
+	return MNL_CB_OK;
+}
+
+static struct mnlg_socket *mnlg_socket_open(const char *family_name, uint8_t version)
+{
+	struct mnlg_socket *nlg;
+	struct nlmsghdr *nlh;
+	int err;
+
+	nlg = malloc(sizeof(*nlg));
+	if (!nlg)
+		return NULL;
+	nlg->id = 0;
+
+	err = -ENOMEM;
+	nlg->buf = malloc(mnl_ideal_socket_buffer_size());
+	if (!nlg->buf)
+		goto err_buf_alloc;
+
+	nlg->nl = mnl_socket_open(NETLINK_GENERIC);
+	if (!nlg->nl) {
+		err = -errno;
+		goto err_mnl_socket_open;
+	}
+
+	if (mnl_socket_bind(nlg->nl, 0, MNL_SOCKET_AUTOPID) < 0) {
+		err = -errno;
+		goto err_mnl_socket_bind;
+	}
+
+	nlg->portid = mnl_socket_get_portid(nlg->nl);
+
+	nlh = __mnlg_msg_prepare(nlg, CTRL_CMD_GETFAMILY,
+				 NLM_F_REQUEST | NLM_F_ACK, GENL_ID_CTRL, 1);
+	mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, family_name);
+
+	if (mnlg_socket_send(nlg, nlh) < 0) {
+		err = -errno;
+		goto err_mnlg_socket_send;
+	}
+
+	errno = 0;
+	if (mnlg_socket_recv_run(nlg, get_family_id_cb, &nlg->id) < 0) {
+		errno = errno == ENOENT ? EPROTONOSUPPORT : errno;
+		err = errno ? -errno : -ENOSYS;
+		goto err_mnlg_socket_recv_run;
+	}
+
+	nlg->version = version;
+	errno = 0;
+	return nlg;
+
+err_mnlg_socket_recv_run:
+err_mnlg_socket_send:
+err_mnl_socket_bind:
+	mnl_socket_close(nlg->nl);
+err_mnl_socket_open:
+	free(nlg->buf);
+err_buf_alloc:
+	free(nlg);
+	errno = -err;
+	return NULL;
+}
+
+static void mnlg_socket_close(struct mnlg_socket *nlg)
+{
+	mnl_socket_close(nlg->nl);
+	free(nlg->buf);
+	free(nlg);
+}
diff -urpN wireguard-tools.old/src/version.h wireguard-tools/src/version.h
--- wireguard-tools.old/src/version.h	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/version.h	2020-02-09 23:07:59.749543990 +0300
@@ -1,3 +1,3 @@
 #ifndef WIREGUARD_TOOLS_VERSION
-#define WIREGUARD_TOOLS_VERSION "1.0.20200121"
+#define WIREGUARD_TOOLS_VERSION "1.0.20200206"
 #endif
diff -urpN wireguard-tools.old/src/wg-quick/android.c wireguard-tools/src/wg-quick/android.c
--- wireguard-tools.old/src/wg-quick/android.c	2020-01-22 00:02:18.371740404 +0300
+++ wireguard-tools/src/wg-quick/android.c	2020-02-09 23:07:59.749543990 +0300
@@ -785,6 +785,7 @@ static uid_t *get_uid_list(const char *s
 static void set_users(unsigned int netid, const char *excluded_applications)
 {
 	_cleanup_free_ uid_t *excluded_uids = get_uid_list(excluded_applications);
+	unsigned int args_per_command = 0;
 	_cleanup_free_ char *ranges = NULL;
 	char range[22];
 	uid_t start;
@@ -797,13 +798,19 @@ static void set_users(unsigned int netid
 		else
 			snprintf(range, sizeof(range), "%u-%u", start, *excluded_uids - 1);
 		ranges = concat_and_free(ranges, " ", range);
+		if (++args_per_command % 18 == 0) {
+			cndc("network users add %u %s", netid, ranges);
+			free(ranges);
+			ranges = NULL;
+		}
 	}
 	if (start < 99999) {
 		snprintf(range, sizeof(range), "%u-99999", start);
 		ranges = concat_and_free(ranges, " ", range);
 	}
 
-	cndc("network users add %u %s", netid, ranges);
+	if (ranges)
+		cndc("network users add %u %s", netid, ranges);
 }
 
 static void set_dnses(unsigned int netid, const char *dnses)
