diff -urpN freeradius-server-3.2.6/.github/workflows/ci-rpm.yml freeradius-server-3.2.7/.github/workflows/ci-rpm.yml
--- freeradius-server-3.2.6/.github/workflows/ci-rpm.yml	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/.github/workflows/ci-rpm.yml	2025-01-31 18:42:21.000000000 +0700
@@ -15,9 +15,8 @@ jobs:
     strategy:
       matrix:
         env:
-          - { NAME: "centos-7",  OS: "centos:7",                BADNODE: true  }
-          - { NAME: "rocky-8",   OS: "rockylinux/rockylinux:8", BADNODE: false }
-          - { NAME: "rocky-9",   OS: "rockylinux/rockylinux:9", BADNODE: false }
+          - { NAME: "rocky-8",   OS: "rockylinux/rockylinux:8" }
+          - { NAME: "rocky-9",   OS: "rockylinux/rockylinux:9" }
       fail-fast: false
 
     runs-on: ubuntu-latest
@@ -28,37 +27,17 @@ jobs:
     env:
       HOSTAPD_BUILD_DIR: /tmp/eapol_test.ci
       HOSTAPD_GIT_TAG: hostapd_2_8
-      ACTIONS_ALLOW_USE_UNSECURE_NODE_VERSION: ${{ matrix.env.BADNODE }}
 
     name: "RPM build"
 
     steps:
 
-    - name: Fix up CentOS 7 repositories
-      if: ${{ matrix.env.NAME == 'centos-7' }}
-      run: |
-        sed -i "s/^mirrorlist/#mirrorlist/g" /etc/yum.repos.d/CentOS-*
-        sed -i "s|#\s*baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g" /etc/yum.repos.d/CentOS-*
-
-    # Required so that the checkout action uses git protocol rather than the GitHub REST API.
-    # make rpm requires the FR directory to be a git repository.
-    - name: Install recent git for CentOS 7
-      if: ${{ matrix.env.NAME == 'centos-7' }}
-      run: |
-        yum install -y https://packages.endpointdev.com/rhel/7/os/x86_64/git-core-2.30.1-1.ep7.x86_64.rpm
-
-    # Rocky 9 uses dnf by default.  CentOS 7 doesn't have dnf.  Install yum on Rocky 9 so all distros work
-    - name: Install yum
-      if: ${{ matrix.env.NAME == 'rocky-9'}}
-      run: |
-        dnf install -y yum
-
     - name: Install distro git for Rocky.
       if: ${{ startsWith(matrix.env.NAME, 'rocky-') }}
       run: |
-        yum install -y git-core
+        dnf install -y git-core
 
-    - uses: actions/checkout@v3
+    - uses: actions/checkout@v4
       with:
         path: freeradius
 
@@ -69,8 +48,8 @@ jobs:
         mkdir rpms
         ls -la
 
-    - name: LTB repo for CentOS and Rocky Linux 8
-      if: ${{ startsWith(matrix.env.NAME, 'centos-') || matrix.env.NAME == 'rocky-8' }}
+    - name: LTB repo for Rocky Linux 8
+      if: ${{ matrix.env.NAME == 'rocky-8' }}
       run: |
         echo '[ltb-project]'                                              >  /etc/yum.repos.d/ltb-project.repo
         echo 'name=LTB project packages'                                  >> /etc/yum.repos.d/ltb-project.repo
@@ -80,27 +59,27 @@ jobs:
         echo 'gpgkey=https://www.ltb-project.org/documentation/_static/RPM-GPG-KEY-LTB-project' >> /etc/yum.repos.d/ltb-project.repo
         rpm --import https://www.ltb-project.org/documentation/_static/RPM-GPG-KEY-LTB-project
 
-    - name: Enable EPEL for CentOS and Rocky Linux
-      if: ${{ startsWith(matrix.env.NAME, 'centos-') || startsWith(matrix.env.NAME, 'rocky-') }}
+    - name: Enable EPEL for Rocky Linux
+      if: ${{ startsWith(matrix.env.NAME, 'rocky-') }}
       run: |
-        yum install -y epel-release
+        dnf install -y epel-release
 
     - name: Enable PowerTools on Rocky 8.
       if: ${{ matrix.env.NAME == 'rocky-8' }}
       run: |
-        yum install -y yum-utils
-        yum config-manager --enable PowerTools || :
-        yum config-manager --enable powertools || :
+        dnf install -y yum-utils
+        dnf config-manager --enable PowerTools || :
+        dnf config-manager --enable powertools || :
 
     - name: Enable Code Ready Builer on Rocky 9.
       if: ${{ matrix.env.NAME == 'rocky-9' }}
       run: |
-        yum install -y yum-utils
-        yum config-manager --enable crb
+        dnf install -y yum-utils
+        dnf config-manager --enable crb
 
     - name: Install common tools
       run: |
-        yum install -y \
+        dnf install -y \
           bzip2 \
           gcc \
           make \
@@ -119,7 +98,7 @@ jobs:
 
     - name: Install build dependencies
       run: |
-        yum-builddep -y freeradius/redhat/freeradius.spec
+        dnf builddep -y freeradius/redhat/freeradius.spec
 
     #
     #  It has been observed that sometimes not all the dependencies are
@@ -127,7 +106,7 @@ jobs:
     #
     - name: Second run of install build dependencies
       run: |
-        yum-builddep -y redhat/freeradius.spec
+        dnf builddep -y redhat/freeradius.spec
       working-directory: freeradius
 
     - name: Show versions
@@ -141,7 +120,7 @@ jobs:
     - name: Enable procps-ng on Rocky
       if: ${{ startsWith(matrix.env.NAME, 'rocky-') }}
       run: |
-        yum install -y procps-ng
+        dnf install -y procps-ng
 
     - name: Build RPMs
       run: |
@@ -155,7 +134,7 @@ jobs:
         mv freeradius/rpmbuild/RPMS/x86_64/*.rpm rpms/
 
     - name: Restore eapol_test build directory from cache
-      uses: actions/cache@v3
+      uses: actions/cache@v4
       id: hostapd-cache
       with:
         path: ${{ env.HOSTAPD_BUILD_DIR }}
@@ -163,14 +142,14 @@ jobs:
 
     - name: Build eapol_test
       run: |
-        yum install -y libnl3-devel which
+        dnf install -y libnl3-devel which
         [ -r /opt/rh/devtoolset-8/enable ] && source /opt/rh/devtoolset-8/enable || :
         scripts/ci/eapol_test-build.sh
         mv scripts/ci/eapol_test/eapol_test ../rpms/
       working-directory: freeradius
 
     - name: Store RPMs
-      uses: actions/upload-artifact@v3
+      uses: actions/upload-artifact@v4
       with:
         name: rpms-${{ matrix.env.NAME }}
         path: rpms
@@ -181,7 +160,7 @@ jobs:
     #
     - name: "Debug: Package dependancies for tmate"
       run: |
-        yum install -y xz
+        dnf install -y xz
         ln -s /bin/true /bin/apt-get
       if: ${{ github.ref == 'refs/heads/ci-debug' && failure() }}
 
@@ -201,9 +180,8 @@ jobs:
     strategy:
       matrix:
         env:
-          - { NAME: "centos-7",  OS: "centos:7",                BADNODE: true  }
-          - { NAME: "rocky-8",   OS: "rockylinux/rockylinux:8", BADNODE: false }
-          - { NAME: "rocky-9",   OS: "rockylinux/rockylinux:9", BADNODE: false }
+          - { NAME: "rocky-8",   OS: "rockylinux/rockylinux:8" }
+          - { NAME: "rocky-9",   OS: "rockylinux/rockylinux:9" }
       fail-fast: false
 
     runs-on: ubuntu-latest
@@ -211,26 +189,12 @@ jobs:
     container:
       image: ${{ matrix.env.OS }}
 
-    env:
-      ACTIONS_ALLOW_USE_UNSECURE_NODE_VERSION: ${{ matrix.env.BADNODE }}
-
     name: "RPM install test"
 
     steps:
 
-    - name: Fix up CentOS 7 repositories
-      if: ${{ matrix.env.NAME == 'centos-7' }}
-      run: |
-        sed -i "s/^mirrorlist/#mirrorlist/g" /etc/yum.repos.d/CentOS-*
-        sed -i "s|#\s*baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g" /etc/yum.repos.d/CentOS-*
-
-    - name: Install yum
-      if: ${{ matrix.env.NAME == 'rocky-9'}}
-      run: |
-        dnf install -y yum
-
-    - name: LTB repo for CentOS and Rocky 8
-      if: ${{ startsWith(matrix.env.NAME, 'centos-') || matrix.env.NAME == 'rocky-8' }}
+    - name: LTB repo for Rocky 8
+      if: ${{ matrix.env.NAME == 'rocky-8' }}
       run: |
         echo '[ltb-project]'                                              >  /etc/yum.repos.d/ltb-project.repo
         echo 'name=LTB project packages'                                  >> /etc/yum.repos.d/ltb-project.repo
@@ -240,45 +204,38 @@ jobs:
         echo 'gpgkey=https://www.ltb-project.org/documentation/_static/RPM-GPG-KEY-LTB-project' >> /etc/yum.repos.d/ltb-project.repo
         rpm --import https://www.ltb-project.org/documentation/_static/RPM-GPG-KEY-LTB-project
 
-    - name: Enable EPEL for CentOS and Rocky Linux
-      if: ${{ startsWith(matrix.env.NAME, 'centos-') || startsWith(matrix.env.NAME, 'rocky-') }}
+    - name: Enable EPEL for Rocky Linux
+      if: ${{ startsWith(matrix.env.NAME, 'rocky-') }}
       run: |
-        yum install -y epel-release
+        dnf install -y epel-release
 
     - name: Enable PowerTools on Rocky 8
       if: ${{ matrix.env.NAME == 'rocky-8' }}
       run: |
-        yum install -y yum-utils
-        yum config-manager --enable PowerTools || :
-        yum config-manager --enable powertools || :
+        dnf install -y yum-utils
+        dnf config-manager --enable PowerTools || :
+        dnf config-manager --enable powertools || :
 
     - name: Enable Code Ready Builer on Rocky 9.
       if: ${{ matrix.env.NAME == 'rocky-9' }}
       run: |
-        yum install -y yum-utils
-        yum config-manager --enable crb
+        dnf install -y yum-utils
+        dnf config-manager --enable crb
 
     # For pkill
-    - name: Enable procps-ng on Centos and Rocky
-      if: ${{ startsWith(matrix.env.NAME, 'centos-') || startsWith(matrix.env.NAME, 'rocky-') }}
+    - name: Enable procps-ng on Rocky
+      if: ${{ startsWith(matrix.env.NAME, 'rocky-') }}
       run: |
-        yum install -y procps-ng
+        dnf install -y procps-ng
 
     - name: Load RPMs
-      uses: actions/download-artifact@v3
+      uses: actions/download-artifact@v4
       with:
         name: rpms-${{ matrix.env.NAME }}
 
     - name: Install RPMs
       run: |
-        yum install -y *.rpm
-
-    - name: Ensure certificates are created
-      if: ${{ matrix.env.NAME == 'centos-7' }}
-      run: |
-        if [ ! -e /etc/raddb/certs/server.pem ]; then
-          /sbin/runuser -g radiusd -c 'umask 007; /etc/raddb/certs/bootstrap'
-        fi
+        dnf install -y *.rpm
 
     - name: Config check
       run: |
@@ -290,11 +247,11 @@ jobs:
     #
     - name: Install pre-built eapol_test
       run: |
-        yum install -y libnl3 make gdb which
+        dnf install -y libnl3 make gdb which
         mv eapol_test /usr/local/bin
         chmod +x /usr/local/bin/eapol_test
 
-    - uses: actions/checkout@v3
+    - uses: actions/checkout@v4
       with:
         path: freeradius
 
@@ -307,7 +264,7 @@ jobs:
 
     - name: Upload radius logs on failure
       if: ${{ failure() }}
-      uses: actions/upload-artifact@v3
+      uses: actions/upload-artifact@v4
       with:
         name: radius-logs-${{ matrix.env.NAME }}.tgz
         path: |
@@ -319,7 +276,7 @@ jobs:
     #
     - name: "Debug: Package dependancies for tmate"
       run: |
-        yum install -y xz
+        dnf install -y xz
         ln -s /bin/true /bin/apt-get
       if: ${{ github.ref == 'refs/heads/ci-debug' && failure() }}
 
diff -urpN freeradius-server-3.2.6/.github/workflows/ci.yml freeradius-server-3.2.7/.github/workflows/ci.yml
--- freeradius-server-3.2.6/.github/workflows/ci.yml	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/.github/workflows/ci.yml	2025-01-31 18:42:21.000000000 +0700
@@ -56,10 +56,10 @@ jobs:
 # docker  - the docker image name, if containers are being used
 # name    - used in the job name only
 #
-          - runs_on: "${{ needs.pre-ci.outputs.selfhosted == '1' && 'self-hosted' || 'ubuntu-20.04' }}"
-            docker: "${{ needs.pre-ci.outputs.selfhosted == '1' && 'docker.internal.networkradius.com/self-hosted' || 'ubuntu:20.04' }}"
-            name: "${{ needs.pre-ci.outputs.selfhosted == '1' && 'self' || 'gh' }}-ubuntu20"
-            code: "ubuntu2004"
+          - runs_on: "${{ needs.pre-ci.outputs.selfhosted == '1' && 'self-hosted' || 'ubuntu-24.04' }}"
+            docker: "${{ needs.pre-ci.outputs.selfhosted == '1' && 'docker.internal.networkradius.com/self-hosted' || 'ubuntu:24.04' }}"
+            name: "${{ needs.pre-ci.outputs.selfhosted == '1' && 'self' || 'gh' }}-ubuntu24"
+            code: "ubuntu2404"
 
         env:
           - { CC: gcc,   DO_BUILD: yes, LIBS_OPTIONAL: no,  LIBS_ALT: no,  REPRODUCIBLE: no,  SANITIZER: no,  BUILD_CFLAGS: "-DWITH_EVAL_DEBUG",         NAME: linux-gcc-lean           }
@@ -167,7 +167,6 @@ jobs:
         libyubikey-dev \
         lintian \
         pbuilder \
-        python-dev \
         python3-dev \
         ruby-dev \
         snmp \
@@ -175,10 +174,12 @@ jobs:
         quilt
 
     - name: Install LLVM 15 for 20.04
-      if: ${{ matrix.os.code == 'ubuntu2004' && matrix.env.CC == 'clang' }}
+      if: ${{ matrix.os.code == 'ubuntu2404' && matrix.env.CC == 'clang' }}
       run: |
-        wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add
-        sudo apt-add-repository "deb http://apt.llvm.org/focal/ llvm-toolchain-focal-15 main"
+        install -d -m 0755 -o root -g root /etc/apt/keyrings
+        wget -O /etc/apt/keyrings/llvm-snapshot.asc https://apt.llvm.org/llvm-snapshot.gpg.key
+        echo "deb [signed-by=/etc/apt/keyrings/llvm-snapshot.asc] http://apt.llvm.org/focal/ llvm-toolchain-focal-15 main" | sudo tee /etc/apt/sources.list.d/llvm-toolchain.list
+        sudo apt-get update
         sudo apt-get install ${APT_OPTS} clang-15 llvm-15 gdb libclang-rt-15-dev
         sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-15 60 && sudo update-alternatives --set clang /usr/bin/clang-15
         sudo update-alternatives --install /usr/bin/llvm-symbolizer llvm-symbolizer /usr/bin/llvm-symbolizer-15 60 && sudo update-alternatives --set llvm-symbolizer /usr/bin/llvm-symbolizer-15
@@ -192,39 +193,41 @@ jobs:
     #  Build using some alternative libraries
     #
     #    MIT Kerberos -> HEIMDAL Kerberos
-    #    OpenSSL 1.0  -> OpenSSL 3.0
     #
-    - name: 'Fetch OpenSSL 3.0 SHA'
-      id: opensslshasum
-      if: ${{ matrix.env.LIBS_ALT == 'yes' }}
-      run: |
-        wget -qO- http://www.openssl.org/source/$ALT_OPENSSL_PATH/openssl-$ALT_OPENSSL.tar.gz.sha256 | sed -ne 's/^\s\+/shasum=/p' >> $GITHUB_OUTPUT
-
-    - name: 'Restore OpenSSL 3.0 from the cache'
-      if: ${{ matrix.env.LIBS_ALT == 'yes' }}
-      uses: actions/cache@v4
-      id: openssl-cache
-      with:
-        path: /opt/openssl/
-        key: openssl3-${{ steps.opensslshasum.outputs.shasum }}
-
-    - name: 'Build OpenSSL 3.0 (if cache stale)'
-      if: ${{ matrix.env.LIBS_ALT == 'yes' && steps.openssl-cache.outputs.cache-hit != 'true' }}
-      run: |
-        cd ~
-        wget https://www.openssl.org/source/$ALT_OPENSSL_PATH/openssl-$ALT_OPENSSL.tar.gz
-        tar xzf openssl-$ALT_OPENSSL.tar.gz
-        cd openssl-$ALT_OPENSSL
-        ./Configure --prefix=/opt/openssl --openssldir=.
-        make -j `nproc`
-        make install
+    #  Now runners are Ubuntu 24, OpenSSL 3.0 is default
+    #  The sections below are left for future testing with other versions.
+    #
+#    - name: 'Fetch OpenSSL 3.0 SHA'
+#      id: opensslshasum
+#      if: ${{ matrix.env.LIBS_ALT == 'yes' }}
+#      run: |
+#        wget -qO- http://www.openssl.org/source/$ALT_OPENSSL_PATH/openssl-$ALT_OPENSSL.tar.gz.sha256 | sed -ne 's/^\s\+/shasum=/p' >> $GITHUB_OUTPUT
+
+#    - name: 'Restore OpenSSL 3.0 from the cache'
+#      if: ${{ matrix.env.LIBS_ALT == 'yes' }}
+#      uses: actions/cache@v4
+#      id: openssl-cache
+#      with:
+#        path: /opt/openssl/
+#        key: openssl3-${{ steps.opensslshasum.outputs.shasum }}
+
+#    - name: 'Build OpenSSL 3.0 (if cache stale)'
+#      if: ${{ matrix.env.LIBS_ALT == 'yes' && steps.openssl-cache.outputs.cache-hit != 'true' }}
+#      run: |
+#        cd ~
+#        wget https://www.openssl.org/source/$ALT_OPENSSL_PATH/openssl-$ALT_OPENSSL.tar.gz
+#        tar xzf openssl-$ALT_OPENSSL.tar.gz
+#        cd openssl-$ALT_OPENSSL
+#        ./Configure --prefix=/opt/openssl --openssldir=.
+#        make -j `nproc`
+#        make install
 
     - name: Use alternative libraries
       if: ${{ matrix.env.LIBS_ALT == 'yes' }}
       run: |
-        echo /opt/openssl/lib64 | sudo tee /etc/ld.so.conf.d/openssl3.conf >/dev/null
-        sudo ldconfig
         sudo apt-get install ${APT_OPTS} heimdal-dev
+#        echo /opt/openssl/lib64 | sudo tee /etc/ld.so.conf.d/openssl3.conf >/dev/null
+#        sudo ldconfig
 
     - name: Show versions
       run: |
@@ -300,9 +303,9 @@ jobs:
     - name: Add OpenResty repository
       shell: bash
       run: |
-        wget -O - https://openresty.org/package/pubkey.gpg | sudo apt-key add -
-        echo "deb http://openresty.org/package/ubuntu $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/openresty.list
-
+        install -d -m 0755 -o root -g root /etc/apt/keyrings
+        wget -O /etc/apt/keyrings/openresty.asc https://openresty.org/package/pubkey.gpg
+        echo "deb [signed-by=/etc/apt/keyrings/openresty.asc] http://openresty.org/package/ubuntu $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/openresty.list
         sudo apt-get update
 
     - name: Setup git
diff -urpN freeradius-server-3.2.6/Make.inc.in freeradius-server-3.2.7/Make.inc.in
--- freeradius-server-3.2.6/Make.inc.in	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/Make.inc.in	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 # -*- makefile -*-
 # Make.inc.in
 #
-# Version:	$Id: fefb022a268626190ccc781068efaa16f7072131 $
+# Version:	$Id: 6d5cc1c343ce49e3bd2694a889ca238c0fdad1b7 $
 #
 
 # Location of files.
@@ -65,6 +65,7 @@ INSTALL_PROGRAM	= ${INSTALL}
 INSTALL_DATA	= ${INSTALL} -m 644
 INSTALL_SCRIPT	= ${INSTALL_PROGRAM}
 INSTALLSTRIP	= @INSTALLSTRIP@
+MANSKIP         = @MANSKIP@
 
 #
 #  Linker arguments for libraries searched for by the main
diff -urpN freeradius-server-3.2.6/Makefile freeradius-server-3.2.7/Makefile
--- freeradius-server-3.2.6/Makefile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/Makefile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 #		NOTE: This top-level Makefile must not
 #		use GNU-make extensions. The lower ones can.
 #
-#  Version:	$Id: b7777ed987540591cf9b183bb5b63a52b2fa036d $
+#  Version:	$Id: 888e74e14f0c371788f74309093b0c2d9e12bf34 $
 #
 
 #
@@ -142,7 +142,7 @@ $(R)$(dictdir)/%: share/%
 	@echo INSTALL $(notdir $<)
 	${Q}$(INSTALL) -m 644 $< $@
 
-MANFILES := $(wildcard man/man*/*.?)
+MANFILES := $(filter-out $(MANSKIP),$(wildcard man/man*/*.?))
 MANDIR   := $(wildcard man/man*)
 install.man: $(subst man/,$(R)$(mandir)/,$(MANFILES))
 
@@ -301,7 +301,7 @@ freeradius-server-$(RADIUSD_VERSION_STRI
 	git archive --format=tar --prefix=freeradius-server-$(RADIUSD_VERSION_STRING)/ $(BRANCH) | bzip2 > $@
 
 %.sig: %
-	gpg --default-key packages@freeradius.org -b $<
+	gpg --local-user packages@freeradius.org -b $<
 
 #
 #  High-level targets
diff -urpN freeradius-server-3.2.6/VERSION freeradius-server-3.2.7/VERSION
--- freeradius-server-3.2.6/VERSION	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/VERSION	2025-01-31 18:42:21.000000000 +0700
@@ -1 +1 @@
-3.2.6
+3.2.7
diff -urpN freeradius-server-3.2.6/configure freeradius-server-3.2.7/configure
--- freeradius-server-3.2.6/configure	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/configure	2025-01-31 18:42:21.000000000 +0700
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.71 for freeradius $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $.
+# Generated by GNU Autoconf 2.71 for freeradius $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $.
 #
 # Report bugs to <http://bugs.freeradius.org>.
 #
@@ -611,8 +611,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='freeradius'
 PACKAGE_TARNAME='freeradius'
-PACKAGE_VERSION='$Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $'
-PACKAGE_STRING='freeradius $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $'
+PACKAGE_VERSION='$Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $'
+PACKAGE_STRING='freeradius $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $'
 PACKAGE_BUGREPORT='http://bugs.freeradius.org'
 PACKAGE_URL='http://www.freeradius.org'
 
@@ -652,6 +652,7 @@ ac_header_c_list=
 enable_option_checking=no
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+MANSKIP
 STATIC_MODULES
 USE_STATIC_LIBS
 USE_SHARED_LIBS
@@ -677,10 +678,12 @@ DIRNAME
 AUTOHEADER
 AUTOCONF
 ACLOCAL
+LAST
 RUSERS
 SNMPWALK
 SNMPGET
 openssl_version_check_config
+WITH_RADLAST
 WITH_DHCP
 modconfdir
 dictdir
@@ -785,6 +788,7 @@ with_threads
 with_tcp
 with_vmps
 with_dhcp
+with_radlast
 with_static_modules
 with_shared_libs
 with_modules
@@ -1380,7 +1384,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures freeradius $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $ to adapt to many kinds of systems.
+\`configure' configures freeradius $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $ to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1447,7 +1451,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of freeradius $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $:";;
+     short | recursive ) echo "Configuration of freeradius $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $:";;
    esac
   cat <<\_ACEOF
 
@@ -1490,6 +1494,7 @@ Optional Packages:
   --with-tcp              compile in TCP support. (default=yes)
   --with-vmps             compile in VMPS support. (default=yes)
   --with-dhcp             compile in DHCP support. (default=yes)
+  --with-radlast          install radlast
   --with-static-modules=QUOTED-MODULE-LIST
   --with-shared-libs      build dynamic libraries and link against them.
                           (default=yes)
@@ -1623,7 +1628,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-freeradius configure $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $
+freeradius configure $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $
 generated by GNU Autoconf 2.71
 
 Copyright (C) 2021 Free Software Foundation, Inc.
@@ -2070,7 +2075,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by freeradius $as_me $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $, which was
+It was created by freeradius $as_me $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $, which was
 generated by GNU Autoconf 2.71.  Invocation command line was
 
   $ $0$ac_configure_args_raw
@@ -6796,6 +6801,26 @@ printf "%s\n" "#define WITH_DHCP 1" >>co
 fi
 
 
+
+MANSKIP=
+WITH_RADLAST=
+
+# Check whether --with-radlast was given.
+if test ${with_radlast+y}
+then :
+  withval=$with_radlast;  case "$withval" in
+  yes)
+    WITH_RADLAST=yes
+    ;;
+  *)
+    WITH_RADLAST=no
+  esac
+
+fi
+
+
+
+
 STATIC_MODULES=
 
 # Check whether --with-static_modules was given.
@@ -7261,6 +7286,58 @@ fi
 
 
 
+
+if test "x$WITH_RADLAST" = "x"; then
+  # Extract the first word of "last", so it can be a program name with args.
+set dummy last; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_LAST+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$LAST"; then
+  ac_cv_prog_LAST="$LAST" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_LAST="yes"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_LAST" && ac_cv_prog_LAST="no"
+fi
+fi
+LAST=$ac_cv_prog_LAST
+if test -n "$LAST"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $LAST" >&5
+printf "%s\n" "$LAST" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  WITH_RADLAST="$LAST"
+fi
+if test "x$WITH_RADLAST" != "xyes"; then
+  MANSKIP="$MANSKIP man/man1/radlast.1"
+fi
+
+
 missing_dir=`cd $ac_aux_dir && pwd`
 
 # Expand $ac_aux_dir to an absolute path.
@@ -14670,7 +14747,8 @@ USE_STATIC_LIBS="yes"
 
 
 
-ac_config_files="$ac_config_files ./Make.inc ./src/include/build-radpaths-h ./src/main/radsniff.mk ./src/main/checkrad ./src/main/radlast ./src/main/radtest ./scripts/rc.radiusd ./scripts/cron/radiusd.cron.daily ./scripts/cron/radiusd.cron.monthly ./scripts/cryptpasswd ./raddb/radrelay.conf ./raddb/radiusd.conf"
+
+ac_config_files="$ac_config_files ./Make.inc ./src/include/build-radpaths-h ./src/main/radsniff.mk ./src/main/radlast.mk ./src/main/checkrad ./src/main/radlast ./src/main/radtest ./scripts/rc.radiusd ./scripts/cron/radiusd.cron.daily ./scripts/cron/radiusd.cron.monthly ./scripts/cryptpasswd ./raddb/radrelay.conf ./raddb/radiusd.conf"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -15172,7 +15250,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by freeradius $as_me $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $, which was
+This file was extended by freeradius $as_me $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $, which was
 generated by GNU Autoconf 2.71.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -15241,7 +15319,7 @@ ac_cs_config_escaped=`printf "%s\n" "$ac
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config='$ac_cs_config_escaped'
 ac_cs_version="\\
-freeradius config.status $Id: 5041ca264f4d3ef91410bc78e5516857f1332826 $
+freeradius config.status $Id: f1dfa97c44f600ef564fedd2cac9697c639d1ae6 $
 configured by $0, generated by GNU Autoconf 2.71,
   with options \\"\$ac_cs_config\\"
 
@@ -15370,6 +15448,7 @@ do
     "./Make.inc") CONFIG_FILES="$CONFIG_FILES ./Make.inc" ;;
     "./src/include/build-radpaths-h") CONFIG_FILES="$CONFIG_FILES ./src/include/build-radpaths-h" ;;
     "./src/main/radsniff.mk") CONFIG_FILES="$CONFIG_FILES ./src/main/radsniff.mk" ;;
+    "./src/main/radlast.mk") CONFIG_FILES="$CONFIG_FILES ./src/main/radlast.mk" ;;
     "./src/main/checkrad") CONFIG_FILES="$CONFIG_FILES ./src/main/checkrad" ;;
     "./src/main/radlast") CONFIG_FILES="$CONFIG_FILES ./src/main/radlast" ;;
     "./src/main/radtest") CONFIG_FILES="$CONFIG_FILES ./src/main/radtest" ;;
diff -urpN freeradius-server-3.2.6/configure.ac freeradius-server-3.2.7/configure.ac
--- freeradius-server-3.2.6/configure.ac	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/configure.ac	2025-01-31 18:42:21.000000000 +0700
@@ -23,7 +23,7 @@ dnl ####################################
 AC_PREREQ([2.69])
 export CFLAGS LIBS LDFLAGS CPPFLAGS
 
-AC_INIT([freeradius],[$Id: a24a8061f62ba434a92675ad55fb33af9b1dc5b9 $],[http://bugs.freeradius.org],[],[http://www.freeradius.org])
+AC_INIT([freeradius],[$Id: 6f292066466458fda3ec898b16d2d44e324741fb $],[http://bugs.freeradius.org],[],[http://www.freeradius.org])
 AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_SRCDIR([src/main/radiusd.c])
 AC_CONFIG_HEADER([src/include/autoconf.h])
@@ -567,6 +567,25 @@ if test "x$WITH_DHCP" = "xyes"; then
 fi
 AC_SUBST(WITH_DHCP)
 
+
+dnl #
+dnl #  extra argument: --with-radlast
+dnl #
+MANSKIP=
+WITH_RADLAST=
+AC_ARG_WITH(radlast,
+[  --with-radlast          install radlast],
+[ case "$withval" in
+  yes)
+    WITH_RADLAST=yes
+    ;;
+  *)
+    WITH_RADLAST=no
+  esac ]
+)
+AC_SUBST(WITH_RADLAST)
+
+
 dnl #
 dnl #  Allow the user to specify a list of modules to be linked
 dnl #  statically to the server.
@@ -858,6 +877,19 @@ fi
 
 AC_PATH_PROG(RUSERS, rusers, /usr/bin/rusers)
 
+
+dnl #
+dnl #  radlast depends on last
+dnl #
+if test "x$WITH_RADLAST" = "x"; then
+  AC_CHECK_PROG(LAST, last, yes, no)
+  WITH_RADLAST="$LAST"
+fi
+if test "x$WITH_RADLAST" != "xyes"; then
+  MANSKIP="$MANSKIP man/man1/radlast.1"
+fi
+
+
 dnl #
 dnl #  FIXME This is truly gross.
 dnl #
@@ -2625,11 +2657,13 @@ AC_SUBST(USE_SHARED_LIBS)
 USE_STATIC_LIBS="yes"
 AC_SUBST(USE_STATIC_LIBS)
 AC_SUBST(STATIC_MODULES)
+AC_SUBST(MANSKIP)
 
 AC_CONFIG_FILES([\
   ./Make.inc \
   ./src/include/build-radpaths-h \
   ./src/main/radsniff.mk \
+  ./src/main/radlast.mk \
   ./src/main/checkrad \
   ./src/main/radlast \
   ./src/main/radtest \
diff -urpN freeradius-server-3.2.6/debian/changelog freeradius-server-3.2.7/debian/changelog
--- freeradius-server-3.2.6/debian/changelog	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/debian/changelog	2025-01-31 18:42:21.000000000 +0700
@@ -1,3 +1,9 @@
+freeradius (3.2.7+git) unstable; urgency=medium
+
+  * New upstream version.
+
+ -- Alan DeKok <aland@freeradius.org>  Fri, 31 Jan 2025 12:00:00 +0000
+
 freeradius (3.2.6+git) unstable; urgency=medium
 
   * New upstream version.
diff -urpN freeradius-server-3.2.6/debian/freeradius-utils.install freeradius-server-3.2.7/debian/freeradius-utils.install
--- freeradius-server-3.2.6/debian/freeradius-utils.install	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/debian/freeradius-utils.install	2025-01-31 18:42:21.000000000 +0700
@@ -5,7 +5,6 @@ usr/bin/radeapclient
 usr/bin/radwho
 usr/bin/radsecret
 usr/bin/radsniff
-usr/bin/radlast
 usr/bin/radtest
 usr/bin/radzap
 usr/bin/radsqlrelay
diff -urpN freeradius-server-3.2.6/debian/freeradius.logrotate freeradius-server-3.2.7/debian/freeradius.logrotate
--- freeradius-server-3.2.6/debian/freeradius.logrotate	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/debian/freeradius.logrotate	2025-01-31 18:42:21.000000000 +0700
@@ -39,9 +39,9 @@
 #  to write to a single detail file per IP and use the rotate config
 #  below.  Another is to write to a daily detail file per IP with:
 #
-#     detailfile = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
+#     filename = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
 #
-#  (or similar) in radiusd.conf, without rotation.  If you go with the
+#  (or similar) in mods-enabled/detail, without rotation.  If you go with the
 #  second technique, you will need another cron job that removes old
 #  detail files.  You do not need to comment out the below for method #2.
 #
diff -urpN freeradius-server-3.2.6/debian/freeradius.service freeradius-server-3.2.7/debian/freeradius.service
--- freeradius-server-3.2.6/debian/freeradius.service	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/debian/freeradius.service	2025-01-31 18:42:21.000000000 +0700
@@ -25,7 +25,7 @@ MemoryLimit=2G
 # Ensure the daemon can still write its pidfile after it drops
 # privileges. Combination of options that work on a variety of
 # systems. Test very carefully if you alter these lines.
-RuntimeDirectory=freeradius
+RuntimeDirectory=freeradius freeradius/tmp
 RuntimeDirectoryMode=0775
 # This does not work on Debian Jessie:
 User=freerad
@@ -43,8 +43,13 @@ ExecReload=/bin/kill -HUP $MAINPID
 #  Don't elevate privileges after starting
 NoNewPrivileges=true
 
+# Control socket virtual servers typically create files in
+# the runtime directory.  If this is not kept, FreeRADIUS can't
+# be started in debug mode if those virtual servers are enabled.
+RuntimeDirectoryPreserve=yes
+
 # Allow binding to secure ports, broadcast addresses, and raw interfaces.
-#CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_BROADCAST CAP_NET_RAW CAP_SETUID CAP_SETGID CAP_CHOWN CAP_DAC_OVERRIDE
+AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_BROADCAST CAP_NET_RAW CAP_SETUID CAP_SETGID CAP_CHOWN CAP_DAC_OVERRIDE
 
 # Private /tmp that isn't shared by other processes
 PrivateTmp=true
diff -urpN freeradius-server-3.2.6/debian/rules freeradius-server-3.2.7/debian/rules
--- freeradius-server-3.2.6/debian/rules	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/debian/rules	2025-01-31 18:42:21.000000000 +0700
@@ -204,6 +204,8 @@ install-arch: build-arch-stamp
 	rm -f $(freeradius_dir)/usr/lib/freeradius/rlm_cache_memcached.so
 
 	dh_install --sourcedir=$(freeradius_dir) -p freeradius-utils
+	[ ! -e $(freeradius_dir)/usr/bin/radlast ] || \
+		install -m 0755 $(freeradius_dir)/usr/bin/radlast $(CURDIR)/debian/freeradius-utils/usr/bin/radlast
 	dh_install --sourcedir=$(freeradius_dir) -p freeradius
 
 	dh_strip -a --dbg-package=freeradius-dbg
diff -urpN freeradius-server-3.2.6/doc/ChangeLog freeradius-server-3.2.7/doc/ChangeLog
--- freeradius-server-3.2.6/doc/ChangeLog	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/doc/ChangeLog	2025-01-31 18:42:21.000000000 +0700
@@ -1,3 +1,69 @@
+FreeRADIUS 3.2.7 Fri 31 Jan 2025 12:00:00 UTC urgency=low
+	Configuration changes
+	* The dpsk module now supports dynamic expansion of the
+	  "filename" parameter.
+	* radiusd.conf now contains an "unlang" section, which
+	  controls new behavior for the "return" statement.
+	* New configuration parameters for TEAP which makes it
+	  much easier to configure.  See the "teap" section of
+	  the "eap" module.
+	* Change idle timeout for incoming radsec connections, to
+	  better match behavior of radsecproxy.
+	* python2 and rlm_couchbase are no longer available in the
+	  alpine docker image.
+	* utmp files are becoming obsolete due to 32-bit time. unix/radwtmp
+	  have been commented out in the default config and "radlast" is
+	  no longer installed if "last" is not present on the system.
+
+	Feature improvements
+	* Print MD5 hash of the configuration files in debug mode.
+	  This helps people track configuration changes.
+	* Add support for IPv6 to "abinary" type.  The fields
+	  are the same as for "ip", but use "ipv6", and IPv6
+	  formatted addresses.
+	* Update radclient to make it clear that Message-Authenticator
+	  is added to all Access-Request packets, even if the
+	  input file does not contain it.
+	* Add support for Subject AltName URI.  Closes #5450.
+	* Add python_path_mode option to python3 module.
+	* Relax checks on OpenSSL minor versions for OpenSSL 3.x.
+	* Add API for deleting dynamic home servers.
+	* set SO_KEEPALIVE on outbound sockets, so firewalls are
+	  less likly to close TCP connections.
+	* Allow querying of statistics when home_server has
+	  src_ipaddr set.  See FreeRADIUS-Stats-Server-Src-IP-Address.
+	  Fixes #5483
+	* Update dictionary "man" page.  Fixes #4346.
+	* Change jlibtool to use --show-config, to avoid conflicts with
+	  clang --config.  Fixes #5442.
+	* RADIUS/TLS clients now support a "tls' subsection.  For
+	  connections from this client, this section is used in preference
+	  to the "listen" TLS settings.  This allows a server to easily
+	  present different identities to different clients.
+	* RADIUS/TLS has been updated for TLS-PSK and TLS 1.3.  Tested with
+	  radsecproxy.
+
+	Bug fixes
+	* For EAP-TLS, send TLS start without a length field.
+	  Some clients refuse to do EAP-TLS when this field exists.
+	* Avoid blocking TLS sockets on corner cases during session
+	  setup.
+	* Update home server stats
+	* Correct error message about untrusted certs.  Fixes #5466.
+	* Use PyEval_RestoreThread to swap to main thread.
+	  Fixes #5111
+	* Don't run Python detach function on config check
+	* Fix a number of issues with TLS connections and
+	  "check_client_connections = yes".
+	* Be more careful about managing the incoming queue when databases
+	  block the server.  The server will still be unable to make
+	  progress, but it should crash less.  Whether or not this is a
+	  good thing is unknown.
+	* Better handler single-character expansions.  Fixes #2216.
+	* Correct calculation of EAP length in pre-proxy.  Fixes #5486.
+	* Don't segfault when using detail listeners. Fixes #5485
+	* Add check for Couchbase v2, rlm_couchbase won't build on v3.
+
 FreeRADIUS 3.2.6 Sat 24 Aug 2024 12:00:00 UTC urgency=low
 	Configuration changes
 	* require_message_authenticator=auto and limit_proxy_state=auto
diff -urpN freeradius-server-3.2.6/doc/antora/antora.yml freeradius-server-3.2.7/doc/antora/antora.yml
--- freeradius-server-3.2.6/doc/antora/antora.yml	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/doc/antora/antora.yml	2025-01-31 18:42:21.000000000 +0700
@@ -5,7 +5,7 @@
 #
 name: freeradius-server
 title: The FreeRADIUS Server
-version: '3.2.6'
+version: '3.2.7'
 start_page: ROOT:index.adoc
 nav:
 - modules/ROOT/nav.adoc
diff -urpN freeradius-server-3.2.6/man/man5/dictionary.5 freeradius-server-3.2.7/man/man5/dictionary.5
--- freeradius-server-3.2.6/man/man5/dictionary.5	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/man/man5/dictionary.5	2025-01-31 18:42:21.000000000 +0700
@@ -10,7 +10,7 @@
 .RE
 .sp
 ..
-.TH dictionary 5 "12 Jun 2015"
+.TH dictionary 5 "05 Jan 2025"
 .SH NAME
 dictionary \- RADIUS dictionary file
 .SH DESCRIPTION
@@ -89,8 +89,20 @@ recommended.
 
 The options are:
 
+     array        Multiple values are packed into one attribute.
+     concat	  Multiple attributes should be concatenated
      encrypt=#    set encryption type 1, 2, or 3.
      has_tag      The attribute can have an RFC 2868 style tag
+     secret	  A value which should not be printed in debug mode
+     virtual      The attribute is special to the server.
+
+The "array" flag is only used for DHCP.  It indicates that a DHCP
+option can contain an array of multiple values.
+
+The "concat" flags indicates that when multiple attributes are present
+in a packet, the contents should be concatenated together to get the
+final contents.  Similarly, when encoding packets, a long value should
+be split into multiple attributes.
 
 The "encrypt" flag marks the attribute as being encrypted with one of
 three possible methods.  "1" means that the attribute is encrypted
@@ -105,6 +117,14 @@ tag, as defined in \fIRFC2868\fP.  The p
 grouping of attributes for tunneled users.  See \fIRFC2868\fP for
 more details.
 
+The "secret" flag indicates that the value should not be printed in
+normal debug mode.  The value will be printed when the debug level
+is 3 or higher.
+
+The "virtual" flag is for the server, and indicates that the attribute
+does not really exist.  Instead, the value is taken from an internal
+callback.
+
 When the server receives an encoded attribute in a RADIUS packet, it
 looks up that attribute by number in the dictionary, and uses the
 definition found there for printing diagnostic and log messages.  When
diff -urpN freeradius-server-3.2.6/raddb/all.mk freeradius-server-3.2.7/raddb/all.mk
--- freeradius-server-3.2.6/raddb/all.mk	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/all.mk	2025-01-31 18:42:21.000000000 +0700
@@ -10,8 +10,8 @@ LOCAL_SITES :=		$(addprefix raddb/sites-
 DEFAULT_MODULES :=	always attr_filter chap date \
 			detail detail.log digest dynamic_clients eap \
 			echo exec expiration expr files linelog logintime \
-			mschap ntlm_auth pap passwd preprocess radutmp realm \
-			replicate soh sradutmp totp unix unpack utf8
+			mschap ntlm_auth pap passwd preprocess proxy_rate_limit \
+			radutmp realm replicate soh sradutmp totp unix unpack utf8
 
 ifneq "$(OPENSSL_LIBS)" ""
 DEFAULT_MODULE	+=	dpsk
diff -urpN freeradius-server-3.2.6/raddb/clients.conf freeradius-server-3.2.7/raddb/clients.conf
--- freeradius-server-3.2.6/raddb/clients.conf	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/clients.conf	2025-01-31 18:42:21.000000000 +0700
@@ -2,7 +2,7 @@
 ##
 ## clients.conf -- client configuration directives
 ##
-##	$Id: 5f39ff120a44e3fb837d1893d54a7ebb31fd8749 $
+##	$Id: b1dfe966986b24ad7b6c05189a810751bf835fbb $
 
 #######################################################################
 #
@@ -273,12 +273,44 @@ client localhost {
 		#  If no packets have been received over the connection for
 		#  this time, the connection will be closed.
 		#
+		#  In general, the client should close connections
+		#  when they are idle.  This setting is here just to
+		#  make sure that bad clients do not leave connections open for days.
+		#
+		#  If an idle timeout is set for only a "client" or a
+		#  "listen" section, that timeout is used.
+		#
+		#  If an idle timeout is set for both a "client" and a
+		#  "listen" section, then the smaller timeout is used.
+		#
 		#  Setting this to 0 means "no timeout".
 		#
 		#  We STRONGLY RECOMMEND that you set an idle timeout.
 		#
-		idle_timeout = 30
+		#  Systems with many incoming connections (500+) should
+		#  set this value to a lower number.  There are only a
+		#  limited number of usable file descriptors (usually
+		#  1024) due to Posix API issues.  If many sockets are
+		#  idle, it can prevent the server from opening new
+		#  connections.
+		#
+		idle_timeout = 900
 	}
+
+	#
+	#  TLS Configuration
+	#
+	#  A client can have TLS settings. The settings here are the
+	#  settings used by the server when a client connects to it.
+	#
+	#  The TLS configuration for RADIUS/TLS clients is the same as
+	#  the listener TLS configuration.  See sites-available/tls,
+	#  and "listen { ... tls { ... } }" for examples of the server
+	#  TLS configuration.
+	#
+#	tls {
+#		...
+#	}
 }
 
 # IPv6 Client
diff -urpN freeradius-server-3.2.6/raddb/home_servers/README.md freeradius-server-3.2.7/raddb/home_servers/README.md
--- freeradius-server-3.2.6/raddb/home_servers/README.md	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/home_servers/README.md	2025-01-31 18:42:21.000000000 +0700
@@ -19,3 +19,10 @@ sample shell script which creates home s
 
 This directory also has a `tls.conf` file which contains site-specific
 TLS configuration for home servers.
+
+The `tls.conf` file contains a `limit` section.  That section can be
+used to control idle timeouts, lifetimes, etc. for outgoing TLS
+connections.
+
+When all TLS connections to a dynamic home server are closed, the home
+server is automatically deleted.
diff -urpN freeradius-server-3.2.6/raddb/home_servers/tls.conf freeradius-server-3.2.7/raddb/home_servers/tls.conf
--- freeradius-server-3.2.6/raddb/home_servers/tls.conf	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/home_servers/tls.conf	2025-01-31 18:42:21.000000000 +0700
@@ -56,3 +56,40 @@
 		#  documentation on which configuration items are allowed here.
 		#
 	}
+
+	#
+	#  Connection limiting
+	#
+	limit {
+	      #
+	      #  Limit the number of TLS connections to the home server.
+	      #
+	      #  The default is 16.
+	      #  Setting this to 0 means "no limit"
+	      max_connections = 16
+
+	      #
+	      #  Limit the total number of requests sent over one
+	      #  TLS connection.  After this number of requests, the
+	      #  connection will be closed.  Any new packets that are
+	      #  proxied to the home server will result in a new TLS
+	      #  connection being made.
+	      #
+	      #  Setting this to 0 means "no limit"
+	      max_requests = 0
+
+	      #
+	      #  The lifetime, in seconds, of a TLS connection.  After
+	      #  this lifetime, the connection will be closed.
+	      #
+	      #  Setting this to 0 means "forever".
+	      lifetime = 0
+
+	      #
+	      #  The idle timeout, in seconds, of a TLS connection.
+	      #  If no packets have been sent over the connection for
+	      #  this time, the connection will be closed.
+	      #
+	      #  Setting this to 0 means "no timeout".
+	      idle_timeout = 0
+	}
diff -urpN freeradius-server-3.2.6/raddb/mods-available/dpsk freeradius-server-3.2.7/raddb/mods-available/dpsk
--- freeradius-server-3.2.6/raddb/mods-available/dpsk	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/dpsk	2025-01-31 18:42:21.000000000 +0700
@@ -1,6 +1,6 @@
 # -*- text -*-
 #
-#  $Id: 3cd8411403b3ddd5ad6c65186cae9f91b847bd78 $
+#  $Id: 7781915bcb9fa7d5bacefe8efee20c35acaab5d0 $
 
 #
 #  Calculate dynamic PSKs
@@ -69,7 +69,7 @@ dpsk {
 	#
 	#  The cache is keyed by (supplicant MAC + SSID)
 	#
-	#  The cache entry is the PSK-Identity and Pre-Sharedd-Key,
+	#  The cache entry is the PSK-Identity and Pre-Shared-Key,
 	#  and/or the PMK which are used to verify the information in
 	#  the Access-Request.
 	#
@@ -127,9 +127,10 @@ dpsk {
 	#  NOTE: Tests show that the module can do ~100K PSK / DPSK
 	#  checks per second.  This means that if you have 10,000
 	#  users and 10 packets a second, the system will be 100% busy
-	#  checking PSKs.
+	#  checking PSKs.  Similarly, of you have 100K DPSKs in the file,
+	#  the one packet will take 1 second of CPU time to verify!
 	#
-	#  As a result, the DPSK functionality is scales poorly.  It
+	#  As a result, the DPSK functionality scales poorly.  It
 	#  should be used only with a small number of PSKs (100s
 	#  perhaps), and only at low packet rates.  If the server is
 	#  getting 1000 packets per second, then it can only handle
@@ -141,5 +142,10 @@ dpsk {
 	#  number of PSKs and packet rates should be kept as low as
 	#  possible.
 	#
+	#  The filename is dynamically expanded, so it can reference
+	#  other attributes.  This expansion lets you split up DPSK
+	#  files by location, which can drastically reduce the overall
+	#  search space, and thus the CPU requirements.
+	#
 #	filename = "${modconfdir}/${..:name}/psk.csv"
 }
diff -urpN freeradius-server-3.2.6/raddb/mods-available/eap freeradius-server-3.2.7/raddb/mods-available/eap
--- freeradius-server-3.2.6/raddb/mods-available/eap	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/eap	2025-01-31 18:42:21.000000000 +0700
@@ -2,7 +2,7 @@
 ##
 ##  eap.conf -- Configuration for EAP types (PEAP, TTLS, etc.)
 ##
-##	$Id: d149707f02427234b09974effc33cb0db0dc48fb $
+##	$Id: 84660d7c1e84d9cdd144b2ceba08a44ebc44d7e1 $
 
 #######################################################################
 #
@@ -690,6 +690,12 @@ eap {
 			#  You should also delete all of the files
 			#  in the directory when the server starts.
 			#
+			#  Note that, on Linux systems with systemd, the
+			#  /tmp directory may be restricted. In this case
+			#  it may be best to use `${run_dir}/tmp` here
+			#  and create the temporary directory with the
+			#  systemd `RuntimeDirectory` unit option.
+			#
 		#	tmpdir = /tmp/radiusd
 
 			#  The command used to verify the client cert.
@@ -1149,6 +1155,47 @@ eap {
 
 	#	default_eap_type = mschapv2
 
+		#
+		#  Set the EAP type for user / machine authentication.
+		#
+		#  If set, these values over-ride "default_eap_type"
+		#
+		#  These values can be over-ridden at run time by setting
+		#
+		#	&session-state:TEAP-Type-User = ...
+		#
+		#  and
+		#	&session-state:TEAP-Type-Machine = ...
+		#
+		#  The values for those attributes are the same as for EAP-Type.
+		#
+		#  Note that if you try to use "EAP-Type := TEAP" in the
+		#  "inner-tunnel" virtual server, it will not work.
+		#
+		#
+		#  PASSWORDS
+		#
+		#  Some supplicants support password authentication inside of
+		#  TEAP.  This can be configured automatically by setting
+		#
+		#	identity_type = "user"
+		#
+		#  and then not setting "default_eap_type" or
+		#  "user_eap_type".  The TEAP module will then
+		#  automatically initiate password authentication.
+		#
+		#  The user credentials are placed into the User-Name
+		#  and User-Password attributes inside of the
+		#  "inner-tunnel" virtual server.  These attributes
+		#  are not sent in TEAP, but are created by the module
+		#  from the Basic-Password-Auth-Resp TLV which is in TEAP.
+		#
+		#  Supported authentication methods inside of TEAP are
+		#  EAP-TLS, EAP-MSCHAPv2, and PAP.
+		#
+#		user_eap_type = mschapv2
+#		machine_eap_type = tls
+
 		#  If 'cipher_list' is set here, it will over-ride the
 		#  'cipher_list' configuration from the 'tls-common'
 		#  configuration.  The EAP-TEAP module has it's own
@@ -1163,25 +1210,34 @@ eap {
 		#
 	#	cipher_list = "ALL:!EXPORT:!eNULL:!SSLv2"
 
-		#  PAC lifetime in seconds (default: seven days)
-		#
-	#	pac_lifetime = 604800
-
 		#  Authority ID of the server
 		#
-		#  If you are running a cluster of RADIUS servers, you should make
-		#  the value chosen here (and for "pac_opaque_key") the same on all
-		#  your RADIUS servers.  This value should be unique to your
-		#  installation.  We suggest using a domain name.
+		#  If you are running a cluster of RADIUS servers, you
+		#  should make the value chosen here the same on all
+		#  your RADIUS servers.  This value should be unique
+		#  to your installation.  We suggest using a domain
+		#  name.
 		#
 	#	authority_identity = "1234"
 
-		#  PAC Opaque encryption key (must be exactly 32 bytes in size)
+
 		#
-		#  This value MUST be secret, and MUST be generated using
-		#  a secure method, such as via 'openssl rand -hex 32'
+		#  Automatically go through the workflow of first machine, then user
+		#  authentication.
 		#
-	#	pac_opaque_key = "0123456789abcdef0123456789ABCDEF"
+		#  allowed values:  	"machine,user"
+		#  	   		"user,machine"
+		#			"user"
+		#			"machine"
+		#
+		#  If this isn't set, then TEAP likely won't work.
+		#
+		#  This configuration sets &session-state:FreeRADIUS-EAP-TEAP-TLV-Identity-Type with the
+		#  relevant values.  The TEAP module then picks those values, in order, to authenticate the
+		#  chosen identity.  You can set &session-state:FreeRADIUS-EAP-TEAP-TLV-Identity-Type
+		#  manually, but that is substantially more complicated.
+		#
+	#	identity_types = "machine,user"
 
 		#  Same as for TTLS, PEAP, etc.
 		#
diff -urpN freeradius-server-3.2.6/raddb/mods-available/proxy_rate_limit freeradius-server-3.2.7/raddb/mods-available/proxy_rate_limit
--- freeradius-server-3.2.6/raddb/mods-available/proxy_rate_limit	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/proxy_rate_limit	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,85 @@
+# -*- text -*-
+#
+#  $Id: e7db410a8c3d300e9552731c037fa55186137290 $
+
+#
+#  This module performs rate limiting on proxied packets.
+#
+#  In some cases, a home server does not delay Access-Reject packets.
+#  Badly behaved end-user devices may then try to authenticate many
+#  hundreds of times a second.  This behavior is effectively a denial
+#  of service (DoS) attack on the RADIUS infastructure.
+#
+#  This module tracks Access-Reject packets based on a key.  If the
+#  device is trying to authenticate too many times in quick
+#  succession, the module will return a reject rather than proxying
+#  the packet.  These Access-Requests will not be proxied for a
+#  configurable period of time, which is the "suppression period".
+#
+#  Access-Reject responses from home servers for proxied requests are
+#  store in a local tracking structure, keyed by username + supplicant
+#  MAC. IDs are tracked to identify retransmission of the most recent
+#  request.  There should be few issues with lock contention, as the
+#  tracking structure is designed carefully to avoid locks, or use
+#  multiple distinct locks.
+#
+#  Prior to proxying a request (in the pre-proxy section), the
+#  tracking structure is queried. If an activate entry exists for the
+#  device, then an Access-Reject will be sent and proxying will be
+#  cancelled. Multiple requests arriving within the same second from a
+#  device will cause the suppression period to the extended.
+#
+#  When a request is proxied, if the reponse from the home server (in
+#  the post-proxy section) is Access-Reject, then the device will be
+#  added to the corresponding tracking table.  If the device does not
+#  quickly re-authenticate, then the tracking tavble entry is
+#  discarded.
+#
+#  However, if multiple requests arrive for the same device within the
+#  same second, the module start rate-limiting requests as described
+#  above.
+#
+
+#
+#  Update the "pre-proxy" section to list the "proxy_rate_limit" module:
+#
+#	pre-proxy {
+#		...
+#		proxy_rate_limit
+#		...
+#	}
+#
+#  And update the "post-proxy" section to list the "proxy_rate_limit" module:
+#
+#	post-proxy {
+#		...
+#		proxy_rate_limit
+#		...
+#	}
+#
+
+#
+#  The module configuration.
+#
+proxy_rate_limit {
+	#
+	#  The key used to track entries.
+	#
+	#  For now, the key is not configurable, and is hard-coded to be the expansion below.
+	#
+#	key = "%{User-Name}%{Calling-Station-Id}
+
+	#
+	#  This limits the maximum number of entries which are
+	#  tracked.  If the table becomes full, then older entries
+	#  will be evicted to make room for new entries.
+	#
+	max_entries = 2048
+
+	#
+	#  The idle timeout period, or lifetime of entries.  If we do
+	#  not see packets for a device within this time limit, then
+	#  the entry is expired.
+	#
+	idle_timeout = 10
+}
diff -urpN freeradius-server-3.2.6/raddb/mods-available/python3 freeradius-server-3.2.7/raddb/mods-available/python3
--- freeradius-server-3.2.6/raddb/mods-available/python3	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/python3	2025-01-31 18:42:21.000000000 +0700
@@ -15,6 +15,17 @@ python3 {
 	#
 #	python_path="${modconfdir}/${.:name}:/another_path/to/python_files"
 
+	# How to use "python_path"
+	#
+	#  - "append" - append to system path
+	#  - "prepend" - prepend to the system path
+	#  - "overwrite" - overwrite the system path
+	#
+	#  Note: Take care when using "prepend" - the paths searched
+	#  should not be writeable by any un-trusted users or services
+	#  to avoid overriding standard functionality with malicious code.
+#	python_path_mode = append
+
 	module = example
 
 	# Pass all VPS lists as a 6-tuple to the callbacks
diff -urpN freeradius-server-3.2.6/raddb/mods-available/radutmp freeradius-server-3.2.7/raddb/mods-available/radutmp
--- freeradius-server-3.2.6/raddb/mods-available/radutmp	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/radutmp	2025-01-31 18:42:21.000000000 +0700
@@ -1,6 +1,6 @@
 # -*- text -*-
 #
-#  $Id: 82319c033bbf349991a46b8f198a5bf5487b5da8 $
+#  $Id: 3702bb04e776188d1f38ecdb6710a584e744e653 $
 
 #  Write a 'utmp' style file, of which users are currently
 #  logged in, and where they've logged in from.
@@ -8,6 +8,9 @@
 #  This file is used mainly for Simultaneous-Use checking,
 #  and also 'radwho', to see who's currently logged in.
 #
+#  The 'utmp' file format is becoming obsolete. You should use
+#  a database instead.
+#
 radutmp {
 	#  Where the file is stored.  It's not a log file,
 	#  so it doesn't need rotating.
diff -urpN freeradius-server-3.2.6/raddb/mods-available/rest freeradius-server-3.2.7/raddb/mods-available/rest
--- freeradius-server-3.2.6/raddb/mods-available/rest	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/rest	2025-01-31 18:42:21.000000000 +0700
@@ -99,7 +99,18 @@ rest {
 	#  Additional HTTP headers may be specified with control:REST-HTTP-Header.
 	#  The values of those attributes should be in the format:
 	#
-	#    control:REST-HTTP-Header := "<HTTP attribute>: <value>"
+	#	control:REST-HTTP-Header := "<HTTP attribute>: <value>"
+	#
+	#  You should set this attribute before calling the rest module,
+	#  via something like the following example.  Note that you MUST
+	#  update the HTTP attribute and key value to whatever is needed on
+	#  your local system.  The values given in this example are likely
+	#  to not work for your system.
+	#
+	#	update control {
+	#		&REST-HTTP-Header := "x-api-key: abcdefsupersecret"
+	#	}
+	#	rest
 	#
 	#  The control:REST-HTTP-Header attributes will be consumed
 	#  (i.e. deleted) after each call to the rest module, and each
@@ -191,6 +202,12 @@ rest {
 		uri = "${..connect_uri}/user/%{User-Name}/mac/%{Called-Station-ID}?action=authenticate"
 		method = 'get'
 		tls = ${..tls}
+
+		#
+		#  Note that you CANNOT set 'username' or 'password'
+		#  here.  When doing user authentication, the module
+		#  uses the User-Name and User-Password.
+		#
 	}
 
 	#  Preacct/Accounting/Post-auth/Pre-Proxy/Post-Proxy
diff -urpN freeradius-server-3.2.6/raddb/mods-available/sradutmp freeradius-server-3.2.7/raddb/mods-available/sradutmp
--- freeradius-server-3.2.6/raddb/mods-available/sradutmp	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/sradutmp	2025-01-31 18:42:21.000000000 +0700
@@ -1,14 +1,19 @@
 # -*- text -*-
 #
-#  $Id: 3a2a0e502e76ec00d4ec17e70132448e1547da46 $
+#  $Id: 2fbae19a4c856cc88c928da7a7fed3376c9f1796 $
 
-# "Safe" radutmp - does not contain caller ID, so it can be
-# world-readable, and radwho can work for normal users, without
-# exposing any information that isn't already exposed by who(1).
 #
-# This is another 'instance' of the radutmp module, but it is given
-# then name "sradutmp" to identify it later in the "accounting"
-# section.
+#  "Safe" radutmp - does not contain caller ID, so it can be
+#  world-readable, and radwho can work for normal users, without
+#  exposing any information that isn't already exposed by who(1).
+#
+#  This is another 'instance' of the radutmp module, but it is given
+#  then name "sradutmp" to identify it later in the "accounting"
+#  section.
+#
+#  'utmp' files are becoming obsolete. You should use a database
+#  instead.
+#
 radutmp sradutmp {
 	filename = ${logdir}/sradutmp
 	permissions = 0644
diff -urpN freeradius-server-3.2.6/raddb/mods-available/unix freeradius-server-3.2.7/raddb/mods-available/unix
--- freeradius-server-3.2.6/raddb/mods-available/unix	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-available/unix	2025-01-31 18:42:21.000000000 +0700
@@ -1,6 +1,6 @@
 # -*- text -*-
 #
-#  $Id: 5165139aaf39d533581161871542b48a6e3e8c42 $
+#  $Id: fcdd5b140a14424a780ce996041c3add4712460f $
 
 # Unix /etc/passwd style authentication
 #
@@ -21,5 +21,9 @@ unix {
 	#  Note that the radwtmp file may get large!  You should
 	#  rotate it (cp /dev/null radwtmp), or just not use it.
 	#
+	#  wtmp files are gradually becoming obsolete. Some systems
+	#  may not have 'last' or 'radlast' available any more.
+	#  You shoud use a database instead.
+	#
 	radwtmp = ${logdir}/radwtmp
 }
diff -urpN freeradius-server-3.2.6/raddb/mods-config/attr_filter/pre-proxy freeradius-server-3.2.7/raddb/mods-config/attr_filter/pre-proxy
--- freeradius-server-3.2.6/raddb/mods-config/attr_filter/pre-proxy	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/mods-config/attr_filter/pre-proxy	2025-01-31 18:42:21.000000000 +0700
@@ -2,7 +2,7 @@
 #	Configuration file for the rlm_attr_filter module.
 #	Please see rlm_attr_filter(5) manpage for more information.
 #
-#	$Id: 36d84e86906da2b102b81f4b8435bd49947a2d4d $
+#	$Id: 66f115c5aa05af178d094de45e0e6bc058f85346 $
 #
 #	This file contains security and configuration information
 #	for each realm. It can be used be an rlm_attr_filter module
@@ -62,6 +62,5 @@ DEFAULT
 	Operator-Name =* ANY,
 	Calling-Station-Id =* ANY,
 	Called-Station-Id =* ANY,
-	Operator-Name =* ANY,
 	Chargeable-User-Identity =* ANY,
 	Proxy-State =* ANY
diff -urpN freeradius-server-3.2.6/raddb/radiusd.conf.in freeradius-server-3.2.7/raddb/radiusd.conf.in
--- freeradius-server-3.2.6/raddb/radiusd.conf.in	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/radiusd.conf.in	2025-01-31 18:42:21.000000000 +0700
@@ -3,7 +3,7 @@
 ## radiusd.conf	-- FreeRADIUS server configuration file - @RADIUSD_VERSION_STRING@
 ##
 ##	http://www.freeradius.org/
-##	$Id: 44fee628e74bbc7ee69c905a6892f2841b7b840b $
+##	$Id: 376892e151857fa35c22662769acef3dcea08ecc $
 ##
 
 ######################################################################
@@ -291,6 +291,27 @@ hostname_lookups = no
 #proxy_dedup_window = 1
 
 #
+#  Unlang behavior options
+#
+unlang {
+	#
+	#  By default, the "return" keyword will cause the current process
+	#  section to complete.  These two options allow "return" to be
+	#  used to just exit "group" sections or "policy" sections
+	#
+	#  Setting this to yes, will cause "return" within a group to
+	#  exit the group but continue processing after that.
+	#
+#	group_stop_return = no
+
+	#
+	#  Setting this to yes, will cause "return" within a policy to
+	#  exit the policy but continue processing after that.
+	#
+#	policy_stop_return = no
+}
+
+#
 #  Logging section.  The various "log_*" configuration items
 #  will eventually be moved here.
 #
@@ -704,8 +725,8 @@ security {
 	#
 	#  Global configuration for limiting the combination of
 	#  Proxy-State and Message-Authenticator.  This flag only
-	#  applies to packets sent over UDP or TCP.  This flag is
-	#  ignored for TLS.
+	#  applies to Access-Request packets sent from a client, over
+	#  UDP or TCP.  This flag is ignored for TLS.
 	#
 	#  This flag sets the global default for all clients.  It can
 	#  be over-ridden in an individual client definition by adding
@@ -719,13 +740,13 @@ security {
 	#
 	#  The possible values and meanings for "limit_proxy_state" are;
 	#
-	#  * "no" - allow any packets from the client, even packets
-	#    which contain the BlastRADIUS attack.  Please be aware
-	#    that in this configuration the server will complain for
-	#    EVERY packet which it receives.
+	#  * "no" - allow any Access-Request packets from the client,
+	#    even packets which contain the BlastRADIUS attack.
+	#    Please be aware that in this configuration the server
+	#    will complain for EVERY packet which it receives.
 	#
 	#    The only reason to set this flag to "no" is when the
-	#    client is a proxy, AND the proxy does not send
+	#    client is a proxy, AND it does not send
 	#    Message-Authenticator in Access-Request packets.  Even
 	#    then, the best approach to fix the issue is to (1) update
 	#    the proxy to send Message-Authenticator, and if that
@@ -735,14 +756,17 @@ security {
 	#
 	#    WARNING: Setting both this flag and the
 	#    "require_message_authenticator" flag to "no" will allow
-	#    MITM attackers to create fake Access-Accept packets to the
-	#    NAS!  At least one of them MUST be set to "yes" for the
-	#    system to have any protection against the attack.
-	#
-	#  * "yes" - Allow packets without Message-Authenticator,
-	#    but only when they do not contain Proxy-State.
-	#    packets which contain Proxy-State MUST also contain
-	#    Message-Authenticator, otherwise they are discarded.
+	#    MITM attackers to spoof Access-Request packets, and then
+	#    to create fake Access-Accept packets to the NAS!  At
+	#    least one of these configuration items MUST be set to
+	#    "yes" for the system to have any protection against the
+	#    attack.
+	#
+	#  * "yes" - Allow Access-Request packets without
+	#    Message-Authenticator, but only when they do not contain
+	#    Proxy-State.  Packets which contain Proxy-State MUST also
+	#    contain Message-Authenticator, otherwise they are
+	#    discarded.
 	#
 	#    This setting is safe for most NASes, GGSNs, BRAS, etc.
 	#    Most regular RADIUS clients do not send Proxy-State
@@ -756,7 +780,8 @@ security {
 	#    the WLC, and set "require_message_authenticator" to "yes".
 	#
 	#  * "auto" - Automatically determine the value of the flag,
-	#    based on the first packet received from that client.
+	#    based on the first Access-Request packet received from
+	#    that client.
 	#
 	#    If the packet contains Proxy-State but no
 	#    Message-Authenticator, then the value of the flag is
diff -urpN freeradius-server-3.2.6/raddb/sites-available/decoupled-accounting freeradius-server-3.2.7/raddb/sites-available/decoupled-accounting
--- freeradius-server-3.2.6/raddb/sites-available/decoupled-accounting	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/sites-available/decoupled-accounting	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
 #	This file is NOT meant to be used as-is.  It needs to be
 #	edited to match your local configuration.
 #
-#	$Id: abf455cc2cf10da1e8e749a90b544a533c7e26e1 $
+#	$Id: 46bf7a120dad1c67235afa0da9316641263e7c43 $
 #
 ######################################################################
 
@@ -91,15 +91,16 @@ accounting {
 
 	#  Update the wtmp file
 	#
-	#  If you don't use "radlast", you can delete this line.
-	unix
+	#  If you don't use "radlast" (becoming obsolete and no longer
+	#  available on all systems), you can delete this line.
+#	unix
 
 	#
 	#  For Simultaneous-Use tracking.
 	#
 	#  Due to packet losses in the network, the data here
 	#  may be incorrect.  There is little we can do about it.
-	radutmp
+#	radutmp
 #	sradutmp
 
 	#
diff -urpN freeradius-server-3.2.6/raddb/sites-available/default freeradius-server-3.2.7/raddb/sites-available/default
--- freeradius-server-3.2.6/raddb/sites-available/default	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/sites-available/default	2025-01-31 18:42:21.000000000 +0700
@@ -11,7 +11,7 @@
 #	the "inner-tunnel" virtual server.  You will likely have to edit
 #	that, too, for authentication to work.
 #
-#	$Id: b4339bde9e22910fb01159fd89b6a92cbb2cae24 $
+#	$Id: 5046e59429b1510d5a2372593a60d16f2b951d7b $
 #
 ######################################################################
 #
@@ -190,11 +190,29 @@ listen {
 	      #  If no packets have been received over the connection for
 	      #  this time, the connection will be closed.
 	      #
+	      #  In general, the client should close connections when
+	      #  they are idle.  This setting is here just to make
+	      #  sure that bad clients do not leave connections open
+	      #  for days.
+	      #
+	      #  If an idle timeout is set for only a "client" or a
+	      #  "listen" section, that timeout is used.
+	      #
+	      #  If an idle timeout is set for both a "client" and a
+	      #  "listen" section, then the smaller timeout is used.
+	      #
 	      #  Setting this to 0 means "no timeout".
 	      #
 	      #  We STRONGLY RECOMMEND that you set an idle timeout.
 	      #
-	      idle_timeout = 30
+	      #  Systems with many incoming connections (500+) should
+	      #  set this value to a lower number.  There are only a
+	      #  limited number of usable file descriptors (usually
+	      #  1024) due to Posix API issues.  If many sockets are
+	      #  idle, it can prevent the server from opening new
+	      #  connections.
+	      #
+	      idle_timeout = 900
 	}
 }
 
@@ -681,6 +699,7 @@ accounting {
 	#  recorded from the corresponding Access-Accept
 	#  use it only if your NAS boxes do not support CUI themselves
 #	cui
+
 	#
 	#  Create a 'detail'ed log of the packets.
 	#  Note that accounting requests which are proxied
@@ -690,8 +709,9 @@ accounting {
 
 	#  Update the wtmp file
 	#
-	#  If you don't use "radlast", you can delete this line.
-	unix
+	#  If you don't use "radlast" (becoming obsolete and no longer
+	#  available on all systems), you can delete this line.
+#	unix
 
 	#
 	#  For Simultaneous-Use tracking.
@@ -1080,9 +1100,31 @@ post-auth {
 #  stage.  This stage can re-write the request, or decide to
 #  cancel the proxy.
 #
+#  Before this section is run, the request list is copied to the
+#  proxy list.  The proxied packet can be edited by examining
+#  or changing attributes in the proxy list.
+#
 #  Only a few modules currently have this method.
 #
 pre-proxy {
+	#  Some supplicants will aggressively retry after an Access-Reject,
+	#  contrary to standards. You can avoid sending excessive load to home
+	#  servers that based on recent history is likely to only result in
+	#  further authentication failures by calling the proxy_rate_limit
+	#  module here and in the post-proxy section.
+	#
+	#  If a request is send too soon after a home server returned an
+	#  Access-Reject, then instead of proxying a request a Access-Reject
+	#  will be returned.
+	#
+	#  The principle is to expend a small amount of resources at the edge
+	#  (an in-memory cache of recent rejects for calling stations) to
+	#  defend the limited processing and network resources at the core.
+	#
+	#  The strategy can be tuned in the module configuration.
+	#
+#	proxy_rate_limit
+
 	# Before proxing the request add an Operator-Name attribute identifying
 	# if the operator-name is found for this client.
 	# No need to uncomment this if you have already enabled this in
@@ -1114,6 +1156,11 @@ pre-proxy {
 #  to a home server, the request may be massaged here, in the
 #  post-proxy stage.
 #
+#  Before this section is run, all attributes in the reply list
+#  are deleted.  This section can then examine or edit the
+#  proxy_reply list.  Once this section is finished, the attributes
+#  in the proxy_reply list are copied to the reply list.
+#
 post-proxy {
 
 	#  If you want to have a log of replies from a home server,
@@ -1126,17 +1173,21 @@ post-proxy {
 #	attr_filter.post-proxy
 
 	#
-	#  If you are proxying LEAP, you MUST configure the EAP
-	#  module, and you MUST list it here, in the post-proxy
-	#  stage.
-	#
-	#  You MUST also use the 'nostrip' option in the 'realm'
-	#  configuration.  Otherwise, the User-Name attribute
-	#  in the proxied request will not match the user name
-	#  hidden inside of the EAP packet, and the end server will
-	#  reject the EAP request.
+	#  The EAP module will perform some validation of proxied EAP
+	#  packets.  Malformed EAP packets will be rejected, and will
+	#  not be proxied.
 	#
-	eap
+	#  This configuration is most useful to prevent bad
+	#  supplicants or APs from attacking the proxies and home
+	#  servers.
+	#
+#	eap
+
+	#  If proxied requests are to be rate limited, then the
+	#  proxy_rate_limit module must be called here to maintain a
+	#  record of proxy responses.
+	#
+#	proxy_rate_limit
 
 	#
 	#  If the server tries to proxy a request and fails, then the
diff -urpN freeradius-server-3.2.6/raddb/sites-available/google-ldap-auth freeradius-server-3.2.7/raddb/sites-available/google-ldap-auth
--- freeradius-server-3.2.6/raddb/sites-available/google-ldap-auth	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/sites-available/google-ldap-auth	2025-01-31 18:42:21.000000000 +0700
@@ -7,6 +7,11 @@
 #	This file is designed to be used as an inner tunnel virtual
 #	server for EAP-TTLS-PAP authentication.
 #
+#	Note that Google LDAP does NOT allow FreeRADIUS to read the
+#	password in LDAP.  Which means that it is IMPOSSIBLE to get
+#	PEAP to work with Google LDAP.  It is also IMPOSSIBLE to get
+#	EAP-TTLS with CHAP or MS-CHAP to work.
+#
 #	Use this virtual server in conjunction with the sample Google
 #	Secure LDAP module configuration, which is in
 #	mods-available/ldap_google.
@@ -22,12 +27,13 @@
 #
 #	Typically the caches are beneficial when performing
 #	authentication for 802.1x wifi where repeated authentications
-#	occur as users roam.  We also recommend enabling the "cache"
-#	subsection of mods-available/eap.  Both kinds of caching can
-#	be done at the same time, and both kinds of caching will help
-#	improve system performance and stability.
+#	occur as users roam.  We also recommend enabling session
+#	resumption in the "cache" subsection of mods-available/eap.
+#	Both kinds of caching can be done at the same time, and both
+#	kinds of caching will help to improve system performance and
+#	stability.
 #
-#	$Id: 3be530f0787841628c655031465d2a0e3300629c $
+#	$Id: e547b50cd876554258a05286cf034c1b98994296 $
 #
 #########################################################################
 
diff -urpN freeradius-server-3.2.6/raddb/sites-available/inner-tunnel freeradius-server-3.2.7/raddb/sites-available/inner-tunnel
--- freeradius-server-3.2.6/raddb/sites-available/inner-tunnel	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/sites-available/inner-tunnel	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 #	This is a virtual server that handles *only* inner tunnel
 #	requests for EAP-TTLS and PEAP types.
 #
-#	$Id: 1197e084d77e469f7208306489f2b15588546a4e $
+#	$Id: 68998cf95e67829f462e5bc65c0bb7fdba3843d1 $
 #
 ######################################################################
 
@@ -289,7 +289,7 @@ authenticate {
 #  or rlm_sql module can handle this.
 #  The rlm_sql module is *much* faster
 session {
-	radutmp
+#	radutmp
 
 	#
 	#  See "Simultaneous Use Checking Queries" in `mods-config/sql/main/$driver/queries.conf`
diff -urpN freeradius-server-3.2.6/raddb/sites-available/originate-coa freeradius-server-3.2.7/raddb/sites-available/originate-coa
--- freeradius-server-3.2.6/raddb/sites-available/originate-coa	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/sites-available/originate-coa	2025-01-31 18:42:21.000000000 +0700
@@ -97,6 +97,12 @@ home_server example-coa {
 	#  secret in a "client" section.
 	secret = testing1234
 
+	#
+	#  All of the rest of the home_server configuration items can
+	#  go here, including src_ipaddr,
+	#  require_message_authenticator, etc.
+	#
+
 	#  CoA specific parameters.  See raddb/proxy.conf for details.
 	coa {
 		irt = 2
diff -urpN freeradius-server-3.2.6/raddb/sites-available/tls freeradius-server-3.2.7/raddb/sites-available/tls
--- freeradius-server-3.2.6/raddb/sites-available/tls	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/raddb/sites-available/tls	2025-01-31 18:42:21.000000000 +0700
@@ -426,6 +426,10 @@ listen {
 		#
 		#  Require a client certificate.
 		#
+		#  If you set this to "no", then any client can
+		#  connect anonymously.  This is bad, and is likely
+		#  not what you want.
+		#
 		require_client_cert = yes
 
 		#
@@ -449,7 +453,14 @@ listen {
 			#
 			#  You should also delete all of the files
 			#  in the directory when the server starts.
-	#     		tmpdir = /tmp/radiusd
+			#
+			#  Note that, on Linux systems with systemd, the
+			#  /tmp directory may be restricted. In this case
+			#  it may be best to use `${run_dir}/tmp` here
+			#  and create the temporary directory with the
+			#  systemd `RuntimeDirectory` unit option.
+			#
+	#		tmpdir = /tmp/radiusd
 
 			#  The command used to verify the client cert.
 			#  We recommend using the OpenSSL command-line
@@ -463,7 +474,7 @@ listen {
 			#  in PEM format.  This file is automatically
 			#  deleted by the server when the command
 			#  returns.
-	#    		client = "/path/to/openssl verify -CApath ${..ca_path} %{TLS-Client-Cert-Filename}"
+	#		client = "/path/to/openssl verify -CApath ${..ca_path} %{TLS-Client-Cert-Filename}"
 		}
 
 		#
@@ -554,6 +565,10 @@ home_server tls {
 	#
 #	nonblock = yes
 
+	#
+	#  The TLS settings used by the proxy (i.e. RADIUS client)
+	#  when it connects to a home server.
+	#
 	tls {
 		#
 		#  Similarly to HTTP, the client can use Server Name
diff -urpN freeradius-server-3.2.6/redhat/freeradius-logrotate freeradius-server-3.2.7/redhat/freeradius-logrotate
--- freeradius-server-3.2.6/redhat/freeradius-logrotate	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/redhat/freeradius-logrotate	2025-01-31 18:42:21.000000000 +0700
@@ -42,9 +42,9 @@
 #  to write to a single detail file per IP and use the rotate config
 #  below.  Another is to write to a daily detail file per IP with:
 #
-#     detailfile = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
+#     filename = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
 #
-#  (or similar) in radiusd.conf, without rotation.  If you go with the
+#  (or similar) in mods-enabled/detail, without rotation.  If you go with the
 #  second technique, you will need another cron job that removes old
 #  detail files.  You do not need to comment out the below for method #2.
 #
diff -urpN freeradius-server-3.2.6/redhat/freeradius.spec freeradius-server-3.2.7/redhat/freeradius.spec
--- freeradius-server-3.2.6/redhat/freeradius.spec	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/redhat/freeradius.spec	2025-01-31 18:42:21.000000000 +0700
@@ -1,11 +1,13 @@
 %bcond_with rlm_yubikey
 %bcond_without ldap
+%bcond_with radlast
 # %%bcond_with experimental_modules
 
 %{!?_with_rlm_cache_memcached: %global _without_rlm_cache_memcached --without-rlm_cache_memcached}
 %{!?_with_rlm_eap_pwd: %global _without_rlm_eap_pwd --without-rlm_eap_pwd}
 %{!?_with_rlm_eap_tnc: %global _without_rlm_eap_tnc --without-rlm_eap_tnc}
 %{!?_with_rlm_yubikey: %global _without_rlm_yubikey --without-rlm_yubikey}
+%{!?_with_radlast: %global _without_radlast --without-radlast}
 %{?_without_ldap: %global _without_libfreeradius_ldap --without-libfreeradius-ldap}
 %{?el7: %global _without_rlm_eap_teap --without-rlm_eap_teap}
 
@@ -31,7 +33,7 @@
 
 Summary: High-performance and highly configurable free RADIUS server
 Name: freeradius
-Version: 3.2.6
+Version: 3.2.7
 Release: 1%{?dist}
 License: GPLv2+ and LGPLv2+
 Group: System Environment/Daemons
@@ -428,6 +430,8 @@ export LDFLAGS="-Wl,--build-id"
         %{?_without_rlm_cache_memcached} \
         %{?_without_libwbclient} \
         %{?_without_libfreeradius_ldap} \
+        %{?_with_radlast} \
+        %{?_without_radlast} \
 #        --with-modules="rlm_wimax" \
 
 make %_smp_mflags
@@ -660,6 +664,7 @@ fi
 %{_libdir}/freeradius/rlm_pap.so
 %{_libdir}/freeradius/rlm_passwd.so
 %{_libdir}/freeradius/rlm_preprocess.so
+%{_libdir}/freeradius/rlm_proxy_rate_limit.so
 %{_libdir}/freeradius/rlm_radutmp.so
 %{_libdir}/freeradius/rlm_realm.so
 %{_libdir}/freeradius/rlm_replicate.so
@@ -699,7 +704,7 @@ fi
 %dir %attr(770,root,radiusd) %{_sysconfdir}/raddb/certs
 %attr(640,root,radiusd) %config(noreplace) %{_sysconfdir}/raddb/certs/README.md
 %attr(640,root,radiusd) %config(noreplace) %{_sysconfdir}/raddb/certs/Makefile
-%attr(640,root,radiusd) %config(noreplace) %{_sysconfdir}/raddb/certs/bootstrap
+%attr(750,root,radiusd) %config(noreplace) %{_sysconfdir}/raddb/certs/bootstrap
 %attr(640,root,radiusd) %config(noreplace) %{_sysconfdir}/raddb/certs/xpextensions
 %attr(640,root,radiusd) %config(noreplace) %{_sysconfdir}/raddb/certs/*.cnf
 %dir %attr(770,root,radiusd) %{_sysconfdir}/raddb/certs/realms
@@ -843,7 +848,9 @@ fi
 /usr/bin/radclient
 /usr/bin/radcrypt
 /usr/bin/radeapclient
+%if %{?_with_radlast:1}%{!?_with_radlast:0}
 /usr/bin/radlast
+%endif
 /usr/bin/radtest
 /usr/bin/radsecret
 /usr/bin/radsniff
@@ -858,7 +865,9 @@ fi
 %doc %{_mandir}/man1/rad_counter.1.gz
 %doc %{_mandir}/man1/radclient.1.gz
 %doc %{_mandir}/man1/radeapclient.1.gz
+%if %{?_with_radlast:1}%{!?_with_radlast:0}
 %doc %{_mandir}/man1/radlast.1.gz
+%endif
 %doc %{_mandir}/man8/radsqlrelay.8.gz
 %doc %{_mandir}/man1/radtest.1.gz
 %doc %{_mandir}/man1/radwho.1.gz
diff -urpN freeradius-server-3.2.6/redhat/radiusd.service freeradius-server-3.2.7/redhat/radiusd.service
--- freeradius-server-3.2.6/redhat/radiusd.service	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/redhat/radiusd.service	2025-01-31 18:42:21.000000000 +0700
@@ -22,10 +22,10 @@ Environment=HOSTNAME=%H
 # a leak somewhere.
 MemoryLimit=2G
 
-RuntimeDirectory=radiusd
+RuntimeDirectory=radiusd radiusd/tmp
 RuntimeDirectoryMode=0775
 User=radiusd
-Group=radiusd 
+Group=radiusd
 ExecStartPre=/usr/sbin/radiusd $FREERADIUS_OPTIONS -Cx -lstdout
 ExecStart=/usr/sbin/radiusd -f $FREERADIUS_OPTIONS
 Restart=on-failure
@@ -36,11 +36,13 @@ ExecReload=/bin/kill -HUP $MAINPID
 #  Don't elevate privileges after starting
 NoNewPrivileges=true
 
+# Control socket virtual servers typically create files in
+# the runtime directory.  If this is not kept, FreeRADIUS can't
+# be started in debug mode if those virtual servers are enabled.
+RuntimeDirectoryPreserve=yes
+
 # Allow binding to secure ports, broadcast addresses, and raw interfaces.
-#
-# This list of capabilities may not be exhaustive, and needs
-# further testing. Please uncomment, test, and report any issues.
-#CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_BROADCAST CAP_NET_RAW CAP_SETUID CAP_SETGID CAP_CHOWN CAP_DAC_OVERRIDE
+AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_BROADCAST CAP_NET_RAW CAP_SETUID CAP_SETGID CAP_CHOWN CAP_DAC_OVERRIDE
 
 # Private /tmp that isn't shared by other processes
 PrivateTmp=true
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/alpine/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/alpine/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/alpine/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/alpine/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -3,8 +3,8 @@
 #
 # Rebuild this file with `make docker.alpine.regen`
 #
-ARG from=alpine:3.13
-FROM ${from} as build
+ARG from=alpine:3.21
+FROM ${from} AS build
 
 #
 #  Install build tools
@@ -44,9 +44,9 @@ RUN apk add linux-headers
 RUN apk add pcre-dev libidn-dev krb5-dev samba-dev curl-dev json-c-dev
 RUN apk add openldap-dev unbound-dev
 # languages
-RUN apk add ruby-dev perl-dev python2-dev python3-dev
+RUN apk add ruby-dev perl-dev python3-dev
 # databases
-RUN apk add hiredis-dev libmemcached-dev gdbm-dev libcouchbase-dev
+RUN apk add hiredis-dev libmemcached-dev gdbm-dev
 # sql
 RUN apk add postgresql-dev mariadb-dev unixodbc-dev sqlite-dev
 
@@ -80,8 +80,8 @@ RUN apk update \
     && apk add libcurl json-c libldap hiredis sqlite-dev \
 #RUN apk add libidn krb5
 #RUN apk add unbound-libs
-#RUN apk add ruby-libs perl python2-dev python3-dev
-#RUN apk add libmemcached gdbm libcouchbase
+#RUN apk add ruby-libs perl python3-dev
+#RUN apk add libmemcached gdbm
 #RUN apk add postgresql-dev mariadb-dev unixodbc-dev
     \
     && ln -s /opt/etc/raddb /etc/raddb
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/centos7/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/centos7/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/centos7/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/centos7/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.centos7.regen`
 #
 ARG from=centos:7
-FROM ${from} as build
+FROM ${from} AS build
 
 #
 #  CentOS 7 is now EOL, so we need to fix up the repo source
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/debian10/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/debian10/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/debian10/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/debian10/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.debian10.regen`
 #
 ARG from=debian:buster
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/debian11/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/debian11/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/debian11/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/debian11/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.debian11.regen`
 #
 ARG from=debian:bullseye
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/debian12/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/debian12/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/debian12/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/debian12/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.debian12.regen`
 #
 ARG from=debian:bookworm
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/debiansid/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/debiansid/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/debiansid/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/debiansid/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.debiansid.regen`
 #
 ARG from=debian:sid
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/rocky8/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/rocky8/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/rocky8/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/rocky8/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,8 @@
 # Rebuild this file with `make docker.rocky8.regen`
 #
 ARG from=rockylinux/rockylinux:8
-FROM ${from} as build
+FROM ${from} AS build
+
 
 #
 #  Install yum
@@ -59,8 +60,10 @@ gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-K
 RUN rpm --import https://ltb-project.org/lib/RPM-GPG-KEY-LTB-project
 
 #  Enable EPEL repository for freetds and hiredis
+
 RUN yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm
 
+
 #  Enable powertools repo
 RUN yum config-manager --enable powertools
 
@@ -107,6 +110,7 @@ FROM ${from}
 
 COPY --from=build /root/rpms /tmp/
 
+
 #
 #  Install yum
 #
@@ -122,8 +126,8 @@ gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-K
 > /etc/yum.repos.d/ltb-project.repo \
     && rpm --import https://ltb-project.org/lib/RPM-GPG-KEY-LTB-project
 
-
 #  EPEL repository for freetds and hiredis
+
 RUN yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm \
     && yum install -y dnf-utils \
     && yum config-manager --enable powertools \
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/rocky9/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/rocky9/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/rocky9/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/rocky9/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,8 @@
 # Rebuild this file with `make docker.rocky9.regen`
 #
 ARG from=rockylinux/rockylinux:9
-FROM ${from} as build
+FROM ${from} AS build
+
 
 #
 #  Install yum
@@ -49,8 +50,10 @@ RUN [ -z "$release" ] || git checkout ${
 #
 
 #  Enable EPEL repository for freetds and hiredis
+
 RUN yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
 
+
 #  Enable Code Ready Builder repo (CentOS powertools equivalent)
 RUN yum install -y yum-utils
 RUN yum config-manager --enable crb
@@ -95,14 +98,15 @@ FROM ${from}
 
 COPY --from=build /root/rpms /tmp/
 
+
 #
 #  Install yum
 #
 RUN dnf install -y yum
 
 
-
 #  EPEL repository for freetds and hiredis
+
 RUN yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm \
     && yum install -y dnf-utils \
     && yum config-manager --enable crb \
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/ubuntu18/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/ubuntu18/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/ubuntu18/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/ubuntu18/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.ubuntu18.regen`
 #
 ARG from=ubuntu:18.04
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/ubuntu20/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/ubuntu20/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/ubuntu20/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/ubuntu20/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.ubuntu20.regen`
 #
 ARG from=ubuntu:20.04
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/ubuntu22/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/ubuntu22/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/ubuntu22/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/ubuntu22/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.ubuntu22.regen`
 #
 ARG from=ubuntu:22.04
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/dists/ubuntu24/Dockerfile freeradius-server-3.2.7/scripts/docker/dists/ubuntu24/Dockerfile
--- freeradius-server-3.2.6/scripts/docker/dists/ubuntu24/Dockerfile	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/dists/ubuntu24/Dockerfile	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 # Rebuild this file with `make docker.ubuntu24.regen`
 #
 ARG from=ubuntu:24.04
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.alpine.m4 freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.alpine.m4
--- freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.alpine.m4	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.alpine.m4	2025-01-31 18:42:21.000000000 +0700
@@ -1,5 +1,5 @@
 ARG from=DOCKER_IMAGE
-FROM ${from} as build
+FROM ${from} AS build
 
 #
 #  Install build tools
@@ -39,9 +39,9 @@ RUN apk add linux-headers
 RUN apk add pcre-dev libidn-dev krb5-dev samba-dev curl-dev json-c-dev
 RUN apk add openldap-dev unbound-dev
 # languages
-RUN apk add ruby-dev perl-dev python2-dev python3-dev
+RUN apk add ruby-dev perl-dev python3-dev
 # databases
-RUN apk add hiredis-dev libmemcached-dev gdbm-dev libcouchbase-dev
+RUN apk add hiredis-dev libmemcached-dev gdbm-dev
 # sql
 RUN apk add postgresql-dev mariadb-dev unixodbc-dev sqlite-dev
 
@@ -75,8 +75,8 @@ RUN apk update \
     && apk add libcurl json-c libldap hiredis sqlite-dev \
 #RUN apk add libidn krb5
 #RUN apk add unbound-libs
-#RUN apk add ruby-libs perl python2-dev python3-dev
-#RUN apk add libmemcached gdbm libcouchbase
+#RUN apk add ruby-libs perl python3-dev
+#RUN apk add libmemcached gdbm
 #RUN apk add postgresql-dev mariadb-dev unixodbc-dev
     \
     && ln -s /opt/etc/raddb /etc/raddb
diff -urpN freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.deb.m4 freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.deb.m4
--- freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.deb.m4	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.deb.m4	2025-01-31 18:42:21.000000000 +0700
@@ -1,5 +1,5 @@
 ARG from=DOCKER_IMAGE
-FROM ${from} as build
+FROM ${from} AS build
 
 ARG DEBIAN_FRONTEND=noninteractive
 
diff -urpN freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.m4 freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.m4
--- freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.m4	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.m4	2025-01-31 18:42:21.000000000 +0700
@@ -18,7 +18,7 @@ define([p_SET], [
 ])
 dnl		D_NAME		PKG_TYPE      OS_NAME	OS_VER	OS_CODENAME	DOCKER_IMAGE
 ifelse(
-	D_NAME, [alpine],	[p_SET([alpine], [alpine], [3.13], [alpine],	[alpine:3.13])],
+	D_NAME, [alpine],	[p_SET([alpine], [alpine], [3.21], [alpine],	[alpine:3.21])],
 	D_NAME, [debian10],	[p_SET([deb], [debian],	[10],	[buster],	[debian:buster])],
 	D_NAME, [debian11],	[p_SET([deb], [debian],	[11],	[bullseye],	[debian:bullseye])],
 	D_NAME, [debian12],	[p_SET([deb], [debian],	[12],	[bookworm],	[debian:bookworm])],
diff -urpN freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.rpm.m4 freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.rpm.m4
--- freeradius-server-3.2.6/scripts/docker/m4/Dockerfile.rpm.m4	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/docker/m4/Dockerfile.rpm.m4	2025-01-31 18:42:21.000000000 +0700
@@ -1,5 +1,5 @@
 ARG from=DOCKER_IMAGE
-FROM ${from} as build
+FROM ${from} AS build
 
 ifelse(OS_VER, 7, `dnl
 #
diff -urpN freeradius-server-3.2.6/scripts/jlibtool.c freeradius-server-3.2.7/scripts/jlibtool.c
--- freeradius-server-3.2.6/scripts/jlibtool.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/jlibtool.c	2025-01-31 18:42:21.000000000 +0700
@@ -68,8 +68,8 @@
 #  define PIC_FLAG			"-fPIC -fno-common"
 #  define SHARED_OPTS			"-dynamiclib"
 #  define MODULE_OPTS			"-bundle -dynamic"
-#  define DYNAMIC_LINK_OPTS		"-flat_namespace"
-#  define DYNAMIC_LINK_UNDEFINED	"-undefined suppress"
+#  define DYNAMIC_LINK_OPTS		"-bind_at_load"
+#  define DYNAMIC_LINK_UNDEFINED	"-Wl,-w -undefined dynamic_lookup"
 #  define dynamic_link_version_func	darwin_dynamic_link_function
 #  define DYNAMIC_INSTALL_NAME		"-install_name"
 #  define DYNAMIC_LINK_NO_INSTALL	"-dylib_file"
@@ -327,25 +327,26 @@ static void usage(int code)
 	printf("Usage: jlibtool [OPTIONS...] COMMANDS...\n");
 	printf("jlibtool is a replacement for GNU libtool with similar functionality.\n\n");
 
-	printf("  --config	 show all configuration variables\n");
-	printf("  --debug	  enable verbose shell tracing\n");
-	printf("  --dry-run	display commands without modifying any files\n");
-	printf("  --help	   display this help message and exit\n");
-	printf("  --mode=MODE	   use operational mode MODE (you *must* set mode)\n");
+	printf("  --debug	 enable verbose shell tracing\n");
+	printf("  --dry-run	 display commands without modifying any files\n");
+	printf("  --help	 display this help message and exit\n");
+	printf("  --mode=MODE	 use operational mode MODE (you *must* set mode)\n");
 
 	printf("  --silent	 don't print informational messages\n");
-	printf("  --tag=TAG	Ignored for libtool compatibility\n");
-	printf("  --version	print version information\n");
+	printf("  --tag=TAG	 Ignored for libtool compatibility\n");
+	printf("  --version	 print version information\n");
 
 
 	printf("  --shared	 Build shared libraries when using --mode=link\n");
-	printf("  --export-all	   Try to export 'def' file on some platforms\n");
+	printf("  --show-config	 show all configuration variables\n");
+	printf("                 Or --show-config=VALUE to see just one value\n");
+	printf("  --export-all	 Try to export 'def' file on some platforms\n");
 
 	printf("\nMODE must be one of the following:\n\n");
-	printf("  compile	  compile a source file into a jlibtool object\n");
-	printf("  execute	  automatically set library path, then run a program\n");
-	printf("  install	  install libraries or executables\n");
-	printf("  link	     create a library or an executable\n");
+	printf("  compile	 compile a source file into a jlibtool object\n");
+	printf("  execute	 automatically set library path, then run a program\n");
+	printf("  install	 install libraries or executables\n");
+	printf("  link	         create a library or an executable\n");
 
 	printf("\nMODE-ARGS can be the following:\n\n");
 	printf("  -export-dynamic  accepted and ignored\n");
@@ -649,7 +650,7 @@ static int run_command(command_t *cmd, c
  * print configuration
  * shlibpath_var is used in configure.
  */
-#define printc(_x,_y) if (!value || !strcmp(value, _x)) printf(_x "=\"%s\"\n", _y)
+#define printc(_x,_y) if (!value || !*value || !strcmp(value, _x)) printf(_x "=\"%s\"\n", _y)
 
 static void print_config(char const *value)
 {
@@ -780,7 +781,7 @@ static int parse_long_opt(char const *ar
 	} else if (strcmp(var, "help") == 0) {
 		usage(0);
 
-	} else if (strcmp(var, "config") == 0) {
+	} else if (strcmp(var, "show-config") == 0) {
 		print_config(value);
 
 		exit(0);
diff -urpN freeradius-server-3.2.6/scripts/logrotate/freeradius freeradius-server-3.2.7/scripts/logrotate/freeradius
--- freeradius-server-3.2.6/scripts/logrotate/freeradius	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/scripts/logrotate/freeradius	2025-01-31 18:42:21.000000000 +0700
@@ -41,8 +41,10 @@
 # There are different detail-rotating strategies you can use.  One is
 # to write to a single detail file per IP and use the rotate config
 # below.  Another is to write to a daily detail file per IP with:
-#     detailfile = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
-# (or similar) in radiusd.conf, without rotation.  If you go with the
+#
+#     filename = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
+#
+#  (or similar) in mods-enabled/detail, without rotation.  If you go with the
 # second technique, you will need another cron job that removes old
 # detail files.  You do not need to comment out the below for method #2.
 /var/log/radius/radacct/*/detail {
diff -urpN freeradius-server-3.2.6/scripts/osx/debug.md freeradius-server-3.2.7/scripts/osx/debug.md
--- freeradius-server-3.2.6/scripts/osx/debug.md	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/scripts/osx/debug.md	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,38 @@
+# Debugging on OSX
+
+We assume that all of the code is in a particular path:
+
+```
+FR_PATH=$(HOME)/
+```
+
+The program has to be signed:
+
+````
+cd $(FR_PATH)
+codesign -s - -v -f --entitlements ./scripts/osx/debug.plist ./build/bin/local/radiusd
+```
+
+
+Start it up in Xcode with a full path to the executable:
+`$(FR_PATH)/build/bin/local/radiusd`.  Usually done via `open
+./build/bin/local` and then dragging the `radius` program to the file selector in Xcode.
+
+Set command-line arguments:
+
+```
+-fxx -l stdout -m -d $(FR_PATH)/raddb -D $(FR_PATH)/share
+```
+
+And environment variables.
+
+```
+DYLD_FALLBACK_LIBRARY_PATH=$(FR_PATH)/build/lib/.libs>
+FR_LIBRARY_PATH=$(FR_PATH)/build/lib/local/.libs
+```
+
+Pass signals in `lldb` directly to the program:
+
+```
+(lldb) pro hand -p true -s false SIGHUP
+```
diff -urpN freeradius-server-3.2.6/scripts/osx/debug.plist freeradius-server-3.2.7/scripts/osx/debug.plist
--- freeradius-server-3.2.6/scripts/osx/debug.plist	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/scripts/osx/debug.plist	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1 @@
+<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "https://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict><key>com.apple.security.get-task-allow</key><true/></dict></plist>
diff -urpN freeradius-server-3.2.6/share/dictionary.eleven freeradius-server-3.2.7/share/dictionary.eleven
--- freeradius-server-3.2.6/share/dictionary.eleven	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.eleven	2025-01-31 18:42:21.000000000 +0700
@@ -6,7 +6,7 @@
 #
 #	Eleven Software
 #
-#	$Id: de3921eee87336394f2fd791017c3191dca0f722 $
+#	$Id: 2f82f4a26749b9addcd70bb6e84718e78015bb98 $
 #
 ##############################################################################
 
@@ -33,21 +33,21 @@ ATTRIBUTE	Eleven-EAPOL-Frame-2			3.1	oct
 #
 #  The first EAPoL frame of the 4-way handshake.
 #
-ATTRIBUTE	Eleven-EAPOL-Anonce			2	octets
+ATTRIBUTE	Eleven-EAPOL-Anonce			3.2	octets
 
 #
 #  SSID name
 #
-ATTRIBUTE	Eleven-EAPOL-SSID			3	string
+ATTRIBUTE	Eleven-EAPOL-SSID			3.3	string
 
 #
 #  BSSID
 #
-ATTRIBUTE	Eleven-EAPOL-APMAC			4	octets
+ATTRIBUTE	Eleven-EAPOL-APMAC			3.4	octets
 
 #
 #  Wireless client MAC address.
 #
-ATTRIBUTE	Eleven-EAPOL-STMAC			5	octets
+ATTRIBUTE	Eleven-EAPOL-STMAC			3.5	octets
 
 END-VENDOR Eleven
diff -urpN freeradius-server-3.2.6/share/dictionary.freeradius freeradius-server-3.2.7/share/dictionary.freeradius
--- freeradius-server-3.2.6/share/dictionary.freeradius	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.freeradius	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 #
 #	The FreeRADIUS Vendor-Specific dictionary.
 #
-# Version:	$Id: 2d7bd9c213b96ffe81febad1d6efd1e9468ae91e $
+# Version:	$Id: 38e52801aff6378caead66694ade6071d79fe546 $
 #
 
 VENDOR		FreeRADIUS			11344
@@ -153,6 +153,9 @@ ATTRIBUTE	FreeRADIUS-EAP-FAST-Vendor-Spe
 ATTRIBUTE	FreeRADIUS-EAP-FAST-EAP-Payload		186.9	octets
 ATTRIBUTE	FreeRADIUS-EAP-FAST-Intermediate-Result	186.10	octets
 
+#
+#  PAC is not supported in RFC7170bis
+#
 ATTRIBUTE	FreeRADIUS-EAP-FAST-PAC			186.11	tlv
 ATTRIBUTE	FreeRADIUS-EAP-FAST-PAC-Key		186.11.1	octets
 
@@ -301,4 +304,7 @@ ATTRIBUTE	FreeRADIUS-Stats-Threads-Activ
 ATTRIBUTE	FreeRADIUS-Stats-Threads-Total		194	integer
 ATTRIBUTE	FreeRADIUS-Stats-Threads-Max		195	integer
 
+ATTRIBUTE	FreeRADIUS-Stats-Server-Src-IP-Address	176	ipaddr
+ATTRIBUTE	FreeRADIUS-Stats-Server-Src-IPv6-Address 177	ipaddr
+
 END-VENDOR FreeRADIUS
diff -urpN freeradius-server-3.2.6/share/dictionary.freeradius.internal freeradius-server-3.2.7/share/dictionary.freeradius.internal
--- freeradius-server-3.2.6/share/dictionary.freeradius.internal	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.freeradius.internal	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 #
 #	Non Protocol Attributes used by FreeRADIUS
 #
-#	$Id: 52b9bb8750aa04ef30c32ef335a5d7c9c6d0d92f $
+#	$Id: 82b5f7185cdb9083c3082b516d39f427093dcaf9 $
 #
 
 #	The attributes number ranges are allocates as follows:
@@ -196,6 +196,8 @@ ATTRIBUTE	FreeRADIUS-Client-Require-MA
 
 VALUE	FreeRADIUS-Client-Require-MA	no			0
 VALUE	FreeRADIUS-Client-Require-MA	yes			1
+VALUE	FreeRADIUS-Client-Require-MA	false			0
+VALUE	FreeRADIUS-Client-Require-MA	true			1
 
 ATTRIBUTE	FreeRADIUS-Client-Secret		1123	string secret
 ATTRIBUTE	FreeRADIUS-Client-Shortname		1124	string
@@ -348,6 +350,9 @@ ATTRIBUTE	EAP-Pwd-Password-Hash			1220	o
 ATTRIBUTE	EAP-Pwd-Password-Salt			1221	octets
 ATTRIBUTE	EAP-Pwd-Password-Prep			1222	byte
 
+ATTRIBUTE	TEAP-Type-Machine			1223	integer
+ATTRIBUTE	TEAP-Type-User				1224	integer
+
 #
 #	Range:	1280 - 1535
 #		EAP-type specific attributes
@@ -578,6 +583,8 @@ ATTRIBUTE	TLS-Client-Cert-X509v3-Basic-C
 ATTRIBUTE	TLS-Client-Cert-Subject-Alt-Name-Dns	1931	string
 ATTRIBUTE	TLS-Client-Cert-Subject-Alt-Name-Upn	1932	string
 ATTRIBUTE	TLS-PSK-Identity			1933	string
+ATTRIBUTE	TLS-Cert-Subject-Alt-Name-Uri		1934	string
+ATTRIBUTE	TLS-Client-Cert-Subject-Alt-Name-Uri	1935	string
 ATTRIBUTE	TLS-Client-Cert-X509v3-Extended-Key-Usage-OID 1936	string
 ATTRIBUTE	TLS-Client-Cert-Valid-Since		1937	string
 ATTRIBUTE	TLS-Cache-Method			1938	integer
@@ -586,8 +593,7 @@ VALUE	TLS-Cache-Method		load			2
 VALUE	TLS-Cache-Method		clear			3
 VALUE	TLS-Cache-Method		refresh			4
 
-
-ATTRIBUTE	TLS-Client-Cert-X509v3-Certificate-Policies	1939 string
+ATTRIBUTE	TLS-Client-Cert-X509v3-Certificate-Policies 1939	string
 
 # 1940 - 1959: reserved for TLS session caching, mostly in 4.0
 
@@ -611,6 +617,9 @@ ATTRIBUTE	TLS-Session-Cert-Private-Key-F
 
 ATTRIBUTE	TLS-Server-Name-Indication		1951	string
 
+ATTRIBUTE	TLS-Cert-CRL-Distribution-Points	1960	string
+ATTRIBUTE	TLS-Client-Cert-CRL-Distribution-Points	1961	string
+
 #
 #	Range:	1960-2099
 #		Free
@@ -898,3 +907,164 @@ VALUE	EAP-Code			Failure			4
 #
 VALUE	MS-CHAP-Use-NTLM-Auth		No			0
 VALUE	MS-CHAP-Use-NTLM-Auth		Yes			1
+
+#
+#  Copies of the above for TEAP.  In v4 we have "enum=foo" which clones
+#  a set of VALUES.  Oh well.
+#
+
+#
+#  TEAP User
+#
+VALUE	TEAP-Type-User			None			0
+VALUE	TEAP-Type-User			Identity		1
+VALUE	TEAP-Type-User			Notification		2
+VALUE	TEAP-Type-User			NAK			3
+VALUE	TEAP-Type-User			MD5-Challenge		4
+VALUE	TEAP-Type-User			EAP-MD5			4
+VALUE	TEAP-Type-User			MD5			4
+VALUE	TEAP-Type-User			One-Time-Password	5
+VALUE	TEAP-Type-User			OTP			5
+VALUE	TEAP-Type-User			Generic-Token-Card	6
+VALUE	TEAP-Type-User			EAP-GTC			6
+VALUE	TEAP-Type-User			GTC			6
+VALUE	TEAP-Type-User			RSA-Public-Key		9
+VALUE	TEAP-Type-User			DSS-Unilateral		10
+VALUE	TEAP-Type-User			KEA			11
+VALUE	TEAP-Type-User			KEA-Validate		12
+VALUE	TEAP-Type-User			EAP-TLS			13
+VALUE	TEAP-Type-User			TLS			13
+VALUE	TEAP-Type-User			Defender-Token		14
+VALUE	TEAP-Type-User			RSA-SecurID-EAP		15
+VALUE	TEAP-Type-User			Arcot-Systems-EAP	16
+VALUE	TEAP-Type-User			Cisco-LEAP		17
+VALUE	TEAP-Type-User			LEAP			17
+VALUE	TEAP-Type-User			Nokia-IP-Smart-Card	18
+VALUE	TEAP-Type-User			EAP-SIM			18
+VALUE	TEAP-Type-User			SIM			18
+VALUE	TEAP-Type-User			SRP-SHA1		19
+# 20 is unassigned
+VALUE	TEAP-Type-User			EAP-TTLS		21
+VALUE	TEAP-Type-User			TTLS			21
+VALUE	TEAP-Type-User			Remote-Access-Service	22
+VALUE	TEAP-Type-User			EAP-AKA			23
+VALUE	TEAP-Type-User			AKA			23
+VALUE	TEAP-Type-User			3Com-Wireless		24
+VALUE	TEAP-Type-User			PEAP			25
+VALUE	TEAP-Type-User			Microsoft-MS-CHAPv2	26
+VALUE	TEAP-Type-User			MAKE			27
+VALUE	TEAP-Type-User			CRYPTOCard		28
+VALUE	TEAP-Type-User			Cisco-MS-CHAPv2		29
+VALUE	TEAP-Type-User			DynamID			30
+VALUE	TEAP-Type-User			Rob-EAP			31
+VALUE	TEAP-Type-User			SecurID-EAP		32
+VALUE	TEAP-Type-User			MS-Authentication-TLV	33
+VALUE	TEAP-Type-User			SentriNET		34
+VALUE	TEAP-Type-User			Actiontec-Wireless	35
+VALUE	TEAP-Type-User			Cogent-Biomentric-EAP	36
+VALUE	TEAP-Type-User			AirFortress-EAP		37
+VALUE	TEAP-Type-User			HTTP-Digest		38
+VALUE	TEAP-Type-User			TNC			38
+VALUE	TEAP-Type-User			SecuriSuite-EAP		39
+VALUE	TEAP-Type-User			DeviceConnect-EAP	40
+VALUE	TEAP-Type-User			SPEKE			41
+VALUE	TEAP-Type-User			MOBAC			42
+VALUE	TEAP-Type-User			EAP-FAST		43
+VALUE	TEAP-Type-User			FAST			43
+VALUE	TEAP-Type-User			Zonelabs		44
+VALUE	TEAP-Type-User			Link			45
+VALUE	TEAP-Type-User			PAX			46
+VALUE	TEAP-Type-User			PSK			47
+VALUE	TEAP-Type-User			SAKE			48
+VALUE	TEAP-Type-User			EAP-IKEv2		49
+VALUE	TEAP-Type-User			IKEv2			49
+VALUE	TEAP-Type-User			AKA2			50
+VALUE	TEAP-Type-User			GPSK			51
+VALUE	TEAP-Type-User			PWD			52
+VALUE	TEAP-Type-User			EKEv1			53
+VALUE	TEAP-Type-User			PT-EAP			54
+VALUE	TEAP-Type-User			TEAP			55
+
+#
+#	And this is what most people mean by MS-CHAPv2
+#
+VALUE	TEAP-Type-User			EAP-MSCHAPv2		26
+VALUE	TEAP-Type-User			MSCHAPv2		26
+
+#
+#  TEAP Machine
+#
+VALUE	TEAP-Type-Machine		None			0
+VALUE	TEAP-Type-Machine		Identity		1
+VALUE	TEAP-Type-Machine		Notification		2
+VALUE	TEAP-Type-Machine		NAK			3
+VALUE	TEAP-Type-Machine		MD5-Challenge		4
+VALUE	TEAP-Type-Machine		EAP-MD5			4
+VALUE	TEAP-Type-Machine		MD5			4
+VALUE	TEAP-Type-Machine		One-Time-Password	5
+VALUE	TEAP-Type-Machine		OTP			5
+VALUE	TEAP-Type-Machine		Generic-Token-Card	6
+VALUE	TEAP-Type-Machine		EAP-GTC			6
+VALUE	TEAP-Type-Machine		GTC			6
+VALUE	TEAP-Type-Machine		RSA-Public-Key		9
+VALUE	TEAP-Type-Machine		DSS-Unilateral		10
+VALUE	TEAP-Type-Machine		KEA			11
+VALUE	TEAP-Type-Machine		KEA-Validate		12
+VALUE	TEAP-Type-Machine		EAP-TLS			13
+VALUE	TEAP-Type-Machine		TLS			13
+VALUE	TEAP-Type-Machine		Defender-Token		14
+VALUE	TEAP-Type-Machine		RSA-SecurID-EAP		15
+VALUE	TEAP-Type-Machine		Arcot-Systems-EAP	16
+VALUE	TEAP-Type-Machine		Cisco-LEAP		17
+VALUE	TEAP-Type-Machine		LEAP			17
+VALUE	TEAP-Type-Machine		Nokia-IP-Smart-Card	18
+VALUE	TEAP-Type-Machine		EAP-SIM			18
+VALUE	TEAP-Type-Machine		SIM			18
+VALUE	TEAP-Type-Machine		SRP-SHA1		19
+# 20 is unassigned
+VALUE	TEAP-Type-Machine		EAP-TTLS		21
+VALUE	TEAP-Type-Machine		TTLS			21
+VALUE	TEAP-Type-Machine		Remote-Access-Service	22
+VALUE	TEAP-Type-Machine		EAP-AKA			23
+VALUE	TEAP-Type-Machine		AKA			23
+VALUE	TEAP-Type-Machine		3Com-Wireless		24
+VALUE	TEAP-Type-Machine		PEAP			25
+VALUE	TEAP-Type-Machine		Microsoft-MS-CHAPv2	26
+VALUE	TEAP-Type-Machine		MAKE			27
+VALUE	TEAP-Type-Machine		CRYPTOCard		28
+VALUE	TEAP-Type-Machine		Cisco-MS-CHAPv2		29
+VALUE	TEAP-Type-Machine		DynamID			30
+VALUE	TEAP-Type-Machine		Rob-EAP			31
+VALUE	TEAP-Type-Machine		SecurID-EAP		32
+VALUE	TEAP-Type-Machine		MS-Authentication-TLV	33
+VALUE	TEAP-Type-Machine		SentriNET		34
+VALUE	TEAP-Type-Machine		Actiontec-Wireless	35
+VALUE	TEAP-Type-Machine		Cogent-Biomentric-EAP	36
+VALUE	TEAP-Type-Machine		AirFortress-EAP		37
+VALUE	TEAP-Type-Machine		HTTP-Digest		38
+VALUE	TEAP-Type-Machine		TNC			38
+VALUE	TEAP-Type-Machine		SecuriSuite-EAP		39
+VALUE	TEAP-Type-Machine		DeviceConnect-EAP	40
+VALUE	TEAP-Type-Machine		SPEKE			41
+VALUE	TEAP-Type-Machine		MOBAC			42
+VALUE	TEAP-Type-Machine		EAP-FAST		43
+VALUE	TEAP-Type-Machine		FAST			43
+VALUE	TEAP-Type-Machine		Zonelabs		44
+VALUE	TEAP-Type-Machine		Link			45
+VALUE	TEAP-Type-Machine		PAX			46
+VALUE	TEAP-Type-Machine		PSK			47
+VALUE	TEAP-Type-Machine		SAKE			48
+VALUE	TEAP-Type-Machine		EAP-IKEv2		49
+VALUE	TEAP-Type-Machine		IKEv2			49
+VALUE	TEAP-Type-Machine		AKA2			50
+VALUE	TEAP-Type-Machine		GPSK			51
+VALUE	TEAP-Type-Machine		PWD			52
+VALUE	TEAP-Type-Machine		EKEv1			53
+VALUE	TEAP-Type-Machine		PT-EAP			54
+VALUE	TEAP-Type-Machine		TEAP			55
+
+#
+#	And this is what most people mean by MS-CHAPv2
+#
+VALUE	TEAP-Type-Machine		EAP-MSCHAPv2		26
+VALUE	TEAP-Type-Machine		MSCHAPv2		26
diff -urpN freeradius-server-3.2.6/share/dictionary.h3c freeradius-server-3.2.7/share/dictionary.h3c
--- freeradius-server-3.2.6/share/dictionary.h3c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.h3c	2025-01-31 18:42:21.000000000 +0700
@@ -8,7 +8,7 @@
 #
 #	http://www.h3c.com
 #
-#	$Id: be9eeee0919af69942c7048075e081c96b65a8d5 $
+#	$Id: 228ed8cd74df70d06ee2b5fb725d66f29231c26b $
 #
 ##############################################################################
 
@@ -69,8 +69,8 @@ ATTRIBUTE	H3C-Acct-IPv6-Input-Octets		14
 ATTRIBUTE	H3C-Acct-IPv6-Output-Octets		145	integer
 ATTRIBUTE	H3C-Acct-IPv6-Input-Packets		146	integer
 ATTRIBUTE	H3C-Acct-IPv6-Output-Packets		147	integer
-ATTRIBUTE	H3C-Acct-IPv6-Input-Gigawords		146	integer
-ATTRIBUTE	H3C-Acct-IPv6-Output-Gigawords		147	integer
+ATTRIBUTE	H3C-Acct-IPv6-Input-Gigawords		148	integer
+ATTRIBUTE	H3C-Acct-IPv6-Output-Gigawords		149	integer
 ATTRIBUTE	H3C-User-Role				155	string
 ATTRIBUTE	H3C-Input-Interval-Octets		201	integer
 ATTRIBUTE	H3C-Output-Interval-Octets		202	integer
diff -urpN freeradius-server-3.2.6/share/dictionary.huawei.v2 freeradius-server-3.2.7/share/dictionary.huawei.v2
--- freeradius-server-3.2.6/share/dictionary.huawei.v2	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.huawei.v2	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,254 @@
+# -*- text -*-
+# Copyright (C) 2019 The FreeRADIUS Server project and contributors
+# This work is licensed under CC-BY version 4.0 https://creativecommons.org/licenses/by/4.0
+#
+##############################################################################
+#
+#	Dictionary for Huawe devices S1720, S2700, S5700, and S6720 V200R011C10
+#
+#	$Id: 8cebe653ec636563ddd36477485dad3a1073dbb6 $
+#
+#  https://support.huawei.com/enterprise/en/doc/EDOC1000178178/35071f9a/radius-aaa
+#
+##############################################################################
+
+VENDOR		Huawei				2011
+
+BEGIN-VENDOR	Huawei
+
+ATTRIBUTE	Huawei-Input-Peak-Information-Rate	1	integer
+ATTRIBUTE	Huawei-Input-Committed-Information-Rate	2	integer
+ATTRIBUTE	Huawei-Input-Committed-Burst-Size	3	integer
+ATTRIBUTE	Huawei-Output-Peak-Information-Rate	4	integer
+ATTRIBUTE	Huawei-Output-Committed-Information-Rate 5	integer
+ATTRIBUTE	Huawei-Output-Committed-Burst-Size	6	integer
+ATTRIBUTE	Huawei-In-Kb-Before-T-Switch		7	integer
+ATTRIBUTE	Huawei-Out-Kb-Before-T-Switch		8	integer
+ATTRIBUTE	Huawei-In-Pkt-Before-T-Switch		9	integer
+ATTRIBUTE	Huawei-Out-Pkt-Before-T-Switch		10	integer
+ATTRIBUTE	Huawei-In-Kb-After-T-Switch		11	integer
+ATTRIBUTE	Huawei-Out-Kb-After-T-Switch		12	integer
+ATTRIBUTE	Huawei-In-Pkt-After-T-Switch		13	integer
+ATTRIBUTE	Huawei-Out-Pkt-After-T-Switch		14	integer
+ATTRIBUTE	Huawei-Remanent-Volume			15	integer
+ATTRIBUTE	Huawei-Tariff-Switch-Interval		16	integer
+ATTRIBUTE	Huawei-Subscriber-QoS-Profile		17	string
+ATTRIBUTE	Huawei-Max-Users-Per-Logic-Port		18	integer
+ATTRIBUTE	Huawei-Command				20	integer
+ATTRIBUTE	Huawei-Priority				22	integer
+ATTRIBUTE	Huawei-Control-Identifier		24	integer
+
+ATTRIBUTE	Huawei-Result-Code			25	integer
+
+# > 0 indicates an error.
+VALUE	Huawei-Result-Code		Succeeded		0
+
+ATTRIBUTE	Huawei-Connect-ID			26	integer
+ATTRIBUTE	Huawei-PortalURL			27	string
+ATTRIBUTE	Huawei-FTP-Directory			28	string
+ATTRIBUTE	Huawei-Exec-Privilege			29	integer
+ATTRIBUTE	Huawei-IP-Address			30	integer
+ATTRIBUTE	Huawei-Qos-Data				31	string
+ATTRIBUTE	Huawei-SIP-Server			32	string
+ATTRIBUTE	Huawei-VoiceVlan			33	integer
+ATTRIBUTE	Huawei-Command-Mode			34	string
+ATTRIBUTE	Huawei-ProxyRdsPkt			35	integer
+ATTRIBUTE	Huawei-Rebinding-Time			36	integer
+ATTRIBUTE	Huawei-IGMP-Enable			37	integer
+ATTRIBUTE	Huawei-Destnation-IP-Addr		39	string
+ATTRIBUTE	Huawei-Destnation-Volume		40	string
+ATTRIBUTE	Huawei-NAS-Startup-Time-Stamp		59	integer
+ATTRIBUTE	Huawei-IP-Host-Address			60	string
+ATTRIBUTE	Huawei-Up-Priority			61	integer
+ATTRIBUTE	Huawei-Down-Priority			62	integer
+ATTRIBUTE	Huawei-Tunnel-VPN-Instance		63	string
+ATTRIBUTE	Huawei-VT-Name				64	integer
+ATTRIBUTE	Huawei-User-Date			65	string
+ATTRIBUTE	Huawei-User-Class			66	string
+ATTRIBUTE	Huawei-PPP-NCP-Type			70	integer
+ATTRIBUTE	Huawei-VSI-Name				71	string
+ATTRIBUTE	Huawei-Subnet-Mask			72	ipaddr
+ATTRIBUTE	Huawei-Gateway-Address			73	ipaddr
+ATTRIBUTE	Huawei-Lease-Time			74	integer
+ATTRIBUTE	Huawei-Primary-WINS			75	ipaddr
+ATTRIBUTE	Huawei-Second-WINS			76	ipaddr
+ATTRIBUTE	Huawei-Input-Peak-Burst-Size		77	integer
+ATTRIBUTE	Huawei-Output-Peak-Burst-Size		78	integer
+ATTRIBUTE	Huawei-Reduced-CIR			79	integer
+ATTRIBUTE	Huawei-Tunnel-Session-Limit		80	integer
+ATTRIBUTE	Huawei-Zone-Name			81	string
+ATTRIBUTE	Huawei-Data-Filter			82	string
+ATTRIBUTE	Huawei-Access-Service			83	string
+ATTRIBUTE	Huawei-Accounting-Level			84	integer
+ATTRIBUTE	Huawei-Portal-Mode			85	integer
+
+VALUE	Huawei-Portal-Mode		PADM			0
+VALUE	Huawei-Portal-Mode		Redirectional		1
+VALUE	Huawei-Portal-Mode		Non-captive		2
+
+ATTRIBUTE	Huawei-DPI-Policy-Name			86	string
+ATTRIBUTE	huawei-Policy-Route			87	ipaddr
+ATTRIBUTE	Huawei-Framed-Pool			88	string
+ATTRIBUTE	Huawei-L2TP-Terminate-Cause		89	string
+ATTRIBUTE	Huawei-Multi-Account-Mode		90	integer
+ATTRIBUTE	Huawei-Queue-Profile			91	string
+ATTRIBUTE	Huawei-Layer4-Session-Limit		92	integer
+ATTRIBUTE	Huawei-Multicast-Profile		93	string
+ATTRIBUTE	Huawei-VPN-Instance			94	string
+ATTRIBUTE	Huawei-Policy-Name			95	string
+ATTRIBUTE	Huawei-Tunnel-Group-Name		96	string
+ATTRIBUTE	Huawei-Multicast-Source-Group		97	string
+ATTRIBUTE	Huawei-Multicast-Receive-Group		98	ipaddr
+ATTRIBUTE	Huawei-User-Multicast-Type		99	integer
+ATTRIBUTE	Huawei-Reduced-PIR			100	integer
+ATTRIBUTE	Huawei-LI-ID				101	string
+ATTRIBUTE	Huawei-LI-Md-Address			102	ipaddr
+ATTRIBUTE	Huawei-LI-Md-Port			103	integer
+ATTRIBUTE	Huawei-LI-Md-VpnInstance		104	string
+ATTRIBUTE	Huawei-Service-Chg-Cmd			105	integer
+ATTRIBUTE	Huawei-Acct-Packet-Type			106	integer
+ATTRIBUTE	Huawei-Call-Reference			107	integer
+ATTRIBUTE	Huawei-PSTN-Port			108	integer
+ATTRIBUTE	Huawei-Voip-Service-Type		109	integer
+ATTRIBUTE	Huawei-Acct-Connection-Time		110	integer
+ATTRIBUTE	Huawei-Error-Reason			112	integer
+ATTRIBUTE	Huawei-Remain-Monney			113	integer
+ATTRIBUTE	Huawei-Org-GK-ipaddr			123	ipaddr
+ATTRIBUTE	Huawei-Org-GW-ipaddr			124	ipaddr
+ATTRIBUTE	Huawei-Dst-GK-ipaddr			125	ipaddr
+ATTRIBUTE	Huawei-Dst-GW-ipaddr			126	ipaddr
+ATTRIBUTE	Huawei-Access-Num			127	string
+ATTRIBUTE	Huawei-Remain-Time			128	integer
+ATTRIBUTE	Huawei-Codec-Type			131	integer
+ATTRIBUTE	Huawei-Transfer-Num			132	string
+ATTRIBUTE	Huawei-New-User-Name			133	string
+ATTRIBUTE	Huawei-Transfer-Station-Id		134	string
+ATTRIBUTE	Huawei-Client-Primary-DNS		135	ipaddr
+ATTRIBUTE	Huawei-Client-Secondary-DNS		136	ipaddr
+ATTRIBUTE	Huawei-ONLY-Account-Type		137	integer
+ATTRIBUTE	Huawei-Domain-Name			138	string
+ATTRIBUTE	Huawei-ANCP-Profile			139	string
+ATTRIBUTE	Huawei-HTTP-Redirect-URL		140	string
+ATTRIBUTE	Huawei-AP-Information			141	string
+ATTRIBUTE	Huawei-User-Information			142	string
+
+VALUE	Huawei-QoS-Profile-Type		Original		0
+VALUE	Huawei-QoS-Profile-Type		L2TP-Inbound		1
+VALUE	Huawei-QoS-Profile-Type		L2TP-Outbound		2
+VALUE	Huawei-QoS-Profile-Type		L2TP			3
+
+ATTRIBUTE	Huawei-Max-List-Num			143	integer
+ATTRIBUTE	Huawei-Acct-IPv6-Input-Octets		144	integer
+ATTRIBUTE	Huawei-Acct-IPv6-Output-Octets		145	integer
+ATTRIBUTE	Huawei-Service-Scheme			146	string
+ATTRIBUTE	Huawei-Acct-IPv6-Output-Packets		147	integer
+ATTRIBUTE	Huawei-Acct-IPv6-Input-Gigawords	148	integer
+ATTRIBUTE	Huawei-Acct-IPv6-Output-Gigawords	149	integer
+ATTRIBUTE	Huawei-DHCPv6-Option37			150	string
+ATTRIBUTE	Huawei-DHCPv6-Option38			151	string
+ATTRIBUTE	Huawei-Access-Type			153	integer
+ATTRIBUTE	Huawei-DNS-Server-IPv6-address		154	ipv6addr
+ATTRIBUTE	Huawei-URL-Flag				155	integer
+ATTRIBUTE	Huawei-Portal-UR			156	string
+ATTRIBUTE	Huawei-Terminal-Type			157	string
+ATTRIBUTE	Huawei-DHCP-Option			158	string
+ATTRIBUTE	Huawei-Acct-Update-Address		159	integer
+ATTRIBUTE	Huawei-UCL-Group			160	integer
+ATTRIBUTE	Huawei-Forwarding-VLAN			161	string
+ATTRIBUTE	Huawei-Forwarding-Interface		162	string
+ATTRIBUTE	Huawei-LLDP				163	string
+ATTRIBUTE	Huawei-NAT-Port-Forwarding		164	integer
+ATTRIBUTE	Huawei-NAT-Port-Range-Update		165	integer
+ATTRIBUTE	Huawei-DS-Lite-Tunnel-Name		166	string
+ATTRIBUTE	Huawei-PCP-Server-Name			167	string # manual says text?
+ATTRIBUTE	Huawei-Public-IP-Addr-State		168	integer
+ATTRIBUTE	Huawei-Redirect-ACL			173	string
+
+VALUE	Huawei-Public-IP-Addr-State	Safe			0
+VALUE	Huawei-Public-IP-Addr-State	Warning			1
+VALUE	Huawei-Public-IP-Addr-State	Danger			2
+
+ATTRIBUTE	Huawei-Auth-Type			180	integer
+
+VALUE	Huawei-Auth-Type		PPP			1
+VALUE	Huawei-Auth-Type		Web			2
+VALUE	Huawei-Auth-Type		Dot1x			3
+VALUE	Huawei-Auth-Type		Fast			4
+VALUE	Huawei-Auth-Type		Bind			5
+VALUE	Huawei-Auth-Type		WLAN			6
+VALUE	Huawei-Auth-Type		Administrative		7
+VALUE	Huawei-Auth-Type		Tunnel			8
+VALUE	Huawei-Auth-Type		MIP			9
+VALUE	Huawei-Auth-Type		None			10
+
+ATTRIBUTE	Huawei-Acct-Terminate-Subcause		181	string
+ATTRIBUTE	Huawei-Down-QOS-Profile-Name		182	string
+ATTRIBUTE	Huawei-Port-Mirror			183	integer
+
+VALUE	Huawei-Port-Mirror		Disable			0
+VALUE	Huawei-Port-Mirror		Uplink-Enable		1
+VALUE	Huawei-Port-Mirror		Downlink-Enable		2
+VALUE	Huawei-Port-Mirror		Enable			3
+
+ATTRIBUTE	Huawei-Account-Info			184	string
+ATTRIBUTE	Huawei-Service-Info			185	string
+ATTRIBUTE	Huawei-DHCP-Option			187	octets
+ATTRIBUTE	Huawei-AVpair				188	string
+ATTRIBUTE	Huawei-Delegated-IPv6-Prefix-Pool	191	string
+ATTRIBUTE	Huawei-IPv6-Prefix-Lease		192	octets
+ATTRIBUTE	Huawei-IPv6-Address-Lease		193	octets
+ATTRIBUTE	Huawei-IPv6-Policy-Route		194	ipv6prefix # manual says string?
+ATTRIBUTE	Huawei-MNG-IPv6				196	integer
+ATTRIBUTE	Huawei-User-Extend-Info			201	string
+
+VALUE	Huawei-MNG-IPv6			Unsupported		0
+VALUE	Huawei-MNG-IPv6			Supported		1
+
+#
+#  Huawei supports supplying a DPSK by setting the Attribute	Huawei-DPSK-Info
+#
+#  https://support.huawei.com/hedex/hdx.do?docid=EDOC1100192518&id=EN-US_CONCEPT_0277881327
+#
+
+ATTRIBUTE	Huawei-DPSK-Info			206	string
+
+ATTRIBUTE	Huawei-Flow-Info			211	string
+ATTRIBUTE	Huawei-Flow-Id				212	integer
+ATTRIBUTE	Huawei-DHCP-Server-IP			214	ipaddr
+ATTRIBUTE	Huawei-Application-Type			215	integer
+
+VALUE	Huawei-Application-Type		Fixed			1
+VALUE	Huawei-Application-Type		Nomadic			2
+VALUE	Huawei-Application-Type		Portable		3
+VALUE	Huawei-Application-Type		Simple-Mobile		4
+VALUE	Huawei-Application-Type		Full-Mobile		5
+
+ATTRIBUTE	Huawei-Indication-Flag			216	octets # integer??
+ATTRIBUTE	Huawei-Original_NAS-IP_Address		217	ipaddr
+ATTRIBUTE	Huawei-User-Priority			218	integer
+
+VALUE	Huawei-User-Priority		Common			0
+VALUE	Huawei-User-Priority		Copper			1
+VALUE	Huawei-User-Priority		Silver			2
+VALUE	Huawei-User-Priority		Gold			3
+
+ATTRIBUTE	Huawei-ACS-Url				219	string
+ATTRIBUTE	Huawei-Provision-Code			220	string
+ATTRIBUTE	Huawei-Application-Scene		221	octets
+ATTRIBUTE	Huawei-MS-Maximum-MAC-Study-Number	222	octets # ether??
+ATTRIBUTE	Huawei-GGSN-Vendor			232	string
+ATTRIBUTE	Huawei-GGSN-Version			233	string
+ATTRIBUTE	Huawei-Web-Authen-Info			237	string
+ATTRIBUTE	Huawei-Ext-Specific			238	string
+ATTRIBUTE	Huawei-User-Access-Info			239	string
+ATTRIBUTE	Huawei-Access-Device-Info		240	string
+ATTRIBUTE	Huawei-Reachable-Detect			244	string
+ATTRIBUTE	Huawei-Tariff-Input-Octets		247	string
+ATTRIBUTE	Huawei-Tariff-Output-Octets		248	string
+ATTRIBUTE	Huawei-Tariff-Input-Gigawords		249	string
+ATTRIBUTE	Huawei-Tariff-Output-Gigawords		250	string
+ATTRIBUTE	Huawei-Framed-IPv6-Address		253	ipv6addr
+ATTRIBUTE	Huawei-Version				254	string
+ATTRIBUTE	Huawei-Product-ID			255	string
+
+END-VENDOR	Huawei
diff -urpN freeradius-server-3.2.6/share/dictionary.juniper freeradius-server-3.2.7/share/dictionary.juniper
--- freeradius-server-3.2.6/share/dictionary.juniper	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.juniper	2025-01-31 18:42:21.000000000 +0700
@@ -6,7 +6,7 @@
 #
 #	As posted to the list by Eric Kilfoil <ekilfoil@uslec.net>
 #
-# Version:	$Id: 15b6e6f90da6beeb6684f7a62cf0afda543e58b7 $
+# Version:	$Id: 30b256ecd4d5c0f9a7839abe471ef1097b8c67eb $
 #
 
 VENDOR		Juniper				2636
@@ -22,8 +22,8 @@ ATTRIBUTE	Juniper-Deny-Configuration		5
 ATTRIBUTE	Juniper-Interactive-Command		8	string
 ATTRIBUTE	Juniper-Configuration-Change		9	string
 ATTRIBUTE	Juniper-User-Permissions		10	string
-ATTRIBUTE	Juniper-Junosspace-Profile		11	String
-ATTRIBUTE	Juniper-Junosspace-Profiles		11	String
+ATTRIBUTE	Juniper-Junosspace-Profile		11	string
+ATTRIBUTE	Juniper-Junosspace-Profiles		11	string
 
 ATTRIBUTE	Juniper-CTP-Group			21	integer
 ATTRIBUTE	Juniper-CTPView-APP-Group		22	integer
diff -urpN freeradius-server-3.2.6/share/dictionary.zte freeradius-server-3.2.7/share/dictionary.zte
--- freeradius-server-3.2.6/share/dictionary.zte	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/share/dictionary.zte	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 #
 #       For ZTE.
 #
-#       $Id: 9ee7472dadba6b2c07ff2ca01f6746a544167bdc $
+#       $Id: fb954745054145d72eeb0a6ce32d30a6e7e31166 $
 #
 # QoS attributes Mostly derived from:
 # http://wwwen.zte.com.cn/en/products/bearer/201308/P020130828522349526032.pdf
@@ -12,8 +12,8 @@
 VENDOR		ZTE				3902
 BEGIN-VENDOR	ZTE
 
-ATTRIBUTE	ZTE-Client-DNS-Pri			1	string
-ATTRIBUTE	ZTE-Client-DNS-Sec			2	string
+ATTRIBUTE	ZTE-Client-DNS-Pri			1	ipaddr
+ATTRIBUTE	ZTE-Client-DNS-Sec			2	ipaddr
 ATTRIBUTE	ZTE-Context-Name			4	integer
 ATTRIBUTE	ZTE-Tunnel-Max-Sessions			21	integer
 ATTRIBUTE	ZTE-Tunnel-Max-Tunnels			22	integer
diff -urpN freeradius-server-3.2.6/src/include/clients.h freeradius-server-3.2.7/src/include/clients.h
--- freeradius-server-3.2.6/src/include/clients.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/clients.h	2025-01-31 18:42:21.000000000 +0700
@@ -17,7 +17,7 @@
 #ifndef CLIENTS_H
 #define CLIENTS_H
 /*
- * $Id: 7e962b6797ed165189bfb7b1e06bfc2700ccdaef $
+ * $Id: 5ebca8a2a69bd639bb49b77dddefdd0fe35021ab $
  *
  * @file clients.h
  * @brief Function declarations and structures to manage clients.
@@ -79,7 +79,7 @@ typedef struct radclient {
 #endif
 #ifdef WITH_TLS
 	bool			tls_required;		//!< whether TLS encryption is required.
-
+	fr_tls_server_conf_t	*tls;
 #ifdef WITH_RADIUSV11
 	char const		*radiusv11_name;
 	fr_radiusv11_t 		radiusv11;
diff -urpN freeradius-server-3.2.6/src/include/conffile.h freeradius-server-3.2.7/src/include/conffile.h
--- freeradius-server-3.2.6/src/include/conffile.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/conffile.h	2025-01-31 18:42:21.000000000 +0700
@@ -4,11 +4,11 @@
 /*
  * conffile.h	Defines for the conffile parsing routines.
  *
- * Version:	$Id: 237469c880603666a5975d8c4699af35ca81a7d8 $
+ * Version:	$Id: fb3dd80597045202c5603aa21257a787811809f5 $
  *
  */
 
-RCSIDH(conffile_h, "$Id: 237469c880603666a5975d8c4699af35ca81a7d8 $")
+RCSIDH(conffile_h, "$Id: fb3dd80597045202c5603aa21257a787811809f5 $")
 
 #include <stddef.h>
 #include <freeradius-devel/token.h>
@@ -300,6 +300,10 @@ int cf_file_changed(CONF_SECTION *cs, rb
 extern CONF_SECTION *root_config;
 extern bool cf_new_escape;
 
+
+void cf_md5_init(void);
+void cf_md5_final(uint8_t *digest);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN freeradius-server-3.2.6/src/include/libradius.h freeradius-server-3.2.7/src/include/libradius.h
--- freeradius-server-3.2.6/src/include/libradius.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/libradius.h	2025-01-31 18:42:21.000000000 +0700
@@ -16,14 +16,14 @@
 #ifndef LIBRADIUS_H
 #define LIBRADIUS_H
 /*
- * $Id: 4dda31ced645438d4c2de1a5d7f47f860dc220d3 $
+ * $Id: d3a47815847652873076bc7e25f1e0e0fcc2371d $
  *
  * @file libradius.h
  * @brief Structures and prototypes for the radius library.
  *
  * @copyright 1999-2014 The FreeRADIUS server project
  */
-RCSIDH(libradius_h, "$Id: 4dda31ced645438d4c2de1a5d7f47f860dc220d3 $")
+RCSIDH(libradius_h, "$Id: d3a47815847652873076bc7e25f1e0e0fcc2371d $")
 
 /*
  *  Compiler hinting macros.  Included here for 3rd party consumers
@@ -257,8 +257,7 @@ typedef union value_data {
 	uint32_t		integer;			//!< 32bit unsigned integer.
 	struct in_addr		ipaddr;				//!< IPv4 Address.
 	uint32_t		date;				//!< Date (32bit Unix timestamp).
-	size_t			filter[32/sizeof(size_t)];	//!< Ascend binary format a packed data
-								//!< structure.
+	uint8_t			*filter;			//!< ascend data filter
 
 	uint8_t			ifid[8];			//!< IPv6 interface ID (should be struct?).
 	struct in6_addr		ipv6addr;			//!< IPv6 Address.
@@ -647,6 +646,7 @@ VALUE_PAIR	*fr_cursor_remove(vp_cursor_t
 VALUE_PAIR	*fr_cursor_replace(vp_cursor_t *cursor, VALUE_PAIR *new);
 void		fr_pair_delete_by_num(VALUE_PAIR **, unsigned int attr, unsigned int vendor, int8_t tag);
 void		fr_pair_delete_by_da(VALUE_PAIR **first, DICT_ATTR const *da);
+void		fr_pair_delete(VALUE_PAIR **first, VALUE_PAIR *vp);
 void		fr_pair_add(VALUE_PAIR **, VALUE_PAIR *);
 void		fr_pair_prepend(VALUE_PAIR **, VALUE_PAIR *);
 void		fr_pair_replace(VALUE_PAIR **first, VALUE_PAIR *add);
@@ -807,7 +807,7 @@ void		fr_talloc_verify_cb(const void *pt
 
 #ifdef WITH_ASCEND_BINARY
 /* filters.c */
-int		ascend_parse_filter(value_data_t *out, char const *value, size_t len);
+int		ascend_parse_filter(TALLOC_CTX *ctx, value_data_t *out, char const *value, size_t len);
 void		print_abinary(char *out, size_t outlen, uint8_t const *data, size_t len, int8_t quote);
 #endif /*WITH_ASCEND_BINARY*/
 
@@ -958,6 +958,7 @@ int		fr_fifo_push(fr_fifo_t *fi, void *d
 void		*fr_fifo_pop(fr_fifo_t *fi);
 void		*fr_fifo_peek(fr_fifo_t *fi);
 unsigned int	fr_fifo_num_elements(fr_fifo_t *fi);
+bool		fr_fifo_full(fr_fifo_t *fi);
 
 /*
  *	socket.c
diff -urpN freeradius-server-3.2.6/src/include/listen.h freeradius-server-3.2.7/src/include/listen.h
--- freeradius-server-3.2.6/src/include/listen.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/listen.h	2025-01-31 18:42:21.000000000 +0700
@@ -16,7 +16,7 @@
 #ifndef LISTEN_H
 #define LISTEN_H
 /**
- * $Id: 15d00d1ba1a80c2fa33b5d2b5052d7008cc793d2 $
+ * $Id: 1c57512caaa42a6c31f2494f0fcb274f86cfd8c9 $
  *
  * @file listen.h
  * @brief The listener API.
@@ -43,13 +43,13 @@ typedef enum RAD_LISTEN_TYPE {
 } RAD_LISTEN_TYPE;
 
 typedef enum RAD_LISTEN_STATUS {
-	RAD_LISTEN_STATUS_INIT = 0,
-	RAD_LISTEN_STATUS_KNOWN,
-	RAD_LISTEN_STATUS_PAUSE,
-	RAD_LISTEN_STATUS_RESUME,
-	RAD_LISTEN_STATUS_FROZEN,
-	RAD_LISTEN_STATUS_EOL,
-	RAD_LISTEN_STATUS_REMOVE_NOW
+	RAD_LISTEN_STATUS_INIT = 0,		//!< starting up
+	RAD_LISTEN_STATUS_KNOWN,		//!< alive and operating normally
+	RAD_LISTEN_STATUS_PAUSE,		//!< TLS connection checking: don't read normal packets
+	RAD_LISTEN_STATUS_RESUME,		//!< TLS connection checking: resume reading normal packets
+	RAD_LISTEN_STATUS_FROZEN,		//!< alive, but we're not sending any more packets to it
+	RAD_LISTEN_STATUS_EOL,			//!< we're trying to delete it.
+	RAD_LISTEN_STATUS_REMOVE_NOW		//!< no request is using it, delete the listener.
 } RAD_LISTEN_STATUS;
 
 typedef struct rad_listen rad_listen_t;
@@ -196,6 +196,8 @@ typedef struct listen_socket_t {
 		LISTEN_TLS_RUNNING,
 	} state;
 
+	bool		client_closed;
+
 #ifdef WITH_RADIUSV11
 	bool		alpn_checked;
 	bool		radiusv11;		//!< defaults to "no"!
diff -urpN freeradius-server-3.2.6/src/include/radiusd.h freeradius-server-3.2.7/src/include/radiusd.h
--- freeradius-server-3.2.6/src/include/radiusd.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/radiusd.h	2025-01-31 18:42:21.000000000 +0700
@@ -16,7 +16,7 @@
 #ifndef RADIUSD_H
 #define RADIUSD_H
 /**
- * $Id: ec69b8d4e096bef619e3541bb500744a6644abbd $
+ * $Id: da7a6b8421fbaed9baebcca46c6cdb114022e9b7 $
  *
  * @file radiusd.h
  * @brief Structures, prototypes and global variables for the FreeRADIUS server.
@@ -24,7 +24,7 @@
  * @copyright 1999-2000,2002-2008  The FreeRADIUS server project
  */
 
-RCSIDH(radiusd_h, "$Id: ec69b8d4e096bef619e3541bb500744a6644abbd $")
+RCSIDH(radiusd_h, "$Id: da7a6b8421fbaed9baebcca46c6cdb114022e9b7 $")
 
 #include <freeradius-devel/libradius.h>
 #include <freeradius-devel/radpaths.h>
@@ -183,6 +183,9 @@ typedef struct main_config {
 #ifdef ENABLE_OPENSSL_VERSION_CHECK
 	char const	*allow_vulnerable_openssl;	//!< The CVE number of the last security issue acknowledged.
 #endif
+
+	bool		group_stop_return;		//!< "return" stops at end of group
+	bool		policy_stop_return;		//!< "return" stops at end of policy
 } main_config_t;
 
 #if defined(WITH_VERIFY_PTR)
@@ -199,6 +202,7 @@ typedef struct main_config {
 typedef enum {
 	REQUEST_ACTIVE = 1,
 	REQUEST_STOP_PROCESSING,
+	REQUEST_TO_FREE,			//!< in the queue, and the queue should free it
 } rad_master_state_t;
 #define REQUEST_MASTER_NUM_STATES (REQUEST_STOP_PROCESSING + 1)
 
@@ -284,6 +288,7 @@ struct rad_request {
 	bool			max_time;	//!< did we hit max time?
 
 	bool			in_request_hash;
+	bool			eap_inner_tunnel;
 #ifdef WITH_PROXY
 	bool			in_proxy_hash;
 
@@ -544,6 +549,7 @@ int radius_copy_vp(TALLOC_CTX *ctx, VALU
 /* threads.c */
 int	thread_pool_init(CONF_SECTION *cs, bool *spawn_flag);
 void	thread_pool_stop(void);
+void	thread_pool_free(void);
 int	thread_pool_addrequest(REQUEST *, RAD_REQUEST_FUNP);
 pid_t	rad_fork(void);
 pid_t	rad_waitpid(pid_t pid, int *status);
diff -urpN freeradius-server-3.2.6/src/include/realms.h freeradius-server-3.2.7/src/include/realms.h
--- freeradius-server-3.2.6/src/include/realms.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/realms.h	2025-01-31 18:42:21.000000000 +0700
@@ -5,11 +5,11 @@
  * realms.h	Structures, prototypes and global variables
  *		for realms
  *
- * Version:	$Id: cc5d4c147b6dbb2db2aa618fe0ff89ae991c93ef $
+ * Version:	$Id: 1085e23d272d131b25b4e670c1b3d2790f12f88f $
  *
  */
 
-RCSIDH(realms_h, "$Id: cc5d4c147b6dbb2db2aa618fe0ff89ae991c93ef $")
+RCSIDH(realms_h, "$Id: 1085e23d272d131b25b4e670c1b3d2790f12f88f $")
 
 #ifdef __cplusplus
 extern "C" {
@@ -230,7 +230,8 @@ home_server_t	*home_server_bynumber(int
 home_pool_t	*home_pool_byname(char const *name, int type);
 
 int		home_server_afrom_file(char const *filename);
-int		home_server_delete(char const *name, char const *type);
+int		home_server_delete_byname(char const *name, char const *type);
+int		home_server_delete(home_server_t *home);
 
 #ifdef __cplusplus
 }
diff -urpN freeradius-server-3.2.6/src/include/stats.h freeradius-server-3.2.7/src/include/stats.h
--- freeradius-server-3.2.6/src/include/stats.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/stats.h	2025-01-31 18:42:21.000000000 +0700
@@ -4,7 +4,7 @@
 /*
  * stats.h	Structures and functions for statistics.
  *
- * Version:	$Id: 68903f93497fb4f469d40ce440b9eb7c3eba15c8 $
+ * Version:	$Id: 482d3f383644ea408d76f4dc6b8b7b9b79bc050a $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -23,7 +23,7 @@
  * Copyright 2005,2006,2007,2008  The FreeRADIUS server project
  */
 
-RCSIDH(stats_h, "$Id: 68903f93497fb4f469d40ce440b9eb7c3eba15c8 $")
+RCSIDH(stats_h, "$Id: 482d3f383644ea408d76f4dc6b8b7b9b79bc050a $")
 
 #ifdef __cplusplus
 extern "C" {
@@ -82,7 +82,8 @@ void request_stats_reply(REQUEST *reques
 void radius_stats_ema(fr_stats_ema_t *ema,
 		      struct timeval *start, struct timeval *end);
 
-#define FR_STATS_INC(_x, _y) radius_ ## _x ## _stats._y++;if (listener) listener->stats._y++;if (client) client->_x._y++;
+#define FR_STATS_INC(_x, _y) do { radius_ ## _x ## _stats._y++;if (listener) listener->stats._y++;if (client) client->_x._y++; if (listener && listener->parent) { listener->parent->stats._y++; } } while (0)
+
 #define FR_STATS_TYPE_INC(_x) _x++
 
 #else  /* WITH_STATS */
diff -urpN freeradius-server-3.2.6/src/include/tls-h freeradius-server-3.2.7/src/include/tls-h
--- freeradius-server-3.2.6/src/include/tls-h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/include/tls-h	2025-01-31 18:42:21.000000000 +0700
@@ -18,7 +18,7 @@
 
 #ifdef WITH_TLS
 /**
- * $Id: 506fb19778231add7c5ace250f2153a52e3e6945 $
+ * $Id: 2228e80cc9c02b686b018304073e45c9fa24678b $
  *
  * @file tls.h
  * @brief Structures and prototypes for TLS wrappers
@@ -26,7 +26,7 @@
  * @copyright 2010 Network RADIUS SARL <info@networkradius.com>
  */
 
-RCSIDH(tls_h, "$Id: 506fb19778231add7c5ace250f2153a52e3e6945 $")
+RCSIDH(tls_h, "$Id: 2228e80cc9c02b686b018304073e45c9fa24678b $")
 
 #include <freeradius-devel/conffile.h>
 
@@ -152,8 +152,11 @@ typedef struct _tls_session_t {
 							//!< If set to no then only the first fragment contains length.
 	int		peap_flag;
 
-	VALUE_PAIR	*outer_tlvs;			//!< only for TEAP, and only for the first fragment.
-	uint8_t		*outer_tlvs_octets;		//!< only for TEAP, needed for Crypto-Binding TLV
+	VALUE_PAIR	*outer_tlvs_server;		//!< only for TEAP, and only for the first packert.
+	uint8_t		*outer_tlvs_octets_server;	//!< only for TEAP, needed for Crypto-Binding TLV
+
+	VALUE_PAIR	*outer_tlvs_peer;		//!< only for TEAP, and only for the first packet.
+	uint8_t		*outer_tlvs_octets_peer;	//!< only for TEAP, needed for Crypto-Binding TLV
 
 	size_t		tls_record_in_total_len;	//!< How long the peer indicated the complete tls record
 							//!< would be.
@@ -305,6 +308,10 @@ void 		cbtls_info(SSL const *s, int wher
 void 		cbtls_msg(int write_p, int msg_version, int content_type, void const *buf, size_t len, SSL *ssl,
 			  void *arg);
 int		cbtls_verify(int ok, X509_STORE_CTX *ctx);
+#ifdef PSK_MAX_IDENTITY_LEN
+unsigned int	psk_server_callback(SSL *ssl, const char *identity, unsigned char *psk, unsigned int max_psk_len);
+#endif
+int		cbtls_psk_find_session(SSL *ssl, const unsigned char *id, size_t idlen, SSL_SESSION **sess);
 
 /* threads.c */
 int		tls_mutexes_init(void);
diff -urpN freeradius-server-3.2.6/src/lib/fifo.c freeradius-server-3.2.7/src/lib/fifo.c
--- freeradius-server-3.2.6/src/lib/fifo.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/fifo.c	2025-01-31 18:42:21.000000000 +0700
@@ -2,7 +2,7 @@
  * fifo.c	Non-thread-safe fifo (FIFO) implementation, based
  *		on hash tables.
  *
- * Version:	$Id: 7a9ecfac6d839c13bdce115bb842ae39c2996267 $
+ * Version:	$Id: 7d96aef6ecd175f99a9ae0e1ce7b5d0a9f8fbcdd $
  *
  *   This library is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU Lesser General Public
@@ -22,7 +22,7 @@
  *  Copyright 2005  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: 7a9ecfac6d839c13bdce115bb842ae39c2996267 $")
+RCSID("$Id: 7d96aef6ecd175f99a9ae0e1ce7b5d0a9f8fbcdd $")
 
 #include <freeradius-devel/libradius.h>
 
@@ -119,6 +119,13 @@ unsigned int fr_fifo_num_elements(fr_fif
 	return fi->num;
 }
 
+bool fr_fifo_full(fr_fifo_t *fi)
+{
+	if (!fi) return true;
+
+	return (fi->num >= fi->max);
+}
+
 #ifdef TESTING
 
 /*
diff -urpN freeradius-server-3.2.6/src/lib/filters.c freeradius-server-3.2.7/src/lib/filters.c
--- freeradius-server-3.2.6/src/lib/filters.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/filters.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * filters.c	Routines to parse Ascend's filter attributes.
  *
- * Version:	$Id: 3f3b63daeef38cc14f8ae74f0892a798e2b085b9 $
+ * Version:	$Id: e9d1d0f2e447df0864edbeaa8310b938e4421f1e $
  *
  *   This library is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU Lesser General Public
@@ -20,7 +20,7 @@
  * Copyright 2003,2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: 3f3b63daeef38cc14f8ae74f0892a798e2b085b9 $")
+RCSID("$Id: e9d1d0f2e447df0864edbeaa8310b938e4421f1e $")
 
 #include <freeradius-devel/libradius.h>
 
@@ -35,6 +35,7 @@ RCSID("$Id: 3f3b63daeef38cc14f8ae74f0892
 #define RAD_FILTER_GENERIC	0
 #define RAD_FILTER_IP		1
 #define RAD_FILTER_IPX		2
+#define RAD_FILTER_IPV6		3
 
 /*
  * Generic filters mask and match up to RAD_MAX_FILTER_LEN bytes
@@ -104,6 +105,19 @@ typedef struct ascend_ip_filter_t {
 	unsigned char   fill[4];	/* used to be fill[2] */
 } ascend_ip_filter_t;
 
+typedef struct ascend_ipv6_filter_t {
+	uint8_t		srcip[16];
+	uint8_t		dstip[16];
+	uint8_t 	srcprefix;	// number of high order bits used in IPv6
+	uint8_t 	dstprefix;	// number of high order bits used in IPv6
+	uint8_t		proto;
+	uint8_t		established;
+	uint16_t	srcport;
+	uint16_t	dstport;
+	uint8_t		srcPortComp;
+	uint8_t		dstPortComp;
+	unsigned char   fill[2];
+} ascend_ipv6_filter_t;
 
 /*
  *	ascend_ipx_net_t
@@ -206,6 +220,7 @@ typedef struct ascend_filter_t {
 	uint8_t		fill;
 	union {
 		ascend_ip_filter_t   	 ip;
+		ascend_ipv6_filter_t   	 ipv6;
 		ascend_ipx_filter_t   	 ipx;
 		ascend_generic_filter_t	generic;
 		uint8_t			data[28]; /* ensure it's 32 bytes */
@@ -213,13 +228,6 @@ typedef struct ascend_filter_t {
 } ascend_filter_t;
 
 /*
- *	This is a wild C hack...
- */
-typedef struct _cpp_hack {
-	char data[(sizeof(ascend_filter_t) == 32) ? 1 : -1 ];
-} _cpp_hack;
-
-/*
  * FilterPortType:
  *
  * Ascii names of some well known tcp/udp services.
@@ -281,12 +289,14 @@ typedef enum {
     FILTER_IPX_DST_IPXSOCK,
     FILTER_IPX_SRC_IPXNET,
     FILTER_IPX_SRC_IPXNODE,
-    FILTER_IPX_SRC_IPXSOCK
+    FILTER_IPX_SRC_IPXSOCK,
+    FILTER_IPV6_TYPE,
 } FilterTokens;
 
 
 static const FR_NAME_NUMBER filterKeywords[] = {
 	{ "ip", 	FILTER_IP_TYPE },
+	{ "ipv6", 	FILTER_IPV6_TYPE },
 	{ "generic",	FILTER_GENERIC_TYPE },
 	{ "in", 	FILTER_IN },
 	{ "out",	FILTER_OUT },
@@ -558,7 +568,7 @@ static int ascend_parse_ipaddr(uint32_t
 {
 	int		count = 0;
 	int		ip[4];
-	int	     masklen;
+	int	     	masklen;
 	uint32_t	netmask = 0;
 
 	/*
@@ -833,6 +843,171 @@ static int ascend_parse_ip(int argc, cha
 
 
 /*
+ *	Parse an IP address and optionally a netmask, to a uint32_t.
+ *
+ *	ipaddr should already be initialized to zero.
+ *	ipaddr is in network byte order.
+ *
+ *	Returns -1 on error, or the number of bits in the netmask, otherwise.
+ */
+static int ascend_parse_ipv6addr(uint8_t *ipv6addr, char *str)
+{
+	fr_ipaddr_t ip;
+
+	if (fr_pton6(&ip, str, strlen(str), false, false) < 0) return -1;
+
+	memcpy(ipv6addr, &ip.ipaddr.ip6addr.s6_addr, 16);
+
+	return ip.prefix;
+}
+
+/*
+ *	ascend_parse_ipv6:
+ *
+ *	This routine parses an IP filter string from a RADIUS
+ *	reply. The format of the string is:
+ *
+ *	ipv6 dir action [ dstip addr/mask ] [ srcip addr/mask ]
+ *	    [ proto [ dstport cmp value ] [ srcport cmd value ] [ est ] ]
+ *
+ *	Fields in [...] are optional.
+ *
+ *	dstip:		Keyword for destination IP address.
+ *			addr/mask
+ *
+ *	srcip:		Keyword for source IP address.
+ *			addr/mask
+ *
+ *	proto:		Optional protocol field. Either a name or
+ *			number. Known names are in FilterProtoName[].
+ *
+ *	dstport:	Keyword for destination port. Only valid with tcp
+ *			or udp. 'cmp' are in FilterPortType[]. 'value' can be
+ *			a name or number.
+ *
+ *	srcport:	Keyword for source port. Only valid with tcp
+ *			or udp. 'cmp' are in FilterPortType[]. 'value' can be
+ *			a name or number.
+ *
+ *	est:		Keyword for TCP established. Valid only for tcp.
+ *
+ */
+static int ascend_parse_ipv6(int argc, char **argv, ascend_ipv6_filter_t *filter, size_t *len)
+{
+	int rcode;
+	int token;
+	int flags;
+
+	/*
+	 *	We may have nothing, in which case we simply return.
+	 */
+	if (argc == 0) return 0;
+
+	*len = sizeof(*filter);
+
+	/*
+	 *	There may, or may not, be src & dst IP's in the string.
+	 */
+	flags = 0;
+	while ((argc > 0) && (flags != DONE_FLAGS)) {
+		token = fr_str2int(filterKeywords, argv[0], -1);
+		switch (token) {
+		case FILTER_IP_SRC:
+			if (flags & IP_SRC_ADDR_FLAG) return -1;
+			if (argc < 2) return -1;
+
+			rcode = ascend_parse_ipv6addr(filter->srcip, argv[1]);
+			if (rcode < 0) return rcode;
+
+			filter->srcprefix = rcode;
+			flags |= IP_SRC_ADDR_FLAG;
+			argv += 2;
+			argc -= 2;
+			break;
+
+		case FILTER_IP_DST:
+			if (flags & IP_DEST_ADDR_FLAG) return -1;
+			if (argc < 2) return -1;
+
+			rcode = ascend_parse_ipv6addr(filter->dstip, argv[1]);
+			if (rcode < 0) return rcode;
+
+			filter->dstprefix = rcode;
+			flags |= IP_DEST_ADDR_FLAG;
+			argv += 2;
+			argc -= 2;
+			break;
+
+		case FILTER_IP_SRC_PORT:
+			if (flags & IP_SRC_PORT_FLAG) return -1;
+			if (argc < 3) return -1;
+
+			rcode = ascend_parse_port(&filter->srcport,
+						  argv[1], argv[2]);
+			if (rcode < 0) return rcode;
+			filter->srcPortComp = rcode;
+
+			flags |= IP_SRC_PORT_FLAG;
+			argv += 3;
+			argc -= 3;
+			break;
+
+		case FILTER_IP_DST_PORT:
+			if (flags & IP_DEST_PORT_FLAG) return -1;
+			if (argc < 3) return -1;
+
+			rcode = ascend_parse_port(&filter->dstport,
+						  argv[1], argv[2]);
+			if (rcode < 0) return rcode;
+			filter->dstPortComp = rcode;
+
+			flags |= IP_DEST_PORT_FLAG;
+			argv += 3;
+			argc -= 3;
+			break;
+
+		case FILTER_EST:
+			if (flags & IP_EST_FLAG) return -1;
+			filter->established = 1;
+			argv++;
+			argc--;
+			flags |= IP_EST_FLAG;
+			break;
+
+		default:
+			if (flags & IP_PROTO_FLAG) return -1;
+			if (strspn(argv[0], "0123456789") == strlen(argv[0])) {
+				token = atoi(argv[0]);
+			} else {
+				token = fr_str2int(filterProtoName, argv[0], -1);
+				if (token == -1) {
+					fr_strerror_printf("Unknown IP protocol \"%s\" in IPv6 data filter",
+						   argv[0]);
+					return -1;
+				}
+			}
+			filter->proto = token;
+			flags |= IP_PROTO_FLAG;
+
+			argv++;
+			argc--;
+			break;
+		}
+	}
+
+	/*
+	 *	We should have parsed everything by now.
+	 */
+	if (argc != 0) {
+		fr_strerror_printf("Unknown extra string \"%s\" in IPv6 data filter",
+			   argv[0]);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
  *	ascend_parse_generic
  *
  *	This routine parses a Generic filter string from a RADIUS
@@ -950,14 +1125,16 @@ static int ascend_parse_generic(int argc
  * @param len of value.
  * @return -1 for error or 0.
  */
-int ascend_parse_filter(value_data_t *out, char const *value, size_t len)
+int ascend_parse_filter(TALLOC_CTX *ctx, value_data_t *out, char const *value, size_t len)
 {
 	int		token, type;
 	int		rcode;
 	int		argc;
 	char		*argv[32];
-	ascend_filter_t filter;
+	uint8_t		buffer[256];
+	ascend_filter_t *filter;
 	char		*p;
+	size_t		filter_len = 32;
 
 	rcode = -1;
 
@@ -986,7 +1163,8 @@ int ascend_parse_filter(value_data_t *ou
 	 *	Decide which filter type it is: ip, ipx, or generic
 	 */
 	type = fr_str2int(filterType, argv[0], -1);
-	memset(&filter, 0, sizeof(filter));
+	memset(buffer, 0, sizeof(buffer));
+	filter = (ascend_filter_t *) buffer;
 
 	/*
 	 *	Validate the filter type.
@@ -995,7 +1173,8 @@ int ascend_parse_filter(value_data_t *ou
 	case RAD_FILTER_GENERIC:
 	case RAD_FILTER_IP:
 	case RAD_FILTER_IPX:
-		filter.type = type;
+	case RAD_FILTER_IPV6:
+		filter->type = type;
 		break;
 
 	default:
@@ -1010,11 +1189,11 @@ int ascend_parse_filter(value_data_t *ou
 	token = fr_str2int(filterKeywords, argv[1], -1);
 	switch (token) {
 	case FILTER_IN:
-		filter.direction = 1;
+		filter->direction = 1;
 		break;
 
 	case FILTER_OUT:
-		filter.direction = 0;
+		filter->direction = 0;
 		break;
 
 	default:
@@ -1029,11 +1208,11 @@ int ascend_parse_filter(value_data_t *ou
 	token = fr_str2int(filterKeywords, argv[2], -1);
 	switch (token) {
 	case FILTER_FORWARD:
-		filter.forward = 1;
+		filter->forward = 1;
 		break;
 
 	case FILTER_DROP:
-		filter.forward = 0;
+		filter->forward = 0;
 		break;
 
 	default:
@@ -1045,25 +1224,33 @@ int ascend_parse_filter(value_data_t *ou
 
 	switch (type) {
 	case RAD_FILTER_GENERIC:
-		rcode = ascend_parse_generic(argc - 3, &argv[3], &filter.u.generic);
+		rcode = ascend_parse_generic(argc - 3, &argv[3], &filter->u.generic);
 		break;
 
 	case RAD_FILTER_IP:
-		rcode = ascend_parse_ip(argc - 3, &argv[3], &filter.u.ip);
+		rcode = ascend_parse_ip(argc - 3, &argv[3], &filter->u.ip);
 		break;
 
 	case RAD_FILTER_IPX:
-		rcode = ascend_parse_ipx(argc - 3, &argv[3], &filter.u.ipx);
+		rcode = ascend_parse_ipx(argc - 3, &argv[3], &filter->u.ipx);
+		break;
+
+	case RAD_FILTER_IPV6:
+		rcode = ascend_parse_ipv6(argc - 3, &argv[3], &filter->u.ipv6, &filter_len);
 		break;
 	}
 
+	talloc_free(p);
+
+	if (rcode < 0) return rcode;
+
 	/*
 	 *	Touch the VP only if everything was OK.
 	 */
-	if (rcode == 0) memcpy(out->filter, &filter, sizeof(filter));
-	talloc_free(p);
-
-	return rcode;
+	out->filter = talloc_memdup(ctx, buffer, filter_len);
+	if (!out->filter) return -1;
+	talloc_set_type(out->octets, uint8_t);
+	return filter_len;
 }
 
 /*
@@ -1088,7 +1275,8 @@ void print_abinary(char *out, size_t out
 	/*
 	 *  Just for paranoia: wrong size filters get printed as octets
 	 */
-	if (len != sizeof(*filter)) {
+	if ((len < 32) || (data[0] > 3) || ((data[0] < 3) && (len != 32)) ||
+	    ((data[0] == 3) && (len < 48))) {
 		strcpy(p, "0x");
 		p += 2;
 		outlen -= 2;
@@ -1163,6 +1351,52 @@ void print_abinary(char *out, size_t out
 			i = snprintf(p, outlen, " est");
 			p += i;
 		}
+
+	} else if (filter->type == RAD_FILTER_IPV6) {
+		static const uint8_t zeros[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+		if (memcmp(zeros, filter->u.ipv6.srcip, 16) != 0) {
+			char const *ip = fr_inet_ntop(AF_INET6, filter->u.ipv6.srcip);
+
+			i = snprintf(p, outlen, " srcip %s/%d",
+				     ip, filter->u.ipv6.srcprefix);
+			p += i;
+			outlen -= i;
+		}
+
+		if (memcmp(zeros, filter->u.ipv6.dstip, 16) != 0) {
+			char const *ip = fr_inet_ntop(AF_INET6, filter->u.ipv6.dstip);
+
+			i = snprintf(p, outlen, " dstip %s/%d",
+				     ip, filter->u.ipv6.dstprefix);
+			p += i;
+			outlen -= i;
+		}
+
+		i = snprintf(p, outlen, " %s", fr_int2str(filterProtoName, filter->u.ipv6.proto, "??"));
+		p += i;
+		outlen -= i;
+
+		if (filter->u.ip.srcPortComp > RAD_NO_COMPARE) {
+			i = snprintf(p, outlen, " srcport %s %d",
+				     fr_int2str(filterCompare, filter->u.ipv6.srcPortComp, "??"),
+				     ntohs(filter->u.ip.srcport));
+			p += i;
+			outlen -= i;
+		}
+
+		if (filter->u.ip.dstPortComp > RAD_NO_COMPARE) {
+			i = snprintf(p, outlen, " dstport %s %d",
+				     fr_int2str(filterCompare, filter->u.ipv6.dstPortComp, "??"),
+				     ntohs(filter->u.ip.dstport));
+			p += i;
+			outlen -= i;
+		}
+
+		if (filter->u.ipv6.established) {
+			i = snprintf(p, outlen, " est");
+			p += i;
+		}
 
 		/*
 		 *	Handle IPX filters
diff -urpN freeradius-server-3.2.6/src/lib/misc.c freeradius-server-3.2.7/src/lib/misc.c
--- freeradius-server-3.2.6/src/lib/misc.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/misc.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * misc.c	Various miscellaneous functions.
  *
- * Version:	$Id: b80b9ce468528f05b4dc2af26250431583d5282e $
+ * Version:	$Id: 780cbfbf589da32781d2247a9261140b165fd38c $
  *
  *   This library is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU Lesser General Public
@@ -20,7 +20,7 @@
  * Copyright 2000,2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: b80b9ce468528f05b4dc2af26250431583d5282e $")
+RCSID("$Id: 780cbfbf589da32781d2247a9261140b165fd38c $")
 
 #include <freeradius-devel/libradius.h>
 
@@ -1253,9 +1253,9 @@ struct in_addr fr_inaddr_mask(struct in_
  */
 struct in6_addr fr_in6addr_mask(struct in6_addr const *ipaddr, uint8_t prefix)
 {
-	uint64_t const *p = (uint64_t const *) ipaddr;
 	uint64_t addr;					/* Needed for alignment */
 	uint64_t ret[2], *o = ret;
+	uint8_t	i = 0;
 
 	if (prefix > 128) prefix = 128;
 
@@ -1264,16 +1264,30 @@ struct in6_addr fr_in6addr_mask(struct i
 
 	if (prefix >= 64) {
 		prefix -= 64;
-		memcpy(&addr, p, sizeof(addr));		/* Needed for aligned access (ubsan) */
+		addr = (uint64_t)ipaddr->s6_addr[i] |
+			((uint64_t)ipaddr->s6_addr[i + 1] << 8) |
+			((uint64_t)ipaddr->s6_addr[i + 2] << 16) |
+			((uint64_t)ipaddr->s6_addr[i + 3] << 24) |
+			((uint64_t)ipaddr->s6_addr[i + 4] << 32) |
+			((uint64_t)ipaddr->s6_addr[i + 5] << 40) |
+			((uint64_t)ipaddr->s6_addr[i + 6] << 48) |
+			((uint64_t)ipaddr->s6_addr[i + 7] << 56);
 		*o++ = 0xffffffffffffffffULL & addr;	/* lhs portion masked */
-		p++;
+		i+=8;
 	} else {
 		ret[1] = 0;				/* rhs portion zeroed */
 	}
 
 	/* Max left shift is 63 else we get overflow */
 	if (prefix > 0) {
-		memcpy(&addr, p, sizeof(addr));		/* Needed for aligned access (ubsan) */
+		addr = (uint64_t)ipaddr->s6_addr[i] |
+			((uint64_t)ipaddr->s6_addr[i + 1] << 8) |
+			((uint64_t)ipaddr->s6_addr[i + 2] << 16) |
+			((uint64_t)ipaddr->s6_addr[i + 3] << 24) |
+			((uint64_t)ipaddr->s6_addr[i + 4] << 32) |
+			((uint64_t)ipaddr->s6_addr[i + 5] << 40) |
+			((uint64_t)ipaddr->s6_addr[i + 6] << 48) |
+			((uint64_t)ipaddr->s6_addr[i + 7] << 56);
 		*o = htonll(~((uint64_t)(0x0000000000000001ULL << (64 - prefix)) - 1)) & addr;
 	} else {
 		*o = 0;
diff -urpN freeradius-server-3.2.6/src/lib/pair.c freeradius-server-3.2.7/src/lib/pair.c
--- freeradius-server-3.2.6/src/lib/pair.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/pair.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * pair.c	Functions to handle VALUE_PAIRs
  *
- * Version:	$Id: 449e0e1ca50afaa63e4b873cf16ae8a7977530d0 $
+ * Version:	$Id: c9f2f046819e4fe81b7ffca154f6132f3515e069 $
  *
  *   This library is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU Lesser General Public
@@ -20,7 +20,7 @@
  * Copyright 2000,2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: 449e0e1ca50afaa63e4b873cf16ae8a7977530d0 $")
+RCSID("$Id: c9f2f046819e4fe81b7ffca154f6132f3515e069 $")
 
 #include <freeradius-devel/libradius.h>
 #include <freeradius-devel/regex.h>
@@ -259,6 +259,29 @@ void fr_pair_delete_by_da(VALUE_PAIR **f
 	}
 }
 
+/** Delete matching pair
+ *
+ * @param[in,out] first VP in list.
+ * @param[in] vp to delete
+ */
+void fr_pair_delete(VALUE_PAIR **first, VALUE_PAIR *vp)
+{
+	VALUE_PAIR *i, *next;
+	VALUE_PAIR **last = first;
+
+	for(i = *first; i; i = next) {
+		VERIFY_VP(i);
+		next = i->next;
+		if (i == vp) {
+			*last = next;
+			talloc_free(i);
+			break;
+		} else {
+			last = &i->next;
+		}
+	}
+}
+
 /** Add a VP to the end of the list.
  *
  * Locates the end of 'first', and links an additional VP 'add' at the end.
@@ -1882,11 +1905,32 @@ FR_TOKEN fr_pair_raw_from_str(char const
 		 *	Only report as double quoted if it contained valid
 		 *	a valid xlat expansion.
 		 */
+		raw->quote = T_SINGLE_QUOTED_STRING;
 		p = strchr(raw->r_opand, '%');
-		if (p && (p[1] == '{')) {
-			raw->quote = quote;
-		} else {
-			raw->quote = T_SINGLE_QUOTED_STRING;
+
+		while (p) {
+			/*
+			 *	%{...}
+			 */
+			if (p[1] == '{') {
+				raw->quote = T_DOUBLE_QUOTED_STRING;
+				break;
+			}
+
+			/*
+			 *	Single-character expansions.  See src/main/xlat.c
+			 */
+			if (strchr("cdelmntCDGHIMSTYv", p[1])) {
+				raw->quote = T_DOUBLE_QUOTED_STRING;
+				break;
+			}
+
+			/*
+			 *	Skip %%
+			 */
+			if (p[1] == '%') p++;
+
+			p = strchr(p + 1, '%');
 		}
 
 		break;
diff -urpN freeradius-server-3.2.6/src/lib/pcap.c freeradius-server-3.2.7/src/lib/pcap.c
--- freeradius-server-3.2.6/src/lib/pcap.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/pcap.c	2025-01-31 18:42:21.000000000 +0700
@@ -14,7 +14,7 @@
  */
 
 /**
- * $Id: 987a8ea3f049a843136905b1e2b4c82b26d163ee $
+ * $Id: 440eea5e3926446dde49b8c7b5e480d7e273d58d $
  * @file pcap.c
  * @brief Wrappers around libpcap functions
  *
@@ -366,6 +366,9 @@ bool fr_pcap_link_layer_supported(int li
 #ifdef DLT_LINUX_SLL
 	case DLT_LINUX_SLL:
 #endif
+#ifdef DLT_LINUX_SLL2
+	case DLT_LINUX_SLL2:
+#endif
 	case DLT_PFLOG:
 		return true;
 
@@ -454,6 +457,15 @@ ssize_t fr_pcap_link_layer_offset(uint8_
 		if (((size_t)(p - data)) > len) {
 			goto ood;
 		}
+		break;
+#endif
+
+#ifdef DLT_LINUX_SLL2
+	case DLT_LINUX_SLL2:
+		p += 20;
+		if (((size_t)(p - data)) > len) {
+			goto ood;
+		}
 		break;
 #endif
 
diff -urpN freeradius-server-3.2.6/src/lib/radius.c freeradius-server-3.2.7/src/lib/radius.c
--- freeradius-server-3.2.6/src/lib/radius.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/radius.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: e0f44847fe78a9ae9100e0a7ec7577f9e45fb5b2 $
+ * $Id: c381b72e94dcdb7ed5eb95737238e6eaa6bd46c3 $
  *
  * @file radius.c
  * @brief Functions to send/receive radius packets.
@@ -23,7 +23,7 @@
  * @copyright 2000-2003,2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: e0f44847fe78a9ae9100e0a7ec7577f9e45fb5b2 $")
+RCSID("$Id: c381b72e94dcdb7ed5eb95737238e6eaa6bd46c3 $")
 
 #include	<freeradius-devel/libradius.h>
 
@@ -863,6 +863,7 @@ static ssize_t vp2data_any(RADIUS_PACKET
 	switch (vp->da->type) {
 	case PW_TYPE_STRING:
 	case PW_TYPE_OCTETS:
+	case PW_TYPE_ABINARY:
 		data = vp->data.ptr;
 		if (!data) return 0;
 		break;
@@ -872,7 +873,6 @@ static ssize_t vp2data_any(RADIUS_PACKET
 	case PW_TYPE_IPV6_ADDR:
 	case PW_TYPE_IPV6_PREFIX:
 	case PW_TYPE_IPV4_PREFIX:
-	case PW_TYPE_ABINARY:
 	case PW_TYPE_ETHERNET:	/* just in case */
 		data = (uint8_t const *) &vp->data;
 		break;
@@ -4188,7 +4188,7 @@ ssize_t data2vp(TALLOC_CTX *ctx,
 		break;
 
 	case PW_TYPE_ABINARY:
-		if (datalen > sizeof(vp->vp_filter)) goto raw;
+		if (datalen < 32) goto raw;
 		break;
 
 	case PW_TYPE_INTEGER:
@@ -4401,10 +4401,7 @@ alloc_raw:
 		break;
 
 	case PW_TYPE_ABINARY:
-		if (vp->vp_length > sizeof(vp->vp_filter)) {
-			vp->vp_length = sizeof(vp->vp_filter);
-		}
-		memcpy(vp->vp_filter, data, vp->vp_length);
+		fr_pair_value_memcpy(vp, data, vp->vp_length);
 		break;
 
 	case PW_TYPE_BYTE:
@@ -4598,6 +4595,7 @@ ssize_t rad_vp2data(uint8_t const **out,
 	switch (vp->da->type) {
 	case PW_TYPE_STRING:
 	case PW_TYPE_OCTETS:
+	case PW_TYPE_ABINARY:
 		memcpy(out, &vp->data.ptr, sizeof(*out));
 		break;
 
@@ -4609,7 +4607,6 @@ ssize_t rad_vp2data(uint8_t const **out,
 	case PW_TYPE_IPV6_ADDR:
 	case PW_TYPE_IPV6_PREFIX:
 	case PW_TYPE_IPV4_PREFIX:
-	case PW_TYPE_ABINARY:
 	case PW_TYPE_ETHERNET:
 	case PW_TYPE_COMBO_IP_ADDR:
 	case PW_TYPE_COMBO_IP_PREFIX:
diff -urpN freeradius-server-3.2.6/src/lib/value.c freeradius-server-3.2.7/src/lib/value.c
--- freeradius-server-3.2.6/src/lib/value.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/lib/value.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * value.c	Functions to handle value_data_t
  *
- * Version:	$Id: aa4989741c7059ce254b27786bf4a0cd59ee79a9 $
+ * Version:	$Id: dddfbeae03a2ba05ae67f55edb9408520dea9553 $
  *
  *   This library is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU Lesser General Public
@@ -20,7 +20,7 @@
  * Copyright 2014 The FreeRADIUS server project
  */
 
-RCSID("$Id: aa4989741c7059ce254b27786bf4a0cd59ee79a9 $")
+RCSID("$Id: dddfbeae03a2ba05ae67f55edb9408520dea9553 $")
 
 #include <freeradius-devel/libradius.h>
 #include <ctype.h>
@@ -586,9 +586,7 @@ ssize_t value_data_from_str(TALLOC_CTX *
 		return -1;
 
 	/* raw octets: 0x01020304... */
-#ifndef WITH_ASCEND_BINARY
 	do_octets:
-#endif
 	case PW_TYPE_OCTETS:
 	{
 		uint8_t	*p;
@@ -628,25 +626,15 @@ ssize_t value_data_from_str(TALLOC_CTX *
 	case PW_TYPE_ABINARY:
 #ifdef WITH_ASCEND_BINARY
 		if ((len > 1) && (strncasecmp(src, "0x", 2) == 0)) {
-			ssize_t bin;
-
-			if (len > ((sizeof(dst->filter) + 1) * 2)) {
-				fr_strerror_printf("Hex data is too large for ascend filter");
-				return -1;
-			}
+			goto do_octets;
 
-			bin = fr_hex2bin((uint8_t *) &dst->filter, ret, src + 2, len - 2);
-			if (bin < ret) {
-				memset(((uint8_t *) &dst->filter) + bin, 0, ret - bin);
-			}
 		} else {
-			if (ascend_parse_filter(dst, src, len) < 0 ) {
+			ret = ascend_parse_filter(ctx, dst, src, len);
+			if (ret < 0) {
 				/* Allow ascend_parse_filter's strerror to bubble up */
 				return -1;
 			}
 		}
-
-		ret = sizeof(dst->filter);
 		goto finish;
 #else
 		/*
@@ -1051,20 +1039,6 @@ static ssize_t value_data_hton(value_dat
 		memcpy(dst_ptr, src, dst_len);
 		break;
 
-	case PW_TYPE_ABINARY:
-		dst_len = sizeof(dst->filter);
-		dst_ptr = (uint8_t *) dst->filter;
-
-		/*
-		 *	Too little data is OK here.
-		 */
-		if (src_len < dst_len) {
-			memcpy(dst_ptr, src, src_len);
-			memset(dst_ptr + src_len, 0, dst_len - src_len);			
-			break;
-		}
-		goto copy;
-
 	case PW_TYPE_IFID:
 		dst_len = sizeof(dst->ifid);
 		dst_ptr = (uint8_t *) dst->ifid;
@@ -1153,14 +1127,26 @@ ssize_t value_data_cast(TALLOC_CTX *ctx,
 		return value_data_from_str(ctx, dst, &dst_type, dst_enumv, src->strvalue, src_len, '\0');
 	}
 
+	if (dst_type == PW_TYPE_ABINARY) {
+		if (src_type != PW_TYPE_OCTETS) goto invalid_cast;
+
+		dst->filter = talloc_memdup(ctx, src->octets, src_len);
+		return src_len;
+	}
+
 	/*
 	 *	Converts the src data to octets with no processing.
 	 */
 	if (dst_type == PW_TYPE_OCTETS) {
-		dst_len = value_data_hton(dst, src_type, src, src_len);
-		if (dst_len < 0) return -1;
+		if (src_type != PW_TYPE_ABINARY) {
+			dst_len = value_data_hton(dst, src_type, src, src_len);
+			if (dst_len < 0) return -1;
 
-		dst->octets = talloc_memdup(ctx, dst, dst_len);
+			dst->octets = talloc_memdup(ctx, dst, dst_len);
+		} else {
+			dst->octets = talloc_memdup(ctx, src->filter, src_len);
+			dst_len = src_len;
+		}
 		talloc_set_type(dst->octets, uint8_t);
 		return dst_len;
 	}
@@ -1647,9 +1633,9 @@ char *value_data_aprints(TALLOC_CTX *ctx
 
 	case PW_TYPE_ABINARY:
 #ifdef WITH_ASCEND_BINARY
-		p = talloc_array(ctx, char, 128);
+		p = talloc_array(ctx, char, 256);
 		if (!p) return NULL;
-		print_abinary(p, 128, (uint8_t const *) &data->filter, inlen, 0);
+		print_abinary(p, 256, data->filter, inlen, 0);
 		break;
 #else
 		  /* FALL THROUGH */
@@ -1860,7 +1846,7 @@ print_int:
 
 	case PW_TYPE_ABINARY:
 #ifdef WITH_ASCEND_BINARY
-		print_abinary(buf, sizeof(buf), (uint8_t const *) data->filter, inlen, quote);
+		print_abinary(buf, sizeof(buf), data->filter, inlen, quote);
 		a = buf;
 		len = strlen(buf);
 		break;
diff -urpN freeradius-server-3.2.6/src/main/.gitignore freeradius-server-3.2.7/src/main/.gitignore
--- freeradius-server-3.2.6/src/main/.gitignore	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/.gitignore	2025-01-31 18:42:21.000000000 +0700
@@ -1,5 +1,6 @@
 Makefile
 radsniff.mk
+radlast.mk
 checkrad
 radclient
 radiusd
diff -urpN freeradius-server-3.2.6/src/main/acct.c freeradius-server-3.2.7/src/main/acct.c
--- freeradius-server-3.2.6/src/main/acct.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/acct.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * acct.c	Accounting routines.
  *
- * Version:	$Id: c6112fd15a21de0e43d9f5042f4cfbb224db3462 $
+ * Version:	$Id: f6b048a572d7568f2e1d5d13786b640e0e75be0a $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -23,7 +23,7 @@
  * Copyright 2000  Alan Curry <pacman@world.std.com>
  */
 
-RCSID("$Id: c6112fd15a21de0e43d9f5042f4cfbb224db3462 $")
+RCSID("$Id: f6b048a572d7568f2e1d5d13786b640e0e75be0a $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -150,8 +150,8 @@ int rad_accounting(REQUEST *request)
 
 				vp_prints(buffer, sizeof(buffer), vp);
 				RDEBUG("Proxying due to %s", buffer);
-				return RLM_MODULE_OK;
 			}
+			return RLM_MODULE_OK;
 		}
 	}
 
diff -urpN freeradius-server-3.2.6/src/main/auth.c freeradius-server-3.2.7/src/main/auth.c
--- freeradius-server-3.2.6/src/main/auth.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/auth.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * auth.c	User authentication.
  *
- * Version:	$Id: d9dfc9505c27033850e8557ddc316351860837f4 $
+ * Version:	$Id: 5fa400b9968f5ca6f196aad2b9b4eb7e39213646 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2000  Miquel van Smoorenburg <miquels@cistron.nl>
  * Copyright 2000  Jeff Carneal <jeff@apex.net>
  */
-RCSID("$Id: d9dfc9505c27033850e8557ddc316351860837f4 $")
+RCSID("$Id: 5fa400b9968f5ca6f196aad2b9b4eb7e39213646 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -596,8 +596,8 @@ autz_redo:
 
 				vp_prints(buffer, sizeof(buffer), tmp);
 				RDEBUG("Proxying due to %s", buffer);
-				return RLM_MODULE_OK;
 			}
+			return RLM_MODULE_OK;
 		}
 	}
 
diff -urpN freeradius-server-3.2.6/src/main/cb.c freeradius-server-3.2.7/src/main/cb.c
--- freeradius-server-3.2.6/src/main/cb.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/cb.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * cb.c
  *
- * Version:     $Id: f9713adb100a525c927f984106cf6535c1f621b0 $
+ * Version:     $Id: 686c8a0dcb1c01000d29e1f45ffd4735dbf5e1b1 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,10 +21,11 @@
  * Copyright 2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: f9713adb100a525c927f984106cf6535c1f621b0 $")
+RCSID("$Id: 686c8a0dcb1c01000d29e1f45ffd4735dbf5e1b1 $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include <freeradius-devel/radiusd.h>
+#include <ctype.h>
 
 #ifdef WITH_TLS
 void cbtls_info(SSL const *s, int where, int ret)
@@ -251,4 +252,204 @@ int cbtls_password(char *buf,
 	return len;
 }
 
+#ifdef PSK_MAX_IDENTITY_LEN
+static bool identity_is_safe(const char *identity)
+{
+	char c;
+
+	if (!identity) return true;
+
+	while ((c = *(identity++)) != '\0') {
+		if (isalpha((uint8_t) c) || isdigit((uint8_t) c) || isspace((uint8_t) c) ||
+		    (c == '@') || (c == '-') || (c == '_') || (c == '.')) {
+			continue;
+		}
+
+		return false;
+	}
+
+	return true;
+}
+
+static size_t psk_query_run(unsigned char *psk, REQUEST *request, SSL *ssl, fr_tls_server_conf_t *conf,
+			    char const *identity, unsigned int max_psk_len)
+{
+	size_t hex_len;
+	VALUE_PAIR *vp, **certs;
+	TALLOC_CTX *talloc_ctx;
+	char buffer[2 * PSK_MAX_PSK_LEN + 4]; /* allow for too-long keys */
+
+	/*
+	 *	The passed identity is weird.  Deny it.
+	 */
+	if (!identity_is_safe(identity)) {
+		RWDEBUG("(TLS) %s - Invalid characters in PSK identity %s", conf->name, identity);
+		return 0;
+	}
+
+	vp = pair_make_request("TLS-PSK-Identity", identity, T_OP_SET);
+	if (!vp) return 0;
+
+	certs = (VALUE_PAIR **)SSL_get_ex_data(ssl, fr_tls_ex_index_certs);
+	talloc_ctx = SSL_get_ex_data(ssl, FR_TLS_EX_INDEX_TALLOC);
+	fr_assert(certs != NULL); /* pointer to sock->certs */
+	fr_assert(talloc_ctx != NULL); /* sock */
+
+	fr_pair_add(certs, fr_pair_copy(talloc_ctx, vp));
+
+	hex_len = radius_xlat(buffer, sizeof(buffer), request, conf->psk_query, NULL, NULL);
+	if (!hex_len) {
+		RWDEBUG("(TLS) %s - PSK expansion returned an empty string.", conf->name);
+		return 0;
+	}
+
+	/*
+	 *	The returned key is truncated at MORE than
+	 *	OpenSSL can handle.  That way we can detect
+	 *	the truncation, and complain about it.
+	 */
+	if (hex_len > (2 * max_psk_len)) {
+		RWDEBUG("(TLS) %s - Returned PSK is too long (%u > %u)", conf->name,
+			(unsigned int) hex_len, 2 * max_psk_len);
+		return 0;
+	}
+
+	/*
+	 *	Leave the TLS-PSK-Identity in the request, and
+	 *	convert the expansion from printable string
+	 *	back to hex.
+	 */
+	return fr_hex2bin(psk, max_psk_len, buffer, hex_len);
+}
+
+/*
+ *	When a client uses TLS-PSK to talk to a server, this callback
+ *	is used by the server to determine the PSK to use.
+ */
+unsigned int psk_server_callback(SSL *ssl, const char *identity, unsigned char *psk, unsigned int max_psk_len)
+{
+	unsigned int psk_len = 0;
+	fr_tls_server_conf_t *conf;
+	REQUEST *request;
+
+	conf = (fr_tls_server_conf_t *)SSL_get_ex_data(ssl,
+						       FR_TLS_EX_INDEX_CONF);
+	if (!conf) return 0;
+
+	request = (REQUEST *)SSL_get_ex_data(ssl,
+					     FR_TLS_EX_INDEX_REQUEST);
+	if (request && conf->psk_query) {
+		return psk_query_run(psk, request, ssl, conf, identity, max_psk_len);
+	}
+
+	if (!conf->psk_identity) {
+		DEBUG("No static PSK identity set.  Rejecting the user");
+		return 0;
+	}
+
+	/*
+	 *	No REQUEST, or no dynamic query.  Just look for a
+	 *	static identity.
+	 */
+	if (strcmp(identity, conf->psk_identity) != 0) {
+		ERROR("(TKS) Supplied PSK identity %s does not match configuration.  Rejecting.",
+		      identity);
+		return 0;
+	}
+
+	psk_len = strlen(conf->psk_password);
+	if (psk_len > (2 * max_psk_len)) return 0;
+
+	return fr_hex2bin(psk, max_psk_len, conf->psk_password, psk_len);
+}
+
+#if OPENSSL_VERSION_NUMBER >= 0x10101000
+/** Check that a whole string is valid utf8
+ * @param str input string.
+ * @param inlen length of input string.
+ */
+static bool utf8_validate(uint8_t const *str, size_t inlen) {
+	size_t used, remaining = inlen;
+	uint8_t const *p = str;
+
+	while (remaining > 0) {
+		used = fr_utf8_char(p, remaining);
+		if (used == 0) return false;
+		remaining -= used;
+		p += used;
+	}
+	return true;
+}
+
+int cbtls_psk_find_session(SSL *ssl, const unsigned char *id, size_t idlen, SSL_SESSION **sess) {
+	fr_tls_server_conf_t	*conf = (fr_tls_server_conf_t *) SSL_get_ex_data(ssl, FR_TLS_EX_INDEX_CONF);
+	REQUEST			*request = (REQUEST *)SSL_get_ex_data(ssl, FR_TLS_EX_INDEX_REQUEST);
+	SSL_CIPHER const	*cipher;
+	uint8_t			psk_key[PSK_MAX_PSK_LEN];
+	size_t			key_len = 0;
+
+	if (!utf8_validate(id, idlen)) {
+        	DEBUG2("Id is not a valid utf-8 string, assuming session resumption");
+		*sess = NULL;
+		return 1;
+	} else if (idlen > PSK_MAX_IDENTITY_LEN) {
+		WARN("id is longer than %d bytes", PSK_MAX_IDENTITY_LEN);
+		*sess = NULL;
+		return 0;
+	}
+
+	if (!conf) {
+		ERROR("No configuration for client with PSK id %s found, rejecting connection", id);
+		*sess = NULL;
+		return 0;
+	}
+
+	if (conf->psk_password) {
+		key_len = fr_hex2bin(psk_key, sizeof(psk_key), conf->psk_password,
+				     talloc_array_length(conf->psk_password) - 1);
+	} else {
+		if (request && conf->psk_query) {
+			key_len = psk_query_run(psk_key, request, ssl, conf, (char const *)id, sizeof(psk_key));
+		}
+	}
+
+	if (key_len == 0) {
+		ERROR("No PSK for client with id %s found, rejecting connection", id);
+		*sess = NULL;
+		return 0;
+	}
+
+	*sess = SSL_SESSION_new();
+	if (!*sess) {
+		ERROR("Failed to create new SSL session");
+		return 0;
+	}
+	if (!SSL_SESSION_set1_master_key(*sess, psk_key, key_len)) {
+		ERROR("Failed to set PSK key");
+		return 0;
+	}
+
+	if (!SSL_SESSION_set_protocol_version(*sess, TLS1_3_VERSION)) {
+		ERROR("Failed to set tls version 1.3, mandatory for PSK!");
+		return 0;
+	}
+
+	cipher = SSL_get_pending_cipher(ssl);
+	if (!cipher) {
+		ERROR("Failed to get pending cipher");
+		return 0;
+	}
+
+	DEBUG2("Setting session cipher %s", SSL_CIPHER_get_name(cipher));
+	if (!SSL_SESSION_set_cipher(*sess, cipher)) {
+        	ERROR("Failed to set session cipher");
+		return 0;
+	}
+
+	SSL_set_verify(ssl, SSL_VERIFY_NONE, NULL);
+
+	return 1;
+}
+#endif
+#endif
 #endif
diff -urpN freeradius-server-3.2.6/src/main/client.c freeradius-server-3.2.7/src/main/client.c
--- freeradius-server-3.2.6/src/main/client.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/client.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 6e1a684da6a8ac5d6ef9e3fe65c2768e37e9507d $
+ * $Id: 859e0578bdaa787fa9f3e4f519936769bec3f30f $
  * @file main/client.c
  * @brief Manage clients allowed to communicate with the server.
  *
@@ -24,7 +24,7 @@
  * @copyright 2000 Alan DeKok <aland@ox.org>
  * @copyright 2000 Miquel van Smoorenburg <miquels@cistron.nl>
  */
-RCSID("$Id: 6e1a684da6a8ac5d6ef9e3fe65c2768e37e9507d $")
+RCSID("$Id: 859e0578bdaa787fa9f3e4f519936769bec3f30f $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -576,7 +576,7 @@ RADCLIENT_LIST *client_list_parse_sectio
 		 *	But the list isn't _our_ list that we parsed,
 		 *	so we still need to parse the clients here.
 		 */
-		if (clients->parsed) return clients;		
+		if (clients->parsed) return clients;
 	} else {
 		clients = client_list_init(section);
 		if (!clients) return NULL;
@@ -897,6 +897,7 @@ RADCLIENT *client_afrom_cs(TALLOC_CTX *c
 {
 	RADCLIENT	*c;
 	char const	*name2;
+	CONF_SECTION	*tls;
 
 	name2 = cf_section_name2(cs);
 	if (!name2) {
@@ -939,6 +940,17 @@ RADCLIENT *client_afrom_cs(TALLOC_CTX *c
 	}
 
 	/*
+	 *	Check the TLS configuration.
+	 */
+	tls = cf_section_sub_find(cs, "tls");
+#ifndef WITH_TLS
+	if (tls) {
+		cf_log_err_cs(cs, "TLS transport is not available in this executable");
+		goto error;
+	}
+#endif
+
+	/*
 	 *	Global clients can set servers to use, per-server clients cannot.
 	 */
 	if (in_server && c->server) {
@@ -1219,11 +1231,28 @@ done_coa:
 	/*
 	 *	Be annoying to people, but it's about security.
 	 */
+#ifdef WITH_TLS
+	if (!c->tls_required && (strlen(c->secret) < 12)) {
+#else
 	if (strlen(c->secret) < 12) {
+#endif
 		WARN("Shared secret for client %s is short, and likely can be broken by an attacker.",
 		     c->shortname);
 	}
 
+#ifdef WITH_TLS
+	if (tls) {
+		/*
+		 *	Client TLS settings are taken from the
+		 *	_server_ configuration.  See listen.c, where
+		 *	client->tls is used as listener->tls.
+		 */
+		c->tls = tls_server_conf_parse(tls);
+		if (!c->tls) goto error;
+		c->tls->name = c->shortname;
+	}
+#endif
+
 	return c;
 }
 
diff -urpN freeradius-server-3.2.6/src/main/command.c freeradius-server-3.2.7/src/main/command.c
--- freeradius-server-3.2.6/src/main/command.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/command.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * command.c	Command socket processing.
  *
- * Version:	$Id: 266366b2a8f395e42a1048dd4b3863d305e34cdc $
+ * Version:	$Id: 1e5d43212283d80ede908200fae86f49b54d9afb $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -2805,7 +2805,7 @@ static int command_del_home_server(rad_l
 		return 0;
 	}
 
-	if (home_server_delete(argv[0], argv[1]) < 0) {
+	if (home_server_delete_byname(argv[0], argv[1]) < 0) {
 		cprintf_error(listener, "Failed deleted home_server %s - %s\n", argv[1], fr_strerror());
 		return 0;
 	}
diff -urpN freeradius-server-3.2.6/src/main/conffile.c freeradius-server-3.2.7/src/main/conffile.c
--- freeradius-server-3.2.6/src/main/conffile.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/conffile.c	2025-01-31 18:42:21.000000000 +0700
@@ -5,7 +5,7 @@
  *		write a decent parser. I know how to do that, really :)
  *		miquels@cistron.nl
  *
- * Version:	$Id: 4ed7d055b05ee069095ac0442d62e865b3399ff3 $
+ * Version:	$Id: 75bb5d616e1ea7b053e5951e1d55c23920c20400 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -26,10 +26,11 @@
  * Copyright 2000  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: 4ed7d055b05ee069095ac0442d62e865b3399ff3 $")
+RCSID("$Id: 75bb5d616e1ea7b053e5951e1d55c23920c20400 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/parser.h>
+#include <freeradius-devel/md5.h>
 #include <freeradius-devel/rad_assert.h>
 
 #ifdef HAVE_DIRENT_H
@@ -1503,7 +1504,7 @@ int cf_item_parse(CONF_SECTION *cs, char
 				     next->item.lineno, name);
 			}
 		}
-										   
+
 		if (multi) {
 			while ((next = cf_pair_find_next(cs, next, name)) != NULL) {
 				/*
@@ -2333,6 +2334,34 @@ static char const *cf_local_file(char co
 	return buffer;
 }
 
+static bool cf_md5_initted = false;
+static FR_MD5_CTX conf_context;
+
+void cf_md5_init(void)
+{
+	fr_md5_init(&conf_context);
+	cf_md5_initted = true;
+}
+
+
+static void cf_md5_update(char const *p)
+{
+	if (!cf_md5_initted) return;
+
+	fr_md5_update(&conf_context, (uint8_t const *)p, strlen(p));
+}
+
+void cf_md5_final(uint8_t *digest)
+{
+	if (!cf_md5_initted) {
+		memset(digest, 0, MD5_DIGEST_LENGTH);
+		return;
+	}
+
+	fr_md5_final(digest, &conf_context);
+	cf_md5_initted = false;
+}
+
 
 /*
  *	Read a part of the config file.
@@ -2369,6 +2398,7 @@ static int cf_section_read(char const *f
 		 *	Get data, and remember if we are at EOF.
 		 */
 		at_eof = (fgets(cbuf, sizeof(buf) - (cbuf - buf), fp) == NULL);
+		cf_md5_update(cbuf);
 		(*lineno)++;
 
 		/*
diff -urpN freeradius-server-3.2.6/src/main/listen.c freeradius-server-3.2.7/src/main/listen.c
--- freeradius-server-3.2.6/src/main/listen.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/listen.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * listen.c	Handle socket stuff
  *
- * Version:	$Id: 0460e5f9bc9e9466600e1c0fcb1bc9d6950f41e3 $
+ * Version:	$Id: b817248d71906f14efa7951157207268d268b104 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2005  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: 0460e5f9bc9e9466600e1c0fcb1bc9d6950f41e3 $")
+RCSID("$Id: b817248d71906f14efa7951157207268d268b104 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -1199,8 +1199,6 @@ static int dual_tcp_accept(rad_listen_t
 		close(newfd);
 		return 0;
 	}
-	client->limit.num_connections++;
-	sock->limit.num_connections++;
 
 	/*
 	 *	Add the new listener.  We require a new context here,
@@ -1211,6 +1209,12 @@ static int dual_tcp_accept(rad_listen_t
 	if (!this) return -1;
 
 	/*
+	 *	Now that we've opened a connection, increment the reference count.
+	 */
+	client->limit.num_connections++;
+	sock->limit.num_connections++;
+
+	/*
 	 *	Copy everything, including the pointer to the socket
 	 *	information.
 	 */
@@ -1265,6 +1269,7 @@ static int dual_tcp_accept(rad_listen_t
 		this->recv = dual_tcp_recv;
 
 #ifdef WITH_TLS
+		if (client->tls) this->tls = client->tls;
 		if (this->tls) {
 			this->recv = dual_tls_recv;
 			this->send = dual_tls_send;
@@ -3642,6 +3647,17 @@ rad_listen_t *proxy_new_listener(TALLOC_
 
 
 #ifdef WITH_TCP
+#ifdef SO_KEEPALIVE
+	if (home->proto == IPPROTO_TCP) {
+		int on = 1;
+
+		if (setsockopt(this->fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0) {
+			ERROR("(TLS) Failed to set SO_KEEPALIVE: %s", fr_syserror(errno));
+			goto error;
+		}
+	}
+#endif
+
 #ifdef WITH_TLS
 	if ((home->proto == IPPROTO_TCP) && home->tls) {
 		DEBUG("(TLS) Trying new outgoing proxy connection to %s", buffer);
diff -urpN freeradius-server-3.2.6/src/main/mainconfig.c freeradius-server-3.2.7/src/main/mainconfig.c
--- freeradius-server-3.2.6/src/main/mainconfig.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/mainconfig.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * mainconf.c	Handle the server's configuration.
  *
- * Version:	$Id: 2b2dda804b008f715e50ad72a4605bb83bac7d55 $
+ * Version:	$Id: debfb296f030b4f336551d161b0babcb41833aa1 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2002  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: 2b2dda804b008f715e50ad72a4605bb83bac7d55 $")
+RCSID("$Id: debfb296f030b4f336551d161b0babcb41833aa1 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -230,6 +230,15 @@ static const CONF_PARSER resources[] = {
 	CONF_PARSER_TERMINATOR
 };
 
+static const CONF_PARSER unlang_config[] = {
+	/*
+	 *	Unlang behaviour options
+	 */
+	{ "group_stop_return", FR_CONF_POINTER(PW_TYPE_BOOLEAN, &main_config.group_stop_return), "no" },
+	{ "policy_stop_return", FR_CONF_POINTER(PW_TYPE_BOOLEAN, &main_config.policy_stop_return), "no" },
+	CONF_PARSER_TERMINATOR
+};
+
 static const CONF_PARSER server_config[] = {
 	/*
 	 *	FIXME: 'prefix' is the ONLY one which should be
@@ -282,6 +291,8 @@ static const CONF_PARSER server_config[]
 	{ "log_stripped_names", FR_CONF_POINTER(PW_TYPE_BOOLEAN | PW_TYPE_DEPRECATED, &log_stripped_names), NULL },
 
 	{  "security", FR_CONF_POINTER(PW_TYPE_SUBSECTION, NULL), (void const *) security_config },
+
+	{  "unlang", FR_CONF_POINTER(PW_TYPE_SUBSECTION, NULL), (void const *) unlang_config },
 	CONF_PARSER_TERMINATOR
 };
 
@@ -1006,6 +1017,11 @@ do {\
 	}
 	version_init_numbers(subcs);
 
+	/*
+	 *	Track the status of the configuration.
+	 */
+	if (rad_debug_lvl) cf_md5_init();
+
 	/* Read the configuration file */
 	snprintf(buffer, sizeof(buffer), "%.200s/%.50s.conf", radius_dir, main_config.name);
 	if (cf_file_read(cs, buffer) < 0) {
diff -urpN freeradius-server-3.2.6/src/main/modcall.c freeradius-server-3.2.7/src/main/modcall.c
--- freeradius-server-3.2.6/src/main/modcall.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/modcall.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * @name modcall.c
  *
- * Version:	$Id: 5a3116cc58cd6ed3dd25c23f418a1e0357da121a $
+ * Version:	$Id: 29fc2be1b9912c51affbe05ab1300630008c6dbd $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -20,7 +20,7 @@
  * Copyright 2000,2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: 5a3116cc58cd6ed3dd25c23f418a1e0357da121a $")
+RCSID("$Id: 29fc2be1b9912c51affbe05ab1300630008c6dbd $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modpriv.h>
@@ -1096,6 +1096,12 @@ calculate_result:
 	}
 
 	if (entry->unwind == MOD_RETURN) {
+		if ((entry->c->type == MOD_GROUP && main_config.group_stop_return) ||
+		    (entry->c->type == MOD_POLICY && main_config.policy_stop_return)) {
+			entry->unwind = 0;
+			goto next_sibling;
+		}
+
 		goto finish;
 	}
 
diff -urpN freeradius-server-3.2.6/src/main/modules.c freeradius-server-3.2.7/src/main/modules.c
--- freeradius-server-3.2.6/src/main/modules.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/modules.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * modules.c	Radius module support.
  *
- * Version:	$Id: 9ccb3103ae0a129b258c2e8c84e92b033144a46f $
+ * Version:	$Id: 8f83690b6b4c322aeb3edee38695f141f29cfed6 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
  * Copyright 2000  Alan Curry <pacman@world.std.com>
  */
 
-RCSID("$Id: 9ccb3103ae0a129b258c2e8c84e92b033144a46f $")
+RCSID("$Id: 8f83690b6b4c322aeb3edee38695f141f29cfed6 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modpriv.h>
@@ -285,7 +285,7 @@ char const *fr_dlerror(void)
 	return dlerror();
 }
 
-static int virtual_server_idx(char const *name)
+static uint32_t virtual_server_idx(char const *name)
 {
 	uint32_t hash;
 
@@ -298,11 +298,11 @@ static int virtual_server_idx(char const
 
 static virtual_server_t *virtual_server_find(char const *name)
 {
-	rlm_rcode_t rcode;
+	uint32_t hash;
 	virtual_server_t *server;
 
-	rcode = virtual_server_idx(name);
-	for (server = virtual_servers[rcode];
+	hash = virtual_server_idx(name);
+	for (server = virtual_servers[hash];
 	     server != NULL;
 	     server = server->next) {
 		if (!name && !server->name) break;
@@ -317,6 +317,7 @@ static virtual_server_t *virtual_server_
 static int _virtual_server_free(virtual_server_t *server)
 {
 	if (server->components) rbtree_free(server->components);
+
 	return 0;
 }
 
@@ -345,7 +346,7 @@ void virtual_servers_free(time_t when)
 			 */
 			if ((when == 0) ||
 			    ((server->created < when) && server->can_free)) {
-				*last = server->next;
+				*last = next;
 				talloc_free(server);
 			} else {
 				last = &(server->next);
@@ -1252,9 +1253,10 @@ static int load_byserver(CONF_SECTION *c
 	bool found;
 	char const *name = cf_section_name2(cs);
 	rbtree_t *components;
-	virtual_server_t *server = NULL;
+	virtual_server_t *server = NULL, *old;
 	indexed_modcallable *c;
 	bool is_bare;
+	uint32_t hash;
 
 	if (name) {
 		cf_log_info(cs, "server %s { # from file %s",
@@ -1466,27 +1468,19 @@ static int load_byserver(CONF_SECTION *c
 	}
 
 	/*
-	 *	Now that it is OK, insert it into the list.
+	 *	Mark the existing (i.e. old) server as no longer used.
 	 *
-	 *	This is thread-safe...
+	 *	Do this _before_ adding the new virtual server.
 	 */
-	comp = virtual_server_idx(name);
-	server->next = virtual_servers[comp];
-	virtual_servers[comp] = server;
+	old = virtual_server_find(name);
+	if (old) old->can_free = true;
 
 	/*
-	 *	Mark OLDER ones of the same name as being unused.
+	 *	Insert the new server at the head of the list.
 	 */
-	server = server->next;
-	while (server) {
-		if ((!name && !server->name) ||
-		    (name && server->name &&
-		     (strcmp(server->name, name) == 0))) {
-			server->can_free = true;
-			break;
-		}
-		server = server->next;
-	}
+	hash = virtual_server_idx(name);
+	server->next = virtual_servers[hash];
+	virtual_servers[hash] = server;
 
 	return 0;
 }
diff -urpN freeradius-server-3.2.6/src/main/process.c freeradius-server-3.2.7/src/main/process.c
--- freeradius-server-3.2.6/src/main/process.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/process.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 178202bbb36212d84c2cd5106112d3f531f29b00 $
+ * $Id: 9753792f95f5f10f870ef03e03bbf51293a0a0a5 $
  *
  * @file process.c
  * @brief Defines the state machines that control how requests are processed.
@@ -24,7 +24,7 @@
  * @copyright 2012  Alan DeKok <aland@deployingradius.com>
  */
 
-RCSID("$Id: 178202bbb36212d84c2cd5106112d3f531f29b00 $")
+RCSID("$Id: 9753792f95f5f10f870ef03e03bbf51293a0a0a5 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/process.h>
@@ -62,6 +62,12 @@ time_t fr_start_time = (time_t)-1;
 static rbtree_t *pl = NULL;
 static fr_event_list_t *el = NULL;
 
+/*
+ *	These are shared with threads.c, and nothing else.
+ */
+void request_free(REQUEST *request) CC_HINT(nonnull);
+void request_done(REQUEST *request, int original) CC_HINT(nonnull);
+
 fr_event_list_t *radius_event_list_corral(UNUSED event_corral_t hint) {
 	/* Currently we do not run a second event loop for modules. */
 	return el;
@@ -100,7 +106,7 @@ static char const *master_state_names[RE
 	"?",
 	"active",
 	"stop-processing",
-	"counted"
+	"in-queue-waiting-to-free",
 };
 
 static char const *child_state_names[REQUEST_CHILD_NUM_STATES] = {
@@ -306,7 +312,7 @@ static bool we_are_master(void)
 #define FINAL_STATE(_x) NO_CHILD_THREAD; request->component = "<" #_x ">"; request->module = ""; request->child_state = _x
 
 
-static void event_new_fd(rad_listen_t *this);
+static void event_new_fd(void *ctx);
 
 /*
  *	We need mutexes around the event FD list *only* in certain
@@ -396,7 +402,6 @@ STATE_MACHINE_DECL(request_ping) CC_HINT
 STATE_MACHINE_DECL(request_response_delay) CC_HINT(nonnull);
 STATE_MACHINE_DECL(request_cleanup_delay) CC_HINT(nonnull);
 STATE_MACHINE_DECL(request_running) CC_HINT(nonnull);
-STATE_MACHINE_DECL(request_done) CC_HINT(nonnull);
 
 STATE_MACHINE_DECL(proxy_no_reply) CC_HINT(nonnull);
 STATE_MACHINE_DECL(proxy_running) CC_HINT(nonnull);
@@ -590,7 +595,7 @@ static void request_timer(void *ctx)
  *	request.  If there is a parent, free the parent INSTEAD of the
  *	request.
  */
-static void request_free(REQUEST *request)
+void request_free(REQUEST *request)
 {
 	void *ptr;
 
@@ -598,6 +603,15 @@ static void request_free(REQUEST *reques
 	rad_assert(!request->in_request_hash);
 	rad_assert(!request->in_proxy_hash);
 
+	/*
+	 *	Don't free requests which are in the queue.  The code
+	 *	in threads.c will take care of doing that.
+	 */
+	if (request->child_state == REQUEST_QUEUED) {
+		request->master_state = REQUEST_TO_FREE;
+		return;
+	}
+
 	if ((request->options & RAD_REQUEST_OPTION_CTX) == 0) {
 		talloc_free(request);
 		return;
@@ -687,7 +701,7 @@ static void proxy_reply_too_late(REQUEST
  *	}
  *  \enddot
  */
-static void request_done(REQUEST *request, int original)
+void request_done(REQUEST *request, int original)
 {
 	struct timeval now, when;
 	int action = original;
@@ -802,7 +816,17 @@ static void request_done(REQUEST *reques
 	case FR_ACTION_DONE:
 #ifdef HAVE_PTHREAD_H
 		/*
-		 *	If the child is still running, leave it alone.
+		 *	If the child is still queued or running, don't
+		 *	mark it as DONE.
+		 *
+		 *	For queued requests, the request_free()
+		 *	function will mark up the request so that the
+		 *	queue will free it.
+		 *
+		 *	For running requests, the child thread will
+		 *	eventually call request_done().  A timer in
+		 *	the master thread will then take care of
+		 *	cleaning up the request.
 		 */
 		if (spawn_flag && (request->child_state <= REQUEST_RUNNING)) {
 			break;
@@ -2013,6 +2037,7 @@ skip_dup:
 		/*
 		 *	Don't do delayed reject.  Oh well.
 		 */
+		request->child_state = REQUEST_DONE;
 		request_free(request);
 		return 1;
 	}
@@ -5545,8 +5570,9 @@ static int proxy_eol_cb(void *ctx, void
 }
 #endif	/* WITH_PROXY */
 
-static void event_new_fd(rad_listen_t *this)
+static void event_new_fd(void *ctx)
 {
+	rad_listen_t *this = talloc_get_type_abort(ctx, rad_listen_t);
 	char buffer[1024];
 	listen_socket_t *sock = NULL;
 
@@ -5702,12 +5728,18 @@ static void event_new_fd(rad_listen_t *t
 		/*
 		 *	All sockets: add the FD to the event handler.
 		 */
+#ifdef WITH_TLS
 	insert_fd:
+#endif
 		if (fr_event_fd_insert(el, 0, this->fd,
 				       event_socket_handler, this)) {
 			this->status = RAD_LISTEN_STATUS_KNOWN;
 
 #ifdef WITH_TLS
+			if (this->type == RAD_LISTEN_DETAIL) {
+				return;
+			}
+
 			sock = this->data;
 			if (!sock->write_handler) return;
 
@@ -5735,12 +5767,27 @@ static void event_new_fd(rad_listen_t *t
 		goto listener_is_eol;
 	} /* end of INIT */
 
+#ifdef WITH_TLS
+	/*
+	 *	We're doing TLS connection checks.  Don't read normal packets.
+	 */
 	if (this->status == RAD_LISTEN_STATUS_PAUSE) {
 		fr_event_fd_delete(el, 0, this->fd);
 		return;
 	}
 
-	if (this->status == RAD_LISTEN_STATUS_RESUME) goto insert_fd;
+	/*
+	 *	TLS connection checks are done.  Read the pending
+	 *	packet, then add the listener to the event loop.
+	 */
+	if (this->status == RAD_LISTEN_STATUS_RESUME) {
+		this->status = RAD_LISTEN_STATUS_KNOWN;
+
+		fr_assert(this->tls);
+		(void) this->recv(this);
+		goto insert_fd;
+	}
+#endif
 
 #ifdef WITH_TCP
 	/*
@@ -5922,6 +5969,23 @@ static void event_new_fd(rad_listen_t *t
 				fr_assert(home->listeners);
 
 				(void) rbtree_deletebydata(home->listeners, this);
+
+				/*
+				 *	This home server is dynamic, and has no open connections.  Delete it.
+				 *
+				 *	@todo - have a separate lifetime for dynamic home servers.  i.e. the
+				 *	home server will stick around for a period of time, even if it has no
+				 *	open connections.
+				 *
+				 *	And then after that lifetime, we refresh the home server?
+				 */
+				if (home->dynamic && (rbtree_num_elements(home->listeners) == 0)) {
+					if (home_server_delete(home) < 0) {
+						ERROR("Fatal error removing dynamic home server - %s",
+						      fr_strerror());
+						fr_exit(1);
+					}
+				}
 			}
 #endif
 
@@ -6460,14 +6524,6 @@ static int proxy_delete_cb(UNUSED void *
 	if (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0) return 0;
 #endif
 
-	/*
-	 *	If it's queued we can't delete it from the queue.
-	 *
-	 *	Otherwise, it's OK to delete it.  Even RUNNING, because
-	 *	that will get caught by the check above.
-	 */
-	if (request->child_state == REQUEST_QUEUED) return 0;
-
 	request->in_proxy_hash = false;
 
 	if (!request->in_request_hash) {
@@ -6493,9 +6549,25 @@ static int request_delete_cb(UNUSED void
 	/*
 	 *	Not done, or the child thread is still processing it.
 	 */
-	if (request->child_state < REQUEST_RESPONSE_DELAY) return 0; /* continue */
+	switch (request->child_state) {
+	default:
+	case REQUEST_QUEUED:
+	case REQUEST_RESPONSE_DELAY:
+	case REQUEST_CLEANUP_DELAY:
+	case REQUEST_DONE:
+		break;
+
+	case REQUEST_RUNNING:
+	case REQUEST_PROXIED:
+		return 0;
+	}
 
 #ifdef HAVE_PTHREAD_H
+	/*
+	 *	The request is being processed by a child thread.
+	 *	This should never happen, but perhaps race condition
+	 *	could cause this to be set?
+	 */
 	if (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0) return 0;
 #endif
 
@@ -6532,6 +6604,16 @@ void radius_event_free(void)
 {
 	ASSERT_MASTER;
 
+#ifdef HAVE_PTHREAD_H
+	/*
+	 *	Stop all threads from processing requests.  Do this
+	 *	before trying to clean up or free outstanding requests.
+	 */
+	if (spawn_flag) {
+		thread_pool_stop();
+	}
+#endif
+
 #ifdef WITH_PROXY
 	/*
 	 *	There are requests in the proxy hash that aren't
@@ -6550,7 +6632,7 @@ void radius_event_free(void)
 		 *	ensure that all of the threads have exited.
 		 */
 #ifdef HAVE_PTHREAD_H
-		thread_pool_stop();
+		thread_pool_free();
 #endif
 
 		/*
diff -urpN freeradius-server-3.2.6/src/main/radclient.c freeradius-server-3.2.7/src/main/radclient.c
--- freeradius-server-3.2.6/src/main/radclient.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/radclient.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * radclient.c	General radius packet debug tool.
  *
- * Version:	$Id: ab880dd735d0f4ddc888f5390e07aa6f6b0f3342 $
+ * Version:	$Id: 0f1cc4c2923f2a3a0d05f65f5e5f588e2f6bbdda $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
  * Copyright 2000  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: ab880dd735d0f4ddc888f5390e07aa6f6b0f3342 $")
+RCSID("$Id: 0f1cc4c2923f2a3a0d05f65f5e5f588e2f6bbdda $")
 
 #include <freeradius-devel/radclient.h>
 #include <freeradius-devel/radpaths.h>
@@ -1070,6 +1070,13 @@ static int send_one_packet(rc_request_t
 
 		if (fr_debug_lvl > 2) rad_print_hex(request->packet);
 
+		if ((fr_debug_lvl > 0) &&
+		    ((request->packet->code == PW_CODE_ACCESS_REQUEST) ||
+		     (request->packet->code == PW_CODE_STATUS_SERVER)) &&
+		    !fr_pair_find_by_num(request->packet->vps, PW_MESSAGE_AUTHENTICATOR, 0, TAG_ANY)) {
+			fprintf(fr_log_fp, "\tMessage-Authenticator = 0x\n");
+		}
+
 		if (fr_debug_lvl > 0) vp_printlist(fr_log_fp, request->packet->vps);
 	}
 
diff -urpN freeradius-server-3.2.6/src/main/radiusd.c freeradius-server-3.2.7/src/main/radiusd.c
--- freeradius-server-3.2.6/src/main/radiusd.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/radiusd.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * radiusd.c	Main loop of the radius server.
  *
- * Version:	$Id: f2acec7dd90f25eb17b92cc314639e001260dc98 $
+ * Version:	$Id: d91895cc11405b84b855d7fe0733eec2b6de745b $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@
  * Copyright 2000  Chad Miller <cmiller@surfsouth.com>
  */
 
-RCSID("$Id: f2acec7dd90f25eb17b92cc314639e001260dc98 $")
+RCSID("$Id: d91895cc11405b84b855d7fe0733eec2b6de745b $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -361,6 +361,18 @@ int main(int argc, char *argv[])
 	INFO("%s", fr_debug_state_to_msg(fr_debug_state));
 
 	/*
+	 *	Track configuration versions.  This lets us know if the configuration changed.
+	 */
+	if (rad_debug_lvl) {
+		uint8_t digest[16];
+
+		cf_md5_final(digest);
+
+		INFO("Configuration version: %02x%02x-%02x%02x-%02x%02x-%02x%02x",
+		     digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7]);
+	}
+
+	/*
 	 *  Check for vulnerabilities in the version of libssl were linked against.
 	 */
 #if defined(HAVE_OPENSSL_CRYPTO_H) && defined(ENABLE_OPENSSL_VERSION_CHECK)
@@ -773,6 +785,7 @@ static void sig_fatal(int sig)
 			radius_signal_self(RADIUS_SIGNAL_SELF_TERM);
 			break;
 		}
+		fr_strerror_printf(NULL); /* clear old errors */
 		/* FALL-THROUGH */
 
 	default:
diff -urpN freeradius-server-3.2.6/src/main/radlast.mk freeradius-server-3.2.7/src/main/radlast.mk
--- freeradius-server-3.2.6/src/main/radlast.mk	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/radlast.mk	1970-01-01 07:00:00.000000000 +0700
@@ -1,5 +0,0 @@
-install: $(R)$(bindir)/radlast
-
-$(R)$(bindir)/radlast: src/main/radlast | $(R)$(bindir)
-	@echo INSTALL $(notdir $<)
-	@$(INSTALL) -m 755 $< $(R)$(bindir)
diff -urpN freeradius-server-3.2.6/src/main/radlast.mk.in freeradius-server-3.2.7/src/main/radlast.mk.in
--- freeradius-server-3.2.6/src/main/radlast.mk.in	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/main/radlast.mk.in	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,7 @@
+ifeq (@WITH_RADLAST@,yes)
+install: $(R)$(bindir)/radlast
+
+$(R)$(bindir)/radlast: src/main/radlast | $(R)$(bindir)
+	@echo INSTALL $(notdir $<)
+	@$(INSTALL) -m 755 $< $(R)$(bindir)
+endif
diff -urpN freeradius-server-3.2.6/src/main/realms.c freeradius-server-3.2.7/src/main/realms.c
--- freeradius-server-3.2.6/src/main/realms.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/realms.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * realms.c	Realm handling code
  *
- * Version:     $Id: cf10ccbe1d5ee12209f8026bbe04f88323c699cb $
+ * Version:     $Id: eb81b8a6721f5f35e636802f5c47584620a51444 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2007  Alan DeKok <aland@deployingradius.com>
  */
 
-RCSID("$Id: cf10ccbe1d5ee12209f8026bbe04f88323c699cb $")
+RCSID("$Id: eb81b8a6721f5f35e636802f5c47584620a51444 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/realms.h>
@@ -649,7 +649,7 @@ static bool home_server_insert(home_serv
 		return false;
 	}
 
-	if (!home->virtual_server && !rbtree_insert(home_servers_byaddr, home)) {
+	if (!home->virtual_server && !home->dynamic && !rbtree_insert(home_servers_byaddr, home)) {
 		rbtree_deletebydata(home_servers_byname, home);
 		cf_log_err_cs(cs, "Internal error %d adding home server %s", __LINE__, home->log_name);
 		return false;
@@ -691,7 +691,7 @@ bool realm_home_server_add(home_server_t
 		return false;
 	}
 
-	if (!home->virtual_server && (rbtree_finddata(home_servers_byaddr, home) != NULL)) {
+	if (!home->virtual_server && !home->dynamic && (rbtree_finddata(home_servers_byaddr, home) != NULL)) {
 		char buffer[INET6_ADDRSTRLEN + 3];
 
 		inet_ntop(home->ipaddr.af, &home->ipaddr.ipaddr, buffer, sizeof(buffer));
@@ -978,7 +978,7 @@ home_server_t *home_server_afrom_cs(TALL
 		home->proto = proto;
 	}
 
-	if (!home->virtual_server && rbtree_finddata(home_servers_byaddr, home)) {
+	if (!home->virtual_server && !home->dynamic && rbtree_finddata(home_servers_byaddr, home)) {
 		cf_log_err_cs(cs, "Duplicate home server");
 		goto error;
 	}
@@ -3160,11 +3160,12 @@ home_pool_t *home_pool_byname(char const
 	return rbtree_finddata(home_pools_byname, &mypool);
 }
 
+
 int home_server_afrom_file(char const *filename)
 {
 	CONF_SECTION *cs, *subcs;
 	char const *p;
-	home_server_t *home;
+	home_server_t *home, *old;
 
 	if (!realm_config->dynamic) {
 		fr_strerror_printf("Must set \"dynamic = true\" in proxy.conf for dynamic home servers to work");
@@ -3205,18 +3206,22 @@ int home_server_afrom_file(char const *f
 
 	home->dynamic = true;
 
-	if (home->virtual_server) {
-		fr_strerror_printf("Dynamic home_server '%s' cannot have 'server = %s' configuration item", p, home->virtual_server);
+#ifdef WITH_TLS
+	/*
+	 *	All of the other code assumes that only TLS sockets
+	 *	have child listeners.  See listen.c for references to
+	 *	...->listeners, which are all inside of blocks which
+	 *	check for TLS.
+	 */
+	if (!home->tls) {
+		fr_strerror_printf("Dynamic home_server '%s' does not use TLS - ignoring it.", p);
 		talloc_free(home);
 		goto error;
 	}
-
-	if (home->dual
-#ifdef WITH_TLS
-		&& !home->tls
 #endif
-	) {
-		fr_strerror_printf("Dynamic home_server '%s' is missing 'type', or it is set to 'auth+acct'.  Please specify 'type = auth' or 'type = acct', etc.", p);
+
+	if (home->virtual_server) {
+		fr_strerror_printf("Dynamic home_server '%s' cannot have 'server = %s' configuration item", p, home->virtual_server);
 		talloc_free(home);
 		goto error;
 	}
@@ -3229,8 +3234,88 @@ int home_server_afrom_file(char const *f
 	}
 #endif
 
+	old = home_server_byname(home->name, home->type);
+	if (old) {
+		if (!old->dynamic) {
+			fr_strerror_printf("Cannot replace static home server %s with a dynamic one",
+					   home->name);
+			talloc_free(home);
+			goto error;
+		}
+
+#ifdef WITH_TLS
+		if (!old->tls) {
+			fr_strerror_printf("Cannot replace non-TLS home server %s with a dynamic one",
+					   home->name);
+			talloc_free(home);
+			goto error;
+		}
+#endif
+
+#if 0
+		/*
+		 *	The fr_socket_client_tcp() and fr_socket() functions may change the
+		 *	source IP, i.e. * -> 192.168...., due to issues like FreeBSD jails.
+		 */
+		if (memcmp(&old->src_ipaddr, &home->src_ipaddr, sizeof(home->src_ipaddr)) != 0) {
+			fr_strerror_printf("Cannot change source IP for dynamic home server %s.",
+					   home->name);
+			talloc_free(home);
+			goto error;
+		}
+#endif
+
+		if (old->ipaddr.af != home->ipaddr.af) {
+			fr_strerror_printf("Cannot change IP address families for dynamic home server %s.",
+					   home->name);
+			talloc_free(home);
+			goto error;
+		}
+
+		/*
+		 *	No other thread is writing to it, as we're running in the master thread.  So this
+		 *	memcpy is safe.
+		 *
+		 *	@todo - extend the lifetime?
+		 */
+		if (memcmp(&old->ipaddr, &home->ipaddr, sizeof(home->ipaddr)) == 0) {
+			talloc_free(home);
+			return 0;
+		}
+
+		/*
+		 *	Change the destination IP to the new one.
+		 *
+		 *	This isn't thread-safe.  :(
+		 */
+		switch (old->ipaddr.af) {
+		case AF_INET:
+			old->ipaddr.ipaddr.ip4addr.s_addr = home->ipaddr.ipaddr.ip4addr.s_addr;
+			break;
+
+		case AF_INET6:
+			memcpy(&old->ipaddr.ipaddr.ip6addr.s6_addr,
+			       &home->ipaddr.ipaddr.ip6addr.s6_addr,
+			       sizeof(old->ipaddr.ipaddr.ip6addr.s6_addr));
+			break;
+
+		default:
+			fr_strerror_printf("Bad address family");
+			talloc_free(home);
+			return -1;
+		}
+
+		talloc_free(home);
+		return 0;
+	}
+
+	/*
+	 *	@todo - find the original one.  If it already exists,
+	 *	just change the IP address?
+	 */
+
 	if (!realm_home_server_add(home)) {
-		fr_strerror_printf("Failed adding home_server to the internal data structures");
+		fr_strerror_printf("Failed adding dynamic server");
 		talloc_free(home);
 		goto error;
 	}
@@ -3238,7 +3323,7 @@ int home_server_afrom_file(char const *f
 	return 0;
 }
 
-int home_server_delete(char const *name, char const *type_name)
+int home_server_delete_byname(char const *name, char const *type_name)
 {
 	home_server_t *home;
 	int type;
@@ -3268,13 +3353,24 @@ int home_server_delete(char const *name,
 		return -1;
 	}
 
+	return home_server_delete(home);
+}
+
+int home_server_delete(home_server_t *home)
+{
 	if (!home->dynamic) {
-		fr_strerror_printf("Cannot delete static home_server %s", p);
+		fr_strerror_printf("Cannot delete static home_server %s", home->name);
+		return -1;
+	}
+
+#ifdef WITH_TLS
+	if (rbtree_num_elements(home->listeners) > 0) {
+		fr_strerror_printf("Cannot delete dynaic home_server %s - it still has open sockets", home->name);
 		return -1;
 	}
+#endif
 
 	(void) rbtree_deletebydata(home_servers_byname, home);
-	(void) rbtree_deletebydata(home_servers_byaddr, home);
 #ifdef WITH_STATS
 	(void) rbtree_deletebydata(home_servers_bynumber, home);
 #endif
diff -urpN freeradius-server-3.2.6/src/main/stats.c freeradius-server-3.2.7/src/main/stats.c
--- freeradius-server-3.2.6/src/main/stats.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/stats.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * stats.c	Internal statistics handling.
  *
- * Version:	$Id: 64cbafea931f9e807cfa50984853e20b0e07173b $
+ * Version:	$Id: 9c7d8f81b24003f027facbf91cd2c56e4aba4a98 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2008  Alan DeKok <aland@deployingradius.com>
  */
 
-RCSID("$Id: 64cbafea931f9e807cfa50984853e20b0e07173b $")
+RCSID("$Id: 9c7d8f81b24003f027facbf91cd2c56e4aba4a98 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -261,21 +261,25 @@ void request_stats_final(REQUEST *reques
 	switch (request->proxy->code) {
 	case PW_CODE_ACCESS_REQUEST:
 		proxy_auth_stats.total_requests += request->num_proxied_requests;
+		request->home_server->stats.total_requests += request->num_proxied_requests;
 		break;
 
 #ifdef WITH_ACCOUNTING
 	case PW_CODE_ACCOUNTING_REQUEST:
 		proxy_acct_stats.total_requests += request->num_proxied_requests;
+		request->home_server->stats.total_requests += request->num_proxied_requests;
 		break;
 #endif
 
 #ifdef WITH_COA
 	case PW_CODE_COA_REQUEST:
 		proxy_coa_stats.total_requests += request->num_proxied_requests;
+		request->home_server->stats.total_requests += request->num_proxied_requests;
 		break;
 
 	case PW_CODE_DISCONNECT_REQUEST:
 		proxy_dsc_stats.total_requests += request->num_proxied_requests;
+		request->home_server->stats.total_requests += request->num_proxied_requests;
 		break;
 #endif
 
@@ -357,6 +361,7 @@ void request_stats_final(REQUEST *reques
  done:
 #endif /* WITH_PROXY */
 
+
 	if (request->max_time) {
 		switch (request->packet->code) {
 		case PW_CODE_ACCESS_REQUEST:
@@ -618,7 +623,7 @@ void request_stats_reply(REQUEST *reques
 		fr_ipaddr_t ipaddr;
 		VALUE_PAIR *server_ip, *server_port = NULL;
 		RADCLIENT *client = NULL;
-		RADCLIENT_LIST *cl = NULL;
+		RADCLIENT_LIST *cl =  NULL;
 
 		/*
 		 *	See if we need to look up the client by server
@@ -633,6 +638,10 @@ void request_stats_reply(REQUEST *reques
 				ipaddr.ipaddr.ip4addr.s_addr = server_ip->vp_ipaddr;
 				cl = listener_find_client_list(&ipaddr, server_port->vp_integer, IPPROTO_UDP);
 
+#ifdef WITH_TCP
+				if (!cl) cl = listener_find_client_list(&ipaddr, server_port->vp_integer, IPPROTO_TCP);
+#endif
+
 				/*
 				 *	Not found: don't do anything
 				 */
@@ -648,6 +657,10 @@ void request_stats_reply(REQUEST *reques
 					ipaddr.ipaddr.ip6addr = server_ip->vp_ipv6addr;
 					cl = listener_find_client_list(&ipaddr, server_port->vp_integer, IPPROTO_UDP);
 
+#ifdef WITH_TCP
+					if (!cl) cl = listener_find_client_list(&ipaddr, server_port->vp_integer, IPPROTO_TCP);
+#endif
+
 					/*
 					 *	Not found: don't do anything
 					 */
@@ -842,8 +855,8 @@ void request_stats_reply(REQUEST *reques
 	if (((flag->vp_integer & 0x80) != 0) &&		/* home-server */
 	    ((flag->vp_integer & 0x03) != 0)) {		/* auth or accounting */
 		home_server_t *home;
-		VALUE_PAIR *server_ip, *server_port;
-		fr_ipaddr_t ipaddr;
+		VALUE_PAIR *server_ip, *server_port, *server_src_ip;
+		fr_ipaddr_t ipaddr, src_ipaddr;
 
 		server_port = fr_pair_find_by_num(request->packet->vps, PW_FREERADIUS_STATS_SERVER_PORT, VENDORPEC_FREERADIUS, TAG_ANY);
 		if (!server_port) {
@@ -874,12 +887,32 @@ void request_stats_reply(REQUEST *reques
 			return;
 		}
 
+		memset(&src_ipaddr, 0, sizeof(src_ipaddr));
+		src_ipaddr.af = ipaddr.af;
+
+		if (ipaddr.af == AF_INET) {
+			server_src_ip = fr_pair_find_by_num(request->packet->vps, PW_FREERADIUS_STATS_SERVER_SRC_IP_ADDRESS, VENDORPEC_FREERADIUS, TAG_ANY);
+			if (server_src_ip) {
+				src_ipaddr.prefix = 32;
+				src_ipaddr.ipaddr.ip4addr.s_addr = server_src_ip->vp_ipaddr;
+			}
+#ifdef AF_INET6
+		} else if (ipaddr.af == AF_INET6) {
+			server_src_ip = fr_pair_find_by_num(request->packet->vps, PW_FREERADIUS_STATS_SERVER_SRC_IPV6_ADDRESS, VENDORPEC_FREERADIUS, TAG_ANY);
+			if (server_src_ip) {
+				src_ipaddr.af = AF_INET6;
+				src_ipaddr.ipaddr.ip6addr = server_src_ip->vp_ipv6addr;
+#endif	/* AF_INET6 */
+			}
+		}
+
+
 		/*
 		 *	Not found: don't do anything
 		 */
-		home = home_server_find(&ipaddr, server_port->vp_integer, IPPROTO_UDP);
+		home = home_server_find_bysrc(&ipaddr, server_port->vp_integer, IPPROTO_UDP, &src_ipaddr);
 #ifdef WITH_TCP
-		if (!home) home = home_server_find(&ipaddr, server_port->vp_integer, IPPROTO_TCP);
+		if (!home) home = home_server_find_bysrc(&ipaddr, server_port->vp_integer, IPPROTO_TCP, &src_ipaddr);
 #endif
 		if (!home) {
 			stats_error(request, "Failed to find home server IP");
diff -urpN freeradius-server-3.2.6/src/main/threads.c freeradius-server-3.2.7/src/main/threads.c
--- freeradius-server-3.2.6/src/main/threads.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/threads.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * threads.c	request threading support
  *
- * Version:	$Id: 5730b5e8448e77a8c0bd8b37195f2070581f8b57 $
+ * Version:	$Id: 2075ba12ec742b3d25974fee00a86fc8b222d857 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2000  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: 5730b5e8448e77a8c0bd8b37195f2070581f8b57 $")
+RCSID("$Id: 2075ba12ec742b3d25974fee00a86fc8b222d857 $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include <freeradius-devel/radiusd.h>
@@ -136,6 +136,16 @@ typedef struct fr_pps_t {
 } fr_pps_t;
 #endif
 
+/*
+ *	In process.c, but no one else should be calling these
+ *	functions.
+ */
+extern void request_free(REQUEST *request);
+extern void request_done(REQUEST *request, int original);
+
+#ifndef HAVE_STDATOMIC_H
+static int request_fifo_discard(int priority, bool lower, time_t now);
+#endif
 
 /*
  *	A data structure to manage the thread pool.  There's no real
@@ -362,49 +372,63 @@ static void reap_children(void)
 int request_enqueue(REQUEST *request)
 {
 	bool managed = false;
+	time_t now;
 
 	rad_assert(pool_initialized == true);
 
 	/*
+	 *	Proxied packets get requeued when they time out, or
+	 *	when they get a reply.  We want to use "now" as the
+	 *	time, and not the time 5-10 seconds in the past when
+	 *	we originally received the request.
+	 */
+	if (request->priority == RAD_LISTEN_PROXY) {
+		now = time(NULL);
+	} else {
+		now = request->timestamp;
+	}
+
+	/*
 	 *	If we haven't checked the number of child threads
 	 *	in a while, OR if the thread pool appears to be full,
 	 *	go manage it.
 	 */
-	if (last_cleaned < request->timestamp) {
-		thread_pool_manage(request->timestamp);
+	if (last_cleaned < now) {
+		thread_pool_manage(now);
 		managed = true;
 	}
 
+	/*
+	 *	Update the request state.
+	 */
+	request->component = "<core>";
+	request->module = "<queue>";
+	request->child_state = REQUEST_QUEUED;
+
 #ifdef HAVE_STDATOMIC_H
 	if (!managed) {
 		uint32_t num;
 
 		num = load(thread_pool.active_threads);
 		if (num == thread_pool.total_threads) {
-			thread_pool_manage(request->timestamp);
+			thread_pool_manage(now);
 			managed = true;
 		}
 
 		if (!managed) {
 			num = load(thread_pool.exited_threads);
 			if (num > 0) {
-				thread_pool_manage(request->timestamp);
+				thread_pool_manage(now);
 			}
 		}
 	}
 
 	/*
-	 *	Use atomic queues where possible.  They're substantially faster than mutexes.
-	 */
-	request->component = "<core>";
-	request->module = "<queue>";
-	request->child_state = REQUEST_QUEUED;
-
-	/*
 	 *	Push the request onto the appropriate fifo for that
 	 */
 	if (!fr_atomic_queue_push(thread_pool.queue[request->priority], request)) {
-		ERROR("!!! ERROR !!! Failed inserting request %d into the queue", request->number);
+		RATE_LIMIT(ERROR("Something is blocking the server.  There are too many packets in the queue, "
+				 "waiting to be processed.  Ignoring the new request."));
 		return 0;
 	}
 
@@ -413,7 +437,7 @@ int request_enqueue(REQUEST *request)
 	if (!managed && 
 	    ((thread_pool.active_threads == thread_pool.total_threads) ||
 	     (thread_pool.exited_threads > 0))) {
-		thread_pool_manage(request->timestamp);
+		thread_pool_manage(now);
 	}
 
 	pthread_mutex_lock(&thread_pool.queue_mutex);
@@ -421,7 +445,7 @@ int request_enqueue(REQUEST *request)
 #ifdef WITH_STATS
 #ifdef WITH_ACCOUNTING
 	if (thread_pool.auto_limit_acct) {
-		struct timeval now;
+		struct timeval when;
 
 		/*
 		 *	Throw away accounting requests if we're too
@@ -481,7 +505,7 @@ int request_enqueue(REQUEST *request)
 			}
 		}
 
-		gettimeofday(&now, NULL);
+		gettimeofday(&when, NULL);
 
 		/*
 		 *	Calculate the instantaneous arrival rate into
@@ -490,7 +514,7 @@ int request_enqueue(REQUEST *request)
 		thread_pool.pps_in.pps = rad_pps(&thread_pool.pps_in.pps_old,
 						 &thread_pool.pps_in.pps_now,
 						 &thread_pool.pps_in.time_old,
-						 &now);
+						 &when);
 
 		thread_pool.pps_in.pps_now++;
 	}
@@ -499,27 +523,28 @@ int request_enqueue(REQUEST *request)
 
 	thread_pool.request_count++;
 
-	if (thread_pool.num_queued >= thread_pool.max_queue_size) {
+	/*
+	 *	If there are too many packets _overall_, OR the
+	 *	destinatio fifo is full, then try to delete a lower
+	 *	priority one.
+	 */
+	if (((thread_pool.num_queued >= thread_pool.max_queue_size) &&
+	     (request_fifo_discard(request->priority, true, now) == 0)) ||
+	    (fr_fifo_full(thread_pool.fifo[request->priority]) &&
+	     (request_fifo_discard(request->priority, false, now) == 0))) {
 		pthread_mutex_unlock(&thread_pool.queue_mutex);
-
-		/*
-		 *	Mark the request as done.
-		 */
 		RATE_LIMIT(ERROR("Something is blocking the server.  There are %d packets in the queue, "
 				 "waiting to be processed.  Ignoring the new request.", thread_pool.num_queued));
 		return 0;
 	}
 
-	request->component = "<core>";
-	request->module = "<queue>";
-	request->child_state = REQUEST_QUEUED;
-
 	/*
-	 *	Push the request onto the appropriate fifo for that
+	 *	Push the request onto the appropriate fifo for that priority.
 	 */
 	if (!fr_fifo_push(thread_pool.fifo[request->priority], request)) {
 		pthread_mutex_unlock(&thread_pool.queue_mutex);
-		ERROR("!!! ERROR !!! Failed inserting request %d into the queue", request->number);
+		RATE_LIMIT(ERROR("Something is blocking the server.  There are too many packets in the queue, "
+				 "waiting to be processed.  Ignoring the new request."));
 		return 0;
 	}
 
@@ -542,6 +567,79 @@ int request_enqueue(REQUEST *request)
 	return 1;
 }
 
+#ifndef HAVE_STDATOMIC_H
+/*
+ *	Try to free up requests by discarding requests of lower priority.
+ */
+static int request_fifo_discard(int priority, bool lower, time_t now)
+{
+	int i, rcode;
+	REQUEST *request;
+
+	if (lower) {
+		for (i = NUM_FIFOS - 1; i < priority; i--) {
+			request = fr_fifo_pop(thread_pool.fifo[i]);
+			if (!request) continue;
+
+			fr_assert(request->child_state == REQUEST_QUEUED);
+			request->child_state = REQUEST_DONE;
+			request_done(request, FR_ACTION_DONE);
+			return 1;
+		}
+
+		/*
+		 *	We didn't discard a lower priority entry.
+		 *	Maybe we need to discard one of the current
+		 *	priority, which has been in the queue for a
+		 *	while.
+		 */
+	}
+
+	/*
+	 *	The time stamp for proxied requests may be 5-10
+	 *	seconds in the past, because the home server hasn't
+	 *	responded.  We therefore can't discard "old" requests,
+	 *	as they have just received a reply, or they have just
+	 *	timed out.
+	 */
+	if (priority <= RAD_LISTEN_PROXY) return 0;
+
+	/*
+	 *	Peek at the first entry in the fifo.  Note that there
+	 *	is not always a first entry.  This is because we're
+	 *	called if there are too many _total_ requests.
+	 */
+	rcode = 0;
+
+retry:
+	request = fr_fifo_peek(thread_pool.fifo[priority]);
+	if (!request) return rcode;
+
+	/*
+	 *	This request expires in the future.  We can't do anything.
+	 */
+	if ((request->timestamp + main_config.max_request_time) > now) return rcode;
+
+	request = fr_fifo_pop(thread_pool.fifo[priority]);
+	rad_assert(request != NULL);
+	VERIFY_REQUEST(request);
+
+	request->child_state = REQUEST_DONE;
+	if (request->master_state == REQUEST_TO_FREE) {
+		request_free(request);
+	} else {
+		request_done(request, REQUEST_DONE);
+	}
+	thread_pool.num_queued--;
+
+	/*
+	 *	We might as well delete as many old requests as possible.
+	 */
+	rcode = 1;
+	goto retry;
+}
+#endif
+
 /*
  *	Remove a request from the queue.
  */
@@ -575,8 +673,32 @@ retry:
 
 		/*
 		 *	This entry was marked to be stopped.  Acknowledge it.
+		 *
+		 *	If we own the request, we delete it. Otherwise
+		 *	we run the "done" callback now, which will
+		 *	stop timers, remove it from the request hash,
+		 *	update listener counts, etc.
+		 *
+		 *	Running request_done() here means that old
+		 *	requests are cleaned up immediately, which
+		 *	frees up more resources for new requests.  It
+		 *	also means that we don't need to rely on
+		 *	timers to free up the old requests, as those
+		 *	timers will run much much later.
+		 *
+		 *	Catching this corner case doesn't change the
+		 *	normal operation of the server.  Most requests
+		 *	should NOT be marked "stop processing" when
+		 *	they're in the queue.  This situation
+		 *	generally happens when the server is blocked,
+		 *	due to a slow back-end database.
 		 */
 		request->child_state = REQUEST_DONE;
+		if (request->master_state == REQUEST_TO_FREE) {
+			request_free(request);
+		} else {
+			request_done(request, REQUEST_DONE);
+		}
 	}
 
 	/*
@@ -631,7 +753,13 @@ retry:
 		request = fr_fifo_pop(thread_pool.fifo[i]);
 		rad_assert(request != NULL);
 		VERIFY_REQUEST(request);
+
 		request->child_state = REQUEST_DONE;
+		if (request->master_state == REQUEST_TO_FREE) {
+			request_free(request);
+		} else {
+			request_done(request, REQUEST_DONE);
+		}
 		thread_pool.num_queued--;
 	}
 
@@ -663,6 +791,7 @@ retry:
 
 	rad_assert(*prequest != NULL);
 	rad_assert(request->magic == REQUEST_MAGIC);
+	rad_assert(request->child_state == REQUEST_QUEUED);
 
 	request->component = "<core>";
 	request->module = "";
@@ -1196,10 +1325,30 @@ int thread_pool_init(CONF_SECTION *cs, b
 }
 DIAG_ON(deprecated-declarations)
 
+void thread_pool_stop(void)
+{
+	int i, total_threads;
+
+	if (!pool_initialized) return;
+
+	/*
+	 *	Set pool stop flag.
+	 */
+	thread_pool.stop_flag = true;
+
+	/*
+	 *	Wakeup all threads to make them see stop flag.
+	 */
+	total_threads = thread_pool.total_threads;
+	for (i = 0; i != total_threads; i++) {
+		sem_post(&thread_pool.semaphore);
+	}
+}
+
 /*
- *	Stop all threads in the pool.
+ *	Free all thread-related information
  */
-void thread_pool_stop(void)
+void thread_pool_free(void)
 {
 #ifndef WITH_GCD
 	int i;
@@ -1231,6 +1380,19 @@ void thread_pool_stop(void)
 		delete_thread(handle);
 	}
 
+	/*
+	 *	Free any requests which were blocked in the queue, but
+	 *	only if we're checking that no memory leaked.
+	 */
+	if (main_config.memory_report) {
+		REQUEST *request;
+
+		while (request_dequeue(&request) == 1) {
+			request->child_state = REQUEST_DONE;
+			request_free(request);
+		}
+	}
+
 	for (i = 0; i < NUM_FIFOS; i++) {
 #ifdef HAVE_STDATOMIC_H
 		fr_atomic_queue_free(&thread_pool.queue[i]);
diff -urpN freeradius-server-3.2.6/src/main/tls.c freeradius-server-3.2.7/src/main/tls.c
--- freeradius-server-3.2.6/src/main/tls.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/tls.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * tls.c
  *
- * Version:     $Id: 736ee4182e786621d03c4ba46400529e45cdc279 $
+ * Version:     $Id: 2a348eb9bb8058a5682243d09ab7c958ace32f7f $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
  * Copyright 2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: 736ee4182e786621d03c4ba46400529e45cdc279 $")
+RCSID("$Id: 2a348eb9bb8058a5682243d09ab7c958ace32f7f $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include <freeradius-devel/radiusd.h>
@@ -45,7 +45,6 @@ USES_APPLE_DEPRECATED_API	/* OpenSSL API
 #ifdef HAVE_UTIME_H
 #include <utime.h>
 #endif
-#include <ctype.h>
 
 #ifdef WITH_TLS
 #  ifdef HAVE_OPENSSL_RAND_H
@@ -358,113 +357,6 @@ int tls_error_io_log(REQUEST *request, t
 }
 
 #ifdef PSK_MAX_IDENTITY_LEN
-static bool identity_is_safe(const char *identity)
-{
-	char c;
-
-	if (!identity) return true;
-
-	while ((c = *(identity++)) != '\0') {
-		if (isalpha((uint8_t) c) || isdigit((uint8_t) c) || isspace((uint8_t) c) ||
-		    (c == '@') || (c == '-') || (c == '_') || (c == '.')) {
-			continue;
-		}
-
-		return false;
-	}
-
-	return true;
-}
-
-/*
- *	When a client uses TLS-PSK to talk to a server, this callback
- *	is used by the server to determine the PSK to use.
- */
-static unsigned int psk_server_callback(SSL *ssl, const char *identity,
-					unsigned char *psk,
-					unsigned int max_psk_len)
-{
-	unsigned int psk_len = 0;
-	fr_tls_server_conf_t *conf;
-	REQUEST *request;
-
-	conf = (fr_tls_server_conf_t *)SSL_get_ex_data(ssl,
-						       FR_TLS_EX_INDEX_CONF);
-	if (!conf) return 0;
-
-	request = (REQUEST *)SSL_get_ex_data(ssl,
-					     FR_TLS_EX_INDEX_REQUEST);
-	if (request && conf->psk_query) {
-		size_t hex_len;
-		VALUE_PAIR *vp, **certs;
-		TALLOC_CTX *talloc_ctx;
-		char buffer[2 * PSK_MAX_PSK_LEN + 4]; /* allow for too-long keys */
-
-		/*
-		 *	The passed identity is weird.  Deny it.
-		 */
-		if (!identity_is_safe(identity)) {
-			RWDEBUG("(TLS) %s - Invalid characters in PSK identity %s", conf->name, identity);
-			return 0;
-		}
-
-		vp = pair_make_request("TLS-PSK-Identity", identity, T_OP_SET);
-		if (!vp) return 0;
-
-		certs = (VALUE_PAIR **)SSL_get_ex_data(ssl, fr_tls_ex_index_certs);
-		talloc_ctx = SSL_get_ex_data(ssl, FR_TLS_EX_INDEX_TALLOC);
-		fr_assert(certs != NULL); /* pointer to sock->certs */
-		fr_assert(talloc_ctx != NULL); /* sock */
-
-		fr_pair_add(certs, fr_pair_copy(talloc_ctx, vp));
-
-		hex_len = radius_xlat(buffer, sizeof(buffer), request, conf->psk_query,
-				      NULL, NULL);
-		if (!hex_len) {
-			RWDEBUG("(TLS) %s - PSK expansion returned an empty string.", conf->name);
-			return 0;
-		}
-
-		/*
-		 *	The returned key is truncated at MORE than
-		 *	OpenSSL can handle.  That way we can detect
-		 *	the truncation, and complain about it.
-		 */
-		if (hex_len > (2 * max_psk_len)) {
-			RWDEBUG("(TLS) %s - Returned PSK is too long (%u > %u)", conf->name,
-				(unsigned int) hex_len, 2 * max_psk_len);
-			return 0;
-		}
-
-		/*
-		 *	Leave the TLS-PSK-Identity in the request, and
-		 *	convert the expansion from printable string
-		 *	back to hex.
-		 */
-		return fr_hex2bin(psk, max_psk_len, buffer, hex_len);
-	}
-
-	if (!conf->psk_identity) {
-		DEBUG("No static PSK identity set.  Rejecting the user");
-		return 0;
-	}
-
-	/*
-	 *	No REQUEST, or no dynamic query.  Just look for a
-	 *	static identity.
-	 */
-	if (strcmp(identity, conf->psk_identity) != 0) {
-		ERROR("(TKS) Supplied PSK identity %s does not match configuration.  Rejecting.",
-		      identity);
-		return 0;
-	}
-
-	psk_len = strlen(conf->psk_password);
-	if (psk_len > (2 * max_psk_len)) return 0;
-
-	return fr_hex2bin(psk, max_psk_len, conf->psk_password, psk_len);
-}
-
 static unsigned int psk_client_callback(SSL *ssl, UNUSED char const *hint,
 					char *identity, unsigned int max_identity_len,
 					unsigned char *psk, unsigned int max_psk_len)
@@ -1248,7 +1140,7 @@ static unsigned int record_minus(record_
 
 void tls_session_information(tls_session_t *tls_session)
 {
-	char const *str_write_p, *str_version, *str_content_type = "";
+	char const *str_write_p, *str_version, *str_content_type;
 	char const *str_details1 = "", *str_details2= "";
 	char const *details = NULL;
 	REQUEST *request;
@@ -1416,6 +1308,9 @@ void tls_session_information(tls_session
 
 				case SSL3_AD_ILLEGAL_PARAMETER:
 					str_details2 = " illegal_parameter";
+					if (tls_session->conf->psk_identity || tls_session->conf->psk_query) {
+						details = "the client and server have different values for the PSK";
+					}
 					break;
 
 				case TLS1_AD_UNKNOWN_CA:
@@ -2614,23 +2509,28 @@ static int ocsp_parse_cert_url(X509 *cer
 			       char **path_out, int *is_https)
 {
 	int			i;
-	bool			found_uri = false;
 
 	AUTHORITY_INFO_ACCESS	*aia;
 	ACCESS_DESCRIPTION	*ad;
+	int			ret = -1;
 
 	aia = X509_get_ext_d2i(cert, NID_info_access, NULL, NULL);
 
+	if (!aia) return 0;
+
 	for (i = 0; i < sk_ACCESS_DESCRIPTION_num(aia); i++) {
 		ad = sk_ACCESS_DESCRIPTION_value(aia, i);
 		if (OBJ_obj2nid(ad->method) != NID_ad_OCSP) continue;
 		if (ad->location->type != GEN_URI) continue;
-		found_uri = true;
 
 		if (OCSP_parse_url((char *) ad->location->d.ia5->data, host_out,
-				   port_out, path_out, is_https)) return 1;
+				   port_out, path_out, is_https)) {
+			ret = 1;
+			break;
+		}
 	}
-	return found_uri ? -1 : 0;
+	AUTHORITY_INFO_ACCESS_free(aia);
+	return ret;
 }
 
 /*
@@ -2709,7 +2609,7 @@ static ocsp_status_t ocsp_check(REQUEST
 		switch (ret) {
 		case -1:
 			RWDEBUG("(TLS) ocsp: Invalid URL in certificate.  Not doing OCSP");
-			break;
+			goto skipped;
 
 		case 0:
 			if (conf->ocsp_url) {
@@ -2821,7 +2721,7 @@ static ocsp_status_t ocsp_check(REQUEST
 	}
 	bresp = OCSP_response_get1_basic(resp);
 	if (!bresp) {
-		RDEBUG("ocsp: Failed parsing response");
+		tls_error_log(request, "ocsp: Failed parsing response");
 		goto ocsp_end;
 	}
 
@@ -2830,13 +2730,13 @@ static ocsp_status_t ocsp_check(REQUEST
 		goto ocsp_end;
 	}
 	if (OCSP_basic_verify(bresp, untrusted, store, 0)!=1){
-		REDEBUG("ocsp: Couldn't verify OCSP basic response");
+		tls_error_log(request, "ocsp: Couldn't verify OCSP basic response");
 		goto ocsp_end;
 	}
 
 	/*	Verify OCSP cert status */
 	if (!OCSP_resp_find_status(bresp, certid, &status, &reason, &rev, &thisupd, &nextupd)) {
-		REDEBUG("ocsp: No Status found");
+		tls_error_log(request, "ocsp: No Status found");
 		goto ocsp_end;
 	}
 
@@ -2928,7 +2828,7 @@ ocsp_end:
 /*
  *	For creating certificate attributes.
  */
-static char const *cert_attr_names[9][2] = {
+static char const *cert_attr_names[11][2] = {
 	{ "TLS-Client-Cert-Serial",			"TLS-Cert-Serial" },
 	{ "TLS-Client-Cert-Expiration",			"TLS-Cert-Expiration" },
 	{ "TLS-Client-Cert-Subject",			"TLS-Cert-Subject" },
@@ -2937,7 +2837,9 @@ static char const *cert_attr_names[9][2]
 	{ "TLS-Client-Cert-Subject-Alt-Name-Email",	"TLS-Cert-Subject-Alt-Name-Email" },
 	{ "TLS-Client-Cert-Subject-Alt-Name-Dns",	"TLS-Cert-Subject-Alt-Name-Dns" },
 	{ "TLS-Client-Cert-Subject-Alt-Name-Upn",	"TLS-Cert-Subject-Alt-Name-Upn" },
-	{ "TLS-Client-Cert-Valid-Since",		"TLS-Cert-Valid-Since" }
+	{ "TLS-Client-Cert-Valid-Since",		"TLS-Cert-Valid-Since" },
+	{ "TLS-Client-Cert-Subject-Alt-Name-Uri",	"TLS-Cert-Subject-Alt-Name-Uri" },
+	{ "TLS-Client-Cert-CRL-Distribution-Points",	"TLS-Cert-CRL-Distribution-Points"},
 };
 
 #define FR_TLS_SERIAL		(0)
@@ -2949,6 +2851,37 @@ static char const *cert_attr_names[9][2]
 #define FR_TLS_SAN_DNS          (6)
 #define FR_TLS_SAN_UPN          (7)
 #define FR_TLS_VALID_SINCE	(8)
+#define FR_TLS_SAN_URI		(9)
+#define FR_TLS_CDP		(10)
+
+/*
+ *	Extract Certification Distribution point URL from the certificate
+ */
+static const char *get_cdp_url(DIST_POINT *dp)
+{
+	GENERAL_NAMES *gens;
+	GENERAL_NAME *gen;
+	int i, gtype;
+	ASN1_STRING *uri;
+
+	if (!dp->distpoint || (dp->distpoint->type != 0)) {
+		return NULL;
+	}
+
+	gens = dp->distpoint->name.fullname;
+
+	for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
+		gen = sk_GENERAL_NAME_value(gens, i);
+		uri = GENERAL_NAME_get0_value(gen, &gtype);
+
+		if ((gtype == GEN_URI) && (ASN1_STRING_length(uri) > 6)) {
+			return (const char *) ASN1_STRING_get0_data(uri);
+		}
+	}
+
+	return NULL;
+}
+
 
 /*
  *	Before trusting a certificate, you must make sure that the
@@ -3006,6 +2939,7 @@ int cbtls_verify(int ok, X509_STORE_CTX
 #endif
 	VALUE_PAIR	*vp;
 	TALLOC_CTX	*talloc_ctx;
+	STACK_OF(DIST_POINT) *crl_dp;
 
 	REQUEST		*request;
 
@@ -3141,6 +3075,35 @@ int cbtls_verify(int ok, X509_STORE_CTX
 	}
 
 	/*
+	 *	Get the Certificate Distribution points
+	 */
+	crl_dp = X509_get_ext_d2i(client_cert, NID_crl_distribution_points, NULL, NULL);
+	if (crl_dp) {
+		DIST_POINT *dp;
+		const char *url_ptr;
+
+		for (int i = 0; i < sk_DIST_POINT_num(crl_dp); i++) {
+			size_t len;
+			char cdp[1024];
+
+			dp = sk_DIST_POINT_value(crl_dp, i);
+			if (!dp) continue;
+
+			url_ptr = get_cdp_url(dp);
+			if (!url_ptr) continue;
+
+			len = strlen(url_ptr);
+			if (len >= sizeof(cdp)) continue;
+
+			memcpy(cdp, url_ptr, len + 1);
+
+			vp = fr_pair_make(talloc_ctx, certs, cert_attr_names[FR_TLS_CDP][lookup], cdp, T_OP_ADD);
+			rdebug_pair(L_DBG_LVL_2, request, vp, NULL);
+		}
+		sk_DIST_POINT_pop_free(crl_dp, DIST_POINT_free);
+	}
+
+	/*
 	 *	Get the RFC822 Subject Alternative Name
 	 */
 	loc = X509_get_ext_by_NID(client_cert, NID_subject_alt_name, -1);
@@ -3186,6 +3149,13 @@ int cbtls_verify(int ok, X509_STORE_CTX
 					}
 					break;
 #endif	/* GEN_OTHERNAME */
+#ifdef GEN_URI
+				case GEN_URI:
+					vp = fr_pair_make(talloc_ctx, certs, cert_attr_names[FR_TLS_SAN_URI][lookup],
+						      (char const *) ASN1_STRING_get0_data(name->d.uniformResourceIdentifier), T_OP_SET);
+					rdebug_pair(L_DBG_LVL_2, request, vp, NULL);
+					break;
+#endif /* GEN_URI */
 				default:
 					/* XXX TODO handle other SAN types */
 					break;
@@ -3367,25 +3337,29 @@ int cbtls_verify(int ok, X509_STORE_CTX
 		tls_session_t *ssn = SSL_get_ex_data(ssl, FR_TLS_EX_INDEX_SSN);
 #if OPENSSL_VERSION_NUMBER >= 0x10100000L
 		STACK_OF(X509)* untrusted = NULL;
+		int num_untrusted = X509_STORE_CTX_get_num_untrusted(ctx);
 #endif
 
 		rad_assert(ssn != NULL);
 
 #if OPENSSL_VERSION_NUMBER >= 0x10100000L
 		/*
-		 *	See if there are any untrusted certificates.
-		 *	If so, complain about them.
+		 *	"Untrusted" certificates are those presented by the client
+		 *	so we always expect there to be one.
+		 *
+		 *	If there's more than one, then the client is presenting
+		 *	intermediate CAs as well.
 		 */
-		untrusted = X509_STORE_CTX_get0_untrusted(ctx);
-		if (untrusted) {
+		if (num_untrusted > 1) {
+			untrusted = X509_STORE_CTX_get0_untrusted(ctx);
 			if (conf->disallow_untrusted || RDEBUG_ENABLED2) {
 				int  i;
 
 				WARN("Certificate chain - %i intermediate CA cert(s) untrusted",
-				     X509_STORE_CTX_get_num_untrusted(ctx));
-				WARN("To forbid these certificates see 'reject_unknown_intermediate_ca'");
+				     num_untrusted - 1);
+				if (!conf->disallow_untrusted) WARN("To forbid these certificates set 'reject_unknown_intermediate_ca'");
 
-				for (i = sk_X509_num(untrusted); i > 0 ; i--) {
+				for (i = num_untrusted; i > 1 ; i--) {
 					X509 *this_cert = sk_X509_value(untrusted, i - 1);
 
 					X509_NAME_oneline(X509_get_subject_name(this_cert), subject, sizeof(subject));
@@ -3669,6 +3643,10 @@ int tls_global_init(TLS_UNUSED bool spaw
 	OpenSSL_add_all_algorithms();	/* required for SHA2 in OpenSSL < 0.9.8o and 1.0.0.a */
 	CONF_modules_load_file(NULL, NULL, 0);
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+	EVP_set_default_properties(NULL, "fips=no");
+#endif
+
 	/*
 	 *	Initialize the index for the certificates.
 	 */
@@ -3940,7 +3918,7 @@ SSL_CTX *tls_init_ctx(fr_tls_server_conf
 		}
 
 		if (conf->psk_password && *conf->psk_password) {
-			ERROR(LOG_PREFIX ": Invalid PSK Configuration: psk_password and psk_query cannot be used at the same time.");
+			ERROR(LOG_PREFIX ": Invalid PSK Configuration: psk_hexphrase and psk_query cannot be used at the same time.");
 			return NULL;
 		}
 
@@ -3960,12 +3938,12 @@ SSL_CTX *tls_init_ctx(fr_tls_server_conf
 
 
 		if (!conf->psk_password || !*conf->psk_password) {
-			ERROR(LOG_PREFIX ": Invalid PSK Configuration: psk_identity is set, but there is no psk_password");
+			ERROR(LOG_PREFIX ": Invalid PSK Configuration: psk_identity is set, but there is no psk_hexphrase");
 			return NULL;
 		}
 
 	} else if (conf->psk_password) {
-		ERROR(LOG_PREFIX ": Invalid PSK Configuration: psk_password is set, but there is no psk_identity");
+		ERROR(LOG_PREFIX ": Invalid PSK Configuration: psk_hexphrase is set, but there is no psk_identity");
 		return NULL;
 	}
 
@@ -3974,6 +3952,9 @@ SSL_CTX *tls_init_ctx(fr_tls_server_conf
 	 */
 	if (!client && (conf->psk_identity || conf->psk_query)) {
 		SSL_CTX_set_psk_server_callback(ctx, psk_server_callback);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000
+		SSL_CTX_set_psk_find_session_callback(ctx, cbtls_psk_find_session);
+#endif
 	}
 
 	/*
@@ -4769,7 +4750,7 @@ static int tls_realms_load(fr_tls_server
 		    S_ISDIR(stat_buf.st_mode)) continue;
 
 		strcpy(buffer2, buffer);
-		p = strchr(buffer2, '.'); /* which must be there... */
+		p = strrchr(buffer2, '.'); /* which must be there... */
 		if (!p) continue;
 
 		/*
@@ -4778,7 +4759,7 @@ static int tls_realms_load(fr_tls_server
 		 *	the chain file.
 		 */
 		strcpy(p, ".key");
-		if (stat(buffer2, &stat_buf) != 0) private_key_file = buffer2;
+		if (stat(buffer2, &stat_buf) == 0) private_key_file = buffer2;
 
 		ctx = tls_init_ctx(conf, 1, buffer, private_key_file);
 		if (!ctx) goto error;
@@ -4847,7 +4828,7 @@ fr_tls_server_conf_t *tls_server_conf_pa
 	 *	PSK query.
 	 */
 #ifdef PSK_MAX_IDENTITY_LEN
-	if (conf->psk_identity) {
+	if (conf->psk_identity || conf->psk_query) {
 		if (conf->private_key_file) {
 			WARN(LOG_PREFIX ": Ignoring private key file due to psk_identity being used");
 		}
@@ -5444,4 +5425,3 @@ fr_tls_status_t tls_ack_handler(tls_sess
 	}
 }
 #endif	/* WITH_TLS */
-
diff -urpN freeradius-server-3.2.6/src/main/tls_listen.c freeradius-server-3.2.7/src/main/tls_listen.c
--- freeradius-server-3.2.6/src/main/tls_listen.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/tls_listen.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * tls.c
  *
- * Version:     $Id: 6d4e1c351ce8d9fb547d1b15cc61371e21c83710 $
+ * Version:     $Id: d22972957934794e60fc03b492a61c97377d8327 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
  * Copyright 2006  The FreeRADIUS server project
  */
 
-RCSID("$Id: 6d4e1c351ce8d9fb547d1b15cc61371e21c83710 $")
+RCSID("$Id: d22972957934794e60fc03b492a61c97377d8327 $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include <freeradius-devel/radiusd.h>
@@ -51,6 +51,8 @@ USES_APPLE_DEPRECATED_API	/* OpenSSL API
 #define PTHREAD_MUTEX_UNLOCK(_x)
 #endif
 
+#define LOG_PREFIX "TLS"
+
 static void dump_hex(char const *msg, uint8_t const *data, size_t data_len)
 {
 	size_t i;
@@ -72,8 +74,9 @@ static void dump_hex(char const *msg, ui
 static void tls_socket_close(rad_listen_t *listener)
 {
 	listen_socket_t *sock = listener->data;
+	REQUEST *request = sock->request;
 
-	SSL_shutdown(sock->ssn->ssl);
+	if (!sock->client_closed) SSL_shutdown(sock->ssn->ssl);
 
 	listener->status = RAD_LISTEN_STATUS_EOL;
 	listener->tls = NULL; /* parent owns this! */
@@ -81,7 +84,7 @@ static void tls_socket_close(rad_listen_
 	/*
 	 *	Tell the event handler that an FD has disappeared.
 	 */
-	DEBUG("(TLS) Closing connection");
+	ROPTIONAL(RDEBUG3, DEBUG3, "(TLS) Closing connection");
 	radius_update_listener(listener);
 
 	/*
@@ -125,7 +128,6 @@ static int CC_HINT(nonnull) tls_socket_w
 
 
 		ERROR("(TLS) Error writing to socket: %s", fr_syserror(errno));
-
 		tls_socket_close(listener);
 		return -1;
 	}
@@ -520,7 +522,7 @@ static int tls_socket_recv(rad_listen_t
 			     sizeof(sock->ssn->dirty_in.data));
 		if ((rcode < 0) && (errno == ECONNRESET)) {
 		do_close:
-			DEBUG("(TLS) Closing socket from client port %u", sock->other_port);
+			RDEBUG("(TLS) Closing socket from client port %u", sock->other_port);
 			tls_socket_close(listener);
 			PTHREAD_MUTEX_UNLOCK(&sock->mutex);
 			return 0;
@@ -536,6 +538,7 @@ static int tls_socket_recv(rad_listen_t
 		 */
 		if (rcode == 0) {
 			RDEBUG("(TLS) Client has closed the TCP connection");
+			sock->client_closed = true;
 			goto do_close;
 		}
 
@@ -671,6 +674,7 @@ get_application_data:
 	 */
 	if (sock->state != LISTEN_TLS_RUNNING) {
 		RDEBUG3("(TLS) Holding application data until setup is complete");
+		PTHREAD_MUTEX_UNLOCK(&sock->mutex);
 		return 0;
 	}
 
@@ -687,12 +691,14 @@ read_application_data:
 	if (sock->ssn->clean_out.used < 20) {
 		RDEBUG3("(TLS) Received partial packet (have %zu, want >=20), waiting for more.",
 			sock->ssn->clean_out.used);
+		PTHREAD_MUTEX_UNLOCK(&sock->mutex);
 		return 0;
 	}
 
 	if (((int) sock->ssn->clean_out.used) < ((sock->ssn->clean_out.data[2] << 8) | sock->ssn->clean_out.data[3])) {
 		RDEBUG3("(TLS) Received partial packet (have %zu, want %u), waiting for more.",
 			sock->ssn->clean_out.used, (sock->ssn->clean_out.data[2] << 8) | sock->ssn->clean_out.data[3]);
+		PTHREAD_MUTEX_UNLOCK(&sock->mutex);
 		return 0;
 	}
 
@@ -747,7 +753,6 @@ read_application_data:
 	return 1;
 }
 
-
 int dual_tls_recv(rad_listen_t *listener)
 {
 	RADIUS_PACKET *packet;
@@ -911,39 +916,42 @@ int dual_tls_send(rad_listen_t *listener
 	rad_assert(request->listener == listener);
 	rad_assert(listener->send == dual_tls_send);
 
-	if (listener->status != RAD_LISTEN_STATUS_KNOWN) return 0;
-
 	/*
-	 *	See if the policies allowed this connection.
+	 *	If the socket is vaguely alive, then write to it.
+	 *	Otherwise it's dead, and we don't do anything.
 	 */
-	if (sock->state == LISTEN_TLS_CHECKING) {
-		if (request->reply->code != PW_CODE_ACCESS_ACCEPT) {
-			RDEBUG("(TLS) Connection checks failed - closing connection");
-			listener->status = RAD_LISTEN_STATUS_EOL;
-			listener->tls = NULL; /* parent owns this! */
-
-			/*
-			 *	Tell the event handler that an FD has disappeared.
-			 */
-			radius_update_listener(listener);
-			return 0;
-		}
-
-		/*
-		 *	Resume reading from the listener.
-		 */
-		RDEBUG("(TLS) Connection checks succeeded - continuing with normal reads");
-		listener->status = RAD_LISTEN_STATUS_RESUME;
-		radius_update_listener(listener);
+	switch (listener->status) {
+	case RAD_LISTEN_STATUS_KNOWN:
+	case RAD_LISTEN_STATUS_FROZEN:
+	case RAD_LISTEN_STATUS_PAUSE:
+	case RAD_LISTEN_STATUS_RESUME:
+		break;
 
-		rad_assert(sock->request->packet != request->packet);
+	case RAD_LISTEN_STATUS_INIT:
+	case RAD_LISTEN_STATUS_EOL:
+	case RAD_LISTEN_STATUS_REMOVE_NOW:
+		return 0;
+	}
 
-		sock->state = LISTEN_TLS_SETUP;
-		(void) dual_tls_recv(listener);
+	/*
+	 *	We're trying to send a reply to the "check
+	 *	client connection" packet.  Instead, just
+	 *	finish the session setup.
+	 */
+	if (sock->state == LISTEN_TLS_SETUP) {
+		RDEBUG("(TLS) Finishing session setup");
 		return 0;
 	}
 
 	/*
+	 *	The code in rad_status_server() looks for this state,
+	 *	and either swaps it to LISTEN_TLS_SETUP, or else
+	 *	changes listener->status to EOL.  As a result, this
+	 *	state should never be reachable in the send() routine.
+	 */
+	fr_assert(sock->state != LISTEN_TLS_CHECKING);
+
+	/*
 	 *	Accounting reject's are silently dropped.
 	 *
 	 *	We do it here to avoid polluting the rest of the
diff -urpN freeradius-server-3.2.6/src/main/unittest.c freeradius-server-3.2.7/src/main/unittest.c
--- freeradius-server-3.2.6/src/main/unittest.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/unittest.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * unittest.c	Unit test wrapper for the RADIUS daemon.
  *
- * Version:	$Id: c82d31dcfa2233ac41477e41e95559a3c228e2a1 $
+ * Version:	$Id: feb72d6598abb0f1aff5a0a1f37637051701aeca $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  * Copyright 2013  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: c82d31dcfa2233ac41477e41e95559a3c228e2a1 $")
+RCSID("$Id: feb72d6598abb0f1aff5a0a1f37637051701aeca $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -72,6 +72,23 @@ void request_inject(UNUSED REQUEST *requ
 	/* do nothing */
 }
 
+/*
+ *	These are shared with threads.c, and nothing else.
+ */
+void request_free(REQUEST *request) CC_HINT(nonnull);
+void request_done(REQUEST *request, int original) CC_HINT(nonnull);
+
+void request_free(UNUSED REQUEST *request)
+{
+	/* do nothing */
+}
+
+void request_done(UNUSED REQUEST *request, UNUSED int original)
+{
+	/* do nothing */
+}
+
+
 #ifdef WITH_RADIUSV11
 int fr_radiusv11_client_init(UNUSED fr_tls_server_conf_t *tls);
 
diff -urpN freeradius-server-3.2.6/src/main/version.c freeradius-server-3.2.7/src/main/version.c
--- freeradius-server-3.2.6/src/main/version.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/main/version.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * version.c	Print version number and exit.
  *
- * Version:	$Id: c190337c1d553caf6847d8720e69067ea6f391fa $
+ * Version:	$Id: 44a6edc699e8cad9eb54e54e673bf6fd316e8505 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
  * Copyright 2000  Chris Parker <cparker@starnetusa.com>
  */
 
-RCSID("$Id: c190337c1d553caf6847d8720e69067ea6f391fa $")
+RCSID("$Id: 44a6edc699e8cad9eb54e54e673bf6fd316e8505 $")
 
 #include <freeradius-devel/radiusd.h>
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
@@ -57,7 +57,20 @@ int ssl_check_consistency(void)
 	ssl_linked = SSLeay();
 
 	/*
-	 *	Major and minor versions mismatch, that's bad.
+	 *	Major mismatch, that's bad.
+	 */
+	if ((ssl_linked & 0xff000000) != (ssl_built & 0xff000000)) goto mismatch;
+
+	/*
+	 *	For OpenSSL 3, the minor versions are API/ABI compatible.
+	 *
+	 *	https://openssl-library.org/policies/releasestrat/index.html
+	 */
+	if ((ssl_linked & 0xff000000) >= 0x30000000) return 0;
+
+	/*
+	 *	For other versions of OpenSSL, the minor versions have
+	 *	to match, too.
 	 */
 	if ((ssl_linked & 0xfff00000) != (ssl_built & 0xfff00000)) goto mismatch;
 
@@ -514,7 +527,11 @@ void version_init_numbers(CONF_SECTION *
 	snprintf(buffer, sizeof(buffer), "%i.%i.*", talloc_version_major(), talloc_version_minor());
 	version_add_number(cs, "talloc", buffer);
 
+#ifdef OPENSSL_FULL_VERSION_STR
+	version_add_number(cs, "ssl", OPENSSL_FULL_VERSION_STR);
+#else
 	version_add_number(cs, "ssl", ssl_version_num());
+#endif
 
 #if defined(HAVE_REGEX) && defined(HAVE_PCRE)
 	version_add_number(cs, "pcre", pcre_version());
diff -urpN freeradius-server-3.2.6/src/modules/rlm_couchbase/configure freeradius-server-3.2.7/src/modules/rlm_couchbase/configure
--- freeradius-server-3.2.6/src/modules/rlm_couchbase/configure	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_couchbase/configure	2025-01-31 18:42:21.000000000 +0700
@@ -3798,6 +3798,39 @@ fail="$fail couchbase.h"
 fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for lcb_t in couchbase.h" >&5
+$as_echo_n "checking for lcb_t in couchbase.h... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <libcouchbase/couchbase.h>
+int
+main ()
+{
+
+		lcb_t *instance;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fail="$fail lcb_t(couchbase-2.x)"
+
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+
 smart_try_dir="$libcouchbase_lib_dir"
 
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_couchbase/configure.ac freeradius-server-3.2.7/src/modules/rlm_couchbase/configure.ac
--- freeradius-server-3.2.6/src/modules/rlm_couchbase/configure.ac	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_couchbase/configure.ac	2025-01-31 18:42:21.000000000 +0700
@@ -180,6 +180,22 @@ if test "x$ac_cv_header_libcouchbase_cou
 	FR_MODULE_FAIL([couchbase.h])
 fi
 
+dnl # lcb_t is in couchbase v2, so if the system is v3 we can't build
+
+AC_MSG_CHECKING([for lcb_t in couchbase.h])
+AC_COMPILE_IFELSE(
+	[AC_LANG_PROGRAM([#include <libcouchbase/couchbase.h>], [[
+		lcb_t *instance;
+	]])],
+	[
+		AC_MSG_RESULT(yes)
+	],
+	[
+		AC_MSG_RESULT(no)
+		FR_MODULE_FAIL([lcb_t(couchbase-2.x)])
+	])
+
+
 dnl ############################################################
 dnl # Check for libcouchbase libraries
 dnl ############################################################
diff -urpN freeradius-server-3.2.6/src/modules/rlm_dpsk/rlm_dpsk.c freeradius-server-3.2.7/src/modules/rlm_dpsk/rlm_dpsk.c
--- freeradius-server-3.2.6/src/modules/rlm_dpsk/rlm_dpsk.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_dpsk/rlm_dpsk.c	2025-01-31 18:42:21.000000000 +0700
@@ -18,13 +18,13 @@
  */
 
 /**
- * $Id: 6ca43ee39c4122c8c618d8c76d4894d86904bdb9 $
+ * $Id: 35773056b3d080b3dff4e3f5a9a229dc645bca41 $
  * @file rlm_dpsk.c
  * @brief Dynamic PSK for WiFi
  *
  * @copyright 2023 Network RADIUS SAS (legal@networkradius.com)
  */
-RCSID("$Id: 6ca43ee39c4122c8c618d8c76d4894d86904bdb9 $")
+RCSID("$Id: 35773056b3d080b3dff4e3f5a9a229dc645bca41 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -121,6 +121,7 @@ typedef struct {
 struct rlm_dpsk_s {
 	char const		*xlat_name;
 	bool			ruckus;
+	bool			dynamic;
 
 	rbtree_t		*cache;
 
@@ -471,10 +472,11 @@ static rlm_rcode_t CC_HINT(nonnull) mod_
 
 	if (inst->filename && !psk) {
 		FR_TOKEN token;
-		char const *q;
+		char const *q, *filename;
 		char token_psk[256];
 		char token_mac[256];
 		char buffer[1024];
+		char filename_buffer[1024];
 
 		/*
 		 *	If there's a cached entry, we don't read the file.
@@ -485,18 +487,29 @@ static rlm_rcode_t CC_HINT(nonnull) mod_
 			goto make_digest;
 		}
 
-		RDEBUG3("Looking for PSK in file %s", inst->filename);
+		if (!inst->dynamic) {
+			filename = inst->filename;
+		} else {
+			if (radius_xlat(filename_buffer, sizeof(filename_buffer),
+					request, inst->filename, NULL, NULL) < 0) {
+				return RLM_MODULE_FAIL;
+			}
+
+			filename = filename_buffer;
+		}
 
-		fp = fopen(inst->filename, "r");
+		RDEBUG3("Looking for PSK in file %s", filename);
+
+		fp = fopen(filename, "r");
 		if (!fp) {
-			REDEBUG("Failed opening %s - %s", inst->filename, fr_syserror(errno));
+			REDEBUG("Failed opening %s - %s", filename, fr_syserror(errno));
 			return RLM_MODULE_FAIL;
 		}
 
 get_next_psk:
 		q = fgets(buffer, sizeof(buffer), fp);
 		if (!q) {
-			RDEBUG("Failed to find matching key in %s", inst->filename);
+			RDEBUG("Failed to find matching key in %s", filename);
 		fail:
 			fclose(fp);
 			return RLM_MODULE_FAIL;
@@ -507,19 +520,19 @@ get_next_psk:
 		 */
 		token = getstring(&q, token_identity, sizeof(token_identity), true);
 		if (token == T_INVALID) {
-			RDEBUG("%s[%d] Failed parsing identity", inst->filename, lineno);
+			RDEBUG("%s[%d] Failed parsing identity", filename, lineno);
 			goto fail;
 		}
 
 		if (*q != ',') {
-			RDEBUG("%s[%d] Failed to find ',' after identity", inst->filename, lineno);
+			RDEBUG("%s[%d] Failed to find ',' after identity", filename, lineno);
 			goto fail;
 		}
 		q++;
 
 		token = getstring(&q, token_psk, sizeof(token_psk), true);
 		if (token == T_INVALID) {
-			RDEBUG("%s[%d] Failed parsing PSK", inst->filename, lineno);
+			RDEBUG("%s[%d] Failed parsing PSK", filename, lineno);
 			goto fail;
 		}
 
@@ -528,7 +541,7 @@ get_next_psk:
 
 			token = getstring(&q, token_mac, sizeof(token_mac), true);
 			if (token == T_INVALID) {
-				RDEBUG("%s[%d] Failed parsing MAC", inst->filename, lineno);
+				RDEBUG("%s[%d] Failed parsing MAC", filename, lineno);
 				goto fail;
 			}
 
@@ -538,7 +551,7 @@ get_next_psk:
 			 */
 			if ((strlen(token_mac) != 12) ||
 			    (fr_hex2bin((uint8_t *) token_mac, 6, token_mac, 12) != 12)) {
-				RDEBUG("%s[%d] Failed parsing MAC", inst->filename, lineno);
+				RDEBUG("%s[%d] Failed parsing MAC", filename, lineno);
 				goto fail;
 			}
 
@@ -563,7 +576,7 @@ get_next_psk:
 		/*
 		 *	Generate the PMK using the SSID, this MAC, and the PSK we just read.
 		 */
-		RDEBUG3("%s[%d] Trying PSK %s", inst->filename, lineno, token_psk);
+		RDEBUG3("%s[%d] Trying PSK %s", filename, lineno, token_psk);
 		if (generate_pmk(request, inst, pmk, sizeof(pmk), ssid, s_mac, token_psk, strlen(token_psk)) == 0) {
 			RDEBUG("No &config:Pairwise-Master-Key or &config:Pre-Shared-Key found");
 			return RLM_MODULE_NOOP;
@@ -841,6 +854,8 @@ static int mod_bootstrap(CONF_SECTION *c
 		return -1;
 	}
 
+	inst->dynamic = inst->filename && (strchr(inst->filename, '%') != NULL);
+
 	return 0;
 }
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/eap.c freeradius-server-3.2.7/src/modules/rlm_eap/eap.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/eap.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/eap.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * eap.c    rfc2284 & rfc2869 implementation
  *
- * Version:     $Id: 5c0bba0c3b9a5fd1f33a27e5cbead952965dc361 $
+ * Version:     $Id: 08b7f539f7364e74ab7cee9fc8fe20b6027f066a $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -56,7 +56,7 @@
 
 #include <freeradius-devel/modpriv.h>
 
-RCSID("$Id: 5c0bba0c3b9a5fd1f33a27e5cbead952965dc361 $")
+RCSID("$Id: 08b7f539f7364e74ab7cee9fc8fe20b6027f066a $")
 
 #include "rlm_eap.h"
 #include <ctype.h>
@@ -382,18 +382,24 @@ eap_rcode_t eap_method_select(rlm_eap_t
 		 */
 		vp = fr_pair_find_by_num(handler->request->config, PW_EAP_TYPE, 0,
 			      TAG_ANY);
-		if (vp) next = vp->vp_integer;
+		if (vp) {
+			next = vp->vp_integer;
 
-		/*
-		 *	Ensure it's valid.
-		 */
-		if ((next < PW_EAP_MD5) ||
-		    (next >= PW_EAP_MAX_TYPES) ||
-		    (!inst->methods[next])) {
-			REDEBUG2("Tried to start unsupported EAP type %s (%d)",
-				 eap_type2name(next), next);
-
-			return EAP_INVALID;
+			/*
+			 *	Ensure it's valid.
+			 */
+			if ((next < PW_EAP_MD5) ||
+			    (next >= PW_EAP_MAX_TYPES) ||
+			    (!inst->methods[next])) {
+				REDEBUG2("Tried to start unsupported EAP type %s (%d)",
+					 eap_type2name(next), next);
+
+				return EAP_INVALID;
+			}
+
+			RDEBUG("Found &control:EAP-Type = %s", eap_type2name(next));
+		} else {
+			RDEBUG("Using default_eap_type = %s", eap_type2name(next));
 		}
 
 	do_initiate:
@@ -442,6 +448,7 @@ eap_rcode_t eap_method_select(rlm_eap_t
 			return EAP_INVALID;
 		}
 
+		RDEBUG("Found compatible type in NAK - EAP-Type = %s", eap_type2name(next));
 		goto do_initiate;
 
 		/*
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/libeap/eap_tls.c freeradius-server-3.2.7/src/modules/rlm_eap/libeap/eap_tls.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/libeap/eap_tls.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/libeap/eap_tls.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,8 +1,7 @@
-
 /*
  * eap_tls.c
  *
- * Version:     $Id: 3a915bc624d69b99a180bc4a86bfb2d85704754c $
+ * Version:     $Id: fe07ef18d4d032ee3764c1d1d16be2175d400dcf $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -39,7 +38,7 @@
  *
  */
 
-RCSID("$Id: 3a915bc624d69b99a180bc4a86bfb2d85704754c $")
+RCSID("$Id: fe07ef18d4d032ee3764c1d1d16be2175d400dcf $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include <assert.h>
@@ -102,6 +101,13 @@ tls_session_t *eaptls_session(eap_handle
 	SSL_set_ex_data(ssn->ssl, FR_TLS_EX_INDEX_SSN, (void *)ssn);
 	SSL_set_ex_data(ssn->ssl, FR_TLS_EX_INDEX_TALLOC, handler);
 
+	/*
+	 *	It makes no sense to do session resumption for TLS
+	 */
+	if (request->parent && request->parent->eap_inner_tunnel) {
+		ssn->allow_session_resumption = false;
+	}
+
 	return talloc_steal(handler, ssn); /* ssn */
 }
 
@@ -271,8 +277,8 @@ int eaptls_request(EAP_DS *eap_ds, tls_s
 	 *	This is included in the first fragment, and then never
 	 *	afterwards.
 	 */
-	if (start && ssn->outer_tlvs) {
-		for (vp = fr_cursor_init(&cursor, &ssn->outer_tlvs);
+	if (start && ssn->outer_tlvs_server) {
+		for (vp = fr_cursor_init(&cursor, &ssn->outer_tlvs_server);
 		     vp;
 		     vp = fr_cursor_next(&cursor)) {
 			if (vp->da->type != PW_TYPE_OCTETS) {
@@ -331,15 +337,15 @@ int eaptls_request(EAP_DS *eap_ds, tls_s
 
 	if (obit) {
 		nlen = 0;
-		for (vp = fr_cursor_init(&cursor, &ssn->outer_tlvs);
+		for (vp = fr_cursor_init(&cursor, &ssn->outer_tlvs_server);
 		     vp;
 		     vp = fr_cursor_next(&cursor)) {
 			if (vp->da->type != PW_TYPE_OCTETS) continue;
 			nlen += sizeof(ohdr) + vp->vp_length;
 		}
 
-		ssn->outer_tlvs_octets = talloc_array(ssn, uint8_t, olen);
-		if (!ssn->outer_tlvs_octets) return 0;
+		ssn->outer_tlvs_octets_server = talloc_array(ssn, uint8_t, olen);
+		if (!ssn->outer_tlvs_octets_server) return 0;
 
 		nlen = htonl(nlen);
 		memcpy(reply.data + lbit, &nlen, sizeof(nlen));
@@ -353,7 +359,7 @@ int eaptls_request(EAP_DS *eap_ds, tls_s
 	 */
 	if (obit) {
 		olen = 0;
-		for (vp = fr_cursor_init(&cursor, &ssn->outer_tlvs);
+		for (vp = fr_cursor_init(&cursor, &ssn->outer_tlvs_server);
 		     vp;
 		     vp = fr_cursor_next(&cursor)) {
 			if (vp->da->type != PW_TYPE_OCTETS) continue;
@@ -367,9 +373,9 @@ int eaptls_request(EAP_DS *eap_ds, tls_s
 			ohdr[1] = htons(vp->vp_length);
 
 			/* use by Crypto-Binding TLV */
-			memcpy(ssn->outer_tlvs_octets + olen, ohdr, sizeof(ohdr));
+			memcpy(ssn->outer_tlvs_octets_server + olen, ohdr, sizeof(ohdr));
 			olen += sizeof(ohdr);
-			memcpy(ssn->outer_tlvs_octets + olen, vp->vp_octets, vp->vp_length);
+			memcpy(ssn->outer_tlvs_octets_server + olen, vp->vp_octets, vp->vp_length);
 			olen += vp->vp_length;
 
 			memcpy(reply.data + lbit + obit + size, ohdr, sizeof(ohdr));
@@ -436,6 +442,7 @@ static fr_tls_status_t eaptls_verify(eap
 	eaptls_packet_t		*eaptls_packet, *eaptls_prev = NULL;
 	REQUEST			*request = handler->request;
 	size_t			frag_len;
+	uint32_t		olen = 0;
 
 	/*
 	 *	We don't check ANY of the input parameters.  It's all
@@ -500,6 +507,21 @@ static fr_tls_status_t eaptls_verify(eap
 		   (EAP_HEADER_LEN + (TLS_LENGTH_INCLUDED(eaptls_packet->flags) ? 6 : 2));
 
 	/*
+	 *	Get the total length of Outer TLVs.
+	 */
+	if (TLS_OUTER_TLV_INCLUDED(eaptls_packet->flags)) {
+		uint8_t const *p = eaptls_packet->data;
+
+		p += TLS_LENGTH_INCLUDED(eaptls_packet->flags) << 2;
+
+		memcpy(&olen, p, sizeof(olen));
+		olen = ntohl(olen);
+
+		fr_assert((4 + olen) <= frag_len); /* already checked in eap_vp2packet */
+		frag_len -= (olen + 4);
+	}
+
+	/*
 	 *	The L bit (length included) is set to indicate the
 	 *	presence of the four octet TLS Message Length field,
 	 *	and MUST be set for the first fragment of a fragmented
@@ -590,6 +612,18 @@ static fr_tls_status_t eaptls_verify(eap
 		tls_session->tls_record_in_recvd_len = frag_len;
 		RDEBUG2("(TLS) EAP Got all data (%zu bytes)", frag_len);
 		return FR_TLS_LENGTH_INCLUDED;
+
+	} else if (TLS_OUTER_TLV_INCLUDED(eaptls_packet->flags)) {
+		if (handler->trips > 1) {
+			REDEBUG("(TLS) EAP Peer set 'O' bit after initial TEAP fragment");
+			return FR_TLS_INVALID;
+		}
+
+		tls_session->tls_record_in_total_len = frag_len;
+		tls_session->tls_record_in_recvd_len = frag_len;
+
+		RDEBUG2("(TLS) EAP Got first and final fragment (%zu bytes)", frag_len);
+		return FR_TLS_FIRST_FRAGMENT;
 	}
 
 	/*
@@ -601,8 +635,8 @@ static fr_tls_status_t eaptls_verify(eap
 	 *	this must be the final record fragment
 	 */
 	if ((eaptls_prev && TLS_MORE_FRAGMENTS(eaptls_prev->flags)) && !TLS_MORE_FRAGMENTS(eaptls_packet->flags)) {
-		RDEBUG2("(TLS) EAP Got final fragment (%zu bytes)", frag_len);
 		tls_session->tls_record_in_recvd_len += frag_len;
+		RDEBUG2("(TLS) EAP Got final fragment (%zu bytes) total %zu", frag_len, tls_session->tls_record_in_recvd_len);
 		if (tls_session->tls_record_in_recvd_len != tls_session->tls_record_in_total_len) {
 			RWDEBUG("(TLS) EAP Total received record fragments (%zu bytes), does not equal expected "
 				"expected data length (%zu bytes)",
@@ -662,12 +696,14 @@ static fr_tls_status_t eaptls_verify(eap
  *  packet including the Code, Identifir, Length, Type, and TLS data
  *  fields.
  */
-static EAPTLS_PACKET *eaptls_extract(REQUEST *request, EAP_DS *eap_ds, fr_tls_status_t status)
+static EAPTLS_PACKET *eaptls_extract(REQUEST *request, EAP_DS *eap_ds, fr_tls_status_t *status_p, tls_session_t *tls_session)
 {
 	EAPTLS_PACKET	*tlspacket;
 	uint32_t	data_len = 0;
-	uint32_t	obit = 0;
+	uint32_t	skip = 0;
+	uint32_t	chop = 0;
 	uint8_t		*data = NULL;
+	fr_tls_status_t status = *status_p;
 
 	if (status == FR_TLS_INVALID) return NULL;
 
@@ -702,6 +738,38 @@ static EAPTLS_PACKET *eaptls_extract(REQ
 	tlspacket->flags = eap_ds->response->type.data[0];
 
 	/*
+	 *	Skip extra fields in the header, depending on the flags.
+	 */
+	skip = TLS_OUTER_TLV_INCLUDED(tlspacket->flags) << 2;
+	skip += TLS_LENGTH_INCLUDED(tlspacket->flags) << 2;
+
+	/*
+	 *	'O' without 'L'.  It's the first fragment, but also the last one.
+	 *
+	 *	@todo - cache and save the outer client TLVs.  We need
+	 *	them to calculate the TEAP Crypto-Binding TLV.
+	 */
+	if (TLS_OUTER_TLV_INCLUDED(tlspacket->flags)) {
+		uint8_t const *p;
+
+		if (!TLS_LENGTH_INCLUDED(tlspacket->flags)) {
+			*status_p = FR_TLS_OK;
+		}
+
+		p = eap_ds->response->type.data + 1;
+		p += TLS_LENGTH_INCLUDED(tlspacket->flags) << 2;
+
+		memcpy(&chop, p, sizeof(chop));
+		chop = ntohl(chop);
+
+		tls_session->outer_tlvs_octets_peer = talloc_memdup(tls_session,
+								    eap_ds->response->type.data + eap_ds->response->type.length - chop,
+								    chop);
+
+		fr_assert(tls_session->outer_tlvs_octets_peer != NULL);
+	}
+
+	/*
 	 *	eaptls_verify() ensures that all of the flags are correct.
 	 */
 	switch (status) {
@@ -715,27 +783,14 @@ static EAPTLS_PACKET *eaptls_extract(REQ
 	 *	length should solve the problem.
 	 */
 	case FR_TLS_FIRST_FRAGMENT:
-		obit = TLS_OUTER_TLV_INCLUDED(tlspacket->flags) << 2;
-
-		/*
-		 *	@todo - decode outer TLVs, too
-		 */
-
-		/* FALL-THROUGH */
-
 	case FR_TLS_LENGTH_INCLUDED:
 	case FR_TLS_MORE_FRAGMENTS_WITH_LENGTH:
-		eap_ds->response->type.data += 4 + obit;
-		eap_ds->response->type.length -= 4 + obit;
-
-		/* FALL-THROUGH */
-
-		/*
-		 *	Data length is implicit, from the EAP header.
-		 */
 	case FR_TLS_MORE_FRAGMENTS:
 	case FR_TLS_OK:
-		data_len = eap_ds->response->type.length - 1;
+		eap_ds->response->type.data += skip;
+		eap_ds->response->type.length -= skip;
+
+		data_len = eap_ds->response->type.length - 1 - chop;
 		data = eap_ds->response->type.data + 1;
 		break;
 
@@ -979,7 +1034,7 @@ fr_tls_status_t eaptls_process(eap_handl
 	/*
 	 *	Extract the TLS packet from the buffer.
 	 */
-	if ((tlspacket = eaptls_extract(request, handler->eap_ds, status)) == NULL) {
+	if ((tlspacket = eaptls_extract(request, handler->eap_ds, &status, tls_session)) == NULL) {
 		REDEBUG("(TLS) EAP Failed extracting TLS packet from EAP-Message");
 		status = FR_TLS_FAIL;
 		goto done;
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/libeap/eapcommon.c freeradius-server-3.2.7/src/modules/rlm_eap/libeap/eapcommon.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/libeap/eapcommon.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/libeap/eapcommon.c	2025-01-31 18:42:21.000000000 +0700
@@ -3,7 +3,7 @@
  *
  * code common to clients and to servers.
  *
- * Version:     $Id: 5abe47a750c0fe354d89fcccb973db79e5fe5081 $
+ * Version:     $Id: 12399696ed3df4cd774099567b45b50b0f3248bf $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -57,12 +57,19 @@
  *
  */
 
-RCSID("$Id: 5abe47a750c0fe354d89fcccb973db79e5fe5081 $")
+RCSID("$Id: 12399696ed3df4cd774099567b45b50b0f3248bf $")
 
 #include <freeradius-devel/libradius.h>
 #include <freeradius-devel/rad_assert.h>
 #include "eap_types.h"
 
+#ifndef TLS_LENGTH_INCLUDED
+#define TLS_LENGTH_INCLUDED(x) 	(((x) & 0x80) != 0)
+#endif
+#ifndef TLS_OUTER_TLV_INCLUDED
+#define TLS_OUTER_TLV_INCLUDED(x) (((x) & 0x10) != 0)
+#endif
+
 const FR_NAME_NUMBER eap_rcode_table[] = {
 	{ "notfound",		EAP_NOTFOUND		},
 	{ "found",		EAP_OK			},
@@ -422,11 +429,19 @@ eap_packet_raw_t *eap_vp2packet(TALLOC_C
 			return NULL;
 		}
 
+#if 0
+		DEBUG("(TLS) EAP Peer sent flags %c%c%c%c",
+		      TLS_START(eap_packet->data[1]) ? 'S' : '-',
+		      TLS_MORE_FRAGMENTS(eap_packet->data[1]) ? 'M' : '-',
+		      TLS_OUTER_TLV_INCLUDED(eap_packet->data[1]) ? 'O' : '-',
+		      TLS_LENGTH_INCLUDED(eap_packet->data[1]) ? 'L' : '-');
+#endif
+
 		/*
 		 *	L bit set means we have 4 octets of Length
 		 *	following the flags field.
 		 */
-		if ((eap_packet->data[1] & 0x80) != 0) {
+		if (TLS_LENGTH_INCLUDED(eap_packet->data[1])) {
 			uint32_t tls_len;
 
 			if (len <= (2 + 4)) {
@@ -452,23 +467,44 @@ eap_packet_raw_t *eap_vp2packet(TALLOC_C
 			/*
 			 *	O bit set means we have 4 octets of Outer TLV Length
 			 *	following the Length field.
+			 *
+			 * 0                   1                   2                   3
+			 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+			 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+			 * |     Code      |   Identifier  |            Length             |
+			 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+			 * |     Type      |   Flags | Ver |        Message Length         :
+			 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+			 * :         Message Length        |         Outer TLV Length
+			 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+			 * :     Outer TLV Length          |         TLS Data...
+			 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+			 * |       Outer TLVs...
+			 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 			 */
-			if ((eap_packet->data[1] & 0x10) != 0) {
+			if (TLS_OUTER_TLV_INCLUDED(eap_packet->data[1])) {
 				uint32_t tlv_len;
+				uint16_t offset;
 
+			check_outer_tlv:
 				if (!allow_o) {
 					fr_strerror_printf("Malformed EAP packet - TLS 'O' bit is set, but EAP method does not use it.");
 					talloc_free(eap_packet);
 					return NULL;
 				}
 
-				if (len <= (2 + 4 + 4)) {
+				/*
+				 *	Type + flags + potentially a message length.
+				 */
+				offset = 2 + (TLS_LENGTH_INCLUDED(eap_packet->data[1]) << 2);
+
+				if (len <= (offset + 4)) {
 					fr_strerror_printf("Malformed EAP packet - TLS 'O' bit is set, but packet is too small to contain 'outer tlv length' field");
 					talloc_free(eap_packet);
 					return NULL;
 				}
 
-				memcpy(&tlv_len, eap_packet->data + 2 + 4, 4);
+				memcpy(&tlv_len, eap_packet->data + offset, 4);
 				tlv_len = ntohl(tlv_len);
 
 				/*
@@ -479,19 +515,14 @@ eap_packet_raw_t *eap_vp2packet(TALLOC_C
 				 *	flags, length field, or outer
 				 *	tlv length field.
 				 */
-				if ((int)tlv_len > (len - (2 + 4 + 4))) {
+				if ((int)tlv_len > (len - (offset + 4))) {
 					fr_strerror_printf("Malformed EAP packet - TLS 'O' bit is set, but 'outer tlv length' field is larger than the current fragment");
 					talloc_free(eap_packet);
 					return NULL;
 				}
 			}
-		} else {
-			if ((eap_packet->data[1] & 0x10) != 0) {
-				fr_strerror_printf("Malformed EAP packet - TLS 'O' bit is set, but 'L' bit is not set.");
-				talloc_free(eap_packet);
-				return NULL;
-			}
-
+		} else if (TLS_OUTER_TLV_INCLUDED(eap_packet->data[1])) {
+			goto check_outer_tlv;
 		}
 		break;
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/radeapclient.c freeradius-server-3.2.7/src/modules/rlm_eap/radeapclient.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/radeapclient.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/radeapclient.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * radeapclient.c	EAP specific radius packet debug tool.
  *
- * Version:	$Id: ae24f06cc7154e87c02ed2b46c6afed4dc41c5e1 $
+ * Version:	$Id: 66d9f040f924a56bd92169663dccf8cbdae3f7d2 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
  * Copyright 2000  Alan DeKok <aland@ox.org>
  */
 
-RCSID("$Id: ae24f06cc7154e87c02ed2b46c6afed4dc41c5e1 $")
+RCSID("$Id: 66d9f040f924a56bd92169663dccf8cbdae3f7d2 $")
 
 #include <freeradius-devel/libradius.h>
 
@@ -190,12 +190,27 @@ rlm_rcode_t process_post_auth(UNUSED int
 	return RLM_MODULE_FAIL;
 }
 
-
 fr_event_list_t *radius_event_list_corral(UNUSED event_corral_t hint)
 {
 	return NULL;
 }
 
+/*
+ *	These are shared with threads.c, and nothing else.
+ */
+void request_free(REQUEST *request) CC_HINT(nonnull);
+void request_done(REQUEST *request, int original) CC_HINT(nonnull);
+
+void request_free(UNUSED REQUEST *request)
+{
+	/* do nothing */
+}
+
+void request_done(UNUSED REQUEST *request, UNUSED int original)
+{
+	/* do nothing */
+}
+
 static void NEVER_RETURNS usage(void)
 {
 	fprintf(stdout, "Usage: radeapclient [options] server[:port] <command> [<secret>]\n");
@@ -694,7 +709,7 @@ static void generate_triplets(RADIUS_PAC
 		char buffer[33];	/* 32 hexits (16 bytes) + 1 */
 
 		for (i = 0; i < EAPSIM_RAND_SIZE; i++) {
-			ess.keys.rand[idx][i] = ch[(idx * EAPSIM_RAND_SIZE) + i];
+			ess.keys.rand[idx][i] = ch ? ch[(idx * EAPSIM_RAND_SIZE) + i] : 0;
 		}
 
 		/*
@@ -1981,7 +1996,7 @@ int main(int argc, char **argv)
 			timeout = atof(optarg);
 			break;
 		case 'v':
-			printf("$Id: ae24f06cc7154e87c02ed2b46c6afed4dc41c5e1 $"
+			printf("$Id: 66d9f040f924a56bd92169663dccf8cbdae3f7d2 $"
 #ifndef ENABLE_REPRODUCIBLE_BUILDS
 			", built on " __DATE__ " at " __TIME__
 #endif
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/rlm_eap.c freeradius-server-3.2.7/src/modules/rlm_eap/rlm_eap.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/rlm_eap.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/rlm_eap.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 18eb1c439cf0d6723cf198ce94eb244f5c879863 $
+ * $Id: f94c4928a1e172cec27f7770d58b1dca7904e938 $
  * @file rlm_eap.c
  * @brief Implements the EAP framework.
  *
@@ -23,7 +23,7 @@
  * @copyright 2001  hereUare Communications, Inc. <raghud@hereuare.com>
  * @copyright 2003  Alan DeKok <aland@freeradius.org>
  */
-RCSID("$Id: 18eb1c439cf0d6723cf198ce94eb244f5c879863 $")
+RCSID("$Id: f94c4928a1e172cec27f7770d58b1dca7904e938 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/modules.h>
@@ -591,7 +591,8 @@ static rlm_rcode_t CC_HINT(nonnull) mod_
 static rlm_rcode_t CC_HINT(nonnull) mod_pre_proxy(UNUSED void *instance, REQUEST *request)
 {
 	VALUE_PAIR	*vp;
-	size_t		length, eap_length;
+	vp_cursor_t	cursor;
+	size_t		length, eap_length = 0;
 
 	vp = fr_pair_find_by_num(request->packet->vps, PW_EAP_MESSAGE, 0, TAG_ANY);
 	if (!vp) return RLM_MODULE_NOOP;
@@ -615,12 +616,13 @@ static rlm_rcode_t CC_HINT(nonnull) mod_
 	/*
 	 *	Get length of all EAP-Message attributes
 	 */
-	for (eap_length = 0; vp != NULL; vp = vp->next) {
+	fr_cursor_init(&cursor, &request->packet->vps);
+	while ((vp = fr_cursor_next_by_num(&cursor, PW_EAP_MESSAGE, 0, TAG_ANY))) {
 		eap_length += vp->vp_length;
 	}
 
 	if (length != eap_length) {
-		RDEBUG("EAP length does not match attribute length");
+		RDEBUG("EAP length (%zu) does not match attribute length (%zu)", eap_length, length);
 		goto add_error_cause;
 	}
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_fast/eap_fast.c freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_fast/eap_fast.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_fast/eap_fast.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_fast/eap_fast.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * eap_fast.c  contains the interfaces that are called from the main handler
  *
- * Version:     $Id: bbb5a03c9582ebdc878d4f7339359841ceb3f765 $
+ * Version:     $Id: 0d0b6c970cee8806ac3480f02509c8bdfa291098 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  *   Copyright 2016 The FreeRADIUS server project
  */
 
-RCSID("$Id: bbb5a03c9582ebdc878d4f7339359841ceb3f765 $")
+RCSID("$Id: 0d0b6c970cee8806ac3480f02509c8bdfa291098 $")
 
 #include "eap_fast.h"
 #include "eap_fast_crypto.h"
@@ -902,6 +902,8 @@ static PW_CODE eap_fast_eap_payload(REQU
 	fake = request_alloc_fake(request);
 	rad_assert(!fake->packet->vps);
 
+	fake->eap_inner_tunnel = true;
+
 	t = (eap_fast_tunnel_t *) tls_session->opaque;
 
 	/*
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_peap/peap.c freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_peap/peap.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_peap/peap.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_peap/peap.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * peap.c contains the interfaces that are called from eap
  *
- * Version:     $Id: efe9b102d3e82095316d34f0875f30bf1f3ecc04 $
+ * Version:     $Id: 24e7a664f5e871fb3d26c7b52f6603c3e048d7db $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  *   Copyright 2006 The FreeRADIUS server project
  */
 
-RCSID("$Id: efe9b102d3e82095316d34f0875f30bf1f3ecc04 $")
+RCSID("$Id: 24e7a664f5e871fb3d26c7b52f6603c3e048d7db $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include "eap_peap.h"
@@ -826,6 +826,9 @@ rlm_rcode_t eappeap_process(eap_handler_
 	case PEAP_STATUS_WAIT_FOR_SOH_RESPONSE:
 		fake = request_alloc_fake(request);
 		rad_assert(!fake->packet->vps);
+
+		fake->eap_inner_tunnel = true;
+
 		eapsoh_verify(fake, fake->packet, data + header, data_len - header);
 		setup_fake_request(request, fake, t);
 
@@ -919,9 +922,10 @@ rlm_rcode_t eappeap_process(eap_handler_
 	}
 
 	fake = request_alloc_fake(request);
-
 	rad_assert(!fake->packet->vps);
 
+	fake->eap_inner_tunnel = true;
+
 	switch (t->status) {
 		/*
 		 *	If we're in PHASE2_INIT, the phase2 method hasn't been
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.c freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * eap_teap.c  contains the interfaces that are called from the main handler
  *
- * Version:     $Id: dbe694ef62143de12b1f87e4cbfaeb1f64123da5 $
+ * Version:     $Id: 8e372c69f311eb9e05015ff259bd0903d652d99e $
  *
  * Copyright (C) 2022 Network RADIUS SARL <legal@networkradius.com>
  *
@@ -21,7 +21,7 @@
  * SUCH DAMAGE.
  */
 
-RCSID("$Id: dbe694ef62143de12b1f87e4cbfaeb1f64123da5 $")
+RCSID("$Id: 8e372c69f311eb9e05015ff259bd0903d652d99e $")
 
 #include "eap_teap.h"
 #include "eap_teap_crypto.h"
@@ -29,18 +29,15 @@ RCSID("$Id: dbe694ef62143de12b1f87e4cbfa
 #include <openssl/ssl.h>
 #include <openssl/rand.h>
 
-#define PW_EAP_TEAP_TLV_IDENTITY (PW_FREERADIUS_EAP_TEAP_TLV | (EAP_TEAP_TLV_IDENTITY << 8))
-#define PW_EAP_TEAP_TLV_PAC (PW_FREERADIUS_EAP_TEAP_TLV | (EAP_TEAP_TLV_PAC << 8))
-
 #define EAPTLS_MPPE_KEY_LEN 32
 
 #define RDEBUGHEX(_label, _data, _length) \
-do {\
+if (fr_debug_lvl > 2) {\
 	char __buf[8192];\
 	for (size_t i = 0; (i < (size_t) _length) && (3*i < sizeof(__buf)); i++) {\
 		sprintf(&__buf[3*i], " %02x", (uint8_t)(_data)[i]);\
 	}\
-	RDEBUG("%s - hexdump(len=%zu):%s", _label, (size_t)_length, __buf);\
+	RDEBUG2("%s - hexdump(len=%zu):%s", _label, (size_t)_length, __buf);\
 } while (0)
 
 #define RANDFILL(x) do { rad_assert(sizeof(x) % sizeof(uint32_t) == 0); for (size_t i = 0; i < sizeof(x); i += sizeof(uint32_t)) *((uint32_t *)&x[i]) = fr_rand(); } while(0)
@@ -73,9 +70,9 @@ static void eap_teap_init_keys(REQUEST *
 	const EVP_MD *md = SSL_CIPHER_get_handshake_digest(SSL_get_current_cipher(tls_session->ssl));
 	const int md_type = EVP_MD_type(md);
 
-	RDEBUG("Using MAC %s (%d)", OBJ_nid2sn(md_type), md_type);
+	RDEBUG3("Phase 2: Using MAC %s (%d)", OBJ_nid2sn(md_type), md_type);
 
-	RDEBUG2("Deriving EAP-TEAP keys");
+	RDEBUG3("Phase 2: Deriving keys");
 
 	rad_assert(t->received_version > -1);
 	rad_assert(t->imckc == 0);
@@ -83,7 +80,7 @@ static void eap_teap_init_keys(REQUEST *
 	/* S-IMCK[0] = session_key_seed (RFC7170, Section 5.1) */
 	eaptls_gen_keys_only(request, tls_session->ssl, "EXPORTER: teap session key seed", NULL, 0, t->imck_msk.simck, sizeof(t->imck_msk.simck));
 	memcpy(t->imck_emsk.simck, t->imck_msk.simck, sizeof(t->imck_msk.simck));
-	RDEBUGHEX("S-IMCK[0]", t->imck_msk.simck, sizeof(t->imck_msk.simck));
+	RDEBUGHEX("Phase 2: S-IMCK[0]", t->imck_msk.simck, sizeof(t->imck_msk.simck));
 }
 
 /**
@@ -99,7 +96,7 @@ static void eap_teap_derive_imck(REQUEST
 	teap_tunnel_t *t = tls_session->opaque;
 
 	t->imckc++;
-	RDEBUG2("Updating ICMK (j = %d)", t->imckc);
+	RDEBUG2("Phase 2: Calculating ICMK for round (j = %d)", t->imckc);
 
 	uint8_t imsk_msk[EAP_TEAP_IMSK_LEN] = {0};
 	uint8_t imsk_emsk[EAP_TEAP_IMSK_LEN + 32];	// +32 for EMSK overflow
@@ -113,9 +110,9 @@ static void eap_teap_derive_imck(REQUEST
 
 	if (msklen) {
 		memcpy(imsk_msk, msk, MIN(msklen, EAP_TEAP_IMSK_LEN));
-		RDEBUGHEX("IMSK from MSK", imsk_msk, EAP_TEAP_IMSK_LEN);
+		RDEBUGHEX("Phase 2: IMSK from MSK", imsk_msk, EAP_TEAP_IMSK_LEN);
 	} else {
-		RDEBUGHEX("IMSK Zero", imsk_msk, EAP_TEAP_IMSK_LEN);
+		RDEBUGHEX("Phase 2: IMSK Zero", imsk_msk, EAP_TEAP_IMSK_LEN);
 	}
 	imck_seed[1].iov_base = imsk_msk;
 	TLS_PRF(tls_session->ssl,
@@ -124,8 +121,8 @@ static void eap_teap_derive_imck(REQUEST
 		(uint8_t *)&imck_msk, sizeof(imck_msk));
 
 	/* IMCK[j] 60 octets => S-IMCK[j] first 40 octets, CMK[j] last 20 octets */
-	RDEBUGHEX("MSK S-IMCK[j]", imck_msk.simck, sizeof(imck_msk.simck));
-	RDEBUGHEX("MSK CMK[j]", imck_msk.cmk, sizeof(imck_msk.cmk));
+	RDEBUGHEX("Phase 2: MSK S-IMCK[j]", imck_msk.simck, sizeof(imck_msk.simck));
+	RDEBUGHEX("Phase 2: MSK CMK[j]", imck_msk.cmk, sizeof(imck_msk.cmk));
 
 	if (emsklen) {
 		uint8_t emsk_label[20] = "TEAPbindkey@ietf.org";
@@ -137,13 +134,24 @@ static void eap_teap_derive_imck(REQUEST
 			{ (void *)length, sizeof(length) }
 		};
 
+		/*
+		 *	IMSK[j] = First 32 octets of TLS-PRF(
+		 *			EMSK[j],
+		 *			"TEAPbindkey@ietf.org",
+		 *			0x00 | 0x00 | 0x40)
+		 */
 		TLS_PRF(tls_session->ssl,
 			emsk, emsklen,
 			emsk_seed, ARRAY_SIZE(emsk_seed),
 			imsk_emsk, sizeof(imsk_emsk));
 
-		RDEBUGHEX("IMSK from EMSK", imsk_emsk, EAP_TEAP_IMSK_LEN);
+		RDEBUGHEX("Phase 2: IMSK from EMSK", imsk_emsk, EAP_TEAP_IMSK_LEN);
 
+		/*
+		 *	IMCK[j] = the first 60 octets of TLS-PRF(S-IMCK[j-1],
+		 *			"Inner Methods Compound Keys",
+		 *			IMSK[j])
+		 */
 		imck_seed[1].iov_base = imsk_emsk;
 		TLS_PRF(tls_session->ssl,
 			t->imck_emsk.simck, sizeof(t->imck_emsk.simck),
@@ -151,12 +159,13 @@ static void eap_teap_derive_imck(REQUEST
 			(uint8_t *)&imck_emsk, sizeof(imck_emsk));
 
 		/* IMCK[j] 60 octets => S-IMCK[j] first 40 octets, CMK[j] last 20 octets */
-		RDEBUGHEX("EMSK S-IMCK[j]", imck_emsk.simck, sizeof(imck_emsk.simck));
-		RDEBUGHEX("EMSK CMK[j]", imck_emsk.cmk, sizeof(imck_emsk.cmk));
+		RDEBUGHEX("Phase 2: EMSK S-IMCK[j]", imck_emsk.simck, sizeof(imck_emsk.simck));
+		RDEBUGHEX("Phase 2: EMSK CMK[j]", imck_emsk.cmk, sizeof(imck_emsk.cmk));
+
+		memcpy(&t->imck_emsk, &imck_emsk, sizeof(imck_emsk));
 	}
 
 	memcpy(&t->imck_msk, &imck_msk, sizeof(imck_msk));
-	if (emsklen) memcpy(&t->imck_emsk, &imck_emsk, sizeof(imck_emsk));
 }
 
 static void eap_teap_tlv_append(tls_session_t *tls_session, int tlv, bool mandatory, int length, const void *data)
@@ -178,14 +187,25 @@ static void eap_teap_send_error(tls_sess
 	eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_ERROR, true, sizeof(value), &value);
 }
 
-static void eap_teap_append_identity(tls_session_t *tls_session, int value) {
+static void eap_teap_append_identity_type(tls_session_t *tls_session, int value)
+{
 	uint16_t identity;
 	identity = htons(value);
+	teap_tunnel_t *t = (teap_tunnel_t *) tls_session->opaque;
+
+	fr_assert(value != 0);
+	fr_assert(value <= 2);
+
+	/*
+	 *	If we send this, it's required.
+	 */
+	t->auths[value].required = true;
+	t->auths[value].sent = true;
 
-	eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_IDENTITY, false, sizeof(identity), &identity);
+	eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_IDENTITY_TYPE, false, sizeof(identity), &identity);
 }
 
-static void eap_teap_append_result(tls_session_t *tls_session, PW_CODE code)
+static void eap_teap_append_result(REQUEST *request, tls_session_t *tls_session, PW_CODE code)
 {
 	teap_tunnel_t *t = (teap_tunnel_t *) tls_session->opaque;
 
@@ -193,11 +213,17 @@ static void eap_teap_append_result(tls_s
 			? EAP_TEAP_TLV_RESULT
 			: EAP_TEAP_TLV_INTERMED_RESULT;
 
+	char const *name = (t->result_final) ? "Result" : "Intermediate-Result";
+
 	uint16_t state = (code == PW_CODE_ACCESS_REJECT)
 			? EAP_TEAP_TLV_RESULT_FAILURE
 			: EAP_TEAP_TLV_RESULT_SUCCESS;
 	state = htons(state);
 
+	char const *state_name = (code == PW_CODE_ACCESS_REJECT) ? "Failure" : "Success";
+
+	RDEBUG("Phase 2: %s = %s", name, state_name);
+
 	eap_teap_tlv_append(tls_session, type, true, sizeof(state), &state);
 }
 
@@ -205,7 +231,7 @@ static void eap_teap_append_eap_identity
 {
 	eap_packet_raw_t eap_packet;
 
-	RDEBUG("Sending EAP-Identity");
+	RDEBUG("Phase 2: Sending EAP-Identity");
 
 	eap_packet.code = PW_EAP_REQUEST;
 	eap_packet.id = eap_session->eap_ds->response->id + 1;
@@ -216,69 +242,6 @@ static void eap_teap_append_eap_identity
 	eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_EAP_PAYLOAD, true, sizeof(eap_packet), &eap_packet);
 }
 
-#if 0
-static void eap_teap_send_pac_tunnel(REQUEST *request, tls_session_t *tls_session)
-{
-	teap_tunnel_t			*t = tls_session->opaque;
-	eap_teap_pac_t				pac;
-	eap_teap_attr_pac_opaque_plaintext_t	opaque_plaintext;
-	int					alen, dlen;
-
-	memset(&pac, 0, sizeof(pac));
-	memset(&opaque_plaintext, 0, sizeof(opaque_plaintext));
-
-	RDEBUG("Sending Tunnel PAC");
-
-	pac.key.hdr.type = htons(EAP_TEAP_TLV_MANDATORY | PAC_INFO_PAC_KEY);
-	pac.key.hdr.length = htons(sizeof(pac.key.data));
-	rad_assert(sizeof(pac.key.data) % sizeof(uint32_t) == 0);
-	RANDFILL(pac.key.data);
-
-	pac.info.lifetime.hdr.type = htons(PAC_INFO_PAC_LIFETIME);
-	pac.info.lifetime.hdr.length = htons(sizeof(pac.info.lifetime.data));
-	pac.info.lifetime.data = htonl(time(NULL) + t->pac_lifetime);
-
-	pac.info.a_id.hdr.type = htons(EAP_TEAP_TLV_MANDATORY | PAC_INFO_A_ID);
-	pac.info.a_id.hdr.length = htons(sizeof(pac.info.a_id.data));
-	memcpy(pac.info.a_id.data, t->a_id, sizeof(pac.info.a_id.data));
-
-	pac.info.a_id_info.hdr.type = htons(PAC_INFO_A_ID_INFO);
-	pac.info.a_id_info.hdr.length = htons(sizeof(pac.info.a_id_info.data));
-	#define MIN(a,b) (((a)>(b)) ? (b) : (a))
-	alen = MIN(talloc_array_length(t->authority_identity) - 1, sizeof(pac.info.a_id_info.data));
-	memcpy(pac.info.a_id_info.data, t->authority_identity, alen);
-
-	pac.info.type.hdr.type = htons(EAP_TEAP_TLV_MANDATORY | PAC_INFO_PAC_TYPE);
-	pac.info.type.hdr.length = htons(sizeof(pac.info.type.data));
-	pac.info.type.data = htons(PAC_TYPE_TUNNEL);
-
-	pac.info.hdr.type = htons(EAP_TEAP_TLV_MANDATORY | PAC_INFO_PAC_INFO);
-	pac.info.hdr.length = htons(sizeof(pac.info.lifetime)
-				+ sizeof(pac.info.a_id)
-				+ sizeof(pac.info.a_id_info)
-				+ sizeof(pac.info.type));
-
-	memcpy(&opaque_plaintext.type, &pac.info.type, sizeof(opaque_plaintext.type));
-	memcpy(&opaque_plaintext.lifetime, &pac.info.lifetime, sizeof(opaque_plaintext.lifetime));
-	memcpy(&opaque_plaintext.key, &pac.key, sizeof(opaque_plaintext.key));
-
-
-	rad_assert(PAC_A_ID_LENGTH <= EVP_GCM_TLS_TAG_LEN);
-	memcpy(pac.opaque.aad, t->a_id, PAC_A_ID_LENGTH);
-	rad_assert(RAND_bytes(pac.opaque.iv, sizeof(pac.opaque.iv)) != 0);
-	dlen = eap_teap_encrypt((unsigned const char *)&opaque_plaintext, sizeof(opaque_plaintext),
-				t->a_id, PAC_A_ID_LENGTH, t->pac_opaque_key, pac.opaque.iv,
-				pac.opaque.data, pac.opaque.tag);
-	if (dlen < 0) return;
-
-	pac.opaque.hdr.type = htons(EAP_TEAP_TLV_MANDATORY | PAC_INFO_PAC_OPAQUE);
-	pac.opaque.hdr.length = htons(sizeof(pac.opaque) - sizeof(pac.opaque.hdr) - sizeof(pac.opaque.data) + dlen);
-
-	eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_MANDATORY | EAP_TEAP_TLV_PAC, true,
-			    sizeof(pac) - sizeof(pac.opaque.data) + dlen, &pac);
-}
-#endif
-
 /*
  * RFC7170 and the consequences of EID5768, EID5770 and EID5775 makes the path forward unclear,
  * so just do what hostapd does...which the IETF probably agree with anyway:
@@ -292,18 +255,22 @@ static void eap_teap_append_crypto_bindi
 	uint8_t				mac_msk[EVP_MAX_MD_SIZE], mac_emsk[EVP_MAX_MD_SIZE];
 	unsigned int			maclen = EVP_MAX_MD_SIZE;
 	uint8_t				*buf;
-	unsigned int			olen;
+	size_t				olen, buflen;
 	struct crypto_binding_buffer	*cbb;
+	uint8_t				*outer_tlvs;
 
-	RDEBUG("Sending Cryptobinding");
+	RDEBUG("Phase 2: Sending Cryptobinding");
 
 	eap_teap_derive_imck(request, tls_session, msk, msklen, emsk, emsklen);
 
 	t->imck_emsk_available = emsklen > 0;
 
-	olen = tls_session->outer_tlvs_octets ? talloc_array_length(tls_session->outer_tlvs_octets) : 0;
+	olen = tls_session->outer_tlvs_octets_server ? talloc_array_length(tls_session->outer_tlvs_octets_server) : 0;
+	olen += tls_session->outer_tlvs_octets_peer ? talloc_array_length(tls_session->outer_tlvs_octets_peer) : 0;
 
-	buf = talloc_zero_array(request, uint8_t, sizeof(struct crypto_binding_buffer) - 1/*outer_tlvs*/ + olen);
+	buflen = sizeof(struct crypto_binding_buffer) - 1/*outer_tlvs*/ + olen;
+
+	buf = talloc_zero_array(request, uint8_t, buflen);
 	rad_assert(buf != NULL);
 
 	cbb = (struct crypto_binding_buffer *)buf;
@@ -318,14 +285,27 @@ static void eap_teap_append_crypto_bindi
 	RANDFILL(cbb->binding.nonce);
 	cbb->binding.nonce[sizeof(cbb->binding.nonce) - 1] &= ~0x01; /* RFC 7170, Section 4.2.13 */
 
-	if (olen) memcpy(cbb->outer_tlvs, tls_session->outer_tlvs_octets, olen);
+	outer_tlvs = &cbb->outer_tlvs[0];
+
+	if (tls_session->outer_tlvs_octets_server) {
+		size_t len = talloc_array_length(tls_session->outer_tlvs_octets_server);
 
-	RDEBUGHEX("BUFFER for Compound MAC calculation", buf, talloc_array_length(buf));
+		memcpy(outer_tlvs, tls_session->outer_tlvs_octets_server, len);
+		outer_tlvs += len;
+	}
+
+	if (tls_session->outer_tlvs_octets_peer) {
+		size_t len = talloc_array_length(tls_session->outer_tlvs_octets_peer);
+
+		memcpy(outer_tlvs, tls_session->outer_tlvs_octets_peer, len);
+	}
+
+	RDEBUGHEX("Phase 2: BUFFER for Compound MAC calculation", buf, buflen);
 
 	const EVP_MD *md = SSL_CIPHER_get_handshake_digest(SSL_get_current_cipher(tls_session->ssl));
-	HMAC(md, &t->imck_msk.cmk, EAP_TEAP_CMK_LEN, buf, talloc_array_length(buf), mac_msk, &maclen);
+	HMAC(md, &t->imck_msk.cmk, EAP_TEAP_CMK_LEN, buf, buflen, mac_msk, &maclen);
 	if (t->imck_emsk_available) {
-		HMAC(md, &t->imck_emsk.cmk, EAP_TEAP_CMK_LEN, buf, talloc_array_length(buf), mac_emsk, &maclen);
+		HMAC(md, &t->imck_emsk.cmk, EAP_TEAP_CMK_LEN, buf, buflen, mac_emsk, &maclen);
 	}
 	memcpy(cbb->binding.msk_compound_mac, &mac_msk, sizeof(cbb->binding.msk_compound_mac));
 	if (t->imck_emsk_available) {
@@ -351,7 +331,7 @@ static int eap_teap_verify(REQUEST *requ
 
 	while (remaining > 0) {
 		if (remaining < 4) {
-			RDEBUG2("EAP-TEAP TLV is too small (%u) to contain a EAP-TEAP TLV header", remaining);
+			REDEBUG("Phase 2: Data is too small (%u) to contain a TLV header", remaining);
 			return 0;
 		}
 
@@ -365,29 +345,38 @@ static int eap_teap_verify(REQUEST *requ
 		case EAP_TEAP_TLV_VENDOR_SPECIFIC:
 		case EAP_TEAP_TLV_EAP_PAYLOAD:
 		case EAP_TEAP_TLV_INTERMED_RESULT:
-		case EAP_TEAP_TLV_PAC:
 		case EAP_TEAP_TLV_CRYPTO_BINDING:
+		case EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP:
 			num[attr]++;
 			present |= 1 << attr;
 
 			if (num[EAP_TEAP_TLV_EAP_PAYLOAD] > 1) {
-				RDEBUG("Too many EAP-Payload TLVs");
+				REDEBUG("Phase 2: Too many EAP-Payload TLVs");
 unexpected:
-				for (int i = 0; i < EAP_TEAP_TLV_MAX; i++)
-					if (present & (1 << i))
-						RDEBUG(" - attribute %d is present", i);
+				for (int i = 0; i < EAP_TEAP_TLV_MAX; i++) {
+					DICT_ATTR const *da;
+
+					if (!(present & (1 << i))) continue;
+
+					da = dict_attrbyvalue((i << 8) | PW_FREERADIUS_EAP_TEAP_TLV, VENDORPEC_FREERADIUS);
+					if (da) {
+						RDEBUG("Phase 2: - attribute %s is present", da->name);
+					} else {
+						RDEBUG("Phase 2: - attribute %d is present", i);
+					}
+				}
 				eap_teap_send_error(tls_session, EAP_TEAP_ERR_UNEXPECTED_TLV);
 				return 0;
 			}
 
 			if (num[EAP_TEAP_TLV_INTERMED_RESULT] > 1) {
-				RDEBUG("Too many Intermediate-Result TLVs");
+				REDEBUG("Phase 2: Too many Intermediate-Result TLVs");
 				goto unexpected;
 			}
 			break;
 		default:
 			if ((data[0] & 0x80) != 0) {
-				RDEBUG("Unknown mandatory TLV %02x", attr);
+				REDEBUG("Phase 2: Unknown mandatory TLV %02x", attr);
 				goto unexpected;
 			}
 
@@ -403,7 +392,7 @@ unexpected:
 		remaining -= 4;
 
 		if (length > remaining) {
-			RDEBUG2("EAP-TEAP TLV %u is longer than room remaining in the packet (%u > %u).", attr,
+			REDEBUG2("Phase 2: TLV %u is longer than room remaining in the packet (%u > %u).", attr,
 				length, remaining);
 			return 0;
 		}
@@ -416,7 +405,7 @@ unexpected:
 		 * of the TLCs, die.
 		 */
 		if (remaining < length) {
-			RDEBUG2("EAP-TEAP TLV overflows packet!");
+			REDEBUG2("Phase 2: TLV overflows packet.");
 			return 0;
 		}
 
@@ -431,9 +420,9 @@ unexpected:
 		 * memory.
 		 */
 		if ((attr == EAP_TEAP_TLV_INTERMED_RESULT) || (attr == EAP_TEAP_TLV_RESULT)) {
-			if (length < 2) {
+			if (length != 2) {
 			fail_length:
-				RDEBUG("EAP-TEAP TLV %u is too short.  Expected 2, got %d.", attr, length);
+				REDEBUG("Phase 2: TLV %u is too short.  Expected 2, got %d.", attr, length);
 				return 0;
 			}
 
@@ -442,6 +431,65 @@ unexpected:
 		}
 
 		/*
+		 *	1 octet length + User-Name
+		 *	1 octet length + User-Password
+		 */
+		if (attr == EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP) {
+			uint8_t const *p = data;
+			uint16_t vlen = length;
+
+			if (vlen <= 2) {
+				REDEBUG("Phase 2: Basic-Password-Auth-Resp TLV is too short.  Expected >2, got %d.", vlen);
+				return 0;
+			}
+
+			/*
+			 *	Can't be zero.  We must have MORE than "1 octet length + User-Name"
+			 */
+			if (!p[0] || ((p[0] + 1) >= vlen)) {
+				REDEBUG("Phase 2: Basic-Password-Auth-Resp TLV is invalid.  User-Name field has bad lenth %u", p[0]);
+				return 0;
+			}
+
+			vlen -= p[0] + 1;
+			if (!vlen) {
+				REDEBUG("Phase 2: Basic-Password-Auth-Resp TLV is invalid.  Password field is missing");
+				return 0;
+			}
+
+			p += p[0] + 1;
+			if (!p[0] || (p[0] >= vlen)) {
+				REDEBUG("Phase 2: Basic-Password-Auth-Resp TLV is invalid.  Password field has bad lenth %u", p[0]);
+				return 0;
+			}
+		}
+
+		if (attr == EAP_TEAP_TLV_IDENTITY_TYPE) {
+			if (length != 2) goto fail_length;
+
+			if ((data[0] != 0) || (data[1] == 0) || (data[1] > 2)) {
+				REDEBUG("Phase 2: Identity-Type TLV contains invalid value %02x%02x",
+				       data[0], data[1]);
+				return 0;
+			}
+		}
+
+		/*
+		 *	Check the size of Crypto-Binding TLV, and the TEAP version.
+		 */
+		if (attr == EAP_TEAP_TLV_CRYPTO_BINDING) {
+			if (length != sizeof(eap_tlv_crypto_binding_tlv_t)) {
+				REDEBUG("Phase 2: Crypto-Binding TLV has incorrect length %u", length);
+				return 0;
+			}
+
+			if (data[1] != EAP_TEAP_VERSION) {
+				REDEBUG("Phase 2: Crypto-Binding TLV has incorrect version %u", data[1]);
+				return 0;
+			}
+		}
+
+		/*
 		 * remaining > length, continue.
 		 */
 		remaining -= length;
@@ -454,16 +502,16 @@ unexpected:
 	if (status) {
 		if (status == EAP_TEAP_TLV_RESULT_FAILURE) {
 			if (!error) {
-				RDEBUG("EAP-TEAP TLV Status indicates failure with error %u.  Rejecting request.", error);
+				REDEBUG("Phase 2: Received Result from peer which indicates failure with error %u.  Rejecting request.", error);
 			} else {
-				RDEBUG("EAP-TEAP TLV Status indicates failure.  Rejecting request.");
+				REDEBUG("Phase 2: Received Result from peer which indicates failure.  Rejecting request.");
 			}
 			return 0;
 		}
 
 		if (status != EAP_TEAP_TLV_RESULT_SUCCESS) {
 		unknown_value:
-			RDEBUG("EAP-TEAP TLV Status contains unknown value %u.  Rejecting request.", status);
+			REDEBUG("Phase 2: Received Result from peer with unknown value %u.  Rejecting request.", status);
 			goto unexpected;
 		}
 	}
@@ -472,7 +520,7 @@ unexpected:
 	 * Check if the peer mixed & matched TLVs.
 	 */
 	if ((num[EAP_TEAP_TLV_NAK] > 0) && (num[EAP_TEAP_TLV_NAK] != total)) {
-		RDEBUG("NAK TLV sent with non-NAK TLVs.  Rejecting request.");
+		REDEBUG("Phase 2: NAK TLV was sent along with non-NAK TLVs.  Rejecting request.");
 		goto unexpected;
 	}
 
@@ -486,30 +534,51 @@ unexpected:
 	switch (t->stage) {
 	case TLS_SESSION_HANDSHAKE:
 		if (present) {
-			RDEBUG("Unexpected TLVs in TLS Session Handshake stage");
+			REDEBUG("Phase 2: Unexpected TLVs in TLS Session Handshake stage");
 			goto unexpected;
 		}
 		break;
 	case AUTHENTICATION:
-		if (present & ~((1 << EAP_TEAP_TLV_EAP_PAYLOAD) | (1 << EAP_TEAP_TLV_CRYPTO_BINDING) | (1 << EAP_TEAP_TLV_INTERMED_RESULT) | (1 << EAP_TEAP_TLV_RESULT))) {
-			RDEBUG("Unexpected TLVs in authentication stage");
+		if (present & ~((1 << EAP_TEAP_TLV_EAP_PAYLOAD) | (1 << EAP_TEAP_TLV_CRYPTO_BINDING) | (1 << EAP_TEAP_TLV_INTERMED_RESULT) | (1 << EAP_TEAP_TLV_RESULT) | (1 << EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP))) {
+			REDEBUG("Phase 2: Unexpected TLVs in authentication stage");
+			goto unexpected;
+		}
+
+		/*
+		 *	A password request must yield a password response.
+		 */
+		if (t->sent_basic_password && ((present & (1 << EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP)) == 0)) {
+			REDEBUG("Phase 2: Sent Basic-Password-Auth-Req but reply does not contain Basic-Password-Auth-Resp");
+			goto unexpected;
+		}
+
+		/*
+		 *	If we have Identity-Type, the packet must also
+		 *	contain either EAP-Payload or
+		 *	Basic-Password-Auth-Resp.
+		 */
+		if (((present & (1 << EAP_TEAP_TLV_IDENTITY_TYPE)) != 0) &&
+		    ((present & (1 << EAP_TEAP_TLV_EAP_PAYLOAD)) == 0) &&
+		    ((present & (1 << EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP)) == 0)) {
+			REDEBUG("Phase 2: Received Identity-Type without EAP-Payload or Basic-Password-Auth-Resp");
 			goto unexpected;
 		}
+
 		break;
 	case PROVISIONING:
-		if (present & ~((1 << EAP_TEAP_TLV_PAC) | (1 << EAP_TEAP_TLV_RESULT))) {
-			RDEBUG("Unexpected TLVs in provisioning stage");
+		if (present & ~(1 << EAP_TEAP_TLV_RESULT)) {
+			REDEBUG("Phase 2: Unexpected TLVs in provisioning stage");
 			goto unexpected;
 		}
 		break;
 	case COMPLETE:
 		if (present) {
-			RDEBUG("Unexpected TLVs in complete stage");
+			REDEBUG("Phase 2: Unexpected TLVs in complete stage");
 			goto unexpected;
 		}
 		break;
 	default:
-		RDEBUG("Unexpected stage %d", t->stage);
+		REDEBUG("Phase 2: Internal error, invalid stage %d", t->stage);
 		return 0;
 	}
 
@@ -644,6 +713,7 @@ static ssize_t eap_teap_decode_vp(TALLOC
 		fr_pair_list_free(&vp);
 		return -1;
 	}
+
 	vp->type = VT_DATA;
 	*out = vp;
 	return attr_len;
@@ -688,14 +758,13 @@ VALUE_PAIR *eap_teap_teap2vp(REQUEST *re
 		data_left -= 4;
 
 		/*
-		 * Look up the TLV.
+		 *	Look up the TLV.
 		 *
-		 * For now, if it doesn't exist, ignore it.
+		 *	For now, if it doesn't exist, ignore it.
 		 */
 		da = dict_attrbyparent(teap_da, attr, teap_da->vendor);
 		if (!da) {
-			RDEBUG("eap_teap_teap2vp: no sub attribute found %s attr: %u vendor: %u",
-					teap_da->name, attr, teap_da->vendor);
+			RDEBUG3("Phase 2: Skipping unknown attribute %u", attr);
 			goto next_attr;
 		}
 		if (da->type == PW_TYPE_TLV) {
@@ -704,7 +773,7 @@ VALUE_PAIR *eap_teap_teap2vp(REQUEST *re
 		}
 		decoded = eap_teap_decode_vp(request, da, data, length, &vp);
 		if (decoded < 0) {
-			RERROR("Failed decoding %s: %s", da->name, fr_strerror());
+			REDEBUG3("Phase 2: Failed decoding %s: %s", da->name, fr_strerror());
 			goto next_attr;
 		}
 
@@ -787,6 +856,13 @@ static void eapteap_copy_request_to_tunn
 	}
 }
 
+static const char *stage_name[] = {
+	"TLS session handshake",
+	"Authentication",
+	"Provisioning",
+	"Complete"
+};
+
 /*
  * Use a reply packet to determine what to do.
  */
@@ -799,11 +875,14 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 	vp_cursor_t			cursor;
 	uint8_t				msk[2 * CHAP_VALUE_LENGTH] = {0}, emsk[2 * EAPTLS_MPPE_KEY_LEN] = {0};
 	size_t				msklen = 0, emsklen = 0;
+	bool				doing_eap;
 
 	teap_tunnel_t	*t = tls_session->opaque;
 
 	rad_assert(eap_session->request == request);
 
+	RDEBUG("Phase 2: Stage %s", stage_name[t->stage]);
+
 	/*
 	 * If the response packet was Access-Accept, then
 	 * we're OK.  If not, die horribly.
@@ -813,7 +892,7 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 	 */
 	switch (reply->code) {
 	case PW_CODE_ACCESS_ACCEPT:
-		RDEBUG("Got tunneled Access-Accept");
+		RDEBUG("Phase 2: Got tunneled Access-Accept");
 
 		for (vp = fr_cursor_init(&cursor, &reply->vps); vp; vp = fr_cursor_next(&cursor)) {
 			if (vp->da->attr == PW_EAP_EMSK) {
@@ -837,12 +916,12 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 					memcpy(msk, vp->vp_octets, CHAP_VALUE_LENGTH);
 				} else {
 				wrong_length:
-					REDEBUG("Found %s with incorrect length.  Expected %u or %u, got %zu",
+					REDEBUG("Phase 2: Found %s with incorrect length.  Expected %u or %u, got %zu",
 						vp->da->name, CHAP_VALUE_LENGTH, EAPTLS_MPPE_KEY_LEN, vp->vp_length);
 					return RLM_MODULE_INVALID;
 				}
 
-				RDEBUGHEX("MSCHAP_MPPE_SEND_KEY [low MSK]", vp->vp_octets, vp->length);
+				RDEBUGHEX("Phase 2: MSCHAP-MPPE-SEND-KEY [low MSK]", vp->vp_octets, vp->length);
 				break;
 
 			case PW_MSCHAP_MPPE_RECV_KEY:
@@ -859,11 +938,11 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 					goto wrong_length;
 				}
 
-				RDEBUGHEX("MSCHAP_MPPE_RECV_KEY [high MSK]", vp->vp_octets, vp->vp_length);
+				RDEBUGHEX("Phase 2: MSCHAP-MPPE-RECV-KEY [high MSK]", vp->vp_octets, vp->vp_length);
 				break;
 
 			case PW_MSCHAP2_SUCCESS:
-				RDEBUG("Got %s, tunneling it to the client in a challenge", vp->da->name);
+				RDEBUG("Phase 2: Got %s, tunneling it to the client in a challenge", vp->da->name);
 				if (t->use_tunneled_reply) {
 					t->authenticated = true;
 					/*
@@ -901,12 +980,13 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 			fr_pair_delete_by_num(&reply->vps, PW_EAP_SESSION_ID, 0, TAG_ANY);
 		}
 
-		eap_teap_append_result(tls_session, reply->code);
+		eap_teap_append_result(request, tls_session, reply->code);
 		eap_teap_append_crypto_binding(request, tls_session, msk, msklen, emsk, emsklen);
 
-		vp = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY, VENDORPEC_FREERADIUS, TAG_ANY);
+		vp = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY_TYPE, VENDORPEC_FREERADIUS, TAG_ANY);
 		if (vp) {
-			RDEBUG("&session-state:FreeRADIUS-EAP-TEAP-TLV-Identity-Type set so continuing EAP sequence/chaining");
+			RDEBUG("Phase 2: Continuing with Identity-Type = %s",
+			       (vp->vp_short == 1) ? "User" : "Machine");
 
 			/* RFC3748, Section 2.1 - does not explictly tell us to but we need to eat the EAP-Success */
 			fr_pair_delete_by_num(&reply->vps, PW_EAP_MESSAGE, 0, TAG_ANY);
@@ -915,15 +995,67 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 			talloc_free(t->username);
 			t->username = NULL;
 
+			if (t->num_identities == 2) {
+				RDEBUG("Phase 2: Configured to send too many identities, failing the session");
+				goto fail;
+			}
+
+			t->identity_types[t->num_identities++] = vp->vp_short;
+
 			/* RFC7170, Appendix C.6 */
-			eap_teap_append_identity(tls_session, vp->vp_short);
-			eap_teap_append_eap_identity_request(request, tls_session, eap_session);
+			eap_teap_append_identity_type(tls_session, vp->vp_short);
+
+			if (t->default_method || t->eap_method[vp->vp_short]) {
+				eap_teap_append_eap_identity_request(request, tls_session, eap_session);
+			}
+
+			if (!t->auto_chain) goto challenge;
 
+			if (!(t->default_method || t->eap_method[vp->vp_short])) {
+				RDEBUG("Phase 2: No %s EAP methods configured - assuming password",
+				       (vp->vp_short == 1) ? "User" : "Machine");
+
+				vp = fr_pair_afrom_num(reply, PW_EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_REQ, VENDORPEC_FREERADIUS);
+				if (vp) {
+					fr_pair_add(&reply->vps, vp);
+				} else {
+					RERROR("Failed adding attribute &reply:FreeRADIUS-EAP-TEAP-Basic-Password-Auth-Req");
+					goto fail;
+				}
+			}
+
+			/*
+			 *	Delete the &session-state:FreeRADIUS-EAP-TEAP-TLV-Identity-Type
+			 *	which we found.
+			 *
+			 *	If there are more than one, then the
+			 *	next round will pick up the next one.
+			 */
+			RDEBUG("Phase 2: Deleting &session-state:FreeRADIUS-EAP-TEAP-Identity-Type += %s",
+			       (vp->vp_short == 1) ? "User" : "Machine");
+			fr_pair_delete(&request->state, vp);
+
+			/*
+			 *	Always challenge, as we're sending EAP-Identity.
+			 */
 			goto challenge;
 		}
 
+		if (t->auths[1].required && !t->auths[1].received) {
+			REDEBUG("Phase 2: We required Identity-Type = User, but we did not see it - rejecting the session");
+			goto fail;
+		}
+
+		if (t->auths[2].required && !t->auths[2].received) {
+			REDEBUG("Phase 2: We required Identity-Type = Machine, but we did not see it - rejecting the session");
+			goto fail;
+		}
+
+		RDEBUG("Phase 2: All inner authentications have succeeded");
+
 		t->result_final = true;
-		eap_teap_append_result(tls_session, reply->code);
+		t->sent_basic_password = false;
+		eap_teap_append_result(request, tls_session, reply->code);
 
 		tls_session->authentication_success = true;
 		rcode = RLM_MODULE_OK;
@@ -931,9 +1063,10 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 		break;
 
 	case PW_CODE_ACCESS_REJECT:
-		RDEBUG("Got tunneled Access-Reject");
+		RDEBUG("Phase 2: Got tunneled Access-Reject");
 
-		eap_teap_append_result(tls_session, reply->code);
+	fail:
+		eap_teap_append_result(request, tls_session, PW_CODE_ACCESS_REJECT);
 		rcode = RLM_MODULE_REJECT;
 		break;
 
@@ -944,7 +1077,7 @@ static rlm_rcode_t CC_HINT(nonnull) proc
 	 * a Reply-Message to the client.
 	 */
 	case PW_CODE_ACCESS_CHALLENGE:
-		RDEBUG("Got tunneled Access-Challenge");
+		RDEBUG("Phase 2: Got tunneled Access-Challenge");
 challenge:
 		/*
 		 *	Keep the State attribute, if necessary.
@@ -954,24 +1087,50 @@ challenge:
 		fr_pair_list_free(&t->state);
 		fr_pair_list_mcopy_by_num(t, &t->state, &reply->vps, PW_STATE, 0, TAG_ANY);
 
+		t->sent_basic_password = false;
+		doing_eap = false;
+
 		/*
-		 *	Copy the EAP-Message back to the tunnel.
+		 *	Copy the EAP-Message back to the tunnel.  Note
+		 *	that there can only be one EAP-Message
+		 *	attribute.  The RADIUS encoder takes care of
+		 *	splitting it into multiple chunks in a RADIUS
+		 *	packet.
+		 *
+		 *	For TEAP, we can only send one EAP-Payload TLV
+		 *	in a packet.
 		 */
-		(void) fr_cursor_init(&cursor, &reply->vps);
-
-		while ((vp = fr_cursor_next_by_num(&cursor, PW_EAP_MESSAGE, 0, TAG_ANY)) != NULL) {
+		vp = fr_pair_find_by_num(reply->vps, PW_EAP_MESSAGE, 0, TAG_ANY);
+		if (vp) {
+			doing_eap = true;
 			eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_EAP_PAYLOAD, true, vp->vp_length, vp->vp_octets);
 		}
 
 		/*
-		 * When chaining, we 'goto challenge' and can use that to now signal back
-		 * to unlang that a method has completed and we can now move to the next
+		 *	When chaining, we 'goto challenge' and can use
+		 *	that to now signal back to unlang that a
+		 *	method has completed and we can now move to
+		 *	the next
 		 */
 		rcode = reply->code == PW_CODE_ACCESS_CHALLENGE ? RLM_MODULE_HANDLED : RLM_MODULE_OK;
+
+		if (!doing_eap) {
+			vp = fr_pair_find_by_num(reply->vps, PW_EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_REQ, VENDORPEC_FREERADIUS, TAG_ANY);
+			if (!vp) {
+				RWDEBUG("Phase 2: Not configured to use EAP or passwords.  Authentication will likely fail.");
+				break;
+			}
+
+			t->sent_basic_password = true;
+
+			RDEBUG("Phase 2: Sending Basic-Password-Auth-Req");
+			eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_REQ, true, vp->vp_length, vp->vp_strvalue);
+		}
+
 		break;
 
 	default:
-		RDEBUG("Unknown RADIUS packet type %d: rejecting tunneled user", reply->code);
+		RDEBUG("Phase 2: Unknown RADIUS packet type %d: rejecting tunneled user", reply->code);
 		rcode = RLM_MODULE_INVALID;
 		break;
 	}
@@ -980,36 +1139,20 @@ challenge:
 	return rcode;
 }
 
-static PW_CODE eap_teap_eap_payload(REQUEST *request, eap_handler_t *eap_session,
-				    tls_session_t *tls_session,
-				    VALUE_PAIR *vp_eap, VALUE_PAIR *vp_type)
+static PW_CODE eap_teap_phase2(REQUEST *request, eap_handler_t *eap_session,
+			       tls_session_t *tls_session, REQUEST *fake)
 {
 	PW_CODE			code = PW_CODE_ACCESS_REJECT;
 	rlm_rcode_t		rcode;
 	VALUE_PAIR		*vp;
-	teap_tunnel_t	*t;
-	REQUEST			*fake;
-
-	RDEBUG("Processing received EAP Payload");
+	teap_tunnel_t		*t;
+	int			eap_method = 0;
 
-	/*
-	 * Allocate a fake REQUEST structure.
-	 */
-	fake = request_alloc_fake(request);
-	rad_assert(!fake->packet->vps);
+	RDEBUG3("Phase 2: Processing received EAP Payload");
 
 	t = (teap_tunnel_t *) tls_session->opaque;
 
-	/*
-	 * Add the tunneled attributes to the fake request.
-	 */
-
-	fake->packet->vps = fr_pair_afrom_num(fake->packet, PW_EAP_MESSAGE, 0);
-	fr_pair_value_memcpy(fake->packet->vps, vp_eap->vp_octets, vp_eap->vp_length);
-
-	if (vp_type) fr_pair_add(&fake->packet->vps, fr_pair_copy(fake->packet, vp_type));
-
-	RDEBUG("Got tunneled request");
+	RDEBUG("Phase 2: Got tunneled request");
 	rdebug_pair_list(L_DBG_LVL_1, request, fake->packet->vps, NULL);
 
 	/*
@@ -1036,18 +1179,19 @@ static PW_CODE eap_teap_eap_payload(REQU
 
 			fr_pair_value_bstrncpy(t->username, vp->vp_octets + 5, vp->vp_length - 5);
 
-			RDEBUG("Got tunneled identity of %s", t->username->vp_strvalue);
-		} else {
+			RDEBUG("Phase 2: Got tunneled identity of %s", t->username->vp_strvalue);
+
+		} else if (!fake->username) {
 			/*
 			 * Don't reject the request outright,
 			 * as it's permitted to do EAP without
 			 * user-name.
 			 */
-			RWDEBUG2("No EAP-Identity found to start EAP conversation");
+			RWDEBUG2("Phase 2: No EAP-Identity found to start EAP conversation");
 		}
 	} /* else there WAS a t->username */
 
-	if (t->username) {
+	if (t->username && !fake->username) {
 		vp = fr_pair_list_copy(fake->packet, t->username);
 		fr_pair_add(&fake->packet->vps, vp);
 		fake->username = vp;
@@ -1064,13 +1208,85 @@ static PW_CODE eap_teap_eap_payload(REQU
 	if (t->stage == AUTHENTICATION) {
 		VALUE_PAIR *tvp;
 
-		RDEBUG2("AUTHENTICATION");
+		eap_method = t->default_method;
+
+		RDEBUG2("Phase 2: Authentication");
 
-		if (t->default_method) {
+		/*
+		 *	See which method we're doing.  If we're told to do a particular kind of identity
+		 *	check, AND there's not any EAP-Type already set, THEN do it.
+		 */
+		vp = fr_pair_find_by_num(fake->packet->vps, PW_EAP_TEAP_TLV_IDENTITY_TYPE, VENDORPEC_FREERADIUS, TAG_ANY);
+		if (vp) {
+			VALUE_PAIR *teap_type;
+
+			t->auths[vp->vp_short].received++;
+
+			/*
+			 *	User auth.  Prefer:
+			 *		* values set by the admin for this session.
+			 *	 	* otherwise configured in the TEAP module
+			 *		* otherwise default_eap_type
+			 *		* otherwise ???
+			 */
+			if (vp->vp_short == 1) {
+				teap_type = fr_pair_find_by_num(request->state, PW_TEAP_TYPE_USER, 0, TAG_ANY);
+				if (teap_type) {
+					eap_method = teap_type->vp_integer;
+
+					RDEBUG("Phase 2: Setting User EAP-Type = %s from &config:TEAP-Type-User",
+					       eap_type2name(eap_method));
+
+				} else if (t->eap_method[vp->vp_short]) {
+					eap_method = t->eap_method[vp->vp_short];
+
+					RDEBUG("Phase 2: Setting User EAP-Type = %s from TEAP configuration user_eap_type",
+					       eap_type2name(eap_method));
+
+				} else if (eap_method) {
+					RDEBUG("Phase 2: Setting User EAP-Type = %s from TEAP configuration default_eap_type",
+					       eap_type2name(eap_method));
+
+				} else if (fake->password) {
+					RDEBUG("Phase 2: User is not doing EAP, but instead is doing User-Password authentication");
+
+				} else {
+					RWDEBUG("Phase 2: Not setting User EAP-Type");
+				}
+			}
+
+			if (vp->vp_short == 2) {
+				teap_type = fr_pair_find_by_num(request->state, PW_TEAP_TYPE_MACHINE, 0, TAG_ANY);
+				if (teap_type) {
+					eap_method = teap_type->vp_integer;
+
+					RDEBUG("Phase 2: Setting Machine EAP-Type = %s from &config:TEAP-Type-Machine",
+					       eap_type2name(eap_method));
+
+				} else if (t->eap_method[vp->vp_short]) {
+					eap_method = t->eap_method[vp->vp_short];
+
+					RDEBUG("Phase 2: Setting Machine EAP-Type = %s from TEAP configuration machine_eap_type",
+					       eap_type2name(eap_method));
+
+				} else if (eap_method) {
+					RDEBUG("Phase 2: Using Machine EAP-Type = %s from TEAP configuration default_eap_type",
+					       eap_type2name(eap_method));
+
+				} else if (fake->password) {
+					RDEBUG("Phase 2: Machine is not doing EAP, but instead is doing User-Password authentication");
+
+				} else {
+					RWDEBUG("Phase 2: Not setting Machine EAP-Type");
+				}
+			}
+		}
+
+		if (eap_method) {
 			/*
 			 *	RFC 7170 - Authenticating Using EAP-TEAP-MSCHAPv2
 			 */
-			if (t->default_method == PW_EAP_MSCHAPV2 && t->mode == EAP_TEAP_PROVISIONING_ANON) {
+			if (eap_method == PW_EAP_MSCHAPV2 && t->mode == EAP_TEAP_PROVISIONING_ANON) {
 				tvp = fr_pair_afrom_num(fake, PW_MSCHAP_CHALLENGE, VENDORPEC_MICROSOFT);
 				//fr_pair_value_memcpy(tvp, t->keyblock->server_challenge, CHAP_VALUE_LENGTH);
 				fr_pair_add(&fake->config, tvp);
@@ -1079,6 +1295,21 @@ static PW_CODE eap_teap_eap_payload(REQU
 				//fr_pair_value_memcpy(tvp, t->keyblock->client_challenge, CHAP_VALUE_LENGTH);
 				fr_pair_add(&fake->config, tvp);
 			}
+
+			/*
+			 *	Set the configuration to force a particular EAP-Type.
+			 */
+			RDEBUG("Phase 2: Forcing inner TEAP authentication to &control:EAP-Type = %s", eap_type2name(eap_method));
+			vp = fr_pair_afrom_num(fake, PW_EAP_TYPE, 0);
+			if (vp) {
+				fr_pair_add(&fake->config, vp);
+				vp->vp_integer = eap_method;
+			}
+
+		} else if (!fake->password) {
+			RWDEBUG("Phase 2: No explicit EAP-Type set.");
+		} else {
+			/* else it's User-Password authentication */
 		}
 	}
 
@@ -1105,11 +1336,18 @@ static PW_CODE eap_teap_eap_payload(REQU
 	 */
 	switch (fake->reply->code) {
 	case 0:
-		RDEBUG("No tunneled reply was found, rejecting the user.");
+		vp = fr_pair_find_by_num(fake->config, PW_RESPONSE_PACKET_TYPE, 0, TAG_ANY);
+		if (vp && (vp->vp_integer == PW_CODE_ACCESS_CHALLENGE)) {
+			fake->reply->code = PW_CODE_ACCESS_CHALLENGE;
+			goto do_reply;
+		}
+
+		RDEBUG("Phase 2: No tunneled reply was found, rejecting the user.");
 		code = PW_CODE_ACCESS_REJECT;
 		break;
 
 	default:
+	do_reply:
 		/*
 		 * Returns RLM_MODULE_FOO, and we want to return PW_FOO
 		 */
@@ -1134,8 +1372,6 @@ static PW_CODE eap_teap_eap_payload(REQU
 		break;
 	}
 
-	talloc_free(fake);
-
 	return code;
 }
 
@@ -1144,36 +1380,63 @@ static PW_CODE eap_teap_crypto_binding(R
 {
 	teap_tunnel_t			*t = tls_session->opaque;
 	uint8_t				*buf;
-	unsigned int			olen;
+	size_t				olen, buflen;
 	struct crypto_binding_buffer	*cbb;
 	uint8_t				mac[EVP_MAX_MD_SIZE];
 	unsigned int			maclen = sizeof(mac);
 	unsigned int			flags;
 	struct teap_imck_t	 	*imck = NULL;
+	uint8_t				*outer_tlvs;
 
-	olen = tls_session->outer_tlvs_octets ? talloc_array_length(tls_session->outer_tlvs_octets) : 0;
-	/* FIXME: include client outer TLVs */
+	/*
+	 *	@todo - put crypto binding calculations into a common function,
+	 */
+	olen = tls_session->outer_tlvs_octets_server ? talloc_array_length(tls_session->outer_tlvs_octets_server) : 0;
+	olen += tls_session->outer_tlvs_octets_peer ? talloc_array_length(tls_session->outer_tlvs_octets_peer) : 0;
 
-	buf = talloc_zero_array(request, uint8_t, sizeof(struct crypto_binding_buffer) - 1/*outer_tlvs*/ + olen);
+	buflen = sizeof(struct crypto_binding_buffer) - 1/*outer_tlvs*/ + olen;
+
+	buf = talloc_zero_array(request, uint8_t, buflen);
 	rad_assert(buf != NULL);
 
 	cbb = (struct crypto_binding_buffer *)buf;
 
+	/*
+	 *	binding->version is what they are using.
+	 *	binding->received_version is what they got from us.
+	 */
 	if (binding->version != t->received_version || binding->received_version != EAP_TEAP_VERSION) {
-		RDEBUG2("Crypto-Binding TLV version mis-match (possible downgrade attack!)");
+		RDEBUG2("Phase 2: Crypto-Binding TLV version mis-match (possible downgrade attack!)");
+		RDEBUG2("Phase 2: Expected client to send %d, got %d.  We sent %d, they echoed back %d",
+			t->received_version, binding->version,
+			EAP_TEAP_VERSION, binding->received_version);
 		return PW_CODE_ACCESS_REJECT;
 	}
 	if ((binding->subtype & 0xf) != EAP_TEAP_TLV_CRYPTO_BINDING_SUBTYPE_RESPONSE) {
-		RDEBUG2("Crypto-Binding TLV unexpected non-response");
+		RDEBUG2("Phase 2: Crypto-Binding TLV contains unexpected response");
 		return PW_CODE_ACCESS_REJECT;
 	}
 	flags = binding->subtype >> 4;
 
 	CRYPTO_BINDING_BUFFER_INIT(cbb);
 	memcpy(&cbb->binding, binding, sizeof(cbb->binding) - sizeof(cbb->binding.emsk_compound_mac) - sizeof(cbb->binding.msk_compound_mac));
-	if (olen) memcpy(cbb->outer_tlvs, tls_session->outer_tlvs_octets, olen);
 
-	RDEBUGHEX("BUFFER for Compound MAC calculation", buf, talloc_array_length(buf));
+	outer_tlvs = &cbb->outer_tlvs[0];
+
+	if (tls_session->outer_tlvs_octets_server) {
+		size_t len = talloc_array_length(tls_session->outer_tlvs_octets_server);
+
+		memcpy(outer_tlvs, tls_session->outer_tlvs_octets_server, len);
+		outer_tlvs += len;
+	}
+
+	if (tls_session->outer_tlvs_octets_peer) {
+		size_t len = talloc_array_length(tls_session->outer_tlvs_octets_peer);
+
+		memcpy(outer_tlvs, tls_session->outer_tlvs_octets_peer, len);
+	}
+
+	RDEBUGHEX("Phase 2: BUFFER for Compound MAC calculation", buf, buflen);
 
 	/*
 	 * we carry forward the S-IMCK[j] based on what we verified for session key generation
@@ -1182,27 +1445,40 @@ static PW_CODE eap_teap_crypto_binding(R
 	 * https://github.com/emu-wg/teap-errata/pull/13
 	 */
 	const EVP_MD *md = SSL_CIPHER_get_handshake_digest(SSL_get_current_cipher(tls_session->ssl));
-	if (flags != EAP_TEAP_TLV_CRYPTO_BINDING_FLAGS_CMAC_EMSK) {
-		HMAC(md, &t->imck_msk.cmk, sizeof(t->imck_msk.cmk), buf, talloc_array_length(buf), mac, &maclen);
+
+	/*
+	 *	We verify cryptobinding MSK and EMSK, but we prefer
+	 *	EMSK for the later IMCK deriviation.
+	 */
+	if ((flags & EAP_TEAP_TLV_CRYPTO_BINDING_FLAGS_CMAC_MSK) != 0) {
+		HMAC(md, &t->imck_msk.cmk, sizeof(t->imck_msk.cmk), buf, buflen, mac, &maclen);
 		if (memcmp(binding->msk_compound_mac, mac, sizeof(binding->msk_compound_mac))) {
-			RDEBUG2("Crypto-Binding TLV (MSK) mis-match");
+			RDEBUG2("Phase 2: Crypto-Binding TLV (MSK) mis-match");
 			return PW_CODE_ACCESS_REJECT;
 		}
 		imck = &t->imck_msk;
 	}
-	if (flags != EAP_TEAP_TLV_CRYPTO_BINDING_FLAGS_CMAC_MSK && t->imck_emsk_available) {
-		HMAC(md, &t->imck_emsk.cmk, sizeof(t->imck_emsk.cmk), buf, talloc_array_length(buf), mac, &maclen);
+
+	if (((flags & EAP_TEAP_TLV_CRYPTO_BINDING_FLAGS_CMAC_EMSK) != 0) && t->imck_emsk_available) {
+		HMAC(md, &t->imck_emsk.cmk, sizeof(t->imck_emsk.cmk), buf, buflen, mac, &maclen);
 		if (memcmp(binding->emsk_compound_mac, mac, sizeof(binding->emsk_compound_mac))) {
-			RDEBUG2("Crypto-Binding TLV (EMSK) mis-match");
+			RDEBUG2("Phase 2: Crypto-Binding TLV (EMSK) mis-match");
 			return PW_CODE_ACCESS_REJECT;
 		}
+
+		RDEBUG3("Phase 2: Using all EMSK for ICMK");
 		imck = &t->imck_emsk;
-	}
 
-	if (!imck) imck = &imck_zeros;
+	} else if (imck) {
+		RDEBUG3("Phase 2: Using all MSK for ICMK");
+
+	} else {
+		RDEBUG3("Phase 2: Using all zeroes for ICMK");
+		imck = &imck_zeros;
+	}
 
 	/* IMCK[j] 60 octets => S-IMCK[j] first 40 octets, CMK[j] last 20 octets */
-	RDEBUGHEX("S-IMCK[j]", imck->simck, sizeof(imck->simck));
+	RDEBUGHEX("Phase 2: S-IMCK[j]", imck->simck, sizeof(imck->simck));
 
 	uint8_t mk_msk_label[31] = "Session Key Generating Function";
 
@@ -1213,7 +1489,7 @@ static PW_CODE eap_teap_crypto_binding(R
 		imck->simck, sizeof(imck->simck),
 		mk_msk_seed, ARRAY_SIZE(mk_msk_seed),
 		(uint8_t *)&t->msk, sizeof(t->msk));
-	RDEBUGHEX("Derived key (MSK)", t->msk, sizeof(t->msk));
+	RDEBUGHEX("Phase 2: Derived key (MSK)", t->msk, sizeof(t->msk));
 
 	uint8_t mk_emsk_label[40] = "Extended Session Key Generating Function";
 	struct iovec mk_emsk_seed[1] = {
@@ -1223,7 +1499,7 @@ static PW_CODE eap_teap_crypto_binding(R
 		imck->simck, sizeof(imck->simck),
 		mk_emsk_seed, ARRAY_SIZE(mk_emsk_seed),
 		(uint8_t *)&t->emsk, sizeof(t->emsk));
-	RDEBUGHEX("Derived key (EMSK)", t->emsk, sizeof(t->emsk));
+	RDEBUGHEX("Phase 2: Derived key (EMSK)", t->emsk, sizeof(t->emsk));
 
 	return PW_CODE_ACCESS_ACCEPT;
 }
@@ -1233,96 +1509,158 @@ static PW_CODE eap_teap_process_tlvs(REQ
 				     tls_session_t *tls_session, VALUE_PAIR *teap_vps)
 {
 	teap_tunnel_t			*t = (teap_tunnel_t *) tls_session->opaque;
-	VALUE_PAIR			*vp, *vp_eap = NULL, *vp_type = NULL;
+	VALUE_PAIR			*vp, *copy;
 	vp_cursor_t			cursor;
-	PW_CODE code			= PW_CODE_ACCESS_ACCEPT;
-	bool gotintermedresult = false, gotresult = false, gotcryptobinding = false;
+	PW_CODE				code = PW_CODE_ACCESS_ACCEPT;
+	uint8_t const			*p;
+	bool				gotintermedresult = false, gotresult = false, gotcryptobinding = false;
+	REQUEST				*fake;
+
+	/*
+	 * Allocate a fake REQUEST structure.
+	 */
+	fake = request_alloc_fake(request);
+	rad_assert(!fake->packet->vps);
+
+	fake->eap_inner_tunnel = true;
 
 	for (vp = fr_cursor_init(&cursor, &teap_vps); vp; vp = fr_cursor_next(&cursor)) {
 		char *value;
 		DICT_ATTR const *parent_da = NULL;
+		VALUE_PAIR *vp_config;
+
 		parent_da = dict_parent(vp->da->attr, vp->da->vendor);
 		if (parent_da == NULL || vp->da->vendor != VENDORPEC_FREERADIUS ||
-			((vp->da->attr & 0xff) != PW_FREERADIUS_EAP_TEAP_TLV)) {
-			value = vp_aprints(request->packet, vp, '"');
-			RDEBUG2("ignoring non-EAP-TEAP TLV %s", value);
-			talloc_free(value);
+		    ((vp->da->attr & 0xff) != PW_FREERADIUS_EAP_TEAP_TLV)) {
 			continue;
 		}
 
 		switch (parent_da->attr) {
 		case PW_FREERADIUS_EAP_TEAP_TLV:
 			switch (vp->da->attr >> 8) {
-			case EAP_TEAP_TLV_IDENTITY:
-				vp_type = vp;
+			case EAP_TEAP_TLV_IDENTITY_TYPE:
+				vp_config = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY_TYPE, VENDORPEC_FREERADIUS, TAG_ANY);
+				if (vp_config && (vp_config->vp_short != vp->vp_short)) {
+					RWDEBUG("We requested &session-state:FreeRADIUS-EAP-TEAP-TLV-Identity-Type = %s",
+						(vp_config->vp_short == 1) ? "User" : "Machine");
+					RWDEBUG("But the supplicant returned FreeRADIUS-EAP-TEAP-TLV-Identity-Type = %u",
+						vp->vp_short);
+					RWDEBUG("Authentication will likely fail.");
+				}
+
+				fr_pair_add(&fake->packet->vps, fr_pair_copy(fake->packet, vp));
 				break;
+
+				/*
+				 *	Copy EAP-Payload to EAP-Message
+				 */
 			case EAP_TEAP_TLV_EAP_PAYLOAD:
-				vp_eap = vp;
+				copy = fr_pair_afrom_num(fake->packet, PW_EAP_MESSAGE, 0);
+				fr_pair_value_memcpy(copy, vp->vp_octets, vp->vp_length);
+				fr_pair_add(&fake->packet->vps, copy);
+				break;
+
+				/*
+				 *	We copy the full attribute, even if the administrator
+				 *	isn't ever going to use it.  The existence of the attribute
+				 *	is a signal that we have a password response, and not an EAP-Message.
+				 */
+			case EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP:
+				fr_pair_add(&fake->packet->vps, fr_pair_copy(fake->packet, vp));
+
+				p = vp->vp_octets;
+
+				copy = fr_pair_afrom_num(fake->packet, PW_USER_NAME, 0);
+				fr_pair_value_bstrncpy(copy, p + 1, p[0]);
+				fr_pair_add(&fake->packet->vps, copy);
+				fake->username = copy;
+
+				p += p[0] + 1;
+
+				copy = fr_pair_afrom_num(fake->packet, PW_USER_PASSWORD, 0);
+				fr_pair_value_bstrncpy(copy, p + 1, p[0]);
+				fr_pair_add(&fake->packet->vps, copy);
+				fake->password = copy;
 				break;
+
+				/*
+				 *	The rest of the TEAP
+				 *	attributes are signalling, and
+				 *	aren't needed by the inner-tunnel virtual server.
+				 */
 			case EAP_TEAP_TLV_RESULT:
 				gotresult = true;
-				if (vp->vp_short != EAP_TEAP_TLV_RESULT_SUCCESS) code = PW_CODE_ACCESS_REJECT;
+				if (vp->vp_short != EAP_TEAP_TLV_RESULT_SUCCESS) {
+					REDEBUG("Phase 2: Peer sent Result = Failure - rejecting the session");
+					code = PW_CODE_ACCESS_REJECT;
+				}
 				break;
+
 			case EAP_TEAP_TLV_INTERMED_RESULT:
 				gotintermedresult = true;
-				if (vp->vp_short != EAP_TEAP_TLV_RESULT_SUCCESS) code = PW_CODE_ACCESS_REJECT;
+				if (vp->vp_short != EAP_TEAP_TLV_RESULT_SUCCESS) {
+					REDEBUG("Phase 2: Peer sent Intermediate-Result = Failure - rejecting the session");
+					code = PW_CODE_ACCESS_REJECT;
+				}
 				break;
+
 			case EAP_TEAP_TLV_CRYPTO_BINDING:
 				gotcryptobinding = true;
-				if (vp->vp_length >= sizeof(eap_tlv_crypto_binding_tlv_t))
-					code = eap_teap_crypto_binding(request, eap_session, tls_session,
-								       (eap_tlv_crypto_binding_tlv_t const *)vp->vp_octets);
+
+				code = eap_teap_crypto_binding(request, eap_session, tls_session,
+							       (eap_tlv_crypto_binding_tlv_t const *)vp->vp_octets);
 				break;
+
 			default:
 				value = vp_aprints_value(request->packet, vp, '"');
-				RDEBUG2("ignoring unknown %s", value);
-				talloc_free(value);
-			}
-			break;
-		case PW_EAP_TEAP_TLV_PAC:
-			switch ( ( vp->da->attr >> 16 )) {
-			case PAC_INFO_PAC_ACK:
-				if (vp->vp_integer == EAP_TEAP_TLV_RESULT_SUCCESS) {
-					t->pac.expires = UINT32_MAX;
-					t->pac.expired = false;
-				}
-				break;
-			case PAC_INFO_PAC_TYPE:
-				if (vp->vp_integer != PAC_TYPE_TUNNEL) {
-					RDEBUG("only able to serve Tunnel PAC's, ignoring request");
-					break;
-				}
-				t->pac.send = true;
-				break;
-			default:
-				value = vp_aprints(request->packet, vp, '"');
-				RDEBUG2("ignoring unknown EAP-TEAP-PAC-TLV %s", value);
+				RDEBUG2("Ignoring unknown attribute %s", value);
 				talloc_free(value);
 			}
 			break;
+
 		default:
 			value = vp_aprints(request->packet, vp, '"');
-			RDEBUG2("ignoring EAP-TEAP TLV %s", value);
+			RDEBUG2("Ignoring TEAP TLV %s", value);
 			talloc_free(value);
 		}
 
-		if (code == PW_CODE_ACCESS_REJECT)
+		if (code == PW_CODE_ACCESS_REJECT) {
+			talloc_free(fake);
 			return PW_CODE_ACCESS_REJECT;
+		}
 	}
 
-	if (t->stage == AUTHENTICATION) {
+	/*
+	 *	Move to the provisioning stage only if we have a final result.
+	 */
+	if ((t->stage == AUTHENTICATION) && t->result_final) {
 		if (gotcryptobinding && gotintermedresult) t->stage = PROVISIONING;
 		/* rollback if we have an EAP sequence (chaining) */
-		vp = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY, VENDORPEC_FREERADIUS, TAG_ANY);
 		if (t->stage == PROVISIONING && !gotresult && vp) t->stage = AUTHENTICATION;
 	}
+
 	if (t->stage == PROVISIONING) {
 		if (gotcryptobinding && gotresult) t->stage = COMPLETE;
 	}
 
-	if (vp_eap)
-		code = eap_teap_eap_payload(request, eap_session, tls_session, vp_eap, vp_type);
+	if (t->stage == COMPLETE) {
+		if (!gotcryptobinding) {
+			RWDEBUG("Phase 2: Peer did not send Crypto-Binding - rejecting");
+			talloc_free(fake);
+			return PW_CODE_ACCESS_REJECT;
+		}
+
+		if (!gotresult) {
+			RWDEBUG("Phase 2: Peer did not send Result - rejecting");
+			talloc_free(fake);
+			return PW_CODE_ACCESS_REJECT;
+		}
+
+	}  else {
+		code = eap_teap_phase2(request, eap_session, tls_session, fake);
+	}
 
+	talloc_free(fake);
 	return code;
 }
 
@@ -1382,33 +1720,49 @@ PW_CODE eap_teap_process(eap_handler_t *
 		if (strstr(SSL_CIPHER_description(SSL_get_current_cipher(tls_session->ssl),
 						  buf, sizeof(buf)), "Au=None")) {
 			/* FIXME enforce MSCHAPv2 - RFC 7170 */
-			RDEBUG2("Using anonymous provisioning");
+			RDEBUG2("Phase 2: Using anonymous provisioning");
 			t->mode = EAP_TEAP_PROVISIONING_ANON;
-			t->pac.send = true;
 		} else {
 			if (SSL_session_reused(tls_session->ssl)) {
-				RDEBUG("Session Resumed from PAC");
+				RDEBUG("Phase 2: Outer session was resumed");
 				t->mode = EAP_TEAP_NORMAL_AUTH;
 			} else {
-				RDEBUG2("Using authenticated provisioning");
+				RDEBUG2("Phase 2: Using authenticated provisioning");
 				t->mode = EAP_TEAP_PROVISIONING_AUTH;
 			}
-
-			/*
-			 *	Send a new pac at ~0.6 times the lifetime.
-			 */
-			if (!t->pac.expires || t->pac.expired || t->pac.expires < (time(NULL) + (t->pac_lifetime >> 1) + (t->pac_lifetime >> 3))) {
-				t->pac.send = true;
-			}
 		}
 
 		eap_teap_init_keys(request, tls_session);
 
+
 		/* RFC7170, Appendix C.6 */
-		vp = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY, VENDORPEC_FREERADIUS, TAG_ANY);
-		if (vp) eap_teap_append_identity(tls_session, vp->vp_short);
+		vp = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY_TYPE, VENDORPEC_FREERADIUS, TAG_ANY);
+		if (vp) {
+			RDEBUG("Phase 2: Sending Identity-Type = %s", (vp->vp_short == 1) ? "User" : "Machine");
+			eap_teap_append_identity_type(tls_session, vp->vp_short);
+
+			if (t->num_identities == 2) {
+				RDEBUG("Phase 2: Configured to send too many identities, failing the session");
+				goto fail;
+			}
+
+			t->identity_types[t->num_identities++] = vp->vp_short;
 
-		eap_teap_append_eap_identity_request(request, tls_session, eap_session);
+			RDEBUG("Phase 2: Deleting &session-state:FreeRADIUS-EAP-TEAP-Identity-Type += %s",
+			       (vp->vp_short == 1) ? "User" : "Machine");
+			fr_pair_delete(&request->state, vp);
+		}
+
+		/*
+		 *	We always start off with an EAP-Identity-Request.
+		 */
+		if (t->default_method || (vp && t->eap_method[vp->vp_short])) {
+			eap_teap_append_eap_identity_request(request, tls_session, eap_session);
+		} else {
+			RDEBUG("Phase 2: No %s EAP method configured - sending Basic-Password-Auth-Req = \"\"",
+			       !vp ? "" : (vp->vp_short == 1) ? "User" : "Machine");
+			eap_teap_tlv_append(tls_session, EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_REQ, true, 0, "");
+		}
 
 		t->stage = AUTHENTICATION;
 
@@ -1419,7 +1773,7 @@ PW_CODE eap_teap_process(eap_handler_t *
 
 	teap_vps = eap_teap_teap2vp(request, tls_session->ssl, data, data_len, NULL, NULL);
 
-	RDEBUG("Got Tunneled TEAP TLVs");
+	RDEBUG("Phase 2: Got Tunneled TEAP TLVs");
 	rdebug_pair_list(L_DBG_LVL_1, request, teap_vps, NULL);
 
 	code = eap_teap_process_tlvs(request, eap_session, tls_session, teap_vps);
@@ -1436,37 +1790,11 @@ PW_CODE eap_teap_process(eap_handler_t *
 	case PROVISIONING:
 		if (!t->result_final) {
 			t->result_final = true;
-			eap_teap_append_result(tls_session, code);
-		}
-
-#if 0
-		if (t->pac.send) {
-			RDEBUG("Peer requires new PAC");
-			eap_teap_send_pac_tunnel(request, tls_session);
-			code = PW_CODE_ACCESS_CHALLENGE;
-			break;
+			eap_teap_append_result(request, tls_session, code);
 		}
-#endif
-
 		/* FALL-THROUGH */
 
 	case COMPLETE:
-#if 0
-		/*
-		 * RFC 7170 - Network Access after EAP-TEAP Provisioning
-		 */
-		if (t->pac.type && t->pac.expired) {
-			REDEBUG("Rejecting expired PAC.");
-			code = PW_CODE_ACCESS_REJECT;
-			break;
-		}
-
-		if (t->mode == EAP_TEAP_PROVISIONING_ANON) {
-			REDEBUG("Rejecting unauthenticated provisioning");
-			code = PW_CODE_ACCESS_REJECT;
-			break;
-		}
-#endif
 		/*
 		 * TEAP wants to use it's own MSK, so boo to eap_tls_gen_mppe_keys()
 		 */
@@ -1479,6 +1807,7 @@ PW_CODE eap_teap_process(eap_handler_t *
 
 	default:
 		RERROR("Internal sanity check failed in EAP-TEAP at %d", t->stage);
+	fail:
 		code = PW_CODE_ACCESS_REJECT;
 	}
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.h freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.h
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_teap/eap_teap.h	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * eap_teap.h
  *
- * Version:     $Id: d6905ece86cc8b0fa1bc7411fc25c0f94373de2f $
+ * Version:     $Id: 59f7835a2673b471cd6a8996961c9d7b44b2ec97 $
  *
  * Copyright (C) 2022 Network RADIUS SARL <legal@networkradius.com>
  *
@@ -23,7 +23,7 @@
 #ifndef _EAP_TEAP_H
 #define _EAP_TEAP_H
 
-RCSIDH(eap_teap_h, "$Id: d6905ece86cc8b0fa1bc7411fc25c0f94373de2f $")
+RCSIDH(eap_teap_h, "$Id: 59f7835a2673b471cd6a8996961c9d7b44b2ec97 $")
 
 #include "eap_tls.h"
 
@@ -46,6 +46,13 @@ RCSIDH(eap_teap_h, "$Id: d6905ece86cc8b0
 #define EAP_TEAP_TLV_RESULT_SUCCESS		1
 #define EAP_TEAP_TLV_RESULT_FAILURE		2
 
+#define EAP_TEAP_IDENTITY_TYPE_USER		1
+#define EAP_TEAP_IDENTITY_TYPE_MACHINE		2
+
+#define PW_EAP_TEAP_TLV_IDENTITY_TYPE (PW_FREERADIUS_EAP_TEAP_TLV | (EAP_TEAP_TLV_IDENTITY_TYPE << 8))
+#define PW_EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_REQ (PW_FREERADIUS_EAP_TEAP_TLV | (EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_REQ << 8))
+#define PW_EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP (PW_FREERADIUS_EAP_TEAP_TLV | (EAP_TEAP_TLV_BASIC_PASSWORD_AUTH_RESP << 8))
+
 typedef enum eap_teap_stage_t {
 	TLS_SESSION_HANDSHAKE = 0,
 	AUTHENTICATION,
@@ -60,114 +67,6 @@ typedef enum eap_teap_auth_type {
 	EAP_TEAP_NORMAL_AUTH
 } eap_teap_auth_type_t;
 
-typedef enum eap_teap_pac_info_attr_type_t {
-	PAC_INFO_PAC_KEY = 1,	// 1
-	PAC_INFO_PAC_OPAQUE,	// 2
-	PAC_INFO_PAC_LIFETIME,	// 3
-	PAC_INFO_A_ID,		// 4
-	PAC_INFO_I_ID,		// 5
-	PAC_INFO_PAC_RESERVED6,	// 6
-	PAC_INFO_A_ID_INFO,	// 7
-	PAC_INFO_PAC_ACK,	// 8
-	PAC_INFO_PAC_INFO,	// 9
-	PAC_INFO_PAC_TYPE,	// 10
-	PAC_INFO_MAX
-} eap_teap_pac_info_attr_type_t;
-
-typedef enum eap_teap_pac_type_t {
-	PAC_TYPE_TUNNEL = 1,	// 1
-	PAC_TYPE_MACHINE_AUTH,	// 2
-	PAC_TYPE_USER_AUTHZ,	// 3
-	PAC_TYPE_MAX
-} eap_teap_pac_type_t;
-
-#define PAC_KEY_LENGTH		32
-#define PAC_A_ID_LENGTH		16
-#define PAC_I_ID_LENGTH		16
-#define PAC_A_ID_INFO_LENGTH	32
-
-/*
- *	11 - PAC TLV
- */
-typedef struct eap_teap_pac_attr_hdr_t {
-	uint16_t			type;
-	uint16_t			length;
-} CC_HINT(__packed__) eap_teap_pac_attr_hdr_t;
-
-/*
- *	11.1 - Key
- */
-typedef struct eap_teap_pac_attr_key_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint8_t				data[1];
-} CC_HINT(__packed__) eap_teap_pac_attr_key_t;
-
-/*
- *	11.2 - Opaque
- */
-typedef struct eap_teap_pac_attr_opaque_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint8_t				data[1];
-} CC_HINT(__packed__) eap_teap_pac_attr_opaque_t;
-
-/*
- *	11.3 and 11.9.3 - lifetime
- */
-typedef struct eap_teap_pac_attr_lifetime_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint32_t			data;	// secs since epoch
-} CC_HINT(__packed__) eap_teap_pac_attr_lifetime_t;
-
-/*
- *	11.4 and 11.9.4 - A-ID
- */
-typedef struct eap_teap_pac_attr_a_id_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint8_t				data[1];
-} CC_HINT(__packed__) eap_teap_pac_attr_a_id_t;
-
-/*
- *	11.5 and 11.9.5 - I-ID
- */
-typedef struct eap_teap_pac_attr_i_id_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint8_t				data[1];
-} CC_HINT(__packed__) eap_teap_pac_attr_i_id_t;
-
-/*
- *	11.7 and 11.9.7 - A-ID-Info
- */
-typedef struct eap_teap_pac_attr_a_id_info_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint8_t				data[1];
-} CC_HINT(__packed__) eap_teap_pac_attr_a_id_info_t;
-
-/*
- *	11.8 - Acknowledgement
- */
-typedef struct eap_teap_pac_pac_attr_acknowlegement_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint16_t			data; /* 1 = success, 2 = failure */
-} CC_HINT(__packed__) eap_teap_pac_pac_attr_acknowlegement_t;
-
-/*
- *	11.9 - Info
- *
- *	MUST contain A-ID (4), A-ID-Info (7), and PAC-Type (10).  MAY contain others.
- */
-typedef struct eap_teap_pac_pac_attr_info_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint8_t				data[1]; /* sub TLVs */
-} CC_HINT(__packed__) eap_teap_pac_pac_attr_info_t;
-
-/*
- *	11.10 and 11.9.10 - PAC Type
- */
-typedef struct eap_teap_pac_attr_pac_type_t {
-	eap_teap_pac_attr_hdr_t		hdr;
-	uint16_t			data; /* 1 = Tunnel-PAC */
-} CC_HINT(__packed__) eap_teap_pac_attr_pac_type_t;
-
 /* RFC 7170, Section 4.2.13 - Crypto-Binding TLV */
 typedef struct eap_tlv_crypto_binding_tlv_t {
         uint8_t reserved;
@@ -182,7 +81,7 @@ typedef struct eap_tlv_crypto_binding_tl
 typedef enum eap_teap_tlv_type_t {
 	EAP_TEAP_TLV_RESERVED_0 = 0,		// 0
 	EAP_TEAP_TLV_AUTHORITY,  		// 1
-	EAP_TEAP_TLV_IDENTITY,  		// 2
+	EAP_TEAP_TLV_IDENTITY_TYPE,  		// 2
 	EAP_TEAP_TLV_RESULT,     		// 3
 	EAP_TEAP_TLV_NAK,        		// 4
 	EAP_TEAP_TLV_ERROR,      		// 5
@@ -216,6 +115,13 @@ typedef struct teap_imck_t {
 	uint8_t		simck[EAP_TEAP_SIMCK_LEN];
 	uint8_t		cmk[EAP_TEAP_CMK_LEN];
 } CC_HINT(__packed__) teap_imck_t;
+
+typedef struct {
+	bool		required;
+	bool		sent;
+	uint8_t		received;
+} teap_auth_t;
+
 typedef struct teap_tunnel_t {
 	VALUE_PAIR	*username;
 	VALUE_PAIR	*state;
@@ -229,6 +135,11 @@ typedef struct teap_tunnel_t {
 	int			mode;
 	eap_teap_stage_t	stage;
 
+	int			num_identities;
+	uint16_t		identity_types[2];
+
+	teap_auth_t		auths[3]; /* so we can index by Identity-Type */
+
 	int			imckc;
 	bool			imck_emsk_available;
 	struct teap_imck_t	imck_msk;
@@ -238,21 +149,11 @@ typedef struct teap_tunnel_t {
 	uint8_t			emsk[EAP_TEAP_EMSK_LEN];
 
 	int			default_method;
-
-	uint32_t		pac_lifetime;
-	char const		*authority_identity;
-	uint8_t const 		*a_id;
-	uint8_t const 		*pac_opaque_key;
-
-	struct {
-		uint8_t			*key;
-		eap_teap_pac_type_t	type;
-		uint32_t		expires;
-		bool			expired;
-		bool			send;
-	}			pac;
+	int			eap_method[3];
 
 	bool			result_final;
+	bool			auto_chain;		//!< do we automatically chain identities
+	bool			sent_basic_password;
 
 #ifdef WITH_PROXY
 	bool		proxy_tunneled_request_as_eap;	//!< Proxy tunneled session as EAP, or as de-capsulated
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_teap/rlm_eap_teap.c freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_teap/rlm_eap_teap.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_teap/rlm_eap_teap.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_teap/rlm_eap_teap.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * rlm_eap_teap.c  contains the interfaces that are called from eap
  *
- * Version:     $Id: 5f2a8db04cbc7670167c3b6d2b09d7b3b7955bca $
+ * Version:     $Id: f2e2cc3d40612adcc9cc50fe3f6a49650f596b45 $
  *
  * Copyright (C) 2022 Network RADIUS SARL <legal@networkradius.com>
  *
@@ -21,7 +21,7 @@
  * SUCH DAMAGE.
  */
 
-RCSID("$Id: 5f2a8db04cbc7670167c3b6d2b09d7b3b7955bca $")
+RCSID("$Id: f2e2cc3d40612adcc9cc50fe3f6a49650f596b45 $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #include "eap_teap.h"
@@ -40,6 +40,19 @@ typedef struct rlm_eap_teap_t {
 	int default_method;
 
 	/*
+	 *	User tunneled EAP type
+	 */
+	char const *user_method_name;
+
+	/*
+	 *	Machine tunneled EAP type
+	 */
+	char const *machine_method_name;
+
+	int eap_method[3];
+
+
+	/*
 	 *	Use the reply attributes from the tunneled session in
 	 *	the non-tunneled reply to the client.
 	 */
@@ -56,9 +69,11 @@ typedef struct rlm_eap_teap_t {
 	 */
 	bool req_client_cert;
 
-	uint32_t pac_lifetime;
 	char const *authority_identity;
-	char const *pac_opaque_key;
+
+	uint16_t	identity_type[2];
+
+	char const	*identity_type_name;
 
 	/*
 	 *	Virtual server for inner tunnel session.
@@ -69,17 +84,25 @@ typedef struct rlm_eap_teap_t {
 
 static CONF_PARSER module_config[] = {
 	{ "tls", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, tls_conf_name), NULL },
-	{ "default_eap_type", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, default_method_name), "md5" },
+	{ "default_eap_type", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, default_method_name), .dflt = "" },
 	{ "copy_request_to_tunnel", FR_CONF_OFFSET(PW_TYPE_BOOLEAN, rlm_eap_teap_t, copy_request_to_tunnel), "no" },
 	{ "use_tunneled_reply", FR_CONF_OFFSET(PW_TYPE_BOOLEAN, rlm_eap_teap_t, use_tunneled_reply), "no" },
 	{ "require_client_cert", FR_CONF_OFFSET(PW_TYPE_BOOLEAN, rlm_eap_teap_t, req_client_cert), "no" },
-	{ "pac_lifetime", FR_CONF_OFFSET(PW_TYPE_INTEGER, rlm_eap_teap_t, pac_lifetime), "604800" },
 	{ "authority_identity", FR_CONF_OFFSET(PW_TYPE_STRING | PW_TYPE_REQUIRED, rlm_eap_teap_t, authority_identity), NULL },
-	{ "pac_opaque_key", FR_CONF_OFFSET(PW_TYPE_STRING | PW_TYPE_REQUIRED, rlm_eap_teap_t, pac_opaque_key), NULL },
 	{ "virtual_server", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, virtual_server), NULL },
+	{ "identity_types", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, identity_type_name), NULL },
+
+	{ "user_eap_type", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, user_method_name), .dflt = "" },
+	{ "machine_eap_type", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_eap_teap_t, machine_method_name), .dflt = "" },
 	CONF_PARSER_TERMINATOR
 };
 
+static const bool allowed[PW_EAP_MAX_TYPES] = {
+	[PW_EAP_SIM] = true,
+	[PW_EAP_TLS] = true,
+	[PW_EAP_MSCHAPV2] = true,
+	[PW_EAP_PWD] = true,
+};
 
 /*
  *	Attach the module.
@@ -112,11 +135,57 @@ static int mod_instantiate(CONF_SECTION
 		if (inst->default_method < 0) {
 			ERROR("rlm_eap_teap: Unknown EAP type %s",
 			      inst->default_method_name);
-		return -1;
+			return -1;
 		}
 	}
 
 	/*
+	 *	@todo - allow a special value like 'basic-password', which
+	 *	means that we propose the Basic-Password-Auth-Req TLV during Phase 2.
+	 *
+	 *	@todo - and then also track the username across
+	 *	multiple rounds, including some kind of State which
+	 *	can be used to signal where we are in the negotiation
+	 *	process.
+	 */
+	if (inst->user_method_name && *inst->user_method_name) {
+		int method = eap_name2type(inst->user_method_name);
+
+		if (method < 0) {
+			ERROR("rlm_eap_teap: Unknown User EAP type %s",
+			      inst->user_method_name);
+			return -1;
+		}
+
+		if (!allowed[method]) {
+			ERROR("rlm_eap_teap: Invalid User EAP type %s",
+			      inst->user_method_name);
+			return -1;
+		}
+
+		inst->eap_method[EAP_TEAP_IDENTITY_TYPE_USER] = method;
+	}
+
+	if (inst->machine_method_name && *inst->machine_method_name) {
+		int method;
+
+		method = eap_name2type(inst->machine_method_name);
+		if (method < 0) {
+			ERROR("rlm_eap_teap: Unknown Machine EAP type %s",
+			      inst->machine_method_name);
+			return -1;
+		}
+
+		if (!allowed[method]) {
+			ERROR("rlm_eap_teap: Invalid Machine EAP type %s",
+			      inst->machine_method_name);
+			return -1;
+		}
+
+		inst->eap_method[EAP_TEAP_IDENTITY_TYPE_MACHINE] = method;
+	}
+
+	/*
 	 *	Read tls configuration, either from group given by 'tls'
 	 *	option, or from the eap-tls configuration.
 	 */
@@ -127,6 +196,51 @@ static int mod_instantiate(CONF_SECTION
 		return -1;
 	}
 
+	/*
+	 *	Parse default identities
+	 */
+	if (inst->identity_type_name) {
+		char const *p;
+		int i;
+
+		p = inst->identity_type_name;
+		i = 0;
+
+		while (*p) {
+			while (isspace((uint8_t) *p)) p++;
+
+			if (strncasecmp(p, "user", 4) == 0) {
+				inst->identity_type[i] = 1;
+				p += 4;
+
+			} else if (strncasecmp(p, "machine", 7) == 0) {
+				inst->identity_type[i] = 2;
+				p += 7;
+
+			} else {
+			invalid_identity:
+				cf_log_err_cs(cs, "Invalid value in identity_types = '%s' at %s",
+					      inst->identity_type_name, p);
+				return -1;
+			}
+
+			i++;
+
+			while (isspace((uint8_t) *p)) p++;
+
+			/*
+			 *	We only support two things.
+			 */
+			if ((i == 2) && *p) goto invalid_identity;
+
+			if (!*p) break;
+
+			if (*p != ',') goto invalid_identity;
+
+			p++;
+		}
+	}
+
 	return 0;
 }
 
@@ -141,6 +255,7 @@ static teap_tunnel_t *teap_alloc(TALLOC_
 
 	t->received_version = -1;
 	t->default_method = inst->default_method;
+	memcpy(&t->eap_method, &inst->eap_method, sizeof(t->eap_method));
 	t->copy_request_to_tunnel = inst->copy_request_to_tunnel;
 	t->use_tunneled_reply = inst->use_tunneled_reply;
 	t->virtual_server = inst->virtual_server;
@@ -164,6 +279,14 @@ static int mod_session_init(void *type_a
 
 	handler->tls = true;
 
+	if (request->parent) {
+		RWDEBUG("----------------------------------------------------------------------");
+		RWDEBUG("You have configured TEAP to run inside of TEAP.  THIS WILL NOT WORK.");
+		RWDEBUG("Supported inner methods for TEAP are EAP-TLS, EAP-MSCHAPv2, and PAP.");
+		RWDEBUG("Other methods may work, but are not actively supported.");
+		RWDEBUG("----------------------------------------------------------------------");
+	}
+
 	/*
 	 *	Check if we need a client certificate.
 	 */
@@ -209,7 +332,53 @@ static int mod_session_init(void *type_a
 	ssn->length_flag = false;
 
 	vp = fr_pair_make(ssn, NULL, "FreeRADIUS-EAP-TEAP-Authority-ID", inst->authority_identity, T_OP_EQ);
-	fr_pair_add(&ssn->outer_tlvs, vp);
+	fr_pair_add(&ssn->outer_tlvs_server, vp);
+
+	/*
+	 *	Be nice about identity types.
+	 */
+	vp = fr_pair_find_by_num(request->state, PW_EAP_TEAP_TLV_IDENTITY_TYPE, VENDORPEC_FREERADIUS, TAG_ANY);
+	if (vp) {
+		RDEBUG("Found &session-state:FreeRADIUS-EAP-TEAP-Identity-Type, not setting from configuration");
+
+	} else if (!inst->identity_type[0]) {
+		RWDEBUG("No &session-state:FreeRADIUS-EAP-TEAP-Identity-Type was found.");
+		RWDEBUG("No 'identity_types' was set in the configuration.  TEAP will likely not work.");
+
+	} else {
+		teap_tunnel_t *t;
+
+		fr_assert(ssn->opaque == NULL);
+
+		ssn->opaque = teap_alloc(ssn, inst);
+		t = (teap_tunnel_t *) ssn->opaque;
+
+		/*
+		 *	We automatically add &session-state:FreeRADIUS-EAP-TEAP-Identity-Type
+		 *	to control the flow.
+		 */
+		t->auto_chain = true;
+
+		vp = fr_pair_make(request->state_ctx, &request->state, "FreeRADIUS-EAP-TEAP-Identity-Type", NULL, T_OP_SET);
+		if (vp) {
+			vp->vp_short = inst->identity_type[0];
+			RDEBUG("Setting &session-state:FreeRADIUS-EAP-TEAP-Identity-Type = %s",
+			       (vp->vp_short == 1) ? "User" : "Machine");
+
+			t->auths[vp->vp_short].required = true;
+		}
+
+		if (inst->identity_type[1]) {
+			vp = fr_pair_make(request->state_ctx, &request->state, "FreeRADIUS-EAP-TEAP-Identity-Type", NULL, T_OP_ADD);
+			if (vp) {
+				vp->vp_short = inst->identity_type[1];
+				RDEBUG("Followed by &session-state:FreeRADIUS-EAP-TEAP-Identity-Type += %s",
+				       (vp->vp_short == 1) ? "User" : "Machine");
+
+				t->auths[vp->vp_short].required = true;
+			}
+		}
+	}
 
 	/*
 	 *	TLS session initialization is over.  Now handle TLS
@@ -333,7 +502,18 @@ phase2:
 	if (!tls_session->opaque) {
 		tls_session->opaque = teap_alloc(tls_session, inst);
 		t = (teap_tunnel_t *) tls_session->opaque;
-		if (t->received_version < 0) t->received_version = handler->eap_ds->response->type.data[0] & 0x07;
+	}
+
+	if (t->received_version < 0) {
+		t->received_version = handler->eap_ds->response->type.data[0] & 0x07;
+
+		/*
+		 *	We only support TEAPv1.
+		 */
+		if (t->received_version != EAP_TEAP_VERSION) {
+			RDEBUG("Invalid TEAP version received.  Expected 1, got %u", t->received_version);
+			goto fail;
+		}
 	}
 
 	/*
@@ -342,6 +522,7 @@ phase2:
 	rcode = eap_teap_process(handler, tls_session);
 	switch (rcode) {
 	case PW_CODE_ACCESS_REJECT:
+	fail:
 		eaptls_fail(handler, 0);
 		ret = 0;
 		goto done;
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_tls/rlm_eap_tls.c freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_tls/rlm_eap_tls.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_tls/rlm_eap_tls.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_tls/rlm_eap_tls.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * rlm_eap_tls.c  contains the interfaces that are called from eap
  *
- * Version:     $Id: 482fdca64066835ed3b49ce7b87ea9f36d7ac6ac $
+ * Version:     $Id: 0eaf063421cc52f21103361973cf91f8cc1f18b5 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -23,7 +23,7 @@
  *
  */
 
-RCSID("$Id: 482fdca64066835ed3b49ce7b87ea9f36d7ac6ac $")
+RCSID("$Id: 0eaf063421cc52f21103361973cf91f8cc1f18b5 $")
 USES_APPLE_DEPRECATED_API	/* OpenSSL API has been deprecated by Apple */
 
 #ifdef HAVE_OPENSSL_RAND_H
@@ -81,10 +81,8 @@ static int mod_instantiate(CONF_SECTION
  */
 static int mod_session_init(void *type_arg, eap_handler_t *handler)
 {
-	int		status;
 	tls_session_t	*ssn;
 	rlm_eap_tls_t	*inst;
-	REQUEST		*request = handler->request;
 	bool		require_client_cert = true;
 
 	inst = type_arg;
@@ -122,13 +120,7 @@ static int mod_session_init(void *type_a
 	 *	TLS session initialization is over.  Now handle TLS
 	 *	related handshaking or application data.
 	 */
-	status = eaptls_request(handler->eap_ds, ssn, true);
-	if ((status == FR_TLS_INVALID) || (status == FR_TLS_FAIL)) {
-		REDEBUG("[eaptls start] = %s", fr_int2str(fr_tls_status_table, status, "<INVALID>"));
-	} else {
-		RDEBUG3("[eaptls start] = %s", fr_int2str(fr_tls_status_table, status, "<INVALID>"));
-	}
-	if (status == 0) return 0;
+	eaptls_start(handler->eap_ds, ssn->peap_flag);
 
 	/*
 	 *	The next stage to process the packet.
@@ -180,6 +172,8 @@ static int CC_HINT(nonnull) mod_process(
 			fake = request_alloc_fake(request);
 			rad_assert(!fake->packet->vps);
 
+			fake->eap_inner_tunnel = true;
+
 			fake->packet->vps = fr_pair_list_copy(fake->packet, request->packet->vps);
 
 			/* set the virtual server to use */
diff -urpN freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_ttls/ttls.c freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_ttls/ttls.c
--- freeradius-server-3.2.6/src/modules/rlm_eap/types/rlm_eap_ttls/ttls.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_eap/types/rlm_eap_ttls/ttls.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * rlm_eap_ttls.c  contains the interfaces that are called from eap
  *
- * Version:     $Id: d997e3ea3b6ac46555518ea4bc35fe18a440287a $
+ * Version:     $Id: 4a27fcc63df8d0adb7278c7356d1bc7dc6ba2a52 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
  *   Copyright 2006 The FreeRADIUS server project
  */
 
-RCSID("$Id: d997e3ea3b6ac46555518ea4bc35fe18a440287a $")
+RCSID("$Id: 4a27fcc63df8d0adb7278c7356d1bc7dc6ba2a52 $")
 
 #include "eap_ttls.h"
 #include "eap_chbind.h"
@@ -1005,9 +1005,10 @@ int eapttls_process(eap_handler_t *handl
 	 *	Allocate a fake REQUEST structure.
 	 */
 	fake = request_alloc_fake(request);
-
 	rad_assert(!fake->packet->vps);
 
+	fake->eap_inner_tunnel = true;
+
 	/*
 	 *	Add the tunneled attributes to the fake request.
 	 */
diff -urpN freeradius-server-3.2.6/src/modules/rlm_proxy_rate_limit/all.mk freeradius-server-3.2.7/src/modules/rlm_proxy_rate_limit/all.mk
--- freeradius-server-3.2.6/src/modules/rlm_proxy_rate_limit/all.mk	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_proxy_rate_limit/all.mk	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,4 @@
+TARGETNAME	:= rlm_proxy_rate_limit
+
+TARGET		:= $(TARGETNAME).a
+SOURCES		:= $(TARGETNAME).c
diff -urpN freeradius-server-3.2.6/src/modules/rlm_proxy_rate_limit/rlm_proxy_rate_limit.c freeradius-server-3.2.7/src/modules/rlm_proxy_rate_limit/rlm_proxy_rate_limit.c
--- freeradius-server-3.2.6/src/modules/rlm_proxy_rate_limit/rlm_proxy_rate_limit.c	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_proxy_rate_limit/rlm_proxy_rate_limit.c	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,512 @@
+/*
+ * Copyright (C) 2024 Network RADIUS SAS (legal@networkradius.com)
+ *
+ * This software may not be redistributed in any form without the prior
+ * written consent of Network RADIUS.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/**
+ * $Id: 1fe5bcc7415247e903312b91b8b9c24b9b13ee41 $
+ * @file rlm_proxy_rate_limit.c
+ * @brief Rate limiting when proxying requests
+ *
+ * @copyright 2024 Network RADIUS SAS (legal@networkradius.com)
+ */
+RCSID("$Id: 1fe5bcc7415247e903312b91b8b9c24b9b13ee41 $")
+
+#include <freeradius-devel/radiusd.h>
+#include <freeradius-devel/modules.h>
+#include <freeradius-devel/dlist.h>
+#include <freeradius-devel/rad_assert.h>
+
+#include <ctype.h>
+
+#ifdef HAVE_PTHREAD_H
+#include <pthread.h>
+
+#define PTHREAD_MUTEX_LOCK pthread_mutex_lock
+#define PTHREAD_MUTEX_UNLOCK pthread_mutex_unlock
+#else
+#define PTHREAD_MUTEX_LOCK(_x)
+#define PTHREAD_MUTEX_UNLOCK(_x)
+#endif
+
+/*
+ *	The default configuration will use all 256 subtables, but may
+ *	be configured to use fewer to simplify testing
+ */
+#define MAX_NUM_SUBTABLES		(256)
+
+typedef struct rlm_proxy_rate_limit_s rlm_proxy_rate_limit_t;
+
+/*
+ *	A subtable, together with an associated expiry list and mutex.
+ */
+typedef struct {
+	int			id;
+	rbtree_t		*tree;
+	fr_dlist_t		expiry_list;
+#ifdef HAVE_PTHREAD_H
+	pthread_mutex_t		mutex;
+#endif
+} rlm_proxy_rate_limit_table_t;
+
+typedef struct {
+	char				*key;
+	size_t				key_len;
+
+	time_t				expires;
+
+	/*
+	 *	Track the last RADIUS ID for the last request to
+	 *	differentiate retransmissions versus new requests (at
+	 *	least for serialised authentication attampts).
+	 */
+	int				last_id;
+
+	/*
+	 *	Time that last reject was received from the home server
+	 */
+	time_t				last_reject;
+
+	/*
+	 *	Time that last request was received from the end station
+	 */
+	time_t				last_request;
+
+	/*
+	 *	We only actively suppress after receiving two Access-Rejects from
+	 *	home servers within the same second.
+	 */
+	bool				active;
+
+	/*
+	 *	Rough count of number of times the rate has been
+	 *	exceeded since suppression began.
+	 */
+	int				count;
+
+	/*
+	 *	Table containing this entry so we can lookup relevant
+	 *	expiry_list and mutex during rbtree callbacks
+	 */
+	rlm_proxy_rate_limit_table_t	*table;
+
+	fr_dlist_t			dlist;
+} rlm_proxy_rate_limit_entry_t;
+
+struct rlm_proxy_rate_limit_s {
+
+	uint32_t			max_entries;
+	uint32_t			idle_timeout;
+	uint32_t			num_subtables;
+	uint32_t			window;
+
+	rlm_proxy_rate_limit_table_t	tables[MAX_NUM_SUBTABLES];
+
+};
+
+static const CONF_PARSER module_config[] = {
+	{ "max_entries", FR_CONF_OFFSET(PW_TYPE_INTEGER, rlm_proxy_rate_limit_t, max_entries), "65536" },
+	{ "idle_timeout", FR_CONF_OFFSET(PW_TYPE_INTEGER, rlm_proxy_rate_limit_t, idle_timeout), "2" },
+	{ "num_subtables", FR_CONF_OFFSET(PW_TYPE_INTEGER, rlm_proxy_rate_limit_t, num_subtables), "256" },
+	{ "window", FR_CONF_OFFSET(PW_TYPE_INTEGER, rlm_proxy_rate_limit_t, window), "1"},
+	CONF_PARSER_TERMINATOR
+};
+
+static inline CC_HINT(nonnull) rlm_proxy_rate_limit_entry_t *fr_dlist_head(fr_dlist_t const *head)
+{
+	if (head->prev == head) return NULL;
+
+	return (rlm_proxy_rate_limit_entry_t *) (((uintptr_t) head->next) - offsetof(rlm_proxy_rate_limit_entry_t, dlist));
+}
+
+static rlm_proxy_rate_limit_table_t* derive_key_and_table(rlm_proxy_rate_limit_t *inst, REQUEST *request, char *key, size_t *key_len) {
+
+	uint32_t	hash;
+	char		hash_hex[9];
+	VALUE_PAIR	*vp1, *vp2;
+
+	fr_assert(*key_len >= 6);	/* Satisfy analyser */
+
+	if ((vp1 = fr_pair_find_by_num(request->packet->vps, PW_USER_NAME, 0, TAG_ANY)) == NULL) {
+		RDEBUG("Not rate limiting a request without a User-Name attribute");
+		return NULL;
+	}
+
+	if ((vp2 = fr_pair_find_by_num(request->packet->vps, PW_CALLING_STATION_ID, 0, TAG_ANY)) == NULL) {
+		RDEBUG("Not rate limiting a request without a Calling-Station-ID attribute");
+		return NULL;
+	}
+
+	/*
+	 *	Should not happen since the buffer we are given is sufficient: 512 = 253 + 253 + 6
+	 */
+	if (unlikely(6 + vp1->vp_length + vp2->vp_length > *key_len)) {
+		RDEBUG("Not rate limiting a request where the key expansion is too large.");
+		return NULL;
+	}
+
+	/*
+	 *	key will be "HHHHHH{User-Name}{Calling-Station-Id}"
+	 */
+        memcpy(key + 6, vp1->vp_strvalue, vp1->vp_length);
+	memcpy(key + 6 + vp1->vp_length, vp2->vp_strvalue, vp2->vp_length);
+	*key_len = 6 + vp1->vp_length + vp2->vp_length;
+
+	/*
+	 *	Stable map of the key to a 4-octet value. Provides
+	 *	good distribution with similar prefixes.
+	 */
+	hash = fr_hash(key + 6, (*key_len) - 6);
+
+	/*
+	 *	First three octets are used as a prefix of the key,
+	 *	since usernames have much in common.
+	 */
+	snprintf(hash_hex, 9, "%08X", hash);
+	memcpy(key, hash_hex, 6);
+
+	/*
+	 *	Last octet used to pick one of the tables.
+	 */
+	return &inst->tables[(hash & 0xff) % inst->num_subtables];
+
+}
+
+/*
+ *	Check whether we have recently seen repeated Access-Rejects for this username
+ *      and calling station, and if this is a new request then issue an Access-Reject
+ */
+static rlm_rcode_t CC_HINT(nonnull) mod_pre_proxy(void * instance, REQUEST *request)
+{
+	rlm_proxy_rate_limit_t		*inst = instance;
+	char				key[512];
+	size_t				key_len = sizeof(key);
+	rlm_proxy_rate_limit_table_t	*table;
+	rlm_proxy_rate_limit_entry_t	*entry, my_entry;
+	VALUE_PAIR			*vp;
+
+	if (!(table = derive_key_and_table(inst, request, key, &key_len)))
+		return RLM_MODULE_OK;
+
+	my_entry.key = key;
+	my_entry.key_len = key_len;
+	entry = rbtree_finddata(table->tree, &my_entry);
+
+	if (!entry)
+		return RLM_MODULE_OK;
+
+	if (entry->expires <= request->timestamp) {
+		RDEBUG3("Rate limit entry %.*s (%d) has expired", 6, entry->key, entry->table->id);
+		rbtree_deletebydata(table->tree, entry);
+		return RLM_MODULE_OK;
+	};
+
+	/*
+	 *	@todo - add configurable threshold. For now, it's only one packet.
+	 */
+
+	/*
+	 *	Limit only when active and for new requests, not
+	 *	retransmissions.
+	 */
+	if (!entry->active || entry->last_id == request->packet->id)
+		return RLM_MODULE_OK;
+
+	RDEBUG("Active rate limit entry %.*s (%d) matched for new request. Cancelling proxy "
+		"and sending Access-Reject. Instance %d.", 6, entry->key, entry->table->id, entry->count);
+
+	/*
+	 *	Extend the suppression period for misbehaving devices that are continuing
+	 *	to send rapid requests (within the same second), i.e. they are not waiting
+	 *	for our (delayed) responses.
+	 *
+	 *	We don't do this unless the requests are very
+	 *	frequent, otherwise suppression would continue for so
+	 *	long as the end stations continues to periodically
+	 *	retry, which is likely not what we want.
+	 */
+	if ((request->timestamp - entry->last_request) < inst->window &&
+	    (entry->expires < request->timestamp + inst->idle_timeout)) {
+		entry->expires = request->timestamp + inst->idle_timeout;
+
+		PTHREAD_MUTEX_LOCK(&table->mutex);
+		fr_dlist_entry_unlink(&entry->dlist);
+		fr_dlist_insert_tail(&table->expiry_list, &entry->dlist);
+		PTHREAD_MUTEX_UNLOCK(&table->mutex);
+		RDEBUG3("Active rate limit entry %.*s (%d) extended", 6, entry->key, entry->table->id);
+	}
+
+	entry->last_request = request->timestamp;
+	entry->count++;
+
+	/*
+	 *  This new request arrived within the suppression interval. Don't proxy but
+	 *  return our own Access-Reject instead.
+	 *
+	 *  Allocating a proxy_reply and setting dst_port to 0 ensures that we send a
+	 *  delayed response.
+	 */
+	request->proxy_reply = rad_alloc_reply(request, request->proxy);
+	request->proxy_reply->code = PW_CODE_ACCESS_REJECT;
+	request->proxy->dst_port = 0;
+
+	vp = pair_make_reply("Reply-Message", "Proxy rate limit exceeded", T_OP_EQ);
+	if (!vp)
+		REDEBUG("Failed creating Reply-Message");
+
+	return RLM_MODULE_FAIL;
+
+}
+
+/*
+ *	Record Access-Rejects for (username + calling station) a key and store the ID.
+ *
+ *      Trigger suppression after receiving two Access Rejects within the same second.
+ */
+static rlm_rcode_t CC_HINT(nonnull) mod_post_proxy(void *instance, REQUEST *request)
+{
+	rlm_proxy_rate_limit_t		*inst = instance;
+	char				key[512];
+	size_t				key_len = sizeof(key);
+	rlm_proxy_rate_limit_table_t	*table;
+	rlm_proxy_rate_limit_entry_t	*entry, my_entry;
+
+	if (request->proxy_reply->code != PW_CODE_ACCESS_REJECT)
+		return RLM_MODULE_NOOP;
+
+	if (!(table = derive_key_and_table(inst, request, key, &key_len)))
+		return RLM_MODULE_OK;
+
+	my_entry.key = (char *)key;
+	my_entry.key_len = key_len;
+	entry = rbtree_finddata(table->tree, &my_entry);
+	if (!entry) {
+
+		/*
+		 *	Too many entries in the table.  Delete the oldest one.
+		 */
+		if (rbtree_num_elements(table->tree) > inst->max_entries) {
+			PTHREAD_MUTEX_LOCK(&table->mutex);
+			entry = fr_dlist_head(&table->expiry_list);
+			PTHREAD_MUTEX_UNLOCK(&table->mutex);
+
+			rbtree_deletebydata(table->tree, entry);
+		}
+
+		MEM(entry = talloc_zero(NULL, rlm_proxy_rate_limit_entry_t));
+
+		MEM(entry->key = talloc_memdup(entry, key, key_len));
+		entry->key_len = key_len;
+
+		fr_dlist_entry_init(&entry->dlist);
+		entry->table = table;
+		entry->active = false;
+		entry->last_request = entry->last_reject = request->timestamp;
+		entry->last_id = request->packet->id;
+
+		/*
+		 *	Set to "request->timestamp +
+		 *	inst->idle_timeout" if we at some point decide
+		 *	to periodically walk from the head of the
+		 *	expiry list to free expired entries.  (To
+		 *	maintain list in order of expiry time, without
+		 *	requiring two lists.)
+		 */
+		entry->expires = request->timestamp + 1;
+
+		/*
+		 *	Save it.
+		 */
+		if (!rbtree_insert(table->tree, entry)) {
+			talloc_free(entry);
+			return RLM_MODULE_OK;
+		}
+		RDEBUG3("Inactive rate limit entry %.*s (%d) saved", 6, entry->key, entry->table->id);
+
+	} else {
+
+		/*
+		 * Trigger suppression after two Access-Rejects from a home server
+		 * for different requests (not retransmissions) are received within
+		 * the same second.
+		 */
+		if (!entry->active && entry->last_id != request->packet->id &&
+		    request->timestamp - entry->last_reject < 1) {
+			entry->active = true;
+			entry->count = 0;
+			RDEBUG("Rate limit entry %.*s (%d) activated", 6, entry->key, entry->table->id);
+		} else {
+			RDEBUG3("Rate limit entry %.*s (%d) updated", 6, entry->key, entry->table->id);
+		}
+
+		entry->last_request = entry->last_reject = request->timestamp;
+		entry->last_id = request->packet->id;
+
+		/*
+		 * Ditto comment above ("request->timestamp + inst->idle_timeout") should we later
+		 * decide to proactively free expiry list entries.
+		 */
+		entry->expires = request->timestamp +
+			(entry->active ? inst->idle_timeout : 1);
+
+	}
+
+	PTHREAD_MUTEX_LOCK(&table->mutex);
+	fr_dlist_entry_unlink(&entry->dlist);
+	fr_dlist_insert_tail(&table->expiry_list, &entry->dlist);
+	PTHREAD_MUTEX_UNLOCK(&table->mutex);
+
+	return RLM_MODULE_OK;
+}
+
+static int cmp_table_entry(void const *one, void const *two)
+{
+	rlm_proxy_rate_limit_entry_t const *a = (rlm_proxy_rate_limit_entry_t const *) one;
+	rlm_proxy_rate_limit_entry_t const *b = (rlm_proxy_rate_limit_entry_t const *) two;
+
+	if (a->key_len < b->key_len) return -1;
+	if (a->key_len > b->key_len) return +1;
+
+	return memcmp(a->key, b->key, a->key_len);
+}
+
+static void free_table_entry(void *data)
+{
+	rlm_proxy_rate_limit_entry_t *entry = (rlm_proxy_rate_limit_entry_t *) data;
+
+	PTHREAD_MUTEX_LOCK(&entry->table->mutex);
+	fr_dlist_entry_unlink(&entry->dlist);
+	PTHREAD_MUTEX_UNLOCK(&entry->table->mutex);
+
+	talloc_free(entry);
+}
+
+static int mod_instantiate(CONF_SECTION *conf, void *instance)
+{
+	int i;
+	rlm_proxy_rate_limit_t *inst = instance;
+
+	FR_INTEGER_BOUND_CHECK("max_entries", inst->max_entries, <=, ((uint32_t) 1) << 20);
+	FR_INTEGER_BOUND_CHECK("max_entries", inst->max_entries, >=, 1);
+
+	FR_INTEGER_BOUND_CHECK("idle_timeout", inst->idle_timeout, <=, 10);
+	FR_INTEGER_BOUND_CHECK("idle_timeout", inst->idle_timeout, >=, 1);
+
+	if (!inst->window) {
+		inst->window = 1;
+	} else {
+		FR_INTEGER_BOUND_CHECK("window", inst->window, <=, 5);
+	}
+
+	/* Undocumented. Intended to simplify testing. */
+	if (!inst->num_subtables) {
+		inst->num_subtables = MAX_NUM_SUBTABLES;
+	} else {
+		FR_INTEGER_BOUND_CHECK("num_subtables", inst->num_subtables, <=, MAX_NUM_SUBTABLES);
+		FR_INTEGER_BOUND_CHECK("num_subtables", inst->num_subtables, >=, 1);
+	}
+
+	/*
+	 *	Don't worry the user about sub-tables.
+	 */
+	inst->max_entries /= inst->num_subtables;
+
+	/*
+	 *	Create a set of tables containing an rbtree, with
+	 *	associated expiry list and mutex
+	 *
+	 *	Multiple such structures mitigates lock contention.
+	 */
+	for (i = 0; i < (int)inst->num_subtables; i++) {
+
+		rlm_proxy_rate_limit_table_t *table = &inst->tables[i];
+
+		table->id = i;
+
+		if (!(table->tree = rbtree_create(inst, cmp_table_entry, free_table_entry, RBTREE_FLAG_LOCK))) {
+			cf_log_err_cs(conf, "Failed creating internal data structure for tracking table %d", i);
+			goto fail;
+		}
+
+		fr_dlist_entry_init(&table->expiry_list);
+#ifdef HAVE_PTHREAD_H
+		if (pthread_mutex_init(&table->mutex, NULL) < 0) {
+			rbtree_free(table->tree);		/* We just allocated this */
+			cf_log_err_cs(conf, "Failed creating mutex for tracking table %d", i);
+			goto fail;
+		}
+#endif
+
+	}
+
+	return 0;
+
+fail:
+
+	/*
+	 *  Release what we allocated prior to failure.
+	 *
+	 */
+	for (i--; i > 0; i--) {
+#ifdef HAVE_PTHREAD_H
+		pthread_mutex_destroy(&inst->tables[i].mutex);
+#endif
+		rbtree_free(inst->tables[i].tree);
+	}
+
+	return -1;
+
+}
+
+static int mod_detach(void *instance)
+{
+	rlm_proxy_rate_limit_t *inst = instance;
+	int i;
+
+	for (i = 0; i < (int)inst->num_subtables; i++) {
+#ifdef HAVE_PTHREAD_H
+		pthread_mutex_destroy(&inst->tables[i].mutex);
+#endif
+		rbtree_free(inst->tables[i].tree);
+	}
+
+	return 0;
+}
+
+/*
+ *	The module name should be the only globally exported symbol.
+ *	That is, everything else should be 'static'.
+ *
+ *	If the module needs to temporarily modify it's instantiation
+ *	data, the type should be changed to RLM_TYPE_THREAD_UNSAFE.
+ *	The server will then take care of ensuring that the module
+ *	is single-threaded.
+ */
+extern module_t rlm_proxy_rate_limit;
+module_t rlm_proxy_rate_limit = {
+	.magic		= RLM_MODULE_INIT,
+	.name		= "proxy_rate_limit",
+	.type		= RLM_TYPE_THREAD_SAFE,
+	.inst_size	= sizeof(rlm_proxy_rate_limit_t),
+	.config		= module_config,
+	.instantiate	= mod_instantiate,
+	.detach		= mod_detach,
+	.methods = {
+		[MOD_PRE_PROXY]		= mod_pre_proxy,
+		[MOD_POST_PROXY]	= mod_post_proxy,
+	},
+};
diff -urpN freeradius-server-3.2.6/src/modules/rlm_python3/rlm_python3.c freeradius-server-3.2.7/src/modules/rlm_python3/rlm_python3.c
--- freeradius-server-3.2.6/src/modules/rlm_python3/rlm_python3.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_python3/rlm_python3.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 48deaa37a6a0a9edc39c4661678e15ee20629b05 $
+ * $Id: 4f0f68d7f3416ff362de68b87c09b05b5981826b $
  * @file rlm_python3.c
  * @brief Translates requests between the server an a python interpreter.
  *
@@ -25,7 +25,7 @@
  * @copyright 2002  Miguel A.L. Paraz <mparaz@mparaz.com>
  * @copyright 2002  Imperium Technology, Inc.
  */
-RCSID("$Id: 48deaa37a6a0a9edc39c4661678e15ee20629b05 $")
+RCSID("$Id: 4f0f68d7f3416ff362de68b87c09b05b5981826b $")
 
 #define LOG_PREFIX "rlm_python3 - "
 
@@ -90,6 +90,7 @@ static CONF_PARSER module_config[] = {
 #undef A
 
         { "python_path", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_python_t, python_path), NULL },
+	{ "python_path_mode", FR_CONF_OFFSET(PW_TYPE_STRING, rlm_python_t, python_path_mode_str), "append" },
         { "cext_compat", FR_CONF_OFFSET(PW_TYPE_BOOLEAN, rlm_python_t, cext_compat), "yes" },
         { "pass_all_vps", FR_CONF_OFFSET(PW_TYPE_BOOLEAN, rlm_python_t, pass_all_vps), "no" },
         { "pass_all_vps_dict", FR_CONF_OFFSET(PW_TYPE_BOOLEAN, rlm_python_t, pass_all_vps_dict), "no" },
@@ -133,6 +134,19 @@ static struct {
 	{ NULL, 0 },
 };
 
+typedef enum {
+	PYTHON_PATH_MODE_APPEND,
+	PYTHON_PATH_MODE_PREPEND,
+	PYTHON_PATH_MODE_OVERWRITE
+} py_path_mode;
+
+FR_NAME_NUMBER const python_path_mode[] = {
+	{ "append",	PYTHON_PATH_MODE_APPEND    },
+	{ "prepend",	PYTHON_PATH_MODE_PREPEND   },
+	{ "overwrite",	PYTHON_PATH_MODE_OVERWRITE },
+	{ NULL, -1 }
+};
+
 /*
  *	This allows us to initialise PyThreadState on a per thread basis
  */
@@ -204,12 +218,12 @@ static void python_error_log(void)
 		return;
 	}
 
-	if (((pStr1 = PyObject_Str(pExcType)) != NULL) && 
+	if (((pStr1 = PyObject_Str(pExcType)) != NULL) &&
 	    ((pStr2 = PyObject_Str(pExcValue)) != NULL)) {
 		ERROR("%s:%d, Exception type: %s, Exception value: %s", __func__, __LINE__, PyUnicode_AsUTF8(pStr1), PyUnicode_AsUTF8(pStr2));
 		Py_DECREF(pStr1);
 		Py_DECREF(pStr2);
-	} 
+	}
 
 	if (pExcTraceback) {
 		PyObject *pRepr = PyObject_Repr(pExcTraceback);
@@ -389,7 +403,7 @@ static int mod_populate_vptuple(PyObject
 			python_error_log();
 			PyErr_Clear();
 		}
-		
+
 		return -1;
 	}
 
@@ -1036,7 +1050,12 @@ static void *dlopen_libpython(int flags)
 /*
  * creates a module "radiusd"
  */
+#if PY_MINOR_VERSION >= 9
+PyMODINIT_FUNC PyInit_radiusd(void);
+PyMODINIT_FUNC PyInit_radiusd(void)
+#else
 static PyMODINIT_FUNC PyInit_radiusd(void)
+#endif
 {
 	CONF_SECTION *cs;
 	/*
@@ -1169,12 +1188,16 @@ static int python_interpreter_init(rlm_p
 
 #if PY_VERSION_HEX <= 0x030a0000
 		Py_InitializeEx(0);			/* Don't override signal handlers - noop on subs calls */
+#if PY_VERSION_HEX <= 0x03060000
 		PyEval_InitThreads(); 			/* This also grabs a lock (which we then need to release) */
 #endif
+#endif
 		main_interpreter = PyThreadState_Get();	/* Store reference to the main interpreter */
 		locked = true;
 	}
+#if PY_VERSION_HEX < 0x03090000
 	rad_assert(PyEval_ThreadsInitialized());
+#endif
 
 	/*
 	 *	Increment the reference counter
@@ -1210,25 +1233,38 @@ static int python_interpreter_init(rlm_p
 		if (inst->python_path) {
 			char *p, *path;
 			PyObject *sys = PyImport_ImportModule("sys");
-			PyObject *sys_path = PyObject_GetAttrString(sys, "path");
+			PyObject *sys_path;
+			Py_ssize_t i = 0;
 
 			memcpy(&p, &inst->python_path, sizeof(path));
 
+			if (inst->python_path_mode == PYTHON_PATH_MODE_OVERWRITE) {
+				sys_path = PyList_New(0);
+			} else {
+				sys_path = PyObject_GetAttrString(sys, "path");
+			}
+
 			for (path = strtok(p, ":"); path != NULL; path = strtok(NULL, ":")) {
-#if PY_VERSION_HEX > 0x03050000
+#if PY_VERSION_HEX > 0x03000000
 				wchar_t *py_path;
 
+#if PY_VERSION_HEX > 0x03050000
 				MEM(py_path = Py_DecodeLocale(path, NULL));
-				PyList_Append(sys_path, PyUnicode_FromWideChar(py_path, -1));
-				PyMem_RawFree(py_path);
-#elif PY_VERSION_HEX > 0x03000000
-				wchar_t *py_path;
-
+#else
 				MEM(py_path = _Py_char2wchar(path, NULL));
-				PyList_Append(sys_path, PyUnicode_FromWideChar(py_path, -1));
+#endif
+				if (inst->python_path_mode == PYTHON_PATH_MODE_PREPEND) {
+					PyList_Insert(sys_path, i++, PyUnicode_FromWideChar(py_path, -1));
+				} else {
+					PyList_Append(sys_path, PyUnicode_FromWideChar(py_path, -1));
+				}
 				PyMem_RawFree(py_path);
 #else
-				PyList_Append(sys_path, PyLong_FromString(path));
+				if (inst->python_path_mode == PYTHON_PATH_PREPEND) {
+					PyList_Insert(sys_path, i++, PyLong_FromString(path));
+				} ekse {
+					PyList_Append(sys_path, PyLong_FromString(path));
+				}
 #endif
 			}
 
@@ -1267,6 +1303,13 @@ static int mod_instantiate(CONF_SECTION
 	inst->name = cf_section_name2(conf);
 	if (!inst->name) inst->name = cf_section_name1(conf);
 
+	inst->python_path_mode = fr_str2int(python_path_mode, inst->python_path_mode_str, -1);
+	if (inst->python_path_mode < 0) {
+		cf_log_err_cs(conf, "Invalid 'python_path_mode' value \"%s\", expected 'append', "
+			      "'prepend' or 'overwrite'", inst->python_path_mode_str);
+		return -1;
+	}
+
 	/*
 	 *	Load the python code required for this module instance
 	 */
@@ -1299,9 +1342,9 @@ static int mod_instantiate(CONF_SECTION
 	PYTHON_FUNC_LOAD(detach);
 
 	/*
-	 *	Call the instantiate function only if the function and module is set.
+	 *	Call the instantiate function only if the function and module is set and we're not doing a config check.
 	 */
-	if (inst->instantiate.module_name && inst->instantiate.function_name) {
+	if (!check_config && inst->instantiate.module_name && inst->instantiate.function_name) {
 
 		code = do_python_single(NULL, inst->instantiate.function, "instantiate", inst->pass_all_vps, inst->pass_all_vps_dict);
 		if (code < 0) {
@@ -1326,7 +1369,7 @@ static int mod_detach(void *instance)
 	 */
 	PyEval_RestoreThread(inst->sub_interpreter);
 
-	if (inst->detach.function) ret = do_python_single(NULL, inst->detach.function, "detach", inst->pass_all_vps, inst->pass_all_vps_dict);
+	if (!check_config && inst->detach.function) ret = do_python_single(NULL, inst->detach.function, "detach", inst->pass_all_vps, inst->pass_all_vps_dict);
 
 #define PYTHON_FUNC_DESTROY(_x) python_function_destroy(&inst->_x)
 	PYTHON_FUNC_DESTROY(instantiate);
@@ -1366,7 +1409,7 @@ static int mod_detach(void *instance)
 	if (!inst->cext_compat) python_interpreter_free(inst->sub_interpreter);
 
 	if ((--python_instances) == 0) {
-		PyThreadState_Swap(main_interpreter); /* Swap to the main thread */
+		PyEval_RestoreThread(main_interpreter); /* Swap to the main thread */
 		Py_Finalize();
 		dlclose(python_dlhandle);
 	}
diff -urpN freeradius-server-3.2.6/src/modules/rlm_python3/rlm_python3.h freeradius-server-3.2.7/src/modules/rlm_python3/rlm_python3.h
--- freeradius-server-3.2.6/src/modules/rlm_python3/rlm_python3.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_python3/rlm_python3.h	2025-01-31 18:42:21.000000000 +0700
@@ -21,6 +21,8 @@ typedef struct rlm_python_t {
 	char const	*name;			//!< Name of the module instance
 	PyThreadState	*sub_interpreter;	//!< The main interpreter/thread used for this instance.
 	char const	*python_path;		//!< Path to search for python files in.
+	char const	*python_path_mode_str;	//!< How to use the value of `python_path`.
+	int		python_path_mode;
 	PyObject	*module;		//!< Local, interpreter specific module, containing
 						//!< FreeRADIUS functions.
 	bool		cext_compat;		//!< Whether or not to create sub-interpreters per module
diff -urpN freeradius-server-3.2.6/src/modules/rlm_rest/rest.c freeradius-server-3.2.7/src/modules/rlm_rest/rest.c
--- freeradius-server-3.2.6/src/modules/rlm_rest/rest.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_rest/rest.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 035f5578fe749c6c0ed4e046a02bafa4626f60f9 $
+ * $Id: d18c0084575951f3d27b8aa287c17cedc83527bf $
  *
  * @brief Functions and datatypes for the REST (HTTP) transport.
  * @file rest.c
@@ -23,7 +23,7 @@
  * @copyright 2012-2014  Arran Cudbard-Bell <a.cudbard-bell@freeradius.org>
  */
 
-RCSID("$Id: 035f5578fe749c6c0ed4e046a02bafa4626f60f9 $")
+RCSID("$Id: d18c0084575951f3d27b8aa287c17cedc83527bf $")
 
 #include <ctype.h>
 #include <string.h>
@@ -394,7 +394,7 @@ void *mod_conn_create(TALLOC_CTX *ctx, v
 	CURL *candle = curl_easy_init();
 
 	CURLcode ret = CURLE_OK;
-	char const *option = "unknown";
+	char const *option;
 
 	if (!candle) {
 		ERROR("rlm_rest (%s): Failed to create CURL handle", inst->xlat_name);
@@ -480,10 +480,15 @@ int mod_conn_alive(void *instance, void
 	rlm_rest_handle_t	*randle = handle;
 	CURL			*candle = randle->handle;
 
-	long last_socket;
 	CURLcode ret;
 
-	ret = curl_easy_getinfo(candle, CURLINFO_LASTSOCKET, &last_socket);
+#if CURL_AT_LEAST_VERSION(7,45,0)
+	curl_socket_t	socket;
+	ret = curl_easy_getinfo(candle, CURLINFO_ACTIVESOCKET, &socket);
+#else
+	long	socket;
+	ret = curl_easy_getinfo(candle, CURLINFO_LASTSOCKET, &socket);
+#endif
 	if (ret != CURLE_OK) {
 		ERROR("rlm_rest (%s): Couldn't determine socket state: %i - %s", inst->xlat_name, ret,
 		      curl_easy_strerror(ret));
@@ -491,7 +496,7 @@ int mod_conn_alive(void *instance, void
 		return false;
 	}
 
-	if (last_socket == -1) {
+	if (socket == -1) {
 		return false;
 	}
 
@@ -1960,7 +1965,7 @@ static int rest_request_config_body(UNUS
 	CURL			*candle = handle->handle;
 
 	CURLcode ret = CURLE_OK;
-	char const *option = "unknown";
+	char const *option;
 
 	ssize_t len;
 
@@ -2040,7 +2045,7 @@ int rest_request_config(rlm_rest_t *inst
 	http_auth_type_t	auth = section->auth;
 
 	CURLcode	ret = CURLE_OK;
-	char const	*option = "unknown";
+	char const	*option;
 	char const	*content_type;
 
 	VALUE_PAIR 	*header;
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_mysql/rlm_sql_mysql.c freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_mysql/rlm_sql_mysql.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_mysql/rlm_sql_mysql.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_mysql/rlm_sql_mysql.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 06f5dc96a918d70d3272f6adaf316f88f3dec54a $
+ * $Id: f52ec0b0f19fafe411e46679daa656cc8ed59e25 $
  * @file rlm_sql_mysql.c
  * @brief MySQL driver.
  *
@@ -24,7 +24,7 @@
  * @copyright 2000  Mike Machado <mike@innercite.com>
  * @copyright 2000  Alan DeKok <aland@ox.org>
  */
-RCSID("$Id: 06f5dc96a918d70d3272f6adaf316f88f3dec54a $")
+RCSID("$Id: f52ec0b0f19fafe411e46679daa656cc8ed59e25 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -299,14 +299,18 @@ static sql_rcode_t sql_socket_init(rlm_s
 
 	mysql_options(&(conn->db), MYSQL_READ_DEFAULT_GROUP, "freeradius");
 
+#if MYSQL_VERSION_ID < 80034
 	/*
 	 *	We need to know about connection errors, and are capable
 	 *	of reconnecting automatically.
+	 *
+	 *	This deprecated as of 8.0.34.
 	 */
 	{
 		int reconnect = 0;
 		mysql_options(&(conn->db), MYSQL_OPT_RECONNECT, &reconnect);
 	}
+#endif
 
 	if (config->query_timeout) {
 		unsigned int connect_timeout = config->query_timeout;
@@ -385,6 +389,9 @@ static sql_rcode_t sql_check_error(MYSQL
 	if (sql_errno > 0) switch (sql_errno) {
 	case CR_SERVER_GONE_ERROR:
 	case CR_SERVER_LOST:
+#ifdef ER_CLIENT_INTERACTION_TIMEOUT
+	case ER_CLIENT_INTERACTION_TIMEOUT:
+#endif
 	case -1:
 		return RLM_SQL_RECONNECT;
 
@@ -430,6 +437,14 @@ static sql_rcode_t sql_check_error(MYSQL
 	case ER_NON_UNIQ_ERROR:			/* Column '%s' in %s is ambiguous */
 		return RLM_SQL_QUERY_INVALID;
 
+	/*
+	 *	Constraints errors that signify no data returned.
+	 *
+	 *	This is considered OK as the caller may look for the next result set.
+	 */
+	case ER_SP_FETCH_NO_DATA:
+		return RLM_SQL_OK;
+
 	}
 
 	return RLM_SQL_OK;
@@ -544,9 +559,12 @@ static sql_rcode_t sql_fetch_row(rlm_sql
 
 	/*
 	 *  Check pointer before de-referencing it.
+	 *  Lack of conn->result is either an error, or no result returned.
 	 */
 	if (!conn->result) {
-		return RLM_SQL_RECONNECT;
+		rcode = sql_check_error(conn->sock, 0);
+		if (rcode == RLM_SQL_OK) return RLM_SQL_NO_MORE_ROWS;
+		return rcode;
 	}
 
 	TALLOC_FREE(handle->row);		/* Clear previous row set */
@@ -696,6 +714,8 @@ static size_t sql_error(TALLOC_CTX *ctx,
 	if (error && (error[0] != '\0')) {
 		error = talloc_asprintf(ctx, "ERROR %u (%s): %s", mysql_errno(conn->sock), error,
 					mysql_sqlstate(conn->sock));
+	} else {
+		error = NULL;
 	}
 
 	/*
@@ -734,8 +754,8 @@ static size_t sql_error(TALLOC_CTX *ctx,
 	if (error) {
 		out[i].type = L_ERR;
 		out[i].msg = error;
+		i++;
 	}
-	i++;
 
 	return i;
 }
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_oracle/rlm_sql_oracle.c freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_oracle/rlm_sql_oracle.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_oracle/rlm_sql_oracle.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_oracle/rlm_sql_oracle.c	2025-01-31 18:42:21.000000000 +0700
@@ -19,7 +19,7 @@
  * Copyright 2000  David Kerry <davidk@snti.com>
  */
 
-RCSID("$Id: 9fe8a191306d6a20edb5567ddedb4d73ede5cd3d $")
+RCSID("$Id: bfddcc5dea45d46b23cd63b49fda7d502a773c94 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -115,15 +115,17 @@ static int sql_check_error(rlm_sql_handl
 {
 	char errbuff[512];
 
-	if (sql_prints_error(errbuff, sizeof(errbuff), handle, config) < 0) goto unknown;
+	if (sql_prints_error(errbuff, sizeof(errbuff), handle, config) < 0) {
+		ERROR("rlm_sql_oracle: OCI_SERVER_NORMAL");
+		return -1;
+	}
 
 	if (strstr(errbuff, "ORA-03113") || strstr(errbuff, "ORA-03114")) {
 		ERROR("rlm_sql_oracle: OCI_SERVER_NOT_CONNECTED");
 		return RLM_SQL_RECONNECT;
 	}
 
-unknown:
-	ERROR("rlm_sql_oracle: OCI_SERVER_NORMAL");
+	ERROR("rlm_sql_oracle: error %s", errbuff);
 	return -1;
 }
 
@@ -437,6 +439,7 @@ static sql_rcode_t sql_finish_query(UNUS
 
 	if (OCIStmtRelease(conn->query, conn->error, NULL, 0, OCI_DEFAULT) != OCI_SUCCESS ) {
 		ERROR("OCI release failed in sql_finish_query");
+		(void) sql_check_error(handle, config);
 		return RLM_SQL_ERROR;
 	}
 
@@ -452,7 +455,8 @@ static sql_rcode_t sql_finish_select_que
 	conn->col_count = 0;
 
 	if (OCIStmtRelease (conn->query, conn->error, NULL, 0, OCI_DEFAULT) != OCI_SUCCESS ) {
-		ERROR("OCI release failed in sql_finish_query");
+		ERROR("OCI release failed in sql_finish_select_query");
+		(void) sql_check_error(handle, config);
 		return RLM_SQL_ERROR;
 	}
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/config.h.in freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/config.h.in
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/config.h.in	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/config.h.in	2025-01-31 18:42:21.000000000 +0700
@@ -6,6 +6,9 @@
 /* Whether the PGRES_SINGLE_TUPLE constant is defined */
 #undef HAVE_PGRES_SINGLE_TUPLE
 
+/* Whether the PGRES_TUPLES_CHUNK constant is defined */
+#undef HAVE_PGRES_TUPLES_CHUNK
+
 /* Whether the PGRES_PIPELINE_SYNC constant is defined */
 #undef HAVE_PGRES_PIPELINE_SYNC
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure	2025-01-31 18:42:21.000000000 +0700
@@ -2931,6 +2931,38 @@ $as_echo "no" >&6; }
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for PGRES_TUPLES_CHUNK" >&5
+$as_echo_n "checking for PGRES_TUPLES_CHUNK... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <libpq-fe.h>
+int
+main ()
+{
+
+			if (PGRES_TUPLES_CHUNK) return 0;
+			return 1;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+
+$as_echo "#define HAVE_PGRES_TUPLES_CHUNK 1" >>confdefs.h
+
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for PGRES_COPY_BOTH" >&5
 $as_echo_n "checking for PGRES_COPY_BOTH... " >&6; }
 	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure.ac freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure.ac
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure.ac	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/configure.ac	2025-01-31 18:42:21.000000000 +0700
@@ -64,6 +64,21 @@ else
 			AC_MSG_RESULT(no)
 		])
 
+	AC_MSG_CHECKING([for PGRES_TUPLES_CHUNK])
+	AC_COMPILE_IFELSE(
+		[AC_LANG_PROGRAM([#include <libpq-fe.h>], [[
+			if (PGRES_TUPLES_CHUNK) return 0;
+			return 1;
+		]])],
+		[
+			AC_DEFINE([HAVE_PGRES_TUPLES_CHUNK], [1],
+				[Whether the PGRES_TUPLES_CHUNK constant is defined])
+			AC_MSG_RESULT(yes)
+		],
+		[
+			AC_MSG_RESULT(no)
+		])
+
 	AC_MSG_CHECKING([for PGRES_COPY_BOTH])
 	AC_COMPILE_IFELSE(
 		[AC_LANG_PROGRAM([#include <libpq-fe.h>], [[
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/rlm_sql_postgresql.c freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/rlm_sql_postgresql.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_postgresql/rlm_sql_postgresql.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_postgresql/rlm_sql_postgresql.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * sql_postgresql.c		Postgresql rlm_sql driver
  *
- * Version:	$Id: c88d8b05a67289537a5c339f62ac37e091176d98 $
+ * Version:	$Id: 9d7fe3218d94b14a75477a46f617da3dd237f022 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -37,7 +37,7 @@
  * Bernhard Herzog <bh@intevation.de>
  */
 
-RCSID("$Id: c88d8b05a67289537a5c339f62ac37e091176d98 $")
+RCSID("$Id: 9d7fe3218d94b14a75477a46f617da3dd237f022 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -420,6 +420,9 @@ static CC_HINT(nonnull) sql_rcode_t sql_
 #ifdef HAVE_PGRES_SINGLE_TUPLE
 	case PGRES_SINGLE_TUPLE:
 #endif
+#ifdef HAVE_PGRES_TUPLES_CHUNK
+	case PGRES_TUPLES_CHUNK:
+#endif
 	case PGRES_TUPLES_OK:
 		conn->cur_row = 0;
 		conn->affected_rows = PQntuples(conn->result);
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_sqlite/rlm_sql_sqlite.c freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_sqlite/rlm_sql_sqlite.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_sqlite/rlm_sql_sqlite.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_sqlite/rlm_sql_sqlite.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,14 +15,14 @@
  */
 
 /**
- * $Id: 87227ca549d582658d8e9d09dc3ada20735d37e0 $
+ * $Id: 37f8ba99cc3eaae02df95448cc7f950570ad26af $
  * @file rlm_sql_sqlite.c
  * @brief SQLite driver.
  *
  * @copyright 2013 Network RADIUS SARL <info@networkradius.com>
  * @copyright 2007 Apple Inc.
  */
-RCSID("$Id: 87227ca549d582658d8e9d09dc3ada20735d37e0 $")
+RCSID("$Id: 37f8ba99cc3eaae02df95448cc7f950570ad26af $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -151,7 +151,7 @@ static sql_rcode_t sql_check_error(sqlit
 	}
 
 	if (status != SQLITE_OK) return sql_error_to_rcode(status);
-	if (hstatus != SQLITE_OK) return sql_error_to_rcode(status);
+	if (hstatus != SQLITE_OK) return sql_error_to_rcode(hstatus);
 
 	return RLM_SQL_OK;
 }
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_unixodbc/rlm_sql_unixodbc.c freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_unixodbc/rlm_sql_unixodbc.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/drivers/rlm_sql_unixodbc/rlm_sql_unixodbc.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/drivers/rlm_sql_unixodbc/rlm_sql_unixodbc.c	2025-01-31 18:42:21.000000000 +0700
@@ -19,7 +19,7 @@
  * Copyright 2000  Dmitri Ageev <d_ageev@ortcc.ru>
  */
 
-RCSID("$Id: 248b55e8faf9bec0fb13a75fd37814651e5f01d5 $")
+RCSID("$Id: 59f5a4d240d0387c721348a22d7a838eef3106cd $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/rad_assert.h>
@@ -40,7 +40,7 @@ USES_APPLE_DEPRECATED_API
 #include <sqlext.h>
 
 /* Forward declarations */
-static int sql_check_error(long err_handle, rlm_sql_handle_t *handle, rlm_sql_config_t *config);
+static sql_rcode_t sql_check_error(long err_handle, rlm_sql_handle_t *handle, rlm_sql_config_t *config);
 static sql_rcode_t sql_free_result(rlm_sql_handle_t *handle, rlm_sql_config_t *config);
 static int sql_affected_rows(rlm_sql_handle_t *handle, rlm_sql_config_t *config);
 static int sql_num_fields(rlm_sql_handle_t *handle, rlm_sql_config_t *config);
@@ -121,7 +121,7 @@ static sql_rcode_t sql_query(rlm_sql_han
 {
 	rlm_sql_unixodbc_conn_t *conn = handle->conn;
 	long err_handle;
-	int state;
+	sql_rcode_t state;
 
 	/* Executing query */
 	{
@@ -186,7 +186,7 @@ static sql_rcode_t sql_fetch_row(rlm_sql
 {
 	rlm_sql_unixodbc_conn_t *conn = handle->conn;
 	long err_handle;
-	int state;
+	sql_rcode_t state;
 
 	handle->row = NULL;
 
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/rlm_sql.c freeradius-server-3.2.7/src/modules/rlm_sql/rlm_sql.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/rlm_sql.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/rlm_sql.c	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 4989dd484b982d09e30f2346ce87e54c88469ef0 $
+ * $Id: 9d21243683894524f6e80096ecdda40a7fe3851f $
  * @file rlm_sql.c
  * @brief Implements SQL 'users' file, and SQL accounting.
  *
@@ -24,7 +24,7 @@
  * @copyright 2000  Mike Machado <mike@innercite.com>
  * @copyright 2000  Alan DeKok <aland@ox.org>
  */
-RCSID("$Id: 4989dd484b982d09e30f2346ce87e54c88469ef0 $")
+RCSID("$Id: 9d21243683894524f6e80096ecdda40a7fe3851f $")
 
 #include <ctype.h>
 
@@ -1706,7 +1706,7 @@ static rlm_rcode_t mod_checksimul(void *
 
 		num_rows = (inst->module->sql_num_fields)(handle, inst->config);
 		if (num_rows < 8) {
-			RDEBUG("Too few rows returned.  Please do not edit 'simul_verify_query'");
+			WARN("SELECT returned too few fields.  Please do not edit 'simul_verify_query'");
 			rcode = RLM_MODULE_FAIL;
 
 			goto finish;
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/rlm_sql.h freeradius-server-3.2.7/src/modules/rlm_sql/rlm_sql.h
--- freeradius-server-3.2.6/src/modules/rlm_sql/rlm_sql.h	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/rlm_sql.h	2025-01-31 18:42:21.000000000 +0700
@@ -15,7 +15,7 @@
  */
 
 /**
- * $Id: 5af8db40905fa83358081d70b1525090c77d8e1e $
+ * $Id: 78ab86b04112cdc1789828627b96612950547da6 $
  * @file rlm_sql.h
  * @brief Prototypes and functions for the SQL module
  *
@@ -27,7 +27,7 @@
 #ifndef _RLM_SQL_H
 #define _RLM_SQL_H
 
-RCSIDH(rlm_sql_h, "$Id: 5af8db40905fa83358081d70b1525090c77d8e1e $")
+RCSIDH(rlm_sql_h, "$Id: 78ab86b04112cdc1789828627b96612950547da6 $")
 
 #include <freeradius-devel/radiusd.h>
 #include <freeradius-devel/connection.h>
@@ -194,7 +194,7 @@ typedef struct rlm_sql_module_t {
 	char const	*name;
 	int		flags;
 
-	sql_rcode_t (*mod_instantiate)(CONF_SECTION *conf, rlm_sql_config_t *config);
+	int (*mod_instantiate)(CONF_SECTION *conf, rlm_sql_config_t *config);
 	sql_rcode_t (*sql_socket_init)(rlm_sql_handle_t *handle, rlm_sql_config_t *config);
 
 	sql_rcode_t (*sql_query)(rlm_sql_handle_t *handle, rlm_sql_config_t *config, char const *query);
@@ -252,7 +252,7 @@ int		sql_dict_init(rlm_sql_handle_t *han
 void 		CC_HINT(nonnull (1, 2, 4)) rlm_sql_query_log(rlm_sql_t *inst, REQUEST *request, sql_acct_section_t *section, char const *query);
 sql_rcode_t	CC_HINT(nonnull (1, 3, 4)) rlm_sql_select_query(rlm_sql_t *inst, REQUEST *request, rlm_sql_handle_t **handle, char const *query);
 sql_rcode_t	CC_HINT(nonnull (1, 3, 4)) rlm_sql_query(rlm_sql_t *inst, REQUEST *request, rlm_sql_handle_t **handle, char const *query);
-int		rlm_sql_fetch_row(rlm_sql_t *inst, REQUEST *request, rlm_sql_handle_t **handle);
+sql_rcode_t	rlm_sql_fetch_row(rlm_sql_t *inst, REQUEST *request, rlm_sql_handle_t **handle);
 void		rlm_sql_print_error(rlm_sql_t *inst, REQUEST *request, rlm_sql_handle_t *handle, bool force_debug);
 int		sql_set_user(rlm_sql_t *inst, REQUEST *request, char const *username);
 #endif
diff -urpN freeradius-server-3.2.6/src/modules/rlm_sql/sql.c freeradius-server-3.2.7/src/modules/rlm_sql/sql.c
--- freeradius-server-3.2.6/src/modules/rlm_sql/sql.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/rlm_sql/sql.c	2025-01-31 18:42:21.000000000 +0700
@@ -2,7 +2,7 @@
  *  sql.c		rlm_sql - FreeRADIUS SQL Module
  *		Main code directly taken from ICRADIUS
  *
- * Version:	$Id: a18e00b1fe7bc6c189ef5d0aaaed3b9d3d9d8b00 $
+ * Version:	$Id: 59f81e44092e52f7b0219fee2b8fa9b7308de72d $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -24,7 +24,7 @@
  * Copyright 2001  Chad Miller <cmiller@surfsouth.com>
  */
 
-RCSID("$Id: a18e00b1fe7bc6c189ef5d0aaaed3b9d3d9d8b00 $")
+RCSID("$Id: 59f81e44092e52f7b0219fee2b8fa9b7308de72d $")
 
 #include	<freeradius-devel/radiusd.h>
 #include	<freeradius-devel/rad_assert.h>
@@ -191,7 +191,7 @@ int sql_fr_pair_list_afrom_str(TALLOC_CT
  */
 sql_rcode_t rlm_sql_fetch_row(rlm_sql_t *inst, REQUEST *request, rlm_sql_handle_t **handle)
 {
-	int ret;
+	sql_rcode_t ret;
 
 	if (!*handle || !(*handle)->conn) return RLM_SQL_ERROR;
 
diff -urpN freeradius-server-3.2.6/src/modules/stable freeradius-server-3.2.7/src/modules/stable
--- freeradius-server-3.2.6/src/modules/stable	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/modules/stable	2025-01-31 18:42:21.000000000 +0700
@@ -25,6 +25,7 @@ rlm_pap
 rlm_passwd
 rlm_perl
 rlm_preprocess
+rlm_proxy_rate_limit
 rlm_python
 rlm_python3
 rlm_radutmp
diff -urpN freeradius-server-3.2.6/src/tests/eap-teap-mschap-tls.conf freeradius-server-3.2.7/src/tests/eap-teap-mschap-tls.conf
--- freeradius-server-3.2.6/src/tests/eap-teap-mschap-tls.conf	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/eap-teap-mschap-tls.conf	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,28 @@
+#
+#   eapol_test -c eap-teap.conf -s testing123
+#
+network={
+	key_mgmt=IEEE8021X
+	eap=TEAP
+
+	anonymous_identity="anonymous"
+	ca_cert="../../raddb/certs/ca.pem"
+	phase1="teap_compat=freeradius,tls_disable_tlsv1_0=1,tls_disable_tlsv1_1=1"
+
+	#
+	#  User Credentials
+	#
+	phase2="auth=MSCHAPV2"
+	identity="bob"
+	password="bob"
+
+	#
+	#  Machine Credentials
+	#
+	machine_phase2="auth=TLS"
+	machine_identity="machine"
+	machine_ca_cert="../../raddb/certs/ca.pem"
+	machine_client_cert="../../raddb/certs/client.crt"
+	machine_private_key="../../raddb/certs/client.key"
+	machine_private_key_passwd="whatever"
+}
diff -urpN freeradius-server-3.2.6/src/tests/eap-teap-mschap-x2.conf freeradius-server-3.2.7/src/tests/eap-teap-mschap-x2.conf
--- freeradius-server-3.2.6/src/tests/eap-teap-mschap-x2.conf	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/eap-teap-mschap-x2.conf	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,25 @@
+#
+#   eapol_test -c eap-teap-mschapv2.conf -s testing123
+#
+network={
+	key_mgmt=IEEE8021X
+	eap=TEAP
+
+	anonymous_identity="anonymous"
+	phase1="teap_compat=freeradius,tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=1 tls_disable_tlsv1_2=1 tls_disable_tlsv1_3=0"
+	ca_cert="../../raddb/certs/ca.pem"
+
+	#
+	#  User Credentials
+	#
+	identity="bob"
+	password="bob"
+	phase2="auth=MSCHAPV2"
+
+	#
+	#  Machine Credentials
+	#
+	machine_identity="machine"
+	machine_password="machine"
+	machine_phase2="auth=MSCHAPv2"
+}
diff -urpN freeradius-server-3.2.6/src/tests/eap-teap-mschapv2.conf freeradius-server-3.2.7/src/tests/eap-teap-mschapv2.conf
--- freeradius-server-3.2.6/src/tests/eap-teap-mschapv2.conf	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/eap-teap-mschapv2.conf	1970-01-01 07:00:00.000000000 +0700
@@ -1,21 +0,0 @@
-#
-#   eapol_test -c eap-teap-mschapv2.conf -s testing123
-#
-network={
-        key_mgmt=IEEE8021X
-        eap=TEAP
-        anonymous_identity="anonymous"
-        identity="bob"
-        password="bob"
-
-#       openssl_ciphers="DEFAULT@SECLEVEL=1"
-#       phase1="tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=1 tls_disable_tlsv1_2=1 tls_disable_tlsv1_3=0"
-        phase2="autheap=MSCHAPV2"
-
-#       phase1="tls_disable_session_ticket=0 fast_provisioning=2"
-#       phase1="fast_provisioning=0"
-        pac_file="blob://eap-fast-pac"
-
-	ca_cert="../../raddb/certs/ca.pem"
-#        ca_cert="/etc/freeradius/certs/ca.pem"
-}
diff -urpN freeradius-server-3.2.6/src/tests/eap-teap-password.conf freeradius-server-3.2.7/src/tests/eap-teap-password.conf
--- freeradius-server-3.2.6/src/tests/eap-teap-password.conf	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/eap-teap-password.conf	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,17 @@
+#
+#   eapol_test -c eap-teap.conf -s testing123
+#
+network={
+	key_mgmt=IEEE8021X
+	eap=TEAP
+
+	anonymous_identity="anonymous"
+	phase1="teap_compat=freeradius,tls_disable_tlsv1_0=1,tls_disable_tlsv1_1=1"
+	ca_cert="../../raddb/certs/ca.pem"
+
+	#
+	#  User Credentials
+	#
+	identity="bob"
+	password="bob"
+}
diff -urpN freeradius-server-3.2.6/src/tests/map/map_unit.c freeradius-server-3.2.7/src/tests/map/map_unit.c
--- freeradius-server-3.2.6/src/tests/map/map_unit.c	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/map/map_unit.c	2025-01-31 18:42:21.000000000 +0700
@@ -1,7 +1,7 @@
 /*
  * radattr.c	Map debugging tool.
  *
- * Version:	$Id: af6d016a5ab83a1cbfbcbc084d95d81c8a1009c4 $
+ * Version:	$Id: 24f1a291b1bc194a03acc1be7cd782786c6ef1e0 $
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -20,7 +20,7 @@
  * Copyright 2015  Alan DeKok <aland@freeradius.org>
  */
 
-RCSID("$Id: af6d016a5ab83a1cbfbcbc084d95d81c8a1009c4 $")
+RCSID("$Id: 24f1a291b1bc194a03acc1be7cd782786c6ef1e0 $")
 
 #include <freeradius-devel/libradius.h>
 
@@ -54,6 +54,9 @@ pid_t rad_waitpid(pid_t pid, int *status
 }
 #endif
 
+/* Dummy config to allow linking to modcall */
+main_config_t main_config;
+
 rlm_rcode_t indexed_modcall(UNUSED rlm_components_t comp, UNUSED int idx, UNUSED REQUEST *request)
 {
 	return RLM_MODULE_OK;
diff -urpN freeradius-server-3.2.6/src/tests/tls/README.md freeradius-server-3.2.7/src/tests/tls/README.md
--- freeradius-server-3.2.6/src/tests/tls/README.md	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/tls/README.md	2025-01-31 18:42:21.000000000 +0700
@@ -38,3 +38,8 @@ You can also send accounting packets:
 ./radacct.sh
 ```
 
+Try many many TLS connections:
+
+```
+./stress.py
+```
diff -urpN freeradius-server-3.2.6/src/tests/tls/home/radiusd.conf freeradius-server-3.2.7/src/tests/tls/home/radiusd.conf
--- freeradius-server-3.2.6/src/tests/tls/home/radiusd.conf	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/tls/home/radiusd.conf	2025-01-31 18:42:21.000000000 +0700
@@ -23,6 +23,10 @@ thread pool {
 	auto_limit_acct = no
 }
 
+security {
+	reject_delay = 1.0
+}
+
 #
 #  Referenced by some modules for default thread pool configuration
 #
@@ -32,7 +36,7 @@ $INCLUDE ${raddb}/mods-available/always
 }
 
 clients radsec {
-	client home {
+	client proxy {
 		ipaddr = 127.0.0.1
 		proto = tls
 	}
@@ -47,6 +51,8 @@ listen {
 
 	clients = radsec
 
+	check_client_connections = yes
+
 	virtual_server = default
 
 	tls {
@@ -88,9 +94,17 @@ listen {
 
 server default {
 	authorize {
+		if (&User-Name != &User-Password) {
+			reject
+		}
+
 		update control {
 			Auth-Type := accept
 		}
+
+		Autz-Type New-TLS-Connection {
+			ok
+		}
 	}
 
 	preacct {
diff -urpN freeradius-server-3.2.6/src/tests/tls/radclient-reject.sh freeradius-server-3.2.7/src/tests/tls/radclient-reject.sh
--- freeradius-server-3.2.6/src/tests/tls/radclient-reject.sh	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/tls/radclient-reject.sh	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,7 @@
+#!/bin/sh
+. $(dirname $0)/common.sh
+
+#
+#  Run radclient auth
+#
+exec $DIR/build/make/jlibtool --mode=execute $FR_DEBUGGER $DIR/build/bin/local/radclient -d $(dirname $0)/home -D $DIR/share/ -f reject_password $@ localhost:${FR_LOCAL_PREFIX}1812 auth testing123
diff -urpN freeradius-server-3.2.6/src/tests/tls/radsecproxy.conf freeradius-server-3.2.7/src/tests/tls/radsecproxy.conf
--- freeradius-server-3.2.6/src/tests/tls/radsecproxy.conf	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/tls/radsecproxy.conf	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,84 @@
+# Minimal sample radsecproxy config
+#
+# Intended for use with radsecproxy > 1.11.1 for TLS PSK
+#
+# Checkout source from https://github.com/radsecproxy/radsecproxy
+# Then build with
+#   sh autogen.sh
+#   ./configure
+#   make
+
+# By default, the config file is expected to be in
+# /usr/local/etc/radsecproxy.conf
+
+# radsecproxy can be run with maximum debug and in the foreground with
+#
+# ./radsecproxy -f -d 5
+
+# Set some non-standard ports so radsecproxy can run
+# on the same host as FreeRADIUS
+ListenUDP	*:1814
+ListenTLS	*:2084
+
+#
+# To test interoperability with FreeRADIUS, both should use
+# the same certificates - either copy certificates from
+# raddb to the paths below, or adjust the paths to point
+# to certificates in raddb
+#
+tls default {
+  # Trust file / path for verifying peer
+  CACertificateFile  /usr/local/etc/cacerts/ca.pem
+  CACertificatePath  /usr/local/etc/cacerts
+
+  # Certificate presented by radsecproxy
+  CertificateFile     /usr/local/etc/hostcertkey/client.pem
+  CertificateKeyFile  /usr/local/etc/hostcertkey/client.key
+  CertificateKeyPassword    "whatever"
+}
+
+# "client" entries - where do we accept requests from
+# Add extra as required
+
+# Normal RADIUS over UDP
+client 127.0.0.1 {
+	type	udp
+	secret	testing123
+}
+
+# RadSec
+client 127.0.0.1 {
+	type	tls
+	secret	radsec
+	CertificateNameCheck off
+# If TLS-PSK is needed
+# Note: the pskkey is in ASCII, but non-printable
+# characters can be represented in %xx format, where
+# xx is the hex representation of the character.
+#	pskidentity	clientidentity
+#	pskkey		verysecretpresharedkey
+}
+
+# "server" entries - where do we send packets
+
+# Note: RadSec connections are created immediately
+server 127.0.0.1 {
+	type	tls
+	secret	radsec
+	CertificateNameCheck off
+#	pskidentity	radsecidentity
+#	pskkey		othertopsecretkey
+}
+
+# "realm" entries - determine how requests should be routed
+
+# Send @example.com authentication to the RadSec home server above
+realm example.com {
+	server 127.0.0.1
+}
+
+# Reject other users
+realm * {
+	replymessage "User unkown"
+}
+
diff -urpN freeradius-server-3.2.6/src/tests/tls/reject_password freeradius-server-3.2.7/src/tests/tls/reject_password
--- freeradius-server-3.2.6/src/tests/tls/reject_password	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/tls/reject_password	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,3 @@
+User-Name = "bob"
+User-Password = "REJECT_ME"
+Message-Authenticator = 0x00
diff -urpN freeradius-server-3.2.6/src/tests/tls/stress.py freeradius-server-3.2.7/src/tests/tls/stress.py
--- freeradius-server-3.2.6/src/tests/tls/stress.py	1970-01-01 07:00:00.000000000 +0700
+++ freeradius-server-3.2.7/src/tests/tls/stress.py	2025-01-31 18:42:21.000000000 +0700
@@ -0,0 +1,57 @@
+#!/usr/bin/env python3
+import multiprocessing
+import time
+import socket
+import ssl
+import logging
+
+class SSLClient:
+    def __init__(self, ip, client_cert_file_location, trusted_cas_file_location):
+        self.client_cert_file_location = client_cert_file_location
+        self.trusted_cas_file_location = trusted_cas_file_location
+        self.socket: ssl.SSLSocket = self.connect_to_server(ip, 2083, self.client_cert_file_location, self.trusted_cas_file_location)
+
+
+    def connect_to_server(self, ip, port, client_cert_file, ca_file_location): 
+        try:
+            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
+            context.verify_mode = ssl.CERT_REQUIRED
+            context.load_cert_chain(certfile=client_cert_file, password='whatever')
+
+            context.load_verify_locations(cafile=ca_file_location)
+            context.check_hostname = False
+            sock = context.wrap_socket(sock, server_hostname=ip)
+            
+            connection =  sock.connect((ip, int(port)))  
+            return sock
+            
+        except Exception as e:
+            logging.error(f'Radius tcp monitor: RADIUS server {ip} is DOWN. err: ' + str(e))
+            return None
+
+
+def send_stuff(x):
+    try:
+        test = SSLClient('127.0.0.1', '../../../raddb/certs/client.pem', '../../../raddb/certs/ca.pem')
+
+        test.socket.send(b'asdlkfjasldkfj')
+        test.socket.shutdown(socket.SHUT_WR)
+        test.socket.recv(1024)
+        test.socket.close()
+    except Exception as e: 
+        print('error while sending things')
+    finally:
+        try:
+            test.socket.close()
+        except: 
+            pass
+
+
+
+
+if __name__ == '__main__':
+    with multiprocessing.Pool(16) as p: 
+        while True:
+            p.map(send_stuff, range(400))
+            time.sleep(1)
diff -urpN freeradius-server-3.2.6/suse/freeradius.spec freeradius-server-3.2.7/suse/freeradius.spec
--- freeradius-server-3.2.6/suse/freeradius.spec	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/suse/freeradius.spec	2025-01-31 18:42:21.000000000 +0700
@@ -1,5 +1,5 @@
 Name:         freeradius-server
-Version:      3.2.6
+Version:      3.2.7
 Release:      0
 License:      GPLv2 ; LGPLv2.1
 Group:        Productivity/Networking/Radius/Servers
diff -urpN freeradius-server-3.2.6/suse/radiusd-logrotate freeradius-server-3.2.7/suse/radiusd-logrotate
--- freeradius-server-3.2.6/suse/radiusd-logrotate	2024-08-24 20:06:25.000000000 +0700
+++ freeradius-server-3.2.7/suse/radiusd-logrotate	2025-01-31 18:42:21.000000000 +0700
@@ -47,9 +47,9 @@
 #  to write to a single detail file per IP and use the rotate config
 #  below.  Another is to write to a daily detail file per IP with:
 #
-#     detailfile = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
+#     filename = ${radacctdir}/%{Client-IP-Address}/%Y%m%d-detail
 #
-#  (or similar) in radiusd.conf, without rotation.  If you go with the
+#  (or similar) in mods-enabled/detail, without rotation.  If you go with the
 #  second technique, you will need another cron job that removes old
 #  detail files.  You do not need to comment out the below for method #2.
 #
