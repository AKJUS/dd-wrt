Index: ndpi_api.h
===================================================================
--- ndpi_api.h	(revision 53718)
+++ ndpi_api.h	(working copy)
@@ -736,7 +736,7 @@
    *
    * @par  ndpi_mod = the detection module
    */
-NDPI_STATIC   void ndpi_dump_protocols(struct ndpi_detection_module_struct *mod);
+NDPI_STATIC void ndpi_dump_protocols(struct ndpi_detection_module_struct *mod, FILE *dump_out);
 
   /**
    * Generate Options list used in OPNsense firewall plugin
@@ -743,7 +743,7 @@
    *
    * @par  opt = The Option list to generate
    */
-NDPI_STATIC   void ndpi_generate_options(u_int opt);
+NDPI_STATIC void ndpi_generate_options(u_int opt, FILE *dump_out);
 
   /**
    * Write the list of the scores and their associated risks
@@ -750,7 +750,7 @@
    *
    * @par  ndpi_mod = the detection module
    */
-NDPI_STATIC   void ndpi_dump_risks_score(void);
+NDPI_STATIC void ndpi_dump_risks_score(FILE *dump_out);
 
   /**
    * Read a file and load the protocols
@@ -770,7 +770,7 @@
 NDPI_STATIC   int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_mod,
 			       const char* path);
 
-NDPI_STATIC ndpi_load_protocols_file2(struct ndpi_detection_module_struct *ndpi_mod,
+NDPI_STATIC int ndpi_load_protocols_file2(struct ndpi_detection_module_struct *ndpi_mod,
 			        FILE *fd);
 #endif
 
@@ -827,7 +827,7 @@
    */
   int ndpi_load_category_file(struct ndpi_detection_module_struct *ndpi_str,
 			      char* path, ndpi_protocol_category_t category_id);
-  
+
   /**
    * Load files (whose name is <categoryid>_<label>.<extension>) stored
    * in a directory and bind each domain to the specified category.
@@ -1221,8 +1221,6 @@
 #endif
 
   NDPI_STATIC char *ndpi_get_ip_proto_name(u_int16_t ip_proto, char *name, unsigned int name_len);
-  NDPI_STATIC void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]);
-  NDPI_STATIC u_int32_t ndpi_quick_hash(unsigned char *str, u_int str_len);
 
   NDPI_STATIC const char* ndpi_http_method2str(ndpi_http_method m);
   NDPI_STATIC ndpi_http_method ndpi_http_str2method(const char* method, u_int16_t method_len);
@@ -1817,10 +1815,22 @@
 
   /* ******************************* */
 
+  NDPI_STATIC void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]);
   NDPI_STATIC u_int32_t ndpi_crc32(const void* data, size_t n_bytes);
   NDPI_STATIC u_int32_t ndpi_nearest_power_of_two(u_int32_t x);
 
+  NDPI_STATIC u_int32_t ndpi_crc32(const void* data, size_t n_bytes);
+  NDPI_STATIC u_int32_t ndpi_nearest_power_of_two(u_int32_t x);
+
   /* ******************************* */
+
+  NDPI_STATIC u_int64_t ndpi_quick_hash64(const char *str, u_int str_len);
+  NDPI_STATIC u_int32_t ndpi_hash_string(const char *str);
+  NDPI_STATIC u_int32_t ndpi_rev_hash_string(const char *str);
+  NDPI_STATIC u_int32_t ndpi_hash_string_len(const char *str, u_int len);
+  NDPI_STATIC u_int32_t ndpi_murmur_hash(const char *str, u_int str_len);
+
+  /* ******************************* */
   NDPI_STATIC int ndpi_des_init(struct ndpi_des_struct *des, double alpha, double beta, float significance);
   NDPI_STATIC int ndpi_des_add_value(struct ndpi_des_struct *des, const double _value, double *forecast, double *confidence_band);
   NDPI_STATIC void ndpi_des_fitting(double *values, u_int32_t num_values, float *ret_alpha, float *ret_beta);
@@ -1851,6 +1861,7 @@
                             ndpi_confidence_t confidence,
                             ndpi_protocol l7_protocol);
 #endif /* KERNEL */
+  NDPI_STATIC u_int32_t ndpi_quick_hash(const unsigned char *str, u_int str_len);
   NDPI_STATIC const char* ndpi_risk2str(ndpi_risk_enum risk);
   NDPI_STATIC const char* ndpi_severity2str(ndpi_risk_severity s);
   NDPI_STATIC ndpi_risk_info* ndpi_risk2severity(ndpi_risk_enum risk);
@@ -2051,11 +2062,51 @@
   NDPI_STATIC void ndpi_bitmap_iterator_free(ndpi_bitmap* b);
   NDPI_STATIC bool ndpi_bitmap_iterator_next(ndpi_bitmap_iterator* i, u_int32_t *value);
   /* ******************************* */
+
   /*
-    Bloom-filter on steroids based on ndpi_bitmap
+    Bitmap with 64 bit values based
+    on https://github.com/FastFilter/xor_singleheader/tree/master
+
+    This is
+    - a probabilistic datastructure !!! (i.e. be prepared to false positives)
+    - immutable (i.e. adding keys after a search (i.e. ndpi_bitmap64_isset)
+      is not allowed
+   */
+
+  NDPI_STATIC ndpi_bitmap64* ndpi_bitmap64_alloc(void);
+  NDPI_STATIC bool ndpi_bitmap64_set(ndpi_bitmap64 *b, u_int64_t value);
+  NDPI_STATIC bool ndpi_bitmap64_compress(ndpi_bitmap64 *b);
+  NDPI_STATIC bool ndpi_bitmap64_isset(ndpi_bitmap64 *b, u_int64_t value);
+  NDPI_STATIC void ndpi_bitmap64_free(ndpi_bitmap64 *b);
+  NDPI_STATIC u_int32_t ndpi_bitmap64_size(ndpi_bitmap64 *b);
+
+  /* ******************************* */
+
+  /*
+ Bloom-filter on steroids based on ndpi_bitmap
+
+    The main difference with respect to bloom filters
+    is that here the filter cardinality is 2^32 and thus
+    not limited as in blooms. This combined with compression
+    of ndpi_bitmap creates a memory savvy datastructure at the
+    price of little performance penalty due to using a
+    compressed datastucture.
+
+    The result is a datatructure with few false positives
+    (see https://hur.st/bloomfilter/) computed as
+
+    p = (1 - e(-((k * n)/m)))^k
+
+    number of hash function (k)
+    false positive rate (p)
+    number of item (n)
+    the number of bits (m)
+
+    As in our case m = 2^32, k = 1, for n = 1000000
+    (see https://hur.st/bloomfilter/?n=1000000&p=&m=4294967296&k=1)
+    p = 2.3 x 10^-4
   */
-
-  NDPI_STATIC ndpi_filter* ndpi_filter_alloc();
+  NDPI_STATIC ndpi_filter* ndpi_filter_alloc(void);
   NDPI_STATIC bool         ndpi_filter_add(ndpi_filter *f, u_int32_t value); /* returns true on success, false on failure */
   NDPI_STATIC bool         ndpi_filter_add_string(ndpi_filter *f, char *string); /* returns true on success, false on failure */
   NDPI_STATIC bool         ndpi_filter_contains(ndpi_filter *f, u_int32_t value); /* returns true on success, false on failure */
@@ -2063,20 +2114,6 @@
   NDPI_STATIC void         ndpi_filter_free(ndpi_filter *f);
   NDPI_STATIC size_t       ndpi_filter_size(ndpi_filter *f);
   NDPI_STATIC u_int32_t    ndpi_filter_cardinality(ndpi_filter *f);
-  
-  /* ******************************* */
- 
-  /*
-    Efficient (space and speed) probabilitic datastructure
-    for exact string searching with a false positive rate
-    of 5 * 10 ^ -8
-  */
-  NDPI_STATIC ndpi_string_search* ndpi_string_search_alloc();
-  NDPI_STATIC void                ndpi_string_search_free(ndpi_string_search *s);
-  NDPI_STATIC u_int32_t           ndpi_string_search_size(ndpi_string_search *s);
-  NDPI_STATIC bool                ndpi_string_search_add(ndpi_string_search *s, char *string);
-  NDPI_STATIC bool                ndpi_string_search_contains(ndpi_string_search *s, char *string);
-  NDPI_STATIC u_int32_t           ndpi_string_search_cardinality(ndpi_string_search *f);
 
   /* ******************************* */
 
@@ -2085,19 +2122,40 @@
     for substring domain matching and classification
   */
 
-  NDPI_STATIC ndpi_domain_classify* ndpi_domain_classify_alloc();
+  NDPI_STATIC ndpi_domain_classify* ndpi_domain_classify_alloc(void);
   NDPI_STATIC void                  ndpi_domain_classify_free(ndpi_domain_classify *s);
   NDPI_STATIC u_int32_t             ndpi_domain_classify_size(ndpi_domain_classify *s);
   NDPI_STATIC bool                  ndpi_domain_classify_add(ndpi_domain_classify *s,
-						 u_int16_t classification_id, char *domain);
+						 u_int8_t class_id, const char *domain);
+  NDPI_STATIC u_int32_t             ndpi_domain_classify_add_domains(ndpi_domain_classify *s,
+							 u_int8_t class_id,
   NDPI_STATIC u_int32_t             ndpi_domain_classify_add_domains(ndpi_domain_classify *_s,
 							 u_int16_t classification_id,
 							 char *file_path);
-  NDPI_STATIC u_int16_t             ndpi_domain_classify_contains(ndpi_domain_classify *s, char *domain);
 
+  NDPI_STATIC bool                  ndpi_domain_classify_finalize(ndpi_domain_classify *s);
+  NDPI_STATIC bool                  ndpi_domain_classify_contains(ndpi_domain_classify *s,
+						      u_int8_t *class_id /* out */,
+						      const char *domain);
 
   /* ******************************* */
 
+  /*
+    Similar to ndpi_filter but based on binary search and with the
+    ability to store a category per value (as ndpi_domain_classify)
+  */
+  NDPI_STATIC ndpi_binary_bitmap* ndpi_binary_bitmap_alloc(void);
+  NDPI_STATIC bool ndpi_binary_bitmap_set(ndpi_binary_bitmap *b, u_int64_t value, u_int8_t category);
+  NDPI_STATIC bool ndpi_binary_bitmap_compress(ndpi_binary_bitmap *b);
+  NDPI_STATIC bool ndpi_binary_bitmap_isset(ndpi_binary_bitmap *b, u_int64_t value, u_int8_t *out_category);
+  NDPI_STATIC void ndpi_binary_bitmap_free(ndpi_binary_bitmap *b);
+  NDPI_STATIC u_int32_t ndpi_binary_bitmap_size(ndpi_binary_bitmap *b);
+  NDPI_STATIC u_int32_t ndpi_binary_bitmap_cardinality(ndpi_binary_bitmap *b);
+
+  /* ******************************* */
+
+  /* ******************************* */
+
   NDPI_STATIC char* ndpi_get_flow_risk_info(struct ndpi_flow_struct *flow,
 				char *out, u_int out_len,
 				u_int8_t use_json);
Index: ndpi_define.h.in
===================================================================
--- ndpi_define.h.in	(revision 53718)
+++ ndpi_define.h.in	(working copy)
@@ -326,9 +326,10 @@
 #define get_u_int16_t(X,O)  (*(u_int16_t *)((&(((u_int8_t *)X)[O]))))
 #define get_u_int32_t(X,O)  (*(u_int32_t *)((&(((u_int8_t *)X)[O]))))
 #if defined(__arm__)
-static inline u_int64_t get_u_int64_t(const u_int8_t* X, int O)
+#include <stdint.h>
+static inline uint64_t get_u_int64_t(const uint8_t* X, int O)
 {
-  u_int64_t tmp;
+  uint64_t tmp;
   memcpy(&tmp, X + O, sizeof(tmp));
   return tmp;
 }
@@ -410,33 +411,103 @@
 
 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 
+#ifndef htobe16
 #define htobe16(x) htons(x)
+#endif
+
+#ifndef htole16
 #define htole16(x) (x)
+#endif
+
+#ifndef be16toh
 #define be16toh(x) ntohs(x)
+#endif
+
+#ifndef le16toh
 #define le16toh(x) (x)
+#endif
+
+#ifndef htobe32
 #define htobe32(x) htonl(x)
+#endif
+
+#ifndef htole32
 #define htole32(x) (x)
+#endif
+
+#ifndef be32toh
 #define be32toh(x) ntohl(x)
+#endif
+
+#ifndef le32toh
 #define le32toh(x) (x)
+#endif
+
+#ifndef htobe64
 #define htobe64(x) ndpi_htonll(x)
+#endif
+
+#ifndef htole64
 #define htole64(x) (x)
+#endif
+
+#ifndef be64toh
 #define be64toh(x) ndpi_ntohll(x)
+#endif
+
+#ifndef le64toh
 #define le64toh(x) (x)
+#endif
 
 #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 
+#ifndef htobe16
 #define htobe16(x) (x)
+#endif
+
+#ifndef htole16
 #define htole16(x) __builtin_bswap16(x)
+#endif
+
+#ifndef be16toh
 #define be16toh(x) (x)
+#endif
+
+#ifndef le16toh
 #define le16toh(x) __builtin_bswap16(x)
+#endif
+
+#ifndef htobe32
 #define htobe32(x) (x)
+#endif
+
+#ifndef htole32
 #define htole32(x) __builtin_bswap32(x)
+#endif
+
+#ifndef be32toh
 #define be32toh(x) (x)
+#endif
+
+#ifndef le32toh
 #define le32toh(x) __builtin_bswap32(x)
+#endif
+
+#ifndef htobe64
 #define htobe64(x) (x)
+#endif
+
+#ifndef htole64
 #define htole64(x) __builtin_bswap64(x)
+#endif
+
+#ifndef be64toh
 #define be64toh(x) (x)
+#endif
+
+#ifndef le64toh
 #define le64toh(x) __builtin_bswap64(x)
+#endif
 
 #else
 #error Unexpected __BYTE_ORDER__
Index: ndpi_includes.h
===================================================================
--- ndpi_includes.h	(revision 53718)
+++ ndpi_includes.h	(working copy)
@@ -57,11 +57,14 @@
 #include <sys/param.h>
 #include <arpa/inet.h>
 #include <sys/time.h>
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
+#ifndef __APPLE__
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <netinet/udp.h>
+#endif
 
 #if !defined __APPLE__ && !defined __FreeBSD__ && !defined __NetBSD__ && !defined __OpenBSD__
 #include <endian.h>
Index: ndpi_patricia_typedefs.h
===================================================================
--- ndpi_patricia_typedefs.h	(revision 53718)
+++ ndpi_patricia_typedefs.h	(working copy)
@@ -64,6 +64,10 @@
 #ifndef _NDPI_PATRICIA_TYPEDEF_H_
 #define _NDPI_PATRICIA_TYPEDEF_H_
 
+#ifndef NDPI_CFFI_PREPROCESSING
+#include "ndpi_includes.h"
+#endif
+
 #define UV16_MAX_USER_VALUES  2
 
 struct patricia_uv16 {
Index: ndpi_protocol_ids.h
===================================================================
--- ndpi_protocol_ids.h	(revision 53718)
+++ ndpi_protocol_ids.h	(working copy)
@@ -368,7 +368,7 @@
 
   NDPI_PROTOCOL_FACEBOOK_REEL_STORY   = 337,
   NDPI_PROTOCOL_SRTP                  = 338,
-  NDPI_PROTOCOL_FREE                  = 339, /* Formerly used by gambling now a category. It can be reused in the future */
+  NDPI_PROTOCOL_OPERA_VPN             = 339,
   NDPI_PROTOCOL_EPICGAMES             = 340,
   NDPI_PROTOCOL_GEFORCENOW            = 341,
   NDPI_PROTOCOL_NVIDIA                = 342,
@@ -378,6 +378,8 @@
   NDPI_PROTOCOL_ROBLOX                = 346,
   NDPI_PROTOCOL_SERVICE_LOCATION      = 347,
   NDPI_PROTOCOL_MULLVAD               = 348,
+  NDPI_PROTOCOL_HTTP2                 = 349,
+  NDPI_PROTOCOL_HAPROXY               = 350,
 
 #ifdef CUSTOM_NDPI_PROTOCOLS
 #include "../../../nDPI-custom/custom_ndpi_protocol_ids.h"
Index: ndpi_protocols.h
===================================================================
--- ndpi_protocols.h	(revision 53718)
+++ ndpi_protocols.h	(working copy)
@@ -467,6 +467,8 @@
 NDPI_STATIC void init_bitcoin_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id);
 NDPI_STATIC void init_apache_thrift_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id);
 NDPI_STATIC void init_slp_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id);
+NDPI_STATIC void init_http2_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id);
+NDPI_STATIC void init_haproxy_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id);
 
 /* ndpi_main.c */
 NDPI_STATIC  u_int32_t ndpi_ip_port_hash_funct(u_int32_t ip, u_int16_t port);
Index: ndpi_typedefs.h
===================================================================
--- ndpi_typedefs.h	(revision 53718)
+++ ndpi_typedefs.h	(working copy)
@@ -1,5 +1,5 @@
 /*
- * ndpi_typedefs.h
+E * ndpi_typedefs.h
  *
  * Copyright (C) 2011-23 - ntop.org
  *
@@ -31,6 +31,9 @@
 #undef HAVE_HYPERSCAN
 #endif
 #include "ndpi_define.h"
+#ifndef NDPI_CFFI_PREPROCESSING
+#include "ndpi_includes.h"
+#endif
 #include "ndpi_protocol_ids.h"
 #include "ndpi_utils.h"
 
@@ -55,6 +58,12 @@
 #endif
 #endif /* __KERNEL__ */
 
+#ifdef __APPLE__
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+#endif
+
 /* NDPI_LOG_LEVEL */
 typedef enum {
 	      NDPI_LOG_ERROR,
@@ -143,7 +152,7 @@
   NDPI_DNS_LARGE_PACKET,
   NDPI_DNS_FRAGMENTED,
   NDPI_INVALID_CHARACTERS,
-  NDPI_POSSIBLE_EXPLOIT, /* Log4J, Wordpress and other exploits */
+  NDPI_POSSIBLE_EXPLOIT, /* 40 */ /* Log4J, Wordpress and other exploits */
   NDPI_TLS_CERTIFICATE_ABOUT_TO_EXPIRE,
   NDPI_PUNYCODE_IDN, /* https://en.wikipedia.org/wiki/Punycode */
   NDPI_ERROR_CODE_DETECTED,
@@ -157,7 +166,9 @@
   NDPI_MINOR_ISSUES,           /* Generic packet issues (e.g. DNS with 0 TTL) */
   NDPI_TCP_ISSUES,             /* 50 */ /* TCP issues such as connection failed, probing or scan */
   NDPI_FULLY_ENCRYPTED,        /* This (unknown) session is fully encrypted */
-
+  NDPI_TLS_ALPN_SNI_MISMATCH,  /* Invalid ALPN/SNI combination */
+  NDPI_MALWARE_HOST_CONTACTED, /* Flow client contacted a malware host */
+				 
   /* Leave this as last member */
   NDPI_MAX_RISK /* must be <= 63 due to (**) */
 } ndpi_risk_enum;
@@ -634,6 +645,19 @@
   unsigned char seen_flow_beginning;
 };
 
+/* Save memory limiting the key to 56 bit */
+//#define SAVE_BINARY_BITMAP_MEMORY
+
+PACK_ON
+struct ndpi_binary_bitmap_entry {
+#ifdef SAVE_BINARY_BITMAP_MEMORY
+  u_int64_t value:56, category:8;
+#else
+  u_int64_t value;
+  u_int8_t category;
+#endif
+} PACK_OFF;
+
 /* ******************* ********************* ****************** */
 /* ************************************************************ */
 
@@ -975,6 +999,10 @@
   /* NDPI_PROTOCOL_LINE_CALL */
   u_int8_t line_pkts[2];
   u_int8_t line_base_cnt[2];
+
+  /* NDPI_PROTOCOL_TFTP */
+  u_int16_t tftp_data_num;
+  u_int16_t tftp_ack_num;
 };
 
 /* ************************************************** */
@@ -1278,8 +1306,26 @@
 #define NUM_CUSTOM_CATEGORIES      5
 #define CUSTOM_CATEGORY_LABEL_LEN 32
 
-typedef void ndpi_domain_classify;
+typedef void ndpi_bitmap;
+typedef void ndpi_bitmap64;
+typedef void ndpi_bitmap_iterator;
+typedef void ndpi_filter;
+    
+typedef struct {
+  u_int32_t num_allocated_entries, num_used_entries;
+  struct ndpi_binary_bitmap_entry *entries;
+  bool is_compressed;
+} ndpi_binary_bitmap;
 
+#define MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS          16
+
+typedef struct {
+  struct {
+    u_int16_t class_id;
+    ndpi_bitmap64 *domains;
+  } classes[MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS];
+} ndpi_domain_classify;
+
 #ifdef NDPI_LIB_COMPILATION
 
 /* Needed to have access to HAVE_* defines */
@@ -1564,9 +1610,6 @@
   /* Some protocols calculate the entropy. */
   float entropy;
 
-  /* Place textual flow info here */
-  char flow_extra_info[16];
-
   /* General purpose field used to save mainly hostname/SNI information.
    * In details it used for: MGCP, COLLECTD, DNS, SSDP and NETBIOS name, HTTP, MUNIN and DHCP hostname,
    * WHOIS request, TLS/QUIC server name, XIAOMI domain and STUN realm.
@@ -1647,6 +1690,10 @@
     } softether;
 
     struct {
+      char currency[16];
+    } mining;  
+
+    struct {
       char *server_names, *advertised_alpns, *negotiated_alpn, *tls_supported_versions, *issuerDN, *subjectDN;
       u_int32_t notBefore, notAfter;
       char ja3_client[33], ja3_server[33];
@@ -1674,6 +1721,8 @@
       } encrypted_ch;
 
       ndpi_cipher_weakness server_unsafe_cipher;
+
+      u_int32_t quic_version;
     } tls_quic; /* Used also by DTLS and POPS/IMAPS/SMTPS/FTPS */
 
     struct {
@@ -1836,8 +1885,8 @@
 
 #if !defined(NDPI_CFFI_PREPROCESSING) && defined(__linux__)
 #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
-_Static_assert(sizeof(((struct ndpi_flow_struct *)0)->protos) <= 210,
-               "Size of the struct member protocols increased to more than 210 bytes, "
+_Static_assert(sizeof(((struct ndpi_flow_struct *)0)->protos) <= 216,
+               "Size of the struct member protocols increased to more than 216 bytes, "
                "please check if this change is necessary.");
 _Static_assert(sizeof(struct ndpi_flow_struct) <= 988,
                "Size of the flow struct increased to more than 988 bytes, "
@@ -2160,17 +2209,4 @@
 
 /* **************************************** */
 
-typedef void ndpi_bitmap;
-typedef void ndpi_bitmap_iterator;
-typedef void ndpi_filter;
-
-typedef struct {
-  ndpi_filter *filter[2 /* direct and reverse */];
-} ndpi_string_search;
-
-
-#define MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS  16
-
-/* **************************************** */
-
 #endif /* __NDPI_TYPEDEFS_H__ */
Index: ndpi_utils.h
===================================================================
--- ndpi_utils.h	(revision 53718)
+++ ndpi_utils.h	(working copy)
@@ -25,9 +25,14 @@
 #define __NDPI_UTILS_H__
 
 #include "ndpi_define.h"
+#ifndef NDPI_CFFI_PREPROCESSING
+#include "ndpi_includes.h"
+#endif
 
 #ifndef NDPI_CFFI_PREPROCESSING
-NDPI_STATIC u_int8_t ndpi_ends_with(char *str, char *ends);
+struct ndpi_detection_module_struct;
+NDPI_STATIC u_int8_t ndpi_ends_with(struct ndpi_detection_module_struct *ndpi_struct,
+                               char *str, char *ends);
 #endif // NDPI_CFFI_PREPROCESSING
 /* **************************************** */
 
